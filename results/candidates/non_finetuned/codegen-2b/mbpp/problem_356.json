{
  "problem": {
    "task_id": "MBPP/367",
    "prompt": "Write a function to check if a binary tree is balanced or not.",
    "canonical_solution": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False",
    "test_list": [
      "assert is_tree_balanced(root) == False",
      "assert is_tree_balanced(root1) == True",
      "assert is_tree_balanced(root2) == False "
    ],
    "challenge_test_list": [],
    "problem_id": 356
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        self.isBalanced(root.left, root.right)\n        return abs(self.getHeight(root.left) - self.getHeight(root.right)) < 1\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def height(node):\n            if node is None:\n                return 0\n            return max(height(node.left), height(node.right)) + 1\n\n        def isBalancedRecur(node, h):\n            if node is None:\n                return True\n            if h[0] - h[1] > 1:\n                return False\n            return isBalancedRecur(node.left, h) and isBalancedRecur(node.right, h)\n\n        h = [0, 0]\n        return isBalancedRecur(root, h)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n        \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return 1 + max(self.getHeight(root.left), self.getHeight(root.right))",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.left.right.left = TreeNode(7)\n    root.left.right.right = TreeNode(8)\n    root.right.right.left = TreeNode(9)\n    root.right.right.right = TreeNode(10)\n\n    s = Solution()\n    print(s.isBalanced(root))",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.isBalancedHelper(root, 0, 0)\n\n    def isBalancedHelper(self, node, height, maxHeight):\n        if not node:\n            return True\n        if height > maxHeight:\n            return False\n        return self.isBalancedHelper(node.left, height + 1, maxHeight) and self.isBalancedHelper(node.right, height + 1, maxHeight)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n    \n    def getHeight(self, node):\n        if node is None:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isBalanced(None)\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.isBalanced(TreeNode(1))\n    print s.is",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        self.preorder = []\n        self.inorder = []\n        self.level = []\n        self.visited = set()\n        self.dfs(root)\n        return len(self.level) > 0 and sum(self.level) == 0\n\n    def dfs(self, root):\n        if root is None:\n            return\n        if root.left is None and root.right is None:\n            self.level.append(len(self.inorder) - 1)\n            self.visited.add(root)\n            self.preorder.append(root.val)\n            return\n        if root.left is not None:\n            self.level.append(len(self.inorder) - 1)\n            self.visited.add(root)\n            self.dfs(root.left)\n        if root.right is not None:\n            self.level.append(len(self.inorder) - 1)\n            self.visited.add(root)\n            self.dfs(root.right)\n        self.level.append(len(self.inorder) - 1)\n        self.visited.add(root)\n        self.preorder.append(root.val)\n        self.inorder.append(root.val)\n\n\nclass Solution2:\n    def isBalanced(self, root: TreeNode) -> bool:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if not self.isBalanced(root.left) or not self.isBalanced(root.right):\n            return False\n        self.visited.add(root)\n        self.level.append(len(self.inorder) - 1)\n        self.dfs(root)\n        return len(self.level) > 0 and sum(self.level) == 0\n\n    def dfs",
    "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and self.height(root) == 2\n        \n    def height(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            return self.isBalanced(root.left) and self.isBalanced(root.right)\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.height(root.left) - self.height(root.right)) <= 1\n    \n    def height(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(9)\n    root.left.right = TreeNode(2)\n    root.left.left.left = TreeNode(1)\n    root.left.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    root.right.right.right = TreeNode(6)\n    root.right.right.right.left = TreeNode(10)\n    root.right.right.right.right = TreeNode(13)\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return True\n            if abs(node.left.val - node.right.val) > 1:\n                return False\n            return dfs(node.left) and dfs(node.right)\n        return dfs(root)\n\n# Note:\n# The given tree could be a binary tree or a non-binary tree.",
    "import sys\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\ndef is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None and root.right is not None:\n        return False\n    if root.right is None and root.left is not None:\n        return False\n    return is_balanced(root.left) and is_balanced(root.right)\n\n\ndef main():\n    node1 = TreeNode(1)\n    node2 = TreeNode(2)\n    node3 = TreeNode(3)\n    node4 = TreeNode(4)\n    node5 = TreeNode(5)\n    node6 = TreeNode(6)\n    node7 = TreeNode(7)\n    node8 = TreeNode(8)\n    node9 = TreeNode(9)\n    node10 = TreeNode(10)\n    node11 = TreeNode(11)\n    node12 = TreeNode(12)\n    node13 = TreeNode(13)\n    node14 = TreeNode(14)\n    node15 = TreeNode(15)\n    node16 = TreeNode(16)\n    node17 = TreeNode(17)\n    node18 = TreeNode(18)\n    node19 = TreeNode(19)\n    node20 = TreeNode(20)\n    node21 = TreeNode(21)\n    node22 = TreeNode(22)\n    node23 = TreeNode(23)\n    node24 = TreeNode(24)\n    node25 = TreeNode(25)\n    node26 = TreeNode(26)\n    node27 = TreeNode(27)\n    node28 = TreeNode(28)\n    node29 = TreeNode(29)\n    node30 = TreeNode(30)\n    node31 = TreeNode(31)\n    node32 = TreeNode(32)\n    node33 = TreeNode(33)\n    node34 = TreeNode(34)\n    node35 = Tree",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if abs(left - right) > 1:\n            return False\n        return self.isBalanced(root.right)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\nif __name__ == \"__main__\":\n    print Solution().isBalanced(None)\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)",
    "from collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n\n        def dfs(node):\n            if not node:\n                return True\n\n            if not dfs(node.left):\n                return False\n            if not dfs(node.right):\n                return False\n            return abs(self.height(node.left) - self.height(node.right)) <= 1\n\n        return dfs(root)\n\n    def height(self, node):\n        if not node:\n            return 0\n        return max(self.height(node.left), self.height(node.right)) + 1\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n\n    print(Solution().isBalanced(root))",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root == None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    def getHeight(self, root):\n        if root == None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.isBalanced(TreeNode(1))",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self.rec(root) > -1\n\n    def rec(self, root):\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        if root.left is None and root.right is not None:\n            return 1 + self.rec(root.right)\n        if root.left is not None and root.right is None:\n            return 1 + self.rec(root.left)\n        if root.left is None and root.right is not None:\n            return 1 + self.rec(root.right)\n        if abs(self.rec(root.left) - self.rec(root.right)) > 1:\n            return -1\n        return max(self.rec(root.left), self.rec(root.right))\n\n\nif __name__ == '__main__':\n    t = TreeNode(1)\n    t.left = TreeNode(2)\n    t.right = TreeNode(3)\n    t.left.left = TreeNode(4)\n    t.left.right = TreeNode(5)\n    t.right.left = TreeNode(6)\n    t.right.right = TreeNode(7)\n    s = Solution()\n    print s.isBalanced(t)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.height(root.left)) - abs(self.height(root.right)) <= 1\n    def height(self, root):\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        height_left = self.getHeight(root.left)\n        height_right = self.getHeight(root.right)\n        if abs(height_left - height_right) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n# TESTS\nfor root, expected in [\n    ([None], True),\n    ([None, None], True),\n    ([None, None, None], True),\n    ([None, None, None, None], True),\n    ([None, None, None, None, None], True),\n    ([None, None, None, None, None, None], True),\n    ([None, None, None, None, None, None, None], True),\n    ([None, None, None, None, None, None, None, None], True),\n    ([None, None, None, None, None, None, None, None, None], True),\n    ([1], False),\n    ([1, 1], False),\n    ([1, 1, 1], False),\n    ([1, 1, 1, 1], False),\n    ([1, 1, 1, 1, 1], False),\n    ([1, 1, 1, 1, 1, 1], False),\n    ([1, 1, 1, 1, 1, 1, 1], False),\n    ([1, 1, 1, 1, 1, 1, 1, 1, 1], False),\n]:\n    root = TreeNode.deserialize(root)\n    actual = Solution().isBalanced(root)\n    print(\"The tree is\", root, \"->\", actual)\n    assert actual == expected",
    "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return self.helper(root)\n\n    def helper(self, root):\n        if not root:\n            return True\n        l = self.helper(root.left)\n        r = self.helper(root.right)\n        if abs(l - r) > 1:\n            return False\n        return abs(l - r) == 1 and self.helper(root.right) or self.helper(root.left)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n        return False\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.right.right.left = TreeNode(10)\n    root.right.right.right = TreeNode(11)\n\n    print(Solution().isBalanced(root))",
    "from tree_node import TreeNode\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n\n        # check left subtree\n        if not self.isBalanced(root.left):\n            return False\n        # check right subtree\n        if not self.isBalanced(root.right):\n            return False\n        # check height\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        # check balance\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) == 1:\n            return abs(self.getHeight(root.left) - self.getHeight(root.right)) == 1\n        return True\n\n    def getHeight(self, node):\n        if not node:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1\n\n\nif __name__ == '__main__':\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left, root.right) and self.isBalanced(root.right, root.left)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: True if the tree is balanced, or false\n    \"\"\"\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n        return False\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == '__main__':\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n# Note:\n# Given a tree, you need to determine whether the tree is height-balanced or not.\n#\n# Here are some tips to help you solve the problem:\n#\n# 1. A balanced tree is defined as a tree such that the heights of the left and right subtrees of every node are equal.\n# 2. The height of a tree is the maximum height of any node in the tree.\n# 3. The height of a tree is also the maximum depth of any node in the tree.\n# 4. A tree is balanced if the height of the left and right subtrees of every node are equal.\n# 5. A balanced tree is also a binary tree.\n#\n# Example:\n#\n# Given the following binary tree:\n#\n#         1\n#       /   \\\n#      2     3\n#     /  \\   / \\\n#    4    5  6   7\n#\n# The height of the tree is 6.\n#\n# The height of the left subtree is 2, the height of the right subtree is 2.\n# Therefore the height of the whole tree is 6.\n#\n# Note:\n# You may assume the sum of height of all the nodes in the tree won't exceed 1000.",
    "import sys\nfrom collections import deque\n\ndef is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    def helper(root):\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            if root.left.val == root.right.val:\n                return helper(root.left) and helper(root.right)\n            else:\n                return helper(root.left) and helper(root.right) and helper(root) and root.val == root.left.val + root.right.val\n        else:\n            return helper(root.left) and helper(root.right)\n    return helper(root)\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if is_balanced(root) is True:\n            return True\n        else:\n            return False\n\nif __name__ == '__main__':\n    tree = TreeNode(1)\n    tree.left = TreeNode(2)\n    tree.right = TreeNode(3)\n    tree.left.left = TreeNode(4)\n    tree.left.right = TreeNode(5)\n    tree.right.left = TreeNode(6)\n    tree.right.right = TreeNode(7)\n    solution = Solution()\n    print(solution.isBalanced(tree))",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getDepth(root.left) - self.getDepth(root.right)) < 2\n    \n    def getDepth(self, root):\n        if root is None:\n            return 0\n        return max(self.getDepth(root.left), self.getDepth(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.helper(root)\n\n    def helper(self, root):\n        if root is None:\n            return True\n        if abs(root.val) > abs(root.left.val) + abs(root.right.val):\n            return False\n        if abs(root.left.val) > abs(root.right.val):\n            return self.helper(root.left) and self.helper(root.right)\n        return self.helper(root.left) and self.helper(root.right) and abs(root.left.val) == abs(root.right.val)",
    "\"\"\"\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if self.isBalanced(root.left) and self.isBalanced(root.right):\n            return True if abs(self.height(root.left) - self.height(root.right)) <= 1 else False\n        else:\n            return False\n\n    def height(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        else:\n            return max(self.height(root.left), self.height(root.right)) + 1\n\n\n# TESTS\nfor root, expected in [\n    ([1], True),\n    ([1, 2], False),\n    ([1, 2, 3, 4, 5], True),\n    ([1, 2, 3, 4, 5, 6], False),\n]:\n    sol = Solution()\n    actual = sol.isBalanced(TreeNode(root))\n    print(\"isBalanced({}) = {}, expected = {}\".format(root, actual, expected))\n    assert actual == expected",
    "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if abs(left - right) > 1:\n            return False\n        return True",
    "from collections import deque\n\ndef is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    # Recursive\n    # return is_balanced_recursive(root) or is_balanced_recursive(root.left) or is_balanced_recursive(root.right)\n\n    # Iterative\n    stack = deque()\n    stack.append(root)\n    while len(stack) > 0:\n        current = stack.pop()\n        if current.val == 0:\n            return True\n        elif current.val == -1:\n            return False\n        else:\n            stack.append(current.left)\n            stack.append(current.right)\n\n    return True\n\ndef is_balanced_recursive(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n\n    if root.left is None and root.right is None:\n        return True\n\n    if root.left is not None and root.right is not None:\n        if root.left.val == root.right.val:\n            return is_balanced_recursive(root.left) and is_balanced_recursive(root.right)\n        else:\n            return False\n\n    return is_balanced_recursive(root.left) and is_balanced_recursive(root.right)\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.right = TreeNode(10)\n    root.left.right.left = TreeNode(11)\n    root.left.right.right.left = TreeNode(12)\n    root.left.right.right.right = TreeNode",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left, root.right) and self.isBalanced(root.right, root.left)",
    "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param root, a tree node\n\t# @return a boolean\n\tdef isBalanced(self, root):\n\t\tif root is None:\n\t\t\treturn True\n\t\tif abs(self.height(root.left) - self.height(root.right)) > 1:\n\t\t\treturn False\n\t\treturn self.isBalanced(root.left) and self.isBalanced(root.right)\n\t\t\n\t# get the height of the left subtree of a node\n\tdef height(self, root):\n\t\tif root is None:\n\t\t\treturn 0\n\t\treturn max(self.height(root.left), self.height(root.right)) + 1\n\nclass Solution2:\n\t# @param root, a tree node\n\t# @return a boolean\n\tdef isBalanced(self, root):\n\t\tif root is None:\n\t\t\treturn True\n\t\tif abs(self.height(root.left) - self.height(root.right)) > 1:\n\t\t\treturn False\n\t\treturn self.isBalanced(root.left) and self.isBalanced(root.right)\n\t\t\n\t# get the height of the left subtree of a node\n\tdef height(self, root):\n\t\tif root is None:\n\t\t\treturn 0\n\t\treturn max(self.height(root.left), self.height(root.right)) + 1\n\nif __name__ == '__main__':\n\ts = Solution()\n\troot = TreeNode(1)\n\troot.left = TreeNode(2)\n\troot.right = TreeNode(3)\n\troot.right.left = TreeNode(4)\n\troot.right.right = TreeNode(5)\n\tprint s.isBalanced(root)\n\t\n\ts = Solution2()\n\troot = TreeNode(1)\n\troot.left = TreeNode(2)\n\troot.right = TreeNode(3)\n\troot.right.left = TreeNode(4)\n\troot.right.right = TreeNode(5)",
    "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        else:\n            return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left)) == abs(self.getHeight(root.right))\n        \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\nif __name__ == \"__main__\":\n    print Solution().isBalanced(None)\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if left is False or right is False:\n            return False\n        return abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isBalanced_recursion(root):\n            if root is None:\n                return True\n            left = isBalanced_recursion(root.left)\n            right = isBalanced_recursion(root.right)\n            if abs(left - right) > 1:\n                return False\n            if left < 0 or right < 0:\n                return False\n            return True\n\n        return isBalanced_recursion(root)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: True if the tree is balanced, or false\n    \"\"\"\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left)-self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    def getHeight(self, node):\n        if node is None:\n            return 0\n        return 1 + max(self.getHeight(node.left), self.getHeight(node.right))\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.isBalanced(None)\n    print solution.isBalanced([1])\n    print solution.isBalanced([1,2])\n    print solution.isBalanced([1,2,3,4,5])\n    print solution.isBalanced([1,2,3,4,5,6,7])\n    print solution.isBalanced([1,2,3,4,5,6,7,8])",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if abs(left - right) > 1:\n            return False\n        return abs(left - right) <= 1 and self.isBalanced(root.right) and self.isBalanced(root.left)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        \"\"\"\n        DFS\n        :param root: root node\n        :return: True if tree is balanced, False otherwise\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return True\n            if not node.left and not node.right:\n                return True\n            if not node.left and not node.right:\n                return True\n            if abs(node.left.val - node.right.val) > 1:\n                return False\n            if not dfs(node.left) or not dfs(node.right):\n                return False\n            return True\n\n        return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print(Solution().isBalanced(root))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not self.isBalanced(root.left) or not self.isBalanced(root.right):\n            return False\n        return abs(self.getHeight(root.left) - self.getHeight(root.right)) < 1\n    \n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n# Test cases\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    print Solution().isBalanced(root)\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def check(node):\n            if node is None:\n                return True\n            if abs(node.left.val - node.right.val) > 1:\n                return False\n            return check(node.left) and check(node.right)\n        return check(root)",
    "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        self.depth = self.helper(root)\n        return self.depth >= 0\n\n    def helper(self, root):\n        if root == None:\n            return 0\n        left = self.helper(root.left)\n        right = self.helper(root.right)\n        if left < 0 or right < 0:\n            return -1\n        return abs(left - right)",
    "import unittest\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/balanced-binary-tree/solution/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\n\n// Approach #1: Recursive [Accepted]\n// time:O(n)\n// space:O(n)\n// score:65.22%\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        int leftHeight = getHeight(root.left);\n        int rightHeight = getHeight(root.right);\n        if (leftHeight < 0 || rightHeight < 0) {",
    "import unittest\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        if left == False or right == False:\n            return False\n        return True\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\nThe idea is to use the height function to check the balance of the tree.\n\nThe height function returns the height of the tree. If the tree is balanced,\nthen the height of the tree is the same.\n\nThe height function can be called recursively. If the height of the left subtree\nis smaller than the height of the right subtree, then the height of the tree\nis also smaller.\n\nThe height function can be called recursively. If the height of the left subtree\nis larger than the height of the right subtree, then the height of the tree\nis also larger.\n\nThe height function can be called recursively. If the height of the left subtree\nis smaller than the height of the right subtree, then the height of the tree\nis also smaller.\n\nThe height function can be called recursively. If the height of the left subtree\nis larger than the height of the right subtree, then the height of the tree\nis also larger.\n\nThe height function can be called recursively. If the height of the left subtree\nis smaller than the height of the right subtree, then the height of the tree\nis also smaller.\n\nThe height function can be called recursively.",
    "from tree_node import TreeNode\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not root.left and not root.right:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and self.isBalanced(root.left) == self.isBalanced(root.right)\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print solution.isBalanced(root)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: True if the tree is balanced, or False\n    \"\"\"\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.left = TreeNode(7)\n\n    print solution.isBalanced(root)",
    "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root):\n    \"\"\"\n    :type root: Node\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n    \n    if root.left is None and root.right is None:\n        return True\n    \n    if (root.left is None or is_balanced(root.left)) and (root.right is None or is_balanced(root.right)):\n        return True\n    \n    return False\n\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n    root.left.right.left = Node(10)\n    root.right.left.left = Node(11)\n    root.right.right.left = Node(12)\n    root.right.right.right = Node(13)\n    root.left.left.left.left = Node(14)\n    root.left.left.left.right = Node(15)\n    root.left.left.right.left = Node(16)\n    root.left.right.left.left = Node(17)\n    root.left.right.right.left = Node(18)\n    root.right.left.left.left = Node(19)\n    root.right.left.right.left = Node(20)\n    root.right.right.left.left = Node(21)\n    root.right.right.right.left = Node(22)\n    root.right.right.right.left = Node(23)\n    root.right.right.right.right = Node(24)\n    root.left.left.left.left.",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def dfs(root):\n            if not root:\n                return True\n            if not root.left and not root.right:\n                return abs(root.val - dfs(root.right)) < 1e-9\n            return abs(root.val - dfs(root.left) - dfs(root.right)) < 1e-9\n        return dfs(root)",
    "class Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, node):\n        if node is None:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1\n\nif __name__ == \"__main__\":\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not root.left and not root.right:\n            return True\n        if not root.left and root.right:\n            return False\n        if not root.right and root.left:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if root is None:\n            return True\n        return self.helper(root)\n\n    def helper(self, root):\n        if root is None:\n            return True\n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        return self.helper(root.left) and self.helper(root.right)\n        \n    def height(self, root):\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n\n        height = self.getHeight(root)\n        if height == -1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(height - 1) <= 1\n    def getHeight(self, root):\n        if root is None:\n            return -1\n        height = 0\n        if root.left is not None:\n            height = max(height, self.getHeight(root.left))\n        if root.right is not None:\n            height = max(height, self.getHeight(root.right))\n        return height + 1\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        # write your code here\n        def isBalanced_aux(root):\n            if not root:\n                return True\n            return isBalanced_aux(root.left) and isBalanced_aux(root.right) and abs(root.left.val - root.right.val) <= 1\n        return isBalanced_aux(root)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    print(Solution().isBalanced(root))",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if abs(left - right) > 1:\n            return False\n        return abs(left - right) == 0 and self.isBalanced(root.right) or self.isBalanced(root.left) and self.isBalanced(root.right)\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n\n        if root.left and root.right:\n            if not self.isBalanced(root.left):\n                return False\n            if not self.isBalanced(root.right):\n                return False\n\n            return abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n        else:\n            return True\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: bool\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return True\n            if not node.left and not node.right:\n                return True\n            if not node.left:\n                return dfs(node.left) and dfs(node.right)\n            if not node.right:\n                return dfs(node.right) and dfs(node.left)\n            return abs(node.left.height() - node.right.height()) <= 1 and dfs(node.left) and dfs(node.right)\n\n        return dfs(root)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return True\n            if not node.left and not node.right:\n                return True\n            if not node.left:\n                return dfs(node.left) and dfs(node.right)\n            if not node.right:\n                return dfs(node.right) and dfs(node.left)\n            return abs(node.left.height() - node.right.height()) <= 1 and dfs(node.left) and dfs(node.right)\n\n        return dfs(root)\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return True\n            if not node.left and not node.right:\n                return True\n            if not node.left:\n                return d",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and self.isBalanced(root.left, root.right)\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.right.right.right = TreeNode(10)\n    root.right.right.right = TreeNode(11)\n    print Solution().isBalanced(root)",
    "class TreeNode:\n\tdef __init__(self, val, left=None, right=None):\n\t\tself.val = val\n\t\tself.left = left\n\t\tself.right = right\n\ndef isBalanced(root):\n\tif root == None:\n\t\treturn True\n\t\n\tif abs(root.left.val - root.right.val) > 1:\n\t\treturn False\n\t\n\treturn isBalanced(root.left) and isBalanced(root.right)\n\n# Recursive\ndef isBalancedRecursive(root):\n\tif root == None:\n\t\treturn True\n\t\n\tif abs(root.left.val - root.right.val) > 1:\n\t\treturn False\n\t\n\treturn isBalancedRecursive(root.left) and isBalancedRecursive(root.right)\n\n# Iterative\ndef isBalancedIterative(root):\n\tif root == None:\n\t\treturn True\n\t\n\tif abs(root.left.val - root.right.val) > 1:\n\t\treturn False\n\t\n\tif abs(root.left.val - root.right.val) == 1:\n\t\treturn isBalancedIterative(root.left) and isBalancedIterative(root.right)\n\n# Iterative\ndef isBalancedIterative(root):\n\tif root == None:\n\t\treturn True\n\t\n\tif abs(root.left.val - root.right.val) > 1:\n\t\treturn False\n\t\n\tif abs(root.left.val - root.right.val) == 1:\n\t\treturn isBalancedIterative(root.left) and isBalancedIterative(root.right)\n\n# Iterative\ndef isBalancedIterative(root):\n\tif root == None:\n\t\treturn True\n\t\n\tif abs(root.left.val - root.right.val) > 1:\n\t\treturn False\n\t\n\tif abs(root.left.val - root.right.val) == 1:\n\t\treturn isBalancedIterative(root.left) and isBalancedIterative(root.right)\n\n# Iterative\ndef isBalancedIterative(root):\n\tif root == None:\n\t\treturn True",
    "import unittest\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 2, None, 1, None, 3], True)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], True)\n        self._test([1, 2, 2, None, 1, None, 3], True)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], True)\n        self._test([1, 2, 2, None, 1, None, 3], True)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2, None, 1, None, 3], False)\n        self._test([1, 2, 2",
    "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        self.isBalanced(root.left, root.right)\n        if abs(self.getDepth(root.left) - self.getDepth(root.right)) > 1:\n            return False\n        else:\n            return True\n\n    def getDepth(self, root):\n        if root is None:\n            return 0\n        return max(self.getDepth(root.left), self.getDepth(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n\n    sol = Solution()\n    print(sol.isBalanced(root))\n\n\n    print(sol.isBalanced(None))\n    print(sol.isBalanced(root.left))\n    print(sol.isBalanced(root.right))\n\n    print(sol.isBalanced(root.left.left))\n    print(sol.isBalanced(root.right.left))\n    print(sol.isBalanced(root.right.right))",
    "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root: return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n    \n    def getHeight(self, root):\n        if not root: return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if abs(root.left.val - root.right.val) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        \n        if root.left is None and root.right is None:\n            return True\n        \n        if root.left is None or root.right is None:\n            return False\n        \n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        \n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        \n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def getHeight(root):\n            if root is None:\n                return 0\n            return max(getHeight(root.left), getHeight(root.right)) + 1\n\n        return abs(getHeight(root) - getHeight(root.left) - getHeight(root.right)) <= 1\n\n\nclass Solution2:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def getHeight(root):\n            if root is None:\n                return 0\n            return max(getHeight(root.left), getHeight(root.right)) + 1\n\n        return abs(getHeight(root) - getHeight(root.left) - getHeight(root.right)) <= 1",
    "import sys\n\n\ndef is_tree_balanced(tree):\n    if tree is None:\n        return True\n    if tree.left is None and tree.right is None:\n        return True\n    if tree.left is not None and tree.right is not None:\n        if abs(tree.left.height() - tree.right.height()) > 1:\n            return False\n    return is_tree_balanced(tree.left) and is_tree_balanced(tree.right)\n\n\ndef main():\n    if len(sys.argv) == 2:\n        tree = create_tree(sys.argv[1])\n        print(is_tree_balanced(tree))\n    else:\n        print(\"Usage: %s [path/to/binary_tree.txt]\" % sys.argv[0])\n\n\ndef create_tree(path):\n    with open(path, \"r\") as f:\n        tree = TreeNode(f.readline().strip())\n        while True:\n            line = f.readline().strip()\n            if line == \"\":\n                break\n            tree.left = TreeNode(line)\n            line = f.readline().strip()\n            if line == \"\":\n                break\n            tree.right = TreeNode(line)\n    return tree\n\n\nclass TreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.height = 0\n\n    def height(self):\n        if self.left is None and self.right is None:\n            return 1\n        return max(self.left.height(), self.right.height()) + 1\n\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isBalancedRecur(node):\n            if not node:\n                return True\n            if not isBalancedRecur(node.left):\n                return False\n            if not isBalancedRecur(node.right):\n                return False\n            return abs(self.getHeight(node.left) - self.getHeight(node.right)) <= 1\n        return isBalancedRecur(root)\n    \n    def getHeight(self, node):\n        if not node:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1\n\n# Note:\n# This is a recursive solution.\n# The idea is to check the height of each side separately.\n# If there is a difference, it is not balanced.\n# If the height of the left and the right is equal, the tree is balanced.",
    "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n                return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.left.left.left = TreeNode(6)\nroot.left.right.left = TreeNode(7)\nroot.left.right.right = TreeNode(8)\nroot.right.left = TreeNode(9)\nroot.right.right = TreeNode(10)\nroot.right.right.left = TreeNode(11)\nroot.right.right.right = TreeNode(12)\n\ns = Solution()\nprint(s.isBalanced(root))",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            return self.isBalanced(root.left) and self.isBalanced(root.right)\n        return (self.isBalanced(root.left) and self.isBalanced(root.right)) or (not self.isBalanced(root.left) and not self.isBalanced(root.right))",
    "\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: True if the binary tree is balanced, or false\n    \"\"\"\n    def isBalanced(self, root):\n        if not root:\n            return True\n\n        return self.isBalanced(root.left, root.val) and self.isBalanced(root.right, root.val)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.helper(root)\n\n    def helper(self, root):\n        if root is None:\n            return True\n        if abs(root.left.val - root.right.val) > 1:\n            return False\n        return self.helper(root.left) and self.helper(root.right)",
    "import sys\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        self.isBalanced(root.left)\n        self.isBalanced(root.right)\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return True\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\ndef main():\n    solution = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print solution.isBalanced(root)\n\nif __name__ == '__main__':\n    main()\n    sys.exit(0)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None:\n            return False\n        if root.right is None:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n        \n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return 1 + max(self.getHeight(root.left), self.getHeight(root.right))\n\ns = Solution()\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint(s.isBalanced(root))",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self.helper(root) >= 0\n        \n    def helper(self, root):\n        if root is None:\n            return 0\n        left = self.helper(root.left)\n        right = self.helper(root.right)\n        if abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().isBalanced(root)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        return abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            if self.isBalanced(root.left) and self.isBalanced(root.right):\n                return True\n        if abs(self.depth(root.left) - self.depth(root.right)) <= 1:\n            return True\n        return False\n\n    def depth(self, root):\n        if root is None:\n            return 0\n        return max(self.depth(root.left), self.depth(root.right)) + 1\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            if self.isBalanced(root.left) and self.isBalanced(root.right):\n                return True\n        if abs(self.depth(root.left) - self.depth(root.right)) <= 1:\n            return True\n        return False\n\n    def depth(self, root):\n        if root is None:\n            return 0\n        return max(self.depth(root.left), self.depth(root.right)) + 1\n\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n\n        if not root.left and not root.right:\n            return True\n\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    print s.isBalanced(root)\n    print s.isBalanced(root.left)\n    print s.isBalanced(root.right)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        self.depth(root)\n        return self.check(root)\n\n    def depth(self, node):\n        if not node:\n            return 0\n        left = self.depth(node.left)\n        right = self.depth(node.right)\n        if abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1\n\n    def check(self, node):\n        if not node:\n            return True\n        if node.left and node.right:\n            if abs(self.depth(node.left) - self.depth(node.right)) > 1:\n                return False\n        return self.check(node.left) and self.check(node.right)",
    "\"\"\"\nA binary tree is considered balanced if the heights of the two subtrees of every node are equal.\n\"\"\"\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if not root:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right) and abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n\n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n# Note:\n# The root node should be a tree node.\n# The height of a tree node is the maximum of the height of its two subtrees.",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None:\n            return self.isBalanced(root.right)\n        if root.right is None:\n            return self.isBalanced(root.left)\n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if root is None:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Note:\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.\n# The height of a tree is the number of nodes on the longest path from the root to the farthest leaf node.",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def dfs(node: TreeNode):\n            if not node:\n                return True\n\n            if node.left and not dfs(node.left):\n                return False\n\n            if node.right and not dfs(node.right):\n                return False\n\n            return abs(node.left.val - node.right.val) <= 1\n\n        return dfs(root)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        if abs(left_height - right_height) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def get_height(self, root):\n        if root is None:\n            return 0\n        return 1 + max(self.get_height(root.left), self.get_height(root.right))",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root is None:\n            return True\n        left = self.isBalanced(root.left)\n        right = self.isBalanced(root.right)\n        if abs(left - right) > 1:\n            return False\n        return left >= 0 and right >= 0 and abs(left - right) <= 1",
    "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if abs(self.getHeight(root.left)) > abs(self.getHeight(root.right)):\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(9)\n    print(Solution().isBalanced(root))",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        queue = [root]\n        left_queue = []\n        right_queue = []\n        while queue:\n            curr = queue.pop()\n            if curr.left:\n                left_queue.append(curr.left)\n            if curr.right:\n                right_queue.append(curr.right)\n            if len(left_queue) > len(right_queue):\n                return False\n            if len(right_queue) > len(left_queue):\n                return False\n        return True",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isBalanced(root, is_balanced):\n            if not root:\n                return is_balanced\n            if root.left:\n                is_balanced = isBalanced(root.left, is_balanced)\n                if not is_balanced:\n                    return False\n            if root.right:\n                is_balanced = isBalanced(root.right, is_balanced)\n                if not is_balanced:\n                    return False\n            return True\n\n        return isBalanced(root, True)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if not self.isBalanced(root.left):\n            return False\n        if not self.isBalanced(root.right):\n            return False\n        return abs(self.getHeight(root.left) - self.getHeight(root.right)) <= 1\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        self.level = [0]\n        self.is_balanced(root)\n        return self.level[0] == 0\n\n    def is_balanced(self, root):\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None:\n            self.level[0] += 1\n            if not self.is_balanced(root.left):\n                return False\n            self.level[0] -= 1\n        if root.right is not None:\n            self.level[0] += 1\n            if not self.is_balanced(root.right):\n                return False\n            self.level[0] -= 1\n        return True\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.isBalanced(TreeNode(1))",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not root.left and not root.right:\n            return True\n        if root.left and not root.right:\n            return False\n        if root.right and not root.left:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)",
    "class Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root == None:\n            return True\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def getHeight(self, root):\n        if root == None:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n\nif __name__ == '__main__':\n    tree = TreeNode(1)\n    tree.left = TreeNode(2)\n    tree.right = TreeNode(3)\n    tree.left.left = TreeNode(4)\n    tree.left.right = TreeNode(5)\n    tree.right.left = TreeNode(6)\n    tree.right.right = TreeNode(7)\n    \n    print Solution().isBalanced(tree)\n    \n    # print Solution().isBalanced(TreeNode(1))",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        self.stack = []\n        self.result = True\n        if root is None:\n            return True\n\n        self.stack.append(root)\n        self.stack.append(None)\n        self.result = self.result and self.isBalanced(root.left) and self.isBalanced(root.right)\n        while self.stack:\n            node = self.stack.pop()\n            if node.left:\n                self.stack.append(node.left)\n            if node.right:\n                self.stack.append(node.right)\n\n        return self.result",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if root.left and root.right:\n            return self.isBalanced(root.left) and self.isBalanced(root.right)\n        if abs(self.getHeight(root.left) - self.getHeight(root.right)) > 1:\n            return False\n        return True\n\n    def getHeight(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        if root == None:\n            return True\n        if not self.isBalanced(root.left):\n            return False\n        if not self.isBalanced(root.right):\n            return False\n        return abs(self.getHeight(root.left)) - abs(self.getHeight(root.right)) <= 1\n    \n    def getHeight(self, node):\n        if not node:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.isBalancedHelper(root, True)\n\n    def isBalancedHelper(self, node, isLeft):\n        if node is None:\n            return True\n        if not isLeft and abs(self.getHeight(node.left) - self.getHeight(node.right)) > 1:\n            return False\n        if isLeft and abs(self.getHeight(node.left) - self.getHeight(node.right)) > 1:\n            return False\n        return self.isBalancedHelper(node.left, isLeft) and self.isBalancedHelper(node.right, isLeft)\n    \n    def getHeight(self, node):\n        if node is None:\n            return 0\n        return max(self.getHeight(node.left), self.getHeight(node.right)) + 1"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}