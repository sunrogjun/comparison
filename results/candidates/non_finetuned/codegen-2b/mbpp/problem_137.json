{
  "problem": {
    "task_id": "MBPP/148",
    "prompt": "Write a function to divide a number into two parts such that the sum of digits is maximum.",
    "canonical_solution": "def sum_digits_single(x) : \r\n    ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A) ",
    "test_list": [
      "assert sum_digits_twoparts(35)==17",
      "assert sum_digits_twoparts(7)==7",
      "assert sum_digits_twoparts(100)==19"
    ],
    "challenge_test_list": [],
    "problem_id": 137
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def maxTwoDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 10:\n            return n\n        max_sum = 0\n        for i in range(10, n+1):\n            for j in range(10, i+1):\n                sum = i + j\n                if sum > max_sum:\n                    max_sum = sum\n        return max_sum\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.maxTwoDigits(123) == 15\n    assert s.maxTwoDigits(123456789) == 34\n    assert s.maxTwoDigits(12345678901) == 34\n    assert s.maxTwoDigits(1234567890123456789) == 34",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def divide(self, num):\n        if num < 1:\n            return 0\n        \n        digits = []\n        for i in range(10):\n            digits.append(num % 10)\n            num /= 10\n        \n        max_sum = 0\n        for i in range(len(digits) - 1, -1, -1):\n            sum = 0\n            for j in range(len(digits) - i):\n                sum += digits[j]\n            \n            if sum > max_sum:\n                max_sum = sum\n            elif sum < max_sum:\n                return i\n        \n        return len(digits) - 1",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend < 0:\n            return self.divide(dividend * -1, divisor)\n        if dividend == 0:\n            return 0\n        if divisor == 0:\n            return dividend\n        if divisor == 1:\n            return dividend\n        if dividend % divisor == 0:\n            return self.divide(dividend / divisor, 2)\n        if dividend % divisor == 0:\n            return self.divide(dividend / divisor, 2)\n        if dividend % divisor < 0:\n            return self.divide(dividend / divisor, 2)\n        else:\n            return self.divide(dividend / divisor, 2)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.divide(0, 0))\n    print(sol.divide(1, 2))\n    print(sol.divide(5, 2))\n    print(sol.divide(5, 3))",
    "class Solution(object):\n    def splitInt(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        res = 0\n        while num > 0:\n            res = max(res, num % 10)\n            num /= 10\n        return res",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while dividend > 0:\n            dividend, r = divmod(dividend, divisor)\n            res = max(res, r)\n        return res",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend_str = str(dividend)\n        dividend_str = dividend_str.split('0')\n        dividend_str = [int(i) for i in dividend_str]\n        dividend_str = sorted(dividend_str)\n        divisor_str = str(divisor)\n        divisor_str = divisor_str.split('0')\n        divisor_str = [int(i) for i in divisor_str]\n        divisor_str = sorted(divisor_str)\n        if dividend < divisor:\n            return -1\n        dividend_sum = sum([i for i in dividend_str])\n        divisor_sum = sum([i for i in divisor_str])\n        if dividend_sum < divisor_sum:\n            return -1\n        elif dividend_sum > divisor_sum:\n            return 1\n        elif dividend_sum == divisor_sum:\n            return 0\n        else:\n            return -1",
    "class Solution:\n    # @param num, a number\n    # @return a list of two integers\n    def splitIntoPieces(self, num):\n        if num <= 0:\n            return []\n\n        n = 1\n        res = []\n        while num >= n:\n            res.append(num % n)\n            num /= n\n            n += 1\n        res.append(num)\n        res.reverse()\n        return res\n\n    # @param num, a number\n    # @return a list of two integers\n    def splitIntoPieces2(self, num):\n        if num <= 0:\n            return []\n\n        res = []\n        while num > 0:\n            res.append(num % 10)\n            num /= 10\n        res.reverse()\n        return res\n\n    # @param num, a number\n    # @return a list of two integers\n    def splitIntoPieces3(self, num):\n        if num <= 0:\n            return []\n\n        res = []\n        while num > 0:\n            res.append(num % 10)\n            num /= 10\n        res.reverse()\n        return res\n\n    # @param num, a number\n    # @return a list of two integers\n    def splitIntoPieces4(self, num):\n        if num <= 0:\n            return []\n\n        res = []\n        while num > 0:\n            res.append(num % 10)\n            num /= 10\n        res.reverse()\n        return res",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend = str(dividend)\n        divisor = str(divisor)\n        dividend = [int(x) for x in dividend]\n        divisor = [int(x) for x in divisor]\n        if len(dividend) < len(divisor):\n            return self.divide(dividend, divisor[:len(dividend)])\n        elif len(dividend) > len(divisor):\n            return self.divide(dividend, divisor[:len(divisor)])\n        else:\n            dividend.sort()\n            divisor.sort()\n            i = 0\n            while i < len(dividend) and i < len(divisor):\n                if dividend[i] < divisor[i]:\n                    i += 1\n                elif dividend[i] > divisor[i]:\n                    return divisor[i]\n                else:\n                    return dividend[i]\n            return max(dividend)\n\n\nif __name__ == \"__main__\":\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(1, 7) == 0\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13, 7) == 3\n    assert Solution().divide(13",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend_int = int(dividend)\n        divisor_int = int(divisor)\n        result = 0\n        while dividend_int >= divisor_int:\n            dividend_int, divisor_int = divmod(dividend_int, divisor_int)\n            result += 1\n        return result",
    "class Solution:\n\t# @param {integer} x\n\t# @return {integer}\n\tdef divide(self, x):\n\t\t# base case\n\t\tif x == 0:\n\t\t\treturn 0, 0\n\t\t# base case\n\t\tif x == 1:\n\t\t\treturn 1, 1\n\t\t# base case\n\t\tif x == 2:\n\t\t\treturn 2, 2\n\t\t# base case\n\t\tif x == 3:\n\t\t\treturn 3, 3\n\t\t# base case\n\t\tif x == 4:\n\t\t\treturn 4, 4\n\t\t# base case\n\t\tif x == 5:\n\t\t\treturn 5, 5\n\t\t# base case\n\t\tif x == 6:\n\t\t\treturn 6, 6\n\t\t# base case\n\t\tif x == 7:\n\t\t\treturn 7, 7\n\t\t# base case\n\t\tif x == 8:\n\t\t\treturn 8, 8\n\t\t# base case\n\t\tif x == 9:\n\t\t\treturn 9, 9\n\t\t# base case\n\t\tif x == 10:\n\t\t\treturn 10, 10\n\t\t# base case\n\t\tif x == 11:\n\t\t\treturn 11, 11\n\t\t# base case\n\t\tif x == 12:\n\t\t\treturn 12, 12\n\t\t# base case\n\t\tif x == 13:\n\t\t\treturn 13, 13\n\t\t# base case\n\t\tif x == 14:\n\t\t\treturn 14, 14\n\t\t# base case\n\t\tif x == 15:\n\t\t\treturn 15, 15\n\t\t# base case\n\t\tif x == 16:\n\t\t\treturn 16, 16\n\t\t# base case\n\t\tif x == 17:\n\t\t\treturn 17, 17\n\t\t# base case\n\t\tif x == 18:\n\t\t\treturn 18, 18\n\t\t# base case\n\t\tif x == 19:\n\t\t\treturn 19, 19\n\t\t# base case\n\t\tif x == 20:\n\t\t\treturn 20, 20\n\t\t# base case\n\t\tif x == 21:\n\t\t\treturn 21, 21\n\t\t# base case\n\t\tif x == 22:\n\t\t\treturn 22, 22\n\t\t# base case\n\t\tif x == 23:\n\t\t\treturn 23, 23\n\t\t# base case\n\t\tif x == 24:\n\t\t\treturn 24, 24\n\t\t# base case\n\t\tif x == 25:\n\t\t\treturn 25, 25\n\t\t# base case\n\t\tif x == 26:",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend = str(dividend)\n        divisor = str(divisor)\n\n        result = 0\n        for i in range(len(dividend)):\n            if dividend[i]!= divisor[i]:\n                break\n            result += int(dividend[i])\n        return result",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param {integer} dividend\n    # @param {integer} divisor\n    # @return {integer}\n    def divide(self, dividend, divisor):\n        dividend_s = str(dividend)\n        divisor_s = str(divisor)\n        if dividend_s == '':\n            return 0\n        if divisor_s == '':\n            return dividend_s\n\n        dividend_len = len(dividend_s)\n        divisor_len = len(divisor_s)\n\n        if dividend_len < divisor_len:\n            return self.divide(dividend_s, divisor_s[:dividend_len])\n        elif dividend_len > divisor_len:\n            return self.divide(dividend_s, divisor_s[:divisor_len])\n        else:\n            return self.divide(dividend_s, divisor_s)\n\n\n    # @param {integer} dividend\n    # @param {integer} divisor\n    # @return {integer}\n    def divide(self, dividend, divisor):\n        dividend_s = str(dividend)\n        divisor_s = str(divisor)\n        if dividend_s == '':\n            return 0\n        if divisor_s == '':\n            return dividend_s\n\n        dividend_len = len(dividend_s)\n        divisor_len = len(divisor_s)\n\n        if dividend_len < divisor_len:\n            return self.divide(dividend_s, divisor_s[:dividend_len])\n        elif dividend_len > divisor_len:\n            return self.divide(dividend_s, divisor_s[:divisor",
    "class Solution(object):\n    def splitIntoPieces(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        result = 0\n        while n:\n            result += n % 10\n            n /= 10\n        return result\n\n    def splitIntoPieces1(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            result += n % 10\n            n /= 10\n        return result\n\n    def splitIntoPieces2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            result += n % 10\n            n /= 10\n        return result + n\n\n    def splitIntoPieces3(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            result += n % 10\n            n /= 10\n        return result + n\n\n    def splitIntoPieces4(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            result += n % 10\n            n /= 10\n        return result + n\n\nif __name__ == \"__main__\":\n    print Solution().splitIntoPieces(5)\n    print Solution().splitIntoPieces1(5)\n    print Solution().splitIntoPieces2(5)\n    print Solution().splitIntoPieces3(5)\n    print Solution().splitIntoPieces4(5)",
    "class Solution(object):\n    def maxTwoDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        n = str(n)\n        if len(n) == 1:\n            return n\n        else:\n            return max(self.maxTwoDigits(int(n[:2])), self.maxTwoDigits(int(n[2:])))\n\n\nif __name__ == '__main__':\n    print Solution().maxTwoDigits(9223372036854775807)",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def twoSum(self, num, target):\n        \"\"\"\n        :type num: int\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if target < 0:\n            return []\n        res = []\n        for i in range(10 ** 9 + 1):\n            if target - i < 0:\n                break\n            j = target - i\n            for k in range(10 ** 9 + 1):\n                if num - k < 0:\n                    break\n                if j - k < 0:\n                    break\n                if num - k - j < 0:\n                    break\n                if num - k - j == 0:\n                    res.append([i, k])\n                    break\n        return res\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.twoSum(10, 0))\n    print(sol.twoSum(10, 10))\n    print(sol.twoSum(100, 100))\n    print(sol.twoSum(100, 100))",
    "class Solution(object):\n    def maxTwoSum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # first sort the list\n        nums = sorted(num)\n        # write a method to split the num into two parts\n        # return the max sum of two parts\n        return max(self.maxTwoSumHelper(nums), self.maxTwoSumHelper(nums[::-1]))\n\n    def maxTwoSumHelper(self, nums):\n        # write a method to compute the max sum of two parts\n        # return the max sum of two parts\n        n = len(nums)\n        if n < 2:\n            return n\n        # we need to find the max sum of two parts\n        # we only need to take care of the first part\n        # the second part is the same as the first part\n        # the max sum of two parts\n        # the max sum of two parts is the max of the first part and the second part\n        # we can get the max sum of two parts by taking the max of two numbers\n        max_sum_of_two_parts = max(nums[0] + nums[1], nums[n-1] + nums[n-2])\n        return max_sum_of_two_parts\n\n\nif __name__ == \"__main__\":\n    # print Solution().maxTwoSum(-5)\n    print Solution().maxTwoSum(100)",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def divide(self, num):\n        if num <= 0:\n            return 0\n        num = str(num)\n        if len(num) == 1:\n            return 0\n        if len(num) == 2:\n            return 1\n        max_sum = 0\n        for i in xrange(len(num)):\n            num_str = ''.join(map(str, map(int, num[i:])))\n            max_sum = max(max_sum, len(num_str))\n        if max_sum == len(num):\n            return 0\n        if max_sum == len(num)-1:\n            return 1\n        return self.divide(num[:max_sum]) + self.divide(num[max_sum:])\n\ns = Solution()\nprint s.divide(14)",
    "class Solution:\n    def maxTwoSum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        max = 0\n        n = 10 ** 9 + 7\n        for i in xrange(1, n):\n            for j in xrange(1, n):\n                sum = num % 10\n                num //= 10\n                if sum == 0 or sum == i or sum == j:\n                    continue\n                else:\n                    for k in xrange(1, 10):\n                        if sum + k == 0:\n                            max = max if sum + k > max else sum + k\n                            break\n                    else:\n                        max = max if sum + k > max else sum + k\n        return max\n\nif __name__ == \"__main__\":\n    assert Solution().maxTwoSum(3) == 4\n    assert Solution().maxTwoSum(9) == 10",
    "class Solution:\n\t\n\t# @param num, a integer\n\t# @return a list of integers\n\tdef divide(self, num):\n\t\tmax_sum = 0\n\t\tresult = []\n\t\twhile num > 0:\n\t\t\tif num % 10 == 0:\n\t\t\t\tnum /= 10\n\t\t\telse:\n\t\t\t\tnum *= 10\n\t\t\tmax_sum = max(max_sum, num)\n\t\tif max_sum > 10:\n\t\t\tresult.append(10)\n\t\tfor i in range(10, max_sum + 1):\n\t\t\tif i > max_sum:\n\t\t\t\tresult.append(i)\n\t\treturn result\n\nif __name__ == '__main__':\n\ts = Solution()\n\tprint s.divide(9)\n\tprint s.divide(100)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend_digits = list(str(dividend))\n        divisor_digits = list(str(divisor))\n        dividend_digits.sort()\n        divisor_digits.sort()\n        max_sum = 0\n        for i in range(len(dividend_digits)):\n            sum_ = 0\n            for j in range(len(divisor_digits)):\n                sum_ += int(dividend_digits[i]) * divisor_digits[j]\n            max_sum = max(max_sum, sum_)\n        return max_sum",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend % divisor == 0:\n            return 0\n        res = 0\n        while dividend > 0:\n            res = max(res, len(str(dividend % divisor)))\n            dividend /= divisor\n        return res\n\n\nif __name__ == '__main__':\n    print Solution().divide(100, 2)",
    "# Definition for a digit.\nclass Digit:\n    def __init__(self, n):\n        self.n = n\n\n    def __repr__(self):\n        return str(self.n)\n\n\nclass Solution:\n    def maxDigits(self, n: int) -> int:\n        return int(str(n)[::-1])\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxDigits(1) == 1\n    assert Solution().maxDigits(2) == 2\n    assert Solution().maxDigits(3) == 3\n    assert Solution().maxDigits(4) == 4\n    assert Solution().maxDigits(5) == 5\n    assert Solution().maxDigits(6) == 6\n    assert Solution().maxDigits(7) == 7\n    assert Solution().maxDigits(8) == 8\n    assert Solution().maxDigits(9) == 9\n    assert Solution().maxDigits(10) == 10\n    assert Solution().maxDigits(11) == 11\n    assert Solution().maxDigits(12) == 12\n    assert Solution().maxDigits(13) == 13\n    assert Solution().maxDigits(14) == 14\n    assert Solution().maxDigits(15) == 15\n    assert Solution().maxDigits(16) == 16\n    assert Solution().maxDigits(17) == 17\n    assert Solution().maxDigits(18) == 18\n    assert Solution().maxDigits(19) == 19\n    assert Solution().maxDigits(20) == 20\n    assert Solution().maxDigits(21) == 21\n    assert Solution().maxDigits(22) == 22\n    assert Solution().maxDigits(23) == 23\n    assert Solution().maxDigits(24) == 24\n    assert Solution().maxDigits(25) == 25\n    assert Solution().maxDigits(26) == 26\n    assert Solution().maxDigits(27) == 27\n    assert Solution().maxDigits(28) == 28\n    assert Solution().maxDigits(29) == 29\n    assert Solution().maxDigits(30) == 30\n    assert Solution().maxDigits(31) == 31\n    assert Solution().maxDigits(32) == 32",
    "import unittest\n\n\nclass Solution:\n    # @param {integer} num\n    # @return {integer[]}\n    def splitIntoTwo(self, num):\n        n = 0\n        for i in range(10):\n            n += num // i\n            num %= i\n        return [n, num]\n\n    def test(self):\n        self.assertEqual(self.splitIntoTwo(123), [123, 0])\n        self.assertEqual(self.splitIntoTwo(1234), [1234, 0])\n        self.assertEqual(self.splitIntoTwo(123456789), [123456789, 0])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        if dividend > divisor:\n            return self.divide(dividend - divisor, divisor)\n        if dividend == divisor:\n            return 1\n        if dividend % divisor == 0:\n            return self.divide(dividend - divisor, divisor) + 1\n        return self.divide(dividend, divisor) + 1",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        n = max(dividend, divisor)\n        d = n\n        while n > 0:\n            if n % divisor == 0:\n                d = n\n            n /= 10\n        return d\n\nif __name__ == '__main__':\n    assert Solution().divide(12345, 7) == 9\n    assert Solution().divide(12345, 7) == 9",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def divide(self, num):\n        res = 0\n        while num > 0:\n            res = max(res, num % 10)\n            num = num / 10\n        return res",
    "def divide_into_two(num):\n    d = [0] * 10\n    d[0] = 1\n    for i in range(1, 10):\n        d[i] = d[i - 1] + num % 10\n        num /= 10\n    return d\n\n\nif __name__ == \"__main__\":\n    print(divide_into_two(123))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))\n    print(divide_into_two(123456789))",
    "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def divide(self, n):\n        # write your code here\n        res = 0\n        while n > 0:\n            res = max(res, (n % 10) + (n % 100 / 10) + (n % 1000 / 100))\n            n /= 10\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.divide(123)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0:\n            return 0\n        if dividend < 0:\n            dividend = -dividend\n        if divisor == 0:\n            return dividend\n        if divisor < 0:\n            divisor = -divisor\n        # 1. find maximum\n        # 2. divide into two parts\n        # 3. find maximum again\n        max_digits = 0\n        max_digits_num = 0\n        while dividend:\n            dividend, divisor = divisor, dividend % divisor\n            if divisor == 0:\n                break\n            max_digits += 1\n            if max_digits > max_digits_num:\n                max_digits_num = max_digits\n        max_digits_num = max_digits\n        # print max_digits_num\n        if max_digits_num > max_digits:\n            return max_digits\n        return max_digits_num - max_digits\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.divide(13, 13)\n    print s.divide(13, 13)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13, 1)\n    print s.divide(13",
    "import math\n\nclass Solution:\n    \"\"\"\n    @param: num: a number\n    @return: a tuple(int, int)\n    \"\"\"\n    def splitIntoTwo(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        if num == 0:\n            return [0, 0]\n\n        res = []\n        while num:\n            res.append(num % 10)\n            num = num / 10\n\n        res.sort(reverse=True)\n        return res\n\nif __name__ == '__main__':\n    print Solution().splitIntoTwo(3)\n    print Solution().splitIntoTwo(8)\n    print Solution().splitIntoTwo(1)\n    print Solution().splitIntoTwo(9)",
    "#!/usr/bin/python\n\n#!/usr/bin/python\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxSumOfTwo(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root:\n                return 0\n            left, right = dfs(root.left), dfs(root.right)\n            if not left and not right:\n                return root.val\n            left_sum = 0\n            right_sum = 0\n            for i in xrange(left.val + right.val):\n                left_sum += left.val if i < left.val else 0\n                right_sum += right.val if i < right.val else 0\n            max_left_sum = max(left_sum, right_sum)\n            max_right_sum = max(left_sum, right_sum)\n            max_sum = max(max_left_sum, max_right_sum)\n            if max_sum == max_left_sum:\n                return root.val\n            if max_sum == max_right_sum:\n                return root.val\n            return max(max_sum, max(left_sum, right_sum))\n        return dfs(root)",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def maxTwoSum(self, num):\n        ans = 0\n        for i in range(10):\n            for j in range(i, 10):\n                ans = max(ans, self.twoSum(num, i, j))\n        return ans\n\n    def twoSum(self, num, i, j):\n        ans = 0\n        for k in range(10):\n            if k == i or k == j:\n                continue\n            ans = max(ans, num - k)\n            if ans == num - k:\n                return num - k\n        return ans\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxTwoSum(100)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        \n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        if dividend == divisor:\n            return 1\n        \n        if dividend > divisor:\n            return self.divide(divisor, dividend)\n        else:\n            return self.divide(dividend, divisor)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def __init__(self):\n        self.result = 0\n        self.max_sum = 0\n\n    def divide(self, root, target):\n        if not root:\n            return\n        self.result += 1\n        self.max_sum = max(self.max_sum, self.max_sum(root))\n        self.divide(root.left, target)\n        self.divide(root.right, target)\n        self.max_sum = max(self.max_sum, self.max_sum(root))\n\n    def max_sum(self, root):\n        if not root:\n            return 0\n        return max(self.max_sum(root.left), self.max_sum(root.right)) + root.val\n\n    def divide_recur(self, root, target):\n        if not root:\n            return\n        self.divide_recur(root.left, target)\n        self.divide_recur(root.right, target)\n        self.result += 1\n        self.max_sum = max(self.max_sum, self.max_sum(root))\n\n    def max_sum_recur(self, root, target):\n        if not root:\n            return\n        self.divide_recur(root.left, target)\n        self.divide_recur(root.right, target)\n        self.result += 1\n        self.max_sum = max(self.max_sum, self.max_sum(root))\n\n    def max_sum_iter(self, root, target):\n        if not root:\n            return\n        self.max_sum = max(self.max_sum, self.max_sum(root))\n        if target < root.val:\n            self.max_sum_iter(root.left, target)\n            self.max_sum_iter(root.right, target)\n        else:\n            self.max_sum_iter(root.left,",
    "class Solution(object):\n    def splitIntoFibonacci(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num < 10:\n            return num\n        if num % 10 == 0:\n            return num\n        fib_list = [1, 1]\n        while num > 0:\n            fib_list.append(fib_list[-1] + fib_list[-2])\n            num /= 10\n        max_digit = 0\n        for i in range(len(fib_list)):\n            max_digit = max(max_digit, len(str(fib_list[i])))\n        return sum(map(int, str(fib_list[-1:]))) + max_digit\n\n\nif __name__ == \"__main__\":\n    print Solution().splitIntoFibonacci(1234)",
    "def max_sum_divide(n):\n\treturn int(str(n)[::-1] + str(n)[::-1])\n\nprint max_sum_divide(1234567890)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend, divisor = abs(dividend), abs(divisor)\n        if dividend > divisor:\n            return self.divide(dividend - divisor, divisor)\n        res = 0\n        for i in xrange(dividend):\n            res = max(res, i + self.divide(i, divisor))\n        return res\n\n    def test(self):\n        self.assertEqual(1, self.divide(4, 3))\n        self.assertEqual(2, self.divide(9, 7))\n        self.assertEqual(1, self.divide(9, 10))\n\nif __name__ == '__main__':\n    Solution().test()",
    "class Solution:\n    # @param {integer} dividend\n    # @param {integer} divisor\n    # @return {integer}\n    def divide(self, dividend, divisor):\n        # write your code here\n        carry = 0\n        result = 0\n        while dividend >= divisor:\n            dividend, result = divmod(dividend, divisor)\n            carry += result\n        return carry + result\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.divide(2345, 10)\n    print solution.divide(123, 10)\n    print solution.divide(123, 11)\n    print solution.divide(123, 12)\n    print solution.divide(123, 13)\n    print solution.divide(123, 14)\n    print solution.divide(123, 15)\n    print solution.divide(123, 16)\n    print solution.divide(123, 17)\n    print solution.divide(123, 18)\n    print solution.divide(123, 19)\n    print solution.divide(123, 20)\n    print solution.divide(123, 21)\n    print solution.divide(123, 22)\n    print solution.divide(123, 23)\n    print solution.divide(123, 24)\n    print solution.divide(123, 25)\n    print solution.divide(123, 26)\n    print solution.divide(123, 27)\n    print solution.divide(123, 28)\n    print solution.divide(123, 29)\n    print solution.divide(123, 30)\n    print solution.divide(123, 31)\n    print solution.divide(123, 32)\n    print solution.divide(123, 33)\n    print solution.divide(123, 34)\n    print solution.divide(123, 35)\n    print solution.divide(123, 36)\n    print solution.divide(123, 37)\n    print solution.divide(123, 38)\n    print solution.divide(123, 39)\n    print solution.divide(123, 40)\n    print solution.divide",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        l, r = 0, 0\n        while dividend:\n            l = l * 10 + dividend % 10\n            dividend /= 10\n        while divisor:\n            r = r * 10 + divisor % 10\n            divisor /= 10\n        while l < r:\n            tmp = l\n            l = r\n            r = tmp\n        return max(l, r)",
    "# https://www.hackerrank.com/challenges/two-digit-multiplication/problem\n\ndef twoDigitMultiplication(num):\n    res = []\n    mult = 1\n    while num!= 0:\n        res.append(num % 10)\n        num = num / 10\n        mult *= 10\n    res.reverse()\n    \n    while mult > 1:\n        res.append(mult % 10)\n        mult /= 10\n    res.reverse()\n    return res\n\nif __name__ == \"__main__\":\n    num = int(input())\n    print(twoDigitMultiplication(num))",
    "class Solution:\n    # @param {integer} num\n    # @return {integer}\n    def maxTwoSum(self, num):\n        max_sum = 0\n        for i in range(10):\n            temp = 0\n            for j in range(i, 10):\n                temp += num / j\n                if temp > max_sum:\n                    max_sum = temp\n            num %= i\n        return max_sum\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.maxTwoSum(2147483647))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        for i in range(10):\n            dividend *= 10\n            dividend += i\n            if dividend % divisor == 0:\n                dividend /= divisor\n                max_sum = max(max_sum, i)\n        return max_sum\n\n    # @param dividend, an integer\n    # @param divisor, an integer\n    # @return an integer\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        dividend *= 10\n        dividend += max(0, divisor - 1)\n        max_sum = 0\n        while dividend >= divisor:\n            dividend -= divisor\n            max_sum = max(max_sum, max(dividend, divisor))\n        return max_sum\n\n\na = Solution()\nprint(a.divide(10, 5))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # print dividend, divisor\n        dividend_str = str(dividend)\n        divisor_str = str(divisor)\n        if len(divisor_str) > len(dividend_str):\n            return self.divide(divisor, int(dividend_str[:len(divisor_str)]))\n        elif len(divisor_str) < len(dividend_str):\n            return self.divide(int(dividend_str[:len(divisor_str)]), divisor)\n        else:\n            return int(dividend_str[:len(divisor_str)]) + self.divide(int(dividend_str[len(divisor_str):]), divisor)\n\n\nif __name__ == \"__main__\":\n    Solution().divide(10, 7)",
    "class Solution:\n    def maxTwoSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if j < len(nums) - 1:\n                    if nums[i] + nums[j] > nums[j + 1]:\n                        result = max(result, nums[i] + nums[j])\n        return result",
    "class Solution(object):\n    def maxTwoSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # base case: no solution\n        if len(nums) == 0:\n            return 0\n        # base case: one element\n        if len(nums) == 1:\n            return nums[0]\n        # base case: two element\n        if len(nums) == 2:\n            return nums[0] + nums[1]\n\n        # build dictionary\n        d = {}\n        for num in nums:\n            # add num to the dictionary\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n\n        # loop through dictionary to find two numbers with max sum of digits\n        max_sum = 0\n        max_sum_idx = 0\n        for num in d:\n            # compare the sum of digits\n            sum_of_digits = 0\n            for i in range(len(str(num))):\n                sum_of_digits += nums[i]\n            if sum_of_digits > max_sum:\n                max_sum = sum_of_digits\n                max_sum_idx = i\n        # return the two numbers with max sum of digits\n        return nums[max_sum_idx] + nums[(max_sum_idx + 1) % len(nums)]\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().maxTwoSum(nums))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        ans = 0\n        if dividend < divisor:\n            ans = 1\n        while dividend >= divisor:\n            dividend -= divisor\n            ans += 1\n        return ans",
    "class Solution(object):\n    def twoSum(self, num, target):\n        \"\"\"\n        :type num: int\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        # num is a list of numbers\n        # target is a number\n        # find the index of num in num\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index is in the range [0, len(num))\n        # append the target to the list\n        # if the index is in the range [len(num), len(num))\n        # append the target to the list\n        # if the index",
    "class Solution:\n\t# @param {integer} x\n\t# @return {integer}\n\tdef maxSubArray(self, x):\n\t\tmax_sum = 0\n\t\tmax_sum_index = 0\n\t\tfor i in range(len(str(x))):\n\t\t\tif x > 0:\n\t\t\t\tcur_sum = x % 10\n\t\t\t\tx = x / 10\n\t\t\telse:\n\t\t\t\tcur_sum = 0\n\t\t\tmax_sum = max(max_sum, cur_sum)\n\t\t\tif max_sum > max_sum_index:\n\t\t\t\tmax_sum_index = max_sum\n\t\treturn max_sum_index\n\nif __name__ == '__main__':\n\ts = Solution()\n\tprint s.maxSubArray(123)\n\tprint s.maxSubArray(1000)\n\tprint s.maxSubArray(10000)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # https://discuss.leetcode.com/topic/3579/java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/3579/Java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/3311/java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/926/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1286/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1287/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1290/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1292/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1293/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1295/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1296/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/1298/Java-solution-with-explanation\n        # https://leetcode.com/problems/divide-two-integers/discuss/12",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        if dividend < 0:\n            dividend *= -1\n        if divisor < 0:\n            divisor *= -1\n        if dividend >= divisor:\n            if dividend - divisor == 0:\n                return 0\n            else:\n                return 1\n        elif dividend == divisor:\n            return 1\n        else:\n            return self.divide(dividend - divisor, divisor)\n\n\nif __name__ == '__main__':\n    print Solution().divide(10, 2)\n    print Solution().divide(4, 2)\n    print Solution().divide(5, 3)\n    print Solution().divide(2, -1)\n    print Solution().divide(1, -1)\n    print Solution().divide(2, -2)\n    print Solution().divide(1, -2)\n    print Solution().divide(1, -3)",
    "class Solution(object):\n    def maxDigitSum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num < 10:\n            return num\n        nums = []\n        while num > 0:\n            nums.append(num % 10)\n            num = num / 10\n        nums.reverse()\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i] * nums[i])\n        return max_sum\n\nif __name__ == '__main__':\n    print Solution().maxDigitSum(12)",
    "class Solution:\n    \"\"\"\n    @param: n: a positive integer\n    @return: two integers\n    \"\"\"\n    def divide(self, n):\n        # write your code here\n        if n == 0:\n            return 0, 0\n        nums = list(str(n))\n        nums.sort()\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, int(nums[i]))\n        res = [0, 0]\n        for i in range(len(nums)):\n            res[0] += int(nums[i])\n            res[1] += int(nums[i])\n            res[0] %= 10\n            res[1] %= 10\n            if res[0] > res[1]:\n                res[0] = 0\n                res[1] = 1\n            else:\n                res[0] = 1\n                res[1] = 0\n        return res",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while dividend >= divisor:\n            res += 1\n            dividend -= divisor\n        res += max(0, len(str(dividend)) - len(str(divisor)))\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.divide(12, 10)\n    print sol.divide(10, 10)\n    print sol.divide(11, 10)\n    print sol.divide(12, 11)\n    print sol.divide(12, 12)",
    "class Solution:\n    # @param num, an integer\n    # @return a list of integer\n    def splitInt(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        if num < 10:\n            result.append(num)\n            return result\n\n        # split the number into two parts\n        left = num\n        right = num\n        while left!= 0:\n            # find the maximum number of digits in left and right\n            max_left = 0\n            max_right = 0\n            while left!= 0:\n                if left % 10!= 0:\n                    max_left = max(max_left, len(str(left)))\n                left /= 10\n            while right!= 0:\n                if right % 10!= 0:\n                    max_right = max(max_right, len(str(right)))\n                right /= 10\n            # if the max_left is less than max_right, then we need to swap the two parts\n            if max_left <= max_right:\n                # swap the left part and right part\n                result.append(left)\n                result.append(right)\n                # change the current number to the number of the left part\n                left = num / 10\n                right = num % 10\n            else:\n                result.append(right)\n                result.append(left)\n                left = num / 10\n                right = num % 10\n        return result\n\ns = Solution()\nprint s.splitInt(12345)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # dp[i][j] means the max sum of digits of dividend[0...i-1] and divisor[0...j-1]\n        dp = [ [ 0 ] * (j+1) for i in range(1, (dividend//divisor)+1) ]\n        for i in range(1, (dividend//divisor)+1):\n            for j in range(1, (divisor//dividend)+1):\n                if divisor == 0:\n                    dp[i][j] = dividend\n                elif dividend == 0:\n                    dp[i][j] = divisor\n                else:\n                    dp[i][j] = max(dp[i-1][j-1], dp[i][j-1]) + max(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print Solution().divide(100, 10)",
    "class Solution(object):\n    def splitIntoPieces(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        while n > 0:\n            ret.append(n % 10)\n            n //= 10\n        return ret\n\nif __name__ == '__main__':\n    print(Solution().splitIntoPieces(123))",
    "class Solution(object):\n    def splitInt(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # base case\n        if num < 2:\n            return num, 0\n\n        # find the first number whose sum of digits is greater than num\n        max_sum_of_digits = 0\n        for i in xrange(2, num + 1):\n            if num % i == 0:\n                max_sum_of_digits = max(max_sum_of_digits, i)\n        \n        # find the first number whose sum of digits is greater than max_sum_of_digits\n        for i in xrange(2, num + 1):\n            if num % i == 0:\n                max_sum_of_digits = max(max_sum_of_digits, i)\n        \n        # split num into two parts\n        first = num // max_sum_of_digits\n        second = num % max_sum_of_digits\n\n        return first, second\n\nif __name__ == \"__main__\":\n    print Solution().splitInt(19)",
    "class Solution(object):\n    def twoSum(self, num, target):\n        \"\"\"\n        :type num: int\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        return self.twoSum_1(num, target)\n\n    def twoSum_1(self, num, target):\n        res = []\n        for i in range(len(str(num))):\n            n = int(str(num)[i])\n            for j in range(len(str(num))):\n                if j!= i:\n                    if (n + str(num)[j]) > target:\n                        res.append([i, j])\n                        break\n        return res\n\n    def twoSum_2(self, num, target):\n        res = []\n        for i in range(len(str(num))):\n            n = int(str(num)[i])\n            for j in range(len(str(num))):\n                if j!= i:\n                    if (n + str(num)[j]) > target:\n                        res.append([i, j])\n                        break\n        return res",
    "# https://leetcode.com/problems/divide-two-numbers-whose-sum-is-equal-to-the-given-number/discuss/147833/Java-Solution\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/discuss/76637/Java-Solution\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        dividend_digits = [x for x in str(dividend) if x in '0123456789']\n        divisor_digits = [x for x in str(divisor) if x in '0123456789']\n\n        if dividend_digits == [] or divisor_digits == []:\n            return 0\n\n        max_sum = 0\n        for i in range(len(dividend_digits)):\n            if dividend_digits[i] == divisor_digits[i]:\n                max_sum = max(max_sum, int(dividend_digits[i]))\n\n        if max_sum < dividend:\n            return -1\n\n        if max_sum == dividend:\n            return max_sum\n\n        return 0\n\n\nif __name__ == '__main__':\n    assert Solution().divide(7, 3) == 0\n    assert Solution().divide(7, -3) == 1\n    assert Solution().divide(7, 0) == 0",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend % divisor == 0:\n            return 0\n        if dividend < divisor:\n            return self.divide(dividend, divisor)\n        \n        # max(dividend, divisor)\n        # max(dividend - divisor, divisor)\n        # max(dividend - divisor - 1, divisor)\n        # max(dividend - divisor + 1, divisor)\n        # max(dividend - divisor + 2, divisor)\n        \n        max_div = max(dividend, divisor)\n        max_sub = max(dividend - divisor, divisor)\n        max_add = max(dividend - divisor - 1, divisor)\n        max_add_1 = max(dividend - divisor + 1, divisor)\n        max_add_2 = max(dividend - divisor + 2, divisor)\n        \n        max_div = max(max_div, max_sub, max_add, max_add_1, max_add_2)\n        return max_div",
    "# https://oj.leetcode.com/problems/divide-two-numbers-to-get-the-maximum-subarray/\n# O(n)\n# O(n)\n\nclass Solution(object):\n    def maxTwoSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        nums.sort()\n        max_sum = nums[0]\n        max_index = 0\n        for i in range(1, len(nums)):\n            sum = nums[i]\n            for j in range(i-1, -1, -1):\n                if j < 0:\n                    break\n                if nums[j] + sum < max_sum:\n                    max_index = i\n                    max_sum = nums[j] + sum\n                elif nums[j] + sum > max_sum:\n                    break\n            if max_sum < nums[i]:\n                max_sum = nums[i]\n                max_index = i\n\n        return max_index + 1\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxTwoSum([-3, -8, -10, -1, -2, -5, -9, -6])\n    print s.maxTwoSum([-1, -1, -2, -3, -3, -4, -4, -5, -5, -6, -7, -7])",
    "class Solution:\n    def divide(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        \n        max_sum = 0\n        max_sum_2 = 0\n        \n        for i in range(10):\n            if num % i == 0:\n                num /= i\n                max_sum = max(max_sum, i)\n                max_sum_2 = max(max_sum_2, i)\n                \n        return max(max_sum, max_sum_2)",
    "class Solution:\n    # @return a tuple, (length of second part, sum of digits in second part)\n    def splitIntoTwo(self, num):\n        if not num:\n            return 0, 0\n        if num == 1:\n            return 1, 1\n        d = 0\n        for i in xrange(1, len(str(num))):\n            d += int(str(num)[i])\n        return self.splitIntoTwo(d)\n\n    def splitIntoTwo_recursive(self, num):\n        if not num:\n            return 0, 0\n        if num == 1:\n            return 1, 1\n        if num % 10 == 0:\n            return self.splitIntoTwo_recursive(num // 10)\n        if num % 5 == 0:\n            return self.splitIntoTwo_recursive(num // 5)\n        return self.splitIntoTwo_recursive(num // 2)\n\nsol = Solution()\nprint sol.splitIntoTwo(123)\nprint sol.splitIntoTwo(123456789)",
    "class Solution:\n    # @return a tuple, (index1, index2)\n    # @param {integer} target\n    # @return {integer}\n\n    def twoSum(self, num, target):\n        res = []\n        for i in range(len(num)):\n            for j in range(len(num)):\n                if num[i] + num[j] == target:\n                    res.append([i, j])\n                    break\n        return res\n\n    def twoSum2(self, num, target):\n        return sorted(self.twoSum(num, target), key=lambda x: x[1])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.twoSum2([2, 7, 11, 15], 22)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend < divisor:\n            return self.divide(dividend, divisor)\n        dividend, divisor = divisor, dividend\n        divisor, dividend = divisor, dividend\n        ans = 0\n        while dividend > 0:\n            if dividend % divisor == 0:\n                ans = max(ans, divisor + 1)\n            divisor, dividend = divisor, dividend\n            divisor = divisor % 10 + 1\n        return ans",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        def getDigits(n):\n            return [int(x) for x in str(n)]\n\n        def getMaxDigits(n):\n            return max([sum(digits) for digits in getDigits(n)])\n\n        if dividend < 0:\n            return getMaxDigits(abs(dividend))\n\n        if divisor == 0:\n            return getMaxDigits(dividend)\n\n        if divisor < 0:\n            return getMaxDigits(dividend - divisor)\n\n        if dividend < divisor:\n            return getMaxDigits(dividend - divisor)\n\n        return getMaxDigits(dividend / divisor)\n\n\nif __name__ == '__main__':\n    assert Solution().divide(10, 7) == 2\n    assert Solution().divide(7, 7) == 1\n    assert Solution().divide(9, 7) == 3\n    assert Solution().divide(9, 8) == 2\n    assert Solution().divide(11, 8) == 3\n    assert Solution().divide(11, 9) == 4\n    assert Solution().divide(12, 9) == 5\n    assert Solution().divide(12, 10) == 3\n    assert Solution().divide(12, 11) == 4\n    assert Solution().divide(12, 12) == 1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def maxPathSum(self, root):\n        if not root:\n            return 0\n        \n        sum = self.maxPathSum(root.left) + self.maxPathSum(root.right)\n        if root.val < 0:\n            sum = -sum\n        return sum + root.val",
    "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return max(nums)\n        l, r = 0, 0\n        for i in range(len(nums)):\n            if l == 0:\n                r = max(r, nums[i])\n            else:\n                l = max(l, nums[i])\n                r = max(r, nums[i])\n        return max(l, r)\n\n\nif __name__ == \"__main__\":\n    print Solution().maxProduct([2,3,4,3,5,6,7,8,6,5])",
    "# The number is written in string format.\n# e.g.\n# The number written as 1234 is divided into two parts as 1+2+3=max digits.\n# The number written as 12345 is divided into two parts as 1+23+45=max digits.\n# The number written as 1234567 is divided into two parts as 1+23+45+67=max digits.\n# The number written as 12345678 is divided into two parts as 1+23+45+67+78=max digits.\n\n# This problem is the same as the problem 9, except we use the function max_digit_sum() instead of sum_digits().\n\n# Example 1:\n# Input: 5\n# Output: [2,3]\n# Explanation:\n# The number written as 5 is divided into two parts as 1+5=2 digits.\n# The number written as 5678 is divided into two parts as 1+5+7=3 digits.\n# Example 2:\n# Input: 10\n# Output: [2,2,3]\n# Explanation:\n# The number written as 10 is divided into two parts as 1+0+10=2 digits.\n# The number written as 1234 is divided into two parts as 1+2+3+4=4 digits.\n# Example 3:\n# Input: 12345\n# Output: [2,2,3,5]\n# Explanation:\n# The number written as 12345 is divided into two parts as 1+23+45=2 digits.\n# The number written as 123456 is divided into two parts as 1+23+45+6=5 digits.\n# The number written as 1234567 is divided into two parts as 1+23+45+67=7 digits.\n# The number written as 12345678 is divided into two parts as 1+23+45+67+78=8 digits.\n\nclass Solution(object):\n    def splitIntoPieces(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        return max_digit_sum(num)\n\n\ndef max_digit_sum(num):\n    \"\"\"\n    :type num: int\n    :rtype: List[int]\n    \"\"\"\n    if num ==",
    "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in xrange(len(nums) - 1):\n            if nums[i] + nums[i+1] > target:\n                break\n            if nums[i] + nums[i+1] < target:\n                return [i, i+1]\n        return [len(nums) + 1, len(nums)]\n\n\nif __name__ == '__main__':\n    print Solution().twoSum([1, 2, 3, 4, 5, 6], 10)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0:\n            return 0\n        if divisor == 0:\n            return dividend\n        if dividend >= divisor:\n            return self.divide(dividend - divisor, divisor) + 1\n        else:\n            return self.divide(dividend, divisor - dividend) + 1\n\na = Solution()\nprint(a.divide(123, 7))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if divisor == 0:\n            return 0\n        if dividend > divisor:\n            dividend, divisor = divisor, dividend\n        # print dividend, divisor\n        # print \"s=\", divisor, \"d=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        if dividend == 0:\n            return 0\n        # print dividend, divisor\n        # print \"s=\", divisor, \"d=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"s=\", divisor, \"d=\", dividend\n        # print \"s=\", divisor, \"d=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"s=\", divisor, \"d=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=\", divisor, \"s=\", dividend\n        # print \"d=",
    "class Solution(object):\n    def maxProduct(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num <= 0:\n            return 0\n\n        digits = [0] * 10\n        maxDigit = 0\n        for i in range(10):\n            temp = 1\n            for j in range(10):\n                if i + j <= num:\n                    temp *= (num - i - j + 1)\n                    digits[j] += temp\n                    maxDigit = max(digits[j], maxDigit)\n            digits[i] = temp\n\n        maxDigit = 0\n        for i in range(10):\n            temp = 0\n            for j in range(10):\n                if i + j <= num:\n                    temp += digits[j] * (num - i - j + 1)\n            maxDigit = max(maxDigit, temp)\n        return maxDigit\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxProduct(0) == 0\n    assert Solution().maxProduct(1) == 1\n    assert Solution().maxProduct(10) == 10\n    assert Solution().maxProduct(100) == 100\n    assert Solution().maxProduct(1000) == 1000\n    assert Solution().maxProduct(10000) == 10000",
    "class Solution:\n    # @return a tuple, (the first element is the maximum sum of digits, the second is the maximum sum of digits of the two parts)\n    def maxTwoSum(self, num):\n        if len(num) < 2:\n            return 0, 0\n\n        # dp[i] stores the maximum sum of digits for two part (i + 1)\n        dp = [0] * (len(num) + 1)\n        for i in range(len(dp)):\n            dp[i] = i\n\n        for i in range(len(num)):\n            for j in range(i + 1, len(num)):\n                # consider the two digits\n                # if the first digit is larger, the first digit is the maximum sum of digits\n                # if the second digit is larger, the second digit is the maximum sum of digits\n                dp[j] = max(dp[j], dp[j - 1] + num[i])\n\n        return dp[-1], dp[-1]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxTwoSum(10))\n    print(sol.maxTwoSum(20))\n    print(sol.maxTwoSum(30))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0:\n            return 0\n        if divisor == 0:\n            return 0\n\n        if dividend > divisor:\n            dividend, divisor = divisor, dividend\n\n        # keep the dividend in the range of [1, 10]\n        dividend, divisor = max(1, min(dividend, 10)), max(1, min(divisor, 10))\n\n        # get the first digit\n        first_digit = dividend % 10\n\n        # get the second digit\n        second_digit = divisor % 10\n\n        # get the third digit\n        third_digit = 0\n\n        # get the first digit of dividend and divisor\n        for i in range(first_digit, 3):\n            third_digit += int(dividend / 10 ** i) * 10 ** (3 - i)\n\n        for i in range(second_digit, 3):\n            third_digit += int(divisor / 10 ** i) * 10 ** (3 - i)\n\n        third_digit += int(dividend / 10 ** 3) * 10 ** (2 - 3)\n\n        third_digit += int(divisor / 10 ** 3) * 10 ** (2 - 3)\n\n        third_digit += int(dividend / 10 ** 6) * 10 ** (1 - 6)\n\n        third_digit += int(divisor / 10 ** 6) * 10 ** (1 - 6)\n\n        third_digit += int(dividend / 10 ** 9) * 10 ** (0 - 9)\n\n        third_digit += int(divisor / 10 ** 9) * 10 ** (0 - 9)\n\n        return third_digit\n\n        # get the first digit\n        # first_digit = dividend % 10\n\n        # get the second digit\n        # second_digit = divisor % 10\n\n        # get the third digit\n        # third_digit = 0\n\n        # get the first digit of dividend and divisor\n        # for i in range(first_digit, 3):\n        #",
    "class Solution:\n    # @param {integer} num\n    # @return {integer[]}\n    def splitIntoPieces(self, num):\n        # Write your code here\n        result = []\n        if num < 0:\n            return result\n        \n        while num:\n            result.append(num % 10)\n            num /= 10\n        return result",
    "class Solution(object):\n    def maxProduct(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 1\n        if num == 1:\n            return 2\n        ret = 0\n        for i in xrange(1, 10):\n            ret = max(ret, self.maxProduct(num - i) + self.maxProduct(i))\n        return ret\n\nif __name__ == \"__main__\":\n    print Solution().maxProduct(15)",
    "class Solution:\n    # @param {integer} num\n    # @return {integer[]}\n    def splitIntoParts(self, num):\n        if num <= 0:\n            return []\n        if num == 1:\n            return [1]\n        if num == 2:\n            return [1,2]\n        \n        max_sum = 0\n        max_sum_index = 0\n        for i in range(1, num):\n            if i <= num // 2:\n                max_sum += i\n            else:\n                max_sum += num - i\n                if max_sum > max_sum_index:\n                    max_sum_index = max_sum\n        return [1,max_sum_index]",
    "# https://discuss.leetcode.com/topic/58194/java-solution-using-python-dp-solution-and-iterative-dp-solution\nclass Solution:\n    # @param {integer} n\n    # @return {integer}\n    def maxTwoSum(self, n):\n        # Write your code here\n        d = {}\n        for i in xrange(n):\n            d[i] = i\n\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if d[i] + j not in d and d[j] + i not in d:\n                    d[i] += j\n                    d[j] += i\n                    d[i] = max(d[i], d[j])\n                    break\n        return max(d.values())\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxTwoSum(100)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend_str = str(dividend)\n        divisor_str = str(divisor)\n        dividend_len = len(dividend_str)\n        divisor_len = len(divisor_str)\n        dividend_list = list(dividend_str)\n        divisor_list = list(divisor_str)\n        max_sum = 0\n        for i in range(divisor_len - 1):\n            for j in range(dividend_len - i - 1, -1, -1):\n                dividend_list[j] = '0'\n                dividend_list[i] = '1'\n                divisor_list[i] = '0'\n                divisor_list[j] = '1'\n                dividend_str = ''.join(dividend_list)\n                divisor_str = ''.join(divisor_list)\n                dividend_sum = 0\n                divisor_sum = 0\n                for i in range(len(dividend_str)):\n                    dividend_sum += int(dividend_str[i])\n                for i in range(len(divisor_str)):\n                    divisor_sum += int(divisor_str[i])\n                if dividend_sum > divisor_sum:\n                    max_sum = max(max_sum, dividend_sum)\n        return max_sum\n\n\nif __name__ == '__main__':\n    assert Solution().divide(11, 3) == 3\n    assert Solution().divide(11, 4) == 2\n    assert Solution().divide(11, 5) == 2\n    assert Solution().divide(11, 6) == 2\n    assert Solution().divide(11, 7) == 2\n    assert Solution().divide(11, 8) == 2\n    assert Solution().divide(11, 9) == 2\n    assert Solution",
    "class Solution:\n    def maxTwoSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i!= j and nums[i] + nums[j] > nums[i] + nums[j + 1]:\n                    return nums[i] + nums[j]\n        return nums[0] + nums[len(nums) - 1]",
    "class Solution(object):\n    def splitIntoPieces(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        if num <= 0:\n            return []\n        \n        result = []\n        max_len = 0\n        for i in range(10):\n            remain = num % 10\n            num /= 10\n            if remain == 0:\n                max_len = max(max_len, 1)\n                continue\n            result.append(remain)\n            max_len = max(max_len, len(str(remain)))\n            \n        return result + [0] * (max_len - len(result))\n\n\nif __name__ == '__main__':\n    print Solution().splitIntoPieces(10)",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend < 0:\n            return self.divide(-dividend, divisor)\n        if divisor < 0:\n            return self.divide(dividend, -divisor)\n        #dividend = abs(dividend)\n        #divisor = abs(divisor)\n        #if dividend > divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend < divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend == divisor:\n        #    return dividend\n        #return self.divide(dividend, divisor)\n        #\n        #\n        #divisor = abs(divisor)\n        #dividend = abs(dividend)\n        #if dividend >= divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend < divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend == divisor:\n        #    return dividend\n        #return self.divide(dividend, divisor)\n        #\n        #\n        #divisor = abs(divisor)\n        #dividend = abs(dividend)\n        #if dividend >= divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend < divisor:\n        #    return self.divide(dividend, divisor)\n        #if dividend == divisor:\n        #    return dividend\n        #return self.divide(dividend, divisor)\n        #\n        #\n        #divisor = abs(divisor)\n        #dividend = abs(dividend)\n        #if dividend >= divisor:\n        #    return self",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # dp[i] is the maximum sum of digits of the number i\n        dp = [0] * (dividend + 1)\n        for i in range(len(dp)):\n            dp[i] = i\n        for i in range(len(dp)):\n            if divisor < 0:\n                divisor = -divisor\n            if divisor == 0:\n                return max(dp)\n            while dividend >= divisor:\n                if dividend % divisor == 0:\n                    dp[dividend] = max(dp[dividend], dp[dividend - divisor] + 1)\n                    dividend -= divisor\n                else:\n                    divisor = divisor - 1\n        return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert Solution().divide(15, -2) == 3\n    assert Solution().divide(1, -2) == 0\n    assert Solution().divide(13, -2) == 3\n    assert Solution().divide(1, -2) == 0\n    assert Solution().divide(13, -3) == 1\n    assert Solution().divide(1, -3) == 0\n    assert Solution().divide(13, -3) == 1\n    assert Solution().divide(123, -3) == 3\n    assert Solution().divide(123, -3) == 3\n    assert Solution().divide(123, -3) == 3\n    assert Solution().divide(123, -3) == 3",
    "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > target:\n                break\n            if i+1 < len(nums):\n                if nums[i] + nums[i+1] > target:\n                    return [i+1, i+1]\n        return [0, len(nums)-1]",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while dividend > 0:\n            dividend, divisor = divisor, dividend % divisor\n            res = max(res, divisor)\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().divide(100, 10) == 22\n    assert Solution().divide(100, 100) == 1\n    assert Solution().divide(100, 100) == 1",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while dividend >= divisor:\n            res = max(res, max(self.write_dividend(dividend, divisor),\n                              self.write_dividend(dividend - divisor, divisor)))\n            dividend -= divisor\n        return res\n\n    def write_dividend(self, dividend, divisor):\n        digits = []\n        while dividend >= divisor:\n            digits.append(dividend % 10)\n            dividend = dividend // 10\n        digits.reverse()\n        return sum(digits)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.divide(99, 9))",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # dp[i] = max(dp[i-1], dp[i-2] + dp[i-3])\n        dp = [0] * (divisor + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, dividend + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + dp[i - 3])\n\n        return dp[dividend]\n\ns = Solution()\nprint(s.divide(20, 4))",
    "class Solution(object):\n    def maxProduct(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        max_product = 0\n        max_digit = 0\n        for i in range(len(str(num))):\n            max_digit = max(max_digit, 1)\n            max_digit = max(max_digit, num % 10)\n            max_product = max(max_product, max_digit * 10 ** (len(str(num)) - i - 1))\n        return max_product\n\nif __name__ == \"__main__\":\n    print Solution().maxProduct(8)\n    print Solution().maxProduct(123)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def maxNumber(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        ans = self.maxNumber(root.left)\n        ans = max(ans, self.maxNumber(root.right))\n        ans = max(ans, self.sumOfDigits(root.val))\n        return ans\n\n    def sumOfDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        ans = 0\n        while num > 0:\n            ans += num % 10\n            num /= 10\n        return ans\n\nif __name__ == '__main__':\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(1)\n    root.right.right = TreeNode(7)\n    print Solution().maxNumber(root)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        if dividend == divisor:\n            return 1\n        if dividend > divisor:\n            return self.divide(dividend - divisor, divisor)\n        if dividend < divisor:\n            return self.divide(dividend, divisor - 1)\n        return 0\n\n\nif __name__ == '__main__':\n    assert Solution().divide(1, 2) == 0\n    assert Solution().divide(2, 1) == 1\n    assert Solution().divide(2, 2) == 1\n    assert Solution().divide(3, 2) == 2\n    assert Solution().divide(4, 2) == 2\n    assert Solution().divide(4, 3) == 2\n    assert Solution().divide(5, 3) == 2\n    assert Solution().divide(6, 3) == 3\n    assert Solution().divide(7, 3) == 3\n    assert Solution().divide(8, 3) == 3\n    assert Solution().divide(9, 3) == 3\n    assert Solution().divide(10, 3) == 3\n    assert Solution().divide(100, 3) == 3\n    assert Solution().divide(1000, 3) == 3\n    assert Solution().divide(10000, 3) == 3\n    assert Solution().divide(100000, 3) == 3\n    assert Solution().divide(1000000, 3) == 3",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        if dividend % divisor == 0:\n            return 0\n        if dividend > divisor:\n            return 1\n        if dividend < divisor:\n            return 2\n        # if dividend == divisor:\n        #     return 3\n        max_digits = 0\n        while dividend!= 0:\n            dividend, digit = divmod(dividend, divisor)\n            if digit > max_digits:\n                max_digits = digit\n        return max_digits",
    "import sys\n\n\ndef main():\n    if len(sys.argv)!= 2:\n        sys.exit('usage:./divide_number.py num')\n\n    num = int(sys.argv[1])\n    print(divide_number(num))\n\n\ndef divide_number(num):\n    if num < 10:\n        return num\n\n    left_part, right_part = 0, 0\n    while num:\n        digit = num % 10\n        num = num // 10\n        left_part = max(left_part, digit)\n        right_part += digit\n\n    return max(left_part, right_part)\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(str(dividend))):\n            tmp = divisor\n            while tmp > 0:\n                result = max(result, int(str(dividend)[i]))\n                tmp -= 1\n        return result\n\n\nif __name__ == \"__main__\":\n    print Solution().divide(1729, 10)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxSumOfTwo(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        def max_sum(node, left, right):\n            if not node:\n                return 0\n            if not left and not right:\n                return node.val\n            if left and right:\n                if node.val < left.val + right.val:\n                    return max_sum(node.left, left, node)\n                else:\n                    return max_sum(node.right, node, right)\n            elif left:\n                return max_sum(node.left, left, right)\n            else:\n                return max_sum(node.right, left, right)\n        if not root:\n            return 0\n        return max_sum(root, None, None)",
    "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend == 0 or divisor == 0:\n            return 0\n        if dividend >= divisor:\n            return 0\n        if dividend < divisor:\n            return 1\n        result = 0\n        while dividend > 0:\n            dividend, divisor = divisor, dividend % divisor\n            result += 1\n        return result\n\n\nif __name__ == '__main__':\n    print Solution().divide(12345, 11)\n    print Solution().divide(12345, 22)\n    print Solution().divide(12345, 33)",
    "def max_sum_digit(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    n = str(n)\n    sum = 0\n    for i in range(len(n)):\n        sum += n[i]\n        if sum >= 10:\n            break\n    return sum\n\n# Note:\n# The solution above is not efficient, because the loop is executed many times.\n# A better way is to use an extra variable to track the highest number of digits in the number.\n# Another way is to use a counter variable instead of a loop.\n# The second solution is more concise and easier to understand.",
    "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def divide(self, n):\n        digits = [0] * 10\n        while n:\n            digits[n % 10] += 1\n            n /= 10\n\n        s = 0\n        for i in range(10):\n            if digits[i] > digits[s]:\n                s = i\n        return s, s + 1",
    "class Solution:\n    # @return a tuple, (index1, index2)\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: tuple\n        \"\"\"\n        divisor, r = divmod(dividend, divisor)\n        return divisor, r\n\n    def maxDigitSub(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend < divisor:\n            return self.maxDigitSub(dividend, divisor)\n        if dividend == divisor:\n            return dividend\n        if dividend > divisor:\n            return self.maxDigitSub(dividend - divisor, divisor)\n        if dividend == divisor:\n            return dividend\n\n        digits = [10 ** 9] * 10\n        dividend, r = self.divide(dividend, divisor)\n        digits[0] = 1\n        for i in range(1, 10):\n            digits[i] = min(digits[i - 1] + (dividend % 10 ** i), digits[i - 1])\n        digits[0] = max(digits[0], digits[0] + r)\n        return digits[0]\n\n    def maxDigitSub2(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend < divisor:\n            return self.maxDigitSub2(dividend, divisor)\n        if dividend == divisor:\n            return dividend\n        if dividend > divisor:\n            return self.maxDigitSub2(dividend - divisor, divisor)\n        if dividend == divisor:\n            return dividend\n\n        if dividend % divisor == 0:\n            return dividend\n        if dividend % divisor == divisor - 1:\n            return self.maxDigitSub2(dividend / divisor",
    "import math\n\n\ndef divide_into_two(num):\n    if num == 0:\n        return 0, 0\n\n    if num % 10 == 0:\n        return num / 10, 0\n\n    if num % 100 == 0:\n        return num / 100, 1\n\n    if num % 1000 == 0:\n        return num / 1000, 2\n\n    return num / 1000, 3\n\n\ndef main():\n    num = int(input())\n    print(max(divide_into_two(num)))\n\nif __name__ == \"__main__\":\n    main()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}