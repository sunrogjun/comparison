{
  "problem": {
    "task_id": "MBPP/110",
    "prompt": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.",
    "canonical_solution": "def extract_missing(test_list, strt_val, stop_val):\r\n  res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res) ",
    "test_list": [
      "assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]",
      "assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]",
      "assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]"
    ],
    "challenge_test_list": [],
    "problem_id": 99
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        if start == end:\n            return [range(start, end + 1)]\n        \n        for i in range(start, end + 1):\n            if i not in nums:\n                res.append(range(start, i))\n                \n        return res",
    "#!/usr/bin/env python\n\nclass Range:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @return {integer[][]}\n    def missingRanges(self, intervals):\n        intervals.sort()\n        ranges = []\n        i = 0\n        while i < len(intervals):\n            if i == len(intervals) - 1 or intervals[i]!= intervals[i + 1]:\n                ranges.append(Range(intervals[i], intervals[i + 1]))\n                i += 1\n            else:\n                i += 1\n        missing = []\n        for i in range(len(intervals)):\n            for j in range(len(ranges)):\n                if j >= len(ranges) or ranges[j].start > intervals[i]:\n                    missing.append(intervals[i])\n                    break\n        return missing\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.missingRanges([1, 2, 3, 4, 5])",
    "def missing_ranges(l, s, e):\n    return [x for x in l if x < s or x > e]\n\nif __name__ == \"__main__\":\n    l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param nums, a list of integer\n    # @param start, an integer\n    # @param end, an integer\n    # @return a list of lists of integers\n    def missingRanges(self, nums, start, end):\n        if start > end:\n            return [nums]\n        \n        ans = []\n        for i in range(start, end+1):\n            ans += [nums[i-start:i]]\n        return ans",
    "# https://www.hackerrank.com/challenges/missing-ranges/problem\n\nimport math\n\n\ndef missing_ranges(start, end, list_of_ranges):\n    \"\"\"\n    :param start: int\n    :param end: int\n    :param list_of_ranges: list of ints\n    :return: list of ranges\n    \"\"\"\n\n    ranges = []\n\n    for i in range(start, end):\n        if i not in list_of_ranges:\n            ranges.append((start, i))\n\n    return ranges\n\n\nif __name__ == \"__main__\":\n    start, end, list_of_ranges = map(int, input().split())\n\n    ranges = missing_ranges(start, end, list_of_ranges)\n\n    print(ranges)",
    "def findMissingRanges(arr, start, end):\n    if start == end:\n        return [start]\n    if arr[start] >= arr[end]:\n        return []\n    if arr[start] > arr[end]:\n        return []\n    start_range = start\n    end_range = end\n    while arr[start_range] > arr[end_range]:\n        start_range += 1\n    while arr[end_range] < arr[start_range]:\n        end_range -= 1\n    return findMissingRanges(arr, start_range, end_range) + [end_range]\n\n\narr = [0, 1, 3, 4, 5, 6, 8, 9]\nprint(findMissingRanges(arr, 2, 5))",
    "def get_missing_range(ranges, start, end):\n    for i in range(start, end+1):\n        if i not in ranges:\n            return i\n\ndef main():\n    ranges = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]\n    start = 4\n    end = 23\n    missing_range = get_missing_range(ranges, start, end)\n    print(missing_range)\n\nif __name__ == '__main__':\n    main()",
    "# Write your code here\ndef missing_ranges(arr, start_range, end_range):\n    # write your code here\n    return\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    start_range = 4\n    end_range = 7\n    missing_ranges(arr, start_range, end_range)\n    # print(arr)\n    # print(start_range)\n    # print(end_range)\n    # print(missing_ranges(arr, start_range, end_range))\n    # print(missing_ranges(arr, start_range, end_range))",
    "# Thought: https://leetcode.com/problems/missing-ranges/solution/\n\n# @param {number[]} nums\n# @param {number} start\n# @param {number} end\n# @return {number[]}\n\n# @example\n# nums = [1,3,5,6]\n# start = 2\n# end = 4\n# return [1,3]\n\nclass Solution:\n    # @param {number[]} nums\n    # @param {number} start\n    # @param {number} end\n    # @return {number[]}\n    def missingRanges(self, nums, start, end):\n        result = []\n        for i in range(start, end+1):\n            if i not in nums:\n                result.append(i)\n        return result\n\nif __name__ == \"__main__\":\n    print(Solution().missingRanges([1,3,5,6], 2, 4))",
    "class Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n        if start < 0:\n            start = 0\n        if end < 0:\n            end = 0\n        if start == end:\n            return [start]\n        ret = []\n        for i in xrange(start, end+1):\n            if i not in nums:\n                ret.append(i)\n        return ret\n\nif __name__ == \"__main__\":\n    print Solution().findMissingRanges([2, 3, 4, 5, 6], 1, 6)\n    print Solution().findMissingRanges([1, 2, 3, 4, 5, 6], 0, 6)",
    "class Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        if s > e:\n            return []\n        if s == e:\n            return [s]\n        if s < e:\n            return [s, e]\n        # s > e\n        # s is the start of the range\n        # e is the end of the range\n        # e is the start of the range\n        # s is the start of the range\n        # e is the end of the range\n        # e is the start of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        # s is the start of the range\n        # e is the end of the range\n        #",
    "import sys\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        ranges = []\n        ranges.append(s)\n        ranges.append(e)\n        if s <= e:\n            for i in xrange(s, e + 1):\n                if i > nums[0]:\n                    ranges.append(nums[0])\n                for j in xrange(1, len(nums)):\n                    if nums[j] > i:\n                        ranges.append(nums[j])\n        return ranges\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findMissingRanges([1, 3, 5, 6], 0, 5)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 3)\n    print s.findMissingRanges([1, 3, 5, 6], 2, 4)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 2)\n    print s.findMissingRanges([1, 3, 5, 6], 5, 6)\n    print s.findMissingRanges([1, 3, 5, 6], 5, 6)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 6)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 5)\n    print s.findMissingRanges([1, 3, 5, 6], 3, 5)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 3)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 5)\n    print s.findMissingRanges([1, 3, 5, 6], 1, 6)\n    print s.findMissingRanges([1, 3, 5, 6], 2, 4)\n    print s.findMissingRanges([1, 3, 5, 6], 2, 5)",
    "# https://leetcode.com/problems/missing-ranges/\n\n\n# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMissingRanges(self, root: TreeNode, s: int, e: int) -> List[List[int]]:\n        ranges = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node is None:\n                continue\n            if node.val < s or node.val > e:\n                ranges.append([node.val, node.val])\n            else:\n                stack.append(node.left)\n                stack.append(node.right)\n        return ranges",
    "class Solution:\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n        l = [start]\n        r = [end]\n        for i in xrange(start, end):\n            if l[-1] < i < r[-1]:\n                l.append(i)\n            elif l[-1] > i > r[-1]:\n                r.append(i)\n        return l + r[1:]",
    "# https://www.hackerrank.com/challenges/missing-ranges\n# input\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n# 1 3\n# 1 5\n# 4 3\n# 5 4\n# 2 2\n# 1 1\n#",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def findMissingRanges(self, root: TreeNode, start: int, end: int) -> List[List[int]]:\n        def helper(root, start, end, res):\n            if not root:\n                return\n            if root.val >= start and root.val <= end:\n                res.append([root.val, end])\n            elif root.val > end:\n                return\n            helper(root.left, start, root.val, res)\n            helper(root.right, root.val, end, res)\n\n        res = []\n        helper(root, start, end, res)\n        return res\n\n    # @param root, a tree node\n    # @param start, an integer\n    # @param end, an integer\n    # @return a list of lists of integers\n    def findMissingRanges(self, root: TreeNode, start: int, end: int) -> List[List[int]]:\n        if not root:\n            return []\n        if root.val > start and root.val < end:\n            return [[root.val, end]]\n        if root.val >= start and root.val <= end:\n            return []\n        return self.findMissingRanges(root.left, start, end) + self.findMissingRanges(root.right, start, end)",
    "# https://www.hackerrank.com/challenges/missing-ranges/problem\n\n#!/usr/bin/python\n\nfrom collections import Counter\n\nn = int(input())\nranges = [[]] * n\n\nfor i in range(n):\n    ranges[i].append(int(input()))\n\nranges = list(zip(*ranges))\n\nfor i in range(n):\n    if i == 0:\n        continue\n    for j in range(i):\n        if ranges[i][0] <= ranges[j][1] and ranges[i][1] >= ranges[j][0]:\n            ranges[i][0] = min(ranges[i][0], ranges[j][0])\n            ranges[i][1] = max(ranges[i][1], ranges[j][1])\n\nfor i in range(n):\n    if ranges[i][1] < ranges[i][0]:\n        ranges[i][1] = ranges[i][0]\n\nfor i in range(n):\n    if ranges[i][1] - ranges[i][0] < 1:\n        ranges[i][1] += 1\n\nfor i in range(n):\n    print(ranges[i][0], ranges[i][1])\n\nprint(Counter(ranges).most_common(1))",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        if s > e:\n            return []\n\n        if s == e:\n            return [s]\n\n        ans = []\n        for i in range(s, e):\n            ans.append(i)\n\n        for i in range(s, e):\n            for j in range(i + 1, e + 1):\n                if nums[i] > nums[j]:\n                    ans.append(j)\n\n        return ans",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start < 0 or end < 0 or start > end:\n            return []\n\n        if start == end:\n            return [start]\n\n        if start > end:\n            return []\n\n        ret = []\n        for i in xrange(start, end + 1):\n            if i not in nums:\n                ret.append(i)\n\n        return ret\n\n\nif __name__ == \"__main__\":\n    print Solution().findMissingRanges([1, 2, 3, 4, 5], 1, 5)",
    "class Solution(object):\n    def getRange(self, arr, start, end):\n        \"\"\"\n        :type arr: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start < end:\n            return [start, end]\n        if start == end:\n            return [start]\n        mid = (start + end) / 2\n        ret = self.getRange(arr, start, mid)\n        ret.extend(self.getRange(arr, mid, end))\n        return ret\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    arr = [1,2,3,4,5,6,7,8]\n    print(s.getRange(arr, 1, 7))\n    print(s.getRange(arr, 1, 8))",
    "# https://leetcode.com/problems/missing-ranges/\nclass Solution(object):\n    def missingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[List[int]]\n        \"\"\"\n        dic = {}\n        for i in range(len(nums)):\n            if i in dic:\n                dic[i] += 1\n            else:\n                dic[i] = 1\n\n        # print dic\n        ans = []\n        for i in range(len(nums)):\n            if i not in dic or dic[i] < 2:\n                ans.append([nums[i], nums[i]])\n            else:\n                for j in range(s, e+1):\n                    if i in dic:\n                        if j > i and j < e:\n                            ans.append([nums[i], nums[j]])\n                    elif j < i:\n                        if j > i:\n                            ans.append([nums[i], nums[j]])\n        return ans",
    "# Definition for a range.\n# class Range:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def missingRanges(self, nums: List[int], start: int, end: int) -> List[Range]:\n        return [Range(start, end)]\n\n# Test",
    "def getMissingRanges(ranges, start, end):\n    if not ranges:\n        return []\n    if start > end:\n        return []\n    if start < 1:\n        start = 1\n    if end > len(ranges):\n        end = len(ranges)\n    missing = []\n    for i in range(start, end):\n        if i not in ranges:\n            missing.append(i)\n    return missing\n\nif __name__ == '__main__':\n    ranges = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]\n    print getMissingRanges(ranges, 1, 100)",
    "def missing_ranges(ranges, start, end):\n    ranges_to_check = [r for r in range(start, end+1)]\n    return [r for r in ranges if r not in ranges_to_check]\n\nif __name__ == '__main__':\n    ranges = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220",
    "def get_missing_ranges(start_range, end_range, list_range):\n    \"\"\"\n    Input: start_range, end_range, list_range.\n    Output: a list of missing ranges.\n    \"\"\"\n    return list(set(list_range) - set(range(start_range, end_range+1)))\n\ndef main():\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert get_missing_ranges(1, 3, [1, 2, 3]) == [], \"test_range_1\"\n    assert get_missing_ranges(1, 3, [1, 2]) == [], \"test_range_2\"\n    assert get_missing_ranges(1, 3, [1, 2, 3, 4]) == [], \"test_range_3\"\n    assert get_missing_ranges(2, 4, [1, 2, 3]) == [], \"test_range_4\"\n    assert get_missing_ranges(1, 2, [1, 2]) == [], \"test_range_5\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4]) == [], \"test_range_6\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5]) == [], \"test_range_7\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5, 6]) == [], \"test_range_8\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5, 6, 7]) == [], \"test_range_9\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5, 6, 7, 8]) == [], \"test_range_10\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == [], \"test_range_11\"\n    assert get_missing_ranges(1, 2, [1, 2, 3, 4, 5, 6",
    "def missing_ranges(ranges, start, end):\n    \"\"\"\n    Input: start and end range values\n    Output: a list of missing ranges\n    \"\"\"\n    # TODO: write code\n    return []\n\nif __name__ == '__main__':\n    ranges = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    start = 3\n    end = 7\n    missing_ranges(ranges, start, end)\n    print missing_ranges(ranges, start, end)",
    "class Solution:\n    def getMissingRanges(self, ranges: List[int], start: int, end: int) -> List[List[int]]:\n        if start >= end:\n            return []\n        ret = []\n        for r in range(start, end + 1):\n            for i in range(r - 1, -1, -1):\n                if i < 0:\n                    continue\n                if r in ranges:\n                    break\n            else:\n                ret.append([r])\n            for i in range(r - 1, -1, -1):\n                if i < 0:\n                    continue\n                if r not in ranges:\n                    break\n                ret[-1].append(i)\n        return ret\n\n\na = Solution()\nprint(a.getMissingRanges([1, 3, 5], 0, 5))\nprint(a.getMissingRanges([1, 3, 5], 0, 4))\nprint(a.getMissingRanges([1, 3, 5], 0, 6))\nprint(a.getMissingRanges([1, 3, 5], 0, 7))\nprint(a.getMissingRanges([1, 3, 5], 0, 8))",
    "# https://leetcode.com/problems/missing-ranges/\n# Write a function to find the missing ranges in an integer array.\n# The function returns an array of missing ranges.\n# The range (start, end] is a missing range, where start and end are inclusive.\n# Example 1:\n# Input: nums = [0,1,3], start = 1, end = 2\n# Output: [Range(0,1), Range(3,3)]\n# Example 2:\n# Input: nums = [0], start = 0, end = 0\n# Output: []\n# Note:\n# The length of the given nums will not exceed 50,000.\n# The given start and end are all valid.\n# The given start and end are both smaller than the size of nums.\n# The given nums's size is at most 5000.\n#\n\n# 2018.02.18\nclass Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[Range]\n        \"\"\"\n        if start > end:\n            return []\n        if start < 0:\n            start = 0\n        if end > len(nums):\n            end = len(nums)\n        result = []\n        for i in range(start, end + 1):\n            if i > 0 and nums[i-1] == nums[i]:\n                continue\n            if nums[i] > nums[i-1]:\n                result.append(Range(nums[i-1], nums[i]))\n        return result\n\nclass Range(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nif __name__ == \"__main__\":\n    print(Solution().findMissingRanges([0,1,3], 1, 2))",
    "# Definition for a Range.\nclass Range:\n    def __init__(self, start: int, end: int):\n        self.start = start\n        self.end = end\n\n    def __str__(self):\n        return '[' + str(self.start) + ','+ str(self.end) + ']'\n\nclass Solution:\n    def missingRanges(self, nums: List[int], start: int, end: int) -> List[Range]:\n        ranges = []\n        for i in range(start, end + 1):\n            if i in nums:\n                continue\n            if i == start or i == end:\n                ranges.append(Range(start, i))\n            else:\n                ranges.append(Range(i, end))\n        return ranges\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 3, 5, 6]\n    ranges = sol.missingRanges(nums, 1, 5)\n    print(ranges)\n    nums = [1, 2, 3, 4]\n    ranges = sol.missingRanges(nums, 1, 4)\n    print(ranges)\n    nums = [1, 3, 5, 7]\n    ranges = sol.missingRanges(nums, 1, 7)\n    print(ranges)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    ranges = sol.missingRanges(nums, 1, 8)\n    print(ranges)",
    "class Solution:\n    # @param {integer[]} intervals\n    # @param {integer} start\n    # @param {integer} end\n    # @return {integer[]}\n    def findDisappearedNumbers(self, intervals: List[int], start: int, end: int) -> List[int]:\n        result = []\n        i = 0\n        while i < len(intervals):\n            if intervals[i] >= start and intervals[i] <= end:\n                i += 1\n            elif intervals[i] > end:\n                result.append(intervals[i - 1] + 1)\n                i += 1\n            elif intervals[i] < start:\n                result.append(intervals[i])\n                i += 1\n        return result",
    "from collections import defaultdict\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        d = defaultdict(int)\n        for num in nums:\n            d[num] += 1\n        \n        # d[s:e] is the range that is not used\n        ranges = []\n        for key in d:\n            if key < s or key > e:\n                ranges.append(key)\n        \n        return ranges",
    "# https://leetcode.com/problems/missing-ranges/discuss/83861/Python-Solution-with-explanation\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        ranges = [s, e]\n        for i in range(s, e):\n            if i not in nums:\n                ranges.append(i)\n        return ranges",
    "from collections import Counter\nfrom itertools import islice\nfrom typing import List\n\n__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def get_missing_ranges(self, nums: List[int], start: int, end: int) -> List[List[int]]:\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if start > end:\n            return [nums[:start]]\n\n        # make sure that start is inclusive\n        start += 1\n\n        # make sure that end is exclusive\n        end -= 1\n\n        # get the number of missing ranges\n        num_ranges = (end - start) / 2 + 1\n\n        # get the list of missing ranges\n        ranges = [nums[start:start + i] for i in range(num_ranges)]\n\n        # return the list of missing ranges\n        return ranges\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.get_missing_ranges([1, 3, 5, 7], 1, 3))",
    "# https://www.hackerrank.com/challenges/missing-ranges/problem\n\n# Complete the missingRanges function below.\ndef missingRanges(arr):\n    # Complete this function\n    if len(arr) == 0:\n        return 0\n\n    end = arr[0]\n    start = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > end:\n            end = arr[i]\n        if arr[i] < start:\n            start = arr[i]\n    if start > end:\n        return 0\n    return 1 + missingRanges(arr[(end + 1) : ]) + missingRanges(arr[:(start - 1)])\n\nprint(missingRanges([1,2,3,4,5,6,7,8,9,10]))",
    "# https://leetcode.com/problems/missing-ranges/\nclass Solution(object):\n    def findMissingRanges(self, ranges, lower, upper):\n        \"\"\"\n        :type ranges: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[int]\n        \"\"\"\n        res = [lower]\n        for i in xrange(1, len(ranges)):\n            if ranges[i-1] < lower:\n                res.append(lower)\n            if ranges[i] > upper:\n                res.append(upper)\n            lower = ranges[i-1]\n            upper = ranges[i]\n        if lower < upper:\n            res.append(upper)\n        return res\n\n# https://leetcode.com/problems/missing-ranges/solution/\nclass Solution1(object):\n    def findMissingRanges(self, ranges, lower, upper):\n        \"\"\"\n        :type ranges: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[int]\n        \"\"\"\n        res = [lower]\n        for i in xrange(1, len(ranges)):\n            if ranges[i-1] < lower:\n                res.append(lower)\n            if ranges[i] > upper:\n                res.append(upper)\n            lower = ranges[i-1]\n            upper = ranges[i]\n        if lower < upper:\n            res.append(upper)\n        return res\n\n# https://leetcode.com/problems/missing-ranges/solution/\nclass Solution2(object):\n    def findMissingRanges(self, ranges, lower, upper):\n        \"\"\"\n        :type ranges: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[int]\n        \"\"\"\n        res = [lower]\n        for i in xrange(1, len(ranges)):\n            if ranges[i-1] < lower:\n                res.append(lower)\n            if ranges[i] > upper:\n                res.append(upper)\n            lower = ranges",
    "class Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if start > end:\n            return []\n        if start == end:\n            return [start]\n        if start > end:\n            return []\n        \n        if n == 1:\n            return [start, end]\n        \n        start_idx = bisect.bisect_right(nums, start)\n        end_idx = bisect.bisect_left(nums, end)\n        \n        return [nums[start_idx - 1], nums[end_idx]]",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[str]\n        \"\"\"\n        sorted_nums = sorted(nums)\n        if s < 0 or e < 0 or s > e or e > len(nums):\n            return []\n        if s == e:\n            return [str(s)]\n        if s == 0:\n            return [str(0)]\n        if e == len(nums) - 1:\n            return [str(s + 1)]\n\n        i = s\n        j = e\n        while i < j:\n            while i < j and sorted_nums[i] <= s:\n                i += 1\n            while i < j and sorted_nums[j] > e:\n                j -= 1\n            if i < j:\n                yield str(s + 1) + \"->\" + str(s + i - 1)\n            s = i\n            i += 1\n            e = j\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 6]\n    s, e = 2, 4\n    print Solution().findMissingRanges(nums, s, e)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n        nums.sort()\n        result = []\n        i = start\n        while i < end:\n            if nums[i]!= i + 1:\n                result.append(i + 1)\n                i += 1\n            else:\n                i += 1\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [1, 3, 5, 6]\n    print s.findMissingRanges(nums, 1, 5)",
    "# https://leetcode.com/problems/missing-ranges/discuss/92631/Python-Solution-with-explanation\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[str]\n        \"\"\"\n        if s == e:\n            return []\n        if s > e:\n            return []\n        i, j = s, e\n        ranges = []\n        while i < j:\n            ranges.append(\"%s->%s\" % (i, j))\n            i += 1\n            j -= 1\n        return ranges",
    "# https://www.codewars.com/kata/54c0e7c8d09f6d9c2c18e0e/train/python\n\n# TODO:\n#   - Check if the input range is valid\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order\n#   - Check if the input range is in ascending order",
    "class Solution:\n    def get_missing_ranges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for i in range(start, end+1):\n            if i not in nums:\n                ret.append(i)\n        return ret",
    "def find_ranges(numbers, start, end):\n    \"\"\"\n    :type numbers: List[int]\n    :type start: int\n    :type end: int\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    if start <= end:\n        for i in range(start, end + 1):\n            if i not in numbers:\n                result.append(i)\n    else:\n        for i in range(start, end + 1):\n            if i not in numbers:\n                result.append(i)\n            else:\n                result.append(i + 1)\n\n    return result\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    start = 1\n    end = 5\n    result = find_ranges(numbers, start, end)\n    print(result)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def findMissingRanges(self, root: TreeNode, start: int, end: int) -> List[int]:\n        res = []\n        def dfs(node):\n            if not node:\n                return\n            if node.val >= start and node.val <= end:\n                res.append(node.val)\n            if node.left:\n                dfs(node.left)\n            if node.right:\n                dfs(node.right)\n        dfs(root)\n        return res",
    "# https://leetcode.com/problems/missing-ranges/description/\n\nclass Solution(object):\n    def findRange(self, nums, m, n):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m > n or n > m+1:\n            return []\n\n        nums.sort()\n        start = 0\n        end = 0\n        for i in range(len(nums)):\n            if nums[i] == m:\n                start = i+1\n            if nums[i] == n:\n                end = i+1\n            if start > end:\n                return []\n        return [start, end]\n\n# test\nnums = [3,2,5,1,7,6,4,9]\nm = 2\nn = 5\nassert Solution().findRange(nums, m, n) == [2, 4]",
    "def extract(ranges, start, end):\n\tfor i in range(start, end):\n\t\tif i not in ranges:\n\t\t\tranges.append(i)\n\ndef main():\n\tprint extract([], 0, 5)\n\tprint extract([1, 2, 3], 0, 5)\n\tprint extract([1, 2, 3, 4, 5], 0, 5)\n\tprint extract([1, 2, 3, 4, 5], 2, 4)\n\tprint extract([1, 2, 3, 4, 5], 2, 5)\n\tprint extract([1, 2, 3, 4, 5], 3, 5)\n\nif __name__ == '__main__':\n\tmain()",
    "# Definition for a interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findRange(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in xrange(len(intervals)):\n            if i == 0:\n                continue\n            if intervals[i].end < intervals[i - 1].end:\n                res.append(intervals[i])\n        return res\n\n    def findRange1(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in xrange(len(intervals)):\n            if i == 0:\n                continue\n            if intervals[i].end < intervals[i - 1].end:\n                res.append(intervals[i])\n            else:\n                res.append(intervals[i - 1])\n        return res\n\n\nif __name__ == \"__main__\":\n    print Solution().findRange([Interval(1, 5), Interval(2, 6), Interval(3, 8)])\n    print Solution().findRange1([Interval(1, 5), Interval(2, 6), Interval(3, 8)])\n    print Solution().findRange([Interval(1, 5), Interval(2, 6), Interval(3, 8)])",
    "# https://leetcode.com/problems/missing-ranges/description/\n\n# Example 1:\n# Input: nums = [2,3,5]\n# start = 0, end = 2\n# Output: [1,2]\n# Explanation: There is only one range: [1,2]\n# Example 2:\n# Input: nums = [0,1,2,4,5,10]\n# start = 0, end = 4\n# Output: [0,2,4]\n# Explanation: There are three ranges: [0,1], [2,4], [5,10]\n# Example 3:\n# Input: nums = [0,1,2,3,4,5,6,7,8,9]\n# start = 0, end = 4\n# Output: [0,2,4]\n\n# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        i = start\n        while i < end:\n            if i in nums:\n                nums.remove(i)\n                ans.append(i)\n            else:\n                ans.append(end)\n            i += 1\n        if nums:\n            ans.append(nums[0])\n        return ans",
    "# https://leetcode.com/problems/missing-ranges/discuss/133499/Java-using-stack-and-recursion-to-solve-the-problem\n\n# 2018.03.06\n\nclass Solution:\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n\n        ret = []\n        if start == end:\n            ret.append(start)\n        if len(nums) == 1:\n            ret.append(start)\n            return ret\n\n        stack = []\n        for i in range(len(nums)):\n            if i == start:\n                stack.append(i)\n            if i == end:\n                ret.append(stack.pop())\n            elif i < end:\n                while len(stack) and nums[stack[-1]] < i:\n                    stack.pop()\n                if len(stack):\n                    ret.append(stack.pop())\n                else:\n                    ret.append(i)\n                    stack.append(i)\n        return ret\n\n\n# 2018.03.06\nclass Solution:\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n\n        if start == end:\n            return [start]\n        ret = []\n        if start == end:\n            ret.append(start)\n        if len(nums) == 1:\n            ret.append(start)\n            return ret\n\n        stack = []\n        for i in range(len(nums)):\n            if i == start:\n                stack.append(i)\n            if i == end:\n                ret.append(stack.pop())\n            elif i < end:\n                while len(stack) and nums[stack[-1]] < i:\n                    stack.pop()",
    "# https://leetcode.com/problems/missing-ranges/\n# https://leetcode.com/problems/missing-ranges/solution/\n# https://leetcode.com/problems/missing-ranges/discuss/113624/Easy-To-Understand-Solution-With-Java-Solutions\n# https://leetcode.com/problems/missing-ranges/discuss/113624/Java-Solutions\n# https://leetcode.com/problems/missing-ranges/discuss/113624/Java-Solutions\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} start\n    # @param {integer} end\n    # @return {integer[][]}\n    def findMissingRanges(self, intervals, start, end):\n        result = []\n        if end - start < 2:\n            return result\n        \n        for i in range(start, end):\n            if i not in intervals:\n                result.append([i, i])\n        \n        # remove duplicates\n        intervals = list(set(intervals))\n        \n        # now intervals is a list of unique integers\n        # we can do the following to make it a list of lists\n        intervals = [[x] for x in intervals]\n        \n        # now we have a list of lists\n        for i in range(1, len(intervals)):\n            if intervals[i]!= intervals[i-1]:\n                # we have a new interval\n                result.append(intervals[i-1])\n        \n        return result\n\n# Test cases\nprint(Solution().findMissingRanges([1,2,3,4,5], 1, 6))\nprint(Solution().findMissingRanges([1,2,3,4,5], 1, 6))\nprint(Solution().findMissingRanges([1,2,3,4,5], 1, 6))\nprint(Solution().findMissingRanges([1,2,3,4,5], 1, 6))\nprint(Solution().findMissingRanges([1,2,3,4,5], 1, 6))\nprint(Solution().findMissingRanges([1,2",
    "class Solution:\n    # @param startRange, an integer\n    # @param endRange, an integer\n    # @param numRanges, an integer\n    # @return an integer\n    def missingRanges(self, startRange, endRange, numRanges):\n        if startRange > endRange:\n            return 0\n        if numRanges == 1:\n            return 1\n        if startRange == endRange:\n            return 0\n        if startRange == numRanges - 1:\n            return 1\n        if startRange == endRange - 1:\n            return 1\n        return self.missingRanges(startRange + 1, endRange - 1, numRanges - 1) + 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.missingRanges(0, 1, 3))\n    print(s.missingRanges(1, 3, 3))\n    print(s.missingRanges(1, 3, 4))\n    print(s.missingRanges(1, 3, 5))",
    "# https://www.hackerrank.com/challenges/missing-ranges\n\ndef find_missing_ranges(arr, start, end):\n    return [arr[i] for i in range(start, end) if arr[i]!= arr[i+1]]\n\narr = [1,2,3,4,5,6,7,8,9]\nstart = 0\nend = len(arr)\n\nprint(find_missing_ranges(arr, start, end))",
    "# https://www.codewars.com/kata/55d9ba2d4d6f6eac0e0006f/train/python\n\ndef ranges_missing_from_list(list_, start_range, end_range):\n    return [x for x in list_ if x > start_range and x < end_range]\n\n# Test cases\n# [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [6, 8, 9]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [6, 8, 9], [7, 8, 9]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [6, 8, 9], [7, 8, 9], [8, 9, 10]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [6, 8, 9], [7, 8, 9], [8, 9, 10], [9, 10, 11]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [6, 8, 9], [7, 8, 9], [8, 9, 10], [9, 10, 11], [10, 11, 12]]\n# [[1, 4, 5], [2, 4, 6], [3, 4, 7], [4, 6, 8], [5, 7, 8], [",
    "# Definition for a range.\n# class Range:\n#     def __init__(self, s = 0, e = 0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def missingRanges(self, nums: List[int], s: int, e: int) -> List[Range]:\n        if e < s:\n            return []\n        res = []\n        for i in range(s, e + 1):\n            if i not in nums:\n                res.append(Range(s, i))\n        return res",
    "# https://leetcode.com/problems/missing-ranges/discuss/78164/Python-DP-solution\n\nclass Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = [[]]\n        for i in range(start, end):\n            if i > nums[-1]:\n                res[-1].append(i)\n            else:\n                res = [[i] + j for j in res if j]\n        return res",
    "# https://www.hackerrank.com/challenges/missing-ranges/problem\n\nfrom collections import Counter\nimport sys\n\n\ndef missing_ranges(arr, start, end):\n    # write your code here\n    n = len(arr)\n    if start > end:\n        return 0\n    if start == end:\n        return 1\n    if arr[start]!= arr[end]:\n        return 0\n    if start == end - 1:\n        return 1\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0\n    if arr[start] < arr[end]:\n        return 0\n    if arr[start] == arr[end]:\n        return 0\n    if arr[start] > arr[end]:\n        return 0",
    "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param root, a tree node\n\t# @param start, a integer\n\t# @param end, a integer\n\t# @return a list of ranges\n\tdef findMissingRanges(self, root, start, end):\n\t\tranges = []\n\t\tif root is None:\n\t\t\treturn ranges\n\t\tif root.val < start:\n\t\t\tranges.append((start, root.val))\n\t\t\tstart = root.val\n\t\tif root.val > end:\n\t\t\tranges.append((root.val, end))\n\t\t\tend = root.val\n\t\tif root.left is None and root.right is None:\n\t\t\treturn ranges\n\t\tif root.left is not None and root.right is None:\n\t\t\tranges.append((root.left.val, end))\n\t\t\tend = root.left.val\n\t\tif root.right is not None and root.left is None:\n\t\t\tranges.append((start, root.right.val))\n\t\t\tstart = root.right.val\n\t\tif root.left is not None and root.right is not None:\n\t\t\tranges.append((root.left.val, root.right.val))\n\t\t\tif root.left.val > start:\n\t\t\t\tstart = root.left.val\n\t\t\tif root.right.val < end:\n\t\t\t\tend = root.right.val\n\t\treturn self.findMissingRanges(root.left, start, end) + self.findMissingRanges(root.right, start, end)",
    "def find_ranges(arr, start, end):\n    \"\"\"\n    :type arr: List[int]\n    :type start: int\n    :type end: int\n    :rtype: List[int]\n    \"\"\"\n    if start >= end:\n        return []\n\n    ranges = []\n    for i in range(start, end + 1):\n        if i in arr:\n            ranges.append(i)\n\n    return ranges\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    start = 4\n    end = 7\n\n    ranges = find_ranges(arr, start, end)\n    print(ranges)",
    "# https://leetcode.com/problems/missing-ranges/discuss/453618/C++-Python-Solution\n\nimport collections\n\ndef find_ranges(lst):\n    if not lst:\n        return []\n    ranges = []\n    prev = lst[0]\n    for i in lst[1:]:\n        if i <= prev:\n            ranges.append((prev, i))\n        prev = i\n    ranges.append((prev, lst[-1]))\n    return ranges\n\ndef missing_ranges(lst, start, end):\n    if not lst:\n        return []\n    ranges = find_ranges(lst)\n    return [i for i in range(start, end + 1) if not any(i >= r[0] and i <= r[1] for r in ranges)]\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(missing_ranges(lst, 1, 10))\n    print(missing_ranges(lst, 1, 8))",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} start\n    # @param {integer} end\n    # @return {integer[]}\n    def findMissingRanges(self, intervals, start, end):\n        ret = []\n        for i in xrange(start, end + 1):\n            if i not in intervals:\n                ret.append(i)\n        return ret\n\ns = Solution()\nprint s.findMissingRanges([1,3,5,7], 1, 7)\nprint s.findMissingRanges([1,3,5,7], 2, 5)\nprint s.findMissingRanges([1,3,5,7], 1, 5)",
    "# Tries\n\ndef get_missing_ranges(ranges, start_range, end_range):\n    if start_range > end_range:\n        return []\n    if start_range < end_range:\n        return [start_range, end_range]\n    else:\n        return [start_range, end_range]\n\ndef get_missing_ranges2(ranges, start_range, end_range):\n    if start_range > end_range:\n        return []\n    if start_range < end_range:\n        return [start_range, end_range]\n    else:\n        return [start_range, end_range]\n\n# Tests\n\ndef test_get_missing_ranges():\n    assert get_missing_ranges([1, 2, 3], 1, 2) == [2, 3]\n    assert get_missing_ranges([1, 2, 3], 1, 3) == [2, 3]\n    assert get_missing_ranges([1, 2, 3], 1, 4) == [2, 3]\n    assert get_missing_ranges([1, 2, 3], 2, 3) == [3, 4]\n    assert get_missing_ranges([1, 2, 3], 2, 4) == [3, 4]\n    assert get_missing_ranges([1, 2, 3], 3, 4) == []\n    assert get_missing_ranges([1, 2, 3], 4, 4) == []\n    assert get_missing_ranges([1, 2, 3], 1, 1) == []\n    assert get_missing_ranges([1, 2, 3], 2, 2) == []\n\ndef test_get_missing_ranges2():\n    assert get_missing_ranges2([1, 2, 3], 1, 2) == [2, 3]\n    assert get_missing_ranges2([1, 2, 3], 1, 3) == [2, 3]\n    assert get_missing_ranges2([1, 2, 3], 1, 4) == [2, 3]\n    assert get_missing_ranges2([1, 2, 3], 2, 3) == [3, 4]",
    "# -*- coding: utf-8 -*-\n\n\"\"\"\nCopyright (C) 2015 Jeison Pacateque, Santiago Puerto, Wilmar Fernandez\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>\n\"\"\"\n\n\ndef get_missing_ranges(list_of_ranges, start_range, end_range):\n    \"\"\"\n    :param list_of_ranges: a list of ranges\n    :param start_range: the start range\n    :param end_range: the end range\n    :return: a list of missing ranges\n    \"\"\"\n\n    new_ranges = []\n    for range in list_of_ranges:\n        if (range[0] >= start_range) and (range[1] <= end_range):\n            new_ranges.append(range)\n        elif (range[0] > end_range):\n            new_ranges.append((start_range, range[1]))\n        elif (range[1] < start_range):\n            new_ranges.append((range[0], end_range))\n\n    return new_ranges\n\n\ndef main():\n    \"\"\"\n    :return: a list of missing ranges\n    \"\"\"\n    list_of_ranges = [[0, 10], [2, 4], [5, 7], [9, 20]]\n    start_range = 3\n    end_range = 7\n    print(get_missing_ranges(list_of_ranges, start_range, end_range))\n\n\nif __name__ == '__main__':\n    main()",
    "import collections\n\nclass Range:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __repr__(self):\n        return \"Range({}, {})\".format(self.start, self.end)\n\n    def __eq__(self, other):\n        return isinstance(other, Range) and self.start == other.start and self.end == other.end\n\n    def __hash__(self):\n        return hash(self.start) ^ hash(self.end)\n\n    def __lt__(self, other):\n        return self.start < other.start or (self.start == other.start and self.end < other.end)\n\n    def __gt__(self, other):\n        return self.start > other.start or (self.start == other.start and self.end > other.end)\n\n    def __le__(self, other):\n        return self.start <= other.start or (self.start == other.start and self.end <= other.end)\n\n    def __ge__(self, other):\n        return self.start >= other.start or (self.start == other.start and self.end >= other.end)\n\n    def __bool__(self):\n        return self.start!= self.end\n\n    def __len__(self):\n        return self.end - self.start\n\n    def __iter__(self):\n        yield self.start\n        yield self.end\n\n    def __add__(self, other):\n        return Range(self.start, self.end + other.end)\n\n    def __sub__(self, other):\n        return Range(self.start, self.end - other.start)\n\n    def __add__(self, other):\n        return Range(self.start, self.end + other)\n\n    def __sub__(self, other):\n        return Range(self.start - other.start, self.end - other.start)\n\n    def __str__(self):\n        return \"{} - {}\".format(self.start, self.end)\n\ndef get_missing_ranges(ranges):\n    ranges_set = set(ranges)",
    "# https://leetcode.com/problems/missing-ranges/\n\n# TLE\n# 12/17/2017\n\nclass Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start < end:\n            ranges = [start]\n            for i in xrange(start + 1, end):\n                if i not in nums:\n                    ranges.append(i)\n            return ranges\n        else:\n            return [start]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [1,3,5,7,9]\n    start = 1\n    end = 5\n    ranges = s.missingRanges(nums, start, end)\n    print(ranges)",
    "import collections\n\nclass Range(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __str__(self):\n        return \"Range: %d - %d\" % (self.start, self.end)\n\n    def __repr__(self):\n        return \"Range: %d - %d\" % (self.start, self.end)\n\n    def __eq__(self, other):\n        return self.start == other.start and self.end == other.end\n\n    def __ne__(self, other):\n        return self.start!= other.start or self.end!= other.end\n\n    def __lt__(self, other):\n        return self.start < other.start\n\n    def __le__(self, other):\n        return self.start <= other.start\n\n    def __gt__(self, other):\n        return self.start > other.start\n\n    def __ge__(self, other):\n        return self.start >= other.start\n\n    def __add__(self, other):\n        return Range(self.start, self.end + other.end)\n\n    def __sub__(self, other):\n        return Range(self.start, self.end - other.end)\n\n    def __mul__(self, other):\n        return Range(self.start * other.start, self.end * other.end)\n\n    def __truediv__(self, other):\n        return Range(self.start / other.start, self.end / other.end)\n\n    def __floordiv__(self, other):\n        return Range(self.start // other.start, self.end // other.end)\n\n    def __mod__(self, other):\n        return Range(self.start % other.start, self.end % other.end)\n\n    def __radd__(self, other):\n        return Range(other.start + self.start, other.start + self.end)\n\n    def __rsub__(self, other):\n        return Range(other.start - self.start, other.start - self.end)\n\n    def __rmul__(self, other):\n        return",
    "def find_missing_ranges(list_to_check, start_range, end_range):\n    \"\"\"\n    :type list_to_check: List[int]\n    :type start_range: int\n    :type end_range: int\n    :rtype: List[int]\n    \"\"\"\n    # Write your code here\n    return list()\n\n\nif __name__ == \"__main__\":\n    list_to_check = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    start_range = 3\n    end_range = 10\n    missing_ranges = find_missing_ranges(list_to_check, start_range, end_range)\n    print(missing_ranges)",
    "class Solution(object):\n    def missingRanges(self, start, end, A):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not A: return []\n        res = []\n        for i in range(start, end + 1):\n            if i not in A: res.append(i)\n        return res",
    "# https://www.hackerrank.com/challenges/missing-ranges/problem\n\nn = int(input())\narr = []\nfor i in range(n):\n    arr.append(int(input()))\n\nstart = int(input())\nend = int(input())\n\n# print(arr)\n# print(start, end)\n\n# print(find_missing_ranges(arr, start, end))\n\n# print(find_missing_ranges_recursive(arr, start, end))\n\n# print(find_missing_ranges_dp(arr, start, end))",
    "# Thought:\n\n# 1. Extract all ranges that are missing from the given list.\n# 2. Extract all ranges that are missing from the given list and has start range equal to or greater than the given start range and end range equal to or less than the given end range.\n# 3. Extract all ranges that are missing from the given list and has start range equal to or greater than the given start range and end range equal to or less than the given end range.\n# 4. Extract all ranges that are missing from the given list and has start range greater than the given start range and end range equal to or less than the given end range.\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\nclass Solution(object):\n    def findMissingRanges(self, arr, s, e):\n        \"\"\"\n        :type arr: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        start = 0\n        end = 0\n        for i in xrange(len(arr)):\n            if arr[i] < s:\n                result.append(start)\n                start = i + 1\n            elif arr[i] > e:\n                result.append(end)\n                end = i + 1\n        result.append(end)\n        return result",
    "class Solution(object):\n    def findRange(self, arr, start, end):\n        \"\"\"\n        :type arr: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        if start > end:\n            return []\n        res = []\n        for i in range(start, end + 1):\n            if i in arr:\n                res.append(i)\n        return res\n\nif __name__ == '__main__':\n    assert Solution().findRange([1, 2, 3], 0, 1) == [0]\n    assert Solution().findRange([1, 2, 3], 1, 2) == [1]\n    assert Solution().findRange([1, 2, 3], 2, 3) == [1, 2]\n    assert Solution().findRange([1, 2, 3], 1, 3) == [1, 2, 3]\n    assert Solution().findRange([1, 2, 3], 1, 3) == [1, 2, 3]\n    assert Solution().findRange([1, 2, 3], 1, 2) == [1, 2]\n    assert Solution().findRange([1, 2, 3], 1, 3) == [1, 2, 3]\n    assert Solution().findRange([1, 2, 3], 1, 3) == [1, 2, 3]\n    assert Solution().findRange([1, 2, 3], 1, 2) == [1, 2]",
    "# -*- coding:utf-8 -*-\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        i = 0\n        while i < len(nums):\n            if nums[i] < s:\n                ret.append(s)\n                s = nums[i]\n            elif nums[i] > e:\n                ret.append(e)\n                e = nums[i]\n            else:\n                i += 1\n        ret.append(e)\n        return ret\n\n# -*- coding:utf-8 -*-\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        if e < s:\n            return []\n        ret = []\n        i = 0\n        while i < len(nums):\n            if nums[i] < s:\n                ret.append(s)\n                s = nums[i]\n            elif nums[i] > e:\n                ret.append(e)\n                e = nums[i]\n            else:\n                i += 1\n        ret.append(e)\n        return ret\n\n# -*- coding:utf-8 -*-\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        if e < s:\n            return []\n        ret = []\n        i = 0\n        while i < len(nums):\n            if nums[i] < s:\n                ret.append(s)\n                s = nums[i]\n            elif nums[i] > e:",
    "import unittest\n\n# Tests\nclass TestCode(unittest.TestCase):\n    def test_extract_missing_ranges(self):\n        test_list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 313, 315, 317, 319, 321, 323, 325, 327, 329, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 377, 379, 381, 383, 385, 387, 389, 391, 393, 395, 397, 399, 401, 403, 405, 407, 409, 411, 413, 415, 417, 419, 421, 423, 425, 427, 429, 431, 433, 435, 437, 439, 441, 443, 445, 447, 449, 451, 453, 455, 457,",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(len(nums)):\n            if nums[i] >= start and nums[i] <= end:\n                continue\n            elif nums[i] > end:\n                result.append(end)\n            elif nums[i] < start:\n                result.append(start)\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.missingRanges([1, 3, 5], 1, 4)\n    print s.missingRanges([1, 2, 3, 4, 5], 2, 3)",
    "class Solution:\n    def findMissingRanges(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[int]\n        \"\"\"\n        if lower == 0 and upper == len(nums) - 1:\n            return nums\n        if lower > upper:\n            return []\n        if lower == upper:\n            return [lower]\n        res = []\n        for i in range(lower, upper + 1):\n            if i == lower or i == upper:\n                continue\n            res.append(i)\n        return res",
    "def find_ranges(list, start, end):\n    \"\"\"\n    :type list: List[int]\n    :type start: int\n    :type end: int\n    :rtype: List[int]\n    \"\"\"\n    def find_range(list, start, end, cur_start, cur_end):\n        if start > end:\n            return list\n        if start == end:\n            list.append(cur_start)\n            return list\n        if cur_start < start:\n            find_range(list, start, end, cur_start, cur_end)\n        if cur_end > end:\n            find_range(list, start, end, cur_start, cur_end)\n        return list\n    return find_range(list, start, end, start, end)\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} start\n    # @param {integer} end\n    # @return {integer[]}\n    def findRange(self, nums, start, end):\n        if start > end:\n            return []\n        if start == end:\n            return [start]\n        if start > end:\n            return []\n        if start == end:\n            return [start]\n        if start < end:\n            return [start, end]\n        if start > end:\n            return [start, end]\n        return [start, end]",
    "import collections\n\nclass Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        res = []\n        i, j = start, end\n        while i < end:\n            while i < end and nums[i] <= i:\n                i += 1\n            while j > i and nums[j] > j:\n                j -= 1\n            if i < j:\n                res.append(i, j)\n            i = j\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().findMissingRanges([1, 2, 3, 4, 5], 0, 5) == [0, 1, 2, 3, 4]\n    assert Solution().findMissingRanges([1, 2, 3, 4, 5], 2, 7) == [3, 4]\n    assert Solution().findMissingRanges([1, 2, 3, 4, 5], 1, 4) == [2, 3, 4, 5]",
    "def find_missing(s, e):\n    \"\"\"\n    :type s: int\n    :type e: int\n    :rtype: List[int]\n    \"\"\"\n    \n    ranges = []\n    \n    while s <= e:\n        ranges.append(s)\n        s += 1\n    \n    return ranges\n\ndef main():\n    s = 5\n    e = 7\n    ranges = find_missing(s, e)\n    print(ranges)\n    \nif __name__ == \"__main__\":\n    main()",
    "from collections import deque\n\ndef extract_ranges(numbers, start, end):\n    ranges = []\n    for i in range(start, end):\n        ranges.append(deque())\n        ranges[i].append(numbers[i])\n    return ranges\n\ndef main():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218",
    "# Approach #1: Binary Search\ndef missing_ranges(ranges, start, end):\n    left, right = start, end\n    while left < right:\n        mid = left + (right - left) / 2\n        if mid not in ranges:\n            left = mid + 1\n        elif mid == end:\n            return [left, mid]\n        else:\n            right = mid\n    return [left, right]\n\n# Approach #2: Greedy\ndef missing_ranges(ranges, start, end):\n    start, end = min(start, end), max(start, end)\n    left = start\n    right = end\n    while left < right:\n        mid = left + (right - left) / 2\n        if mid not in ranges:\n            left = mid + 1\n        elif mid == end:\n            return [left, mid]\n        else:\n            right = mid\n    return [left, right]\n\n# Approach #3: Recursive\ndef missing_ranges(ranges, start, end):\n    if start == end:\n        return [start]\n    mid = start + (end - start) / 2\n    if mid not in ranges:\n        return missing_ranges(ranges, start, mid)\n    elif mid == end:\n        return [mid]\n    else:\n        return missing_ranges(ranges, mid + 1, end)\n\n# Approach #4: Iterative\ndef missing_ranges(ranges, start, end):\n    if start == end:\n        return [start]\n    mid = start + (end - start) / 2\n    if mid not in ranges:\n        return missing_ranges(ranges, start, mid)\n    elif mid == end:\n        return [mid]\n    else:\n        return missing_ranges(ranges, mid + 1, end)\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)",
    "class Solution:\n    # @param {ListNode[]} ranges\n    # @param {integer} start\n    # @param {integer} end\n    # @return {integer[][]}\n    def findMissingRanges(self, ranges, start, end):\n        \n        if start == end:\n            return [[start, end]]\n        \n        if start < end:\n            start += 1\n        \n        ranges.sort(key=lambda x: x[0])\n        \n        l = len(ranges)\n        \n        ret = [[ranges[i][0] for i in range(l)] for i in range(l)]\n        \n        for i in range(l-1):\n            ret[i][0] = ranges[i][0]\n            ret[i][1] = ranges[i+1][0]\n            \n        ret[l-1][0] = start\n        ret[l-1][1] = end\n        \n        return ret",
    "# https://leetcode.com/problems/missing-ranges/\n# Definition for a Range.\nclass Range(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def findRange(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[Range]\n        \"\"\"\n        if not nums:\n            return []\n        m = nums[0]\n        for n in nums[1:]:\n            if n < m:\n                m = n\n        r = [Range(m, nums[-1])]\n        for n in nums[:-1]:\n            if n < m:\n                r.append(Range(n, m))\n                m = n\n        return r\n\n# \u6839\u636e\u7ed9\u5b9a\u7684\u6570\u7ec4\u548c\u8d77\u70b9\u548c\u7ec8\u70b9\uff0c\u8ba1\u7b97\u8be5\u6570\u7ec4\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5305\u62ec\u8be5\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u533a\u95f4\n# \u8fd9\u6837\u7684\u60c5\u51b5\u8d77\u70b9\u548c\u7ec8\u70b9\u90fd\u662f0\uff0c\u53ef\u4ee5\u8fd4\u56de\u4e00\u4e2a\u5305\u542b\u4efb\u610f\u533a\u95f4\u7684\u5217\u8868\n# \u8fd9\u91cc\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7b2c\u4e00\u4e2a\u5305\u62ec\u8be5\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u533a\u95f4\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u90fd\u662f0\n# \u53ef\u4ee5\u7b80\u5355\u5730\u8ba1\u7b97\u4e00\u4e0b\uff0c\u5982\u679c\u7b2c\u4e00\u4e2a\u5305\u62ec\u8be5\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u533a\u95f4\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u90fd\u662f0\ufffd",
    "# Definition for a Range.\nclass Range(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        \n    def __repr__(self):\n        return '<Range {} {}>'.format(self.start, self.end)\n\nclass Solution(object):\n    def findMissingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[Range]\n        \"\"\"\n        if start > end:\n            return []\n        \n        ret = []\n        \n        for i in range(start, end):\n            for j in range(start, end):\n                if i == j:\n                    continue\n                \n                if i < j:\n                    ret.append(Range(i, j))\n        \n        return ret",
    "#\n# Definition for an interval.\n# type: List[List[int]]\n#\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findMissingRanges(self, intervals, s, e):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type s: int\n        :type e: int\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals = sorted(intervals)\n        result = []\n        if s < e:\n            for i in range(len(intervals)):\n                if intervals[i][0] < s or intervals[i][1] > e:\n                    result.append([s, e])\n                    break\n                elif intervals[i][0] < e and intervals[i][1] > s:\n                    result.append([s, intervals[i][1]])\n                    s = intervals[i][0]\n        return result",
    "def missing_ranges(ranges, start_range, end_range):\n    \"\"\"\n    ranges: list of integers\n    start_range: integer\n    end_range: integer\n    return: list of tuples of integers\n    \"\"\"\n    ranges = sorted(ranges)\n    start_range = sorted(start_range)\n    end_range = sorted(end_range)\n    if len(start_range) == 0:\n        return [tuple(range(ranges[0], end_range[0]))]\n    if len(end_range) == 0:\n        return [tuple(range(start_range[0], ranges[0]))]\n    return [tuple(range(start_range[0], end_range[0]))]\n\nif __name__ == '__main__':\n    ranges = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n    start_range = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n    end_range = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n    print(missing_ranges(ranges, start_range, end_range))",
    "def ranges_missing(start, end, list):\n    \"\"\"\n    :type start: int\n    :type end: int\n    :type list: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [x for x in range(start, end+1) if x not in list]\n\nclass Solution:\n    def rangesMissing(self, start, end, nums):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(start, end+1):\n            if i not in nums:\n                res.append(i)\n        return res",
    "class Solution(object):\n    def missingRanges(self, nums, start, end):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type end: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        for i in range(start, end + 1):\n            if i < end:\n                if i in nums:\n                    continue\n                if i - start in nums:\n                    nums.remove(i - start)\n                else:\n                    ret.append([start, i])\n                    nums.append(i)\n            else:\n                if i in nums:\n                    nums.remove(i)\n                else:\n                    ret.append([start, end])\n                    nums.append(i)\n        return ret\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 6, 8]\n    s = Solution()\n    print(s.missingRanges(nums, 1, 5))\n    print(s.missingRanges(nums, 1, 3))\n    print(s.missingRanges(nums, 1, 6))\n    print(s.missingRanges(nums, 1, 8))\n    print(s.missingRanges(nums, 1, 10))\n    print(s.missingRanges(nums, 1, 11))\n    print(s.missingRanges(nums, 1, 14))\n    print(s.missingRanges(nums, 1, 15))\n    print(s.missingRanges(nums, 1, 16))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def missingRanges(self, root: TreeNode, start: int, end: int) -> List[int]:\n        l = []\n        r = []\n        if root is None:\n            return l, r\n        if start > end:\n            return l, r\n        if start == end:\n            return [start], []\n        l.append(start)\n        r.append(end)\n        if root.left is None and root.right is None:\n            return l, r\n        if root.left is not None:\n            l = self.missingRanges(root.left, start, end)\n        if root.right is not None:\n            r = self.missingRanges(root.right, start, end)\n        return l, r",
    "# Thought:\n# 1. If the list has only one element, just return it.\n# 2. If the list has two elements, then the first element is the start range and the second is the end range.\n# 3. If the list has more than two elements, then we can make a binary search to find the range.\n# 4. If the list has more than two elements, then we can make a binary search to find the range.\n# 5. If the list has more than two elements, then we can make a binary search to find the range.\n# 6. If the list has more than two elements, then we can make a binary search to find the range.\n# 7. If the list has more than two elements, then we can make a binary search to find the range.\n# 8. If the list has more than two elements, then we can make a binary search to find the range.\n# 9. If the list has more than two elements, then we can make a binary search to find the range.\n# 10. If the list has more than two elements, then we can make a binary search to find the range.\n# 11. If the list has more than two elements, then we can make a binary search to find the range.\n# 12. If the list has more than two elements, then we can make a binary search to find the range.\n# 13. If the list has more than two elements, then we can make a binary search to find the range.\n# 14. If the list has more than two elements, then we can make a binary search to find the range.\n# 15. If the list has more than two elements, then we can make a binary search to find the range.\n# 16. If the list has more than two elements, then we can make a binary search to find the range.\n# 17. If the list has more than two elements, then we can make a binary search to find the range.\n# 18. If the list has more than two elements, then we can make a binary search to find the range.\n# 19. If the list has more than two elements, then we can make a binary search to find the range.\n# 20. If the list has more than two elements, then we can make a binary search to find the range.\n# 21. If the list has more than two elements, then we",
    "def get_missing_ranges(start, end, nums):\n    \"\"\"\n    :type start: int\n    :type end: int\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if start > end:\n        return []\n    \n    result = []\n    for i in range(start, end + 1):\n        if i in nums:\n            continue\n        result.append(i)\n    return result\n\ndef main():\n    \"\"\"\n    Sample Input\n    [1,2,3,4,5,6,7]\n    Sample Output\n    [1,2,3,5,6]\n    \"\"\"\n    start = 1\n    end = 7\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    result = get_missing_ranges(start, end, nums)\n    print result\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a range.\n# class Range:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def missingRanges(self, nums: List[int], m: int, n: int) -> List[List[int]]:\n        if m == 0 or n == 0:\n            return []\n        \n        if m < n:\n            m, n = n, m\n        \n        ranges = []\n        \n        for i in range(m):\n            ranges.append([])\n        \n        for i in range(m, n):\n            for j in range(m, i):\n                ranges[j].append(nums[i])\n        \n        return ranges",
    "from collections import defaultdict\n\n\ndef missing_ranges(start, end, values):\n    \"\"\"\n    :type start: int\n    :type end: int\n    :type values: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    # values[start:end] should be present\n    missing_ranges = []\n    for i in range(start, end):\n        if values[i]!= i + 1:\n            missing_ranges.append([i, values[i]])\n    return missing_ranges\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    start, end, values = input().strip().split(' ')\n    start, end = int(start), int(end)\n    values = list(map(int, values.split(',')))\n    print('{}'.format(missing_ranges(start, end, values)))\n\n\nif __name__ == '__main__':\n    main()",
    "# https://leetcode.com/problems/missing-ranges/discuss/84920/Java-O(1)-Solutions-3-in-O(N)-Time-and-O(1)-Space\n\n# Definition for a range.\nclass Range:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def missingRanges(self, ranges: List[Range]) -> List[Range]:\n        ranges.sort(key=lambda x: (x.start, x.end))\n        ret = []\n        for i in range(0, len(ranges)):\n            if i == 0:\n                ret.append(ranges[i])\n                continue\n            if ranges[i].start > ranges[i-1].end:\n                ret.append(ranges[i])\n        return ret",
    "# Definition for a Range.\nclass Range:\n    def __init__(self, s = 0, e = 0):\n        self.start = s\n        self.end = e\n\n    def __repr__(self):\n        return str(self.start) +'' + str(self.end)\n\n\nclass Solution:\n    def findMissingRanges(self, nums: List[int], s: int, e: int) -> List[Range]:\n        ret = []\n        for i in range(len(nums)):\n            if nums[i] < s or nums[i] > e:\n                ret.append(Range(s, e))\n                s = e + 1\n            else:\n                e = nums[i] + 1\n        ret.append(Range(s, e))\n        return ret\n\n# Note:\n# The given list might contain duplicates.\n# The given start and end range values might be out of the given list range.\n# Example 1:\n# Input: nums = [2,5,3,5], s = 1, e = 3\n# Output: [Range(1,3)]\n# Example 2:\n# Input: nums = [1,2,3,4,5], s = 4, e = 5\n# Output: [Range(4,5)]\n# Example 3:\n# Input: nums = [1,2,3,4,5], s = 2, e = 4\n# Output: []\n# Note:\n# The given start and end range values are all positive integers and will not exceed the given list length.\n# The given list has no duplicate elements.\n# Time complexity: O(n)\n# Space complexity: O(n)",
    "# https://leetcode.com/problems/missing-ranges/discuss/4748/Python-using-recursion-to-find-all-missing-ranges\n\nclass Solution(object):\n    def findMissingRanges(self, ranges, lower_bound, upper_bound):\n        \"\"\"\n        :type ranges: List[int]\n        :type lower_bound: int\n        :type upper_bound: int\n        :rtype: List[int]\n        \"\"\"\n        return self.findMissingRangesRec(ranges, lower_bound, upper_bound)\n\n    def findMissingRangesRec(self, ranges, lower_bound, upper_bound):\n        if len(ranges) == 0:\n            return [[lower_bound, upper_bound]]\n\n        mid = (lower_bound + upper_bound) / 2\n        if mid >= ranges[0]:\n            return self.findMissingRangesRec(ranges[1:], lower_bound, mid)\n        else:\n            return self.findMissingRangesRec(ranges[1:], mid, upper_bound)\n\n\nif __name__ == '__main__':\n    print Solution().findMissingRanges([1, 3, 5], 1, 4)",
    "# https://leetcode.com/problems/missing-ranges/\n\n# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom utils import TreeNode\n\n\nclass Solution:\n    def findMissingRanges(self, root: TreeNode, s: int, e: int) -> List[List[int]]:\n        if not root:\n            return [[s, e]]\n\n        ranges = []\n        self.findMissingRanges(root.left, s, e)\n        self.findMissingRanges(root.right, s, e)\n        if root.left and not root.left.val:\n            ranges.append([s, root.left.val])\n        if root.right and not root.right.val:\n            ranges.append([root.right.val, e])\n        return ranges\n\n\ndef main():\n    solution = Solution()\n    root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(7)), TreeNode(3, TreeNode(5), TreeNode(8)))\n    print(solution.findMissingRanges(root, 1, 5))\n    print(solution.findMissingRanges(root, 5, 10))\n    print(solution.findMissingRanges(root, 1, 2))\n    print(solution.findMissingRanges(root, 1, 3))\n\n\nif __name__ == \"__main__\":\n    main()",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution(object):\n    def findMissingRanges(self, nums, s, e):\n        \"\"\"\n        :type nums: List[int]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            if i < s or i > e:\n                res.append(nums[i])\n            else:\n                res.append(res[i-s] + nums[i])\n        return res",
    "import math\n\ndef missing_ranges(given_ranges, start, end):\n    ranges = []\n    for i in range(start, end + 1):\n        for j in range(i, end + 1):\n            if i == j:\n                ranges.append((i, i))\n            elif i < j:\n                ranges.append((i, j))\n            else:\n                ranges.append((j, j))\n    return ranges\n\ndef main():\n    given_ranges = [\n        (0, 1),\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 5),\n        (5, 6),\n        (6, 7),\n        (7, 8),\n        (8, 9),\n        (9, 10),\n        (10, 11),\n        (11, 12),\n        (12, 13),\n        (13, 14),\n        (14, 15),\n        (15, 16),\n        (16, 17),\n        (17, 18),\n        (18, 19),\n        (19, 20),\n        (20, 21),\n        (21, 22),\n        (22, 23),\n        (23, 24),\n        (24, 25),\n        (25, 26),\n        (26, 27),\n        (27, 28),\n        (28, 29),\n        (29, 30),\n        (30, 31),\n        (31, 32),\n        (32, 33),\n        (33, 34),\n        (34, 35),\n        (35, 36),\n        (36, 37),\n        (37, 38),\n        (38, 39),\n        (39, 40),\n        (40, 41),\n        (41, 42),\n        (42, 43),\n        (43, 44),\n        (44, 45),\n        (45, 46),\n        (46, 47),\n        (47, 48),\n        (48, 49),\n        (49, 50),\n        (50, 51),\n        (51, 52),\n        (52, 53),\n        (53, 54),\n        (54, 55),\n        (55, 56",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution:\n    # @return a list of lists of length 2, [[val1, val2]]\n    def missingRanges(self, nums, start, end):\n        if start > end:\n            return []\n\n        if start > nums[-1]:\n            return [[nums[-1], nums[-1]]]\n\n        if start == end:\n            return [[start, end]]\n\n        if start > nums[-1]:\n            return [[nums[-1], nums[-1]]]\n\n        for i in range(len(nums) - 1):\n            if nums[i] < start:\n                continue\n            if nums[i] > end:\n                continue\n            if start <= nums[i] and end >= nums[i]:\n                continue\n            if nums[i] > start and nums[i] < end:\n                return self.missingRanges(nums[i + 1:], start, end)\n\n        return [[start, end]]",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findRange(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ret = []\n        for i in xrange(len(intervals)):\n            if i == 0:\n                ret.append(intervals[i])\n            else:\n                if intervals[i].start < ret[-1].end:\n                    ret[-1].end = intervals[i].end\n                else:\n                    ret.append(intervals[i])\n        return ret",
    "__author__ = 'Danyang'\n\nclass Solution(object):\n    def missing_ranges(self, nums, s, e):\n        \"\"\"\n        :param nums: list of integer\n        :param s: integer\n        :param e: integer\n        :return: list of integer\n        \"\"\"\n        # brute force\n        d = {}\n        for i in xrange(s, e):\n            d[i] = 1\n        res = []\n        for num in nums:\n            if num not in d:\n                res.append(num)\n                d[num] = 1\n        return res\n\n    def missing_ranges_dp(self, nums, s, e):\n        \"\"\"\n        :param nums: list of integer\n        :param s: integer\n        :param e: integer\n        :return: list of integer\n        \"\"\"\n        # dp\n        res = []\n        d = {}\n        for num in nums:\n            if num not in d:\n                d[num] = 1\n            else:\n                d[num] += 1\n        for i in xrange(s, e):\n            if i in d:\n                if d[i] == 1:\n                    res.append(i)\n                else:\n                    res.append(i-1)\n                    d[i] -= 1\n        return res\n\n\nif __name__==\"__main__\":\n    assert Solution().missing_ranges([2,3,4,5,6], 0, 7) == [0,2,4,6]\n    assert Solution().missing_ranges([2,3,4,5,6], 1, 7) == [1,2,3,4]\n    assert Solution().missing_ranges([2,3,4,5,6], 1, 6) == [1,2,3]\n    assert Solution().missing_ranges([2,3,4,5,6], 2, 7) == [2,3]\n    assert Solution().missing_ranges([2,3,4,5,6], 3, 7) == [3]\n    assert Solution().missing_ranges([2,3,4,5,6], 4, 7) == []",
    "# https://leetcode.com/problems/missing-ranges/\n\nclass Solution(object):\n    def findMissingRanges(self, intervals, s, e):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type s: int\n        :type e: int\n        :rtype: List[int]\n        \"\"\"\n        l = len(intervals)\n        if l == 0:\n            return [s, e]\n\n        intervals_new = []\n        for i in range(l):\n            intervals_new.append([])\n\n        for i in range(l):\n            intervals_new[i].append(intervals[i][0])\n            intervals_new[i].append(intervals[i][-1])\n\n        if s < intervals_new[0][0] or e > intervals_new[0][-1]:\n            return [s, e]\n\n        for i in range(1, l):\n            if s < intervals_new[i][0] or e > intervals_new[i][-1]:\n                return [s, e]\n\n            if s < intervals_new[i-1][1] and e > intervals_new[i-1][-1]:\n                return [s, e]\n\n            if s < intervals_new[i-1][1] and e > intervals_new[i][0]:\n                return [s, e]\n\n            if s < intervals_new[i][1] and e > intervals_new[i][-1]:\n                return [s, e]\n\n            if s < intervals_new[i-1][1] and e > intervals_new[i][1]:\n                return [s, e]\n\n            if s < intervals_new[i][1] and e > intervals_new[i-1][-1]:\n                return [s, e]\n\n            if s < intervals_new[i][1] and e > intervals_new[i][0]:\n                return [s, e]\n\n            if s < intervals_new[i-1][-1] and e > intervals_new[i][-1]:\n                return [s, e]\n\n            if s < intervals_new[i][-1]"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}