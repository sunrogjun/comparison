{
  "problem": {
    "task_id": "MBPP/306",
    "prompt": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .",
    "canonical_solution": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]",
    "test_list": [
      "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11",
      "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7",
      "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"
    ],
    "challenge_test_list": [],
    "problem_id": 295
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s or len(s) == 0:\n            return 0\n        n = len(s)\n        start = 0\n        end = 0\n        max_sum = 0\n        while end < n:\n            if s[end] < s[start]:\n                max_sum += s[start] - s[end]\n                start += 1\n            else:\n                end += 1\n        max_sum += s[start]\n        if k < start:\n            max_sum += s[start]\n        else:\n            max_sum += s[k]\n            while start < end:\n                if s[start] < s[end]:\n                    max_sum += s[start] - s[end]\n                    start += 1\n                else:\n                    end += 1\n        return max_sum\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxSubArray([1,2,3], 3)\n    print s.maxSubArray([1,2,3], 4)\n    print s.maxSubArray([1,2,3], 5)",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def maxSubArray(self, nums, k):\n        # write your code here\n        if len(nums) == 0:\n            return 0\n        m, n = len(nums), len(nums)\n        max_sum = nums[0]\n        # print(nums)\n        # print(m, n)\n        # print(max_sum)\n        for i in range(1, n):\n            # print(i, max_sum)\n            if nums[i] > nums[i - 1] + nums[i]:\n                max_sum = nums[i]\n            else:\n                max_sum = max(max_sum, nums[i] + max_sum)\n        if k > n:\n            max_sum = max(max_sum, nums[n - 1])\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    print(Solution().maxSubArray([1,2,3,4], 3))",
    "class Solution(object):\n    def maxSubArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if k > len(nums):\n            return 0\n        \n        if k == 0:\n            return max(nums)\n        \n        # find max from 0 to i-1\n        max_sum = nums[0]\n        max_sum_index = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                max_sum_index = i\n                max_sum = nums[i]\n            else:\n                max_sum += nums[i]\n        return max(max_sum, nums[max_sum_index] + self.maxSubArray(nums, k - 1))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :param s: list\n        :param k: int\n        :return: int\n        \"\"\"\n        if not s:\n            return 0\n\n        n = len(s)\n        res = s[0]\n        for i in range(1, n):\n            res = max(res + s[i], s[i] + s[i - 1])\n\n        return res + s[n - 1] if k > n else 0\n\n    def maxSubArray2(self, s, k):\n        \"\"\"\n        :param s: list\n        :param k: int\n        :return: int\n        \"\"\"\n        if not s:\n            return 0\n\n        n = len(s)\n        res = s[0]\n        for i in range(1, n):\n            res = max(res, s[i] + s[i - 1])\n\n        return res if k > n else 0\n\n\nif __name__ == \"__main__\":\n    print Solution().maxSubArray([-10, -3, -1, 2, -4], 2)\n    print Solution().maxSubArray([-10, -3, -1, 2, -4], 1)\n    print Solution().maxSubArray([-10, -3, -1, 2, -4], 3)",
    "class Solution(object):\n    def maxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n        if not arr or k < 0 or k >= len(arr):\n            return 0\n        ans = arr[0]\n        for i in xrange(1, len(arr)):\n            ans = max(ans, arr[i] + self.maxSubArray(arr[i+1:], k-1))\n        return ans",
    "# https://leetcode.com/problems/maximum-sum-of-increasing-subsequence/\n\nclass Solution:\n    # @param {string} s\n    # @param {integer} i\n    # @param {integer} k\n    # @return {integer}\n    def maxSumSubseq(self, s, i, k):\n        if i == 0:\n            return 0\n        \n        max_sum = 0\n        \n        for j in range(i, len(s)):\n            if j == i:\n                max_sum = max(max_sum, self.maxSumSubseq(s, j, k))\n            else:\n                max_sum = max(max_sum, self.maxSumSubseq(s, j, k) + s[j])\n            \n        return max_sum",
    "class Solution:\n    def findKthLargest(self, arr: List[int], k: int) -> int:\n        max_sum, max_idx = arr[0], 0\n        for i in range(1, len(arr)):\n            if arr[i] > arr[max_idx]:\n                max_sum, max_idx = arr[i], i\n        return max_sum + arr[max_idx] if max_idx < k else -1",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        \"\"\"\n        :type s: int\n        :type e: int\n        \"\"\"\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def maxSumSubseq(self, A, k):\n        \"\"\"\n        :type A: List[Interval]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n\n        ans = 0\n        n = len(A)\n        max_val = A[0].end\n        for i in xrange(1, n):\n            if A[i].end < max_val:\n                max_val = A[i].end\n            ans += max_val - A[i].start\n            max_val = max(max_val, A[i].end)\n        if k <= i:\n            ans += max_val - A[i-1].start\n        return ans",
    "def max_increasing_subsequence(arr, i, k):\n    \"\"\"\n    :type arr: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # This algorithm works only for positive numbers\n    # The idea is to add the elements of the subsequence in reverse order and keep track of the maximum sum.\n    # We can keep track of the maximum sum by comparing the sum of the elements in the subsequence with the maximum sum.\n    # If the sum of the elements in the subsequence is greater than the maximum sum, then we update the maximum sum\n    # and keep track of the sum of the elements in the subsequence.\n    # If the sum of the elements in the subsequence is smaller than the maximum sum, then we update the maximum sum\n    # and keep track of the sum of the elements in the subsequence.\n    # If the sum of the elements in the subsequence is equal to the maximum sum, then we keep track of the sum of the elements in the subsequence\n    # and update the maximum sum.\n    max_sum = arr[0]\n    max_sum_index = 0\n    for index in range(1, i):\n        max_sum_index = max(max_sum_index, index)\n        max_sum = max(max_sum, arr[index])\n\n    for index in range(i+1, len(arr)):\n        max_sum_index = max(max_sum_index, index)\n        max_sum = max(max_sum, arr[index])\n\n    return max_sum + arr[i]\n\ndef max_increasing_subsequence_2(arr, i, k):\n    \"\"\"\n    :type arr: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # This algorithm works only for positive numbers\n    # The idea is to add the elements of the subsequence in reverse order and keep track of the maximum sum.\n    # We can keep track of the maximum sum by comparing the sum of the elements in the subsequence with the maximum sum.\n    # If the sum of the elements in the subsequence is greater than the maximum sum, then we update the maximum sum",
    "def findMaxSubseq(s, i, k):\n    # write your code here\n    if i == len(s) or s[i] > k:\n        return 0\n    if i == 0:\n        return 1\n    if s[i] > k and s[i-1] > k:\n        return 1 + findMaxSubseq(s, i-1, k)\n    if s[i] > k:\n        return findMaxSubseq(s, i, k)\n    else:\n        return findMaxSubseq(s, i-1, k)\n\ndef test_findMaxSubseq():\n    assert(findMaxSubseq(\"ab\", 1, 2) == 1)\n    assert(findMaxSubseq(\"ab\", 2, 2) == 1)\n    assert(findMaxSubseq(\"ab\", 0, 2) == 1)\n    assert(findMaxSubseq(\"ab\", 1, 3) == 1)\n    assert(findMaxSubseq(\"ab\", 2, 3) == 1)\n    assert(findMaxSubseq(\"ab\", 1, 4) == 2)\n    assert(findMaxSubseq(\"ab\", 2, 4) == 2)\n    assert(findMaxSubseq(\"ab\", 3, 4) == 2)\n    assert(findMaxSubseq(\"ab\", 4, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 5, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 6, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 7, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 8, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 9, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 10, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 11, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 12, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 13, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 14, 4) == 3)\n    assert(findMaxSubseq(\"ab\", 15, 4) == 3)\n    assert(findMaxSubseq(\"",
    "from __future__ import print_function\nfrom collections import defaultdict\nimport operator\n\ndef findMaxSum(arr, i, k):\n    \"\"\"\n    :type arr: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    res = [0] * len(arr)\n    dp = defaultdict(int)\n    dp[0] = arr[0]\n    for j in range(1, i):\n        dp[j] = arr[j]\n    for j in range(i + 1, len(arr)):\n        dp[j] = arr[j] + max(dp[j - 1], dp[j - k])\n    for j in range(i + 1, len(arr)):\n        res[j] = dp[j]\n    return max(res)\n\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7]\n    print(findMaxSum(arr, 3, 1))\n    print(findMaxSum(arr, 3, 2))",
    "# https://leetcode.com/problems/find-the-maximum-sum-of-increasing-subsequence-from-previous-k-index-and-also-include-a-given-kth-element-in-the-middle/\n# Approach 1: Recursive\ndef maxSum(arr, i, k):\n    if i == 0:\n        return 0\n    if arr[i] > arr[i - 1]:\n        return arr[i] + max(arr[i - 1], maxSum(arr, i - 1, k))\n    else:\n        return max(arr[i], maxSum(arr, i - 1, k))\n\n# Approach 2: Dynamic Programming\ndef maxSum(arr, i, k):\n    if i == 0:\n        return 0\n    if arr[i] > arr[i - 1]:\n        return arr[i] + max(arr[i - 1], maxSum(arr, i - 1, k))\n    else:\n        return max(arr[i], maxSum(arr, i - 1, k))\n\n# Approach 3: Dynamic Programming\ndef maxSum(arr, i, k):\n    if i == 0:\n        return 0\n    if arr[i] > arr[i - 1]:\n        return arr[i] + max(arr[i - 1], maxSum(arr, i - 1, k))\n    else:\n        return max(arr[i], maxSum(arr, i - 1, k))\n\n# Approach 4: Dynamic Programming\ndef maxSum(arr, i, k):\n    if i == 0:\n        return 0\n    if arr[i] > arr[i - 1]:\n        return arr[i] + max(arr[i - 1], maxSum(arr, i - 1, k))\n    else:\n        return max(arr[i], maxSum(arr, i - 1, k))\n\n# Approach 5: Dynamic Programming\ndef maxSum(arr, i, k):\n    if i == 0:\n        return 0\n    if arr[i] > arr[i - 1]:\n        return arr[i] + max(arr[i - 1], maxSum(arr, i - 1, k))\n    else:",
    "# Your code should also have a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i.\n\nclass Solution(object):\n    def findKthMaxSubsequence(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        j = len(arr)\n        while i < j:\n            m = i + (j - i) / 2\n            if arr[m] > arr[i]:\n                j = m\n            else:\n                i = m + 1\n        return arr[i]\n\n\nif __name__ == \"__main__\":\n    arr = [4, 5, 6, 7, 0, 1, 2]\n    k = 3\n    print Solution().findKthMaxSubsequence(arr, k)",
    "def max_sum_increasing_subsequence(arr, i, k):\n    n = len(arr)\n    s = 0\n    for j in range(i+1, n):\n        s = max(s, arr[j] - arr[i])\n    if k > i:\n        s = max(s, arr[k] - arr[i])\n    return s\n\n\n# Test Cases\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
    "class Solution(object):\n    def maxSubArray(self, s, i, k):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        for j in range(i, len(s)):\n            max_sum = max(max_sum, s[j] + maxSubArray(s, j + 1, k))\n        return max_sum\n\ns = Solution()\nprint(s.maxSubArray([1,2,3,4,5], 3, 2))",
    "class Solution(object):\n    def maxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not arr or len(arr) == 0:\n            return 0\n        max_sum = arr[0]\n        max_k_sum = arr[0]\n        for i in range(1, len(arr)):\n            max_sum = max(max_sum + arr[i], arr[i])\n            max_k_sum = max(max_k_sum, arr[i])\n        return max(max_sum, max_k_sum)",
    "# https://www.geeksforgeeks.org/write-a-function-to-find-the-maximum-sum-of-increasing-subsequence-from-prefix-till-ith-index-and-including-a-given-kth-element-which-is-after-i/\n\ndef findMaxSumOfIncreasingSubsequence(array, start, k):\n    # if array is empty or start is out of range\n    if not array or start < 0 or start >= len(array):\n        return 0\n\n    # if k is out of range\n    if k < 0 or k > len(array):\n        return 0\n\n    # array[start] is the maximum sum of increasing subsequence\n    if array[start] > 0:\n        return array[start]\n\n    # find maximum sum of increasing subsequence till kth index\n    maxSum = 0\n    for i in range(start, len(array)):\n        if i < k:\n            maxSum += array[i]\n        else:\n            break\n\n    # find maximum sum of increasing subsequence uptil i\n    for i in range(start, k):\n        maxSum += array[i]\n\n    return maxSum\n\nif __name__ == '__main__':\n    array = [3, 1, 2, 4, 5, 7, 9, 6, 1, 5, 9, 2, 6]\n    k = 3\n    print(findMaxSumOfIncreasingSubsequence(array, 0, k))",
    "def max_increasing_subsequence(A, i, k):\n    if i == 0:\n        return 0\n    if i == len(A):\n        return A[i - 1]\n    if A[i] > A[i - 1]:\n        return A[i] + max_increasing_subsequence(A, i - 1, k)\n    else:\n        return max_increasing_subsequence(A, i - 1, k)\n\nA = [3, 9, 1, 2, 6, 4, 5, 7, 8]\nprint(max_increasing_subsequence(A, len(A) - 1, 8))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def maxSumSubseq(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        n = len(A)\n        if n < 2:\n            return 0\n        for i in range(1, n):\n            max_sum = max(max_sum, A[i - 1] + A[i])\n            for j in range(i, n):\n                max_sum = max(max_sum, A[j - 1] + A[j])\n                if j < k:\n                    max_sum = max(max_sum, A[j] + A[j - 1])\n        return max_sum",
    "# https://oj.leetcode.com/problems/find-maximum-sum-of-increasing-subsequence-after-kth-element/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        # https://www.youtube.com/watch?v=b1g9yQGXx4U\n        # 1. sort the list\n        # 2. find the kth largest element\n        # 3. return the sum of the kth largest element\n        # 4. return the sum of all the elements until the kth largest element\n        # 5. return the sum of all the elements\n        if len(nums) == 0:\n            return 0\n        \n        # sort the list\n        nums = sorted(nums)\n        \n        # find the kth largest element\n        kth_largest_element = nums[k - 1]\n        \n        # return the sum of all the elements until the kth largest element\n        sum_of_all_elements_until_kth_largest_element = nums[0]\n        for i in range(k - 1):\n            sum_of_all_elements_until_kth_largest_element += nums[i]\n        return sum_of_all_elements_until_kth_largest_element\n        \n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest_1(self, nums, k):\n        # sort the list\n        nums = sorted(nums)\n        \n        # find the kth largest element\n        kth_largest_element = nums[k - 1]\n        \n        # return the sum of all the elements until the kth largest element\n        sum_of_all_elements_until_kth_largest_element = nums[0]\n        for i in range(k - 1):\n            sum_of_all_elements_until_kth_largest_element += nums[i]\n        return sum_of_all",
    "# https://leetcode.com/problems/maximum-sum-of-increasing-subsequence/\n# O(n^2)\n# Time:  O(n^2)\n# Space: O(1)\n\n# Definition for a  pair of integers.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def findKthMaxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        if k > len(arr):\n            return arr[-1]\n        if k == 1:\n            return arr[0]\n        max_sum = arr[0]\n        max_sum_index = 0\n        for i in xrange(1, len(arr)):\n            cur_sum = arr[i]\n            if max_sum <= 0:\n                max_sum = cur_sum\n                max_sum_index = i\n            else:\n                if cur_sum > max_sum:\n                    max_sum = cur_sum\n                    max_sum_index = i\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 3, -4]\n    arr = [1, 2, -3, 4]\n    arr = [1, 2, 3, 4, 5]\n    arr = [1, 2, 3, 4, 5, 6]\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8,",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\n# class Solution(object):\n#     def findMaxSubArray(self, arr, k):\n#         \"\"\"\n#         :type arr: List[int]\n#         :rtype: int\n#         \"\"\"\n#         ans = 0\n#         max_sum = 0\n#         for i in xrange(len(arr)):\n#             if i < k:\n#                 ans = max(ans, arr[i])\n#             else:\n#                 max_sum = max(max_sum, arr[i] + ans)\n#                 ans = max(ans, arr[i])\n#         return max_sum\n\n# def findMaxSubArray(self, arr, k):\n#     \"\"\"\n#     :type arr: List[int]\n#     :rtype: int\n#     \"\"\"\n#     max_sum = 0\n#     for i in xrange(len(arr)):\n#         if i < k:\n#             max_sum = max(max_sum, arr[i])\n#         else:\n#             max_sum = max(max_sum, arr[i] + max_sum)\n#     return max_sum\n\n# def findMaxSubArray(self, arr, k):\n#     \"\"\"\n#     :type arr: List[int]\n#     :rtype: int\n#     \"\"\"\n#     ans = 0\n#     max_sum = 0\n#     for i in xrange(len(arr)):\n#         if i < k:\n#             ans = max(ans, arr[i])\n#         else:\n#             max_sum = max(max_sum, arr[i] + ans)\n#             ans = max(ans, arr[i])\n#     return max_sum\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5]\n    k = 3\n    print findMaxSubArray(arr, k)",
    "from collections import deque\n\nclass Solution:\n    \"\"\"\n    @param A: A list of integers\n    @param i: An integer\n    @param k: An integer\n    @return: The maximum sum of increasing subsequence\n    \"\"\"\n    def maxSubArray(self, A, i, k):\n        if i == len(A) - 1:\n            return A[i]\n        \n        max_sum = A[i]\n        min_sum = A[i]\n        \n        for j in range(i+1, len(A)):\n            if j > i:\n                max_sum = max(max_sum, A[j] + maxSubArray(A, j, k))\n            else:\n                min_sum = min(min_sum, A[j] + minSubArray(A, j, k))\n            \n        return max_sum if max_sum > min_sum else min_sum",
    "class Solution:\n    # @param {string} s\n    # @param {string} prefix\n    # @param {string} suffix\n    # @param {integer} k\n    # @return {integer}\n    def maxSubArray(self, s, prefix, suffix, k):\n        if k == 0:\n            return 0\n        if k == 1:\n            return s[0]\n        if suffix == s:\n            return 0\n        if prefix == s:\n            return 0\n        if suffix == s[:k]:\n            return self.maxSubArray(s, prefix, s[k:], k - 1)\n        if prefix == s[:k]:\n            return self.maxSubArray(s, s[k:], suffix, k - 1)\n        if suffix > prefix:\n            return max(self.maxSubArray(s, prefix, s[k:], k - 1),\n                       self.maxSubArray(s, s[k:], suffix, k - 1))\n        else:\n            return max(self.maxSubArray(s, prefix, s[k:], k - 1),\n                       self.maxSubArray(s, s[k:], suffix, k - 1))\n\n\nif __name__ == '__main__':\n    print Solution().maxSubArray('abcabc', 'abc', 'abc', 3)",
    "def find_max_subsequence(prefix, i, k):\n    \"\"\"\n    :type prefix: str\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # find the max subsequence length\n    max_length = 0\n    # loop over all characters\n    for char in prefix:\n        # loop over all subsequence length\n        for length in range(1, max_length + 1):\n            # loop over all possible subsequence\n            for j in range(i - length + 1, i + 1):\n                # check if the current subsequence has a kth element after i\n                if j >= i and j <= i + k - 1:\n                    # check if the current subsequence is the max\n                    if j == i + k - 1:\n                        max_length = max(max_length, length)\n                    # break out of the loop if the current subsequence is not the max\n                    else:\n                        break\n    return max_length\n\n\nprint(find_max_subsequence(\"aabbcc\", 4, 3))",
    "class Solution(object):\n    def maxSubArray(self, s, i):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        if not s or i == len(s):\n            return 0\n        \n        # We need to check if i is in the subsequence\n        if i < len(s) - 1 and s[i] < s[i + 1]:\n            return self.maxSubArray(s, i + 1)\n        \n        # We need to check if i is in the subsequence\n        if i < len(s) - 2 and s[i] < s[i + 2]:\n            return self.maxSubArray(s, i + 2)\n        \n        # We need to check if i is in the subsequence\n        if i < len(s) - 3 and s[i] < s[i + 3]:\n            return self.maxSubArray(s, i + 3)\n        \n        return max(s[i] + self.maxSubArray(s, i + 1), s[i] + self.maxSubArray(s, i + 2), s[i] + self.maxSubArray(s, i + 3))",
    "class Solution(object):\n    def maxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        if len(arr) == 1:\n            return arr[0]\n        if arr[0] <= k:\n            return arr[0]\n        res = arr[0]\n        for i in xrange(1, len(arr)):\n            if arr[i] <= k:\n                res = max(res, arr[i])\n            else:\n                res = max(res, arr[i] + arr[i - 1])\n        return res\n\n\n    def maxSubArray2(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        if len(arr) == 1:\n            return arr[0]\n        if arr[0] <= k:\n            return arr[0]\n        res = arr[0]\n        for i in xrange(1, len(arr)):\n            if arr[i] <= k:\n                res = max(res, arr[i])\n            else:\n                res = max(res, arr[i] + arr[i - 1])\n        return res\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3]\n    arr2 = [1, 2, 3]\n    arr3 = [1, 2, 3, 3]\n    arr4 = [1, 2, 3, 4]\n    arr5 = [1, 2, 3, 4, 4]\n    arr6 = [1, 2, 3, 4, 5]\n    arr7 = [1, 2, 3, 4, 5, 5]\n    arr8 = [1, 2, 3, 4, 5, 5, 5]\n    arr9 = [1, 2, 3, 4, 5, 5, 5, 5]\n    arr10 = [1, 2, 3, 4, 5, 5, 5, 5, 5",
    "from collections import defaultdict\n\ndef find_max_sum_increasing_subsequence(arr, i, k):\n    # return the max sum increasing subsequence\n    # [1, 2, 3, 4, 5, 6, 7, 8]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n\n    # for the given array of size n and k\n    # find the max sum increasing subsequence\n    # max_sum_increasing_subsequence(arr, k, 0) -> [1, 2, 3, 4, 5, 6]\n    # max_sum_increasing_subsequence(arr, k, 1) -> [1, 2, 3, 4, 5, 6, 7]\n    # max_sum_increasing_subsequence(arr, k, 2) -> [1, 2, 3, 4, 5, 6, 7, 8]\n    # max_sum_increasing_subsequence(arr, k, 3) -> [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # max_sum_increasing_subsequence(arr, k, 4) -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # max_sum_increasing_subsequence(arr, k, 5) -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    # max_sum_increasing_subsequence(arr, k, 6) -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    # max_sum",
    "import sys\n\ndef findMaxSubSum(arr, i, k):\n    \"\"\"\n    :type arr: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if i == 0:\n        return arr[0]\n    if i == len(arr):\n        return arr[i]\n    if arr[i] > arr[i + 1]:\n        return arr[i] + findMaxSubSum(arr, i + 1, k)\n    else:\n        return findMaxSubSum(arr, i + 1, k)\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    print(findMaxSubSum(arr, 4, 0))\n    print(findMaxSubSum(arr, 0, 0))\n    print(findMaxSubSum(arr, 4, 1))\n    print(findMaxSubSum(arr, 4, 2))\n    print(findMaxSubSum(arr, 4, 3))\n    print(findMaxSubSum(arr, 4, 4))\n    print(findMaxSubSum(arr, 4, 5))\n    print(findMaxSubSum(arr, 4, 6))\n    print(findMaxSubSum(arr, 4, 7))\n    print(findMaxSubSum(arr, 4, 8))\n    print(findMaxSubSum(arr, 4, 9))",
    "class Solution(object):\n    def maxSubArray(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        if len(A) == 1:\n            return A[0]\n        res, cur = A[0], A[0]\n        for i in range(1, len(A)):\n            cur = max(cur + A[i], A[i])\n            res = max(res, cur)\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 3))\n    print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 5))\n    print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 0))",
    "class Solution(object):\n    def maxSumSubseq(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        max_sum = A[0]\n        max_sum_subseq = A[0]\n        for i in xrange(1, len(A)):\n            max_sum_subseq = max(max_sum_subseq + A[i], A[i])\n            max_sum = max(max_sum, max_sum_subseq)\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    print Solution().maxSumSubseq([1,2,3,4,5], 2)",
    "import collections\n\n\nclass Solution:\n    def maxSumSubseq(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        prefix = collections.deque()\n        for i in range(len(A)):\n            prefix.append(A[i])\n        if k == 0:\n            return sum(prefix)\n        return max(self.maxSumSubseq(A[i:], k-1) for i in range(len(A)) if i > k-1) + max(prefix)\n\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3]\n    k = 2\n    assert 3 == Solution().maxSumSubseq(A, k)",
    "class Solution(object):\n    def maxSumOfIncSubseq(self, s, i, k):\n        \"\"\"\n        :type s: str\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if i >= len(s):\n            return 0\n        dp = [0] * (i+1)\n        dp[0] = 0\n        for j in xrange(i, 0, -1):\n            dp[j] = max(dp[j-1], dp[j]) + s[j]\n        if k >= i:\n            return max(dp[i], dp[i-1])\n        else:\n            return max(dp[i], dp[i-1])\n\nclass Solution2(object):\n    def maxSumOfIncSubseq(self, s, i, k):\n        \"\"\"\n        :type s: str\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if i >= len(s):\n            return 0\n        dp = [0] * (i+1)\n        dp[0] = 0\n        for j in xrange(i, 0, -1):\n            dp[j] = max(dp[j-1], dp[j]) + s[j]\n        if k >= i:\n            return max(dp[i], dp[i-1])\n        else:\n            return max(dp[i], dp[i-1])",
    "from collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n\n    def max_sum_increasing_subsequence(self, prefix: List[int], k: int) -> int:\n        \"\"\"\n        Bubble Sort and then find the max sum\n        \"\"\"\n        n = len(prefix)\n        if n == 0:\n            return 0\n        dp = defaultdict(int)\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] + prefix[i], prefix[i])\n        dp[n] = max(dp[n - 1] + prefix[n], prefix[n] + k)\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert Solution().max_sum_increasing_subsequence([1, 2, 3], 0) == 3\n    assert Solution().max_sum_increasing_subsequence([1, 2, 3], 1) == 6\n    assert Solution().max_sum_increasing_subsequence([1, 2, 3], 2) == 6",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthSumAfter(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < k:\n            return 0\n        k_sum = 0\n        for i in xrange(n):\n            if i == k:\n                k_sum += nums[i]\n                continue\n            k_sum += nums[i]\n            if k_sum > nums[i]:\n                k_sum -= nums[i]\n            else:\n                return k_sum\n        return k_sum\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findKthSumAfter([1,2,3,4], 3)",
    "# Time:  O(n^2)\n# Space: O(n)\n# DFS\n#\n# 2ms 100%\nclass Solution(object):\n    def maxSubArray(self, s, i, k):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == i:\n            return s[k]\n        if i == 0:\n            return 0\n        if i == len(s) - 1:\n            return max(0, s[i] + s[i-1])\n        return max(0, max(s[i], self.maxSubArray(s, i-1, k)) + s[i])\n\n# Time:  O(n)\n# Space: O(1)\n# DP\nclass Solution2(object):\n    def maxSubArray(self, s, i, k):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if i == len(s) - 1:\n            return max(0, s[i] + s[i-1])\n        return max(0, max(s[i], self.maxSubArray(s, i-1, k) + s[i]))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def maxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n\n        if not arr or k < 0:\n            return 0\n\n        m, n = len(arr), len(arr[0])\n\n        # Find the max subarray from start to end\n        max_sum = arr[0][0]\n        max_index = 0\n        for i in xrange(m):\n            max_sum = max(max_sum, arr[i][0] + arr[i][1])\n            if arr[i][0] + arr[i][1] >= k:\n                max_index = i\n\n        # Find the max subarray from end to start\n        max_sum = arr[-1][-1]\n        max_index = len(arr) - 1\n        for i in xrange(n - 1, -1, -1):\n            max_sum = max(max_sum, arr[-1][i] + arr[-1][i + 1])\n            if arr[-1][i] + arr[-1][i + 1] >= k:\n                max_index = len(arr) - 1 - i\n\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6]\n    arr2 = [1, 2, 3]\n    arr3 = [3, 2, 1]\n    arr4 = [1, 3, 2]\n    arr5 = [1, 2, 3, 4, 5]\n    arr6 = [2, 3, 1, 6, 5]\n    arr7 = [1, 2, 3, 4, 5, 6]\n    arr8 = [1, 2, 3, 4, 5, 6, 7]\n    arr9 = [1, 2, 3, 4, 5, 6,",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def findKthMaxSubseq(self, n, k):\n        max_sum = 0\n        cur_sum = 0\n        cur_index = 0\n        for i in xrange(n):\n            cur_sum += i\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n            if cur_sum > k:\n                break\n            while cur_index < i:\n                cur_sum -= n[cur_index]\n                cur_index += 1\n        return max_sum\n\nif __name__ == '__main__':\n    print Solution().findKthMaxSubseq(n=[1,2,3], k=4)\n    print Solution().findKthMaxSubseq(n=[1,2,3,4], k=4)",
    "class Solution(object):\n    def maxSumSubsequence(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # write your code here\n        max_sum = 0\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                max_sum = max(max_sum, A[i]+A[j])\n                if j+1 < len(A) and A[i] > A[j+1]:\n                    max_sum = max(max_sum, A[i]+A[j+1])\n        return max_sum",
    "def findMaxSum(arr, i, k):\n    # write your code here\n    if i == len(arr) or i == k:\n        return 0\n    if arr[i] > arr[i+1]:\n        return arr[i] + findMaxSum(arr, i+1, k)\n    else:\n        return findMaxSum(arr, i+1, k)\n\ndef main():\n    n = int(input())\n    arr = [int(arr) for arr in input().split()]\n    print(findMaxSum(arr, n, n))\n\nif __name__ == \"__main__\":\n    main()",
    "import unittest\n\nclass Solution:\n    # @param {integer} nums\n    # @param {integer} k\n    # @return {integer}\n    def maxSubArray(self, nums, k):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if k > len(nums):\n            return nums[-1]\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n        return max_sum\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-subarray-sum-with-increasing-prefix/solution/\n\nApproach #1: DP [Accepted]\nComplexity Analysis\nTime Complexity: O(N), where N is the length of the array.\nSpace Complexity: O(N).\n\n# 10ms 86.51%\nclass Solution {\n    public int maxSubArray(int[] nums, int k) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = Math.max(nums[i], nums[i - 1]) + nums[i];\n        }\n\n        return dp[nums.length - 1];\n    }\n}\n\n# 11ms 99.38%\nclass Solution {\n    public int maxSubArray(int[] nums, int k) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n\n        int sum = nums[0];\n        int maxSum = num",
    "#!/usr/bin/env python\n\nimport sys\n\nif len(sys.argv)!= 3:\n    sys.exit(\"Usage: %s <prefix> <k>\" % sys.argv[0])\n\nprefix = sys.argv[1]\nk = int(sys.argv[2])\n\ndef get_max_sum_subseq(prefix, k, i):\n    if i == 0:\n        return 0\n    \n    max_sum = 0\n    for j in range(i):\n        max_sum += get_max_sum_subseq(prefix, k, j)\n    \n    return max_sum + get_max_sum_subseq(prefix, k, i)\n    \n\nprint get_max_sum_subseq(prefix, k, len(prefix))",
    "# Note:\n# The input array is sorted.\n# The length of prefix is [1, k]\n# The input array is guaranteed to contain at least 2 elements.\n# The input array has at most 2^31-1 elements.\n# The length of prefix array and k is at most 2^31-1.\n\n# 2017.02.06\n\nfrom common.array import *\n\nclass Solution:\n    def maxSumFromKth(self, prefix, k):\n        \"\"\"\n        :type prefix: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # sort\n        prefix = sorted(prefix)\n        # find max sum from kth element\n        max_sum = 0\n        for i in range(len(prefix)):\n            max_sum = max(max_sum, prefix[i] + self.maxSumFromKth(prefix[:i] + prefix[i + 1:], k - i))\n        return max_sum\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    prefix = [1, 2, 3, 4, 5, 6, 7]\n    print(sol.maxSumFromKth(prefix, 7))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 7))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 6))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 5))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 4))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 3))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 2))\n    prefix = [1, 2, 3, 4, 5]\n    print(sol.maxSumFromKth(prefix, 1))",
    "#!/bin/python\nimport sys\n\n# Complete the maxSum function below.\ndef maxSum(arr, k):\n    if len(arr) < k:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            max_so_far = max(arr[i], arr[i-1]+arr[i])\n        else:\n            max_so_far = max(arr[i], max_so_far)\n    return max_so_far\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 6\n    print maxSum(arr, k)\n    # arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    # k = 7\n    # print maxSum(arr, k)",
    "class Solution(object):\n    def maxSubArray(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not arr: return 0\n        if k >= len(arr): return arr[0]\n        max_so_far = arr[0]\n        for i in xrange(1, len(arr)):\n            if arr[i] - arr[i-1] > 0:\n                max_so_far = max(max_so_far, arr[i] + arr[i-1])\n            else:\n                max_so_far = max(max_so_far, arr[i])\n        return max_so_far + arr[k]",
    "class Solution(object):\n    def findMaxSumSubseq(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s or not k:\n            return 0\n        return max(self.findMaxSumSubseq(s[:k], k), self.findMaxSumSubseq(s[k+1:], k)) + s[k]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMaxSumSubseq(\"abc\", 3)\n    print s.findMaxSumSubseq(\"abc\", 4)\n    print s.findMaxSumSubseq(\"abc\", 5)\n    print s.findMaxSumSubseq(\"abcd\", 3)\n    print s.findMaxSumSubseq(\"abcd\", 4)",
    "class Solution:\n    # @param {integer} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthSumAfter(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k < 0 or k > n:\n            return 0\n        if k == 0:\n            return nums[0]\n        if k == n:\n            return nums[-1]\n        if k == 1:\n            return max(nums[0], nums[-1])\n        if k == 2:\n            return max(nums[0], nums[-1]) + nums[k-1]\n        if k == 3:\n            return max(nums[0], nums[-1]) + nums[k-2] + nums[k-1]\n        if k <= n:\n            l = k-1\n            r = n\n            while l < r:\n                m = (l+r)/2\n                if nums[m] > nums[k-1]:\n                    r = m\n                else:\n                    l = m+1\n            return max(nums[l], nums[r]) + nums[k-1]\n        return 0\n\nif __name__ == '__main__':\n    print Solution().findKthSumAfter([1,2,3], 2)",
    "def get_max_increasing_subsequence(arr, i, k):\n    if i == len(arr) - 1:\n        return arr[i]\n    else:\n        max_sum = arr[i]\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i] and arr[j] > k:\n                max_sum = max(max_sum, arr[j] + get_max_increasing_subsequence(arr, j, k))\n        return max_sum\n\n\n\nprint(get_max_increasing_subsequence([1, 2, 3, 4, 5], 3, 6))",
    "#!/bin/python\n\nfrom collections import defaultdict\nfrom math import ceil\n\ndef find_max_sum_inc_seq(arr, i, k):\n    # write your code here\n    # arr is sorted\n    # k is an element after i\n    # find the max sum of increasing subsequence\n    # return the max sum\n    # the max sum is the sum of all elements in subsequence which is in increasing order\n    # if k > i, then return the max sum\n    # if k < i, then return 0\n    max_sum = 0\n    if i < 0:\n        return 0\n    if i >= len(arr):\n        return max_sum\n    if arr[i] > k:\n        max_sum += find_max_sum_inc_seq(arr, i - 1, k)\n    else:\n        max_sum = max(max_sum, arr[i] + find_max_sum_inc_seq(arr, i + 1, k))\n    return max_sum\n\ndef find_max_sum_inc_seq_recur(arr, i, k):\n    # write your code here\n    # arr is sorted\n    # k is an element after i\n    # find the max sum of increasing subsequence\n    # return the max sum\n    # the max sum is the sum of all elements in subsequence which is in increasing order\n    # if k > i, then return the max sum\n    # if k < i, then return 0\n    if i < 0:\n        return 0\n    if i >= len(arr):\n        return max_sum\n    if arr[i] > k:\n        max_sum = max(max_sum, find_max_sum_inc_seq_recur(arr, i - 1, k))\n    else:\n        max_sum = max(max_sum, arr[i] + find_max_sum_inc_seq_recur(arr, i + 1, k))\n    return max_sum\n\ndef find_max_sum_inc_seq_recur(arr, i, k):\n    # write your code here\n    # arr is sorted\n    # k is an element after i\n    # find the max sum of increasing subsequence",
    "def find_max_increasing_subsequence(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    max_sum = arr[0]\n    max_idx = 0\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            max_sum = max(max_sum, arr[i] + arr[i-1])\n            max_idx = i\n        else:\n            max_sum = max(max_sum, arr[i])\n    if k > max_idx:\n        max_sum = max(max_sum, arr[k] + arr[max_idx])\n    return max_sum\n\nif __name__ == '__main__':\n    arr = [5, 2, 6, 1, 3, 4]\n    k = 5\n    print find_max_increasing_subsequence(arr, k)",
    "from collections import Counter\n\n\nclass Solution:\n    def findMaxSumSubseq(self, prefix, i, k):\n        \"\"\"\n        :type prefix: str\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        prefix_len = len(prefix)\n        max_sum = 0\n        c = Counter(prefix)\n        for j in range(i, i + k):\n            if j >= prefix_len:\n                break\n            max_sum = max(max_sum, c[prefix[j]] + prefix_len - j)\n        return max_sum\n\n    def findMaxSumSubseq_2(self, prefix, i, k):\n        \"\"\"\n        :type prefix: str\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        prefix_len = len(prefix)\n        c = Counter(prefix)\n        max_sum = 0\n        for j in range(i, i + k):\n            if j >= prefix_len:\n                break\n            max_sum = max(max_sum, c[prefix[j]] + prefix_len - j)\n        return max_sum\n\n\nif __name__ == '__main__':\n    assert Solution().findMaxSumSubseq('a', 2, 3) == 8\n    assert Solution().findMaxSumSubseq('a', 3, 3) == 9\n    assert Solution().findMaxSumSubseq('abc', 0, 2) == 6\n    assert Solution().findMaxSumSubseq('abc', 1, 2) == 7\n    assert Solution().findMaxSumSubseq('abc', 2, 2) == 8",
    "# https://leetcode.com/problems/maximum-sum-of-increasing-subsequence/\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ans = -sys.maxsize - 1\n        for i in xrange(len(s)):\n            if i == k:\n                ans = max(ans, s[i])\n            else:\n                if i == 0:\n                    ans = max(ans, s[i])\n                else:\n                    ans = max(ans, s[i] + max(s[i-1], max(s[i-1], s[i-2])))\n        return ans",
    "def findMaxSumSubseq(arr, i, k):\n    if k > i:\n        return findMaxSumSubseq(arr, i, k - 1)\n    elif i == len(arr) - 1:\n        return arr[i]\n    else:\n        max_sum = 0\n        for j in range(i, len(arr)):\n            max_sum = max(arr[j] + max_sum, findMaxSumSubseq(arr, j + 1, k))\n        return max_sum\n\ndef main():\n    arr = [1,2,3,4,5,6,7]\n    print(findMaxSumSubseq(arr, 2, 4))\n    print(findMaxSumSubseq(arr, 0, 4))\n    print(findMaxSumSubseq(arr, len(arr) - 2, 4))\n    print(findMaxSumSubseq(arr, len(arr) - 1, 4))\n    print(findMaxSumSubseq(arr, len(arr) - 1, 6))\n    print(findMaxSumSubseq(arr, len(arr) - 1, 7))\n\nif __name__ == '__main__':\n    main()",
    "#!/bin/python\n\n# https://www.hackerrank.com/challenges/find-the-maximum-sum-of-increasing-subsequence\n\nfrom __future__ import print_function\nimport math\n\ndef max_sub_sum(arr, k, i):\n    max_sum = arr[0]\n    max_index = 0\n    for j in range(1, i):\n        max_sum = max(max_sum, arr[j] + max_sub_sum(arr, k, j))\n        max_index = max(max_index, j)\n    max_sum = max(max_sum, arr[i] + max_sub_sum(arr, k, i))\n    max_index = max(max_index, i)\n    return max_sum, max_index\n\n# Testcases\n\narr = [1, 2, 3, 4, 5]\nk = 2\ni = 2\nprint(\"Max sum is:\", max_sub_sum(arr, k, i))\n\narr = [1, 2, 3, 4, 5]\nk = 3\ni = 3\nprint(\"Max sum is:\", max_sub_sum(arr, k, i))\n\narr = [1, 2, 3, 4, 5]\nk = 4\ni = 4\nprint(\"Max sum is:\", max_sub_sum(arr, k, i))\n\narr = [1, 2, 3, 4, 5]\nk = 5\ni = 5\nprint(\"Max sum is:\", max_sub_sum(arr, k, i))",
    "import math\n\ndef max_increasing_subsequence(s, i, k):\n    \"\"\"\n    :type s: str\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if i == 0:\n        return 0\n    if i == len(s):\n        return 0\n    if i < len(s) and s[i] == s[i - 1]:\n        return max_increasing_subsequence(s, i - 1, k)\n    if s[i - 1] > k:\n        return max_increasing_subsequence(s, i - 1, k)\n    # if s[i - 1] < k:\n    #     return max_increasing_subsequence(s, i - 1, k)\n    return max(max_increasing_subsequence(s, i - 1, k), max_increasing_subsequence(s, i, k))\n\nprint(max_increasing_subsequence(\"aabbcc\", 3, 6))\n\n\"\"\"\nOutput:\n\n9\n\"\"\"",
    "class Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(s) < k:\n            return 0\n        res, curr, curr_sum = 0, 0, 0\n        for i in range(len(s)):\n            curr_sum += s[i]\n            if curr_sum >= k:\n                curr_sum -= s[i]\n                if curr_sum > res:\n                    res = curr_sum\n                curr = max(curr, i)\n        return res\n\n\nif __name__ == \"__main__\":\n    print Solution().maxSubArray([1,2,3,4,5], 5)\n    print Solution().maxSubArray([1,2,3,4,5], 6)\n    print Solution().maxSubArray([1,2,3,4,5], 7)\n    print Solution().maxSubArray([1,2,3,4,5], 8)",
    "class Solution:\n    # @param A, a list of integers\n    # @param i, an integer\n    # @param k, an integer\n    # @return an integer\n    def maxSubArray(self, A, i, k):\n        if not A:\n            return 0\n        if A[0] <= A[i]:\n            return max(self.maxSubArray(A[:i] + A[i+1:], i, k), self.maxSubArray(A[:i] + A[i+1:], i+1, k))\n        else:\n            return max(self.maxSubArray(A[:i] + A[i+1:], i, k), self.maxSubArray(A[:i] + A[i+1:], i+1, k+1))\n        \n\nif __name__ == '__main__':\n    sol = Solution()\n    A = [1, 2, -1, 4, 1, 3, -4, -1, -1, 1]\n    print sol.maxSubArray(A, 2, 4)\n    print sol.maxSubArray(A, 2, 5)\n    print sol.maxSubArray(A, 2, 6)\n    print sol.maxSubArray(A, 2, 7)\n    print sol.maxSubArray(A, 2, 8)",
    "from math import factorial\n\n\ndef max_increasing_subsequence_from_prefix_till_kth_element(arr, i, k):\n    max_sum = 0\n    if i >= len(arr):\n        return max_sum\n    subsum = arr[i]\n    for j in range(i):\n        if j < k:\n            subsum += arr[j]\n        else:\n            break\n        if subsum > max_sum:\n            max_sum = subsum\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 6, 7, 9, 10, 15]\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 3))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 3, 5))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 3, 10))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 0))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 2))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 3))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 4))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 5))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 6))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 7))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 8))\n    print(max_increasing_subsequence_from_prefix_till_kth_element(arr, 4, 9))\n    print(max_increasing_subsequence",
    "import numpy as np\n\n# input: k, i\n# output: max sum of increasing subsequence\ndef max_sum_increasing_subsequence(k, i):\n    if i < 0:\n        return 0\n    if i == 0:\n        return k\n    if k == 0:\n        return 0\n    if k == 1:\n        return 1\n    if k == 2:\n        return 1\n    if k == 3:\n        return 2\n    if k == 4:\n        return 3\n    if k == 5:\n        return 4\n    if k == 6:\n        return 5\n    if k == 7:\n        return 6\n    if k == 8:\n        return 7\n    if k == 9:\n        return 8\n    if k == 10:\n        return 9\n    if k == 11:\n        return 10\n    if k == 12:\n        return 11\n    if k == 13:\n        return 12\n    if k == 14:\n        return 13\n    if k == 15:\n        return 14\n    if k == 16:\n        return 15\n    if k == 17:\n        return 16\n    if k == 18:\n        return 17\n    if k == 19:\n        return 18\n    if k == 20:\n        return 19\n    if k == 21:\n        return 20\n    if k == 22:\n        return 21\n    if k == 23:\n        return 22\n    if k == 24:\n        return 23\n    if k == 25:\n        return 24\n    if k == 26:\n        return 25\n    if k == 27:\n        return 26\n    if k == 28:\n        return 27\n    if k == 29:\n        return 28\n    if k == 30:\n        return 29\n    if k == 31:\n        return 30\n    if k == 32:\n        return 31\n    if k == 33:\n        return 32\n    if k == 34:\n        return 33\n    if k == 35:\n        return 34\n    if k == 36:\n        return 35\n    if k == 37:\n        return 36\n    if k == 38:\n        return 37\n    if k == 39:\n        return 38\n    if k == 40:\n        return 39",
    "class Solution(object):\n    def maxSumOfTwo(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        if k == 1:\n            return max(self.maxSumOfTwo(s[i] for i in range(n)), self.maxSumOfTwo(s[i:n] for i in range(n)))\n        if k == 2:\n            return max(self.maxSumOfTwo(s[i] for i in range(n)), self.maxSumOfTwo(s[i:n] for i in range(n) if s[i:n].find(s[i]) < 0))\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - s[i]] + s[i])\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(i):\n                if j >= k:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + s[i - 1])\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + s[i - 1])\n        return dp[n][k]\n\n\nif __name__ == '__main__':\n    s = \"abc\"\n    k = 2\n    print(Solution().maxSumOfTwo(s, k))",
    "class Solution(object):\n    def maxSumOfSubseq(self, A, i, k):\n        \"\"\"\n        :type A: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # write your code here\n        \n        max_sum = 0\n        \n        for j in range(i, len(A)):\n            max_sum = max(max_sum, A[j] + self.maxSumOfSubseq(A, j + 1, k))\n        \n        return max_sum",
    "import math\nimport os\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def maxSubArray(self, nums, k):\n        if nums == None or nums == []:\n            return 0\n        \n        max_sum = nums[0]\n        max_k = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n            if nums[i] > k:\n                max_k = max(max_k, nums[i])\n        return max_sum + max_k\n        \nif __name__ == \"__main__\":\n    sol = Solution()\n    \n    nums = [1,1,1,2,2,2,3,3,3]\n    k = 2\n    print \"max sum = \", sol.maxSubArray(nums, k)\n    \n    nums = [1,2,3,4,5,6]\n    k = 2\n    print \"max sum = \", sol.maxSubArray(nums, k)\n    \n    nums = [1,2,3,4,5,6,7,8,9]\n    k = 3\n    print \"max sum = \", sol.maxSubArray(nums, k)\n    \n    nums = [1,2,3,4,5,6,7,8,9,10,11,12]\n    k = 5\n    print \"max sum = \", sol.maxSubArray(nums, k)\n    \n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n    k = 7\n    print \"max sum = \", sol.maxSubArray(nums, k)\n    \n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]",
    "def get_max_sub_seq(prefix, k, i):\n    # write your code here\n    max_sum = 0\n    for j in range(i+1, len(prefix)):\n        if prefix[j] > k:\n            break\n        if prefix[j] > prefix[i]:\n            max_sum = max(max_sum, prefix[j] + get_max_sub_seq(prefix[i+1:], k, i+1))\n    return max_sum\n\nprint(get_max_sub_seq('b', 3, 2))",
    "class Solution(object):\n    def maxSumSubseq(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        if not k:\n            return 0\n        dp = [[0] * (k + 1) for _ in xrange(len(s) + 1)]\n        dp[0][0] = dp[0][1] = 0\n        for i in xrange(1, len(s) + 1):\n            dp[i][0] = dp[i][1] = dp[i - 1][1]\n            for j in xrange(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + s[i - 1] - s[j - 1])\n        return dp[-1][-1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxSumSubseq(\"ABCD\", 3)",
    "class Solution(object):\n    def maxSumOfThreeSubseq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return max(self.threeSum(nums, k), self.twoSum(nums, k), self.oneSum(nums, k))\n\n    def threeSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return self.threeSum(nums[:-1], k, 0, len(nums)-1)\n\n    def twoSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return self.twoSum(nums[:-1], k, 0, len(nums)-1)\n\n    def oneSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return self.oneSum(nums[:-1], k, 0, len(nums)-1)\n\n\nif __name__ == \"__main__\":\n    print Solution().maxSumOfThreeSubseq([-2, -3, -4, -1, -2], 4)",
    "class Solution:\n    # @param s, a string\n    # @param k, an integer\n    # @return an integer\n    def findKthSumAfter(self, s, k):\n        start, end = 0, len(s) - 1\n        max_sum = 0\n        while start <= end:\n            sum = 0\n            while start < end:\n                sum += s[start]\n                start += 1\n            if sum > max_sum:\n                max_sum = sum\n            if sum < k:\n                start -= 1\n            else:\n                end -= 1\n        return max_sum\n\n    # @param s, a string\n    # @param k, an integer\n    # @return an integer\n    def findKthSumAfter2(self, s, k):\n        start, end = 0, len(s) - 1\n        max_sum = 0\n        while start <= end:\n            sum = 0\n            while start < end:\n                sum += s[start]\n                start += 1\n            if sum > max_sum:\n                max_sum = sum\n            if sum < k:\n                start -= 1\n            else:\n                end -= 1\n        return max_sum\n\n\nif __name__ == '__main__':\n    print(Solution().findKthSumAfter('aab', 1))\n    print(Solution().findKthSumAfter('ab', 3))\n    print(Solution().findKthSumAfter2('aab', 1))\n    print(Solution().findKthSumAfter2('ab', 3))",
    "from collections import Counter\n\ndef max_increasing_subsequence(prefix, k, i):\n    if i == len(prefix) - 1:\n        return prefix[i]\n    else:\n        # Get all subsequences starting from i\n        subsequence = [prefix[i]]\n        for j in range(i + 1, len(prefix)):\n            # If the sum of all elements in subsequence is less than k, then the sum of increasing subsequence is less than k\n            if sum(subsequence) < k:\n                subsequence.append(prefix[j])\n            # If the sum of all elements in subsequence is greater than k, then the sum of increasing subsequence is greater than k\n            elif sum(subsequence) > k:\n                break\n        return max(subsequence)\n\ndef test_max_increasing_subsequence():\n    assert max_increasing_subsequence(\"abcd\", 2, 3) == \"bcd\"\n    assert max_increasing_subsequence(\"abcdef\", 3, 3) == \"abc\"\n    assert max_increasing_subsequence(\"abcdef\", 3, 2) == \"abc\"\n\ndef main():\n    test_max_increasing_subsequence()\n\nif __name__ == \"__main__\":\n    main()",
    "# https://oj.leetcode.com/problems/maximum-sum-of-increasing-subsequences/\n\nclass Solution(object):\n    def findKthLargest(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if len(arr) == 1:\n            return arr[0]\n        \n        p = 0\n        r = len(arr) - 1\n        while p < r:\n            m = (p + r) / 2\n            if arr[m] < arr[p]:\n                p = m + 1\n            elif arr[m] > arr[p]:\n                r = m\n            else:\n                break\n        \n        if k == p:\n            return arr[p]\n        elif k > p:\n            return self.findKthLargest(arr[p + 1:], k - p - 1)\n        else:\n            return self.findKthLargest(arr, k)",
    "import numpy as np\nfrom time import time\n\n# @include\ndef find_max_increasing_subsequence_from_prefix_till_index_and_kth_element(prefix, i, k):\n    # A list of lists of indices.\n    # Each inner list represents a subsequence of indices.\n    # The first inner list is the subsequence of indices from 0 to i - 1.\n    # The second inner list is the subsequence of indices from i + 1 to n - 1.\n    # The third inner list is the subsequence of indices from n - 1 to k.\n    # The inner lists are sorted in descending order.\n    # The last inner list is the subsequence of indices from k + 1 to n - 1.\n    increasing_subsequence = [[0] + [i + 1] + [n - 1] for i in range(n)]\n    increasing_subsequence[0].append(k + 1)\n    increasing_subsequence[1].append(k + 1)\n    for j in range(i + 1, n):\n        increasing_subsequence[0][j] = increasing_subsequence[0][j - 1] + 1\n        increasing_subsequence[1][j] = increasing_subsequence[1][j - 1] + 1\n        if increasing_subsequence[0][j] > increasing_subsequence[0][j - 1]:\n            increasing_subsequence[0][j] = increasing_subsequence[0][j - 1]\n        if increasing_subsequence[1][j] > increasing_subsequence[1][j - 1]:\n            increasing_subsequence[1][j] = increasing_subsequence[1][j - 1]\n        if increasing_subsequence[0][j] > increasing_subsequence[1][j]:\n            increasing_subsequence[0][j] = increasing_subsequence[1][j]\n    return max(increasing_subsequence[0])\n# @exclude\n\n\ndef _test_find_max_increasing_subsequence_from_prefix_till_index_and_kth_element():\n    n = 10\n    prefix = [2, 5, 6, 7, 8]\n    k = 4\n    assert find_max_increasing_subsequence_",
    "class Solution:\n    # @param A, a list of integers\n    # @param i, an integer\n    # @param k, an integer\n    # @return an integer\n    def maxSumFromPos(self, A, i, k):\n        # write your code here\n        if i == len(A) - 1:\n            return A[i]\n        elif i == len(A) - 2:\n            return max(A[i] + A[i + 1], A[i])\n        else:\n            return max(A[i] + max(self.maxSumFromPos(A, i + 1, k), self.maxSumFromPos(A, i + 2, k)), A[i])",
    "# https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-from-prefix-till-ith-index-and-including-kth-element/\n# https://leetcode.com/problems/maximum-sum-increasing-subsequence-from-prefix-till-ith-index-and-including-kth-element/\n\n\ndef max_sum_increasing_subsequence_from_prefix_till_ith_index_and_including_kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not arr or len(arr) < 2:\n        return 0\n    l = len(arr)\n    n = len(arr) - 1\n    max_sum = arr[0]\n    for i in range(1, n):\n        if arr[i] >= arr[i - 1]:\n            max_sum = max(max_sum, arr[i] + arr[i - 1])\n        else:\n            max_sum = max(max_sum, arr[i] + arr[i - 1] + arr[i + 1])\n    return max(max_sum, arr[l] + arr[l - 1] + arr[k])\n\n\n# TESTS\nfor arr, k, expected in [\n    ([1, 2, 3, 4, 5, 6], 4, 12),\n    ([1, 2, 3, 4, 5, 6], 7, 7),\n    ([1, 2, 3, 4, 5, 6], 6, 6),\n]:\n    res = max_sum_increasing_subsequence_from_prefix_till_ith_index_and_including_kth_element(arr, k)\n    print(\"Max sum increasing subsequence from prefix till ith index and including kth element =\", res)\n    assert res == expected",
    "class Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        max_so_far = s[0]\n        pre_max = s[0]\n        for i in range(1, len(s)):\n            if i < k:\n                max_so_far = max(max_so_far, s[i])\n            else:\n                max_so_far = max(max_so_far, s[i] + s[i-k])\n            pre_max = max(pre_max, max_so_far)\n        return pre_max\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 3) == 5\n    assert Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 2) == 4\n    assert Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 1) == -2\n    assert Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4], 4) == -5",
    "class Solution(object):\n    def findMaxSumSubseq(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0 or k == 0:\n            return 0\n        max_sum = arr[0]\n        for i in range(1, len(arr)):\n            max_sum = max(arr[i], max_sum + arr[i])\n        max_sum = max(max_sum, arr[k-1])\n        for i in range(k, len(arr)):\n            max_sum = max(max_sum, arr[i])\n        return max_sum",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @param {integer} i\n    # @return {integer}\n    def findMaxSumSubseq(self, n, k, i):\n        max_sum = 0\n        for j in range(i, n):\n            if j == i or j < k:\n                max_sum += j\n            else:\n                max_sum = max(max_sum, j + max(0, k - j))\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findMaxSumSubseq(5, 1, 2))\n    print(sol.findMaxSumSubseq(5, 2, 3))",
    "def find_max_sum_increasing_subsequence(arr, k, i):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :type i: int\n    :rtype: int\n    \"\"\"\n    if k < i:\n        return 0\n\n    if k == i:\n        return arr[i]\n    \n    if k > i:\n        return max(arr[i], find_max_sum_increasing_subsequence(arr, k, i - 1))\n\n    return max(arr[i], max(find_max_sum_increasing_subsequence(arr, k, i - 1), find_max_sum_increasing_subsequence(arr, k, i - 2)))\n\n# Your func will be called as such:\n# find_max_sum_increasing_subsequence(arr, k, i)\n\n# Note:\n# arr will be a list of integers.\n# k will be an integer.\n# i will be an integer.\n# arr[0] will be 0.\n\n# Your function should return the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i.\n\n# Example 1:\n# Input: arr = [1,2,3], k = 2, i = 3\n# Output: 4\n# Explanation: The maximum sum of increasing subsequence is 4.\n# Note:\n# - 1 <= arr.length <= k <= arr[0].length <= 100\n# - arr[0] <= arr[i] <= k <= arr[i].length <= 100\n# - arr[0] <= arr[i] <= arr[i + 1] <= k <= 100\n\n# Example 2:\n# Input: arr = [1,2,3,4], k = 3, i = 3\n# Output: 7\n# Explanation: The maximum sum of increasing subsequence is 7.\n# Note:\n# - 1 <= arr.length <= k <= arr[0].length <= 100\n# - arr[0] <= arr[i] <= k <= arr[i].length <= 100\n# - arr[0] <= arr[i] <= arr[i + 1] <= k <= 100\n\n# Example 3",
    "from collections import defaultdict\nimport math\n\n\n# @include\ndef max_subarray_sum_from_i(A, i, k):\n    max_sum = 0\n    prev_sum = 0\n    for j in range(i, len(A)):\n        if j - i < k:\n            prev_sum = 0\n        else:\n            prev_sum = max(prev_sum, A[i:j])\n        max_sum = max(max_sum, prev_sum + A[j])\n    return max_sum\n# @exclude\n\n\ndef main():\n    A = [1, 2, 3, 4, 5]\n    # Expected output: 5\n    # max_subarray_sum_from_i(A, 0, 1) ==> 5\n    # max_subarray_sum_from_i(A, 1, 2) ==> 4\n    # max_subarray_sum_from_i(A, 2, 3) ==> 3\n    # max_subarray_sum_from_i(A, 3, 4) ==> 2\n    # max_subarray_sum_from_i(A, 4, 5) ==> 1\n    # max_subarray_sum_from_i(A, 5, 6) ==> 0\n    assert max_subarray_sum_from_i(A, 0, 1) == 5\n    assert max_subarray_sum_from_i(A, 1, 2) == 4\n    assert max_subarray_sum_from_i(A, 2, 3) == 3\n    assert max_subarray_sum_from_i(A, 3, 4) == 2\n    assert max_subarray_sum_from_i(A, 4, 5) == 1\n    assert max_subarray_sum_from_i(A, 5, 6) == 0\n\n    A = [1, 2, 3]\n    # Expected output: 1\n    # max_subarray_sum_from_i(A, 0, 1) ==> 1\n    # max_subarray_sum_from_i(A, 1, 2) ==> 1\n    # max_subarray_sum_from_i(A, 2, 3",
    "import unittest\nimport timeit\n\n\nclass Solution(object):\n    def maxSubSum(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n\n        arr.sort()\n        max_so_far = arr[0]\n\n        for i in xrange(1, len(arr)):\n            max_so_far = max(max_so_far + arr[i], arr[i])\n\n        for i in xrange(len(arr)):\n            if arr[i] >= k:\n                max_so_far = max(max_so_far, arr[i])\n\n        return max_so_far\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-sum-of-increasing-subsequence/solution/\n\n# 2ms 100%\nclass Solution {\n    public int maxSubSum(int[] nums, int k) {\n        if (nums == null || nums.length == 0) return 0;\n        Arrays.sort(nums);\n        int max = nums[0];\n        int sum = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum += nums[i];\n            if (sum > k) {\n                max = Math.max(max, sum);\n                sum = nums[i];\n            }\n        }\n        return max;\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public int maxSubSum(int[] nums, int k) {\n        if (nums == null || nums.length == 0) return 0;\n        Arrays.sort(nums);\n        int max = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (n",
    "class Solution(object):\n    def findMaxSumSubsequence(self, nums, i, k):\n        \"\"\"\n        :type nums: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0 for _ in xrange(n)]\n        max_sum = 0\n        for j in xrange(1, i):\n            for i in xrange(j, n):\n                dp[i] = max(dp[i], dp[j] + nums[i])\n                max_sum = max(max_sum, dp[i])\n        return max_sum\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,1,2,3]\n    print Solution().findMaxSumSubsequence(nums, 5, 3)",
    "class Solution:\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        if len(s) == 1:\n            return s[0]\n        if k > len(s):\n            return 0\n        # Find the max sum of increasing subsequence from prefix till i\n        max_sum = 0\n        j = 0\n        for i in range(len(s)):\n            if j == k - 1:\n                break\n            if s[i] > s[j]:\n                max_sum = max(max_sum, s[i] + self.maxSubArray(s[j+1:], k-1))\n                j += 1\n            else:\n                max_sum = max(max_sum, s[i] + self.maxSubArray(s[j+1:], k-1))\n        return max_sum\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2:\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        if len(s) == 1:\n            return s[0]\n        # Find the max sum of increasing subsequence from prefix till i\n        max_sum = 0\n        j = 0\n        for i in range(len(s)):\n            if j == k - 1:\n                break\n            if s[i] > s[j]:\n                max_sum = max(max_sum, s[i] + self.maxSubArray(s[j+1:], k-1))\n                j += 1\n            else:\n                max_sum = max(max_sum, s[i] + self.maxSubArray(s[j+1:], k-1))\n        return max_sum",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param A, a list of integers\n    # @param i, an integer\n    # @param k, an integer\n    # @return an integer\n    def maxSubarraySum(self, A, i, k):\n        # write your code here\n        if i == len(A):\n            return 0\n        max_sum = 0\n        for j in range(i, len(A)):\n            max_sum = max(max_sum, A[j] + self.maxSubarraySum(A, j, k))\n        return max_sum",
    "class Solution(object):\n    def maxSumOfIncreasingSubsequence(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return arr[0]\n        \n        left, right = 0, len(arr)-1\n        max_sum = 0\n        while left < right:\n            if arr[left] < arr[right]:\n                max_sum = max(max_sum, arr[left] + arr[right] + arr[k-1])\n                right -= 1\n            else:\n                left += 1\n        max_sum = max(max_sum, arr[left] + arr[k-1])\n        return max_sum",
    "# Definition for an Interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def maxSumOfInterval(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        max_sum = 0\n        p = 0\n        for i in xrange(len(intervals)):\n            if i == k:\n                max_sum = max(max_sum, intervals[i].end)\n                continue\n            max_sum = max(max_sum, intervals[i].end + max(intervals[i+1].start - intervals[i].start, 0))\n        return max_sum",
    "def get_max_sum_increasing_subsequence(arr, i, k):\n    \"\"\"\n    :type arr: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    if i == 0:\n        return arr[0]\n    else:\n        max_sum = arr[0]\n        for j in range(1, i):\n            max_sum = max(max_sum, arr[j] + get_max_sum_increasing_subsequence(arr[j:], i, k))\n        return max_sum\n\n\ndef main():\n    print(get_max_sum_increasing_subsequence([0, 1, 2, 3, 4, 5], 3, 5))\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def maxIncreasingSubsequence(self, A, i, k):\n        \"\"\"\n        :type A: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n        dp = [0] * (i + 1)\n        dp[0] = 0\n        for j in range(1, i + 1):\n            dp[j] = max(A[j - 1] + dp[j - 1], A[j])\n        dp[i] = max(dp[i - 1], A[i])\n        if k > i:\n            dp[i] = max(dp[i], A[k])\n        return dp[i]",
    "import math\n\ndef max_sub_array(n, arr, k):\n    max_sum = 0\n    max_index = 0\n    for i in range(len(arr)):\n        if i == k:\n            max_sum = max(max_sum, arr[i])\n        else:\n            max_sum = max(max_sum, arr[i] + max_sub_array(n, arr, i))\n        if i >= n:\n            max_index = i\n    return max_sum, max_index\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 4\n    print max_sub_array(len(arr), arr, k)",
    "class Solution(object):\n    def findMaxSumSubseq(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        pre_sum = 0\n        for i in range(len(s)):\n            cur_sum = 0\n            for j in range(i, len(s)):\n                if j < k:\n                    cur_sum += s[j]\n                else:\n                    break\n            pre_sum = max(pre_sum, cur_sum)\n            max_sum = max(max_sum, pre_sum)\n        return max_sum",
    "class Solution(object):\n    def maxSubArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums or nums[0] == 0:\n            return 0\n\n        # store the maximum sum of increasing subsequence from i to the end\n        max_sum = nums[0]\n        j = 0\n\n        for i in xrange(1, len(nums)):\n            max_sum = max(max_sum, nums[i] + nums[j])\n            j = max(j, i)\n\n        # store the maximum sum of increasing subsequence from k to the end\n        max_sum = max(max_sum, nums[k] + nums[j])\n\n        return max_sum\n\n\nprint Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4], 3)",
    "# https://leetcode.com/problems/find-k-in-sorted-matrix-ii/\n# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def findKthSumFromSortedMatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]: return 0\n        res = 0\n        for i in range(k-1):\n            sum = 0\n            for j in range(len(matrix)):\n                sum += matrix[j][i]\n            if sum > res: res = sum\n        return res + matrix[k-1][i]",
    "# https://oj.leetcode.com/problems/maximum-sum-of-increasing-subsequences/\n# Given a list of non-negative integers, you are initially positioned at the first index of the list.\n#\n# Each element in the list represents your maximum jump length at that position.\n#\n# Determine if you are able to reach the last index.\n#\n# For example:\n# A = [2,3,1,1,4], return true.\n#\n# A = [3,2,1,0,4], return false.\n#\n# Companies\n# LinkedIn\n# Related Topics\n# Array\n# Similar Questions\n# Maximum Sum of Increasing Subsequence\n#\n#\n#\n# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def canJump(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if not nums or not k:\n            return False\n        n = len(nums)\n        if k > n:\n            return False\n        dp = [[0 for j in xrange(n)] for i in xrange(k)]\n        for i in xrange(k):\n            for j in xrange(n):\n                if j == i:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] + nums[j])\n        return dp[k - 1][n - 1] >= 0\n\n# Note:\n#\n# 1. Time Complexity: O(n).\n# 2. Space Complexity: O(n).",
    "class Solution:\n    # @param {string} str\n    # @param {string} k\n    # @return {string}\n    def findKthSumAfter(self, str, k):\n        if len(str) == 0:\n            return \"\"\n\n        def helper(str, i, k):\n            if i == len(str):\n                return 0\n            if k == i + 1:\n                return sum(str[i:])\n            else:\n                return max(helper(str, i + 1, k), helper(str, i, k - 1))\n\n        return helper(str, 0, k)\n\n\nif __name__ == '__main__':\n    print(Solution().findKthSumAfter(\"abcde\", 4))",
    "#!/usr/bin/env python\n\nfrom __future__ import print_function\nimport argparse\nimport math\n\n\ndef find_max_sum_increasing_subsequence(prefix, i, k):\n    \"\"\"\n    :type prefix: List[int]\n    :type i: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for j in range(i, len(prefix)):\n        sum = prefix[j]\n        if j!= i:\n            sum = sum + prefix[j - 1]\n        if sum > max_sum:\n            max_sum = sum\n    if k!= 0:\n        sum = prefix[i]\n        if k > i:\n            sum = sum + prefix[k - 1]\n        if sum > max_sum:\n            max_sum = sum\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description='Find maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i')\n    parser.add_argument('prefix', type=int, help='prefix')\n    parser.add_argument('i', type=int, help='i')\n    parser.add_argument('k', type=int, help='k')\n    args = parser.parse_args()\n    print(find_max_sum_increasing_subsequence(args.prefix, args.i, args.k))",
    "class Solution:\n    def maxSubArray(self, s, i, k):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return max(self.maxSubArray(s, i, k-1), self.maxSubArray(s, i+1, k))\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2:\n    def maxSubArray(self, s, i, k):\n        \"\"\"\n        :type s: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if i == len(s):\n            return k\n        if i == 0:\n            return s[0]\n        if s[i] > s[i-1]:\n            return s[i] + max(self.maxSubArray(s, i-1, k), self.maxSubArray(s, i, k-1))\n        else:\n            return max(self.maxSubArray(s, i-1, k), self.maxSubArray(s, i, k-1))",
    "class Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if k == 0:\n            return s[0]\n        max_sum = 0\n        for i in range(len(s)):\n            if i == k - 1:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i + 1:], k - 1))\n            else:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i + 1:], k))\n        return max_sum\n\n    def maxSubArray_2(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if k == 0:\n            return s[0]\n        max_sum = 0\n        for i in range(len(s)):\n            if i == k - 1:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i + 1:], k - 1))\n            else:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i + 1:], k))\n        return max_sum\n\n    def maxSubArray_3(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if k == 0:\n            return s[0]\n        max_sum = 0\n        for i in range(len(s)):\n            if i == k - 1:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i + 1:], k - 1))\n            else:\n                max_sum = max(max_sum, s[i] + maxSubArray(s[i +",
    "# https://leetcode.com/problems/maximum-sum-of-increasing-subsequence/discuss/132576/C++-Python-Solution\n\nclass Solution(object):\n    def maxSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_sum = -float('inf')\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i] + self.maxSum(nums[i+1:], k - i))\n        return max_sum\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.maxSum(nums,k)",
    "class Solution(object):\n    def maxSubArray(self, s, k):\n        \"\"\"\n        :type s: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        max_sum = s[0]\n        for i in range(1, n):\n            max_sum = max(max_sum + s[i], s[i])\n            if i >= k:\n                max_sum = max(max_sum, s[i - k])\n        return max_sum",
    "class Solution(object):\n    def maxSubArray(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not A or len(A) == 1:\n            return A[0] if A else 0\n        ans = 0\n        i = 0\n        while i < len(A):\n            if i > k:\n                ans = max(ans, A[i-1] + self.maxSubArray(A[i:], k))\n            else:\n                ans = max(ans, A[i] + self.maxSubArray(A[i+1:], k-i))\n            i += 1\n        return ans",
    "class Solution(object):\n    def findMaxSumSubseq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k < 0:\n            return -1\n        if k == 0:\n            return nums[0]\n        if k == 1:\n            return max(nums)\n        if k > n:\n            return 0\n        if k == n:\n            return max(nums)\n        if k > n:\n            return 0\n        if k == n + 1:\n            return max(nums)\n        if k == n + 2:\n            return max(nums) + nums[k - 1]\n        if k > n + 1:\n            return 0\n        if k > n + 2:\n            return 0\n        \n        # first max\n        max_subseq = nums[0]\n        max_subseq_index = 0\n        for i in range(1, k):\n            if max_subseq_index < i:\n                max_subseq = max(max_subseq, nums[i])\n                max_subseq_index = i\n        return max(max_subseq, nums[k - 1]) + nums[k - 1 - max_subseq_index]\n\nif __name__ == \"__main__\":\n    print Solution().findMaxSumSubseq([1,3,2,2,4,2,3,5,6], 1)",
    "class Solution(object):\n    def maxSubArray(self, A, i, k):\n        \"\"\"\n        :type A: List[int]\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        count = 1\n        while i < len(A):\n            if A[i] > k:\n                count += 1\n                if count > i - k + 1:\n                    res = max(res, A[i] + self.maxSubArray(A, i + 1, k))\n                count = 1\n            else:\n                count += 1\n            i += 1\n        return res\n\n\ns = Solution()\nA = [1,2,3,4,5]\ni = 3\nk = 5\nprint s.maxSubArray(A, i, k)",
    "class Solution(object):\n    def findMaximumSumOfSubsequence(self, s, i, k):\n        \"\"\"\n        :type s: str\n        :type i: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if i == 0:\n            return 0\n        if k == 0:\n            return 0\n        s += '0'\n        s += str(k)\n        s += str(i)\n        s = s[::-1]\n        max_sum = 0\n        for j in range(i, len(s)):\n            max_sum = max(max_sum, self.findMaximumSumOfSubsequence(s, j, k-1))\n        return max_sum",
    "import unittest\n\n\nclass TestMaximumSumSubsequence(unittest.TestCase):\n\n    def test_max_sum_subsequence(self):\n        self.assertEqual(max_sum_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n                         [1, 3, 3, 4, 5, 6, 6, 7, 8, 10])\n        self.assertEqual(max_sum_subsequence([1, 1]), [1, 1])\n        self.assertEqual(max_sum_subsequence([1, 1, 1]), [1, 1])\n        self.assertEqual(max_sum_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n                         [1, 3, 3, 4, 5, 6, 6, 7, 8, 10, 11])\n        self.assertEqual(max_sum_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),\n                         [1, 3, 3, 4, 5, 6, 6, 7, 8, 10, 11, 12])\n        self.assertEqual(max_sum_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]),\n                         [1, 3, 3, 4, 5, 6, 6, 7, 8, 10, 11, 12, 13, 14, 15])\n        self.assertEqual(max_sum_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]),\n                         [1, 3, 3, 4, 5, 6, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16])\n\n    def test_max_sum_subsequence2(self):\n        self.assertEqual(max_sum_subsequence2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]),\n                         [1, 3, 3, 4, 5, 6, 6, 7,"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}