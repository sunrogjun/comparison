{
  "problem": {
    "task_id": "MBPP/207",
    "prompt": "Write a function to count the longest repeating subsequences such that the two subsequences don\u2019t have same string characters at same positions.",
    "canonical_solution": "def find_longest_repeating_subseq(str): \r\n\tn = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]",
    "test_list": [
      "assert find_longest_repeating_subseq(\"AABEBCDD\") == 3",
      "assert find_longest_repeating_subseq(\"aabb\") == 2",
      "assert find_longest_repeating_subseq(\"aab\") == 1"
    ],
    "challenge_test_list": [],
    "problem_id": 196
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution:\n    \"\"\"\n    @param s: A string\n    @return: A list of lists of string\n    \"\"\"\n    def findLongestRepeatingSubsequence(self, s):\n        \"\"\"\n        @param s: A string\n        @return: A list of lists of string\n        \"\"\"\n        # write your code here\n        if len(s) == 0:\n            return []\n        res = [[]]\n        res_dict = {}\n        length = 1\n        for i in range(len(s)):\n            if i not in res_dict:\n                res_dict[i] = 0\n            while res_dict[i]!= 0 and s[i] == s[res_dict[i] - 1]:\n                res_dict[i] += 1\n                if res_dict[i] > length:\n                    length = res_dict[i]\n                res.append(res_dict[i])\n            res_dict[i] = 0\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.findLongestRepeatingSubsequence(\"abcabcbb\")\n    print sol.findLongestRepeatingSubsequence(\"aaabbb\")\n    print sol.findLongestRepeatingSubsequence(\"\")\n    print sol.findLongestRepeatingSubsequence(\"bbbbb\")",
    "def count_repeat(s, t):\n    # write your code here\n    n = len(s)\n    m = len(t)\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if s[i-1] == t[j-1]:\n                dp[i] = max(dp[i], dp[i-1] + 1)\n    return dp[n]\n\nif __name__ == '__main__':\n    s = \"abc\"\n    t = \"abc\"\n    print(count_repeat(s, t))",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        dp = [0] * len(nums)\n        for i in xrange(len(nums)):\n            dp[i] = 1\n            for j in xrange(i):\n                if nums[i] == nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        max_dp = 0\n        for i in xrange(len(nums)):\n            if dp[i] > max_dp:\n                max_dp = dp[i]\n        return max_dp",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        if not s1 or not s2:\n            return 0\n        if len(s1) <= len(s2):\n            return self.lcs(s1, s2, 0, 0, [])\n        else:\n            return self.lcs(s2, s1, 0, 0, [])\n\n    def lcs(self, s1, s2, i, j, ans):\n        if i == len(s1) or j == len(s2):\n            return len(s1)\n        if s1[i]!= s2[j]:\n            return 0\n        if ans[i] < j:\n            ans[i] = j\n        return max(self.lcs(s1, s2, i+1, j, ans), self.lcs(s1, s2, i, j+1, ans))",
    "import collections\nclass Solution(object):\n    def longestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/283379/C++-solution-using-hashmap\n        res = collections.Counter(s)\n        res_len = len(res)\n        if res_len == 0:\n            return 0\n        res_str = \"\".join(res.most_common(1))\n        return max(res_str.count(c) for c in s)\n\n\nif __name__ == \"__main__\":\n    print Solution().longestSubstring(\"adabd\")",
    "class Solution:\n    # @return a tuple, (the longest repeating subsequence, the longest repeating subsequence position)\n    def twoStrings(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: List[int]\n        \"\"\"\n        s1 = ''.join(s1)\n        s2 = ''.join(s2)\n        if s1 == s2:\n            return (s1, -1)\n        \n        # find the longest repeating subsequence\n        dp = [[0 for _ in xrange(len(s1)+1)] for _ in xrange(len(s2)+1)]\n        dp[0][0] = 1\n        for i in xrange(1, len(s1)+1):\n            for j in xrange(1, len(s2)+1):\n                if s1[i-1] == s2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n        \n        # find the longest repeating subsequence position\n        max_i = 0\n        max_j = 0\n        for i in xrange(len(s1)+1):\n            for j in xrange(len(s2)+1):\n                if dp[i][j] > max_i:\n                    max_i = dp[i][j]\n                if dp[i][j] > max_j:\n                    max_j = dp[i][j]\n        return (s1[max_i-1:], max_j)\n\nif __name__ == '__main__':\n    s1 = 'abcb'\n    s2 = 'abbc'\n    solution = Solution()\n    print solution.twoStrings(s1, s2)",
    "import collections\n\n# @include\ndef find_longest_repeat(s, n):\n    # Returns the length of the longest repeating subsequence of the given string\n    # Assumes that s[i] is unique, n is positive integer\n    # Assumes that s is a string of length at most n\n    # Assumes that s[i] is not the same for all i\n    # Returns the length of longest repeating subsequence of s\n    # If there is no longest repeating subsequence, return 0\n    longest_repeat = 0\n    repeat_dict = collections.defaultdict(int)\n    for i in range(len(s)):\n        repeat_dict[s[i]] += 1\n        if repeat_dict[s[i]] == n:\n            longest_repeat = max(longest_repeat, i - i % 2)\n        elif repeat_dict[s[i]] > n:\n            return 0\n    return longest_repeat\n# @exclude\n\n\ndef find_longest_repeat(s, n):\n    # Returns the length of the longest repeating subsequence of the given string\n    # Assumes that s[i] is unique, n is positive integer\n    # Assumes that s is a string of length at most n\n    # Assumes that s[i] is not the same for all i\n    # Returns the length of longest repeating subsequence of s\n    # If there is no longest repeating subsequence, return 0\n    longest_repeat = 0\n    repeat_dict = collections.defaultdict(int)\n    for i in range(len(s)):\n        repeat_dict[s[i]] += 1\n        if repeat_dict[s[i]] == n:\n            longest_repeat = max(longest_repeat, i - i % 2)\n        elif repeat_dict[s[i]] > n:\n            return 0\n    return longest_repeat\n\n\ndef find_longest_repeat(s, n):\n    # Returns the length of the longest repeating subsequence of the given string\n    # Assumes that s[i] is unique, n is positive integer\n    # Assumes that s is a string of length at most n\n    # Assumes that s[i] is not the same for all i",
    "#!/usr/bin/python\n\nimport sys\n\ndef countLongestRepeatingSubsequence(string):\n    # write your code here\n    if not string:\n        return 0\n    # write your code here\n    dic = {}\n    count = 0\n    l = len(string)\n    for i in range(0, l):\n        if string[i] in dic:\n            dic[string[i]].append(i)\n        else:\n            dic[string[i]] = [i]\n    for key in dic:\n        count += 1\n        for j in range(len(dic[key]) - 1, -1, -1):\n            if dic[key][j]!= j + 1:\n                break\n            dic[key].pop(j)\n    return count\n\nif __name__ == \"__main__\":\n    s = sys.argv[1]\n    print countLongestRepeatingSubsequence(s)",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {integer}\n    def lengthOfLongestSubstring(self, s, t):\n        if not s: return 0\n        if not t: return 0\n        m = [[0] * len(t) for _ in xrange(len(s))]\n        n = [[0] * len(t) for _ in xrange(len(s))]\n        for i in xrange(len(s)):\n            for j in xrange(len(t)):\n                if s[i] == t[j]:\n                    m[i][j] = 1\n                    n[i][j] = 1\n                elif i - 1 >= 0 and s[i] == t[j] and m[i - 1][j] == 1:\n                    m[i][j] = max(m[i - 1][j], 1) + 1\n                    n[i][j] = max(n[i - 1][j], 1) + 1\n                elif j - 1 >= 0 and s[i] == t[j] and m[i][j - 1] == 1:\n                    m[i][j] = max(m[i][j - 1], 1) + 1\n                    n[i][j] = max(n[i][j - 1], 1) + 1\n        max_len = 0\n        max_pos = 0\n        for i in xrange(len(s)):\n            for j in xrange(len(t)):\n                if m[i][j] == 1:\n                    max_len = max(max_len, n[i][j])\n                    max_pos = max(max_pos, i)\n        return max_len\n\nprint Solution().lengthOfLongestSubstring('abcd', 'abcdd')\nprint Solution().lengthOfLongestSubstring('abcd', 'abcd')",
    "# O(n^2) time and space\n# Recursion\ndef longest_repeat(s, i, j):\n    if i >= len(s) or j >= len(s):\n        return 0\n\n    if s[i] == s[j]:\n        return 1 + longest_repeat(s, i+1, j+1)\n    else:\n        return 0\n\n\n# O(n) time and space\ndef longest_repeat(s):\n    res = 0\n    max_repeat = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                res = max(res, 1 + longest_repeat(s, i+1, j+1))\n                max_repeat = max(max_repeat, res)\n    return max_repeat\n\n\n# O(n) time and space\ndef longest_repeat(s):\n    res = 0\n    max_repeat = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                res = max(res, 1 + longest_repeat(s, i+1, j+1))\n                max_repeat = max(max_repeat, res)\n    return max_repeat\n\n\n# O(n) time and space\ndef longest_repeat(s):\n    res = 0\n    max_repeat = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                res = max(res, 1 + longest_repeat(s, i+1, j+1))\n                max_repeat = max(max_repeat, res)\n    return max_repeat",
    "import collections\n\n# https://leetcode.com/problems/longest-repeating-subsequence/\n# https://leetcode.com/problems/longest-increasing subsequence/\n\n\nclass Solution(object):\n    def findLRS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        start = 0\n        end = 0\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                if end - start > ans:\n                    ans = end - start\n                    start = i\n            else:\n                end = i\n        return ans\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findLRS([1, 1, 2, 2, 3, 3, 4, 4, 4, 4])\n    print s.findLRS([1, 1, 1, 2, 2, 3, 3, 4, 4])\n    print s.findLRS([1, 2, 3, 4])\n    print s.findLRS([1, 1, 1, 1, 1, 1, 1])\n    print s.findLRS([1, 2, 3, 4, 5, 6])\n    print s.findLRS([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5])\n    print s.findLRS([1, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5])\n    print s.findLRS([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\nclass Solution(object):\n    def findLRS(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        n, m = len(s), len(t)\n        dp = [[0] * (m+1) for _ in xrange(n+1)]\n        for i in xrange(n):\n            for j in xrange(m):\n                if s[i] == t[j]:\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]) + 1\n                else:\n                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j])\n        return dp[n][m]\n\n\ns = Solution()\ns.findLRS(\"aabccc\", \"cbbd\")\nprint s.findLRS(\"aabccc\", \"aabbcc\")\nprint s.findLRS(\"aabccc\", \"aabbccdd\")\nprint s.findLRS(\"aabccc\", \"aabbccdddd\")\nprint s.findLRS(\"aabccc\", \"aabbccdddddd\")",
    "# https://leetcode.com/problems/longest-repeating-subsequence/\nclass Solution(object):\n    def findLongestRepeating(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        res = 0\n        dic = {}\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] in dic:\n                if dic[s[i]] > max_len:\n                    max_len = dic[s[i]]\n                elif dic[s[i]] == max_len:\n                    res = max(res, i - dic[s[i]])\n            else:\n                dic[s[i]] = i\n        return res if res else -1\n\nif __name__ == \"__main__\":\n    print(Solution().findLongestRepeating(\"aabbbccd\"))\n    print(Solution().findLongestRepeating(\"bbabb\"))\n    print(Solution().findLongestRepeating(\"abcd\"))\n    print(Solution().findLongestRepeating(\"ababbbcd\"))\n    print(Solution().findLongestRepeating(\"aabbbbccd\"))",
    "def get_longest_repeat_subseq(str):\n    \"\"\"\n    :type str: str\n    :rtype: int\n    \"\"\"\n    subseq_count = {}\n    longest_repeat_subseq = 0\n    for i, c in enumerate(str):\n        if c in subseq_count:\n            subseq_count[c] += 1\n        else:\n            subseq_count[c] = 1\n        if i - subseq_count[c] + 1 > longest_repeat_subseq:\n            longest_repeat_subseq = i - subseq_count[c] + 1\n    return longest_repeat_subseq\n\n\nif __name__ == \"__main__\":\n    print get_longest_repeat_subseq(\"aabbbbb\")",
    "# Definition for a  subsequence.\n# class Subsequence(object):\n#     def __init__(self, s, t):\n#         self.s = s\n#         self.t = t\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: int\n        \"\"\"\n        ans = 0\n        if len(S) == 0 or len(T) == 0:\n            return ans\n        s = [0] * len(S)\n        t = [0] * len(T)\n        for i in range(len(S)):\n            s[i] = S[i]\n        for i in range(len(T)):\n            t[i] = T[i]\n        s_l = s.copy()\n        t_l = t.copy()\n        ans = 1\n        while len(s_l) > 0:\n            if s_l[0] == t_l[0]:\n                ans = max(ans, len(s_l))\n            s_l = s_l[1:]\n            t_l = t_l[1:]\n        return ans\n\n\nif __name__ == '__main__':\n    print(Solution().findLongestRepeatingSubsequence('abcabcbb', 'abc'))\n    print(Solution().findLongestRepeatingSubsequence('abcabcbb', 'bbc'))\n    print(Solution().findLongestRepeatingSubsequence('abcabcbb', 'abcbc'))",
    "# Time:  O(n^2)\n# Space: O(1)\n\n# Example 1:\n# Input: \"ababbcabbbc\"\n# Output: 4\n# Explanation: The two subsequences \"aabbb\" and \"abbbc\" are different.\n# Example 2:\n# Input: \"abcabc\"\n# Output: 3\n# Explanation: The two subsequences \"abc\" and \"abc\" are different.\n# Example 3:\n# Input: \"abcc\"\n# Output: 3\n# Explanation: The two subsequences \"a\" and \"bcc\" are different.\n# Example 4:\n# Input: \"bab\"\n# Output: 2\n# Explanation: The two subsequences \"b\" and \"ab\" are different.\n\nclass Solution(object):\n    def maxRepeatedSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        dp = [[0] * (n+1) for _ in xrange(n+1)]\n        for i in xrange(1, n+1):\n            dp[i][0] = 1\n        for i in xrange(1, n+1):\n            for j in xrange(1, i+1):\n                if s[i-1] == s[j-1]:\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + 1\n        return dp[-1][-1]",
    "class Solution(object):\n    def findLRS(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        # use longest increasing subsequence to solve problem\n        # use a stack to store the longest increasing subsequence\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/240780/Python-Solution-with-stack-and-backtracking-with-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/291155/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/281843/Java-Solution-with-backtracking-and-O(N^2)-time-and-space\n        # https://leetcode.com/problems/longest-repeating-subsequence",
    "# https://leetcode.com/problems/longest-repeating-subsequence/\n# \n# \n# Example 1:\n# \n# Input: s1 = \"babad\", s2 = \"bab\"\n# Output: 2\n# Explanation: \"bab\" is the longest repeating subsequence because \"bab\" has 2 repeating subsequences: [bab, baba], [ba, bab]\n# Example 2:\n# \n# Input: s1 = \"aabb\", s2 = \"aaaa\"\n# Output: 4\n# Explanation: \"aaaa\" is the longest repeating subsequence because \"aaaa\" has 4 repeating subsequences: [aaaa, aaa, aaa, aaa], [aaa, aaa, aaa, aaa], [aa, aaa, aaa, aaa], [aa, aaa, aaa, aaa]\n# Example 3:\n# \n# Input: s1 = \"aabb\", s2 = \"aa\"\n# Output: 1\n# Explanation: \"aa\" is the longest repeating subsequence because \"aa\" has 1 repeating subsequence: [aa, aa]\n# Example 4:\n# \n# Input: s1 = \"aa\", s2 = \"a\"\n# Output: 1\n# \n# \n# Constraints:\n# \n# \n# 1 <= s1.length <= 1000\n# 1 <= s2.length <= 1000\n# s1 and s2 consist of lowercase English letters only.\n# \n# \n# Follow up:\n# \n# What if s1 or s2 has more than one repeating subsequence?\n# In this case, the answer is the same as the above case.\n# \n# \n# \n# Follow up:\n# \n# What if we can't find the longest repeating subsequence?\n# In this case, return 0.\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n#",
    "#!/usr/bin/python\n\nimport sys\n\n# @include\ndef find_lps(strs):\n    \"\"\"\n    Returns the longest repeating subsequences for the given strings.\n    \"\"\"\n    result = []\n    for s in strs:\n        # Find the longest repeating subsequence of s.\n        lps = [s[0]]\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                lps.append(s[i])\n            else:\n                lps.pop()\n                lps.append(s[i])\n        result.append(lps)\n    return result\n\n\ndef main():\n    # Returns the longest repeating subsequences for the given strings.\n    strs = [\n        \"aabb\",\n        \"bbbb\",\n        \"abbbb\",\n        \"ababb\",\n        \"abc\",\n        \"abcd\"\n    ]\n    expected = [\n        [\"abbbb\"],\n        [\"bbbb\"],\n        [\"abbbb\", \"abbbb\"],\n        [\"abbbb\", \"abbbb\", \"abbbb\"],\n        [\"ababb\", \"abbbb\"],\n        [\"abc\"]\n    ]\n    result = find_lps(strs)\n    assert result == expected\n    print(\"time elapsed: {}\".format(round(time.time() - time_start, 3)))\n\n\n# @exercise\n# @include\n# def find_lps(strs):\n#     \"\"\"\n#     Returns the longest repeating subsequences for the given strings.\n#     \"\"\"\n#     result = []\n#     for s in strs:\n#         # Find the longest repeating subsequence of s.\n#         lps = [s[0]]\n#         for i in range(1, len(s)):\n#             if s[i] == s[i-1]:\n#                 lps.append(s[i])\n#             else:\n#                 lps.pop()\n#                 lps.append(s[i])\n#         result.append(lps)\n#     return result\n#\n#\n# def main():\n#     # Returns the longest repeating subsequences for the given strings.\n#     strs",
    "class Solution:\n    # @param A, a list of integers\n    # @param B, a list of integers\n    # @return an integer\n    def findLongestRepeating(self, A, B):\n        if not A or not B or len(A)!= len(B):\n            return 0\n        m = [[0 for i in range(len(B))] for j in range(len(A))]\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    m[i][j] = 1 + max(m[i][j-1], m[i+1][j])\n                else:\n                    m[i][j] = 0\n        return max(m[0])",
    "class Solution(object):\n    def countRepeatedSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if len(s) == 1:\n            return 1\n        # sort the string and count the count of the longest repeating subsequences\n        s.sort()\n        res = 0\n        for i in range(len(s)):\n            if s[i] == s[i - 1]:\n                if i == 0:\n                    res = 1\n                else:\n                    res = max(res, i + 1)\n        return res",
    "from collections import defaultdict\nfrom collections import deque\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i][j] = length of longest subsequence of nums[i:j]\n        dp = [[0] * (j + 1) for j in range(len(nums) + 1)]\n        for i in range(1, len(nums) + 1):\n            for j in range(i):\n                if nums[j] == nums[i]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        return max(dp[len(nums)][-1], dp[len(nums) - 1][-1])\n\n    def findLongestRepeatingSubsequence1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i][j] = length of longest subsequence of nums[i:j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\n        dp = [[0] * (j + 1) for j in range(len(nums) + 1)]\n        for i in range(1, len(nums) + 1):\n            for j in range(i):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        return dp[len(nums)][-1]\n\nif __name__ == \"__main__\":\n    assert Solution().findLongestRepeatingSubsequence([1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4]) == 4\n    assert Solution().findLongestRepeatingSubsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11",
    "class Solution(object):\n    def findLongestRepeating(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        maxlen = 0\n        dp = [[0 for _ in xrange(len(s))] for _ in xrange(len(t))]\n        for i in xrange(len(s)):\n            for j in xrange(len(t)):\n                if s[i] == t[j]:\n                    dp[j][i] = 1 + dp[j][i-1]\n                else:\n                    dp[j][i] = max(dp[j][i], dp[j-1][i])\n        for i in xrange(len(t)):\n            maxlen = max(maxlen, dp[i][len(s)-1])\n        return maxlen\n\n\nif __name__ == \"__main__\":\n    assert Solution().findLongestRepeating(\"a\", \"b\") == 2\n    assert Solution().findLongestRepeating(\"aa\", \"a\") == 2\n    assert Solution().findLongestRepeating(\"aa\", \"a\") == 2\n    assert Solution().findLongestRepeating(\"aa\", \"aa\") == 2\n    assert Solution().findLongestRepeating(\"ab\", \"b\") == 2\n    assert Solution().findLongestRepeating(\"aabbcc\", \"aabb\") == 4\n    assert Solution().findLongestRepeating(\"aabbcc\", \"aabbcc\") == 4",
    "class Solution:\n    # @param s, a string\n    # @return an integer\n    def longestRepeatedSubstring(self, s):\n        # write your code here\n        if not s:\n            return 0\n        maxLen = 0\n        count = {}\n        for i in xrange(len(s)):\n            if s[i] not in count:\n                count[s[i]] = 1\n            else:\n                count[s[i]] += 1\n            if i == 0 or count[s[i-1]]!= count[s[i]]:\n                if i+1 < len(s) and count[s[i+1]]!= count[s[i]]:\n                    maxLen = max(maxLen, i+1-count[s[i]])\n        return maxLen\n\nif __name__ == '__main__':\n    print Solution().longestRepeatedSubstring(\"bbbccccccccccc\")",
    "import sys\n\ndef longest_repeat_subseq(string_seq):\n    max_len = 0\n    max_idx = 0\n    max_len_subseq = 0\n    max_idx_subseq = 0\n\n    for i in range(0, len(string_seq) - 1):\n        # Get the max len of two subsequences\n        max_len_subseq = 0\n        max_idx_subseq = 0\n        for j in range(i, len(string_seq)):\n            if string_seq[i] == string_seq[j]:\n                if max_len_subseq < (j - i + 1):\n                    max_len_subseq = j - i + 1\n                    max_idx_subseq = i\n                # If string_seq[i] is equal to string_seq[j], check if there are two subsequences with same length and position\n                elif max_len_subseq == (j - i + 1):\n                    if (j - i + 1) > max_len_subseq:\n                        max_len_subseq = j - i + 1\n                        max_idx_subseq = i\n        # If max_len_subseq is larger than max_len, then update max_len and max_idx\n        if max_len_subseq > max_len:\n            max_len = max_len_subseq\n            max_idx = max_idx_subseq\n        # If max_len_subseq is smaller than max_len, then update max_len and max_idx\n        elif max_len_subseq < max_len:\n            max_len = max_len_subseq\n            max_idx = max_idx_subseq\n\n    return max_idx + 1, max_len\n\n\nif __name__ == \"__main__\":\n    string_seq = \"aabccc\"\n    print(longest_repeat_subseq(string_seq))\n    string_seq = \"abcccba\"\n    print(longest_repeat_subseq(string_seq))\n    string_seq = \"abcde\"\n    print(longest_repeat_subseq(string_seq))",
    "def find_longest_repeating_subsequence(s, t):\n    if not s or not t:\n        return 0\n\n    longest_subseq = 0\n    longest_subseq_count = 0\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                if i + 1 >= len(s) or j + 1 >= len(t):\n                    return 0\n                if s[i + 1] == t[j + 1]:\n                    if s[i] == t[j]:\n                        longest_subseq_count += 1\n                        if longest_subseq_count > longest_subseq:\n                            longest_subseq = s[i:j + 2]\n                            longest_subseq_count = 1\n            else:\n                break\n    return longest_subseq\n\n\nprint(find_longest_repeating_subsequence('abcd', 'abcdef'))",
    "class Solution(object):\n    def longestRepeatedSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        def dfs(num):\n            # print num\n            if len(nums) == 1:\n                return 1\n            \n            max_l = 0\n            for i in range(len(nums)):\n                if i == 0:\n                    max_l = max(max_l, 1)\n                    continue\n                \n                for j in range(i):\n                    if nums[i] == nums[j]:\n                        max_l = max(max_l, dfs(num)+1)\n                        break\n            \n            return max_l\n        \n        return dfs(nums[0])\n\n\nif __name__ == \"__main__\":\n    print Solution().longestRepeatedSubsequence([1,1,2,2,3,3,3,4,4,4,5,5,5,5,5,5,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7",
    "def lrs(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: List[int]\n    \"\"\"\n    cnt = {}\n    for i in range(len(a)):\n        if a[i] in cnt:\n            cnt[a[i]] += 1\n        else:\n            cnt[a[i]] = 1\n    for i in range(len(b)):\n        if b[i] in cnt:\n            cnt[b[i]] -= 1\n        else:\n            cnt[b[i]] = -1\n    res = []\n    for i in cnt:\n        if cnt[i] > 0:\n            res.append(cnt[i])\n    return res\n\n# test cases\na = \"abcabcabcabc\"\nb = \"abcabcabcac\"\nprint(lrs(a, b))",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\nclass Solution(object):\n    def lengthOfLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            if nums[i] in d:\n                d[nums[i]] += 1\n            else:\n                d[nums[i]] = 1\n        max_len = 1\n        for i in range(len(nums)):\n            if nums[i] in d:\n                if d[nums[i]] > 1:\n                    max_len = max(max_len, d[nums[i]])\n                else:\n                    d.pop(nums[i])\n            else:\n                d.pop(nums[i])\n        return max_len",
    "class Solution(object):\n    def longestRepeatedSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n        dp = [ [ 0 for i in range(n+1)] for j in range(n+1) ]\n        # dp[i][j] = max(dp[i][j], dp[i-1][j])\n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n        ans = 0\n        for i in range(1, n+1):\n            for j in range(i, n+1):\n                if dp[i][j] > dp[i-1][j]:\n                    ans = max(ans, dp[i][j])\n        return ans\n\na = Solution()\nprint(a.longestRepeatedSubsequence([1,1,1,2,2,3]))",
    "class Solution:\n    # @param s, a string\n    # @return an integer\n    def numDistinct(self, s):\n        ans = 1\n        for i in range(len(s)):\n            ans *= (i + 1)\n        ans /= 2\n        for i in range(len(s) - 1):\n            j = i + 1\n            while j < len(s) and s[i] == s[j]:\n                j += 1\n            ans -= j * (j - 1) / 2\n        return ans\n\nif __name__ == '__main__':\n    s = 'abcd'\n    print(Solution().numDistinct(s))",
    "class Solution(object):\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: int\n        \"\"\"\n        if not A or not B:\n            return 0\n        m = [[0] * len(B) for _ in range(len(A))]\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    m[i][j] = m[i - 1][j - 1] + 1\n                else:\n                    m[i][j] = max(m[i][j - 1], m[i - 1][j])\n        return max(m[-1])",
    "class Solution(object):\n    def countRepeatedSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = 0\n        prev = \"\"\n        for c in s:\n            if c == prev:\n                count += 1\n            else:\n                count = 1\n                prev = c\n        return count",
    "# https://www.hackerrank.com/challenges/the-longest-repeating-subsequence/problem\n\ndef longest_repeating_subsequence(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return 0\n    if len(a) == 1 or len(b) == 1:\n        return 1\n    result = 0\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result = max(result, 1 + longest_repeating_subsequence(a[:i], b[:i]))\n        else:\n            result = max(result, 1 + longest_repeating_subsequence(a[:i+1], b[:i+1]))\n    return result\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 4, 5, 6, 7, 8]\n    b = [2, 3, 4, 5, 6, 7, 8, 1]\n    print(longest_repeating_subsequence(a, b))",
    "class Solution:\n    # @param s, a string\n    # @param t, a string\n    # @return a integer\n    def repeatedSubstringLen(self, s, t):\n        if not s or not t:\n            return 0\n\n        # find the length of the longest repeating subsequence\n        m = len(s)\n        n = len(t)\n        longest_len = 0\n        for i in xrange(m + 1):\n            for j in xrange(n + 1):\n                if i == 0 or j == 0:\n                    if s[i-1] == t[j-1]:\n                        if j - i > longest_len:\n                            longest_len = j - i\n                else:\n                    if s[i-1] == t[j-1] and (i - j) <= longest_len:\n                        longest_len = max(longest_len, i - j)\n        return longest_len",
    "#!/usr/bin/python\n\n# The longest repeated subsequence is defined as the subsequence with the longest common subsequence of its elements.\n# The longest common subsequence of two strings s and t is the longest common subsequence of s and t where the elements of s and t are also subsequences of the same string.\n# The longest common subsequence of a string and itself is 1.\n\n# Input: s = \"abcabc\", t = \"cbcbcb\"\n# Output: 2\n# Explanation: The two strings are equal and the common subsequence of the two strings is abc.\n# The longest common subsequence of the two strings is abcabc.\n# The common subsequence of \"abcabc\" and \"abcabc\" is abc.\n# The common subsequence of \"cbcbcb\" and \"abcabc\" is cbcbcb.\n# The common subsequence of \"abc\" and \"abcabc\" is abc.\n# The common subsequence of \"abcabc\" and \"abc\" is abc.\n# The common subsequence of \"abc\" and \"abc\" is 1.\n\n# Input: s = \"abcd\", t = \"aacd\"\n# Output: 2\n# Explanation: The two strings are equal and the common subsequence of the two strings is aacd.\n# The longest common subsequence of the two strings is aacd.\n# The common subsequence of \"abcd\" and \"aacd\" is aacd.\n# The common subsequence of \"aacd\" and \"abcd\" is aacd.\n# The common subsequence of \"a\" and \"aacd\" is a.\n# The common subsequence of \"aacd\" and \"a\" is aacd.\n# The common subsequence of \"a\" and \"a\" is 1.\n\n# Input: s = \"abcd\", t = \"aadc\"\n# Output: 1\n# Explanation: The two strings are equal and the common subsequence of the two strings is aadc.\n# The longest common subsequence of the two strings is aadc.\n# The common subsequence of \"abcd\" and \"aadc\" is aadc.\n# The common subsequence of \"aadc\" and \"ab",
    "from collections import Counter\n\ndef longest_repeating_subsequence(seq):\n    # return the longest repeating subsequence\n    # find the longest repeating subsequence\n    # find the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequence\n    # return the longest repeating subsequ",
    "class Solution:\n    \"\"\"\n    @param s: A string\n    @return: An integer\n    \"\"\"\n    def longestRepeating(self, s):\n        count = {}\n        for i in xrange(len(s)):\n            count[s[i]] = 1\n        maxLen = 0\n        for i in xrange(len(s)):\n            if s[i] in count:\n                if i - count[s[i]] > maxLen:\n                    maxLen = i - count[s[i]]\n        return maxLen + 1\n\n\nif __name__ == '__main__':\n    print Solution().longestRepeating('bbbabaa')\n    print Solution().longestRepeating('aaa')",
    "class Solution:\n    # @param s, a string\n    # @return an integer\n    def longestRepeatedSubstring(self, s):\n        if not s:\n            return 0\n        dic = {}\n        longest = 0\n        for i in range(len(s)):\n            if s[i] in dic:\n                dic[s[i]].append(i)\n            else:\n                dic[s[i]] = [i]\n        for i in range(len(s)):\n            if s[i] in dic:\n                for j in range(i+1, len(s)):\n                    if s[j] in dic:\n                        if len(dic[s[i]]) > len(dic[s[j]]):\n                            longest = max(longest, len(dic[s[i]]) - len(dic[s[j]]))\n        return longest\n\nprint Solution().longestRepeatedSubstring(\"aaabbc\")",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestRepeatedSubsequence(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        def find(root, s):\n            if not root:\n                return 0\n            if root.val == s[0]:\n                return max(find(root.left, s), find(root.right, s)) + 1\n            else:\n                return max(find(root.left, s), find(root.right, s))\n            \n        return max(find(root, s) for s in range(1, len(root.val)+1))",
    "# The problem is to find the longest repeating subsequences and the shortest repeating subsequences.\n# The idea is to store the repeating subsequences in a list and then do the following:\n# 1. If the repeating subsequences are the same length, we can only have one repeating subsequences.\n# 2. If the repeating subsequences are different length, we can only have two repeating subsequences.\n# 3. If there is only one repeating subsequences, it is the longest repeating subsequences.\n# 4. If there are more than one repeating subsequences, we can compare the subsequences and see if the one with the longer repeating subsequences is smaller.\n# If so, we can return the longer repeating subsequences.\n# If not, we can return the shortest repeating subsequences.\n\n# Note:\n# There is a problem with the repeating subsequences. We can have two repeating subsequences that have same string characters at same positions.\n# How to solve the problem?\n# 1. Store the repeating subsequences in a list.\n# 2. If the repeating subsequences are the same length, we can only have one repeating subsequences.\n# 3. If the repeating subsequences are different length, we can only have two repeating subsequences.\n# 4. If there is only one repeating subsequences, it is the longest repeating subsequences.\n# 5. If there are more than one repeating subsequences, we can compare the subsequences and see if the one with the longer repeating subsequences is smaller.\n# If so, we can return the longer repeating subsequences.\n# If not, we can return the shortest repeating subsequences.\n\n# A: O(N^2)\ndef longest_repeating_subsequence(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # Store the repeating subsequences in a list.\n    # Note: We can have two repeating subsequences that have same string characters at same positions.\n    # In this case, we can only have one repeating subsequences.\n    # We can have two repeating subsequences that have different string characters at same positions.\n    # In this case, we can only have two repeating subsequences.\n    # We can have only one repeating subsequences.\n    # In this case, we can only have one repeating subsequences.\n    # We can have",
    "# Recursive solution\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        nums.sort()\n\n        # find longest repeating subsequence\n        ret = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i]!= nums[i - 1]:\n                ret = max(ret, 1 + self.findLongestRepeatingSubsequence(nums[i:]))\n\n        return ret\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        nums.sort()\n\n        ret = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i]!= nums[i - 1]:\n                ret = max(ret, 1 + self.findLongestRepeatingSubsequence(nums[i:]))\n\n        return ret\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution3(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        nums.sort()\n\n        ret = 0\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[i - 1]:\n                ret = max(ret, 1 + self.findLongestRepeatingSubsequence(nums[i:]))\n\n        return ret\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution4(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int",
    "def count_longest_repeating_subsequences(s1, s2):\n    \"\"\"\n    :type s1: str\n    :type s2: str\n    :rtype: int\n    \"\"\"\n    if s1 == s2:\n        return 0\n    if len(s1) > len(s2):\n        s1, s2 = s2, s1\n    d = {}\n    for i, c in enumerate(s1):\n        if s2[i] in d:\n            d[s2[i]].append(c)\n        else:\n            d[s2[i]] = [c]\n    ans = 0\n    for k, v in d.items():\n        if len(v) > 1:\n            ans = max(ans, len(v))\n    return ans\n\nif __name__ == '__main__':\n    s1 = 'abcd'\n    s2 = 'abcdd'\n    print(count_longest_repeating_subsequences(s1, s2))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        if len(cipher) == 0:\n            return 0\n        m, n = len(cipher), len(cipher[0])\n\n        dp = [[0] * n for _ in xrange(m)]\n        for i in xrange(m):\n            for j in xrange(n):\n                if cipher[i][j] == cipher[0][j]:\n                    for k in xrange(1, m):\n                        if cipher[i][j] == cipher[k][j]:\n                            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    N = int(f.readline().strip())\n    for _ in xrange(N):\n        N = int(f.readline().strip())\n        cipher = f.readline().strip().split(\" \")\n        print solution.solve(cipher)",
    "import collections\n\nclass Solution:\n    def findLongestRepeating(self, s: str) -> int:\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # count how many times a character appears in the string\n        # note that the string must have the same length\n        count = collections.Counter(s)\n\n        # find the longest repeating subsequences\n        # note that the longest repeating subsequences are the ones with the same number of occurrences\n        # and the subsequences that are repeated at least twice are the ones with the longest repeating subsequences\n        # we assume that the string has the same length\n        longest_repeating_subsequence = collections.Counter()\n        for c in s:\n            # note that the count of the character is the number of times it appears\n            # we assume that the string has the same length\n            if c in count:\n                if count[c] > longest_repeating_subsequence[c]:\n                    # if the character is not repeated in the subsequences,\n                    # then add it to the longest repeating subsequence\n                    longest_repeating_subsequence[c] = count[c]\n            else:\n                # if the character is not repeated in the subsequences,\n                # then add it to the longest repeating subsequence\n                longest_repeating_subsequence[c] = 1\n\n        # return the longest repeating subsequences\n        return max(longest_repeating_subsequence.values())\n\n\nif __name__ == '__main__':\n    s = \"abbabbcabbdabbcabbcdabbcabbdabbbabbcabbccabbcccabbcabbcdabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbbabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbcabbcabbcabbbabbcabbcabbcabbdabbc",
    "# https://discuss.leetcode.com/topic/50381/java-dp-solution-with-explanation\n\n\"\"\"\n    dp[i] = max(dp[i-1]+1, dp[i-1]*(n-i+1))\n\"\"\"\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        return max(dp[n-1])",
    "# https://www.youtube.com/watch?v=bE8hQaRv4hc\n# https://www.youtube.com/watch?v=uRvbXwq1EQQ\n# https://www.youtube.com/watch?v=Z8tFx7vz4kc\n\nimport collections\n\n\ndef find_repeat_subsequence(s1, s2):\n    \"\"\"\n    :type s1: str\n    :type s2: str\n    :rtype: int\n    \"\"\"\n    # TODO: Implement this function\n    # Create a map for each character of s1 and s2\n    # A map is a dictionary that has a key and a value\n    # The value is a list of the keys that has the same value\n    # If two keys have the same value, then the map is a subset of the map\n    # If two keys have the same value, but the map has more than one key, then the map is a superset of the map\n    # If two keys have the same value, but the map only has one key, then the map is a subset of the map\n    # If two keys have the same value, but the map is empty, then the map is a subset of the map\n    # If two keys have the same value, but the map has no keys, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map is a subset of the map\n    # If two keys have the same value, and the map is empty, then the map",
    "from collections import Counter\nfrom collections import deque\n\ndef count_repeating_subsequence(string, n):\n    \"\"\"\n    :type string: str\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not string:\n        return 0\n    if n == 0:\n        return 1\n    if len(string) < n:\n        return 0\n\n    # use the longest subsequence to get the result\n    return max(count_repeating_subsequence(string[i:], n-1) for i in range(len(string)-n+1))\n\nif __name__ == '__main__':\n    assert count_repeating_subsequence('abcabcabc', 3) == 2\n    assert count_repeating_subsequence('abcabcabc', 4) == 3\n    assert count_repeating_subsequence('abcabcabc', 5) == 3",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  @date    2015-03-01\n#  @author  huangxin <3203317@qq.com>\n#  @brief   count the longest repeating subsequences of the given string\n#           such that the two subsequences don\u2019t have same string characters at same positions\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport re\n\ndef lrs(str):\n    \"\"\"\n    Write a function to count the longest repeating subsequences such that the two subsequences don\u2019t have same string characters at same positions.\n    \"\"\"\n    if not str:\n        return 0\n    m = str.split(' ')\n    m = list(set(m))\n    m.sort(key=len)\n    max_len = 1\n    last_len = 1\n    last_num = 0\n    for i in range(len(m)-1):\n        if m[i] == m[i+1]:\n            continue\n        if m[i] == m[i+1][:len(m[i+1])-1]:\n            last_len += 1\n            last_num += 1\n        else:\n            if last_len > max_len:\n                max_len = last_len\n                last_num = 1\n            last_len = 1\n            last_num = 0\n    if last_len > max_len:\n        max_len = last_len\n        last_num = 1\n    return max_len\n\nif __name__ == '__main__':\n    str = 'aaabbbccccccccccc'\n    print(lrs(str))",
    "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def numSubstrings(self, s):\n        ans = []\n        self.count(s, ans, 0)\n        return len(ans)\n\n    def count(self, s, ans, i):\n        if i == len(s):\n            ans.append(1)\n            return\n\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                self.count(s, ans, i + 1)\n                self.count(s, ans, i + 1)\n            else:\n                self.count(s, ans, i + 1)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.numSubstrings('aabbcc'))\n    print(s.numSubstrings('aabbccdd'))\n    print(s.numSubstrings('bbccdd'))",
    "# https://www.hackerrank.com/challenges/longest-repeating-subsequence\n# https://www.hackerrank.com/challenges/longest-repeating-subsequence/problem\n\ndef longest_repeating_subsequence(arr):\n    \"\"\"\n    Returns a list of repeating subsequences of arr.\n    \"\"\"\n    # The following is an implementation of the Longest Repeating Subsequence problem.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence of arr.\n    #\n    # The problem is to find the longest repeating subsequence",
    "class Solution(object):\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: int\n        \"\"\"\n        # return max(len(A), len(B))\n        max_len = max(len(A), len(B))\n        dic = {0: [0]}\n        for i in xrange(max_len):\n            dic[i] = [0]\n        for i in xrange(len(A)):\n            for j in xrange(len(B)):\n                if A[i] == B[j]:\n                    dic[i][j] = dic[i - 1][j - 1] + 1\n                else:\n                    dic[i][j] = max(dic[i][j - 1], dic[i - 1][j])\n        return dic[-1][-1]\n\nif __name__ == \"__main__\":\n    A = \"AAAAAA\"\n    B = \"ABABAA\"\n    print Solution().longestCommonSubsequence(A, B)",
    "from collections import Counter\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef longest_repeat(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: int\n    \"\"\"\n    # Count the number of times the two strings are the same\n    s_counts = Counter(s)\n    t_counts = Counter(t)\n    # If the two strings are the same, return 0\n    if s_counts == t_counts:\n        return 0\n    # Otherwise, return the max of the two\n    return max(s_counts - t_counts, t_counts - s_counts)\n\n\n# Your code should also have a function that returns the longest repeating subsequence of a given length.\n# Given a string, find the longest repeating subsequence of a given length.\n# The string can have one or more instances of the same character.\n# Input: s = \"abcabcbb\", t = \"abc\"\n# Output: 3\n# Explanation: The two strings have the same characters in the same positions.\n# The longest repeating subsequence is \"abcabcbb\".\n\n# Your code should also have a function that returns the longest repeating subsequence of a given length.\n# Given a string, find the longest repeating subsequence of a given length.\n# The string can have one or more instances of the same character.\n# Input: s = \"abcabcbb\", t = \"abc\"\n# Output: 3\n# Explanation: The two strings have the same characters in the same positions.\n# The longest repeating subsequence is \"abcabcbb\".\n\n# Your code should also have a function that returns the longest repeating subsequence of a given length.\n# Given a string, find the longest repeating subsequence of a given length.\n# The string can have one or more instances of the same character.\n# Input: s = \"abcabcbb\", t = \"abc\"\n# Output: 3\n# Explanation: The two strings have the same characters in the same positions.\n# The longest repeating subsequence is \"abcabcbb\".\n\n# Your code should also have a function that returns the longest repeating subsequence of a given length.\n# Given a string, find the",
    "def find_longest_subsequence(arr):\n    # write your code here\n    # write your code here\n    return max(find_longest_subsequence_helper(arr), find_longest_subsequence_helper(reverse(arr)))\n\n\ndef find_longest_subsequence_helper(arr):\n    if len(arr) == 0:\n        return 0\n\n    result = 0\n    i = 0\n    while i < len(arr):\n        j = i + 1\n        while j < len(arr):\n            if arr[j] == arr[i]:\n                result = max(result, j - i)\n                i = j\n            else:\n                break\n        j += 1\n        i = j\n    return result\n\n\ndef reverse(arr):\n    if len(arr) == 0:\n        return arr\n\n    return [arr[-1] if arr[-1] == arr[-2] else arr[-2] for arr in reversed(arr[:-1])]",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findLongestRepeating(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return len(nums)\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i - 1, -1, -1):\n                if nums[j] == nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)",
    "class Solution(object):\n    def findSubsequences(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return 0\n\n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n        return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    print Solution().findSubsequences(\"aabbc\", \"bbb\")",
    "class Solution(object):\n    def findLongestRepeating(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        return self.findLongestRepeatingHelper(s, t, 0, 0, 0)\n\n    def findLongestRepeatingHelper(self, s, t, i, j, k):\n        if i == len(s) and j == len(t):\n            return k + 1\n        if i == len(s):\n            return self.findLongestRepeatingHelper(t, t[j:], j + 1, 0, k + 1)\n        if j == len(t):\n            return self.findLongestRepeatingHelper(s, s[i:], i + 1, 0, k + 1)\n        if s[i] == t[j]:\n            return self.findLongestRepeatingHelper(s, t, i + 1, j + 1, k + 1)\n        return self.findLongestRepeatingHelper(s, t, i, j + 1, k)",
    "class Solution:\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_len = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    if j-i+1 > max_len:\n                        max_len = j-i+1\n        return max_len",
    "#!/usr/bin/env python\n\ndef lrs(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 0 or len(t) == 0:\n        return 0\n    if len(s) < len(t):\n        return lrs(t, s)\n    if len(s) == len(t):\n        if s == t:\n            return 1\n        else:\n            return 0\n    s_len = len(s)\n    t_len = len(t)\n    count = 0\n    # for i in range(s_len):\n    #     for j in range(t_len):\n    #         if s[i] == t[j]:\n    #             count += 1\n    #             if count > lrs(s[i+1:s_len], t[j+1:t_len]):\n    #                 lrs(s[i+1:s_len], t[j+1:t_len]) = count\n    #             if count > lrs(s[i+1:s_len], t[j]):\n    #                 lrs(s[i+1:s_len], t[j]) = count\n    #             if count > lrs(s[i:i+1], t[j+1:t_len]):\n    #                 lrs(s[i:i+1], t[j+1:t_len]) = count\n    #             if count > lrs(s[i:i+1], t[j]):\n    #                 lrs(s[i:i+1], t[j]) = count\n    for i in range(s_len):\n        for j in range(t_len):\n            if s[i] == t[j]:\n                count += 1\n                if count > lrs(s[i+1:s_len], t[j+1:t_len]):\n                    lrs(s[i+1:s_len], t[j+1:t_len]) = count\n                if count > lrs(s[i+1:s_len], t",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\nclass Solution(object):\n    def findLongestRepeating(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # use a dict to store the longest repeating subsequences\n        # the key is the index of the first character of the repeating subsequence\n        # the value is the length of the repeating subsequence\n        # the length of the longest repeating subsequences is the max of all the repeating subsequences\n        # so, the length of the longest repeating subsequences is the max of all the repeating subsequences\n        # note that if the repeating subsequences are the same, we can only return 1\n        # so, we need to store the longest repeating subsequences in the dict\n        # if there is more than one longest repeating subsequences, we will return the max of them\n        # the longest repeating subsequences in the dict are the keys of the dict\n        # if there is no repeating subsequence in the dict, we will return 0\n        # if there is only one repeating subsequence in the dict, we will return 1\n        # note that we can use a list to store the repeating subsequences\n        # we will keep the index of the first character of the repeating subsequence\n        # and the length of the repeating subsequences\n        # if there is a repeating subsequence in the list, we will return the length of the repeating subsequences\n        # if there is no repeating subsequence in the list, we will return 0\n        # if there is only one repeating subsequence in the list, we will return 1\n        # note that we can use a dict to store the repeating subsequences\n        # if there is a repeating subsequence in the dict, we will return the length of the repeating subsequences\n        # if there is no repeating subsequence in the dict, we will return 0\n        # if there is only one repeating subsequence in the dict, we will return 1\n        if not s:\n            return 0\n\n        # first we will store the repeating subsequences in a list\n        # we will keep the index of the first character of the repeating subsequence\n        # and the length of the repeating subsequences\n        # if there is a repeating subsequence in the list, we will return the",
    "# Write a function to count the longest repeating subsequences such that the two subsequences don\u2019t have same string characters at same positions.\n\n# Example 1:\n# Input:\n# s1 = \"b\"\n# s2 = \"aba\"\n# Output:\n# 2\n# Explanation:\n# There are two repeating subsequences.\n# s1 = \"b\"\n# s2 = \"aba\"\n# Both subsequences have the same length.\n# s1 = \"b\"\n# s2 = \"abab\"\n# Both subsequences have the same length.\n# s1 = \"ab\"\n# s2 = \"abab\"\n# One subsequence has length 2 and the other has length 3.\n# s1 = \"a\"\n# s2 = \"abab\"\n# No repeating subsequences.\n# Input:\n# s1 = \"b\"\n# s2 = \"a\"\n# Output:\n# 1\n# Explanation:\n# There is only one repeating subsequence.\n# s1 = \"b\"\n# s2 = \"a\"\n# No repeating subsequences.\n\n# Example 2:\n# Input:\n# s1 = \"abc\"\n# s2 = \"abc\"\n# Output:\n# 3\n# Explanation:\n# There are three repeating subsequences.\n# s1 = \"abc\"\n# s2 = \"abc\"\n# s1 and s2 have same length.\n# s1 = \"abc\"\n# s2 = \"abcabc\"\n# s1 and s2 have same length.\n# s1 = \"abbc\"\n# s2 = \"abcabc\"\n# s1 and s2 have same length.\n# s1 = \"aabc\"\n# s2 = \"abcabc\"\n# s1 and s2 have same length.\n# s1 = \"abcabcabcabcabc\"\n# s2 = \"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
    "import collections\n\ndef find_repeating_subsequence(arr):\n    \"\"\"\n    :type arr: List[str]\n    :rtype: List[str]\n    \"\"\"\n    # use map to get all the unique strings\n    unique_str = map(str, collections.Counter(arr).most_common())\n    # find the longest repeating subsequence\n    longest_sub = ''\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                if longest_sub == '' or len(arr[i:]) > len(longest_sub):\n                    longest_sub = arr[i:j+1]\n    return longest_sub\n\n\nif __name__ == '__main__':\n    arr = ['aa', 'bbb', 'cc', 'aa', 'aaa', 'bbbbbb']\n    print(find_repeating_subsequence(arr))",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s: return 0\n        dp = [[0] * (1 + len(s)) for _ in xrange(len(s) + 1)]\n        dp[0][0] = 1\n        for i in xrange(1, len(s) + 1):\n            for j in xrange(i):\n                if s[i - 1] == s[j]:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + 1\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().findLongestRepeatingSubsequence(\"aab\") == 2\n    assert Solution().findLongestRepeatingSubsequence(\"abc\") == 2\n    assert Solution().findLongestRepeatingSubsequence(\"d\") == 1\n    assert Solution().findLongestRepeatingSubsequence(\"bac\") == 2\n    assert Solution().findLongestRepeatingSubsequence(\"aab\") == 2",
    "#\n# @param {string} s\n# @return {integer}\n#\ndef longest_repeat(s):\n    # write your code here\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0 for x in range(n)] for x in range(n)]\n    dp[0][0] = 1\n    for i in range(1, n):\n        for j in range(0, i):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return max(dp[n-1])",
    "# https://oj.leetcode.com/problems/longest-repeating-character-subsequence/\n# DP\n# https://leetcode.com/problems/longest-repeating-character-subsequence/solution/\n# https://discuss.leetcode.com/topic/16963/java-dp-solution-using-string-and-array-and-binary-search\nclass Solution(object):\n    def countRepeatedSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if s[i - 1] == s[j]:\n                    dp[i] += dp[j]\n        return dp[-1]\n\n    def countRepeatedSubstring_2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if s[i - 1] == s[j]:\n                    dp[i] += dp[j]\n            dp[i] += dp[i - 1]\n        return dp[-1]\n\n\nif __name__ == '__main__':\n    print Solution().countRepeatedSubstring('bab')\n    print Solution().countRepeatedSubstring('aabbb')\n    print Solution().countRepeatedSubstring_2('aabbb')",
    "# https://www.hackerrank.com/challenges/longest-repeating-subsequence\n# https://www.hackerrank.com/challenges/longest-increasing subsequence/problem\n\n# Write a function that takes a string as input and returns the length of the longest repeating subsequence.\n# The repeating subsequence is defined as a subsequence that has the same characters at consecutive positions.\n# For example, if the input is \"abcabcabc\", the output should be 3.\n# The input string can be empty.\n\ndef find_longest_repeat(string):\n    # write your code here\n    length = 0\n    max_length = 0\n    if not string:\n        return 0\n    for i in range(len(string)):\n        count = 1\n        for j in range(i+1, len(string)):\n            if string[i] == string[j]:\n                count += 1\n        if count > max_length:\n            max_length = count\n            length = i+1\n    return max_length\n\nif __name__ == '__main__':\n    print(find_longest_repeat('abcabcabc'))",
    "class Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        dp = [[0 for j in xrange(len(s)+1)] for i in xrange(len(t)+1)]\n        for i in xrange(len(s)+1):\n            for j in xrange(len(t)+1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                max_len = max(max_len, dp[i][j])\n        return max_len\n\n    def test(self):\n        self.assertEqual(2, self.longestCommonSubsequence('a', 'b'))\n        self.assertEqual(3, self.longestCommonSubsequence('abc', 'cba'))\n        self.assertEqual(3, self.longestCommonSubsequence('aa', 'aa'))\n        self.assertEqual(4, self.longestCommonSubsequence('abcde', 'cdef'))\n\ns = Solution()\ns.test()",
    "# https://www.hackerrank.com/challenges/longest-repeating-subsequence/problem\n\ndef lrs(a, b):\n    max_len = 0\n    max_len_a = 0\n    max_len_b = 0\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            if max_len_a < len(a[:i+1]):\n                max_len_a = len(a[:i+1])\n            if max_len_b < len(b[:i+1]):\n                max_len_b = len(b[:i+1])\n            max_len = max(max_len, max_len_a, max_len_b)\n    return max_len\n\ndef lrs2(a, b):\n    max_len = 0\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            max_len = max(max_len, i+1)\n    return max_len\n\na = input().split()\nb = input().split()\nprint(lrs(a, b))",
    "# https://discuss.leetcode.com/topic/24061/java-solution-with-explanation\n# https://www.youtube.com/watch?v=s0n3d0vzgYc\n\nclass Solution(object):\n    def findLongestRepeating(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        # DFS\n        # dp[i] = max(dp[i-1] + 1, dp[i-1] + strs[i][i])\n        # dp[0] = 1\n        # dp[0] = 1\n        dp = [1] * len(strs)\n        for i in range(1, len(strs)):\n            dp[i] = max(dp[i-1] + 1, dp[i-1] + strs[i][i])\n        return dp[-1]\n\n    # BFS\n    # def findLongestRepeating(self, strs):\n    #     \"\"\"\n    #     :type strs: List[str]\n    #     :rtype: int\n    #     \"\"\"\n    #     dp = [0] * len(strs)\n    #     for i in range(1, len(strs)):\n    #         for j in range(i):\n    #             if strs[i][j] == strs[j][i]:\n    #                 dp[i] = max(dp[i], dp[j] + 1)\n    #     return dp[-1]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    strs = [\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
    "# Your function will take as input two strings.\n\n# Input Format\n\n# The first line contains an integer T, denoting the number of test cases.\n\n# Each test case consists of two lines.\n\n# The first line contains an integer N, denoting the length of the first string.\n\n# The second line contains N space-separated integers, denoting the lengths of the second string.\n\n# Output Format\n\n# For each test case, print the length of the longest repeating subsequence in the second string.\n\n# The length of the longest repeating subsequence in the second string should be at least 1.\n\n# Constraints\n\n# 1 <= T <= 100\n\n# 1 <= N <= 10000\n\n# 1 <= l <= 10000\n\n# 1 <= r <= 10000\n\n# The first string and the second string will not have the same characters at the same positions.\n\n# Example\n\n# Input\n\n# 5\n\n# 1 2 3 1 2 3\n\n# 4\n\n# 2 1 2 1 1 2\n\n# Output\n\n# 4\n\n# 2\n\n# 2\n\n# 1\n\n# 3\n\n# 2\n\n# 1\n\n# 2\n\n# 2\n\n# 2\n\n# 2\n\n# 3\n\n# 3\n\n# 2\n\n# 1\n\n# 3\n\n# 3\n\n# 2\n\n# 3\n\n# 2\n\n# 2\n\n# 2\n\n# 3\n\n# 3\n\n# 3\n\n# 2\n\n# 2\n\n# 3\n\n# 3\n\n# 2\n\n# 3\n\n# 3\n\n# 2\n\n# 2\n\n# 2\n\n# 3\n\n# 1\n\n# 2\n\n# 1\n\n# 1\n\n# 2\n\n# 2\n\n# 2\n\n# 2\n\n# 1\n\n# 2\n\n# 1\n\n# 2\n\n# 2\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 2\n\n# 1\n\n# 2\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1\n\n# 1",
    "class Solution:\n    # @param s, a string\n    # @return an integer\n    def countSubseq(self, s):\n        # write your code here\n        dp = [[0] * len(s) for _ in xrange(len(s))]\n        dp[0][0] = 1\n        for i in xrange(1, len(s)):\n            for j in xrange(0, i):\n                if s[j] == s[i]:\n                    dp[i][i] = dp[j][i-1] + dp[j][i-1]\n                else:\n                    dp[i][i] = max(dp[j][i-1], dp[i-1][i])\n        return dp[-1][-1]\n\nif __name__ == \"__main__\":\n    s = \"bbbcddd\"\n    sol = Solution()\n    print sol.countSubseq(s)",
    "def find_longest_repeating_subsequence(seq):\n    \"\"\"\n    :type seq: List[str]\n    :rtype: int\n    \"\"\"\n    def get_rep(s):\n        return [s[i:i+1] for i in range(len(s)-1)]\n\n    def dfs(seq, max_len, rep):\n        if len(seq) == 0:\n            return max_len\n        if len(seq) == 1:\n            return max(len(seq[0]), max_len)\n\n        for i in range(len(seq)-1):\n            if seq[i] == seq[i+1]:\n                rep.append(seq[i])\n                max_len = max(max_len, 1+max(dfs(seq[:i], max_len, rep)))\n                rep.pop()\n            else:\n                max_len = max(max_len, 1+max(dfs(seq[i+1:], max_len, rep)))\n        return max_len\n\n    max_len = 0\n    rep = []\n    max_len = dfs(seq, 0, rep)\n    return max_len\n\nif __name__ == '__main__':\n    assert find_longest_repeating_subsequence(['abcd','abcc','d','de','a']) == 4",
    "# https://leetcode.com/problems/longest-repeating-subsequence/\n\nclass Solution(object):\n    def findLongestRepeating(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        dic = {}\n        for i in s:\n            if i in dic:\n                dic[i] += 1\n            else:\n                dic[i] = 1\n        l = 0\n        for i in t:\n            if i in dic:\n                if dic[i] > l:\n                    l = dic[i]\n            else:\n                l = 0\n            dic[i] = 0\n        return l\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findLongestRepeating('abcd', 'abcdd')\n    print s.findLongestRepeating('abc', 'abc')\n    print s.findLongestRepeating('a', 'aa')\n    print s.findLongestRepeating('abc', 'aa')\n    print s.findLongestRepeating('aa', 'aa')\n    print s.findLongestRepeating('', '')",
    "# Definition for a subsequence.\nclass Subsequence:\n    def __init__(self, s):\n        self.s = s\n\n    def __repr__(self):\n        return \"Subsequence(\" + str(self.s) + \")\"\n\n\nclass Solution(object):\n    def longestRepeatingSubsequence(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        ret = 0\n        length = len(S)\n        for i in range(length):\n            for j in range(i + 1, length):\n                if S[i:j] == S[j:i]:\n                    ret = max(ret, j - i + 1)\n        return ret",
    "# https://oj.leetcode.com/problems/longest-repeating-subsequence-ii/\n\nclass Solution(object):\n    def lengthOfLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [1] * n\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n\nif __name__ == \"__main__\":\n    print Solution().lengthOfLongestRepeatingSubsequence([1,2,3,2,3,2,1])",
    "# https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n# https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n# https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n# https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n# https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # DP: time complexity is O(n), space complexity is O(n)\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n        # https://leetcode.com/problems/longest-repeating-subsequence/discuss/86782/Python-Coding-Easy-Easy-with-Python-Solution-with-explanation\n        # https://le",
    "import sys\n\nclass Solution:\n    def findLongestRepeating(self, s: str) -> int:\n        count = {}\n        longest = 0\n        for i in range(len(s)):\n            if s[i] not in count:\n                count[s[i]] = 1\n            else:\n                count[s[i]] += 1\n            if count[s[i]] > longest:\n                longest = count[s[i]]\n        return longest\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findLongestRepeating(\"aabbb\"))\n    print(sol.findLongestRepeating(\"aaa\"))\n    print(sol.findLongestRepeating(\"abb\"))\n    print(sol.findLongestRepeating(\"b\"))\n    print(sol.findLongestRepeating(\"aa\"))\n    print(sol.findLongestRepeating(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "# https://leetcode.com/problems/longest-repeating-subsequence/description/\n\nclass Solution:\n    # @param {string} s\n    # @return {integer}\n    def lengthOfLongestSubstring(self, s):\n        if not s:\n            return 0\n\n        longest = 0\n        longest_len = 0\n        longest_dict = {}\n        longest_substring = ''\n\n        for i, c in enumerate(s):\n            if c in longest_dict:\n                if longest_len < i - longest_dict[c]:\n                    longest_len = i - longest_dict[c]\n                    longest = longest_len\n                if longest_len == i - longest_dict[c]:\n                    longest_substring = longest_dict[c]\n                longest_dict[c] = i\n            else:\n                if i - longest_dict[c] > longest_len:\n                    longest_len = i - longest_dict[c]\n                    longest = longest_len\n                longest_dict[c] = i\n\n        return longest\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    s = \"bbbbb\"\n    s = \"a\"\n    print(Solution().lengthOfLongestSubstring(s))",
    "def find_longest_repeating_subsequence(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: int\n    \"\"\"\n    if len(s)!= len(t):\n        return 0\n\n    d = collections.defaultdict(list)\n    for i in range(len(s)):\n        if s[i] == t[i]:\n            d[s[i]].append(i)\n\n    max_len = 0\n    max_idx = 0\n    for k, v in d.items():\n        if len(v) > max_len:\n            max_len = len(v)\n            max_idx = k\n    return max_len\n\n# Your code here.",
    "class Solution(object):\n    def findLongestRepeatingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = max(dp[:i] + [1] + dp[i])\n        max_dp = [0] * n\n        for i in range(n):\n            max_dp[i] = dp[i]\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                max_dp[i + 1] = max(max_dp[i + 1], dp[i] + dp[i + 1])\n        return max_dp[-1]\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 1, 2, 2, 3, 3, 3, 4]\n    print(Solution().findLongestRepeatingSubsequence(nums))",
    "# https://oj.leetcode.com/problems/count-repeated-subsequences/\n# Given a string s, find the longest repeated subsequence of s such that the two subsequences don\u2019t have same string characters at same positions.\n\n# Example 1:\n# Input: s = \"bbbbb\"\n# Output: \"bbbb\"\n# Explanation: There are two subsequences: \"bbbb\" and \"bbbbb\". They have different characters, but they have the same length.\n# Example 2:\n# Input: s = \"aabbbc\"\n# Output: \"bbbb\"\n# Explanation: There are two subsequences: \"bbbb\" and \"bbbbb\". They have different characters, but they have the same length.\n# Example 3:\n# Input: s = \"abcabc\"\n# Output: \"abc\"\n# Explanation: There is only one subsequence \"abc\". It has the same characters, but it has different length.\n# Note:\n# The length of s will be in range [1, 10000].\n# The length of the given string will be in range [1, 10000].\n# The given string is guaranteed to be a valid string.\n# The two subsequences don\u2019t have same string characters at same positions.\n# The string s contains only lowercase English letters.\n\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def longestRepeatedSubstring(self, s):\n        if len(s) < 2:\n            return 0\n\n        # count\n        count = {}\n        for i in range(len(s)):\n            if s[i] in count:\n                count[s[i]] += 1\n            else:\n                count[s[i]] = 1\n\n        # longest\n        max_len = 1\n        for i in range(len(s)):\n            if s[i] in count:\n                if count[s[i]] > max_len:\n                    max_len = count[s[i]]\n        return max_len\n\nif __name__ == '__main__':\n    print(Solution().longestRepeatedSubstring('bbbbb'))\n    print(Solution().longestRepeatedSubstring('aabb",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param A, a list of integers\n    # @return an integer\n    def longestRepeatingSubsequence(self, A):\n        if len(A) == 0:\n            return 0\n        if len(A) == 1:\n            return 1\n        maxlen = 1\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                if A[i] == A[j]:\n                    if A[i] > maxlen:\n                        maxlen = A[i]\n                    if A[j] > maxlen:\n                        maxlen = A[j]\n        return maxlen\n\nif __name__ == '__main__':\n    print Solution().longestRepeatingSubsequence([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5])",
    "class Solution(object):\n    def numSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.dfs(s, 0, 0)\n\n    def dfs(self, s, i, j):\n        if i == len(s):\n            return 1\n        if j == len(s):\n            return 2\n        if s[i]!= s[j]:\n            return self.dfs(s, i+1, j)\n        else:\n            return max(self.dfs(s, i+1, j+1), self.dfs(s, i+1, j))\n\n\nif __name__ == '__main__':\n    print Solution().numSubstrings(\"aabb\")",
    "class Solution(object):\n    def repeatedSubstring(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if len(t) == 0:\n            return 0\n        if len(s) < len(t):\n            return 0\n        if len(s) == len(t):\n            if s == t:\n                return 1\n            return 0\n        dp = [[0] * len(t) for i in range(len(s))]\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    dp[i][j] = 1 + dp[i + 1][j]\n        return max(dp[0])\n\n\nif __name__ == \"__main__\":\n    assert Solution().repeatedSubstring(\"abbbc\", \"bca\") == 3\n    assert Solution().repeatedSubstring(\"abcabc\", \"abc\") == 2\n    assert Solution().repeatedSubstring(\"ababbac\", \"bac\") == 2",
    "import collections\n\ndef longest_repeating_subsequence(arr):\n    if not arr:\n        return 0\n\n    result = collections.defaultdict(list)\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i] == arr[j]:\n                result[j].append(i)\n\n    max_len = 0\n    for i in range(len(arr)):\n        if max_len < len(result[i]):\n            max_len = len(result[i])\n\n    return max_len\n\nprint(longest_repeating_subsequence(['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a']))",
    "def find_longest_subsequence(s1, s2):\n\t# write your code here\n\tif not s1 or not s2:\n\t\treturn 0\n\tif len(s1) < len(s2):\n\t\treturn find_longest_subsequence(s2, s1)\n\tif len(s2) < len(s1):\n\t\treturn find_longest_subsequence(s1, s2)\n\t# if len(s1) == len(s2)\n\t# return 0\n\t# if len(s1) > len(s2):\n\t# \treturn len(s1)\n\t# else:\n\t# \treturn len(s2)\n\t# if len(s1) == len(s2):\n\t# \treturn 0\n\t# if s1[0] == s2[0]:\n\t# \treturn 1 + find_longest_subsequence(s1[1:], s2[1:])\n\t# else:\n\t# \treturn 1 + find_longest_subsequence(s1[1:], s2)\n\t# return 0\n\treturn 1 + find_longest_subsequence(s1[1:], s2)\n\nprint find_longest_subsequence('abcabc', 'cbcabc')",
    "# https://leetcode.com/problems/longest-repeating-subsequence/\n# Given a string, find the length of the longest repeating subsequence such that the two subsequences don\u2019t have same string characters at same positions.\n# Example 1:\n# Input: \"abcabcbb\"\n# Output: 3\n# Explanation: The longest repeating subsequence is \"abcabcbb\", and its length is 3.\n# Example 2:\n# Input: \"aaabbb\"\n# Output: 2\n# Explanation: The longest repeating subsequence is \"aaabbb\", and its length is 2.\n# Note:\n# The length of the given string will not exceed 10,000.\n# The string contains only lowercase English letters.\n# The string and its subsequences won\u2019t have leading or trailing spaces.\n\n# 2017.02.11\nclass Solution:\n    def findLongestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 1\n        dp = [[0] * len(s) for _ in range(len(s))]\n        dp[0][0] = 1\n        for i in range(1, len(s)):\n            for j in range(1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print(Solution().findLongestRepeatingSubsequence(\"aaabbb\"))\n    print(Solution().findLongestRepeatingSubsequence(\"aabbb\"))",
    "class Solution:\n    # @return an integer\n    def maxSubseqLen(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        subseqs = self.findSubseqs(s, t)\n        return max([len(s) for s in subseqs])\n\n    def findSubseqs(self, s, t):\n        if len(s) == 0 or len(t) == 0:\n            return []\n        subseqs = [[]]\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    subseqs[0].append(s[i:i + 1])\n                    subseqs.append([])\n        return subseqs",
    "class Solution(object):\n    def longestRepeatedSubsequence(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        dp = [[0] * (len(A[0])) for _ in range(len(A))]\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if A[i][j] == A[i][j - 1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[-1][-1]\n\nif __name__ == \"__main__\":\n    print(Solution().longestRepeatedSubsequence([\"abcabc\", \"dcbdbc\", \"bdb\"]))",
    "# Your code here.\n\ndef long_repeat_subs(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    return _long_repeat_subs(s, 0, len(s))\n\ndef _long_repeat_subs(s, start, end):\n    if start == end:\n        return 1\n    if end - start == 1:\n        return _long_repeat_subs(s, start + 1, end)\n    if start == end - 1:\n        return _long_repeat_subs(s, start, end - 1)\n    if s[start] == s[end - 1]:\n        return _long_repeat_subs(s, start + 1, end - 1)\n    return max(_long_repeat_subs(s, start, end - 1), _long_repeat_subs(s, start + 1, end))\n\ndef long_repeat_subs_2(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    return max(long_repeat_subs_2(s[1:]), long_repeat_subs_2(s[:-1]))\n\ndef long_repeat_subs_3(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    return max(long_repeat_subs_3(s[1:]), long_repeat_subs_3(s[:-1]))\n\ndef long_repeat_subs_4(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    return max(long_repeat_subs_4(s[1:]), long_repeat_subs_4(s[:-1]))\n\ndef long_repeat_subs_5(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    return max(long",
    "class Solution(object):\n    def longestRepeatedSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # write your code here\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [1] * n\n        dp[0] = 1\n        for i in range(1, n):\n            max_i = 0\n            for j in range(i):\n                if nums[j] == nums[i]:\n                    max_i = max(max_i, dp[j] + 1)\n            dp[i] = max(dp[i], max_i)\n        return dp[-1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.longestRepeatedSubsequence([1,1,2,2,3,3]))",
    "__author__ = 'Danyang'\n\nclass Solution(object):\n    def count_repeating_subsequences(self, s, t):\n        \"\"\"\n        Brute force\n        :param s: str\n        :param t: str\n        :return: int\n        \"\"\"\n        if not s or not t:\n            return 0\n\n        l_s = len(s)\n        l_t = len(t)\n\n        # check if s[i] == t[j]\n        # if yes, check if s[i] == t[j-1]\n        # if yes, check if s[i] == t[j+1]\n        # if yes, then s[i] == t[j]\n\n        # for each s[i]\n        for i in range(l_s):\n            # for each t[j]\n            for j in range(l_t):\n                if s[i] == t[j]:\n                    # if s[i] == t[j-1]\n                    if j > 0 and s[i] == t[j-1]:\n                        # if s[i] == t[j+1]\n                        if j+1 < l_t and s[i] == t[j+1]:\n                            # count the length of repeating subsequences\n                            return max(self.count_repeating_subsequences(s[i+1:], t[j+1:]),\n                                       self.count_repeating_subsequences(s[i+1:], t[:j]),\n                                       self.count_repeating_subsequences(s[:i], t[j+1:]),\n                                       self.count_repeating_subsequences(s[:i], t[:j]))\n                        else:\n                            # if j+1 == l_t\n                            return self.count_repeating_subsequences(s[:i], t[:j+1])\n                    else:\n                        # if j+1 == l_t\n                        return self.count_repeating_subsequences(s[:i], t[:j+1])\n\n                # if j+1 == l_t\n                if j+1 ==",
    "class Solution(object):\n    def findSubsequences(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: List[str]\n        \"\"\"\n        # s, t are sorted\n        # find the longest repeating subsequences\n        # sort by length\n        # repeat the longest subsequence\n        # return the result\n\n        if not s or not t:\n            return []\n\n        s, t = sorted((s, t)), sorted((t, s))\n\n        # find the longest repeating subsequence\n        # for each character in s, t, find the longest repeating subsequence\n        # if there is a repeating subsequence, add it to the result\n        result = []\n        length = 1\n        for c in s:\n            if c == t[0]:\n                length += 1\n            else:\n                result.append(s[:length])\n                length = 1\n        result.append(s[:length])\n\n        return result",
    "# https://leetcode.com/problems/longest-repeating-subsequence-ii/solution/\n\n# @param s, a string\n# @return an integer\n\nclass Solution(object):\n    def longestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/longest-repeating-subsequence-ii/discuss/160796/Python-solution-with-an-explaination\n        # 1. find the longest repeating subsequences in the whole string.\n        # 2. find the longest repeating subsequences in the given substrings.\n        # 3. find the longest repeating subsequences in the given substrings but without same characters.\n        # 4. find the longest repeating subsequences in the given substrings but without same characters.\n        # 5. find the longest repeating subsequences in the given substrings but without same characters.\n        # 6. find the longest repeating subsequences in the given substrings but without same characters.\n        # 7. find the longest repeating subsequences in the given substrings but without same characters.\n        # 8. find the longest repeating subsequences in the given substrings but without same characters.\n        # 9. find the longest repeating subsequences in the given substrings but without same characters.\n        # 10. find the longest repeating subsequences in the given substrings but without same characters.\n        # 11. find the longest repeating subsequences in the given substrings but without same characters.\n        # 12. find the longest repeating subsequences in the given substrings but without same characters.\n        # 13. find the longest repeating subsequences in the given substrings but without same characters.\n        # 14. find the longest repeating subsequences in the given substrings but without same characters.\n        # 15. find the longest repeating subsequences in the given substrings but without same characters.\n        # 16. find the longest repeating subsequences in the given substrings but without same characters.\n        # 17. find the longest repeating subsequences in the given substrings but without same characters.\n        # 18. find the longest repeating subsequences in the given substrings but without same characters.\n        # 19. find the longest repeating subsequences in the given substrings but",
    "import string\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findLongestRepeating(self, s: str) -> int:\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # write your code here\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)\n        dp = defaultdict(int)\n        for i, c in enumerate(s):\n            for j in range(i, len(s)):\n                if s[j] == c:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1)\n        return max(dp.values())\n\n\nif __name__ == '__main__':\n    assert Solution().findLongestRepeating('abcabc') == 3\n    assert Solution().findLongestRepeating('abc') == 1\n    assert Solution().findLongestRepeating('abcabc') == 3\n    assert Solution().findLongestRepeating('abcabcabc') == 4\n    assert Solution().findLongestRepeating('abcabcabcabcabc') == 7\n    assert Solution().findLongestRepeating('aa') == 1\n    assert Solution().findLongestRepeating('abcabcabcabcabcabc') == 7",
    "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        res = []\n        def dfs(s, i):\n            if len(res) == len(s):\n                res.append([])\n            if len(s) == 0:\n                res[-1].append(s)\n                return\n            for j in range(i, len(s)):\n                if s[j]!= s[i]:\n                    break\n                dfs(s, j+1)\n                res[-1].append(s[i:j+1])\n        dfs(s, 0)\n        return res\n\nif __name__ == '__main__':\n    print Solution().findSubsequences('aaabbbccc')",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def countSubsequences(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, pre):\n            if not node:\n                return 0\n            if pre:\n                pre.append(node.val)\n            else:\n                pre.append(node.val)\n            return 1 + dfs(node.left, pre) + dfs(node.right, pre)\n        pre = []\n        return dfs(root, pre)",
    "# https://leetcode.com/problems/longest-repeating-character-subsequence/\n\n# Time:  O(n)\n# Space: O(n)\n\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def longestRepeatingSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        d = {}\n        for i in range(len(s)):\n            if s[i] not in d:\n                d[s[i]] = 1\n            else:\n                d[s[i]] += 1\n        m = 0\n        for i in range(len(s)):\n            if d[s[i]] == 1:\n                m = max(m, 1)\n            else:\n                m = max(m, m)\n        return m + 1",
    "# https://leetcode.com/problems/find-all-anagrams-in-a-string/\n\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        if len(p) == 0:\n            return [s]\n\n        s_count = {}\n        for c in s:\n            if c in s_count:\n                s_count[c] += 1\n            else:\n                s_count[c] = 1\n\n        p_count = {}\n        for c in p:\n            if c in p_count:\n                p_count[c] += 1\n            else:\n                p_count[c] = 1\n\n        ans = []\n        for c in p:\n            if c in s_count and c in p_count:\n                if s_count[c] == p_count[c]:\n                    ans.append(s[s_count[c] - 1:])\n                else:\n                    ans.append(s)\n        return ans",
    "#\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findLongestRepeatingSubsequence(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        res = 1\n        if not root.left and not root.right:\n            return res\n        if root.left:\n            res = max(res, self.findLongestRepeatingSubsequence(root.left))\n        if root.right:\n            res = max(res, self.findLongestRepeatingSubsequence(root.right))\n        return max(res, self.findLongestRepeatingSubsequence(root.left, root.right))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}