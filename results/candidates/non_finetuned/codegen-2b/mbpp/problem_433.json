{
  "problem": {
    "task_id": "MBPP/444",
    "prompt": "Write a function to trim each tuple by k in the given tuple list.",
    "canonical_solution": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ",
    "test_list": [
      "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'",
      "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'",
      "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"
    ],
    "challenge_test_list": [],
    "problem_id": 433
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def removeKdigits(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not nums:\n            return None\n        \n        # write your code here\n        res = self.solve(nums, k, 0)\n        if not res:\n            return None\n        \n        return res.next\n        \n    def solve(self, nums, k, i):\n        if not nums or i == k:\n            return None\n        \n        if not nums[i]:\n            res = self.solve(nums, k, i+1)\n            if not res:\n                return None\n            \n            res.next = self.solve(nums[i+1:], k, 0)\n            return res\n        \n        res = self.solve(nums[i+1:], k, i+1)\n        if not res:\n            return None\n            \n        return self.solve(nums[i+1:], k, 0)\n        \n\n# test\nsol = Solution()\nnums = [0, 1, 0, 2, 3, 4, 0, 5, 6, 0, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9]\nnums = [0",
    "class Solution(object):\n    def trim(self, A, k):\n        \"\"\"\n        :type A: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        for i in range(len(A)):\n            if len(A[i]) > k:\n                res.append(A[i][:k])\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().trim([[1], [2], [3], [4], [5], [6]], 3) == [[1], [2], [3], [4], [5], [6]]",
    "def trim(t):\n    for i in range(len(t)):\n        t[i] = t[i][:k]\n    return t\n\ndef main():\n    t = [[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\"]]\n    print(trim(t))\n\nif __name__ == \"__main__\":\n    main()",
    "def trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    k_list = [0] * k\n    for i in range(len(tuple_list)):\n        for j in range(k):\n            if tuple_list[i][j]!= 0:\n                k_list[j] += 1\n\n    result_list = []\n    for i in range(len(tuple_list)):\n        if k_list[i] == 0:\n            result_list.append(tuple_list[i])\n        else:\n            result_list.append(tuple_list[i][:k])\n\n    return result_list\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert trim([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], 1) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)]\n    assert trim([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)]\n    assert trim([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)], 3) == [(0, 1), (1, 1), (2, 1), (3,",
    "def trim(l, k):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(l) <= k:\n        return l\n    return [l[i] for i in range(k)]\n\n# Your Trim function will be called like this:\n# trim(l,k)",
    "def trim_tuple(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuple_list if len(t) >= k]\n\nt = (1, 2, 3, 4, 5, 6)\nt = (1, 2, 3, 4, 5, 6, 7)\nt = (1, 2, 3, 4, 5, 6, 7, 8)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\nt = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16",
    "def trim_tuple(tuples, k):\n    \"\"\"\n    :type tuples: List[tuple]\n    :type k: int\n    :rtype: List[tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(t[:k])\n    return result\n\nclass Solution:\n    # @param {List[Tuple]} tuples\n    # @param {number} k\n    # @return {List[Tuple]}\n    def trim(self, tuples, k):\n        result = []\n        for t in tuples:\n            if len(t) > k:\n                result.append(t[:k])\n        return result",
    "class Solution:\n    # @param {ListNode[]} listNodes\n    # @param {integer} k\n    # @return {void} Do not return anything, modify the tuple list in-place instead.\n    def deleteKFromSortedList(self, listNodes, k):\n        # write your code here\n        \n        if not listNodes:\n            return\n\n        left = listNodes[0]\n        right = listNodes[-1]\n        while left and right and left.val == right.val:\n            left = left.next\n            right = right.next\n        \n        if not left:\n            return\n        \n        if k == 1:\n            left.next = right.next\n            return\n        \n        while right and right.val == left.val:\n            right = right.next\n            if not right:\n                return\n        \n        left.next = right.next\n        right.next = left\n        \n        self.deleteKFromSortedList(listNodes[:k], k-1)\n        self.deleteKFromSortedList(listNodes[k:], len(listNodes)-k)\n        \n\nif __name__ == \"__main__\":\n    solution = Solution()\n    a = [1,2,3]\n    solution.deleteKFromSortedList(a, 2)\n    print a",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if k == 0:\n            return nums\n        if k >= n:\n            return []\n        k -= 1\n        return self.trimRec(nums, k, 0, n-1)\n\n    def trimRec(self, nums, k, i, j):\n        if i > j:\n            return []\n        mid = (i+j)/2\n        if nums[mid].x <= k:\n            return self.trimRec(nums, k, i, mid-1)\n        else:\n            return self.trimRec(nums, k, mid+1, j)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.trim([(1,2,3),(4,5,6)], 2)",
    "def trim_tuple(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [t for t in tuples if len(t) >= k]",
    "def trim(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [x[:k] for x in tuples]",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(L) == 0:\n            return L\n        if len(L) == 1:\n            return L\n        k_i = 0\n        for i in range(len(L)):\n            if k_i > k:\n                L[i] = L[i][:k]\n                k_i = k\n            elif k_i < k:\n                L[i] = L[i][k:]\n                k_i += 1\n        return L",
    "class Solution:\n    # @param {ListNode[]} nums\n    # @param {integer} k\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def partition(self, nums, k):\n        \"\"\"\n        :type nums: ListNode[]\n        :type k: int\n        \"\"\"\n        if not nums:\n            return\n        \n        if k == 1:\n            return\n        \n        pivot = nums[0]\n        \n        i = 0\n        j = len(nums) - 1\n        \n        while i < j:\n            while i < j and nums[i].val <= pivot.val:\n                i += 1\n            \n            while i < j and nums[j].val >= pivot.val:\n                j -= 1\n            \n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n            \n            if i == j:\n                i += 1\n                j -= 1\n                \n            if k == 1:\n                return\n        \n        while i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n        \n        return",
    "# https://leetcode.com/problems/trim-a-list-of-strings/discuss/125518/Python-DP-Solution\n\nclass Solution(object):\n    def trimList(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        slow = dummy\n        fast = dummy\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if k > 0:\n                slow = slow.next\n            if not slow or not slow.next:\n                break\n            k -= 1\n        if not k:\n            return dummy.next\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n            if not slow or not slow.next:\n                break\n            k -= 1\n        if not k:\n            return dummy.next\n        trimList(slow.next, k)\n        return dummy.next",
    "from typing import List\n\n\nclass Solution:\n    def trim(self, tuple_list: List[List[int]], k: int) -> List[List[int]]:\n        if not tuple_list:\n            return tuple_list\n\n        trim_list = []\n        for t in tuple_list:\n            new_t = []\n            for i in range(len(t)):\n                if t[i] <= k:\n                    new_t.append(t[i])\n            trim_list.append(new_t)\n\n        return trim_list",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def trim(self, head: ListNode, k: int) -> ListNode:\n        if head is None:\n            return None\n        elif head.next is None:\n            return head\n        elif head.next is None:\n            return head\n        elif head.val == head.next.val:\n            head.next = head.next.next\n            return head\n        else:\n            new_head = head\n            while new_head.next is not None:\n                if new_head.next.val == new_head.val:\n                    new_head.next = new_head.next.next\n                    continue\n                else:\n                    new_head = new_head.next\n            return new_head\n\nif __name__ == '__main__':\n    l1 = ListNode(1)\n    l1.next = ListNode(2)\n    l1.next.next = ListNode(3)\n    l2 = ListNode(4)\n    l2.next = ListNode(5)\n    l2.next.next = ListNode(6)\n    l3 = ListNode(7)\n    l3.next = ListNode(8)\n    l3.next.next = ListNode(9)\n    l4 = ListNode(10)\n    l4.next = ListNode(11)\n    l4.next.next = ListNode(12)\n    l5 = ListNode(13)\n    l5.next = ListNode(14)\n    l5.next.next = ListNode(15)\n    l6 = ListNode(16)\n    l6.next = ListNode(17)\n    l6.next.next = ListNode(18)\n    l7 = ListNode(19)\n    l7.next = ListNode(20)\n    l7.next.next = ListNode(21)\n    l8 = ListNode(22)\n    l8.next = ListNode(23)\n    l8.next.next = ListNode(24)",
    "class Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k == 0:\n            return []\n        if k < 0:\n            return nums\n        if not nums:\n            return []\n        if len(nums) == 1:\n            return [nums[0]]\n        if len(nums) == 2:\n            return [nums[0], nums[1]]\n        if k == len(nums) - 1:\n            return nums\n        return [nums[k]] + self.trim(nums[:k] + nums[k + 1:], k - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3]\n    k = 2\n    print(Solution().trim(nums, k))",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n    def partition(self, head, k):\n        if head is None:\n            return head\n\n        pivot = head\n        pivot_next = head.next\n        pivot_previous = head\n        for i in range(k):\n            pivot_next = pivot_next.next\n            pivot = pivot.next\n            pivot_previous = pivot_previous.next\n            \n        pivot_next.next = None\n        pivot_previous.next = None\n        \n        pivot_next = self.partition(pivot_next, k)\n        pivot_previous = self.partition(pivot_previous, k)\n        \n        return pivot_previous",
    "class Solution(object):\n    def trim(self, l, k):\n        \"\"\"\n        :type l: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        if not l:\n            return []\n        if k == 0:\n            return l\n        if k == 1:\n            return [t[:k] for t in l]\n        return [t[:k] for t in self.trim(l, k-1)]\n\nif __name__ == '__main__':\n    sln = Solution()\n    print(sln.trim([(1,2),(3,4)], 1))\n    print(sln.trim([(1,2),(3,4),(5,6)], 2))\n    print(sln.trim([(1,2),(3,4),(5,6)], 3))\n    print(sln.trim([(1,2),(3,4),(5,6)], 4))",
    "# https://www.hackerrank.com/challenges/trim-a-tuple/problem\n\nimport sys\n\n# Complete the trimTuple function below.\ndef trimTuple(tupleList, k):\n    # +++your code here+++\n    return\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        tupleList = input().split(' ')\n        k = int(input())\n        print(trimTuple(tupleList, k))",
    "class Solution:\n    # @param {ListNode[]} nums\n    # @param {number} k\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def deleteAndKeepTopK(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return\n        elif n == 1:\n            if nums[0].val == k:\n                nums[0] = nums[0].next\n                nums[0].next = None\n            return\n        elif n == 2:\n            if nums[0].val == k:\n                nums[0] = nums[0].next\n                nums[0].next = nums[1]\n            elif nums[1].val == k:\n                nums[1] = nums[1].next\n                nums[1].next = None\n            return\n        elif n == 3:\n            if nums[0].val == k:\n                nums[0] = nums[0].next\n                nums[0].next = nums[1]\n                nums[1] = nums[1].next\n                nums[1].next = nums[2]\n            elif nums[1].val == k:\n                nums[1] = nums[1].next\n                nums[1].next = nums[2]\n            elif nums[2].val == k:\n                nums[2] = nums[2].next\n                nums[2].next = None\n            return\n        elif n == 4:\n            if nums[0].val == k:\n                nums[0] = nums[0].next\n                nums[0].next = nums[1]\n                nums[1] = nums[1].next\n                nums[1].next = nums[2]\n                nums[2] = nums[2].next\n                nums[2].next = nums[3]\n            elif nums[1].val == k:\n                nums[1] = nums[1].next\n                nums[1].next",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution:\n    def trim(self, k, tuples):\n        \"\"\"\n        :type k: int\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if k == 0:\n            return tuples\n        \n        ret = []\n        for t in tuples:\n            if len(t) > k:\n                ret.append(t[:k])\n            else:\n                ret.append(t)\n        \n        return ret",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n    def deleteDuplicates(self, head):\n        if not head or not head.next:\n            return head\n\n        pre = head\n        cur = head.next\n        while cur and cur.next:\n            if cur.val == pre.val:\n                pre.next = pre.next.next\n                cur = cur.next\n            else:\n                pre = pre.next\n                cur = cur.next\n\n        return pre.next\n\nif __name__ == \"__main__\":\n    # https://leetcode.com/problems/delete-duplicates-in-an-array/solution/\n    solution = Solution()\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next.next = ListNode(9)\n\n    solution.deleteDuplicates(head).val\n    print(solution.deleteDuplicates(head))",
    "def trim(tuple_list, k):\n  # write your code here\n  trim_list = []\n  for tuple in tuple_list:\n    if len(tuple) > k:\n      trim_list.append(tuple[:k])\n    else:\n      trim_list.append(tuple)\n  return trim_list\n\nif __name__ == \"__main__\":\n  print(trim([(1, 2, 3), (2, 3, 4), (3, 4, 5)], 2))",
    "class Solution(object):\n    def trim(self, l, k):\n        \"\"\"\n        :type l: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not l: return []\n        \n        n = len(l)\n        \n        for i in xrange(n):\n            l[i] = l[i][:k] + l[i][k:]\n            \n        return l",
    "import unittest\n\n\n# Your Codec class should have the following data members\nclass Codec:\n    def encode(self, digits):\n        return digits\n\n    def decode(self, digits):\n        return digits\n\n\n# Your Codec object should have a translate method that takes in a list of digits\n# as an argument and returns a new list of digits with the leading k digits\n# removed.\n\nclass TestMethods(unittest.TestCase):\n    def test_encode(self):\n        self.assertEqual(Codec().encode([1, 2, 3, 4, 5, 6]), [1, 2, 3, 4, 5, 6])\n        self.assertEqual(Codec().encode([1, 2, 3, 4, 5, 6, 7, 8]), [1, 2, 3, 4, 5, 6, 7, 8])\n\n    def test_decode(self):\n        self.assertEqual(Codec().decode([]), [])\n        self.assertEqual(Codec().decode([1]), [1])\n        self.assertEqual(Codec().decode([1, 2, 3, 4, 5, 6]), [1, 2, 3, 4, 5, 6])\n        self.assertEqual(Codec().decode([1, 2, 3, 4, 5, 6, 7, 8]), [1, 2, 3, 4, 5, 6, 7, 8])\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        i = 0\n        j = len(nums) - 1\n        while j - i > k:\n            if nums[i] <= nums[j]:\n                i += 1\n            else:\n                j -= 1\n        return nums[i:j + 1]\n\nif __name__ == '__main__':\n    print Solution().trim([2, 3, 1, 3, 2, 1], 1)",
    "def trim(tuples, k):\n    if len(tuples) == 0:\n        return []\n    if len(tuples) == 1:\n        return tuples\n    return [t for t in tuples if len(t) >= k]\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return trim(tuples, k)",
    "def trim(tupleList, k):\n    \"\"\"\n    :type tupleList: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    trimmed = []\n    for tuple in tupleList:\n        trimmed.append(tuple[:k])\n    return trimmed",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        # sort by y, then x\n        tuples.sort()\n        for i in range(len(tuples) - 1):\n            if tuples[i].y is None and tuples[i].x == tuples[i + 1].x:\n                tuples[i].y = tuples[i + 1].y\n                del tuples[i + 1]\n\n        return tuples\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.trim([(1, 1), (1, 2), (2, 1), (3, 1)], 2)",
    "import random\n\ndef trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple[int,...]]\n    :type k: int\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    return [random.sample(tuple_list[:k], k) for _ in range(k)]\n\nclass Solution(object):\n    def trim(self, tuple_list, k):\n        \"\"\"\n        :type tuple_list: List[Tuple[int,...]]\n        :type k: int\n        :rtype: List[Tuple[int,...]]\n        \"\"\"\n        return trim(tuple_list, k)",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        for i in range(len(L)):\n            for j in range(len(L[i])):\n                if L[i][j] > k:\n                    break\n            else:\n                ans.append(L[i][:])\n                break\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().trim([[1,2,3], [4,5,6]], 1) == [[1,2,3], [4,5,6]], \"k = 1\"\n    assert Solution().trim([[1,2,3], [4,5,6]], 2) == [[2,3], [5,6]], \"k = 2\"\n    assert Solution().trim([[1,2,3], [4,5,6]], 3) == [[1,2], [4,5]], \"k = 3\"",
    "# https://oj.leetcode.com/problems/trim-a-b-list-to-make-it-a-b-list/discuss/122280/Python-Python-Solution\n\n# 9ms 100%\nclass Solution:\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or k <= 0:\n            return nums\n        nums = sorted(nums)\n        result = []\n        for i in range(len(nums)):\n            if i + k > len(nums) - 1:\n                result.append(nums[i])\n            else:\n                result.append(nums[i])\n                result.append(nums[i + k])\n        return result",
    "# https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/\n\n\nclass Solution:\n    # @param num, a list of integers\n    # @param k, an integer\n    # @return nothing\n    def removeDuplicates(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        if not num or not num[0]:\n            return\n        # use a stack to keep track of the indices that we need to remove\n        stack = []\n        for i in range(len(num)):\n            if num[i] not in stack:\n                stack.append(i)\n            else:\n                # remove the element at the top of stack\n                stack.pop()\n                # if the stack is empty, break\n                if not stack:\n                    break\n        # remove the duplicate elements from the end of the list\n        while stack and len(num) > k:\n            num[stack.pop()] = num.pop()\n        return\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.removeDuplicates([1, 1, 1, 2, 3], 2)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 1)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 2)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 3)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 4)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 5)\n    print solution.removeDuplicates([2, 2, 3, 3, 3], 6)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        for t in tuples:\n            if len(t) <= k:\n                result.append(t)\n            else:\n                result.append(t[:k])\n        return result\n\n# Note:\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple/discuss/120532/Java-O(N)-Space-O(1)-Time-solution-using-Python-and-a-list\n# https://leetcode.com/problems/trim-a-tuple",
    "# https://leetcode.com/problems/trim-a-string-to-make-it-odd/discuss/68234/C++-Solution\n#\n# Given a list of strings, you can trim all the strings in the list to make it odd.\n#\n# Example 1:\n# Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\n# Output: [\"Hell\", \"Alaska\", \"Dad\", \"Peace\"]\n# Example 2:\n# Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\", \"World\"]\n# Output: [\"Hell\", \"Alaska\", \"Dad\", \"Peace\", \"World\"]\n#\n# Note:\n# The number of elements in the given list is at most 1000.\n# All the elements in the given list are non-empty strings.\n#\n#\n#\n# time: O(N)\n# space: O(1)\n# score:100(0ms)\nclass Solution(object):\n    def trim(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return self.trim_rec(strings, 0, len(strings))\n\n    def trim_rec(self, strings, start, end):\n        if start == end:\n            return strings\n        mid = (start + end) / 2\n        left = self.trim_rec(strings, start, mid)\n        right = self.trim_rec(strings, mid + 1, end)\n        return left + [strings[mid]] + right",
    "def trim(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    if not tuples:\n        return tuples\n    res = []\n    for t in tuples:\n        if len(t) > k:\n            res.append(t[:k])\n        else:\n            res.append(t)\n    return res",
    "from __future__ import print_function\n\nclass Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(L) == 0:\n            return L\n        if len(L[0]) == 0:\n            return L\n        return self.trimRecursive(L, k)\n\n    def trimRecursive(self, L, k):\n        if len(L) == 1:\n            return L\n        newL = []\n        for i in range(len(L)):\n            if len(L[i]) > k:\n                newL.append(L[i][:k])\n            else:\n                newL.append(L[i])\n        return newL\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.trim([[1,2],[3,4,5]], 2))\n    print(sol.trim([[1,2],[3,4]], 1))\n    print(sol.trim([[1,2],[3,4],[5,6]], 1))\n    print(sol.trim([[1,2],[3,4,5],[6,7]], 1))",
    "# https://www.hackerrank.com/challenges/trim-a-tuple/problem\n\ndef trim_tuples(tuples, k):\n    return [t for t in tuples if len(t) >= k]\n\nif __name__ == '__main__':\n    n = int(input())\n    tuples = list(map(tuple, input().split()))\n    print(trim_tuples(tuples, n))",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        if not L:\n            return []\n        \n        # Sort by x.\n        L.sort(key=lambda x: x.x)\n        \n        # Remove k elements.\n        result = []\n        for t in L:\n            if len(result) >= k:\n                break\n            if t.x <= k:\n                result.append(t)\n        \n        return result",
    "def trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    # write your code here\n    trim_list = []\n    for t in tuple_list:\n        trim_list.append(t[:k])\n    return trim_list\n\nclass Solution(object):\n    def trim(self, tuple_list, k):\n        \"\"\"\n        :type tuple_list: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        return trim_list(tuple_list, k)\n\nclass Solution2(object):\n    def trim(self, tuple_list, k):\n        \"\"\"\n        :type tuple_list: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        trim_list = []\n        for t in tuple_list:\n            trim_list.append(t[:k])\n        return trim_list\n\nclass Solution3(object):\n    def trim(self, tuple_list, k):\n        \"\"\"\n        :type tuple_list: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        trim_list = []\n        for t in tuple_list:\n            trim_list.append(t[:k])\n        return trim_list",
    "class Solution:\n    # @param {ListNode[]} nodes\n    # @param {integer} k\n    # @return {ListNode[]}\n    def deleteNode(self, nodes, k):\n        if len(nodes) < 2:\n            return nodes\n        \n        pre_node = nodes[0]\n        pre_node.next = nodes[1]\n        \n        # delete the first node\n        while nodes[0]!= nodes[1]:\n            nodes = nodes[1:]\n        \n        if len(nodes) > 1:\n            # delete the second node\n            nodes[1] = nodes[2]\n            \n            # delete the last node\n            while nodes[-1].next!= nodes[0]:\n                nodes = nodes[:-1]\n            \n            # delete the last node\n            nodes[-1] = nodes[-2]\n            \n            # delete the first node\n            nodes[0] = nodes[1]\n        \n        return nodes\n    \n    # @param {ListNode[]} nodes\n    # @param {integer} k\n    # @return {ListNode[]}\n    def deleteNode2(self, nodes, k):\n        if len(nodes) < 2:\n            return nodes\n        \n        pre_node = nodes[0]\n        pre_node.next = nodes[1]\n        \n        # delete the first node\n        while nodes[0]!= nodes[1]:\n            nodes = nodes[1:]\n        \n        if len(nodes) > 1:\n            # delete the second node\n            nodes[1] = nodes[2]\n            \n            # delete the last node\n            while nodes[-1].next!= nodes[0]:\n                nodes = nodes[:-1]\n            \n            # delete the last node\n            nodes[-1] = nodes[-2]\n            \n            # delete the first node\n            nodes[0] = nodes[1]\n        \n        return nodes",
    "# https://leetcode.com/problems/trim-a-bst/discuss/192218/Python-Cython-Solution\n\nclass BST(object):\n    def __init__(self, root):\n        self.root = root\n\n    def trim(self, l, r, k):\n        if l == r:\n            return (l, r)\n        mid = (l + r) / 2\n        if self.root.val > k:\n            return self.trim(l, mid, k)\n        elif self.root.val < k:\n            return self.trim(mid + 1, r, k)\n        else:\n            return (mid, mid + 1)\n\n\ndef main():\n    bst = BST(1)\n    l = [2, 3, 5, 7, 11, 15, 20]\n    r = [0, 3, 4, 6, 10, 12, 14, 16]\n    k = 5\n    (l, r) = bst.trim(l, r, k)\n    print l, r\n\n\nif __name__ == '__main__':\n    main()",
    "def trimmer(tupleList, k):\n    \"\"\"\n    :type tupleList: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    res = []\n    for t in tupleList:\n        if len(t) >= k:\n            res.append(t[:k])\n        else:\n            res.append(t)\n    return res\n\nif __name__ == '__main__':\n    tupleList = [('a', 1, 2), ('b', 3, 4), ('c', 5, 6)]\n    print trimmer(tupleList, 3)\n    print trimmer(tupleList, 1)\n    print trimmer(tupleList, 2)\n    print trimmer(tupleList, 0)\n    print trimmer(tupleList, 7)\n    print trimmer(tupleList, 8)",
    "class Solution:\n    # @param nums: A list of integers\n    # @param k: An integer\n    # @return: A list of lists of integers\n    def partition(self, nums, k):\n        if k == 0 or len(nums) == 0:\n            return [[]]\n        return self.partition_recur(nums, k, [], [])\n\n    def partition_recur(self, nums, k, left, right):\n        if len(nums) == 0:\n            return left\n        if len(nums) == 1:\n            return [nums[0]] + right\n        if k == 1:\n            return [nums[0]] + right\n        if left == []:\n            return left + self.partition_recur(nums[1:], k-1, right, [])\n        if right == []:\n            return left + self.partition_recur(nums[:-1], k-1, left, right)\n        if len(left) >= k:\n            return left + self.partition_recur(nums[1:], k-1, right, left)\n        else:\n            return left + self.partition_recur(nums[:-1], k-1, left, right)",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n\n    def partition(self, head, k):\n        if not head or not head.next:\n            return head\n\n        left = self.partition(head.next, k)\n        right = self.partition(head.next.next, k)\n\n        if k < len(left.next.next.next):\n            left.next.next.next = self.partition(left.next.next, k)\n        else:\n            left.next.next.next = right\n            right.next = right.next.next\n\n        return left\n\n\nif __name__ == '__main__':\n    solution = Solution()\n\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n\n    print(solution.partition(head, 3))",
    "# https://leetcode.com/problems/trim-a-list-of-strings/discuss/131739/Python-solution-using-tuple-list\n\n# 1. Given a list of tuples, return a new list where each tuple has\n#    its first k elements removed.\n# 2. Example:\n#   input:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n#   output:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n# 3. Example:\n#   input:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n#   output:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n# 4. Example:\n#   input:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n#   output:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n# 5. Example:\n#   input:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n#   output:\n#   [\n#     (1,2,3,4,5),\n#     (1,2,3,4,5)\n#   ]\n# 6. Example:\n#   input:\n#   [\n#     (",
    "import time\n\nclass Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0 or k == 0:\n            return nums\n        res = []\n        for i in range(n):\n            if i >= k:\n                res.append(nums[i - k])\n            else:\n                res.append(nums[i])\n        return res\n\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0 or k == 0:\n            return nums\n        res = []\n        for i in range(k, n):\n            res.append(nums[i])\n        return res\n\nif __name__ == '__main__':\n    start_time = time.time()\n    print Solution().trim([1, 2, 3, 4], 3)\n    print Solution().trim([1, 2, 3, 4], 4)\n    print Solution().trim([1, 2, 3, 4], 1)\n    print Solution().trim([1, 2, 3, 4], 5)\n    print time.time() - start_time",
    "class Solution:\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return [l[:k] for l in L]",
    "class Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        k_sum = sum(nums)\n        if k_sum % k:\n            return nums\n\n        return [n for n in nums if n % k == 0]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n    k = 10\n    print sol.trim(nums, k)",
    "from collections import namedtuple\n\nclass Tuple(namedtuple('Tuple', 'a b')):\n    pass\n\nt = Tuple(1, 2)\n\n# Your TrimTuple function will be called like this:\n# trimtuple = TrimTuple(tuple)\n# trimtuple(3) == ((1, 2), (3,))\n\nclass TrimTuple(object):\n    def __init__(self, tuple):\n        self.tuple = tuple\n\n    def __call__(self, k):\n        return tuple([tuple[i] for i in range(k)])\n\nif __name__ == '__main__':\n    assert(TrimTuple(tuple)(3) == ((1, 2), (3,)))",
    "from collections import defaultdict\n\ndef trim(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # build a dictionary to track the number of elements to be removed\n    # for each tuple\n    removed_tuples = defaultdict(int)\n    for t in tuples:\n        for i in range(k):\n            removed_tuples[t[i]] += 1\n\n    # build a new list of tuples with the elements removed\n    # from the original list\n    new_tuples = []\n    for t in tuples:\n        if removed_tuples[t] == 0:\n            new_tuples.append(t)\n        else:\n            new_tuples.append(t[:removed_tuples[t]])\n\n    return new_tuples\n\n\n# Your Trim function should return the same output as the following.\n# Note:\n# The given tuple list is already sorted in ascending order.\n# The number of tuples to be removed is no more than k.\n# Follow up:\n# Can you solve it in-place?\n# What if the given tuples are unsorted? What if the number of tuples to be\n# removed is greater than the size of the given tuple?\n\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the tuples\n# Trim the",
    "def trim(t, k):\n    \"\"\"\n    >>> trim([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 3)\n    [(1, 2, 3), (4, 5, 6)]\n    >>> trim([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1)\n    [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    >>> trim([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 4)\n    [(1, 2, 3), (4, 5, 6)]\n    >>> trim([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 0)\n    [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    \"\"\"\n    return [t[:k] for t in t]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "from collections import namedtuple\n\n\ndef trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    def _trim(tuples):\n        for i in range(k):\n            tuples.pop(0)\n        return tuples\n    return _trim(tuple_list)\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    tuple_list = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n        [10, 11, 12]\n    ]\n    print(trim(tuple_list, 2))\n\n\nif __name__ == '__main__':\n    main()",
    "# https://leetcode.com/problems/trim-a-tuple-list-to-make-it-the-same-length/discuss/91808/Java-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-Python-",
    "class Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not k:\n            return tuples\n\n        trimmed = []\n        for t in tuples:\n            if len(t) >= k:\n                trimmed.append(t[:k])\n            else:\n                trimmed.append(t)\n        return trimmed\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    tuples = [\n        [1,2,3],\n        [1,2,3,4],\n        [1,2,3,4,5]\n    ]\n    for t in tuples:\n        print(t)\n        print(sol.trim(t, 2))",
    "from collections import namedtuple\n\n\nclass Tuple(namedtuple('Tuple', 'x y')):\n    pass\n\nclass Solution:\n    def trim(self, tuples: List[Tuple], k: int) -> None:\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: None\n        \"\"\"\n        def find_k_th_tuple(t, k):\n            while t:\n                i = t.index(k)\n                t = t[:i] + t[i + 1:]\n                if len(t) == k:\n                    return t\n        \n        for t in tuples:\n            t = find_k_th_tuple(t, k)\n            if t:\n                t = t[:k]\n                t.sort()\n                t = tuple(t)\n            else:\n                t = []\n            tuples.remove(t)\n            tuples.append(t)",
    "def trim(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if len(t) > k]",
    "# https://leetcode.com/problems/trim-a-bst/\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def trimBST(self, root: TreeNode, k: int) -> TreeNode:\n        if not root:\n            return None\n        if root.val < k:\n            return self.trimBST(root.right, k)\n        elif root.val > k:\n            return self.trimBST(root.left, k)\n        else:\n            return root",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        for i in range(len(L)):\n            ans.append(self.trim_aux(L, i, k))\n        return ans\n\n    def trim_aux(self, L, i, k):\n        ans = []\n        for j in range(k):\n            ans.append(L[i][j])\n        for j in range(k, len(L[i])):\n            ans.append(L[i][j])\n        return ans\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    L = [[1,2,3],[4,5,6]]\n    print sol.trim(L, 2)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __str__(self):\n        return str((self.x, self.y))\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        t = []\n        for tup in tuples:\n            if tup.x > k:\n                t.append(tup)\n            else:\n                t[-1].y += 1\n        return t",
    "def trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [ [x[:k] for x in l] for l in tuple_list ]\n\n\nclass Solution:\n    # @param {List[List[int]]} tuples\n    # @param {int} k\n    # @return {List[List[int]]}\n    def trim(self, tuples, k):\n        tuples = [ [x[:k] for x in l] for l in tuples ]\n        return tuples",
    "class Solution(object):\n    def trim(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(A)\n        i = 0\n        while i < n:\n            if A[i] - k < 0:\n                i += 1\n            else:\n                break\n        return A[:i]\n\nif __name__ == \"__main__\":\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 1) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 3) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 5) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 6) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 7) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 0) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 1) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 2) == [0, 1, 2, 3, 4, 5, 6, 7]\n    assert Solution().trim([0, 1, 2, 3, 4, 5, 6, 7], 3) == [0, 1, 2, 3, 4, 5, 6, 7]",
    "class Solution:\n    # @param {ListNode[]} nodes\n    # @param {number} k\n    # @return {void} Do not return anything, modify nodes in-place instead.\n    def deleteK(self, nodes, k):\n        \"\"\"\n        :type nodes: ListNode[]\n        :type k: int\n        \"\"\"\n        if not nodes:\n            return\n\n        if len(nodes) == 1:\n            return\n\n        while nodes and nodes[0].val < k:\n            nodes.pop(0)\n\n        if nodes and nodes[0].val == k:\n            nodes[0] = nodes[0].next\n            self.deleteK(nodes[0:1], k)\n\n        elif nodes and nodes[0].val > k:\n            nodes[0] = nodes[0].next\n            self.deleteK(nodes[0:1], k)\n\n        else:\n            return\n\n\nclass Solution2:\n    # @param {ListNode[]} nodes\n    # @param {number} k\n    # @return {void} Do not return anything, modify nodes in-place instead.\n    def deleteK(self, nodes, k):\n        \"\"\"\n        :type nodes: ListNode[]\n        :type k: int\n        \"\"\"\n        if not nodes:\n            return\n\n        if len(nodes) == 1:\n            return\n\n        while nodes and nodes[0].val < k:\n            nodes.pop(0)\n\n        if nodes and nodes[0].val == k:\n            nodes[0] = nodes[0].next\n            self.deleteK(nodes[0:1], k)\n\n        elif nodes and nodes[0].val > k:\n            nodes[0] = nodes[0].next\n            self.deleteK(nodes[0:1], k)\n\n        else:\n            return\n\n\nclass Solution3:\n    # @param {ListNode[]} nodes\n    # @param {number} k\n    # @return {void} Do not return anything, modify nodes in-place instead.\n    def deleteK(self, nodes, k):\n        \"\"\"\n        :type nodes: ListNode[]\n        :type k: int\n        \"\"\"",
    "class Solution(object):\n    def trim(self, list_, k):\n        \"\"\"\n        :type list_: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(list_) == 0:\n            return []\n\n        def k_trim(lst, k):\n            return [lst[0]] + [lst[i] for i in range(1, len(lst)) if lst[i] <= k]\n\n        return k_trim(list_, k)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\n# Your TrimTuple solution here.\ndef trim(tuple_list, k):\n    for i in xrange(len(tuple_list)):\n        if len(tuple_list[i]) > k:\n            tuple_list[i] = tuple_list[i][:k]\n        else:\n            tuple_list[i] = tuple_list[i][k:]\n    return tuple_list\n\ndef test():\n    tuple_list = [Tuple(i) for i in xrange(1,6)]\n    tuple_list[0] = Tuple(1)\n    tuple_list[1] = Tuple(2)\n    tuple_list[2] = Tuple(3)\n    tuple_list[3] = Tuple(4)\n    tuple_list[4] = Tuple(5)\n    tuple_list[5] = Tuple(6)\n    print \"Input: \", tuple_list\n    print \"Output: \", trim(tuple_list, 2)\n    print \"Output: \", trim(tuple_list, 3)\n    print \"Output: \", trim(tuple_list, 4)\n\nif __name__ == \"__main__\":\n    test()",
    "class Solution:\n    # @param A a list of lists of integers\n    # @param B a list of integers\n    # @return an integer\n    def removeKFromSorted(self, A, B, K):\n        \"\"\"\n        :type A: List[List[int]]\n        :type B: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        if not A or not B:\n            return 0\n        l, r = 0, len(A) - 1\n        while l < r:\n            m = (l + r) / 2\n            if B[m] <= K:\n                l = m + 1\n            else:\n                r = m\n        return l\n\n\nif __name__ == '__main__':\n    s = Solution()\n    A = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    B = [\n        1,\n        2,\n        3,\n        4\n    ]\n    print(s.removeKFromSorted(A, B, 2))\n    print(s.removeKFromSorted(A, B, 5))",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not L or not L[0]:\n            return L\n        res = []\n        for i in range(len(L[0])-1, -1, -1):\n            if L[0][i] - L[0][i+1] <= k:\n                res.append(L[0][:i+1])\n            else:\n                break\n        return res\n\n# Note:\n# You can trim the first element in the tuple if the tuple is not empty.\n# Example:\n# L = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# k = 3\n# L is a tuple list, and the tuple list has only one element.\n# Output:\n# [[4, 5, 6], [7, 8, 9]]\n# Note:\n# 1 <= k <= len(L[0]).",
    "import heapq\n\ndef trim(tuples, k):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    # TODO: write your code here\n    # Your code should be in the form of a function,\n    # but do not use the built-in 'print' function.\n    \n    heap = []\n    for t in tuples:\n        heapq.heappush(heap, t)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return heap",
    "class Solution:\n    # @param {ListNode[]} head\n    # @param {number} k\n    # @return {ListNode[]}\n    def removeK(self, head, k):\n        n = 0\n        curr = head\n        while curr is not None:\n            n += 1\n            curr = curr.next\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        while curr is not None:\n            if n == k:\n                curr = curr.next\n                continue\n            \n            if curr.next is None:\n                curr = None\n                continue\n            \n            if curr.next.val == curr.val:\n                curr = curr.next\n                continue\n            \n            curr.next = curr.next.next\n            \n        return head",
    "import sys\n\ndef trim(t):\n    \"\"\"\n    :type t: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    if not t:\n        return []\n\n    result = []\n    for i in range(len(t)):\n        if t[i][0] > k:\n            result.append(t[i])\n        else:\n            break\n\n    for j in range(i + 1, len(t)):\n        if t[j][0] > k:\n            result.append(t[j])\n        else:\n            break\n\n    return result\n\nif __name__ == '__main__':\n    t = trim([(1, 2), (3, 4), (5, 6)])\n    print(t)",
    "from collections import namedtuple\n\n\nclass Tuple(namedtuple('Tuple', 'a, b, c, d')):\n    __slots__ = ()\n\n\ndef trim_tuple_list(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuples:\n        return tuples\n\n    tuples = sorted(tuples, key=lambda tup: tup.a)\n    trimmed = []\n    for i, tup in enumerate(tuples):\n        if i + k >= len(tuples):\n            trimmed.append(tup)\n            break\n        if i + k < len(tuples) and tuples[i + k].a == tup.a:\n            trimmed.append(tup)\n        else:\n            trimmed.append(tup)\n            break\n\n    return trimmed\n\n\nif __name__ == '__main__':\n    tuples = [(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16)]\n    tuples = trim_tuple_list(tuples, 2)\n    print(tuples)",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = defaultdict(list)\n        for t in tuples:\n            for i in range(len(t)):\n                res[t[i]].append(t[i])\n        for i in range(k):\n            for t in res.values():\n                t.pop(0)\n        return [t for t in res.values()]\n\n\nif __name__ == \"__main__\":\n    assert Solution().trim([[1, 2], [3, 4]], 2) == [[3, 4]]\n    assert Solution().trim([[1, 2], [3, 4]], 1) == [[1, 2], [3, 4]]",
    "# https://leetcode.com/problems/trim-a-bst/discuss/233592/Python-with-O(n)-Space-Time\n# https://leetcode.com/problems/trim-a-bst/discuss/233592/C++-O(n)-Space-Time\n# http://blog.csdn.net/jy_jingyi/article/details/5672446\n\nclass Solution(object):\n    def trimBST(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: TreeNode\n        \"\"\"\n        def _trim(node, k):\n            if not node:\n                return None\n            if k <= 0:\n                return node.left, node.right\n            if node.left and node.left.val < k:\n                return _trim(node.left, k)\n            if node.right and node.right.val > k:\n                return _trim(node.right, k)\n            return node, None\n\n        return _trim(root, k)\n\n\nif __name__ == '__main__':\n    root = TreeNode(3, TreeNode(2, TreeNode(1), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    k = 2\n    print(Solution().trimBST(root, k))",
    "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'x y')\n\n\ndef trim(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if t.x <= k and t.y <= k]",
    "class Solution(object):\n    def partition(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) < k:\n            return [nums]\n\n        result = []\n        start = 0\n        end = k\n        while start < len(nums):\n            while start < end and nums[start] < nums[end]:\n                end -= 1\n            result.append(nums[start:end])\n            start = end\n            end += k\n        return result\n\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        start = 0\n        end = k\n        while start < len(nums):\n            while start < end and nums[start] <= nums[end]:\n                end -= 1\n            result.append(nums[start:end])\n            start = end\n            end += k\n        return result\n\n\nif __name__ == '__main__':\n    assert Solution().partition([1, 2, 3, 4, 5], 2) == [[1, 2], [3, 4], [5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 3) == [[1, 2, 3], [4, 5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 4) == [[1, 2, 3, 4], [5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 5) == [[1, 2, 3, 4, 5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 6) == [[1, 2, 3, 4, 5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 7) == [[1, 2, 3, 4, 5]]\n    assert Solution().partition([1, 2, 3, 4, 5], 8) == [[1, 2, 3, 4, 5]]",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __str__(self):\n        return '({}, {})'.format(self.x, self.y)\n\n\nclass Solution(object):\n    def trim(self, k, tuple_list):\n        \"\"\"\n        :type k: int\n        :type tuple_list: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if k == 0:\n            return tuple_list\n\n        def tr(t):\n            if t.x < k:\n                return (t.x, t.y)\n            return t\n\n        return list(map(tr, tuple_list))\n\nif __name__ == '__main__':\n    assert Solution().trim(0, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(1, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(2, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(3, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(4, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(5, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(6, [(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert Solution().trim(7, [(1, 2), (3, 4), (5, 6)])",
    "from collections import namedtuple\nfrom operator import itemgetter\n\ndef trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple[int,...]]\n    :type k: int\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    trimmed = []\n    for item in tuple_list:\n        item = list(item)\n        item[k:] = []\n        trimmed.append(tuple(item))\n    return trimmed\n\nclass TupleList:\n    def __init__(self, tuple_list):\n        self.tuple_list = tuple_list\n\nclass Tuple:\n    def __init__(self, tuple_list):\n        self.tuple_list = tuple_list\n\n    def __str__(self):\n        return str(self.tuple_list)\n\n    def __repr__(self):\n        return str(self.tuple_list)\n\n    def __eq__(self, other):\n        return self.tuple_list == other.tuple_list\n\n    def __hash__(self):\n        return hash(self.tuple_list)\n\n    def __lt__(self, other):\n        return self.tuple_list < other.tuple_list\n\n    def __le__(self, other):\n        return self.tuple_list <= other.tuple_list\n\n    def __gt__(self, other):\n        return self.tuple_list > other.tuple_list\n\n    def __ge__(self, other):\n        return self.tuple_list >= other.tuple_list\n\ndef main():\n    tuple_list = [\n        (1, 2, 3),\n        (2, 3, 4),\n        (1, 2, 3, 4),\n        (1, 2, 3, 5),\n        (1, 2, 3, 4, 5),\n    ]\n    tuple_list = [TupleList(t) for t in tuple_list]\n    print(trim(tuple_list, 2))\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        res = []\n        for t in tuples:\n            if len(res) == 0:\n                res.append(t)\n            else:\n                if len(res) == k:\n                    res.pop()\n                res.append(t)\n        return res",
    "# https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param {ListNode[]} lists\n    # @param {number} k\n    # @return {void} Do not return anything, modify lists in-place instead.\n    def removeDuplicates(self, lists, k):\n        prev = None\n        head = None\n        for node in lists:\n            if prev is not None and prev.val == node.val:\n                if k == 1:\n                    prev.next = node.next\n                    continue\n                elif k == 2:\n                    prev.next = node\n                    continue\n            else:\n                prev = node\n                head = node\n        return head",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        for i in xrange(len(L)):\n            if len(L[i]) <= k:\n                res.append(L[i])\n            else:\n                res.append(L[i][:k])\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    L = [[1,2,3],[4,5,6]]\n    k = 2\n    print sol.trim(L,k)",
    "class Solution(object):\n    def trim(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return self.trim_iter(nums, k)\n\n    def trim_iter(self, nums, k):\n        if len(nums) <= k:\n            return nums\n\n        trim_nums = []\n        for i in range(k):\n            trim_nums.append(nums.pop(0))\n\n        trim_nums.extend(nums)\n        return trim_nums",
    "def trim(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple[int]]\n    :type k: int\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    if len(tuple_list) < k:\n        return tuple_list\n\n    trimmed_list = []\n    for i in range(k):\n        trimmed_list.append(tuple_list[i])\n\n    for i in range(k, len(tuple_list)):\n        if tuple_list[i]!= tuple_list[i-k]:\n            break\n        else:\n            trimmed_list.append(tuple_list[i])\n\n    return trimmed_list",
    "def trim(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if len(t) >= k]\n\nclass Solution(object):\n    def trim(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        return trim(tuples, k)",
    "# The solution is simple.\n# We start from the end, move k-1 times, and keep the last one.\n# Then we move k-1 times and keep the first one.\n# Finally, we move k-1 times and keep the last one.\n# If k is 0, we just return the original tuple list.\n# If k is -1, we return a list with the last element removed.\n# If k is 1, we return a list with the first element removed.\n# If k is 2, we return a list with the second element removed.\n# If k is 3, we return a list with the third element removed.\n# If k is greater than the length of the tuple list, we return the original tuple list.\n# If k is less than zero, we return a list with the last element removed.\n\ndef trim(tupleList, k):\n    if k == 0:\n        return tupleList\n    elif k == -1:\n        return tupleList[:-1]\n    elif k == 1:\n        return tupleList[1:]\n    elif k == 2:\n        return tupleList[2:]\n    elif k == 3:\n        return tupleList[3:]\n    else:\n        return tupleList[k:]\n\nprint trim([(1, 2, 3), (4, 5, 6)], 0)\nprint trim([(1, 2, 3), (4, 5, 6)], -1)\nprint trim([(1, 2, 3), (4, 5, 6)], 1)\nprint trim([(1, 2, 3), (4, 5, 6)], 2)\nprint trim([(1, 2, 3), (4, 5, 6)], 3)\nprint trim([(1, 2, 3), (4, 5, 6)], 4)\nprint trim([(1, 2, 3), (4, 5, 6)], -3)\nprint trim([(1, 2, 3), (4, 5, 6)], -2)\nprint trim([(1, 2, 3), (4, 5, 6)], -1)\nprint trim([(1, 2, 3), (4, 5, 6)], 0)",
    "class Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[Tuple[int, int]]\n        :type k: int\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        ans = []\n        for l, r in L:\n            if l <= k and r >= k:\n                ans.append((l, r))\n        return ans",
    "# https://leetcode.com/problems/trim-a-tuple/discuss/169917/Python-Solution\n\nclass Solution(object):\n    def trimTuple(self, tupleList, k):\n        \"\"\"\n        :type tupleList: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        def trim(tupleList, k):\n            if len(tupleList) == 0:\n                return tupleList\n            else:\n                for i in range(len(tupleList)):\n                    if len(tupleList[i]) >= k:\n                        tupleList[i] = tupleList[i][:k]\n                    else:\n                        tupleList[i] = tupleList[i]\n                    trim(tupleList[i], k)\n        trim(tupleList, k)\n        return tupleList\n\nif __name__ == '__main__':\n    tupleList = [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i'), ('j', 'k', 'l'), ('m', 'n', 'o')]\n    tupleList = [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i'), ('j', 'k', 'l'), ('m', 'n', 'o')]\n    tupleList = [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i'), ('j', 'k', 'l'), ('m', 'n', 'o')]\n    tupleList = [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i'), ('j', 'k', 'l'), ('m', 'n', 'o')]\n    tupleList = [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i'), ('j', 'k', 'l'), ('m', 'n', 'o')]\n    tupleList = [('a', 'b', 'c'), ('d', 'e', '",
    "# https://leetcode.com/problems/trim-a-list-of-strings/discuss/93872/Python-implementation-of-trim-a-list-of-strings-with-in-order-and-out-of-order\nclass Solution(object):\n    def trim(self, strs, k):\n        \"\"\"\n        :type strs: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        if k <= 0:\n            return []\n        l = 0\n        r = len(strs) - 1\n        while l < r:\n            if strs[l].startswith(strs[r]):\n                l += 1\n            else:\n                r -= 1\n        return strs[:l + k]\n\n# Note:\n# 1. the input list is not sorted, the output list is sorted\n# 2. the input list is a duplicate\n# 3. k is the length of the input list\n# 4. the input list is not empty\n# 5. the input list is not empty\n# 6. the input list is not empty",
    "# https://www.hackerrank.com/challenges/trim-a-tuple\n# https://www.hackerrank.com/challenges/trim-a-tuple-2\n\nimport unittest\n\ndef trim_tuple(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int,...]]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n\n    for i in range(0, len(tuple_list), 2):\n        tuple_list[i] = tuple_list[i][:k]\n    return tuple_list\n\nclass MyTestCases(unittest.TestCase):\n    def test_trim_tuple(self):\n        tuple_list = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n        tuple_list_trimmed = trim_tuple(tuple_list)\n        self.assertEqual(tuple_list_trimmed, [(1, 2, 3), (4, 5, 6), (7, 8, 9)])\n\nif __name__ == '__main__':\n    unittest.main()",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def trim(self, L, k):\n        \"\"\"\n        :type L: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        if not L:\n            return []\n        n = len(L)\n        i = 0\n        j = n\n        while i < j:\n            if L[i]!= L[j]:\n                i += 1\n            j -= 1\n        if i == n - k:\n            return L[i:k]\n        elif i < k:\n            return L[i:]\n        else:\n            return L[:k]",
    "class Solution:\n    # @param {ListNode[]} nodes\n    # @param {integer} k\n    # @return {void} Do not return anything, modify nodes in-place instead.\n    def deleteKthLargest(self, nodes, k):\n        \n        if k == 1:\n            return\n        \n        index = 0\n        while index < len(nodes):\n            if len(nodes) - index >= k - 1:\n                nodes[index] = nodes[index + 1]\n                index += 1\n            else:\n                break\n        \n        nodes[index] = nodes[len(nodes) - 1]\n        del nodes[len(nodes) - 1]\n        \n        nodes.sort(reverse=True)\n        \n        for i in range(len(nodes) - 1, -1, -1):\n            if len(nodes) - i >= k - 1:\n                nodes[i] = nodes[len(nodes) - i]\n            else:\n                break\n        \n        nodes.sort()\n        \n        for i in range(len(nodes) - 1, -1, -1):\n            if len(nodes) - i >= k - 1:\n                nodes[i] = nodes[len(nodes) - i]\n            else:\n                break\n        \n        nodes.sort()",
    "from collections import namedtuple\n\ndef trim(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :type k: int\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    tuple_list = [t for t in tuples]\n    tuple_list.sort(key=lambda tup: tup[0])\n    trimmed = []\n    for tup in tuple_list:\n        if tup[0] >= k:\n            trimmed.append(tup)\n    return trimmed\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2),\n        (3, 4),\n        (5, 6),\n        (7, 8),\n        (9, 10),\n        (11, 12),\n        (13, 14),\n        (15, 16),\n        (17, 18),\n        (19, 20)\n    ]\n    k = 2\n    print(trim(tuples, k))\n    k = 10\n    print(trim(tuples, k))\n    k = 20\n    print(trim(tuples, k))",
    "def trim_tuple(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuple_list:\n        return tuple_list\n    return [(i, j) for i in range(len(tuple_list[0])) for j in range(len(tuple_list)) if j < k]",
    "# https://leetcode.com/problems/trim-a-list-of-strings-to-make-it-smaller-than-k/discuss/71788/Python-Solution-with-O(n)-Time-and-Space\n\nclass Solution:\n    # @return a tuple\n    def trim(self, nums, k):\n        # write your code here\n        if not nums:\n            return []\n        k = min(k, len(nums))\n        for i in xrange(len(nums) - k + 1):\n            if all(nums[i:i+k] == nums[i+k-k:] for i in xrange(len(nums)-k)):\n                return nums[:i]\n        return nums\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,4]\n    k = 2\n    print Solution().trim(nums, k)",
    "class Solution:\n    # @param {ListNode[]} nodes\n    # @param {int} k\n    # @return {ListNode[]}\n    def removeKthLargest(self, nodes, k):\n        n = len(nodes)\n        if n == 0:\n            return []\n\n        head = nodes[0]\n        ans = [head]\n        for i in range(1, n):\n            curr = nodes[i]\n            if curr.val < head.val:\n                ans.append(curr)\n            else:\n                head = curr\n        ans.append(head)\n        ans.pop(0)\n        ans.pop()\n\n        if k > n:\n            return ans\n        elif k == n:\n            return ans[:k]\n\n        return self.removeKthLargest(ans[k:], k)\n\nif __name__ == '__main__':\n    print Solution().removeKthLargest([1, 5, 6, 7], 2)",
    "from collections import namedtuple\n\n_Tuple = namedtuple('_Tuple', 'a b c d')\n\ndef trim(tuples, k):\n    \"\"\"\n    :type tuples: List[_Tuple]\n    :type k: int\n    :rtype: List[_Tuple]\n    \"\"\"\n    for i in range(len(tuples)):\n        if len(tuples[i]) < k:\n            tuples = tuples[:i] + tuples[i+1:]\n    return tuples",
    "from typing import List\n\n\nclass Solution:\n    def trim(self, k: int, tuples: List[List[int]]) -> int:\n        \"\"\"\n        :type k: int\n        :type tuples: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return sum(map(lambda x: x[0], tuples))\n\n        k = k - 1\n        count = 0\n        for i, t in enumerate(tuples):\n            if i < k:\n                t = t[k:]\n            count += sum(map(lambda x: x[0], t))\n        return count",
    "def trim_tuple(tuple_list, k):\n    for i in range(len(tuple_list)):\n        tuple_list[i] = tuple_list[i][:k]\n    return tuple_list\n\ntuple_list = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\ntrim_tuple(tuple_list, 2)\n\nprint(tuple_list)",
    "def trim(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    ans = []\n    for t in tuples:\n        ans.append([x for x in t if x!= 0])\n    return ans",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def trim(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        curr = head\n        while curr:\n            curr = curr.next\n            while curr and curr.val <= k:\n                curr = curr.next\n            if curr and curr.val > k:\n                head.next = curr.next\n                curr.next = None\n        return head"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}