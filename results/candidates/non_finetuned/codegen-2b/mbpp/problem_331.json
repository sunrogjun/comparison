{
  "problem": {
    "task_id": "MBPP/342",
    "prompt": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.",
    "canonical_solution": "from heapq import heappop, heappush\r\nclass Node:\r\n    def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])",
    "test_list": [
      "assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)",
      "assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)",
      "assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)"
    ],
    "challenge_test_list": [],
    "problem_id": 331
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        n1, n2, n3, n4 = len(nums1), len(nums2), len(nums3), len(nums4)\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        for i in range(n1):\n            if nums1[i] >= nums2[i] and nums1[i] >= nums3[i] and nums1[i] >= nums4[i]:\n                return i\n        for i in range(n2):\n            if nums2[i] >= nums1[i] and nums2[i] >= nums3[i] and nums2[i] >= nums4[i]:\n                return i\n        for i in range(n3):\n            if nums3[i] >= nums1[i] and nums3[i] >= nums2[i] and nums3[i] >= nums4[i]:\n                return i\n        for i in range(n4):\n            if nums4[i] >= nums1[i] and nums4[i] >= nums2[i] and nums4[i] >= nums3[i]:\n                return i\n        return -1\n\n\nif __name__ == '__main__':\n    nums1 = [1, 3, 5, 6, 7]\n    nums2 = [2, 4, 6, 8]\n    nums3 = [1, 3, 5, 6, 7]\n    nums4 = [2, 3, 5, 7]\n    print Solution().smallestRange(nums1, nums2, nums3, nums4)",
    "def find_smallest_range(arrays):\n    if not arrays:\n        return (0, 0)\n    arrays = sorted(arrays)\n    min_length = max(map(len, arrays))\n    min_length_index = 0\n    for index in range(len(arrays)):\n        if arrays[index] and min_length > len(arrays[index]):\n            min_length = len(arrays[index])\n            min_length_index = index\n    return (min_length, min_length_index)\n\nif __name__ == '__main__':\n    arrays = [[1,2,3,4], [5,6], [7,8,9], [10]]\n    print(find_smallest_range(arrays))",
    "# https://oj.leetcode.com/problems/smallest-range/\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return an integer\n    def smallestRange(self, intervals):\n        if not intervals:\n            return 0\n\n        # find the first and last intervals\n        first = intervals[0]\n        last = intervals[-1]\n\n        # find the range of the last interval\n        range = last.end - first.start\n        for interval in intervals[1:]:\n            if interval.end < last.start:\n                range = last.end - first.start\n            else:\n                range = min(range, interval.end - last.start)\n\n        return range\n\nif __name__ == '__main__':\n    intervals = [Interval(1, 3), Interval(2, 6), Interval(10, 12)]\n    s = Solution()\n    print(s.smallestRange(intervals))\n    print(s.smallestRange([Interval(1, 3), Interval(2, 6), Interval(10, 12)]))",
    "#!/usr/bin/env python\n\nimport time\n\nstart_time = time.time()\n\ndef smallest_range_of_arrays(arrays):\n    # write your code in Python 3\n    #\n    # arrays is a list of lists. Each list is an array of integers\n    #\n    # return a list of ranges which have at least one integer from each array\n    #\n    # each range is a list of integers, where each integer is the minimum number of integers\n    # from each array to be in the range\n    #\n    # the minimum range is the smallest range that includes at least one element from each array\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def smallestRange(self, intervals: List[Interval]) -> Interval:\n        start, end = 0, 0\n        for interval in intervals:\n            if interval.start <= start:\n                start = max(start, interval.start)\n            elif interval.end > end:\n                end = min(end, interval.end)\n        return Interval(start, end)",
    "def smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not arrays:\n        return 0\n\n    min_range = min(arrays)\n    max_range = max(arrays)\n\n    for element in arrays:\n        if element <= min_range:\n            min_range = min(min_range, element)\n        elif element >= max_range:\n            max_range = max(max_range, element)\n\n    return min_range + max_range",
    "def smallest_range_with_at_least_one(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    result = [0] * len(arrays)\n    for i in range(len(arrays)):\n        result[i] = max(arrays[i])\n        for j in range(i + 1, len(arrays)):\n            if arrays[i][j] == 1:\n                result[j] = min(result[j], result[i] + 1)\n    return result\n\n\n\n#print(smallest_range_with_at_least_one([[0, 0, 0], [1, 1, 1], [2, 2, 2]]))\n#print(smallest_range_with_at_least_one([[0, 1, 2], [3, 4, 5], [6, 7, 8]]))\n\narrays = [[0, 0, 0], [1, 1, 1], [2, 2, 2]]\nprint(smallest_range_with_at_least_one(arrays))",
    "# Approach 1: Loop through each array and find the smallest range that includes at-least one element from each.\ndef smallestRange(arr1, arr2, arr3):\n    minRange = 9999999999\n    for i in range(0, len(arr1)):\n        for j in range(0, len(arr2)):\n            for k in range(0, len(arr3)):\n                if arr1[i] >= arr2[j] and arr1[i] >= arr3[k] and arr2[j] >= arr3[k]:\n                    if arr1[i] + arr2[j] + arr3[k] < minRange:\n                        minRange = arr1[i] + arr2[j] + arr3[k]\n    return minRange\n\n# Approach 2: Iterate through each element of each array and find the smallest range that includes at-least one element from each.\ndef smallestRange2(arr1, arr2, arr3):\n    minRange = 9999999999\n    for i in range(0, len(arr1)):\n        for j in range(0, len(arr2)):\n            for k in range(0, len(arr3)):\n                if arr1[i] >= arr2[j] and arr1[i] >= arr3[k] and arr2[j] >= arr3[k]:\n                    if arr1[i] + arr2[j] + arr3[k] < minRange:\n                        minRange = arr1[i] + arr2[j] + arr3[k]\n    return minRange\n\n# Approach 3: Sort the arrays and then iterate through each element of each array and find the smallest range that includes at-least one element from each.\ndef smallestRange3(arr1, arr2, arr3):\n    arr1.sort()\n    arr2.sort()\n    arr3.sort()\n    minRange = 9999999999\n    for i in range(0, len(arr1)):\n        for j in range(0, len(arr2)):\n            for k in range(0, len(arr3)):\n                if arr1[i] >= arr2[j] and arr1",
    "def smallestRange(arrays):\n    if len(arrays) == 0:\n        return 0\n\n    minRange = float(\"inf\")\n    minIndex = 0\n\n    for i in range(0, len(arrays)):\n        if arrays[i] == []:\n            continue\n\n        arr = arrays[i]\n        minRange = min(minRange, min(arr))\n        minIndex = i\n\n    return minRange\n\ndef main():\n    arrays = [\n        [1, 2, 3, 4],\n        [2, 3, 4],\n        [2, 3],\n        [2, 3, 5],\n        [],\n        [1, 2, 3, 4, 5],\n        [1, 2, 3, 4, 5, 6],\n        [1, 2, 3, 4, 5, 6, 7],\n        [1, 2, 3, 4, 5, 6, 7, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    ]\n\n    print(smallestRange(arrays))\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def threeSum(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        result = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if j >= len(nums3):\n                    break\n                if i >= len(nums1) or j >= len(nums2) or i >= len(nums1) or j >= len(nums2):\n                    continue\n                if nums1[i] + nums2[j] + nums3[j] == 0:\n                    result.append([nums1[i], nums2[j], nums3[j]])\n        return result\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.threeSum([-1, 2, 1, -4], [-5, -3, -2, 1], [5, -1, 4, -3]))",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if len(arrays) == 0:\n        return []\n    else:\n        return [min(arrays[0]), max(arrays[0])] + find_smallest_range(arrays[1:])\n\n\nif __name__ == '__main__':\n    arrays = [[1, 2, 3, 4], [2, 4, 6, 8], [3, 5, 7], [4, 6, 8]]\n    print(find_smallest_range(arrays))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def smallestRange(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n\n        intervals.sort(key=lambda x: (x.start, x.end), reverse=True)\n\n        ans = 0\n        for i in range(len(intervals)):\n            ans = max(ans, intervals[i].end - intervals[i].start + 1)\n\n        return ans\n\n    def smallestRange2(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans = max(ans, intervals[i].end - intervals[i].start + 1)\n            else:\n                ans = max(ans, intervals[i].end - intervals[i-1].start + 1)\n\n        return ans\n\n\na = [Interval(1, 2), Interval(4, 5), Interval(5, 6), Interval(6, 7)]\n\ns = Solution()\n\nprint s.smallestRange(a)",
    "import unittest\n\ndef find_range(arrays):\n    if not arrays:\n        return 0\n    min_range = max_range = arrays[0][0]\n    for arr in arrays:\n        if arr[0] < min_range:\n            min_range = arr[0]\n        if arr[-1] > max_range:\n            max_range = arr[-1]\n    return min_range, max_range\n\n\nclass Test(unittest.TestCase):\n    def test_find_range(self):\n        self.assertEqual(find_range([[1, 2, 3], [4, 5], [6], [7, 8, 9]]), (1, 9))\n        self.assertEqual(find_range([[1, 2], [3, 4, 5], [6, 7], [8, 9, 10]]), (1, 10))\n        self.assertEqual(find_range([[1], [2, 3], [4, 5, 6], [7, 8]]), (1, 7))\n        self.assertEqual(find_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (1, 9))\n\nif __name__ == '__main__':\n    unittest.main()",
    "def find_smallest_range(arr1, arr2, arr3):\n    def find_smallest_range_aux(arr, i, j, k):\n        if i == 0 or j == len(arr) or k == len(arr[0]):\n            return 0\n        \n        if arr[i][k] < arr[j][k]:\n            return k + 1\n        else:\n            return find_smallest_range_aux(arr, i+1, j, k)\n\n    return find_smallest_range_aux(arr1, 0, 0, 0) + find_smallest_range_aux(arr2, 0, 0, 0) + find_smallest_range_aux(arr3, 0, 0, 0)\n\nif __name__ == \"__main__\":\n    arr1 = [1, 2, 3, 4]\n    arr2 = [1, 2, 3, 4, 5]\n    arr3 = [1, 2, 3, 4, 5, 6]\n\n    print find_smallest_range(arr1, arr2, arr3)",
    "def smallestRange(arrays):\n\tif len(arrays) == 0:\n\t\treturn 0\n\t\n\tarrays.sort()\n\tmin_range = max(arrays[0], 0)\n\tfor i in range(1, len(arrays)):\n\t\tif min_range < arrays[i]:\n\t\t\tmin_range = arrays[i]\n\treturn min_range\n\nprint smallestRange([[1, 2], [3, 4], [5, 6], [7, 8]])\nprint smallestRange([[1, 2], [3, 4], [5, 6]])\nprint smallestRange([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])",
    "import unittest\n\nclass Solution(object):\n    def findRange(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        low = 0\n        high = 0\n        for i in xrange(len(nums1)):\n            if low == high:\n                low = nums1[i]\n            high = max(high, nums2[i])\n        return [low, high]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> findRange(int[] nums1, int[] nums2) {\n        int low = 0, high = 0;\n        for (int i = 0; i < nums1.length; i++) {\n            if (low == high) {\n                low = nums1[i];\n            }\n            high = Math.max(high, nums2[i]);\n        }\n        return Arrays.asList(low, high);\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public List<Integer> findRange(int[] nums1, int[] nums2) {\n        int low = 0, high = 0;\n        for (int i = 0; i < nums1.length; i++) {\n            if (low == high) {\n                low = nums1[i];\n            }\n            high = Math.max(high, nums2[i]);\n        }\n        return Arrays.asList(low, high);\n    }\n}\n'''",
    "from collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: list[list[int]]\n    :rtype: int\n    \"\"\"\n    arrays = sorted(arrays)\n    res = 0\n    for i in range(len(arrays)):\n        curr_res = len(arrays[i])\n        res = max(res, curr_res)\n    return res\n\nif __name__ == \"__main__\":\n    arrays = [[1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]]\n    print(find_smallest_range(arrays))\n    arrays = [[1], [2], [3], [4], [5]]\n    print(find_smallest_range(arrays))\n    arrays = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    print(find_smallest_range(arrays))",
    "def find_range(arr1, arr2):\n    def find_min_range(arr):\n        if len(arr) == 0:\n            return None\n        if len(arr) == 1:\n            return arr[0]\n        return min(arr[0], arr[1])\n\n    return find_min_range(arr1) + find_min_range(arr2)\n\n\ndef test():\n    assert find_range([], []) == 0\n    assert find_range([1], [1]) == 1\n    assert find_range([1, 2, 3], [4, 5, 6]) == 3\n    assert find_range([1, 2, 3], [3, 4, 5]) == 2\n\nif __name__ == '__main__':\n    test()",
    "class Solution:\n    def smallestRange(self, arr1, arr2, arr3, arr4):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :type arr3: List[int]\n        :type arr4: List[int]\n        :rtype: int\n        \"\"\"\n        def get_range(arr, start, end):\n            for i in range(start, end):\n                if arr[i] > 0:\n                    return i\n            return -1\n\n        if arr1 == [] or arr2 == [] or arr3 == [] or arr4 == []:\n            return 0\n\n        min_range = 0\n        for i in range(0, len(arr1)):\n            min_range = max(min_range, get_range(arr1, i, i))\n            min_range = max(min_range, get_range(arr2, i, i))\n            min_range = max(min_range, get_range(arr3, i, i))\n            min_range = max(min_range, get_range(arr4, i, i))\n\n        return min_range\n\n\nif __name__ == \"__main__\":\n    assert Solution().smallestRange([1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7]) == 3",
    "# Time:  O(N^2)\n# Space: O(N^2)\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: int\n        \"\"\"\n        # TODO: Refactor to use binary search to find the index of the first element of each list.\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    if nums1[i] <= nums2[j] <= nums3[k]:\n                        return min(i, j, k)\n        return -1",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @param {integer[]} nums4\n    # @param {integer} k\n    # @return {integer}\n    def smallestRange(self, nums1, nums2, nums3, nums4, k):\n        res = [0] * k\n        for i in range(k):\n            res[i] = max(nums1[i], nums2[i], nums3[i], nums4[i])\n        for i in range(k):\n            if res[i] == nums1[i]:\n                for j in range(i + 1, k):\n                    if res[j] < nums1[j]:\n                        res[j] = nums1[j]\n            elif res[i] == nums2[i]:\n                for j in range(i + 1, k):\n                    if res[j] < nums2[j]:\n                        res[j] = nums2[j]\n            elif res[i] == nums3[i]:\n                for j in range(i + 1, k):\n                    if res[j] < nums3[j]:\n                        res[j] = nums3[j]\n            elif res[i] == nums4[i]:\n                for j in range(i + 1, k):\n                    if res[j] < nums4[j]:\n                        res[j] = nums4[j]\n        return res",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    min_range = 0\n    for arr in arrays:\n        min_range = min(min_range, min(arr))\n    return min_range\n\nif __name__ == '__main__':\n    arrays = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n        [10, 11, 12],\n    ]\n    print(find_smallest_range(arrays))",
    "# https://leetcode.com/problems/smallest-range-included-in-all-sorted-arrays/discuss/394899/Python-solution\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/smallest-range-included-in-all-sorted-arrays/discuss/394899/C++-Python-Solutions\n        # https://discuss.leetcode.com/topic/14962/java-solution-with-explanation\n        # O(n) time, O(1) space\n        # dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n        # dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1])\n        dp = [0] * (len(nums1) + 1)\n        for i in range(len(nums1)):\n            for j in range(len(nums2) + 1):\n                dp[j] = min(dp[j - 1], dp[j], dp[j - 1])\n                dp[j] = min(dp[j], dp[j - 1], dp[j - 1])\n        return dp[-1",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @param {integer[]} nums4\n    # @return {integer[]}\n    def fourSum(self, nums1, nums2, nums3, nums4):\n        res = []\n        n1 = len(nums1)\n        n2 = len(nums2)\n        n3 = len(nums3)\n        n4 = len(nums4)\n        if n1 == 0 or n2 == 0 or n3 == 0 or n4 == 0:\n            return res\n        if n1 + n2 + n3 + n4 > 200:\n            return res\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        m = max(n1, n2, n3, n4)\n        for i in range(0, m):\n            if i == 0:\n                a = nums1[i]\n                b = nums2[i]\n                c = nums3[i]\n                d = nums4[i]\n            elif i == 1:\n                a = nums2[i]\n                b = nums1[i]\n                c = nums3[i]\n                d = nums4[i]\n            elif i == 2:\n                a = nums3[i]\n                b = nums1[i]\n                c = nums2[i]\n                d = nums4[i]\n            elif i == 3:\n                a = nums4[i]\n                b = nums1[i]\n                c = nums2[i]\n                d = nums3[i]\n            else:\n                continue\n            for j in range(0, n1):\n                if j >= i:\n                    continue\n                e = j\n                while e < n1 and nums1[j] == nums1[e]:\n                    e += 1\n                for k in range(j+1, e):\n                    if k >=",
    "# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-of-given-arrays/discuss/296917/Python-O(n^2)-Solution\ndef smallestRange(arrays):\n    # Write your code here\n    if not arrays:\n        return []\n    arrays.sort()\n    start = 0\n    end = 0\n    for i in range(len(arrays)):\n        if end < start:\n            start = end\n        end = min(end, start + 1)\n        while start < end:\n            if arr1[start] in arr2:\n                return [start, end]\n            start += 1\n    return []",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def smallestRange(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: Interval\n        \"\"\"\n        # Write your code here\n        ans = [0, 0]\n        for i in intervals:\n            ans[0] = max(ans[0], i.start)\n            ans[1] = min(ans[1], i.end)\n        return ans[0], ans[1]\n\nif __name__ == '__main__':\n    solution = Solution()\n    intervals = [Interval(1, 2), Interval(2, 3), Interval(1, 4)]\n    print solution.smallestRange(intervals)",
    "# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(N)-Solutions-with-Time-Complexity-O(N)\n# https://leetcode.com/problems/range-sum-query-immutable/discuss/96481/Python-with-O(",
    "import collections\nfrom collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # Use a defaultdict to map a range to a list of arrays that contain the range.\n    # This is done because if we use a set, we cannot know if a given range is unique or not.\n    # The defaultdict allows us to know if a given range is unique or not.\n    # We also need to know if the range is empty or not, and this is done by checking if the\n    # defaultdict has a key for the range.\n    # The defaultdict is used because the range could be empty, and we can use the fact that\n    # if the defaultdict has a key for the range, that means the range is not empty.\n    # This is why we cannot use a set because the range could be empty.\n    # If we use a set, we cannot know if the range is empty or not.\n    ranges = defaultdict(list)\n    for array in arrays:\n        # We need to iterate over all the elements in the array, and check if the range\n        # is empty or not.\n        # This is done because we don't know if the range is empty or not, and we need to know\n        # if the range is empty or not.\n        for i in range(len(array)):\n            if i < len(array) - 1:\n                # Check if the range is empty.\n                # If the range is not empty, then we need to add the range to the list of ranges.\n                if array[i] == array[i+1]:\n                    ranges[array[i]].append(array)\n                else:\n                    ranges[array[i]].append(array[i:i+2])\n            else:\n                ranges[array[i]].append(array[:i+1])\n    smallest_range = -1\n    for key in ranges:\n        if len(ranges[key]) == 0:\n            continue\n        if smallest_range == -1:\n            smallest_range = key\n        elif key < smallest_range:\n            smallest_range",
    "def find_smallest_range(arrays):\n    if not arrays:\n        return 0\n\n    arrays = sorted(arrays)\n    min_range = max(arrays)\n    for a in arrays:\n        if a < min_range:\n            min_range = a\n    return min_range\n\nif __name__ == '__main__':\n    arrays = [1, 2, 3, 4, 5, 6, 7]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print(find_smallest_range(arrays))\n    arrays = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    print(find_smallest_range(arrays))",
    "import sys\nimport math\n\ndef find_range(arrays):\n    for i in range(0, len(arrays)):\n        if len(arrays[i]) > 0:\n            break\n    else:\n        return 0\n    for j in range(i, len(arrays)):\n        if len(arrays[j]) > 0:\n            break\n    else:\n        return 0\n    \n    # Find the smallest range\n    for k in range(i, j):\n        if math.fabs(arrays[k][0] - arrays[k][1]) < math.fabs(arrays[k][0] - arrays[k][2]):\n            return arrays[k][0]\n        elif math.fabs(arrays[k][0] - arrays[k][2]) < math.fabs(arrays[k][1] - arrays[k][2]):\n            return arrays[k][2]\n    return -1\n\nif __name__ == \"__main__\":\n    arrays = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\n    print find_range(arrays)\n    arrays = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ]\n    print find_range(arrays)\n    arrays = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ] ]\n    print find_range(arrays)\n    arrays = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\n    print find_range(arrays)",
    "def smallestRange(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # Write your code here\n    if not arrays:\n        return 0\n\n    n = len(arrays)\n    result = None\n    for i in range(n):\n        for j in range(n):\n            if arrays[i][j] > 0:\n                if not result or arrays[i][j] < result[0]:\n                    result = [arrays[i][j], i, j]\n\n    if not result:\n        return 0\n\n    return result[0]\n\nif __name__ == '__main__':\n    arrays = [[1,2,3],[4,5,6],[7,8,9]]\n    print(smallestRange(arrays))",
    "import sys\n\ndef find_smallest_range(arrays):\n    min_range = sys.maxsize\n    for arr in arrays:\n        min_range = min(min_range, min(arr))\n    return min_range\n\nif __name__ == \"__main__\":\n    arrays = [[1, 2, 3, 4], [4, 5, 6, 7], [9, 10, 11, 12]]\n    print(find_smallest_range(arrays))",
    "def find_smallest_range(arr1, arr2, arr3):\n    \"\"\"\n    :type arr1: list[int]\n    :type arr2: list[int]\n    :type arr3: list[int]\n    :rtype: int\n    \"\"\"\n    i = 0\n    j = 0\n    k = 0\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] < arr2[j] and arr1[i] < arr3[k]:\n            return i\n        elif arr2[j] < arr1[i] and arr2[j] < arr3[k]:\n            return j\n        elif arr3[k] < arr1[i] and arr3[k] < arr2[j]:\n            return k\n        i += 1\n        j += 1\n        k += 1\n    return k",
    "#!/usr/bin/python\n\nimport math\n\ndef range_sum(arr1, arr2):\n    return math.sqrt(sum(arr1) + sum(arr2))\n\ndef range_sum_all(arrs):\n    return math.sqrt(sum(arrs))\n\ndef range_sum_all_2(arrs):\n    return math.sqrt(sum([sum(arrs[0:i+1]) for i in range(len(arrs))]))\n\ndef range_sum_all_3(arrs):\n    return math.sqrt(sum([sum([sum(arrs[i:j]) for i in range(0, len(arrs))]) for j in range(1, len(arrs)+1)]))\n\ndef range_sum_all_4(arrs):\n    return math.sqrt(sum([sum([sum([sum(arrs[i:j:k]) for k in range(0, len(arrs))]) for j in range(0, len(arrs))]) for i in range(0, len(arrs))]))\n\ndef range_sum_all_5(arrs):\n    return math.sqrt(sum([sum([sum([sum([sum(arrs[i:j:k:l]) for l in range(0, len(arrs))]) for k in range(0, len(arrs))]) for j in range(0, len(arrs))]) for i in range(0, len(arrs))]))\n\ndef range_sum_all_6(arrs):\n    return math.sqrt(sum([sum([sum([sum([sum(arrs[i:j:k:l:m]) for m in range(0, len(arrs))]) for l in range(0, len(arrs))]) for k in range(0, len(arrs))]) for j in range(0, len(arrs))]))\n\ndef range_sum_all_7(arrs):\n    return math.sqrt(sum([sum([sum([sum([sum(arrs[i:j:k:l:m:n]) for n in range(0, len(arrs))])",
    "import time\nstart_time = time.time()\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    def check_for_array(arr, i, j, res):\n        while i < j:\n            if arr[i] == arr[j]:\n                res.append(arr[i])\n                i += 1\n            else:\n                j -= 1\n\n    res = []\n    for i in xrange(len(arrays)):\n        check_for_array(arrays[i], 0, len(arrays[i]), res)\n    return res\n\nprint \"Elapsed time: %f\" % (time.time() - start_time)",
    "def smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not arrays:\n        return 0\n\n    smallest_range = float('inf')\n    for a in arrays:\n        smallest_range = min(smallest_range, len(a))\n    return smallest_range",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport itertools\n\ndef get_ranges(arrays):\n    ranges = set()\n    for arr in arrays:\n        ranges.add(tuple(sorted(arr)))\n    return sorted(ranges)\n\ndef main():\n    arrays = [[1,2,3], [2,3], [1,2,3,4,5,6], [1,2,3,4,5,6,7,8,9], [1,2,3,4,5,6,7,8,9,10]]\n    print get_ranges(arrays)\n\nif __name__ == '__main__':\n    main()",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    if not arrays:\n        return 0\n    arrays.sort(key=lambda x: x.count(x[0]))\n    min_range = max(arrays) + 1\n    for i in range(len(arrays)):\n        if arrays[i][0] == min_range:\n            min_range += 1\n    return min_range\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nb = [1, 2, 3, 4, 5, 6]\nc = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(find_smallest_range([a, b, c]))",
    "def smallest_range_with_at_least_one_element(arrays):\n\t\"\"\"\n\t:type arrays: List[List[int]]\n\t:rtype: int\n\t\"\"\"\n\tdef find_smallest_range(arrays):\n\t\tif len(arrays) == 0:\n\t\t\treturn 0\n\t\telif len(arrays) == 1:\n\t\t\treturn len(arrays[0])\n\t\telif len(arrays) == 2:\n\t\t\treturn min(len(arrays[0]), len(arrays[1]))\n\t\telif len(arrays) == 3:\n\t\t\treturn min(len(arrays[0]), min(len(arrays[1]), len(arrays[2])))\n\t\telse:\n\t\t\treturn min(find_smallest_range(arrays[0:len(arrays)/2]), find_smallest_range(arrays[len(arrays)/2:]))\n\n\treturn find_smallest_range(arrays)\n\nif __name__ == '__main__':\n\tarrays = [[1, 2, 3], [2, 3, 4], [4, 5, 6]]\n\tprint(smallest_range_with_at_least_one_element(arrays))",
    "def find_smallest_range(arrays):\n    smallest_range = []\n    for array in arrays:\n        if smallest_range == []:\n            smallest_range = [min(array), max(array)]\n        else:\n            smallest_range[0] = min(smallest_range[0], min(array))\n            smallest_range[1] = max(smallest_range[1], max(array))\n    return smallest_range\n\nif __name__ == \"__main__\":\n    arrays = [\n        [1,2,3],\n        [1,2,4],\n        [1,2,5],\n        [3,4,5],\n        [3,4,6],\n        [3,4,7],\n        [3,4,8],\n        [3,4,9],\n        [3,4,10],\n        [3,4,11],\n        [3,4,12],\n        [3,4,13],\n        [3,4,14],\n        [3,4,15],\n        [3,4,16],\n        [3,4,17],\n        [3,4,18],\n        [3,4,19],\n        [3,4,20],\n        [3,4,21],\n        [3,4,22],\n        [3,4,23],\n        [3,4,24],\n        [3,4,25],\n        [3,4,26],\n        [3,4,27],\n        [3,4,28],\n        [3,4,29],\n        [3,4,30],\n        [3,4,31],\n        [3,4,32],\n        [3,4,33],\n        [3,4,34],\n        [3,4,35],\n        [3,4,36],\n        [3,4,37],\n        [3,4,38],\n        [3,4,39],\n        [3,4,40],\n        [3,4,41],\n        [3,4,42],\n        [3,4,43],\n        [3,4,44",
    "def find_min_range(arrays):\n    min_range = None\n    for array in arrays:\n        if min_range is None:\n            min_range = array\n        elif array[0] < min_range[0]:\n            min_range = array\n    return min_range\n\n\nif __name__ == '__main__':\n    arrays = [[2, 4, 5, 7], [3, 6, 8, 10], [1, 9, 11, 12]]\n    min_range = find_min_range(arrays)\n    print(min_range)",
    "# Write your code here\n\n#Input:\n# [[1,2,3], [4,5], [6,7]]\n# [[1,2], [4,5], [7,8]]\n# [[1,2,3,4], [5,6], [7,8,9]]\n\ndef smallestRange(arrays):\n    # your code here\n    # return 0\n    pass",
    "from collections import Counter\n\n\ndef find_min_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    result = float(\"inf\")\n    for a in arrays:\n        result = min(result, min(a))\n    return result\n\n\nif __name__ == \"__main__\":\n    arrays = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    print(find_min_range(arrays))\n\n    arrays = [[0, 1], [2, 3], [4, 5]]\n    print(find_min_range(arrays))",
    "# https://discuss.leetcode.com/topic/102599/java-dp-solution-with-explanation/6\nclass Solution(object):\n    def findRange(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums1.sort(reverse=True)\n        nums2.sort(reverse=True)\n        m = len(nums1)\n        n = len(nums2)\n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0 and j == 0:\n                    return [0, m*n-1]\n                if i == 0:\n                    if j >= m:\n                        continue\n                    return [j*m+i, j*m+m-1]\n                if j == 0:\n                    if i >= n:\n                        continue\n                    return [i*m+j, i*m+n-1]\n                if nums1[i-1] >= nums2[j-1]:\n                    return [i*m+j, i*m+min(nums1[i-1], nums2[j-1])]\n                return [min(i*m+j, m*n-1), j*m+min(nums1[i-1], nums2[j-1])]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findRange([1,2,3,4,5,6], [1,2])\n    print s.findRange([2,3,4], [2,3,4])\n    print s.findRange([1,2,3,4], [4,5,6])",
    "# Your function should return the smallest range.\n\ndef smallestRange(arr1, arr2, arr3):\n\t# If we can find at least one element in each of the three arrays, return the smallest range that contains at least one element from each of the three arrays.\n\tif arr1 and arr2 and arr3:\n\t\treturn min(arr1), min(arr2), min(arr3)\n\telse:\n\t\treturn None\n\nif __name__ == '__main__':\n\tarr1 = [1, 2, 3, 4]\n\tarr2 = [3, 5, 6, 7]\n\tarr3 = [5, 6, 7, 8]\n\tprint(smallestRange(arr1, arr2, arr3))",
    "#!/usr/bin/env python\n\nfrom collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    def find_range_size(arrays):\n        if len(arrays) == 0:\n            return 0\n        max_size = defaultdict(int)\n        for array in arrays:\n            for element in array:\n                max_size[element] += 1\n        return max(max_size.values())\n\n    largest_range = find_range_size(arrays)\n    smallest_range = 0\n    for array in arrays:\n        if len(array) < smallest_range:\n            smallest_range = len(array)\n        elif len(array) == smallest_range:\n            smallest_range = find_range_size(array)\n    return smallest_range",
    "#!/bin/python\n\nimport sys\n\nif len(sys.argv) < 3:\n    print \"Usage:\", sys.argv[0], \"<num_arrays> <num_elements_per_array>\"\n    sys.exit(1)\n\nnum_arrays = int(sys.argv[1])\nnum_elements_per_array = int(sys.argv[2])\n\nfor i in range(num_arrays):\n    print \"array: \", i\n    print \"elements per array: \", num_elements_per_array\n    for j in range(num_elements_per_array):\n        print \"element: \", j\n\nprint \"smallest range: \", min(range(num_arrays))\nprint \"smallest range: \", min(range(num_arrays))",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not arrays:\n        return []\n\n    min_range = [sys.maxsize] * len(arrays[0])\n\n    for i in xrange(len(arrays)):\n        for j in xrange(len(arrays[0])):\n            if arrays[i][j] == 1:\n                if min_range[j] > i:\n                    min_range[j] = i\n    return min_range",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def threeSum(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        result = []\n        for i in xrange(len(nums1)):\n            for j in xrange(len(nums2)):\n                for k in xrange(len(nums3)):\n                    if nums1[i] + nums2[j] + nums3[k] <= 0:\n                        continue\n                    elif i < j and j < k:\n                        result.append([nums1[i], nums2[j], nums3[k]])\n                    elif i < j and j < k:\n                        result.append([nums1[i], nums2[j], nums3[k]])\n                    elif i < k and k < j:\n                        result.append([nums1[i], nums2[j], nums3[k]])\n                    elif i < k and k < j:\n                        result.append([nums1[i], nums2[j], nums3[k]])\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.threeSum([-1, 0, 1, 2, -1, -4], [-3, -1, 1, 4], [-2, 0, 1, 2])",
    "def find_smallest_range(arrays):\n    if not arrays:\n        return []\n    \n    # Check whether all the arrays have the same length.\n    lengths = [len(arr) for arr in arrays]\n    if len(set(lengths))!= 1:\n        return []\n\n    # Check whether all the arrays have the same length.\n    min_length = min(lengths)\n    max_length = max(lengths)\n    \n    # Check whether all the arrays have the same length.\n    if min_length!= max_length:\n        return []\n    \n    # Find the smallest range that includes at least one element from each of the given arrays.\n    return [min(arr) for arr in arrays if len(arr) > 0]",
    "def smallest_range_of_all_arrays(arrays):\n    if not arrays:\n        return 0\n\n    min_arrays = [arrays[0]]\n    for arr in arrays[1:]:\n        min_arrays = [min(arr, min_arrays) for arr in min_arrays]\n    return min(min_arrays)\n\nif __name__ == \"__main__\":\n    arrays = [range(1, 5), range(6, 11)]\n    print(smallest_range_of_all_arrays(arrays))",
    "class Solution(object):\n    def minRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        nums3 = sorted(nums3)\n        nums4 = sorted(nums4)\n\n        m = len(nums1)\n        n = len(nums2)\n        k = len(nums3)\n        l = len(nums4)\n\n        if m + n + k + l == 0:\n            return 0\n\n        if m == 0 and n == 0 and k == 0 and l == 0:\n            return max(nums1 + nums2 + nums3 + nums4)\n\n        if m == 0 and n == 0 and k == 0:\n            return min(nums1 + nums2 + nums3 + nums4)\n\n        if m == 0:\n            return min(nums1 + nums2 + nums3 + nums4)\n\n        if n == 0:\n            return max(nums1 + nums2 + nums3 + nums4)\n\n        if k == 0:\n            return min(nums1 + nums2 + nums3 + nums4)\n\n        if l == 0:\n            return max(nums1 + nums2 + nums3 + nums4)\n\n        min_range = nums1[0]\n        max_range = nums1[0]\n\n        for i in range(1, m + 1):\n            if nums1[i] < min_range:\n                min_range = nums1[i]\n            elif nums1[i] > max_range:\n                max_range = nums1[i]\n\n        for j in range(1, n + 1):\n            if nums2[j] < min_range:\n                min_range = nums2[j",
    "class Solution(object):\n    def findRange(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # O(n)\n        nums1.sort()\n        nums2.sort()\n        if len(nums1) == 0 or len(nums2) == 0:\n            return []\n        \n        n1 = nums1[0]\n        n2 = nums2[0]\n        min_range = [n1, n2]\n        for i in range(1, len(nums1)):\n            if nums1[i] == n1:\n                n1 = nums1[i]\n            else:\n                n1 = nums1[i]\n                min_range.append(n1)\n        for j in range(1, len(nums2)):\n            if nums2[j] == n2:\n                n2 = nums2[j]\n            else:\n                n2 = nums2[j]\n                min_range.append(n2)\n        return min_range",
    "def find_smallest_range(arr1, arr2, arr3):\n\t\n\tif len(arr1) == 0 or len(arr2) == 0 or len(arr3) == 0:\n\t\treturn -1\n\n\tmin_range = 0\n\tfor i in range(1, len(arr1)+1):\n\t\tfor j in range(1, len(arr2)+1):\n\t\t\tfor k in range(1, len(arr3)+1):\n\t\t\t\tif min_range == 0:\n\t\t\t\t\tmin_range = i*j*k\n\t\t\t\telse:\n\t\t\t\t\tif i*j*k < min_range:\n\t\t\t\t\t\tmin_range = i*j*k\n\treturn min_range\n\n\nprint find_smallest_range([0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5])",
    "def find_smallest_range(arrays):\n    if len(arrays) == 0:\n        return\n\n    min_range = arr[0]\n    for arr_ in arrays:\n        if min_range < arr_:\n            min_range = arr_\n    return min_range\n\n\n\narr = [1, 2, 3, 4, 5, 6]\narr_ = [1, 2, 3, 5, 6]\narr_ = [1, 2, 3, 5, 6, 7]\narr_ = [1, 2, 3, 5, 6, 7, 8]\n\nprint(find_smallest_range(arr))\nprint(find_smallest_range(arr_))\nprint(find_smallest_range(arr_))",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not arrays:\n        return []\n\n    min_range = [max(a) for a in arrays]\n    for i in range(1, len(min_range)):\n        for j in range(i):\n            if min_range[i] > min_range[j]:\n                min_range[i] = min(min_range[i], min_range[j])\n    return min_range\n\n\nif __name__ == \"__main__\":\n    print(find_smallest_range([[1, 2, 3], [1, 2], [1, 2, 3, 4]]))\n    print(find_smallest_range([[1, 2, 3], [1, 2], [1, 2, 3, 4]]))\n    print(find_smallest_range([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4, 5]]))\n    print(find_smallest_range([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4, 5]]))\n    print(find_smallest_range([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4, 5]]))\n    print(find_smallest_range([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4, 5]]))",
    "# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-of-the-given-arrays/description/\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        return min(nums1[0], min(nums2[0], min(nums3[0], nums4[0])))",
    "import collections\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    min_range = collections.defaultdict(list)\n    for arr in arrays:\n        for num in arr:\n            min_range[num].append(arr)\n    return min(min_range.keys())",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getSmallestRange(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums1) == 0:\n            return len(nums2)\n        if len(nums2) == 0:\n            return len(nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                return min(i - j, j - i)\n        \n        return min(i - j, j - i)\n        \n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    print(sol.getSmallestRange(nums1, nums2))\n    nums1 = [1, 2, 3, 4]\n    nums2 = [5, 6, 7]\n    print(sol.getSmallestRange(nums1, nums2))\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6, 7]\n    print(sol.getSmallestRange(nums1, nums2))\n    nums1 = [1, 2, 3, 4, 5, 6, 7]\n    nums2 = [8, 9, 10, 11]\n    print(sol.getSmallestRange(nums1, nums2))",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def threeSum(self, nums1, nums2, nums3):\n        if len(nums1) < 3 or len(nums2) < 3 or len(nums3) < 3:\n            return []\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        result = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    if i + j + k > len(nums1) or i + j + k > len(nums2) or i + j + k > len(nums3):\n                        break\n                    if nums1[i] + nums2[j] + nums3[k] == 0:\n                        if result and result[-1][0] > i + j + k:\n                            result[-1][0] = i + j + k\n                        else:\n                            result.append([i + j + k, i, j, k])\n        return result\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 0, -1]\n    nums2 = [0, 1, -1]\n    nums3 = [1, 1, -1]\n    print(Solution().threeSum(nums1, nums2, nums3))",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def threeSum(self, nums):\n        nums.sort()\n        nums2 = []\n        for i in range(len(nums)-2):\n            if i == 0 or nums[i]!= nums[i-1]:\n                nums2.append(nums[i])\n            for j in range(i+1, len(nums)-1):\n                if j == i or nums[j]!= nums[j-1]:\n                    nums2.append(nums[j])\n                if j+1 == len(nums)-1 or nums[j+1]!= nums[j]:\n                    nums2.append(nums[j+1])\n        return [nums[i] for i in range(len(nums)) if nums[i] in nums2]\n\ns = Solution()\nprint(s.threeSum([1,2,3,4,5,6,7,8,9]))\nprint(s.threeSum([1,2,4,5,6,7,8,9,10]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11,12]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11,12,13]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11,12,13,14]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]))\nprint(s.threeSum([1,2,3,4,5,6,7,8,9,10,11,12,13",
    "# @include\ndef find_smallest_range(arrays: list[list[int]]) -> list[list[int]]:\n  # Create a mapping from each array to its smallest range.\n  mapping = {}\n  for arr in arrays:\n    if arr in mapping:\n      mapping[arr] = min(mapping[arr], arr)\n    else:\n      mapping[arr] = arr\n  # The smallest range is the smallest range that includes at least one element from each of the given arrays.\n  return sorted(mapping.values())[0]\n# @exclude\n\n\ndef main():\n    # print(find_smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    print(find_smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]]))\n    print(find_smallest_range([[1, 2, 3], [3, 4, 5], [1, 2, 3]]))\n    print(find_smallest_range([[1, 2], [2, 3], [3, 4]]))\n\n\nif __name__ == '__main__':\n    main()",
    "#!/usr/bin/python\n\nclass Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def threeSum(self, nums):\n        nums.sort()\n        n = len(nums)\n        if n < 3:\n            return []\n        i = 0\n        while i < n - 2:\n            j = i + 1\n            while j < n - 1:\n                if nums[i] + nums[j] + nums[j + 1] <= 0:\n                    break\n                if nums[i] + nums[j] + nums[j + 1] > 0:\n                    print(\"%d %d %d\" % (nums[i], nums[j], nums[j + 1]))\n                    return [nums[i], nums[j], nums[j + 1]]\n                j += 1\n            i += 1\n        return []\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums1 = [2, -3, 4, -1, -4]\n    nums2 = [4, -2, 4, -2, -2]\n    nums3 = [1, 2, 3, 4, 5, 6]\n    print solution.threeSum(nums1)\n    print solution.threeSum(nums2)\n    print solution.threeSum(nums3)",
    "from collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    arrays = defaultdict(list)\n    for a in arrays:\n        arrays[a].append(len(a))\n\n    for a in arrays:\n        arrays[a].sort()\n\n    min_range = 0\n    for a in arrays:\n        min_range = min(min_range, len(a))\n    return min_range\n\n\nif __name__ == '__main__':\n    print(find_smallest_range([[1,2],[3,4]]))\n    print(find_smallest_range([[1,2],[3,5]]))\n    print(find_smallest_range([[1,2],[3,5]]))\n    print(find_smallest_range([[1,2],[3,4]]))\n    print(find_smallest_range([[1,2],[3,4]]))",
    "def smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not arrays:\n        return 0\n\n    min_index = 0\n    min_size = len(arrays[0])\n\n    for i in range(1, len(arrays)):\n        if len(arrays[i]) < min_size:\n            min_index = i\n            min_size = len(arrays[i])\n\n    return min_size\n\n# Time:  O(n)\n# Space: O(n)\n# DP solution\n# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-array/discuss/223937/DP-solution-with-explanation\n# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-array/discuss/223937/DP-solution-with-explanation\n# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-array/discuss/223937/DP-solution-with-explanation\n# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-array/discuss/223937/DP-solution-with-explanation\nclass Solution(object):\n    def smallestRange(self, arrays):\n        \"\"\"\n        :type arrays: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not arrays:\n            return 0\n\n        # DP solution\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] for k in range(i + 1, len(arrays)))\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[j][k] for k in range(i + 1, len(arrays)))\n        # dp[i][j]",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def smallestRange(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> int:\n        if len(nums1) == 0 or len(nums2) == 0 or len(nums3) == 0:\n            return -1\n        \n        # find the minimum range of at least one element from each list\n        min1 = min(nums1)\n        min2 = min(nums2)\n        min3 = min(nums3)\n        \n        # find the maximum range\n        max1 = max(nums1)\n        max2 = max(nums2)\n        max3 = max(nums3)\n        \n        # find the range of the smallest element in each list\n        min_range = min(min1, min2, min3)\n        max_range = max(max1, max2, max3)\n        \n        return min_range + max_range",
    "# https://www.hackerrank.com/challenges/smallest-range\n\ndef smallestRange(arr1, arr2, arr3):\n    \"\"\"\n    :type arr1: List[int]\n    :type arr2: List[int]\n    :type arr3: List[int]\n    :rtype: int\n    \"\"\"\n    # First, find the smallest range that includes at-least one element from all three.\n    # We'll use the largest range that includes at-least one element from all three.\n    # We'll use the largest range that includes at-least one element from arr1.\n    # We'll use the largest range that includes at-least one element from arr2.\n    # We'll use the largest range that includes at-least one element from arr3.\n\n    # If the largest range is already smaller than the smallest range, return it.\n    if max(arr1) < max(arr2) < max(arr3):\n        return max(arr1)\n\n    # Otherwise, find the smallest range that includes at-least one element from all three.\n    # We'll use the largest range that includes at-least one element from arr1.\n    # We'll use the largest range that includes at-least one element from arr2.\n    # We'll use the largest range that includes at-least one element from arr3.\n\n    # If the largest range is already smaller than the smallest range, return it.\n    if max(arr1) < max(arr2) < max(arr3):\n        return max(arr1)\n\n    # Otherwise, find the smallest range that includes at-least one element from all three.\n    # We'll use the largest range that includes at-least one element from arr1.\n    # We'll use the largest range that includes at-least one element from arr2.\n    # We'll use the largest range that includes at-least one element from arr3.\n\n    # If the largest range is already smaller than the smallest range, return it.\n    if max(arr1) < max(arr2) < max(arr3):\n        return max(arr1)\n\n    # Otherwise, find the smallest range that includes at-least one element from all three.",
    "from collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    n = len(arrays)\n    d = defaultdict(list)\n    for i in range(n):\n        for j in range(i+1, n):\n            d[arrays[i][0]].append(arrays[j][0])\n    for i in range(n):\n        if len(d[arrays[i][0]]) == 0:\n            return [0] * n\n        else:\n            return [min(d[arrays[i][0]])]",
    "# https://oj.leetcode.com/problems/smallest-range/\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def __str__(self):\n        return str(self.start) +'' + str(self.end)\n\n    def __repr__(self):\n        return self.__str__()\n\nclass Solution:\n    # @param intervals: A list of Interval\n    # @return: The smallest range\n    def smallestRange(self, intervals):\n        if not intervals:\n            return 0\n        s = intervals[0].start\n        e = intervals[0].end\n        for i in xrange(1, len(intervals)):\n            if intervals[i].start < s:\n                s = intervals[i].start\n            if intervals[i].end > e:\n                e = intervals[i].end\n        return e - s",
    "# https://www.hackerrank.com/challenges/smallest-range\n\ndef smallest_range(arr1, arr2, arr3):\n    # Write your code here\n    if len(arr1) == 0 or len(arr2) == 0 or len(arr3) == 0:\n        return 0\n    min_range = min(arr1[0], arr2[0], arr3[0])\n    for i in range(1, len(arr1)):\n        if arr1[i] < min_range:\n            min_range = arr1[i]\n        if arr2[i] < min_range:\n            min_range = arr2[i]\n        if arr3[i] < min_range:\n            min_range = arr3[i]\n    return min_range\n\nif __name__ == \"__main__\":\n    arr1 = [1,2,3,4,5,6,7,8,9]\n    arr2 = [1,2,3,4,5,6,7,8,9]\n    arr3 = [1,2,3,4,5,6,7,8,9]\n    print smallest_range(arr1, arr2, arr3)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def smallestRange(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums1 or not nums2 or not nums3 or not nums4:\n            return 0\n\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n\n        left = 0\n        right = 0\n        for i in range(len(nums1)):\n            if nums1[i] >= nums3[left]:\n                left += 1\n            if nums1[i] >= nums4[right]:\n                right += 1\n\n        return left + right",
    "def smallest_range(arrays):\n\t\n\tif len(arrays) == 0:\n\t\treturn 0\n\n\tmin_range = None\n\tfor i in range(len(arrays)):\n\t\tmin_range = min(min_range, len(arrays[i]))\n\n\tfor i in range(len(arrays)):\n\t\tfor j in range(min_range, len(arrays[i])):\n\t\t\tif arrays[i][j] == True:\n\t\t\t\treturn min_range\n\n\treturn min_range\n\n\n\nif __name__ == \"__main__\":\n\n\tarrays = [[1,2,3],[1,2,3]]\n\tprint(smallest_range(arrays))\n\tarrays = [[1,2,3],[1,2]]\n\tprint(smallest_range(arrays))\n\tarrays = [[1,2,3],[2,3,4]]\n\tprint(smallest_range(arrays))\n\tarrays = [[1,2,3],[4,5,6]]\n\tprint(smallest_range(arrays))",
    "from math import ceil\n\ndef find_min_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not arrays:\n        return 0\n    if len(arrays) == 1:\n        return len(arrays[0])\n    min_range = min(map(len, arrays))\n    for i in range(min_range):\n        for j in range(i, min_range):\n            if all(arrays[i][j] == arr for arr in arrays):\n                return j\n    return min_range\n\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        return find_min_range([nums1, nums2, nums3, nums4])\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.smallestRange([0, 1, 0, 1], [1, 0, 1, 1], [1, 0, 0, 0], [1, 0, 1, 0])",
    "from typing import List\n\nfrom collections import Counter\nfrom itertools import accumulate, islice\n\nclass Solution:\n    def smallestRange(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> int:\n        nums1 = list(nums1)\n        nums2 = list(nums2)\n        nums3 = list(nums3)\n        return min(self.smallestRangeHelper(nums1, nums2, nums3))\n\n    def smallestRangeHelper(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> int:\n        if not nums1:\n            return 0\n\n        n1 = sum(nums1)\n        n2 = sum(nums2)\n        n3 = sum(nums3)\n\n        if n1 > n2 and n1 > n3:\n            return n1\n        elif n2 > n1 and n2 > n3:\n            return n2\n        elif n3 > n1 and n3 > n2:\n            return n3\n        else:\n            return n1\n\n\nif __name__ == '__main__':\n    assert Solution().smallestRange([1,2,3,4], [1,2,3], [1,2,3,4]) == 3\n    assert Solution().smallestRange([1,2,3,4], [1,2,3], [2,3,4]) == 3\n    assert Solution().smallestRange([1,2,3,4], [1,2,3], [3,4]) == 3\n    assert Solution().smallestRange([1,2,3,4], [1,2,3], [2,3,4,5]) == 3\n    assert Solution().smallestRange([1,2,3], [1,2,3], [1,2,3,4]) == 3\n    assert Solution().smallestRange([1,2,3], [1,2,3], [1,2,3,4]) == 3\n    assert Solution().smallestRange([1,2,3], [1,2,3], [1,2",
    "# https://oj.leetcode.com/problems/range-sum-query-immutable/\n\n# Trie\nclass TrieNode:\n    def __init__(self):\n        self.val = 0\n        self.childs = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        self.root.val = -1\n        self.root.childs = {}\n\n    def insert(self, word):\n        node = self.root\n        for letter in word:\n            if letter not in node.childs:\n                node.childs[letter] = TrieNode()\n            node = node.childs[letter]\n        node.val += 1\n\n    def search(self, word):\n        node = self.root\n        for letter in word:\n            if letter not in node.childs:\n                return False\n            node = node.childs[letter]\n        return node.val!= -1\n\n    def query(self, word):\n        node = self.root\n        for letter in word:\n            if letter not in node.childs:\n                return False\n            node = node.childs[letter]\n        return node.val!= -1\n\n    def update(self, word, val):\n        node = self.root\n        for letter in word:\n            if letter not in node.childs:\n                return False\n            node = node.childs[letter]\n        node.val = val\n        return True\n\n# A*\nclass Solution:\n    # @param {string[]} words\n    # @param {string} word\n    # @return {integer}\n    def minDistance(self, words, word):\n        if not words or not word:\n            return len(words)\n        if len(word) == 0:\n            return 0\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        node = trie.root\n        d = [len(word)]\n        for i in range(len(word)):\n            if node.childs.has_key(word[i]):\n                node = node.childs[word[i]]\n            else",
    "from typing import List\n\ndef find_smallest_range(arrays: List[List[int]]) -> List[int]:\n    def min_range(arr: List[int]) -> int:\n        \"\"\"\n        Find the smallest range in the given array.\n        :param arr: An array.\n        :return: The smallest range in the array.\n        \"\"\"\n        return min(arr) if arr else 0\n\n    min_ranges = [min_range(arr) for arr in arrays]\n    return min(min_ranges) if min_ranges else 0",
    "from collections import defaultdict\nfrom functools import reduce\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # dp[i][j] stores the smallest range that includes at least one element from arr[i] and arr[j]\n    dp = [[sys.maxsize for _ in range(len(arrays))] for _ in range(len(arrays))]\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i])):\n            if arrays[i][j]!= -1:\n                dp[i][j] = 1\n    return dp[0][0]\n\ndef find_smallest_range_2(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # dp[i][j] stores the smallest range that includes at least one element from arr[i] and arr[j]\n    dp = [[sys.maxsize for _ in range(len(arrays))] for _ in range(len(arrays))]\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i])):\n            if arrays[i][j]!= -1:\n                dp[i][j] = 1\n    return dp[0][0]\n\ndef find_smallest_range_3(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # dp[i][j] stores the smallest range that includes at least one element from arr[i] and arr[j]\n    dp = [[sys.maxsize for _ in range(len(arrays))] for _ in range(len(arrays))]\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i])):\n            if arrays[i][j]!= -1:\n                dp[i][j] = 1\n    return dp[0][0]\n\ndef find_small",
    "class Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    for l in range(len(nums4)):\n                        if nums1[i] <= nums2[j] and nums2[j] <= nums3[k] and nums3[k] <= nums4[l] and nums4[l] <= nums1[i]:\n                            return min(nums1[i], nums2[j], nums3[k], nums4[l])\n        return 0",
    "def find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not arrays:\n        return []\n\n    smallest = [0] * len(arrays)\n    for i in range(len(arrays)):\n        for j in range(i + 1, len(arrays)):\n            if arrays[i][0] <= arrays[j][0]:\n                smallest[i] = max(smallest[i], arrays[i][1] + arrays[j][1])\n                smallest[j] = max(smallest[j], arrays[i][1] + arrays[j][1])\n    return smallest\n\nif __name__ == '__main__':\n    arrays = [[1, 3], [2, 4], [1, 2], [5, 6]]\n    print(find_smallest_range(arrays))",
    "# https://discuss.leetcode.com/topic/14084/java-solution-with-explanation\n\nclass Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @return an integer\n    def smallestRange(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i][j] means the smallest range from nums1[i] to nums2[j]\n        dp = [[0] * len(nums2) for _ in range(len(nums1))]\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] <= nums2[j]:\n                    dp[i][j] = 1 + dp[i][j - 1]\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return min(dp[-1])\n\n\nif __name__ == \"__main__\":\n    print(Solution().smallestRange([1, 2, 3], [2, 4, 5]))",
    "# Your function should return the smallest range.\n\n# For example:\n# Input: [1,2,3]\n# Input: [1,2]\n# Output: [1,2]\n# Input: [1,2,3,4,5]\n# Input: [1,2,3,4]\n# Output: [1,2]\n# Input: [4,5,6,7,8,9]\n# Input: [4,5,6,7]\n# Output: [4,5]\n# Input: [1,2,3,4,5,6,7,8,9]\n# Input: [1,2,3,4,5,6,7,8,9]\n# Output: [1,2,3,4,5,6]\n# Input: [1,2,3,4,5,6,7,8,9,10,11,12]\n# Input: [1,2,3,4,5,6,7,8,9,10,11]\n# Output: [1,2,3,4,5,6,7,8,9]\n\ndef find_smallest_range(arrays):\n    min_range = None\n    for array in arrays:\n        if min_range is None:\n            min_range = array\n        else:\n            if min_range > array:\n                min_range = array\n    return min_range\n\n# Your function should return a list of ranges, each range is [start,end]\n# The start and end indices should be inclusive,\n# that is, [0,10] and [5,15] is valid, but not [1,4] or [9,15].\n# Note: If there are multiple answers, you should return the smallest one.\n# Example:\n# Input: [[1,3],[2,6]]\n# Output: [[1,3],[2,6]]\n# Input: [[1,3],[5,7]]\n# Output: [[1,3],[5,7]]\n# Input: [[1,3],[5,7],[9,11]]\n# Output: [[1,3],[5,7]]\n# Input: [[1,3],[5,7],[9",
    "import numpy as np\nimport time\n\ndef smallest_range_in_arrays(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    start = np.inf\n    end = -np.inf\n    for array in arrays:\n        start = min(start, min(array))\n        end = max(end, max(array))\n    return [start, end]\n\n\nif __name__ == \"__main__\":\n    print(smallest_range_in_arrays([[1,2,3], [3,4,5], [6,7,8]]))\n    print(smallest_range_in_arrays([[1,2], [3,4], [5,6]]))\n    print(smallest_range_in_arrays([[1,2,3], [2,3,4], [2,3,5], [2,3,6]]))\n    print(smallest_range_in_arrays([[1,2], [3,4], [5,6], [7,8]]))",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fileencoding=utf-8\n\nfrom collections import defaultdict\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: list[list[int]]\n    :rtype: list[int]\n    \"\"\"\n    if not arrays:\n        return []\n    \n    num_elements = defaultdict(int)\n    for arr in arrays:\n        for num in arr:\n            num_elements[num] += 1\n    \n    smallest_ranges = []\n    for num, num_elements in num_elements.items():\n        if num_elements >= 2:\n            smallest_ranges.append(num)\n    return smallest_ranges\n\nif __name__ == '__main__':\n    #print(find_smallest_range([[1, 2, 3], [1, 2, 4], [1, 2, 5]]))\n    print(find_smallest_range([[1, 2, 3], [1, 2, 4], [1, 2, 5]]))\n    print(find_smallest_range([[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 6]]))\n    print(find_smallest_range([[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 6], [1, 2, 7]]))",
    "#!/usr/bin/env python\n\nfrom __future__ import print_function\n\nimport numpy as np\n\ndef find_smallest_range(arrays, min_len=2):\n    \"\"\"\n    Find the smallest range that includes at-least one element from each of the given arrays.\n    :param arrays: list of arrays\n    :param min_len: the smallest range that should be found\n    :return: smallest range that contains at least one element from each of the given arrays\n    \"\"\"\n\n    # initialize all elements to None\n    all_elements = [None for _ in range(len(arrays))]\n\n    # iterate over all elements in all arrays\n    for i in range(len(arrays)):\n\n        # iterate over all elements in the current array\n        for j in range(len(arrays[i])):\n\n            # check if the current element is already in the list\n            if all_elements[i] is not None and all_elements[i] is not arrays[i][j]:\n                # if not, add it to the list\n                all_elements[i] = arrays[i][j]\n\n    # check if the smallest range is at least min_len long\n    if len(all_elements) >= min_len:\n        return all_elements\n\n    # else return None\n    return None\n\nif __name__ == '__main__':\n\n    # create a list of random arrays\n    random_arrays = []\n    for i in range(10):\n        random_arrays.append(np.random.randint(1, 100, size=1000))\n\n    # find the smallest range that contains at least one element from each of the random arrays\n    random_smallest_range = find_smallest_range(random_arrays)\n\n    # print the smallest range\n    print(\"The smallest range is:\", random_smallest_range)\n\n    # find the smallest range that contains at least one element from each of the given arrays\n    smallest_range = find_smallest_range(random_arrays, min_len=5)\n\n    # print the smallest range\n    print(\"The smallest range is:\", smallest_range)",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer[]}\n    def smallestRange(self, nums1, nums2, nums3):\n        if not nums1 or not nums2 or not nums3:\n            return [0, 0]\n        n1 = len(nums1)\n        n2 = len(nums2)\n        n3 = len(nums3)\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        n1 = len(nums1)\n        n2 = len(nums2)\n        n3 = len(nums3)\n        i = 0\n        while i < n1:\n            j = i + 1\n            while j < n1 and nums1[i] == nums1[j]:\n                j += 1\n            if j - i > 1:\n                return [i, j]\n            i += 1\n        i = 0\n        while i < n2:\n            j = i + 1\n            while j < n2 and nums2[i] == nums2[j]:\n                j += 1\n            if j - i > 1:\n                return [0, j]\n            i += 1\n        i = 0\n        while i < n3:\n            j = i + 1\n            while j < n3 and nums3[i] == nums3[j]:\n                j += 1\n            if j - i > 1:\n                return [0, j]\n            i += 1\n        return [0, 0]\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.smallestRange([1, 2, 3], [2, 3, 4], [1, 2, 3])\n    print solution.smallestRange([1, 2, 3], [2, 3, 4], [1, 2, 3, 4])\n    print solution.smallestRange([1, 2, 3], [2, 3, 4], [1, 2, 3, 5])\n    print solution.",
    "import unittest\n\n\nclass TestSolution(unittest.TestCase):\n\n    def test_smallest_range(self):\n        self.assertEqual(smallest_range([1, 2, 3, 4, 5, 6]), [1, 2, 3])\n        self.assertEqual(smallest_range([1, 2, 3, 4, 5, 6, 7]), [1, 2, 3, 4, 5])\n        self.assertEqual(smallest_range([1, 2, 3, 4, 5, 6, 7, 8, 9]), [1, 2, 3, 4, 5, 6, 7])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "import math\n\n\ndef find_smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # for each array, find the smallest range that includes at least one element from each of the array\n    # and return the smallest range\n    if len(arrays) == 0:\n        return 0\n\n    # for each array, find the smallest range that includes at least one element from each of the array\n    # and return the smallest range\n    min_range = float(\"inf\")\n    for array in arrays:\n        min_range = min(min_range, min_range_from_array(array))\n\n    return min_range\n\n\ndef min_range_from_array(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: int\n    \"\"\"\n    # for each element in the array, find the smallest range that includes this element\n    if len(array) == 0:\n        return 0\n    min_range = float(\"inf\")\n    for i in range(len(array)):\n        min_range = min(min_range, min_range_from_element(array[i]))\n    return min_range\n\n\ndef min_range_from_element(element):\n    \"\"\"\n    :type element: int\n    :rtype: int\n    \"\"\"\n    return int(math.ceil(element))\n\n\nif __name__ == \"__main__\":\n    print(find_smallest_range([[1, 2, 3], [1, 2, 3]]))\n    print(find_smallest_range([[1, 2], [2, 3, 4], [1, 2, 3]]))\n    print(find_smallest_range([[1, 2, 3, 4, 5], [1, 2, 3], [1, 2, 3]]))",
    "#!/usr/bin/python\n\ndef find_min_range(arr1, arr2, arr3):\n    \"\"\"\n    Find the smallest range that includes at-least one element from each of the given arrays.\n    Input:\n        arr1:  an array\n        arr2:  an array\n        arr3:  an array\n    Output:\n        a tuple (start, end), where start <= end.\n    \"\"\"\n    # a range is of the form (start, end)\n    range1 = range(min(arr1), max(arr1) + 1)\n    range2 = range(min(arr2), max(arr2) + 1)\n    range3 = range(min(arr3), max(arr3) + 1)\n\n    # find the smallest range that includes at least one element from each of the ranges\n    for i in range(len(range1)):\n        for j in range(len(range2)):\n            for k in range(len(range3)):\n                if (range1[i] <= range2[j] and range1[i] <= range3[k] and range2[j] <= range3[k]):\n                    return (range1[i], range3[k])\n    return (0, 0)\n\n# Test Cases\n\n# arr1 = [1, 2, 3, 4]\n# arr2 = [10, 20, 30]\n# arr3 = [100, 200]\n# print find_min_range(arr1, arr2, arr3)\n\n# arr1 = [0, 1, 2, 3]\n# arr2 = [0, 1, 2, 3]\n# arr3 = [0, 1, 2, 3]\n# print find_min_range(arr1, arr2, arr3)\n\n# arr1 = [0, 1, 2, 3, 4, 5]\n# arr2 = [0, 1, 2, 3, 4, 5]\n# arr3 = [0, 1, 2, 3, 4, 5]\n# print find_min_range(arr1, arr2, arr3)\n\n# arr1 = [1, 2, 3]\n# arr2 = [1, 2, 3]",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findRange(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        if not intervals:\n            return []\n        result = [None, None]\n        for interval in intervals:\n            if result[0]:\n                if interval.start <= result[0][1]:\n                    continue\n                else:\n                    result[0] = interval\n            if result[1]:\n                if interval.end <= result[1][0]:\n                    continue\n                else:\n                    result[1] = interval\n        return [result[0][1], result[1][0]]",
    "import time\n\nstart_time = time.time()\n\ndef find_smallest(arrays):\n    min_range = [1] * len(arrays)\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i])):\n            if arrays[i][j] == 1:\n                for k in range(i+1, len(arrays)):\n                    if arrays[k][j] == 0:\n                        min_range[i] = min(min_range[i], min_range[k]+1)\n                        break\n    return min_range\n\nprint(find_smallest([[0,0,0],[0,1,1],[0,0,0]]))\n\nprint(time.time() - start_time)",
    "# https://leetcode.com/problems/smallest-range-with-at-least-one-element-in-each-array/\n# \n# For example, given nums1 = [1, 2, 2, 1], nums2 = [2, 2], nums3 = [1, 1, 1], return 3.\n# \n# Note:\n# \n# All arrays will have a positive length.\n# Each element in the given array will be an integer in the range [0, 99].\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        \n        dic = defaultdict(int)\n        for i in range(len(nums1)):\n            dic[nums1[i]] += 1\n        for i in range(len(nums2)):\n            dic[nums2[i]] += 1\n        for i in range(len(nums3)):\n            dic[nums3[i]] += 1\n        \n        min_range = 99\n        for i in range(len(dic)):\n            if dic[i] == 1:\n                min_range = min(min_range, i)\n        return min_range\n        \n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.smallestRange([1,2,2,1], [2,2], [1,1,1]))",
    "import sys\n\ndef smallest_range(arr1, arr2, arr3):\n    if not arr1 or not arr2 or not arr3:\n        return 0\n\n    min_range = sys.maxint\n    for i in range(len(arr1)):\n        min_range = min(min_range, min(arr1[i], min(arr2[i], arr3[i])))\n    return min_range\n\nif __name__ == '__main__':\n    arr1 = [2, 4, 5]\n    arr2 = [1, 3, 5]\n    arr3 = [1, 4, 6]\n    print smallest_range(arr1, arr2, arr3)",
    "class Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def smallest_range(nums1, nums2, nums3, nums4):\n            if nums1 and nums2 and nums3 and nums4:\n                return min(nums1), max(nums2), min(nums3), max(nums4)\n            else:\n                return None\n\n        return smallest_range(nums1, nums2, nums3, nums4)\n\n\nif __name__ == '__main__':\n    assert Solution().smallestRange([2, 3, 1], [3, 2, 3], [1, 2, 3], [1, 1, 1]) == [1, 3, 1]",
    "def smallest_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    if not arrays:\n        return 0\n\n    min_range = float('inf')\n    for i in range(len(arrays)):\n        for j in range(len(arrays[i])):\n            if arrays[i][j] < min_range:\n                min_range = arrays[i][j]\n\n    return min_range",
    "def find_min_range(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    min_range = [0] * len(arrays)\n    for i in range(len(arrays)):\n        for j in range(len(arrays[0])):\n            if arrays[i][j] > min_range[i]:\n                min_range[i] = arrays[i][j]\n    return min_range",
    "# https://oj.leetcode.com/problems/smallest-range-containing-a-given-set-of-integers/\n\nclass Solution:\n    # @return an integer\n    def smallestRange(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        i = 0\n        j = 0\n        k = 0\n        res = 0\n        while i < len(nums1) and j < len(nums2) and k < len(nums3):\n            if nums1[i] <= nums2[j] and nums1[i] <= nums3[k]:\n                res = max(res, i-k)\n                k += 1\n            elif nums2[j] <= nums1[i] and nums2[j] <= nums3[k]:\n                res = max(res, j-k)\n                j += 1\n            else:\n                k += 1\n            i += 1\n            j += 1\n        return res",
    "# https://leetcode.com/problems/smallest-range/\n\nclass Solution(object):\n    def smallestRange(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        # print nums1\n        # print nums2\n        # print nums3\n        # print nums4\n        # print nums1.index(nums2[0])\n        # print nums2.index(nums3[0])\n        # print nums3.index(nums4[0])\n        # print nums4.index(nums1[0])\n        # print nums1.index(nums2[0])\n        # print nums2.index(nums3[0])\n        # print nums3.index(nums4[0])\n        # print nums4.index(nums1[0])\n        # print nums1.index(nums2[0])\n        # print nums2.index(nums3[0])\n        # print nums3.index(nums4[0])\n        # print nums4.index(nums1[0])\n        # print nums1.index(nums2[0])\n        # print nums2.index(nums3[0])\n        # print nums3.index(nums4[0])\n        # print nums4.index(nums1[0])\n        # print nums1.index(nums2[0])\n        # print nums2.index(nums3[0])\n        # print nums3.index(nums4[0])\n        # print nums4.index(nums1[0])\n        # print nums1.index(nums2[0])\n        # print nums",
    "# https://oj.leetcode.com/problems/merge-two-sorted-arrays/\n\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def merge(self, intervals):\n        if not intervals:\n            return []\n\n        if len(intervals) == 1:\n            return intervals\n\n        result = []\n        i = 0\n        while i < len(intervals):\n            if intervals[i].end < intervals[i+1].start:\n                result.append(intervals[i])\n                i += 1\n            else:\n                result.append(Interval(min(intervals[i].start, intervals[i+1].start), max(intervals[i].end, intervals[i+1].end)))\n                i += 2\n        return result\n\n\nif __name__ == '__main__':\n    intervals = [Interval(0, 2), Interval(3, 5), Interval(6, 8)]\n    print Solution().merge(intervals)",
    "def find_smallest_range(arrays):\n\tif len(arrays) == 0:\n\t\treturn [0, 0]\n\n\tsmallest_range = [max(arrays[0][0], arrays[1][0]), max(arrays[0][1], arrays[1][1])]\n\n\tfor i in range(2, len(arrays)):\n\t\tsmallest_range[0] = min(smallest_range[0], arrays[i][0])\n\t\tsmallest_range[1] = min(smallest_range[1], arrays[i][1])\n\n\treturn smallest_range\n\n\n# These \"asserts\" using only for self-checking and not necessary for auto-testing\nif __name__ == \"__main__\":\n\tassert find_smallest_range([[1, 4], [3, 6]]) == [1, 3]\n\tassert find_smallest_range([[1, 5], [3, 6]]) == [1, 3]\n\tassert find_smallest_range([[1, 5], [4, 6]]) == [1, 4]\n\tassert find_smallest_range([[1, 6], [4, 5]]) == [1, 4]\n\tassert find_smallest_range([[1, 5], [4, 6], [2, 5], [3, 6]]) == [1, 4]\n\tassert find_smallest_range([[1, 4], [3, 6], [2, 5], [4, 6]]) == [1, 4]\n\tassert find_smallest_range([[1, 6], [3, 6], [2, 5], [4, 6]]) == [1, 4]\n\tassert find_smallest_range([[1, 6], [3, 6], [2, 5], [4, 6], [5, 7]]) == [1, 4]",
    "import unittest\n\ndef find_smallest_range(nums1, nums2, nums3):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type nums3: List[int]\n    :rtype: int\n    \"\"\"\n    min_range = min(nums1[0], nums2[0], nums3[0])\n    max_range = max(nums1[-1], nums2[-1], nums3[-1])\n    for i in range(1, len(nums1)):\n        if nums1[i] > max_range:\n            return max_range\n        elif nums1[i] < min_range:\n            min_range = nums1[i]\n        if nums2[i] > max_range:\n            return max_range\n        elif nums2[i] < min_range:\n            min_range = nums2[i]\n        if nums3[i] > max_range:\n            return max_range\n        elif nums3[i] < min_range:\n            min_range = nums3[i]\n    return min_range\n\nclass TestProblem2(unittest.TestCase):\n    def test_find_smallest_range(self):\n        self.assertEqual(find_smallest_range([1, 2, 3], [4, 5, 6], [7, 8, 9]), 1)\n        self.assertEqual(find_smallest_range([1, 2, 3], [4, 5, 6], [7, 8, 9, 10]), 2)\n        self.assertEqual(find_smallest_range([1, 2, 3, 4, 5, 6], [7, 8, 9], [10, 11, 12, 13]), 1)\n        self.assertEqual(find_smallest_range([1, 2, 3, 4, 5, 6], [7, 8, 9, 10], [11, 12, 13]), 2)\n        self.assertEqual(find_smallest_range([1, 2, 3, 4, 5"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}