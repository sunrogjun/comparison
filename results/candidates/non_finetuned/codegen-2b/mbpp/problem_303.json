{
  "problem": {
    "task_id": "MBPP/314",
    "prompt": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.",
    "canonical_solution": "def max_sum_rectangular_grid(grid, n) : \r\n\tincl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)",
    "test_list": [
      "assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7",
      "assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24",
      "assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81"
    ],
    "challenge_test_list": [],
    "problem_id": 303
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def maxSumAdjacent(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        grid = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                grid[i][j] = sum(grid[i][j - 1:j + 1])\n        for i in range(n):\n            for j in range(m):\n                grid[i][j] = max(grid[i][j], grid[i - 1][j], grid[i][j - 1], grid[i - 1][j - 1])\n        return grid[0][0]\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxSumAdjacent([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) == 42",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        max_sum = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                sum = grid[i][j]\n                if i > 0:\n                    sum += grid[i-1][j]\n                if j > 0:\n                    sum += grid[i][j-1]\n                max_sum = max(max_sum, sum)\n        return max_sum",
    "from collections import defaultdict\nimport heapq\n\n\ndef max_sum_rectangle(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    max_sum = -1 * (m * (m + 1))\n    max_sum_heap = defaultdict(lambda: 0)\n    max_sum_heap[(0, 0)] = 0\n\n    for i in range(n):\n        for j in range(m):\n            if j == 0 or j == m - 1:\n                max_sum_heap[(i, j)] = grid[i][j]\n            else:\n                max_sum_heap[(i, j)] = max(max_sum_heap[(i - 1, j - 1)], max_sum_heap[(i - 1, j)], max_sum_heap[(i - 1, j + 1)],\n                                           max_sum_heap[(i, j - 1)], max_sum_heap[(i, j + 1)]) + grid[i][j]\n            if max_sum_heap[(i, j)] > max_sum:\n                max_sum = max_sum_heap[(i, j)]\n    return max_sum\n\n\nif __name__ == '__main__':\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    print(max_sum_rectangle(grid))",
    "#!/usr/bin/python\n\ndef maxSum(grid):\n    maxSum = 0\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid) - 1:\n                continue\n            else:\n                sum = grid[i][j] + grid[i][j-1] + grid[i][j+1] + grid[i-1][j] + grid[i+1][j]\n                if sum > maxSum:\n                    maxSum = sum\n    return maxSum\n\ngrid = [[1, 1, 1, 1, 1],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1]]\n\nprint maxSum(grid)",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        m = len(grid[0])\n        n = len(grid)\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    continue\n                res = max(res, grid[i][j] + max(grid[i - 1][j], grid[i][j - 1]))\n        return res",
    "import numpy as np\n\ndef find_max_sum(n, rect):\n    # If the grid is a rectangle, find the maximum sum.\n    if rect == 0:\n        return 0\n    # If the grid is not a rectangle, find the maximum sum by the following algorithm.\n    # If there is no such a solution, return 0.\n    # 1. Find the maximum sum for the left side.\n    # 2. Find the maximum sum for the right side.\n    # 3. Find the maximum sum for the top side.\n    # 4. Find the maximum sum for the bottom side.\n    # 5. If the two sides are adjacent, then add them together.\n    # 6. Return the maximum sum.\n    # Note:\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of a rectangle.\n    # The sum of the two sides of a rectangle must be less than or equal to the sum of the two sides of",
    "import math\nimport time\n\ndef find_max_sum(n):\n    # Write your code here\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    grid = [0] * n\n    for i in range(2, n):\n        grid[i-1] = grid[i-2] + grid[i-1]\n    # print(grid)\n    max_sum = grid[0]\n    # print(max_sum)\n    for i in range(1, n):\n        if grid[i] > max_sum:\n            max_sum = grid[i]\n    # print(max_sum)\n    return max_sum\n\nif __name__ == '__main__':\n    print(find_max_sum(2))\n    print(find_max_sum(4))\n    print(find_max_sum(5))\n    print(find_max_sum(10))\n    print(find_max_sum(100))\n    print(find_max_sum(1000))\n    print(find_max_sum(10000))\n    print(find_max_sum(100000))",
    "import unittest\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # first row\n        max_sum = 0\n        for i in xrange(len(grid)):\n            max_sum = max(max_sum, self.maxSum(grid[i]))\n        # second row\n        max_sum = max(max_sum, self.maxSum(grid[::2]))\n        # third row\n        max_sum = max(max_sum, self.maxSum(grid[1::2]))\n        # forth row\n        max_sum = max(max_sum, self.maxSum(grid[::-1]))\n        return max_sum\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/max-sum-rectangular-matrix/solution/\n\n# DFS\n# 10ms 100%\nclass Solution {\n    public int maxSum(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        int[][] dp = new int[grid.length][grid[0].length];\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {\n                dp[i][j] = grid[i][j];\n            }\n        }\n        return dfs(dp, 0, grid.length - 1, grid[0].length - 1);\n    }\n\n    private int dfs(int[][] dp, int i, int j, int k) {\n        if (i < 0 || i >= dp.length || j < 0 || j >= dp[0].length || k < 0 || k >= dp[0][0].length) return 0;\n        if (dp[i][j] == -",
    "# https://www.hackerrank.com/challenges/maximum-sum-of-adjacent-diagonals\n\n# https://www.hackerrank.com/challenges/maximum-sum-of-adjacent-diagonals/problem\n\n# https://www.hackerrank.com/challenges/maximum-sum-of-adjacent-diagonals/submissions/code/36687834\n\ndef find_maximum_sum(grid):\n    max_sum = 0\n    for row in grid:\n        for num in row:\n            if max_sum < num:\n                max_sum = num\n    return max_sum",
    "class Solution:\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        \n        def maxSum(grid, start, end):\n            if start > end:\n                return 0\n            \n            if end - start == 1:\n                return grid[start][end]\n            \n            sum = 0\n            for i in range(start, end + 1):\n                sum += max(maxSum(grid, start, i - 1), maxSum(grid, i + 1, end))\n            return sum\n        \n        return maxSum(grid, 0, len(grid) - 1)",
    "# https://github.com/pythran/pythran/issues/1918\n\ndef max_sum_2xn(n, m):\n    if n < 2 or m < 2:\n        return 0\n    s = [0] * m\n    for i in range(n):\n        for j in range(m):\n            s[j] = max(s[j], s[j + 1] + i)\n    return s[0]\n\n# https://www.hackerrank.com/challenges/sudoku-max-sum-2xn/problem\n\ndef max_sum_2xn_solution(n, m):\n    if n < 2 or m < 2:\n        return 0\n    n_row = m / n\n    n_col = m / n\n    s = [0] * m\n    for i in range(n_row):\n        for j in range(n_col):\n            s[j * n + i] = max(s[j * n + i], s[(j + 1) * n + i] + i)\n    return s[0]\n\n# https://www.hackerrank.com/challenges/sudoku-max-sum-3x3/problem\n\ndef max_sum_3x3_solution(n, m):\n    if n < 2 or m < 2:\n        return 0\n    n_row = m / n\n    n_col = m / n\n    s = [0] * m\n    for i in range(n_row):\n        for j in range(n_col):\n            s[j * n + i] = max(s[j * n + i], s[(j + 1) * n + i] + i)\n            s[i * n + j] = max(s[i * n + j], s[(i + 1) * n + j] + i)\n    return s[0]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    m = int(input())\n    print(max_sum_2xn(n, m))\n    print(max_sum_3x3_solution(n, m",
    "# TLE\n# class Solution(object):\n#     def maxSum(self, grid):\n#         \"\"\"\n#         :type grid: List[List[int]]\n#         :rtype: int\n#         \"\"\"\n#         # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n#         dp = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\n#         for i in range(len(grid)):\n#             for j in range(len(grid[0])):\n#                 if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n#                     dp[i][j] = grid[i][j]\n#                 else:\n#                     dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n#         return max(dp[-1][-1], dp[-1][-2])\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n                    dp[i][j] = grid[i][j]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return max(dp[-1][-1], dp[-1][-2])\n\nif __name__ == \"__main__\":\n    assert Solution().maxSum([[1,2,3],[4,5,6],[7,8,9]]) == 18\n    assert Solution().maxSum([[1,1,1",
    "def max_sum(n, grid):\n    # write your code here\n    if grid[0][0] == grid[n-1][n-1]:\n        return grid[0][0]\n    else:\n        for i in range(1, n-1):\n            if grid[i][0] == grid[i][n-1]:\n                return grid[0][0]\n        for i in range(1, n-1):\n            for j in range(1, n-1):\n                if grid[0][j] == grid[i][j]:\n                    return grid[0][0]\n        return grid[0][0]\n\n# test cases\ngrid = [[1,2,3,4],[3,4,5,6],[5,6,7,8],[1,2,3,4]]\nn = len(grid)\nprint(max_sum(n, grid))",
    "class Solution:\n    # @return an integer\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n\n        # for each row, check the sum of the two adjacent numbers\n        # for each column, check the sum of the two adjacent numbers\n        # if the sum is greater than the maximum sum, return that maximum sum\n        # else, continue to check the sum of the two adjacent numbers in the next row and column\n        max_sum = [[0] * m for i in range(n)]\n        for row in range(n):\n            for col in range(m):\n                if grid[row][col] == 0:\n                    continue\n                if row > 0 and grid[row-1][col] == grid[row][col]:\n                    max_sum[row][col] = max(max_sum[row-1][col], max_sum[row][col])\n                else:\n                    max_sum[row][col] = max(max_sum[row][col], grid[row][col])\n        return max(max_sum)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    n = [0] * 10\n    m = [0] * 10\n    for i in range(1, 10):\n        n.append(i)\n        m.append(i)\n    print(sol.maxSum(n))",
    "class Solution(object):\n    def maxSumSubmatrix(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(mat)\n        m = len(mat[0])\n        if n == 0 or m == 0:\n            return 0\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = mat[i][j]\n                if i > 0 and mat[i - 1][j] >= mat[i][j]:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + mat[i][j])\n                if i < n - 1 and mat[i + 1][j] >= mat[i][j]:\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + mat[i][j])\n                if j > 0 and mat[i][j - 1] >= mat[i][j]:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + mat[i][j])\n                if j < m - 1 and mat[i][j + 1] >= mat[i][j]:\n                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + mat[i][j])\n        return dp[0][0]",
    "class Solution:\n    \"\"\"\n    @param grid: A list of lists of integers\n    @return: The maximum sum\n    \"\"\"\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # 1. dfs\n        # 1.1 init\n        # 1.2 for i in range(0, n):\n        # 1.3   for j in range(0, n):\n        # 1.4     if i > 0 and grid[i-1][j] == grid[i][j]:\n        # 1.4.1    return grid[i-1][j] + grid[i][j]\n        # 1.4.2    else:\n        # 1.4.3     return max(grid[i-1][j] + grid[i][j], grid[i-1][j] + grid[i][j])\n        # 1.4.4    return max(grid[i-1][j] + grid[i][j], grid[i-1][j] + grid[i][j])\n        # 1.4.5    return grid[i-1][j] + grid[i][j]\n\n        # 1.3.1    for i in range(0, n):\n        # 1.3.2     for j in range(0, n):\n        # 1.3.3     if i == 0 or j == 0 or grid[i-1][j] == grid[i][j]:\n        # 1.3.3.1    return grid[i][j]\n        # 1.3.3.2    else:\n        # 1.3.3.3     return max(grid[i][j], grid[i][j] + grid[i-1][j] + grid[i-1][j])\n\n        # 1.3.1    for i in range(0, n):\n        # 1.3.2     for j in range(0, n):\n        # 1.3.3     if i == 0 or j == 0 or grid[i-1][j] == grid[i][j]:\n        # 1.3.3.1    return grid[i][j",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n, m = len(grid), len(grid[0])\n        dp = [0] * (m + 1)\n        for i in range(m + 1):\n            dp[i] = [0] * (n + 1)\n            for j in range(n + 1):\n                dp[i][j] = grid[j][i]\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n        return max(dp[m][n])",
    "# Example 1:\n# Input: n = 3, grid = [[1,2],[3,4]]\n# Output: 8\n# Explanation:\n# The maximum sum for this rectangular grid is 8.\n# (1 + 2 + 3) + (2 + 3 + 4) = 8\n# (1 + 2 + 4) + (3 + 4 + 1) = 8\n# (1 + 3 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 2) + (2 + 1 + 3) = 8\n# (1 + 4 + 3) + (2 + 3 + 1) = 8\n# (1 + 3 + 1) + (2 + 4 + 1) = 8\n# (1 + 1 + 4) + (2 + 4 + 3) = 8\n# (1 + 1 + 3) + (2 + 3 + 4) = 8\n# (1 + 4 + 1) + (2 + 1 + 4) = 8\n# (1 + 4 + 3) + (2 + 4 + 1) = 8\n# (1 + 3 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 1) + (2 + 3 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 3 + 1) + (2 + 4 + 4) = 8\n# (1 + 4 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 4) + (2 + 1 + 4) = 8\n# (1 + 4 + 4) + (2 + 4 + 1) = 8\n# (1 + 4 + 4) +",
    "import unittest\n\nclass Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def find_max_sum(i, j, grid):\n            if i == 0 or j == 0:\n                return 0\n            elif i == len(grid) - 1 or j == len(grid[0]) - 1:\n                return grid[i][j]\n            elif grid[i][j] < grid[i - 1][j] + grid[i][j - 1]:\n                return grid[i][j]\n            else:\n                return max(find_max_sum(i - 1, j, grid), find_max_sum(i, j - 1, grid))\n        return max(find_max_sum(i, j, grid) for i in range(len(grid)) for j in range(len(grid[0])))\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-sum-rectangular-grid/solution/\n\nApproach #1: Dynamic Programming [Accepted]\nComplexity Analysis\nTime Complexity: O(m + n)\nSpace Complexity: O(m + n)\n\n# 1ms 100%\nclass Solution {\n    public int maxSumRectGrid(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[][] dp = new int[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 0;\n                } else if (i == m - 1 || j == n - 1) {\n                    dp[i][j] = grid[i][j];\n                } else if (grid[",
    "# https://leetcode.com/problems/rectangle-sum/discuss/66450/Python-Python-DP-solution-using-two-pointers\n\nclass Solution(object):\n    def maximalSquare(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return 0\n\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]) + matrix[i][j]\n\n        return dp[m-1][n-1]\n\n\nif __name__ == '__main__':\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    matrix = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 1], [1, 1], [1, 1]]\n    matrix = [[1, 2, 3",
    "import math\n\ndef solve(n, grid):\n    \"\"\"\n    :type n: int\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    grid.sort(key=lambda x: x[0])\n    grid.sort(key=lambda x: x[1])\n    return sum(grid[i][0] + grid[i][1] + grid[i][2] for i in range(n))\n\nif __name__ == '__main__':\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert solve(len(grid), grid) == 20\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9], [9, 10, 11]]\n    assert solve(len(grid), grid) == 29\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9], [9, 10, 11], [11, 12, 13]]\n    assert solve(len(grid), grid) == 36\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9], [9, 10, 11], [11, 12, 13], [13, 14, 15]]\n    assert solve(len(grid), grid) == 38\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9], [9, 10, 11], [11, 12, 13], [13, 14, 15], [15, 16, 17]]\n    assert solve(len(grid), grid) == 42\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9], [9, 10, 11], [11, 12, 13], [13, 14, 15], [15, 16, 17], [17, 18, 19]]\n    assert solve(len(grid), grid) == 46\n    grid = [[1, 2, 3], [3, 4, 5], [5, 6, 7], [",
    "# https://leetcode.com/problems/rectangle-sum/\n\nclass Solution(object):\n    def rectangleSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        if n == 0:\n            return 0\n        if m == 0:\n            return 0\n        dp = [0] * (m+1)\n        for i in xrange(1, m+1):\n            dp[i] = max(grid[0][0] + grid[0][i], grid[0][0] + grid[i][0])\n        for i in xrange(1, n+1):\n            dp[0] = max(dp[0], grid[i][0] + grid[0][0])\n        for i in xrange(1, m+1):\n            for j in xrange(1, n+1):\n                dp[i] = max(dp[i], dp[i-1] + grid[j][i])\n        return dp[m]",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        max_sum = -2**32\n        for i in xrange(m):\n            for j in xrange(n):\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\n                    max_sum = max(max_sum, grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1])\n                else:\n                    max_sum = max(max_sum, grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1] - grid[i-1][j] - grid[i-1][j+1] - grid[i+1][j-1] - grid[i-1][j-1])\n        return max_sum\n\nprint Solution().maxSumRectGrid([[1,2,3],[4,5,6],[7,8,9]])",
    "def maxSum(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n\n    max_sum = grid[0][0]\n    for i in range(1, m):\n        for j in range(1, n):\n            sum = grid[i-1][j-1] + grid[i][j] + grid[i][j-1] + grid[i-1][j-1]\n            if sum > max_sum:\n                max_sum = sum\n    return max_sum\n\n# Test Cases:\n# [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]\n# [[1,2],[3,4],[5,6],[7,8]]\n# [[1,2],[3,4],[5,6]]\n# [[1,2],[3,4]]\n# [[1,2],[3,4],[5,6]]\n# [[1,2],[3,4],[5,6],[7,8]]\n# [[1,2],[3,4],[5,6],[7,8],[9,10]]\n# [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12]]\n# [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14]]",
    "def max_sum(n, m, grid):\n    if not grid:\n        return 0\n    elif grid[0] == grid[1]:\n        return max(grid[0], sum(grid[0:2]))\n    elif grid[0] == grid[2]:\n        return max(grid[0], sum(grid[0:3]))\n    elif grid[1] == grid[2]:\n        return max(grid[1], sum(grid[1:3]))\n    else:\n        return max(grid[0], max(grid[1], sum(grid[0:2]))) + max(grid[2], max(grid[0:3]))\n\ngrid = [[1, 2], [2, 3], [1, 3]]\nprint max_sum(len(grid), len(grid[0]), grid)",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n\n        def dfs(r, c, cur_max, r_max, c_max):\n            if r < 0 or r >= m or c < 0 or c >= n:\n                return 0\n            if dp[r][c] > cur_max:\n                return 0\n            if r == m - 1 and c == n - 1:\n                return cur_max\n            if dp[r][c] > cur_max:\n                return 0\n            if grid[r][c] > 0:\n                cur_max += grid[r][c]\n                dfs(r + 1, c, cur_max, r_max, c_max)\n                cur_max -= grid[r][c]\n            if r_max < r:\n                r_max = r\n            if c_max < c:\n                c_max = c\n            return cur_max\n\n        cur_max = 0\n        r_max = 0\n        c_max = 0\n        for r in range(m):\n            for c in range(n):\n                cur_max = max(cur_max, dfs(r, c, 0, r_max, c_max))\n        return cur_max",
    "class Solution(object):\n    def solve(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0])\n        res = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if i > 0 and grid[i-1][j] == grid[i][j]:\n                    res = max(res, grid[i][j] + grid[i-1][j])\n                if j > 0 and grid[i][j-1] == grid[i][j]:\n                    res = max(res, grid[i][j] + grid[i][j-1])\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    for i in xrange(1, 10):\n        for j in xrange(1, 10):\n            print i, j, sol.solve([[i, j], [i, j], [i, j]])",
    "import unittest\n\nclass Solution(object):\n    def maximalRectangle(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if grid[i][j] == 0:\n                return 0\n            if i == 0:\n                return grid[i][j]\n            if j == 0:\n                return grid[i][j]\n            if i == grid.__len__() - 1 and j == grid[0].__len__() - 1:\n                return grid[i][j] + dfs(i - 1, j - 1)\n            if j == grid[0].__len__() - 1 and i == grid.__len__() - 1:\n                return grid[i][j] + dfs(i - 1, j)\n            if i == grid.__len__() - 1 and j < grid[0].__len__() - 1:\n                return grid[i][j] + dfs(i, j + 1)\n            if j == grid[0].__len__() - 1 and i < grid.__len__() - 1:\n                return grid[i][j] + dfs(i + 1, j)\n            return max(grid[i][j], dfs(i, j - 1), dfs(i - 1, j), dfs(i, j + 1), dfs(i + 1, j))\n        return max(dfs(i, j) for i in range(grid.__len__()) for j in range(grid[0].__len__()))\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximal-rectangle/solution/\n#\n# 1. dfs\n# 2. dfs with memoization\n# 3. dfs with memoization\n# 4. dfs with memoization\n#\n# 1. dfs\n# 1. dfs with memoization",
    "class Solution:\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def maximalSquare(self, grid):\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        max_sum = grid[0][0]\n        for i in range(1, n):\n            for j in range(1, n):\n                max_sum = max(max_sum, grid[i][j])\n                \n        for i in range(1, n):\n            for j in range(1, n):\n                max_sum = max(max_sum, grid[i][0] + grid[0][j])\n                \n        return max_sum",
    "import sys\nsys.setrecursionlimit(10000)\n\n\ndef maximum_sum(n, m):\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == 1:\n        return m * m\n    return max(maximum_sum(n - 1, m), maximum_sum(n, m - 1)) + m * m\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    print(maximum_sum(n, m))",
    "class Solution:\n    # @param {integer} grid\n    # @return {integer}\n    def maxSumAdjacent(self, grid):\n        if len(grid) == 0:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        \n        # print grid\n        # print m, n\n        \n        max_sum = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if grid[i][j] == 0:\n                    continue\n                if i == 0 or grid[i-1][j] == 0:\n                    max_sum = max(max_sum, grid[i][j] + self.maxSumAdjacent(grid[i:m, j:]))\n                if j == 0 or grid[i][j-1] == 0:\n                    max_sum = max(max_sum, grid[i][j] + self.maxSumAdjacent(grid[i:, [j]]))\n        return max_sum\n        \n        \n        \n    # @param {integer[][]} grid\n    # @return {integer}\n    def maxSumAdjacent(self, grid):\n        if len(grid) == 0:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        \n        # print grid\n        # print m, n\n        \n        max_sum = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if grid[i][j] == 0:\n                    continue\n                if i == 0 or grid[i-1][j] == 0:\n                    max_sum = max(max_sum, grid[i][j] + self.maxSumAdjacent(grid[i:m, j:]))\n                if j == 0 or grid[i][j-1] == 0:\n                    max_sum = max(max_sum, grid[i][j] + self.maxSumAdjacent(grid[i:, [j]]))\n        return max_sum",
    "import sys\n\nclass Solution(object):\n    def solve(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return self.max_sum(grid, 0, grid[0][0], 0, grid[0][0])\n\n    def max_sum(self, grid, i, j, n, m):\n        if i == n and j == m:\n            return grid[i][j]\n        if i == n and j < m:\n            return max(grid[i][j] + self.max_sum(grid, i + 1, j, n, m),\n                       grid[i][j] + self.max_sum(grid, i, j + 1, n, m))\n        if i < n and j == m:\n            return max(grid[i][j] + self.max_sum(grid, i + 1, j, n, m),\n                       grid[i][j] + self.max_sum(grid, i, j - 1, n, m))\n        if i < n and j < m:\n            return max(grid[i][j] + self.max_sum(grid, i + 1, j, n, m),\n                       grid[i][j] + self.max_sum(grid, i, j - 1, n, m))\n        return grid[i][j]\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.solve([[1, 0, 0, 0, 0],\n                     [1, 1, 1, 1, 1],\n                     [1, 1, 1, 1, 1],\n                     [1, 1, 1, 1, 1],\n                     [1, 1, 1, 1, 1]])",
    "def maximum_sum(grid):\n    max_sum = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                for k in range(i+1, len(grid)):\n                    for l in range(j+1, len(grid[0])):\n                        if grid[k][l] == 1:\n                            max_sum = max(max_sum, grid[i][j] + grid[k][l])\n    return max_sum\n\ngrid = [\n    [0,0,0,0,0],\n    [0,0,1,1,1],\n    [1,1,1,0,1],\n    [1,1,1,1,1],\n    [1,1,1,1,1]\n]\n\nprint(maximum_sum(grid))",
    "class Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maximalSquare(self, grid):\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        if m < n: return self.maximalSquare(grid[:,:m])\n        \n        # max x and y\n        maxx, maxy = 0, 0\n        for i in range(n):\n            for j in range(m):\n                x, y = j + grid[i][j], i + grid[i][j]\n                if x < maxx: continue\n                if y < maxy: continue\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n                \n        return maxx * maxy\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maximalSquare([[1,2],[3,4]]))\n    print(sol.maximalSquare([[1,2],[3,4],[5,6]]))",
    "# https://www.hackerrank.com/challenges/max-sum-rectangular\n\n# 2D array\ndef maxSum(n, arr):\n    if n == 1:\n        return arr[0]\n    \n    for i in range(n):\n        arr[i] = max(arr[i-1], arr[i])\n        arr[i] += arr[i+1]\n        \n    return arr[n-1]\n    \n# 2D array\ndef maxSum(n, arr):\n    if n == 1:\n        return arr[0]\n    \n    for i in range(n):\n        arr[i] = max(arr[i-1], arr[i])\n        arr[i] += arr[i+1]\n        \n    return max(arr)\n    \n    \n# 2D array\ndef maxSum(n, arr):\n    if n == 1:\n        return arr[0]\n    \n    for i in range(n):\n        arr[i] = max(arr[i-1], arr[i])\n        arr[i] += arr[i+1]\n        \n    return arr[n-1]\n    \n    \n# 2D array\ndef maxSum(n, arr):\n    if n == 1:\n        return arr[0]\n    \n    for i in range(n):\n        arr[i] = max(arr[i-1], arr[i])\n        arr[i] += arr[i+1]\n        \n    return max(arr)",
    "import time\nimport random\nimport math\n\nstart_time = time.time()\n\n\ndef max_sum_2xn(n, m):\n    max_sum = 0\n\n    # Start with the first row\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                continue\n            if i == 1 or j == n - 1:\n                continue\n            # Get the sum of the two adjacent numbers\n            sum = sum_of_two_adjacent_numbers(i, j, n, m)\n            # If the sum is greater than the current maximum, update the maximum\n            if sum > max_sum:\n                max_sum = sum\n    return max_sum\n\n\ndef sum_of_two_adjacent_numbers(i, j, n, m):\n    # Get the sum of the two adjacent numbers\n    sum = (i * n + j) * n + ((i - 1) * n + j) * (m - n) + ((i - 1) * n + j - 1) * (m - n) + ((i - 1) * n + j + 1) * (m - n) + ((i + 1) * n + j) * (m - n) + ((i + 1) * n + j - 1) * (m - n) + ((i + 1) * n + j + 1) * (m - n)\n    return sum\n\n\ndef max_sum_2xn_recursive(n, m):\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == n:\n        return m\n    max_sum = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                continue\n            if i == 1 or j == n - 1:\n                continue\n            sum = sum_of_two_adjacent_numbers(i, j, n, m)\n            if sum > max_sum:\n                max_sum = sum\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    print(max_sum_2xn(5, 5))\n    print(",
    "class Solution(object):\n    def maxSumAdj(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i - 1 >= 0 and j - 1 >= 0:\n                    ans = max(ans, grid[i][j] + grid[i - 1][j - 1] + grid[i][j - 1] + grid[i - 1][j])\n                if i - 1 >= 0:\n                    ans = max(ans, grid[i][j] + grid[i - 1][j] + grid[i - 1][j - 1] + grid[i][j - 1])\n                if j - 1 >= 0:\n                    ans = max(ans, grid[i][j] + grid[i][j - 1] + grid[i - 1][j - 1] + grid[i - 1][j])\n                if i + 1 < m and j - 1 >= 0:\n                    ans = max(ans, grid[i][j] + grid[i + 1][j - 1] + grid[i + 1][j])\n                if j + 1 < n and i - 1 >= 0:\n                    ans = max(ans, grid[i][j] + grid[i - 1][j + 1] + grid[i - 1][j])\n                if i + 1 < m and j + 1 < n:\n                    ans = max(ans, grid[i][j] + grid[i + 1][j + 1] + grid[i + 1][j])\n                if i - 1 >= 0 and j + 1 < n:\n                    ans = max(ans, grid[i][j] + grid[i - 1][j + 1] + grid[i - 1][j])\n        return ans\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.maxSumAdj([[1, 2], [3, 4]]))\n    print(sol.maxSumAdj([[1,",
    "#!/usr/bin/env python\n\nclass Solution:\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        s = [[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    s[i][j] = grid[i][j]\n                else:\n                    s[i][j] = max(grid[i-1][j] + grid[i][j-1] + grid[i-1][j-1],\n                                  grid[i][j-1] + grid[i-1][j] + grid[i][j-1])\n        return max(sum(s[i][j] for j in range(n)) for i in range(m))\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.maxSum([[1],[1]]) == 2\n    assert s.maxSum([[1,1],[1,0]]) == 3\n    assert s.maxSum([[1,1],[0,1],[1,1]]) == 4\n    assert s.maxSum([[1,1],[1,0],[1,1]]) == 4\n    assert s.maxSum([[1,1],[1,1],[0,1],[1,0],[1,1]]) == 6",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        ans = [[0] * m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    for k in range(i + 1, n):\n                        for l in range(j + 1, m):\n                            if k >= 0 and l >= 0 and grid[k][l] == 1:\n                                ans[i][j] = max(ans[i][j], ans[i][j] + ans[k][l])\n        return max(ans)\n\nif __name__ == \"__main__\":\n    print Solution().maxSumRectGrid([[1,1,1,1,1,1,1,1],\n                                     [1,1,1,0,1,1,1,1],\n                                     [1,1,0,0,0,0,0,1],\n                                     [1,1,0,1,0,1,0,1],\n                                     [1,1,0,0,0,0,1,1],\n                                     [1,1,0,0,1,1,0,1],\n                                     [1,1,0,0,0,1,0,1],\n                                     [1,1,0,0,0,0,0,1],\n                                     [1,1,1,1,1,1,1,1]])",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(grid) == 0:\n            return 0\n\n        n = len(grid)\n        m = len(grid[0])\n\n        max_sum = 0\n        for i in range(m):\n            row = [0 for j in range(n)]\n            for j in range(m):\n                row[j] = grid[i][j]\n                if j + 1 < n:\n                    row[j] += grid[i][j + 1]\n                if i + 1 < n:\n                    row[j] += grid[i + 1][j]\n            max_sum = max(max_sum, row[i])\n\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(Solution().maxSumRectGrid(grid))",
    "import sys\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    # get input\n    try:\n        grid_width = int(sys.argv[1])\n        grid_height = int(sys.argv[2])\n        n = grid_width * grid_height\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit(1)\n    except IndexError:\n        print(\"No input\")\n        sys.exit(1)\n\n    # get all the numbers\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n\n    # get the maximum sum\n    max_sum = 0\n    for i in range(grid_width):\n        for j in range(grid_height):\n            # get the maximum sum for the current square\n            max_sum = max(max_sum, max(grid[i][j], grid[i][j+1], grid[i+1][j], grid[i+1][j+1]))\n\n    # print the result\n    print(max_sum)\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maximalRectangle(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        result = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if grid[i][j] == 1:\n                    result = max(result, self.maximalRectangle(grid[i + 1:m][j], grid[i][j + 1:n]) + 1)\n                    result = max(result, self.maximalRectangle(grid[i + 1:m][j + 1:n], grid[i][j]) + 1)\n        return result",
    "#!/usr/bin/python\n\n\"\"\"\n\nGiven an n x n grid, find the maximum sum of two adjacent numbers in the grid such that no two chosen numbers are adjacent.\n\nFor example, given the following grid:\n\n[\n [1, 0, 1, 0],\n [1, 1, 1, 1],\n [0, 1, 0, 1]\n]\n\nGiven chosen numbers 0 and 1, the maximum sum is 2.\nGiven chosen numbers 0 and 1, the maximum sum is 1.\n\n\"\"\"\n\n\ndef maxSum(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    # print(grid)\n    # print(maxSum(grid))\n    # print(maxSum(grid, 1))\n    # print(maxSum(grid, 2))\n\n    return max(maxSum(grid, n-1), maxSum(grid, n-2))\n\n\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1]]))\n# print(maxSum([[1, 0, 1, 0], [1, 1, 1, 1",
    "# Definition for a point.\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n# Your Solution here.\nclass Solution:\n    def maxSumRectangle(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(grid) == 0:\n            return 0\n\n        maxSum = 0\n        curSum = 0\n        for i in range(len(grid)):\n            curSum = 0\n            for j in range(len(grid[0])):\n                curSum += grid[i][j]\n                if curSum > maxSum:\n                    maxSum = curSum\n                elif curSum < maxSum:\n                    maxSum = curSum\n\n        return maxSum\n\n\n# Your Solution here.\nclass Solution:\n    def maxSumRectangle(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        maxSum = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n                    maxSum = max(maxSum, grid[i][j])\n                else:\n                    maxSum = max(maxSum, grid[i][j] + grid[i-1][j] + grid[i][j-1] + grid[i-1][j-1])\n\n        return maxSum\n\nif __name__ == \"__main__\":\n    grid = [[1, 3, 1], [4, 2, 1], [3, 2, 4], [2, 2, 3]]\n    print(Solution().maxSumRectangle(grid))\n    grid = [[1, 3, 1], [4, 2, 1], [3, 2, 4], [2, 2, 3]]\n    print(Solution().maxSumRectangle(grid))",
    "import math\n\nclass Solution:\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def maxSumAdjacent(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        if m == 1:\n            return grid[0][0]\n        if n == 1:\n            return grid[0][0]\n        if m == 2:\n            return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n        if n == 2:\n            return max(grid[0][0] + grid[1][0], grid[0][1] + grid[1][1])\n        if m == 3:\n            return max(grid[0][0] + grid[0][1] + grid[0][2], grid[1][0] + grid[1][1] + grid[1][2])\n        if n == 3:\n            return max(grid[0][0] + grid[1][0] + grid[2][0], grid[0][1] + grid[1][1] + grid[2][1])\n        if m == 4:\n            return max(grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3], grid[1][0] + grid[1][1] + grid[1][2] + grid[1][3])\n        if n == 4:\n            return max(grid[0][0] + grid[1][0] + grid[2][0] + grid[3][0], grid[0][1] + grid[1][1] + grid[2][1] + grid[3][1])\n        if m == 5:\n            return max(grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4], grid[1][0] + grid[1][1] + grid[1][2] + grid[1][3] + grid[1][4])\n        if n == 5:\n            return max(grid[0][0] + grid[",
    "import os\nfrom math import sqrt\n\ndef main():\n    file_path = os.path.dirname(os.path.realpath(__file__))\n    with open(file_path + '/input.txt', 'r') as f:\n        n = int(f.readline())\n        grid = []\n        for _ in range(n):\n            grid.append(map(int, f.readline().split()))\n        max_sum = 0\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if grid[i][j] > max_sum:\n                    max_sum = grid[i][j]\n        print max_sum\n\n\nif __name__ == '__main__':\n    main()",
    "#!/usr/bin/python\n\nimport math\n\ndef maxSum(n):\n    result = 0\n    for i in xrange(1, n):\n        result += max(0, i - 1)\n    for j in xrange(1, n):\n        result += max(0, n - j)\n    return max(result, 0)\n\nif __name__ == \"__main__\":\n    print maxSum(5)",
    "class Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        m = len(grid[0])\n\n        # compute the maximum sum\n        max_sum = 0\n        for i in range(n):\n            for j in range(m):\n                max_sum = max(max_sum, self.find_max_sum(grid, i, j))\n\n        return max_sum\n\n    def find_max_sum(self, grid, i, j):\n        # base case\n        if i == n-1 or j == m-1:\n            return grid[i][j]\n\n        # search for the maximum sum\n        max_sum = grid[i][j]\n        for x in range(i-1, -1, -1):\n            max_sum = max(max_sum, self.find_max_sum(grid, x, j))\n        for y in range(j-1, -1, -1):\n            max_sum = max(max_sum, self.find_max_sum(grid, i, y))\n        return max_sum",
    "import sys\n\n# @include\ndef find_max_sum_2xn(grid):\n    # Compute the sum of all the numbers in the grid.\n    num_of_numbers = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            num_of_numbers += grid[i][j]\n\n    # Compute the maximum sum of the given grid.\n    max_sum = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > 0:\n                max_sum = max(max_sum, grid[i][j] + find_max_sum_2xn(grid[i + 1:][0:len(grid[0])]))\n    return max_sum\n# @exclude\n\n\ndef main():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    print(find_max_sum_2xn(grid))\n    # Output: 9\n    grid = [[-1, -2, -3],\n            [-4, -5, -6],\n            [-7, -8, -9]]\n    print(find_max_sum_2xn(grid))\n    # Output: 9\n\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def maxSumRect(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        max_sum = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                max_sum = max(max_sum, self.maxSum(grid, i, j))\n\n        return max_sum\n\n    def maxSum(self, grid, i, j):\n        max_sum = 0\n        for k in range(i-1, -1, -1):\n            max_sum += grid[k][j]\n            if k < 0 or k >= len(grid) or j < 0 or j >= len(grid[0]):\n                return max_sum\n\n        for k in range(j-1, -1, -1):\n            max_sum += grid[i][k]\n            if k < 0 or k >= len(grid[0]) or i < 0 or i >= len(grid):\n                return max_sum\n\n        return max_sum\n\nif __name__ == '__main__':\n    print Solution().maxSumRect([[1,2,3],[4,5,6],[7,8,9]])",
    "import time\n\ndef solution(n):\n    # Start by finding the maximum sum of two numbers in the same row.\n    # Then, add up the maximum sum of two numbers in the same column.\n    # Finally, add up the maximum sum of two numbers in the same diagonal.\n    #\n    # The result is the maximum sum of two numbers in the same row,\n    # the maximum sum of two numbers in the same column,\n    # and the maximum sum of two numbers in the same diagonal.\n    #\n    # Since the result is the maximum sum of two numbers in the same row,\n    # the maximum sum of two numbers in the same column,\n    # and the maximum sum of two numbers in the same diagonal,\n    # then the result is the maximum sum of two numbers in the same row,\n    # the maximum sum of two numbers in the same column,\n    # and the maximum sum of two numbers in the same diagonal.\n\n    # Initialize a variable to store the maximum sum of two numbers in the same row,\n    # the maximum sum of two numbers in the same column,\n    # and the maximum sum of two numbers in the same diagonal.\n    max_row = max_col = max_diag = 0\n    # Find the maximum sum of two numbers in the same row.\n    for i in range(n):\n        for j in range(i+1, n):\n            if i == j:\n                continue\n            max_row = max(max_row, i+j)\n    # Find the maximum sum of two numbers in the same column.\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                continue\n            max_col = max(max_col, i+j)\n    # Find the maximum sum of two numbers in the same diagonal.\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                continue\n            max_diag = max(max_diag, i+j)\n    # Return the maximum sum of two numbers in the same row,\n    # the maximum sum of two numbers in the same column,\n    # and the maximum sum of two numbers in the same diagonal.\n    return max(max_",
    "class Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        elif n == 2:\n            return max(nums[0], nums[1])\n        else:\n            left_max = self.maxSum(nums[:n/2])\n            right_max = self.maxSum(nums[n/2:])\n            return max(left_max, right_max) + nums[n/2]\n\n\nif __name__ == \"__main__\":\n    print Solution().maxSum([1,2,3])",
    "import math\n\ndef max_sum(n, m):\n    max_sum = 0\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0 or i == n-1 or j == n-1:\n                max_sum = max(max_sum, i*j)\n            else:\n                max_sum = max(max_sum, i*j - (i-1)*(j-1))\n    return max_sum\n\nprint max_sum(2, 3)\n\n\"\"\"\nInput: n = 3, m = 3\n\nOutput: 15\n\"\"\"",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        n = len(grid)\n        m = len(grid[0])\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= n or j >= m:\n                return 0\n            if grid[i][j] > 0:\n                return grid[i][j]\n            if i == 0 and j == 0:\n                return grid[i][j]\n            if i == 0:\n                return max(grid[i][j], grid[i + 1][j])\n            if j == 0:\n                return max(grid[i][j], grid[i][j + 1])\n            return max(grid[i][j], grid[i + 1][j + 1]) + dfs(i - 1, j - 1)\n        return dfs(n - 1, m - 1)",
    "class Solution:\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def maximalSquare(self, grid):\n        if not grid: return 0\n        m = len(grid)\n        n = len(grid[0])\n        max_sum = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    if grid[i][j] > max_sum:\n                        max_sum = grid[i][j]\n                else:\n                    if grid[i][j] > max_sum:\n                        max_sum = grid[i][j]\n                    else:\n                        max_sum = max(grid[i - 1][j - 1], grid[i - 1][j], grid[i - 1][j + 1], grid[i][j - 1], grid[i][j + 1], grid[i + 1][j - 1], grid[i + 1][j], grid[i + 1][j + 1])\n        return max_sum * max_sum\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.maximalSquare([[1,2],[3,4]])\n    print solution.maximalSquare([[1,2,3],[4,5,6],[7,8,9]])\n    print solution.maximalSquare([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])\n    print solution.maximalSquare([[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]])\n    print solution.maximalSquare([[-1,-2,-3],[-4,-5,-6],[-7,-8,-9],[-10,-11,-12]])",
    "class Solution(object):\n    def solve(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def helper(x, y, max_sum, grid):\n            if x < 0 or y < 0:\n                return 0\n            if x == grid[y].__len__() - 1:\n                return max(max_sum, grid[y][x])\n            if y == grid.__len__() - 1:\n                return max(max_sum, grid[x][y])\n            return max(max_sum, grid[x][y] + helper(x + 1, y, max_sum, grid) + helper(x, y + 1, max_sum, grid))\n\n        return helper(0, 0, 0, grid)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]\n    print(sol.solve(grid))",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return \"(%d, %d)\" % (self.x, self.y)\n    def __str__(self):\n        return \"(%d, %d)\" % (self.x, self.y)\n\nclass Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        m = len(grid[0])\n        if m == 0:\n            return 0\n        dp = [[0] * (m+1) for _ in range(n+1)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j-1] + grid[i][j], dp[i+1][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i][j-1] + grid[i][j], dp[i][j+1])\n                else:\n                    dp[i][j] = max(dp[i][j-1] + grid[i][j], dp[i][j+1] + grid[i][j])\n        return max(dp[n-1][m-1], dp[n-1][m])\n\nclass Solution2(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        m = len(grid[0])\n        if m == 0:\n            return 0\n        dp = [[0] * (m+1) for _ in range(n+1)]",
    "class Solution(object):\n    def maxSumSubmatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        if n == 0 or m == 0:\n            return 0\n\n        def maxSum(row, col, sum):\n            if row == m-1 and col == n-1:\n                return sum\n            if row < m-1 and col < n-1:\n                return max(maxSum(row+1, col, sum), maxSum(row, col+1, sum))\n            if row < m-1:\n                return max(maxSum(row+1, col, sum), sum)\n            if col < n-1:\n                return max(maxSum(row, col+1, sum), sum)\n            return sum\n\n        return maxSum(0, 0, 0)",
    "class Solution:\n    # @return an integer\n    def maxSumAdjacent(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        m = len(grid)\n        n = len(grid[0])\n        max_sum = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    continue\n                for k in range(i, m):\n                    if i!= k:\n                        if grid[k][j] == grid[i][j]:\n                            max_sum = max(max_sum, grid[i][j] + grid[k][j])\n        return max_sum",
    "# https://leetcode.com/problems/rectangle-sum/\n\n# brute force\n# time complexity: O(n^3)\n# space complexity: O(n^2)\n# for 2 x n, the brute force solution is O(n^3)\n# for 2 x n^2, the brute force solution is O(n^3)\n# for 3 x n^2, the brute force solution is O(n^3)\n# for 4 x n^2, the brute force solution is O(n^3)\n# for 5 x n^2, the brute force solution is O(n^3)\n# for 6 x n^2, the brute force solution is O(n^3)\n# for 7 x n^2, the brute force solution is O(n^3)\n# for 8 x n^2, the brute force solution is O(n^3)\n# for 9 x n^2, the brute force solution is O(n^3)\n# for 10 x n^2, the brute force solution is O(n^3)\n# for 11 x n^2, the brute force solution is O(n^3)\n# for 12 x n^2, the brute force solution is O(n^3)\n# for 13 x n^2, the brute force solution is O(n^3)\n# for 14 x n^2, the brute force solution is O(n^3)\n# for 15 x n^2, the brute force solution is O(n^3)\n# for 16 x n^2, the brute force solution is O(n^3)\n# for 17 x n^2, the brute force solution is O(n^3)\n# for 18 x n^2, the brute force solution is O(n^3)\n# for 19 x n^2, the brute force solution is O(n^3)\n# for 20 x n^2, the brute force solution is O(n^3)\n# for 21 x n^2, the brute force solution is O(n^3)\n# for 22 x n^2, the brute force solution is O(n^3)\n# for 23 x n^2, the brute force solution is O(n^3)\n# for 24 x n^2,",
    "def max_sum_of_adj_nums(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    m = len(grid)\n    n = len(grid[0])\n    max_sum = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            else:\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if grid[k][l] == 0:\n                            continue\n                        else:\n                            if grid[i][j] + grid[k][l] > max_sum:\n                                max_sum = grid[i][j] + grid[k][l]\n    return max_sum\n\nif __name__ == '__main__':\n    grid = [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]]\n    print(max_sum_of_adj_nums(grid))",
    "# @include\ndef max_sum_rectangular(grid):\n    max_sum = -float('inf')\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i == 0 or j == 0:\n                max_sum = max(max_sum, grid[i][j])\n            else:\n                max_sum = max(max_sum, grid[i][j] + grid[i - 1][j - 1])\n    return max_sum\n# @exclude\n\ndef main():\n    grid = [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 0, 0, 0], [0, 0, 0, 0]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n    print('max_sum_rectangular(grid) = {}'.format(max_sum_rectangular(grid)))\n    grid = [[0, 0, 0, 0",
    "class Solution:\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def maxSum(self, grid):\n        if not grid or not grid[0]:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        \n        # store the max sum in the previous row\n        max_sum = [[0 for j in range(n)] for i in range(m)]\n        max_sum[-1][-1] = max(grid[-1])\n\n        # calculate the max sum in the previous column\n        for i in range(m):\n            max_sum[i][-1] = max(grid[i][-1], grid[i][-2])\n\n        # calculate the max sum in the last row\n        for j in range(n):\n            max_sum[-1][j] = max(grid[-1][j], grid[-2][j])\n\n        # calculate the max sum in the last column\n        for i in range(m):\n            for j in range(n):\n                max_sum[i][j] = max(grid[i][j], grid[i-1][j], grid[i][j-1])\n\n        max_sum[0][0] = max(grid[0][0], grid[1][0])\n\n        # return the max sum\n        return max(max_sum)\n\nif __name__ == '__main__':\n    solution = Solution()\n    grid = [[1,2,3],[4,5,6],[7,8,9]]\n    print solution.maxSum(grid)\n    print solution.maxSum([[1,2],[3,4],[5,6]])",
    "def find_max_sum_in_rectangle(grid):\n    if len(grid) == 0:\n        return 0\n    n = len(grid)\n    max_sum = grid[0]\n    for i in range(1, n):\n        max_sum = max(max_sum, grid[i] + grid[i - 1])\n    return max_sum\n\ngrid = [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]\n\nprint(find_max_sum_in_rectangle(grid))",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        if n == 0 or m == 0:\n            return 0\n        if n == 1 or m == 1:\n            return grid[0][0]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if i == 1 or j == 1:\n                    dp[i][j] = grid[i - 1][j - 1]\n                elif i == n or j == m:\n                    dp[i][j] = grid[i - 1][j - 1] + grid[i - 1][j] + grid[i][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]\n        return dp[n][m]\n\nclass Solution2(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        if n == 0 or m == 0:\n            return 0\n        if n == 1 or m == 1:\n            return grid[0][0]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if i == 1 or j == 1:\n                    dp[i][j] = grid[i - 1][j - 1]\n                elif i == n or j == m:\n                    dp[i][j] = grid[i - 1][j - 1] + grid[i - 1][j] + grid[i][j - 1]\n                else:",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        # print(grid)\n        # print(n, m)\n        # print(grid[0][0], grid[0][1], grid[1][0], grid[1][1])\n        for i in range(n):\n            for j in range(m):\n                if i == 0 or j == 0 or i == n-1 or j == m-1:\n                    grid[i][j] = max(grid[i][j-1], grid[i][j+1])\n                else:\n                    grid[i][j] = max(grid[i][j-1], grid[i][j+1]) + grid[i][j]\n        # print(grid)\n        # print(grid[0][0], grid[0][1], grid[1][0], grid[1][1])\n        max_sum = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > max_sum:\n                    max_sum = grid[i][j]\n        return max_sum\n\ns = Solution()\ngrid = [[1,2,3],[1,4,5],[1,6,7]]\nprint(s.maxSum(grid))",
    "class Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maxSum(self, grid):\n        n = len(grid)\n        if n == 0:\n            return 0\n        m = len(grid[0])\n        if m == 0:\n            return 0\n        max_sum = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                if grid[i][j] == 1:\n                    grid[i][j] = 0\n                    curr_sum = self.maxSum(grid)\n                    if curr_sum > max_sum:\n                        max_sum = curr_sum\n                    grid[i][j] = 1\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    grid = [[1,1,1],[1,0,0],[1,1,1]]\n    print Solution().maxSum(grid)\n    grid = [[1,1,1],[1,0,0],[0,1,1]]\n    print Solution().maxSum(grid)",
    "import os\nimport sys\n\n# Complete the gridSolution function below.\ndef gridSolution(n, m):\n    # if m is 0, then return 0\n    if m == 0:\n        return 0\n    # if m is greater than n, then return 0\n    if m > n:\n        return 0\n    # if m is less than or equal to n, then return m\n    if m <= n:\n        return m\n    # if m is greater than n, then return 0\n    if m > n:\n        return 0\n    # if m is less than or equal to n, then return m\n    if m <= n:\n        return m\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    m = int(input())\n\n    fptr.write(str(gridSolution(n, m)) + '\\n')\n\n    fptr.close()",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or not grid[0]:\n            return 0\n\n        def maxSum(row, col):\n            res = 0\n            for i in range(col):\n                res = max(res, row[i])\n            return res\n\n        res = maxSum([maxSum(row, i) for i in range(len(row))], 0)\n        for i in range(len(grid) - 1):\n            res = max(res, maxSum([maxSum(row, i) for i in range(len(row))], i + 1))\n        return res",
    "class Solution(object):\n    def maxSumRectGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or not grid[0]:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        res = -(m + n) * 2 + 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    res = max(res, self.maxSum(grid, i, j))\n                else:\n                    res = max(res, self.maxSum(grid, i, j) + self.maxSum(grid, i + 1, j) + self.maxSum(grid, i, j + 1))\n        return res\n\n    def maxSum(self, grid, i, j):\n        if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n            return grid[i][j]\n        return max(grid[i - 1][j] + grid[i][j - 1], grid[i][j - 1] + grid[i + 1][j] + grid[i][j + 1])",
    "# https://leetcode.com/problems/max-sum-of-two-arrays/\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        m = len(grid)\n        n = len(grid[0])\n\n        # store the max sum\n        max_sum = -sys.maxsize - 1\n\n        # store the first max sum\n        first_max_sum = -sys.maxsize - 1\n\n        # store the last max sum\n        last_max_sum = -sys.maxsize - 1\n\n        # iterate through each row\n        for i in range(m):\n            # iterate through each column\n            for j in range(n):\n                # get the sum of the current row\n                sum_row = sum(grid[i])\n\n                # get the sum of the current column\n                sum_col = sum(grid[j])\n\n                # if the sum of the current row is greater than the sum of the current column\n                if sum_row > sum_col:\n                    # store the sum of the current row\n                    cur_sum = sum_row\n\n                    # store the current max sum\n                    cur_max_sum = sum_row\n\n                # if the sum of the current row is less than the sum of the current column\n                elif sum_row < sum_col:\n                    # store the sum of the current column\n                    cur_sum = sum_col\n\n                    # store the current max sum\n                    cur_max_sum = sum_col\n\n                # if the sum of the current row is equal to the sum of the current column\n                else:\n                    # store the sum of the current row\n                    cur_sum = sum_row\n\n                    # store the current max sum\n                    cur_max_sum = sum_row\n\n                # if the sum of the current row is greater than the max sum so far\n                if cur_sum > max_sum:\n                    # update the max sum\n                    max_sum = cur_sum\n\n                    # update the first max sum\n                    first_max_sum = cur_max_sum\n\n                    # update the last max sum",
    "# Your function will be called like this:\n# def maxSum(n, m)\n# where n is the size of the rectangular grid, and m is the number of elements in the grid.\n\n# Example:\n# Given the grid shown above, the function should return 6, since the maximum sum is 6.\n\n# Note:\n# The numbers in the grid are non-negative integers.\n# The length of grid[i] is in the range [1, n].\n\n# Company Tags: Google, Facebook\n# Tags: Math, Algorithm\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n\nclass Solution(object):\n    def maxSum(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if m == 1:\n            return n\n        if m == 2:\n            return n * (n + 1) // 2\n        if m % 2 == 1:\n            return self.maxSum(n, m - 1) + self.maxSum(n, m - 1)\n\n        left, right = 1, n - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if mid * (mid + 1) > m:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return self.maxSum(left, m - left) + self.maxSum(right, m - right)\n\nif __name__ == \"__main__\":\n    print Solution().maxSum(4, 8)",
    "class Solution(object):\n    def maximalSquare(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(x, y, matrix):\n            if x < 0 or y < 0 or x >= len(matrix) or y >= len(matrix[0]) or matrix[x][y] == 0:\n                return 0\n            return max(dfs(x+1, y, matrix), dfs(x, y+1, matrix)) + matrix[x][y]\n        return dfs(0, 0, matrix)\n\ns = Solution()\nmatrix = [[1,2,3],[4,5,6]]\nprint s.maximalSquare(matrix)",
    "#!/usr/bin/env python\n\nimport sys\n\ndef findMaxSum(n):\n    if n < 2:\n        return 0\n    maxSum = 0\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            maxSum += max(0, (i - 1) * (j - 1) + i * j)\n    return maxSum\n\ndef main(n):\n    return findMaxSum(n)\n\nif __name__ == \"__main__\":\n    n = int(sys.argv[1])\n    print(main(n))",
    "import unittest\n\ndef maximum_sum_grid(n):\n    max_sum = -1\n    for row in range(n):\n        for col in range(n):\n            sum_row = sum([row_data[row][col] for row_data in row_data_list])\n            sum_col = sum([col_data[col][row] for col_data in col_data_list])\n            sum_both = sum([row_data[row][col] for row_data in row_data_list for col_data in col_data_list])\n            if sum_row > max_sum:\n                max_sum = sum_row\n            if sum_col > max_sum:\n                max_sum = sum_col\n            if sum_both > max_sum:\n                max_sum = sum_both\n    return max_sum\n\nclass TestMaximumSumGrid(unittest.TestCase):\n\n    def test_maximum_sum_grid(self):\n        self.assertEqual(maximum_sum_grid(3), 15)\n        self.assertEqual(maximum_sum_grid(4), 25)\n        self.assertEqual(maximum_sum_grid(5), 25)\n        self.assertEqual(maximum_sum_grid(6), 30)\n        self.assertEqual(maximum_sum_grid(7), 45)\n        self.assertEqual(maximum_sum_grid(8), 45)\n        self.assertEqual(maximum_sum_grid(9), 45)\n        self.assertEqual(maximum_sum_grid(10), 45)\n        self.assertEqual(maximum_sum_grid(11), 45)\n        self.assertEqual(maximum_sum_grid(12), 45)\n        self.assertEqual(maximum_sum_grid(13), 45)\n        self.assertEqual(maximum_sum_grid(14), 45)\n        self.assertEqual(maximum_sum_grid(15), 45)\n\nif __name__ == '__main__':\n    unittest.main()",
    "# Definition for a point\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '<Point %s, %s>' % (self.x, self.y)\n\n    def __str__(self):\n        return str(self.x) +'' + str(self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or not grid[0]:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n\n        # find the max sum of each row\n        max_row = [0] * n\n        for i in range(m):\n            max_row[i] = grid[i][0]\n            for j in range(1, n):\n                max_row[i] = max(max_row[i], grid[i][j] + max_row[i - 1])\n\n        # find the max sum of each column\n        max_col = [0] * n\n        for j in range(n):\n            max_col[j] = grid[0][j]\n            for i in range(1, m):\n                max_col[j] = max(max_col[j], grid[i][j] + max_col[j - 1])\n\n        # find the max sum of each diagonal\n        max_diag = [0] * (m * n)\n        for i in range(m):\n            max_diag[i] = grid[i][i]\n            for j in range(n):\n                max_diag[i] = max(max_diag[i], grid[i][j] + max_diag[i - 1 + j * m])\n\n        # find the max sum of all the rectangles",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        max_sum = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\n                    max_sum = max(max_sum, grid[i][j] + grid[i][j-1] + grid[i][j+1] + grid[i-1][j] + grid[i+1][j])\n                else:\n                    max_sum = max(max_sum, grid[i][j] + grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i][j-1] + grid[i][j+1] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1])\n        return max_sum",
    "# https://discuss.leetcode.com/topic/82821/java-python-c-java-solution-in-4-lines\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        res = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                res[i] = max(res[i], res[j] + grid[i][j])\n        \n        return max(res)\n        \n\n# https://discuss.leetcode.com/topic/82821/java-python-c-java-solution-in-4-lines\n\nclass Solution2(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        res = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if grid[i][j] > 0:\n                    res[i] = max(res[i], res[j] + grid[i][j])\n        \n        return max(res)",
    "def max_sum_rectangle(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # base case\n    if len(grid) == 0:\n        return 0\n\n    # max sum of a rectangle\n    max_sum = grid[0][0]\n    for i in range(1, len(grid)):\n        max_sum = max(max_sum, grid[i][0] + grid[i - 1][1])\n\n    # max sum of a rectangle with the bottom row\n    for i in range(1, len(grid)):\n        max_sum = max(max_sum, grid[i][0] + grid[i - 1][-1])\n\n    return max_sum\n\nif __name__ == '__main__':\n    grid = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    assert(max_sum_rectangle(grid) == 14)",
    "#%%\n\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%\n#%%",
    "import math\n\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # dp\n        # nxn\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], grid[i][j]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], grid[i][j]) + grid[i][j]\n        # dp[i][j] = max(dp[i-1][j], grid[i][j]) + grid[i][j]\n        # dp[i][j] = max(grid[i][j]) + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i][j] + grid[i][j]\n        # dp[i][j] = grid[i",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        grid.sort(key=lambda x: x[0])\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n        return max(grid[-1][-1], grid[-1][-2])\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.maxSum([[1, 2, 1], [2, 2, 2], [1, 2, 1]]))\n    print(sol.maxSum([[1, 1], [1, 1], [1, 1]]))\n    print(sol.maxSum([[1, 1], [2, 1], [1, 1]]))\n    print(sol.maxSum([[1, 2, 1], [1, 2, 1], [1, 2, 1]]))",
    "def maximum_sum_of_adjacent_numbers(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not grid:\n        return 0\n\n    max_sum = 0\n    for row in grid:\n        for i in range(len(row)):\n            if i > 0 and row[i-1] + row[i] > max_sum:\n                max_sum = row[i-1] + row[i]\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    print(maximum_sum_of_adjacent_numbers(grid))",
    "class Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maxSumAdjacent(self, grid):\n        n = len(grid)\n        if n == 0:\n            return 0\n        else:\n            maxSum = 0\n            for i in range(n):\n                for j in range(n):\n                    if j > i:\n                        maxSum = max(maxSum, grid[i][j] + self.maxSumAdjacent(grid, i, j))\n            return maxSum\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.maxSumAdjacent([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    print(sol.maxSumAdjacent([[-1, -2, -3], [4, 5, 6], [7, 8, 9]]))\n    print(sol.maxSumAdjacent([[-1, 1, -2], [4, 5, 6], [7, 8, 9]]))\n    print(sol.maxSumAdjacent([[-1, -2, 1], [4, 5, 6], [7, 8, 9]]))",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def find_max_sum(grid, row, col, max_sum, prev_max_sum):\n            if row < 0 or row >= len(grid):\n                return\n            if col < 0 or col >= len(grid[0]):\n                return\n            if grid[row][col] > prev_max_sum:\n                return\n            if grid[row][col] == prev_max_sum:\n                if max_sum < grid[row][col] + grid[row][col-1]:\n                    max_sum = grid[row][col] + grid[row][col-1]\n                    prev_max_sum = grid[row][col]\n            else:\n                prev_max_sum = grid[row][col]\n                max_sum = grid[row][col]\n                find_max_sum(grid, row-1, col, max_sum, prev_max_sum)\n                find_max_sum(grid, row+1, col, max_sum, prev_max_sum)\n                find_max_sum(grid, row, col-1, max_sum, prev_max_sum)\n                find_max_sum(grid, row, col+1, max_sum, prev_max_sum)\n        \n        max_sum = 0\n        prev_max_sum = 0\n        find_max_sum(grid, len(grid)-1, 0, max_sum, prev_max_sum)\n        return max_sum\n\ns = Solution()\n\ngrid = [[3,1,4,7],[2,2,2,2],[1,1,1,1],[4,3,4,4]]\n\nprint(s.maxSum(grid))",
    "class Solution:\n    # @param {integer} n\n    # @param {integer[][]} grid\n    # @return {integer}\n    def maxSumAdjacent(self, n, grid):\n        # write your code here\n        result = [0] * (n + 1)\n        for i in range(n):\n            for j in range(i + 1, n):\n                result[j] = max(result[j], result[j - 1] + grid[i][j])\n        return max(result)",
    "class Solution(object):\n    def maxSumAdjacent(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(matrix)\n        m = len(matrix[0])\n        if n == 0 or m == 0:\n            return 0\n\n        result = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if matrix[j][i] == 1:\n                    result = max(result, self.find_max_sum_adjacent_row(i, j, matrix))\n                    result = max(result, self.find_max_sum_adjacent_col(i, j, matrix))\n                    result = max(result, self.find_max_sum_adjacent_diag(i, j, matrix))\n                    result = max(result, self.find_max_sum_adjacent_up(i, j, matrix))\n                    result = max(result, self.find_max_sum_adjacent_left(i, j, matrix))\n        return result\n\n    def find_max_sum_adjacent_row(self, i, j, matrix):\n        result = 0\n        for k in xrange(j - 1, 0, -1):\n            if matrix[k][i] == 1:\n                result = max(result, self.find_max_sum_adjacent_row(k, j, matrix))\n        return result\n\n    def find_max_sum_adjacent_col(self, i, j, matrix):\n        result = 0\n        for k in xrange(i - 1, 0, -1):\n            if matrix[i][k] == 1:\n                result = max(result, self.find_max_sum_adjacent_col(i, k, matrix))\n        return result\n\n    def find_max_sum_adjacent_diag(self, i, j, matrix):\n        result = 0\n        for k in xrange(i - 1, j - 1, -1):\n            if matrix[k][j] == 1:\n                result = max(result, self.find_max_sum_adjacent_diag(i",
    "import math\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().rstrip().split())))\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(n):\n            sum = grid[i][j] + grid[i][j+1] + grid[i+1][j] + grid[i+1][j+1]\n            if sum > max_sum:\n                max_sum = sum\n\n    print(max_sum)\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def solve(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        x = sorted(x)\n        ret = 0\n        for i in range(len(x)):\n            for j in range(i+1, len(x)):\n                ret = max(ret, x[i] + x[j])\n        return ret\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.solve(range(1, 5)))\n    print(sol.solve(range(1, 100)))",
    "import math\n\nclass Solution:\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def solve(self, grid):\n        n = len(grid)\n        for i in xrange(n):\n            for j in xrange(n):\n                for k in xrange(2):\n                    if k == 0:\n                        if grid[i][j] >= grid[i + 1][j]:\n                            return grid[i][j]\n                    elif k == 1:\n                        if grid[i][j] >= grid[i][j - 1]:\n                            return grid[i][j]\n        return 0\n\n\nif __name__ == '__main__':\n    grid = [[1, 2, 3], [1, 0, 0], [0, 0, 0]]\n    print Solution().solve(grid)",
    "from collections import defaultdict\nimport numpy as np\n\ndef max_sum(n):\n    \"\"\"\n    :param n: the dimensions of the rectangle\n    :return: the maximum sum of the two chosen numbers\n    \"\"\"\n    if n == 1:\n        return 0\n    # base case\n    if n == 2:\n        return max(0, min(\n            (2 * [sum(x) for x in [[0, 1], [1, 0]]]) +\n            [max(x) for x in [[1, 0], [0, 1], [0, -1], [-1, 0], [-1, -1]]]\n        ))\n    # recursion case\n    return max(max_sum(n - 1), max_sum(n - 2)) + min(\n        [max_sum(n - 1), max_sum(n - 2)],\n        [max_sum(n - 1, x) for x in [[1, 0], [0, 1], [0, -1], [-1, 0], [-1, -1]]]\n    )\n\nif __name__ == \"__main__\":\n    n = int(input())\n    assert n >= 2\n    print(max_sum(n))",
    "def grid_max_sum(grid):\n    max_sum = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if i == 0 and j == 0:\n                continue\n            else:\n                if grid[i][j] > max_sum:\n                    max_sum = grid[i][j]\n    return max_sum\n\ndef main():\n    grid = [[1,2,3],\n            [4,5,6],\n            [7,8,9]]\n    print grid_max_sum(grid)\n\nif __name__ == '__main__':\n    main()",
    "def find_max_sum(grid):\n    if grid[0] == grid[1] or grid[0] == grid[-1] or grid[-1] == grid[-2]:\n        return 0\n    else:\n        return max(find_max_sum(grid[0:-2]), find_max_sum(grid[1:-1])) + grid[0]\n\nif __name__ == \"__main__\":\n    grid = [1,2,3,4,5,6,7,8,9]\n    print(find_max_sum(grid))",
    "#!/bin/python\n\nfrom math import *\nimport sys\n\ndef get_max_sum(n):\n    return max(sum(row) for row in [[1]*n for _ in range(2)])\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print \"Usage: python {} <n>\".format(sys.argv[0])\n        sys.exit(0)\n    n = int(sys.argv[1])\n    print get_max_sum(n)",
    "class Solution(object):\n    def maxSumOfThree(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        if n == 1:\n            return grid[0][0]\n        \n        def helper(row, col):\n            if row == n-1:\n                return 0\n            if col == n-1:\n                return 0\n            if row == col:\n                return grid[row][col]\n            return max(grid[row][col], grid[row][col+1], grid[row+1][col])\n        \n        maxSum = 0\n        for row in xrange(n):\n            for col in xrange(n):\n                maxSum = max(maxSum, helper(row, col))\n        return maxSum",
    "import unittest\n\n\nclass Solution(object):\n    def maxSumRect(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        # if m > n, then no adjacent\n        # if m == n, then all adjacent\n        # if m < n, then all adjacent\n        return max(sum([i, j] for i in range(n) for j in range(m)) + [0] for _ in range(m))\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-sum-rectangle/solution/\n#\nApproach #1: Brute Force [Accepted]\nComplexity Analysis\nTime Complexity: O(n^2 m), where n is the size of the grid and m is the number of rows and columns.\nSpace Complexity: O(n^2 m), where n is the size of the grid and m is the number of rows and columns.\n\n# 2ms 100%\nclass Solution {\n    public int maxSumRect(int n, int m) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = dp[i][j - 1] + dp[i][j + 1] + dp[i + 1][j] - dp[i - 1][j];\n            }\n        }\n        return dp[0][0];\n    }\n}\n\nApproach #2: DFS [Accepted]\nComplexity Analysis\nTime Complexity: O(n^2 m), where n is the size of the grid and m is the number of rows and columns.\nSpace Complexity: O(n^2 m), where n is the size of the grid and m is the number of rows and columns.\n\n# 2ms",
    "def get_max_sum(grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 1:\n                max_sum = max(max_sum, grid[i][j] + get_max_sum(grid[:i] + grid[i + 1:]))\n    return max_sum\n\nif __name__ == '__main__':\n    grid = [[1, 2, 3], [1, 1, 1], [1, 1, 1]]\n    print(get_max_sum(grid))",
    "class Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        \n        for i in range(1, n):\n            for j in range(1, m):\n                if i == 1 or j == 1:\n                    dp[i][j] = grid[i-1][j-1]\n                elif i-2 >= 0 and j-2 >= 0:\n                    dp[i][j] = max(dp[i-1][j-1] + grid[i-1][j-2], dp[i-2][j-1] + grid[i-1][j-1])\n                elif i-2 >= 0:\n                    dp[i][j] = max(dp[i-1][j-1] + grid[i-1][j-2], dp[i-1][j] + grid[i-1][j-1])\n                elif j-2 >= 0:\n                    dp[i][j] = max(dp[i][j-1] + grid[i-1][j-2], dp[i][j-2] + grid[i-1][j-1])\n        return max(dp[-1][-1], max(dp[-1][-2], dp[-2][-1]))",
    "import math\n\ndef solve(n, grid):\n    \"\"\"\n    :type n: int\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # if n is 1, then the grid is empty\n    if n == 1:\n        return 0\n\n    # if n is 2, then the grid is only one rectangle\n    if n == 2:\n        for i in range(0, len(grid)):\n            for j in range(i + 1, len(grid)):\n                if grid[i][j] == 1:\n                    return grid[i][j]\n        return 0\n\n    # if n is 3, then the grid is three rectangles\n    if n == 3:\n        for i in range(0, len(grid)):\n            for j in range(i + 1, len(grid)):\n                for k in range(j + 1, len(grid)):\n                    if grid[i][j] == 1 and grid[i][k] == 1 and grid[j][k] == 1:\n                        return grid[i][j] + grid[i][k] + grid[j][k]\n        return 0\n\n    # if n is 4, then the grid is four rectangles\n    if n == 4:\n        for i in range(0, len(grid)):\n            for j in range(i + 1, len(grid)):\n                for k in range(j + 1, len(grid)):\n                    for l in range(k + 1, len(grid)):\n                        if grid[i][j] == 1 and grid[i][k] == 1 and grid[j][l] == 1 and grid[k][l] == 1:\n                            return grid[i][j] + grid[i][k] + grid[j][l] + grid[k][l]\n        return 0\n\n    # otherwise, the grid is n x n\n    if n == len(grid):\n        return 0\n\n    # otherwise, the grid is n x n\n    return solve(n - 1, grid) + solve(n - 1, grid[:n - 1])\n\nif __name__ == '__main__':\n    # grid = [[1, 1], [1, 0",
    "#!/usr/bin/python\n\nclass Solution:\n    # @param {integer[][]} grid\n    # @return {integer}\n    def solve(self, grid):\n        if len(grid) == 0:\n            return 0\n        else:\n            m = len(grid[0])\n            n = len(grid)\n            \n            # write your code here\n            dp = [[0 for i in range(m)] for j in range(n)]\n            \n            for i in range(m):\n                for j in range(n):\n                    if (i == 0 or j == 0) or (i == m-1 or j == n-1):\n                        dp[i][j] = grid[i][j]\n                    else:\n                        dp[i][j] = max(grid[i-1][j-1] + grid[i-1][j], grid[i-1][j] + grid[i][j-1])\n            \n            for i in range(m):\n                for j in range(n):\n                    if (i == 0 or j == 0) or (i == m-1 or j == n-1):\n                        dp[i][j] = grid[i][j]\n                    else:\n                        dp[i][j] = max(grid[i-1][j-1] + grid[i-1][j], grid[i-1][j] + grid[i][j-1])\n            \n            for i in range(m):\n                for j in range(n):\n                    if (i == 0 or j == 0) or (i == m-1 or j == n-1):\n                        dp[i][j] = grid[i][j]\n                    else:\n                        dp[i][j] = max(grid[i-1][j-1] + grid[i-1][j], grid[i-1][j] + grid[i][j-1])\n            \n            for i in range(m):\n                for j in range(n):\n                    if (i == 0 or j == 0) or (i == m-1 or j == n-1):\n                        dp[i][j] = grid[i][j]\n                    else:\n                        dp[i"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}