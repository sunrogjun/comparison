{
  "problem": {
    "task_id": "MBPP/402",
    "prompt": "Write a function to compute the value of ncr%p.",
    "canonical_solution": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ",
    "test_list": [
      "assert ncr_modp(10,2,13)==6",
      "assert ncr_modp(15,12,43)==25",
      "assert ncr_modp(17,9,18)==10"
    ],
    "challenge_test_list": [],
    "problem_id": 391
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r == 0 or n == r:\n            return 1\n        if n == 0:\n            return 0\n        if r > n:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n        if n == 0 or r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.ncr(n - 1, r - 1) * (n - r + 1) / r\n\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return self.ncr(n, r - 1) * (n - r + 1) / r\n\n\nif __name__ == \"__main__\":\n    Solution().ncr(5, 3)",
    "from __future__ import annotations\n\n\ndef ncr(n: int, p: int) -> int:\n    \"\"\"\n    Compute ncr(n, p)\n\n    :param n: The number of elements in the set\n    :param p: The number of elements in the set\n    :return: The ncr(n, p)\n    \"\"\"\n    if n == 0:\n        return 0\n    if p == 0:\n        return 1\n    if n == 1:\n        return p\n    if p == 1:\n        return n\n    if n < p:\n        return ncr(n, p - 1)\n    if p < n:\n        return ncr(p, n - 1)\n    return ncr(n - 1, p - 1) + ncr(n - 1, p)\n\n\nif __name__ == \"__main__\":\n    print(ncr(5, 3))",
    "class Solution:\n    \"\"\"\n    @param n: An integer\n    @param p: An integer\n    @return: An integer\n    \"\"\"\n    def ncr(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 0:\n            return 0\n        if p == 1:\n            return n\n        if p == n:\n            return 1\n        return self.ncr(n, p - 1) * self.ncr(n - 1, p - 1) / p",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return self.ncr_dp(n, r, 0, 1)\n\n    def ncr_dp(self, n, r, prev, curr):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r == 0:\n            return curr\n        if r == 1:\n            return prev\n        if r < 0:\n            return self.ncr_dp(n, r + 1, prev, curr)\n        if n == r:\n            return 1\n        if n < r:\n            return self.ncr_dp(n, r - 1, curr, prev)\n        return self.ncr_dp(n - 1, r, prev, curr * prev)",
    "# https://oj.leetcode.com/problems/ncr-problem/\n# Given a non-negative integer n and a non-empty array of non-negative integers representing a histogram h,\n\n# find the percentage of non-empty buckets in the histogram that contain more than one element.\n#\n# Example 1:\n#\n# Input: n = 3, h = [1,1,2]\n# Output: 50%\n# Explanation: Among the three buckets [1,2], [1,1] and [2,1], \n# one has only one element so 50% of them.\n#\n# Example 2:\n#\n# Input: n = 4, h = [3,2,3,2]\n# Output: 33.33%\n# Explanation: Among the four buckets [3,2], [3,3] and [2,3], \n# two have only one element so 33.33% of them.\n# Note:\n#\n# The length of h will be in the range [1, 20000].\n# h[i] will be in the range [0, h[i-1]].\n# h[i] will not be equal to 0.\n# n will be a non-negative integer.\n# All the integers in h will be in the range [0, 10^9].\n\n\nclass Solution:\n    # @param {integer} n\n    # @param {integer[]} h\n    # @return {integer}\n    def ncr(self, n, h):\n        n_sum = sum(h)\n        if n_sum == 0:\n            return 0\n        ncr = 0\n        for i in range(1, n+1):\n            ncr += self.ncr(n-i, h) * i / n_sum\n        return ncr\n\n\nif __name__ == '__main__':\n    assert Solution().ncr(3, [1, 1, 2]) == 50\n    assert Solution().ncr(4, [3, 2, 3, 2]) == 33.33",
    "from utils import read_int\n\n\ndef main():\n    \"\"\"\n    Sample Input:\n    4\n    3 5\n    2 4\n    3 4\n    Sample Output:\n    0\n    1\n    1\n    \"\"\"\n    n, p = read_int(), read_int()\n    n, p = map(int, (n, p))\n    return n % p\n\n\nif __name__ == \"__main__\":\n    main()",
    "def ncr(n, r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    return (r + n - 1) / (r + 1)\n\nif __name__ == '__main__':\n    print(ncr(10, 3))\n    print(ncr(10, 4))\n    print(ncr(10, 5))\n    print(ncr(10, 6))\n    print(ncr(10, 7))",
    "# Definition for ncr\nclass Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        res = 1\n        for i in range(n):\n            res *= r - i\n            res /= i + 1\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.ncr(3, 2)\n    print sol.ncr(1, 1)\n    print sol.ncr(1, 2)\n    print sol.ncr(2, 2)",
    "def ncr_mod(n,p):\n    \"\"\"\n    Compute the value of ncr%p.\n    \"\"\"\n    return sum(x%p for x in range(1,n+1))\n\nif __name__ == '__main__':\n    print(ncr_mod(4,2))\n    print(ncr_mod(5,2))\n    print(ncr_mod(10,3))\n    print(ncr_mod(12,3))\n    print(ncr_mod(12,2))\n    print(ncr_mod(12,5))",
    "def ncr(n,r,p):\n    \"\"\"\n    >>> ncr(2,3,3)\n    2\n    >>> ncr(2,3,4)\n    1\n    >>> ncr(2,3,5)\n    0\n    >>> ncr(2,3,6)\n    1\n    >>> ncr(2,3,7)\n    0\n    >>> ncr(3,3,3)\n    1\n    >>> ncr(3,3,4)\n    0\n    >>> ncr(3,3,5)\n    1\n    >>> ncr(3,3,6)\n    1\n    >>> ncr(3,3,7)\n    1\n    >>> ncr(3,3,8)\n    1\n    >>> ncr(3,3,9)\n    1\n    >>> ncr(3,3,10)\n    1\n    \"\"\"\n    return (n*(r-1))/p\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "import unittest\n\nclass Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r == 1:\n            return n\n        elif r == n:\n            return 1\n        elif r > n:\n            return 0\n        elif r == n-1:\n            return 1\n        else:\n            return self.ncr(n-r, r) + self.ncr(n-r-1, r-1)\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/n-ary-tree-number-of-containers/solution/\n\nApproach #1: Recursion [Accepted]\nComplexity Analysis\nTime Complexity: O(nlog(n))\nSpace Complexity: O(1)\n\n# 5ms 100%\nclass Solution {\n    public int ncr(int n, int r) {\n        if (r == 1) return n;\n        else if (r == n) return 1;\n        else if (r > n) return 0;\n        else {\n            return ncr(n-r, r) + ncr(n-r-1, r-1);\n        }\n    }\n}\n\n# 3ms 100%\nclass Solution {\n    public int ncr(int n, int r) {\n        if (r == 1) return n;\n        else if (r == n) return 1;\n        else {\n            return ncr(n-r, r-1) + ncr(n-r-1, r);\n        }\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public int ncr(int n, int r) {\n        if (r == 1) return n;\n        else if (r == n) return 1;\n        else {\n            int num = 1;\n            for (int",
    "def ncr(n, p):\n    \"\"\"\n    Compute the value of ncr%p.\n    n, p - positive integers\n    returns the value of ncr%p\n    \"\"\"\n    if n == 0 or p == 0:\n        return 0\n    if n == 1 or p == 1:\n        return 1\n    return ncr(n - 1, p) + ncr(n - 1, p - 1)\n\n\nif __name__ == \"__main__\":\n    print(ncr(3, 2))\n    print(ncr(6, 2))\n    print(ncr(7, 4))\n    print(ncr(7, 7))\n    print(ncr(11, 2))",
    "from collections import Counter\nfrom functools import reduce\n\n\ndef ncr(n, r, p):\n    return reduce(lambda x, y: x * (r - y) / y, range(n), 1) * p / (n * p)\n\n\ndef main():\n    n, r, p = map(int, input().strip().split())\n    print(ncr(n, r, p))\n\n\nif __name__ == '__main__':\n    main()",
    "def ncr(n,r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    ans = 1\n    for i in range(1,r+1):\n        ans *= n\n        ans %= i\n    return ans\n\n\nprint(ncr(5,2))",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        if r == 0:\n            return 1\n        if n == 1:\n            return r\n        if r == 1:\n            return n\n        if r == n:\n            return 1\n        if r > n:\n            return 0\n        \n        ret = 1\n        for i in range(2, r + 1):\n            ret *= n\n            ret /= i\n        return ret\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.ncr(2, 4))\n    print(s.ncr(10, 20))\n    print(s.ncr(9, 4))\n    print(s.ncr(8, 4))\n    print(s.ncr(9, 4))\n    print(s.ncr(9, 6))\n    print(s.ncr(9, 7))\n    print(s.ncr(9, 8))\n    print(s.ncr(9, 9))\n    print(s.ncr(9, 10))\n    print(s.ncr(9, 11))\n    print(s.ncr(9, 12))\n    print(s.ncr(9, 13))\n    print(s.ncr(9, 14))\n    print(s.ncr(9, 15))\n    print(s.ncr(9, 16))\n    print(s.ncr(9, 17))\n    print(s.ncr(9, 18))\n    print(s.ncr(9, 19))\n    print(s.ncr(9, 20))",
    "import math\n\ndef ncr(n,r):\n    return math.factorial(n) / math.factorial(r) / math.factorial(n-r)\n\ndef main():\n    print ncr(5,1)\n    print ncr(5,3)\n    print ncr(5,2)\n    print ncr(5,4)\n    print ncr(5,3)\n    print ncr(5,5)\n    print ncr(5,6)\n    print ncr(5,7)\n    print ncr(5,8)\n    print ncr(5,9)\n    print ncr(5,10)\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {integer}\n    def recursive(self, p, q):\n        if p is None:\n            return 0\n        if q is None:\n            return 0\n        if p.val == q.val:\n            return 1\n        else:\n            return self.recursive(p.left, q) + self.recursive(p.right, q)\n    \n    def ncr(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.recursive(p, q)\n\n# Note:\n# The complexity of this method is O(n) in space, and O(n) in time",
    "#!/usr/bin/env python\n\ndef ncr(n, r):\n    \"\"\"\n    n, r - the values of n and r in the formula\n    return the ncr value\n    \"\"\"\n    return reduce(lambda a, b: a * (r - b) / b, range(1, r + 1), 1) % n\n\nif __name__ == \"__main__\":\n    print ncr(5, 3)",
    "from __future__ import print_function\nfrom collections import Counter\n\n\ndef ncr(a, b, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    :param a: The first number.\n    :param b: The second number.\n    :param p: The third number.\n    :return: The value of ncr%p.\n    \"\"\"\n    # Count the number of zeros in p.\n    zero_count = 0\n    for i in range(1, p):\n        if (p % i) == 0:\n            zero_count += 1\n    # Count the number of ones in p.\n    one_count = 0\n    for i in range(1, p):\n        if (p % i) == 1:\n            one_count += 1\n    # Count the number of ones in a and b.\n    a_one_count = 0\n    b_one_count = 0\n    for i in range(1, a):\n        if (a % i) == 1:\n            a_one_count += 1\n    for i in range(1, b):\n        if (b % i) == 1:\n            b_one_count += 1\n    # If p is 1, return the number of ones in a and b.\n    if (p == 1):\n        return a_one_count + b_one_count\n    # If p is 0, return the number of zeros in a and b.\n    if (p == 0):\n        return a_one_count + b_one_count + zero_count\n    # If p is not 0, return the number of ones in a and b.\n    return a_one_count + b_one_count + zero_count - one_count\n\n\ndef test_ncr():\n    \"\"\"\n    Test for ncr.\n    \"\"\"\n    assert ncr(3, 4, 2) == 0\n    assert ncr(5, 4, 2) == 1\n    assert ncr(5, 5, 2) == 1\n    assert ncr(6, 5, 2) == 2\n    assert ncr(6, 6, 2) == 1\n    assert ncr(7, 5, 2) == 2\n    assert ncr(",
    "import math\n\ndef ncr(n, r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    if r == 2:\n        return n * (n - 1) // 2\n    res = 0\n    for i in range(n + 1):\n        res += ncr(n - i, r - 1) * i\n    return res\n\n# Your ncr_modp solution here\n# n = 4, r = 3\n# res = 1\n# ncr(4, 3) = 1 * 4 * 2 / 2 = 2\n# ncr(4, 2) = 1 * 4 * 3 / 2 = 3\n# ncr(4, 1) = 1 * 4 * 4 / 2 = 4\n# ncr(4, 0) = 1 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -1) = 1 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -2) = 1 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -3) = 1 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -4) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -5) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -6) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -7) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -8) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# ncr(4, -9) = 1 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 / 2 = 4\n# n",
    "import math\n\n\ndef ncr(n, r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    if r == 0:\n        return 0\n    if n == 0 or r == 1:\n        return 1\n    if r > n:\n        return 0\n    ncr = 0\n    for i in range(2, r + 1):\n        ncr += n * ncr(n - i, i)\n    return ncr\n\n\ndef main():\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert ncr(1, 1) == 1, \"1st example\"\n    assert ncr(1, 2) == 0, \"2nd example\"\n    assert ncr(2, 1) == 1, \"3rd example\"\n    assert ncr(2, 2) == 1, \"4th example\"\n    assert ncr(3, 2) == 2, \"5th example\"\n    assert ncr(3, 3) == 1, \"6th example\"\n    assert ncr(5, 2) == 2, \"7th example\"\n    assert ncr(5, 3) == 4, \"8th example\"\n    assert ncr(5, 5) == 1, \"9th example\"\n    assert ncr(8, 3) == 6, \"10th example\"\n\n\nif __name__ == '__main__':\n    main()",
    "def ncr(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 0 or n == 0:\n        return 1\n    if p == 1 or n == 1:\n        return 1\n    if p == 2 or n == 2:\n        return 2\n    if n <= 0 or p <= 0:\n        return 0\n    return ncr(n - 1, p - 1) + ncr(n - 1, p)\n\nif __name__ == '__main__':\n    n = int(input())\n    p = int(input())\n    print(ncr(n, p))",
    "def ncr(n,r,p):\n    return (r-p)*ncr(n-1,r,p)\n\ndef main():\n    print(ncr(3,4,2))\n\nif __name__ == \"__main__\":\n    main()",
    "def ncr(n, r):\n    \"\"\"\n    >>> ncr(3, 2)\n    2\n    >>> ncr(5, 2)\n    2\n    >>> ncr(3, 4)\n    0\n    >>> ncr(5, 4)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    if r == 1:\n        return n\n    if r == 0:\n        return 0\n    if r == n:\n        return 1\n    if r > n:\n        return 0\n    if r == n-1:\n        return 1\n    if r == n-2:\n        return n-1\n    if r == n-3:\n        return n-2\n    if n % r == 0:\n        return ncr(n/r, r)\n    else:\n        return ncr(n-1, r) + ncr(n-1, r-1)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "def ncr(n,p):\n\treturn ((p-1)/(p-1-n))*ncr(n-1,p-1)\n\ndef main():\n\tn = int(input())\n\tp = int(input())\n\tprint(ncr(n,p))\n\nif __name__ == \"__main__\":\n\tmain()",
    "def ncr(n, r, p):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    ncr = 1\n    for i in range(n - r + 1):\n        ncr *= p\n        ncr /= (i + 1)\n    return ncr % p\n\n# test cases\n# input: n, r, p\n# output: ncr(n, r, p)\n# ncr(10, 3, 4) -> 3\n# ncr(10, 3, 5) -> 0\n# ncr(10, 3, 7) -> 2\n\n# time: O(n)\n# space: O(n)",
    "import math\n\ndef ncr_p(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n    n, r and p are all integers.\n    \"\"\"\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    if p == 0:\n        return 1\n    if p == 1:\n        return 1\n    if p == 2:\n        return n\n    if p % 2 == 0:\n        return ncr_p(n, r-1, p/2) * ncr_p(n-1, r-1, p/2)\n    else:\n        return ncr_p(n, r-1, p-1) * ncr_p(n-1, r-1, p-1)\n\nif __name__ == '__main__':\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(ncr_p(n, r, p))",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return (n * (n - 1) // r) // (n - r)",
    "def ncr_mod_p(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 1:\n        return 1\n    if p == 2:\n        return n\n    if p % 2 == 0:\n        return (ncr_mod_p(n, p // 2) * ncr_mod_p(n - 1, p // 2)) % p\n    return (ncr_mod_p(n, p - 1) * ncr_mod_p(n - 1, p - 1)) % p\n\nprint(ncr_mod_p(10, 5))",
    "# https://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/83561/Java-O(n)-Space-O(n)-Time\nclass Solution:\n    # @param s, a string\n    # @param p, a string\n    # @return an integer\n    def findNcr(self, s, p):\n        p = p.split(\"\")\n        p_len = len(p)\n        if p_len == 0:\n            return 1\n        n = len(s)\n        if n == 0:\n            return 0\n        if p_len == 1:\n            return self.findNcr_1(s, p[0])\n        if p_len == 2:\n            return self.findNcr_2(s, p[0], p[1])\n        if n % p_len!= 0:\n            return 0\n        if n == 1:\n            return 1\n        else:\n            return self.findNcr_2(s, p[0], p[1]) * self.findNcr_2(s, p[1], p[0])\n    \n    def findNcr_1(self, s, p):\n        n = len(s)\n        if n == 0:\n            return 1\n        if n == 1:\n            return p == s\n        if p == s:\n            return 1\n        else:\n            return self.findNcr_1(s, p[1:]) * self.findNcr_1(s, p[0:])\n    \n    def findNcr_2(self, s, p, q):\n        n = len(s)\n        if n == 0:\n            return 1\n        if n == 1:\n            return p == s\n        if p == q:\n            return 1\n        if p == s or q == s:\n            return 0\n        else:\n            return self.findNcr_2(s, p, q) * self.findNcr_2(s, p, q) * self.findNcr_2(s, p, q) * self.findNcr_2(s, p, q)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def getPath(self, root: TreeNode, path: List[int], p: int) -> List[int]:\n        if not root:\n            return []\n        if root.left:\n            path.append(root.left.val)\n        if root.right:\n            path.append(root.right.val)\n        if root.val % p == 0:\n            return self.getPath(root.left, path, p) + self.getPath(root.right, path, p)\n        else:\n            return []",
    "def ncr(n,r,p):\n    \"\"\"\n    :param n: int\n    :param r: int\n    :param p: int\n    :return: int\n    \"\"\"\n    if n==0 or r==0 or p==0:\n        return 0\n    if p>r:\n        return ncr(n,r,p-r)\n    if p==1:\n        return n/r\n    if p%2==1:\n        return ncr(n-r,r,p-1)/(p-1)\n    return ncr(n-r,r-1,p-2)/(p-2)\n\n# Test Cases\n\nprint ncr(5,3,3)\nprint ncr(5,3,5)\nprint ncr(5,3,10)\nprint ncr(5,3,13)\nprint ncr(5,3,15)\nprint ncr(5,3,16)\nprint ncr(5,3,17)\nprint ncr(5,3,18)\nprint ncr(5,3,19)\nprint ncr(5,3,20)\nprint ncr(5,3,21)\nprint ncr(5,3,22)\nprint ncr(5,3,23)\nprint ncr(5,3,24)\nprint ncr(5,3,25)\nprint ncr(5,3,26)\nprint ncr(5,3,27)\nprint ncr(5,3,28)\nprint ncr(5,3,29)\nprint ncr(5,3,30)\nprint ncr(5,3,31)\nprint ncr(5,3,32)\nprint ncr(5,3,33)\nprint ncr(5,3,34)\nprint ncr(5,3,35)\nprint ncr(5,3,36)\nprint ncr(5,3,37)\nprint ncr(5,3,38)\nprint ncr(5,3,39)\nprint ncr(5,3,40)\nprint ncr(5,3,41)\nprint ncr(5,3,42)\nprint ncr",
    "import math\n\ndef ncr(n, r):\n    return math.factorial(n) / math.factorial(r) / math.factorial(n-r)\n\ndef ncr_prime(n, r):\n    return math.factorial(n) / (math.factorial(r) * math.factorial(n-r))\n\ndef ncr_prime_mod(n, r):\n    return ncr_prime(n, r) % (math.factorial(r))\n\ndef ncr_mod(n, r):\n    return (ncr(n, r) * math.factorial(r)) % (math.factorial(n))\n\ndef ncr_mod_prime(n, r):\n    return (ncr_prime(n, r) * math.factorial(r)) % (math.factorial(n))\n\nif __name__ == '__main__':\n    print(ncr(20, 5))\n    print(ncr_prime(20, 5))\n    print(ncr_prime_mod(20, 5))\n    print(ncr_mod(20, 5))\n    print(ncr_mod_prime(20, 5))\n    print(ncr_mod_prime(20, 6))\n    print(ncr_mod_prime(20, 7))\n    print(ncr_mod_prime(20, 8))\n    print(ncr_mod_prime(20, 9))\n    print(ncr_mod_prime(20, 10))\n    print(ncr_mod_prime(20, 11))\n    print(ncr_mod_prime(20, 12))\n    print(ncr_mod_prime(20, 13))\n    print(ncr_mod_prime(20, 14))\n    print(ncr_mod_prime(20, 15))\n    print(ncr_mod_prime(20, 16))\n    print(ncr_mod_prime(20, 17))\n    print(ncr_mod_prime(20, 18))\n    print(ncr_mod_prime(20, 19))\n    print(ncr_mod_prime(20, 20))\n    print(ncr_",
    "import math\n\ndef ncr(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 0:\n        return 0\n    if n == 0:\n        return 1\n    if p == 1:\n        return n\n    if p == 2:\n        return n*(n + 1)/2\n    if p == 3:\n        return n*(n + 1)*(2*n + 1)/6\n    if p == 4:\n        return n*(n + 1)*(2*n + 3)/6\n    if p == 5:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)/20\n    if p == 6:\n        return n*(n + 1)*(2*n + 1)*(3*n + 3)/20\n    if p == 7:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 1)/42\n    if p == 8:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 3)/42\n    if p == 9:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 1)*(5*n + 1)/105\n    if p == 10:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 1)*(5*n + 3)/105\n    if p == 11:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 1)*(5*n + 1)*(6*n + 1)/105\n    if p == 12:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*(4*n + 1)*(5*n + 3)*(6*n + 1)/105\n    if p == 13:\n        return n*(n + 1)*(2*n + 1)*(3*n + 1)*",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.res = 0\n        self.max_res = 0\n\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r < 0 or n < r:\n            return 0\n        if n == 0 or r == 0:\n            return 1\n        if r == 1:\n            return n\n        ncr = self.ncr(n-1, r-1)\n        ncr += self.ncr(n-1, r)\n        ncr += self.ncr(n-1, r-1)\n        return ncr\n\n    def ncr_recursive(self, n, r):\n        if r == 0:\n            return 1\n        if n == 0 or r == 1:\n            return 1\n        if r == 2:\n            return n\n        if r == 3:\n            return self.ncr_recursive(n-1, 1)\n        res = self.ncr_recursive(n-1, r-1)\n        res += self.ncr_recursive(n-1, r)\n        res += self.ncr_recursive(n-1, r-1)\n        return res\n\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or r == 0:\n            return 1\n        if n == 1 or r == 1:\n            return 1\n        if r == 2:\n            return n\n        if r == 3:\n            return self.ncr(n-1, 1)\n        res = self.ncr(n-1, r-1)\n        res += self.ncr(n-1, r)\n        res += self.ncr(n-1, r",
    "def ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> Returns the number of combinations of k elements that\n    can be selected out of n without repeating any element.\n    \"\"\"\n    if r == 1 or n == r:\n        return 1\n    elif r > n / 2:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif r == 2:\n        return n - 1\n    else:\n        return ncr(n - 1, r - 1) + ncr(n - 1, r - 2)\n\nprint(ncr(1, 3))",
    "class Solution:\n    \"\"\"\n    @param: n, k, p: positive integer\n    @return: the value of ncr%p\n    \"\"\"\n    def ncr(self, n, k, p):\n        return self.ncr_rec(n, k, p, 0, 1)\n\n    def ncr_rec(self, n, k, p, i, j):\n        if k == 0:\n            return 1\n        elif i == j:\n            return (n + k - 1) * self.ncr_rec(n - 1, k - 1, p, i + 1, j)\n        else:\n            return self.ncr_rec(n, k - 1, p, i, j - 1) * self.ncr_rec(n - 1, k - 1, p, i + 1, j)",
    "import sys\n\nclass Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        ncr = [0] * (r + 1)\n        for i in range(n + 1):\n            ncr[0] += i\n        for i in range(1, r + 1):\n            for j in range(1, n + 1):\n                ncr[i] += ncr[i - 1] * j\n        return ncr[r]\n\nif __name__ == '__main__':\n    sol = Solution()\n    n = int(sys.argv[1])\n    r = int(sys.argv[2])\n    print(sol.ncr(n, r))",
    "def ncr(n, r, p):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 0:\n        return 1\n    if r > n:\n        return 0\n    if r == 1 or r == n - 1:\n        return 1\n    if r > n / 2:\n        return (ncr(n, r - 1, p) + ncr(n - r, r - 1, p)) % p\n    if r % 2 == 1:\n        return (ncr(n, r, p) + ncr(n - r, r - 1, p)) % p\n    else:\n        return (ncr(n, r, p) + ncr(n - r, r - 2, p)) % p\n\n\nif __name__ == '__main__':\n    assert ncr(4, 3, 2) == 3, \"1\"\n    assert ncr(4, 3, 3) == 0, \"2\"\n    assert ncr(4, 3, 4) == 1, \"3\"\n    assert ncr(4, 3, 5) == 0, \"4\"\n    assert ncr(4, 3, 6) == 1, \"5\"\n    assert ncr(4, 3, 7) == 0, \"6\"\n    assert ncr(4, 3, 8) == 1, \"7\"\n    assert ncr(4, 3, 9) == 0, \"8\"\n    assert ncr(4, 3, 10) == 1, \"9\"\n    assert ncr(4, 3, 11) == 0, \"10\"\n    assert ncr(4, 3, 12) == 1, \"11\"\n    assert ncr(4, 3, 13) == 0, \"12\"\n    assert ncr(4, 3, 14) == 1, \"13\"\n    assert ncr(4, 3, 15) == 0, \"14\"\n    assert ncr(4, 3, 16) == 1, \"15\"\n    assert ncr(4, 3, 17) == 0, \"16\"\n    assert ncr(4, 3, 18) == 1, \"17",
    "def ncr(n, r, p):\n    \"\"\"\n    ncr(n,r,p) -> value of ncr(n,r,p)\n    \"\"\"\n    # https://en.wikipedia.org/wiki/Combination_rule\n    return ncr_recursion(n, r, p, 1)\n\ndef ncr_recursion(n, r, p, val):\n    if n == r:\n        return val\n    if n == 0 or r == 0:\n        return 0\n    if n == 1 or r == 1:\n        return p\n    return ncr_recursion(n-1, r, p, val*p)\n\nif __name__ == \"__main__\":\n    for n in range(1, 10):\n        for r in range(1, 10):\n            for p in range(1, 10):\n                print n, r, p, ncr(n, r, p)",
    "def ncr(n,r,p):\n    \"\"\"\n    n,r,p: int\n    return: int\n    \"\"\"\n    if r>n:\n        return 0\n    if r==1:\n        return p\n    if r==n:\n        return 1\n    if r==n-1:\n        return p\n    return ncr(n-1,r-1,p)*p/r\n\nprint ncr(5,2,2)",
    "class Solution:\n    \"\"\"\n    @param: A: An integer\n    @param: m: An integer\n    @param: n: An integer\n    @param: p: An integer\n    @return: A integer\n    \"\"\"\n    def ncr(self, A, m, n, p):\n        \"\"\"\n        :type A: int\n        :type m: int\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 0:\n            return 1\n        if A < 0 or A > p:\n            return 0\n        if m > n or m < 1 or n < 1:\n            return 0\n        if m == 1:\n            return A\n        if n == 1:\n            return p\n        if m == n:\n            return p\n        if m > n:\n            return self.ncr(A, m - 1, n, p - A) * self.ncr(A, m - 1, n - 1, p)\n        else:\n            return self.ncr(A, m, n - 1, p) * self.ncr(A, m - 1, n - 1, p - A)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.ncr(2, 3, 4, 5)",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} r\n    # @param {integer} p\n    # @return {integer}\n    def ncr(self, n, r, p):\n        if n == 0:\n            return 1\n        return self.ncr(n - 1, r, p) + self.ncr(n - 1, r - 1, p) * p\n\nif __name__ == '__main__':\n    Solution().ncr(3, 2, 3)",
    "def ncr(n,r,p):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 0:\n        return 0\n    if n == r:\n        return 1\n    if r > n:\n        return 0\n    return ncr(n, r - 1, p - 1) + ncr(n - r, r, p)\n\n\n\nprint ncr(3, 3, 2)",
    "def ncr(n, p):\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if p == 1:\n        return 1\n    return ncr(n - 1, p) * ncr(n - 1, p - 1)\n\ndef main():\n    print(ncr(4, 3))\n\nif __name__ == '__main__':\n    main()",
    "# https://oj.leetcode.com/problems/combination-sum-possible/\n# time: O(n^2)\n# space: O(n^2)\n# score:25.64\n# score:23.95\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # dp[i][j] = candidates[i] * (n-j) / (j+1)\n        # dp[i][j] = candidates[i] * (n-j) / (j+1)\n        # dp[i][j] = candidates[i] * (n-j) / (j+1)\n        # dp[i][j] = candidates[i] * (n-j) / (j+1)\n        dp = [[0] * (target+1) for _ in range(len(candidates)+1)]\n        for i in range(len(candidates)+1):\n            for j in range(len(candidates)+1):\n                if i == 0:\n                    dp[i][j] = 1\n                elif j == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i][j-1] + candidates[i-1] * (len(candidates)-j+1)\n        # print(dp)\n        res = []\n        for i in range(len(candidates)+1):\n            for j in range(len(candidates)+1):\n                if dp[i][j] == target:\n                    res.append([candidates[i-1] * (len(candidates)-j+1)] + [candidates[i-1] * (len(candidates)-j+1)] + [candidates[i-1] * (len(candidates)-j+1)] + [candidates[i-1] * (len(candidates)-j+1)])\n                    break\n        return res\n\nif __name__ == \"__main__\":\n    candidates = [2,3",
    "import math\n\ndef ncr(n, r):\n    return math.factorial(n)/(math.factorial(r)*math.factorial(n-r))\n\n# Time:  O(n)\n# Space: O(n)\n# DP\n#     2^k   nCr(n, k)\n#   k = 0    1\n#   k = 1    n\n#   k = 2    nCr(n, 1) + nCr(n-1, 2)\n#   k = 3    nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3)\n#  ...\n#   k = n-1  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n    nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n+1  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#  ...\n#   k = n+n-2  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n+n-3  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n+n-4  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#  ...\n#   k = n+n-n2  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n+n-n3  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2, 3) +...\n#   k = n+n-n4  nCr(n, 1) + nCr(n-1, 2) + nCr(n-2,",
    "import math\n\ndef ncr(n, r):\n    \"\"\"\n    Computes the value of ncr(n, r).\n\n    Time complexity: O(n+r).\n    Space complexity: O(1).\n    \"\"\"\n    if r > n:\n        return 0\n    return math.factorial(n) / math.factorial(r) / math.factorial(n-r)\n\ndef test_ncr():\n    assert ncr(3, 2) == 0\n    assert ncr(3, 3) == 1\n    assert ncr(3, 4) == 0\n    assert ncr(5, 2) == 0\n    assert ncr(5, 3) == 1\n    assert ncr(5, 4) == 0\n    assert ncr(5, 5) == 1\n    assert ncr(5, 6) == 0\n    assert ncr(5, 7) == 0\n\nif __name__ == \"__main__\":\n    test_ncr()",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return (n * (r - 1)) / (r * (n - r))",
    "def ncr_mod(n, p):\n    \"\"\"\n    Write a function to compute the value of ncr%p.\n    \"\"\"\n    return ((n-1)//p+1)*ncr_mod(n-1, p)%p\n\ndef ncr(n, p):\n    \"\"\"\n    Write a function to compute the value of ncr.\n    \"\"\"\n    return ncr_mod(n, p)\n\nif __name__ == \"__main__\":\n    for n, p in [(1, 2), (2, 3), (3, 5), (4, 7), (5, 11), (6, 13), (7, 17)]:\n        print(\"{} {} = {}\".format(n, p, ncr(n, p)))",
    "def ncr(n, r):\n    \"\"\"\n    >>> ncr(3, 4)\n    1\n    >>> ncr(3, 3)\n    0\n    >>> ncr(3, 2)\n    2\n    >>> ncr(3, 0)\n    1\n    >>> ncr(3, 5)\n    0\n    \"\"\"\n    if r == 0:\n        return 1\n    if r == n:\n        return 0\n    if n == 0:\n        return 1\n    if r == 1:\n        return n\n    return ncr(n-1, r-1) + ncr(n-1, r)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "from __future__ import print_function\n\nimport math\n\ndef ncr(n, r):\n    \"\"\"\n    ncr(n,r) = n!/[(n-r)!r!(n-r+1)!!]\n    \"\"\"\n    n, r = int(n), int(r)\n    n_factorial = math.factorial(n)\n    r_factorial = math.factorial(r)\n    n_minus_r_factorial = math.factorial(n - r)\n    n_minus_r_minus_1_factorial = math.factorial(n - r - 1)\n    n_minus_r_minus_1_factorial_factorial = math.factorial(n - r - 1) * math.factorial(n - r - 1)\n    return n_factorial / (n_minus_r_factorial * r_factorial * n_minus_r_minus_1_factorial_factorial)\n\nif __name__ == \"__main__\":\n    for n, r in [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]:\n        print(\"ncr({}, {}) = {}\".format(n, r, ncr(n, r)))",
    "import sys\nsys.path.append('../')\n\ndef ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> Returns the number of combinations of r elements chosen from\n    n elements.\n\n    Example:\n\n    >>> ncr(10, 2)\n    4\n    >>> ncr(5, 3)\n    4\n    >>> ncr(10, 4)\n    4\n\n    ncr(n, r) is defined recursively as:\n\n    ncr(n, r) = ncr(n-1, r) + ncr(n-1, r-1)\n\n    For r > n, the value is zero.\n    \"\"\"\n    return ncr(n - 1, r) + ncr(n - 1, r - 1)\n\n\ndef main():\n    \"\"\"\n    Test cases\n    \"\"\"\n    test_cases = open(\"tests.txt\", \"r\")\n    for test in test_cases:\n        test = test.strip()\n        if test:\n            test = test.split(\" \")\n            n, r = [int(x) for x in test]\n            assert ncr(n, r) == int(test[-1])\n\nif __name__ == '__main__':\n    main()",
    "def ncr(n, r, p):\n    \"\"\"\n    Input: n, r, p are integers\n    Output: a tuple of (ncr, remainder) where ncr is the number of combinations\n    and remainder is the remainder after division by p.\n    \"\"\"\n    # This is the way to do it in python\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p\n    # remainder = r - ncr * p\n    # return ncr, remainder\n    # This is the way to do it in C++\n    # ncr = n * (r - 1) // p",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return self.ncr_recursive(n, r)\n\n    def ncr_recursive(self, n, r):\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        if n == 0:\n            return 0\n        return self.ncr_recursive(n - 1, r) * self.ncr_recursive(n - 1, r - 1)\n\n\nif __name__ == '__main__':\n    n = 2\n    r = 3\n    print Solution().ncr(n, r)\n    print Solution().ncr(n, r)",
    "def ncr_mod(n, p):\n    \"\"\"\n    ncr_mod(n, p) -> int\n    Return the value of ncr mod p.\n\n    The modulo p must be a prime.\n\n    :param n: int\n    :param p: int\n    :return: int\n    \"\"\"\n\n    if p == 2:\n        return n\n    if p % 2 == 0:\n        return ncr_mod(n, p // 2)\n    else:\n        return (ncr_mod(n, p // 2) + ncr_mod(n - 1, p // 2)) % p\n\n\n# Your ncr_mod function will be called like this:\n# ncr_mod(n, p)\ndef solution(n, p):\n    \"\"\"\n    Write a function solution that returns the value of ncr mod p.\n    \"\"\"\n    if p == 2:\n        return n\n    if p % 2 == 0:\n        return solution(n, p // 2)\n    else:\n        return (solution(n, p // 2) + solution(n - 1, p // 2)) % p\n\nif __name__ == '__main__':\n    print(ncr_mod(10, 3))\n    print(ncr_mod(10, 7))\n    print(solution(10, 7))",
    "from collections import defaultdict\n\ndef ncr(n, r, p):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return defaultdict(int)({0: 1, 1: p, 2: r - p})[n]\n\nif __name__ == '__main__':\n    print ncr(1, 2, 3)\n    print ncr(2, 1, 3)\n    print ncr(3, 1, 3)\n    print ncr(4, 2, 3)\n    print ncr(5, 2, 3)",
    "#!/usr/bin/env python\n\nimport sys\n\ndef ncr(n,p):\n    \"\"\"\n    ncr(n,p) -> return the value of ncr(n,p)\n    \"\"\"\n    if n==0 or p==0:\n        return 0\n    if n==1 or p==1:\n        return 1\n    return (ncr(n-1,p) + ncr(n-1,p-1)) % p\n\ndef main():\n    if len(sys.argv) == 3:\n        n,p = map(int,sys.argv[1:])\n        print ncr(n,p)\n    else:\n        print \"Please input the number of elements and the number of partitions\"\n\nif __name__ == \"__main__\":\n    main()",
    "def ncr(n, p):\n    \"\"\"\n    n is an integer and p is an integer.\n\n    Return the value of n! / (n-p)! / p!\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if p == 0:\n        return 1\n    if p == 1:\n        return n\n    if n < p:\n        return ncr(n, p-1)\n    if p == 2:\n        return n * (n+1) / 2\n    if p == 3:\n        return n * (n*(n+1) / 2 + 1) / 3\n    else:\n        return ncr(n-1, p-1) * ncr(n-1, p) / ncr(n-1, p-1)\n\nprint ncr(10, 3)",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        return self.ncr_helper(n, r, 1)\n\n    def ncr_helper(self, n, r, prev):\n        if n == 0:\n            return 0\n        if r == 0:\n            return 1\n        if n == 1:\n            return r\n        if r == 1:\n            return prev\n        return self.ncr_helper(n - 1, r - 1, prev * (n - 1))",
    "def ncr(n, r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    if r == 0:\n        return 1\n    elif r == 1:\n        return n\n    else:\n        return ncr(n, r - 1) * n % r\n\nif __name__ == \"__main__\":\n    print ncr(1, 2)",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == r: return 1\n        if n < r: return 0\n        n, r = r, n\n        return sum(self.ncr(n - 1, r) * self.ncr(n - 1, r - 1)\n                   / self.ncr(n, r - 1))",
    "def ncr(n, p):\n    \"\"\"\n    ncr(n, p) -> value\n\n    Compute the number of combinations of n items chosen from a set of p\n    items.\n    \"\"\"\n    if p == 0:\n        return 1\n    if n == 0:\n        return 0\n    if p == 1:\n        return n\n    if p == n:\n        return 1\n    if p == n + 1:\n        return n * (n - 1) / 2\n    if p == n + 2:\n        return n * (n - 1) * (n - 2) / 6\n    if p == n + 3:\n        return n * (n - 1) * (n - 2) * (n - 3) / 24\n    if p == n + 4:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 120\n    if p == n + 5:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) / 240\n    if p == n + 6:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) / 720\n    if p == n + 7:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) / 1440\n    if p == n + 8:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) / 10080\n    return (n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9)) / 362880\n\ndef main():\n    n = int(input())\n    p = int(input())",
    "def ncr(n, p):\n    \"\"\"\n    n is an integer, p is an integer\n    return the value of ncr%p\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if p == 0:\n        return 0\n    if p == 1:\n        return 1\n    if p == 2:\n        return n\n    if p == 3:\n        return n - 1\n    if p == 4:\n        return n - 1\n    if p == 5:\n        return n - 2\n    if p == 6:\n        return n - 2\n    if p == 7:\n        return n - 3\n    if p == 8:\n        return n - 3\n    if p == 9:\n        return n - 4\n    if p == 10:\n        return n - 4\n    if p == 11:\n        return n - 5\n    if p == 12:\n        return n - 5\n    if p == 13:\n        return n - 6\n    if p == 14:\n        return n - 6\n    if p == 15:\n        return n - 7\n    if p == 16:\n        return n - 7\n    if p == 17:\n        return n - 8\n    if p == 18:\n        return n - 8\n    if p == 19:\n        return n - 9\n    if p == 20:\n        return n - 9\n    if p == 21:\n        return n - 10\n    if p == 22:\n        return n - 10\n    if p == 23:\n        return n - 11\n    if p == 24:\n        return n - 11\n    if p == 25:\n        return n - 12\n    if p == 26:\n        return n - 12\n    if p == 27:\n        return n - 13\n    if p == 28:\n        return n - 13\n    if p == 29:\n        return n - 14\n    if p == 30:\n        return n - 14\n    if p == 31:\n        return n - 15\n    if p == 32:\n        return n - 15\n    if p == 33:\n        return n - 16\n    if p == 34:\n        return n - 16\n    if p ==",
    "import math\n\ndef ncr(n, r, p):\n    \"\"\"\n    ncr(n, r, p) -> returns the value of ncr(n, r, p)\n    \n    ncr(n, r, p) computes the n-th cofficient of a polynomial with\n    coefficient of rth degree and polynomial of degree p.\n    \"\"\"\n    return math.factorial(p) / math.factorial(p - r) / math.factorial(r) / math.factorial(n - p)\n\nif __name__ == \"__main__\":\n    print ncr(3, 2, 3)\n    #>>> 1",
    "import collections\n\n\nclass Solution(object):\n    \"\"\"\n    @param nums: a list of integers\n    @param k: an integer\n    @return: a integer\n    \"\"\"\n    def __init__(self, nums, k):\n        self.nums = nums\n        self.k = k\n        self.result = collections.defaultdict(int)\n        self.__recursive_ncr(0, len(nums) - 1, k, nums)\n\n    def __recursive_ncr(self, start, end, k, nums):\n        if end - start < k:\n            return\n\n        for i in range(start + 1, end + 1):\n            self.__recursive_ncr(start, i - 1, k, nums)\n            self.result[nums[i - 1]] += self.result[nums[start]]\n            self.result[nums[i - 1]] %= k\n            self.result[nums[i - 1]] += self.result[nums[i]]\n            self.result[nums[i - 1]] %= k\n            self.__recursive_ncr(i, end, k, nums)\n\n\nif __name__ == \"__main__\":\n    print Solution().ncr(3, 4, 1).result",
    "from collections import Counter\n\n\ndef ncr(n, p):\n    \"\"\"\n    Compute the value of ncr(n, p).\n\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    cnt = Counter(p)\n    return sum(n / i for i in cnt)\n\n\nif __name__ == '__main__':\n    print ncr(5, 2)\n    print ncr(6, 4)\n    print ncr(7, 4)",
    "def ncr(n, p):\n    return n * (n - 1) // p\n\n\"\"\"\nExample 1:\n\nInput: n = 4, p = 2\nOutput: 0\nExplanation: ncr(4, 2) = 0\nExample 2:\n\nInput: n = 2, p = 3\nOutput: 1\nExplanation: ncr(2, 3) = 1\nExample 3:\n\nInput: n = 4, p = 7\nOutput: -1\nExplanation: ncr(4, 7) = -1\nExample 4:\n\nInput: n = 4, p = 1\nOutput: 2\nExplanation: ncr(4, 1) = 2\nExample 5:\n\nInput: n = 7, p = 3\nOutput: 4\nExplanation: ncr(7, 3) = 4\nExample 6:\n\nInput: n = 3, p = 3\nOutput: 0\nExplanation: ncr(3, 3) = 0\n\"\"\"\n\nclass Solution:\n    # @return an integer\n    def ncr(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 0\n        if p == 1:\n            return n\n        if p == n:\n            return 1\n        if p == n - 1:\n            return -1\n        if n < p:\n            return self.ncr(n, p - n)\n        if p > n:\n            return self.ncr(n, p)\n        return self.ncr(n - 1, p) * n / (p - 1)",
    "import math\n\ndef ncr(n, r):\n    return math.factorial(n) / math.factorial(r) / math.factorial(n-r)\n\nprint(ncr(4, 3))",
    "def ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> returns the number of combinations of r elements taken\n    from a set of n elements.\n    \"\"\"\n    if n == 0:\n        return 1\n    if r == 0:\n        return 1\n    if n == 1:\n        return r\n    if r == 1:\n        return n\n    if r == n:\n        return 1\n    if r > n:\n        return 0\n    if n > r:\n        return 0\n    return ncr(n - 1, r - 1) + ncr(n - 1, r)\n\ndef ncr_recursive(n, r):\n    if n == 0:\n        return 1\n    if r == 0:\n        return 1\n    if n == 1:\n        return r\n    if r == 1:\n        return n\n    if r > n:\n        return 0\n    if r > n - 1:\n        return 0\n    return ncr_recursive(n - 1, r) + ncr_recursive(n - 1, r - 1) + ncr_recursive(n, r - 1)\n\nif __name__ == \"__main__\":\n    for n in range(0, 10):\n        for r in range(0, n + 1):\n            print(ncr(n, r), ncr_recursive(n, r))",
    "class Solution(object):\n    def ncr(self, n, r, k):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k > n - r:\n            return 0\n        if k == 0:\n            return 1\n        if n == 1:\n            return 0 if k == 0 else 1\n        if r == 0:\n            return 1\n        if r == 1:\n            return 0\n        if k == 1:\n            return 1\n        if k == 2:\n            return n - r\n        if k == 3:\n            return n - r - 1\n        if k > 3:\n            return self.ncr(n - 1, r, k - 1) + self.ncr(n - 1, r - 1, k - 1)\n        if k % 2 == 1:\n            return self.ncr(n - 1, r - 1, k - 1) + self.ncr(n - 1, r, k - 1)\n        else:\n            return self.ncr(n - 1, r, k - 1)\n\n\nif __name__ == '__main__':\n    print Solution().ncr(2, 3, 3)",
    "def ncr(n, r):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :rtype: int\n    \"\"\"\n    if r == 0:\n        return 1\n    elif r == 1:\n        return n\n    elif r == 2:\n        return n*(n - 1) / 2\n    else:\n        return ncr(n - 1, r - 1) + ncr(n, r - 2)\n\nif __name__ == '__main__':\n    print ncr(20, 5)\n    print ncr(5, 5)\n    print ncr(20, 20)",
    "def ncr(n,r,p):\n    if r==1: return 1\n    if p==0: return 0\n    if p==1: return 1\n    if n==0 or r==0: return 0\n    if p==2: return n*(n-1)/2\n    if p==3: return n*(n-1)*(n-2)/6\n    if p==4: return n*(n-1)*(n-2)*(n-3)/24\n    if p==5: return n*(n-1)*(n-2)*(n-3)*(n-4)/120\n    if p==6: return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)/720\n    if p==7: return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)/5040\n    if p==8: return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)/40320\n    if p==9: return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)/362880\n    return (n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)/\n            362880)\n\ndef test():\n    assert ncr(0,2,0)==1\n    assert ncr(1,2,0)==0\n    assert ncr(2,2,0)==0\n    assert ncr(3,2,0)==0\n    assert ncr(0,2,1)==0\n    assert ncr(1,2,1)==1\n    assert ncr(2,2,1)==0\n    assert ncr(3,2,1)==1\n    assert ncr(0,2,2)==0",
    "def ncr(n, p):\n    if p == 0:\n        return 1\n    return (n * ncr(n - 1, p - 1)) / p\n\n#Test Cases\nprint ncr(10, 2)\nprint ncr(10, 3)\nprint ncr(10, 4)",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        res = 1\n        for i in range(r):\n            res *= n - i\n            res /= i + 1\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.ncr(10, 7)\n    print s.ncr(100, 100)",
    "import math\n\ndef ncr(n,r):\n    return (math.factorial(n) * math.factorial(r) * math.factorial(n-r) /\n            math.factorial(n-1) * math.factorial(r) / math.factorial(r-1))\n\ndef ncr_iter(n,r):\n    if r == 1:\n        return 1\n    else:\n        return ncr(n,r) * (n-r+1) / r\n\ndef ncr_recursive(n,r):\n    if r == 1:\n        return 1\n    else:\n        return ncr(n,r) * (n-r+1) / (r-1)\n\nprint ncr(2,2)\nprint ncr_iter(2,2)\nprint ncr_recursive(2,2)",
    "import sys\nsys.path.append(\"../\")\n\nfrom numpy import *\nfrom scipy import *\n\ndef ncr(n, p):\n    if n == 1:\n        return 1\n    if p == 1:\n        return 0\n    if n == 0:\n        return 1\n    if n == p:\n        return 1\n    if n < p:\n        return 0\n    if n < p:\n        return 0\n    if n == p:\n        return 1\n    return ncr(n-1, p) + ncr(n-1, p-1)\n\ndef main():\n    n = int(sys.argv[1])\n    p = int(sys.argv[2])\n    ans = ncr(n, p)\n    print ans\n\nif __name__ == \"__main__\":\n    main()",
    "def ncr(n, r, p):\n    return (p ** r) / (p ** (r - 1)) * n / p\n\nif __name__ == \"__main__\":\n    print ncr(1, 1, 2)",
    "def ncr(n, r, p):\n    \"\"\"\n    ncr(n, r, p) -> the number of combinations of n things taken\n    r at most, all from the set {0,..., p-1}.\n    \"\"\"\n    return pow(p, r) / (pow(p, r) - pow(n, r))\n\nif __name__ == '__main__':\n    print ncr(2, 3, 4)\n    print ncr(2, 3, 5)\n    print ncr(2, 3, 6)\n    print ncr(2, 3, 7)\n    print ncr(2, 3, 8)\n    print ncr(2, 3, 9)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or r == 0:\n            return 1\n        if n == 1 or r == 1:\n            return 1\n        if n == 2 or r == 2:\n            return 2\n        if n == 3 or r == 3:\n            return 6\n        if n <= r:\n            return self.ncr(n - 1, r) + self.ncr(n - 1, r - 1)\n        else:\n            return self.ncr(n - 1, r - 1) + self.ncr(n - 1, r)\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(0)\n    root.left = TreeNode(1)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(2)\n    root.right.right = TreeNode(2)\n    root.left.left.left = TreeNode(3)\n    root.left.left.right = TreeNode(3)\n    root.left.right.left = TreeNode(3)\n    root.right.right.left = TreeNode(3)\n    root.right.right.right = TreeNode(3)\n    root.right.right.right = TreeNode(3)\n    print(Solution().ncr(2, 3))",
    "def ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> Returns the n-ary coefficient of r.\n    n, r > 0 are integers.\n    \"\"\"\n    return sum(i*ncr(i, r-i) for i in range(1, r+1))\n\nprint(ncr(3, 2))\n\ndef ncr_recursive(n, r):\n    if n == 1 or r == 1:\n        return 1\n    return ncr_recursive(n-1, r) + ncr_recursive(n-1, r-1)\n\nprint(ncr_recursive(3, 2))",
    "def ncr(n, r, p):\n    \"\"\"\n    ncr(n, r, p) -> int\n\n    Computes the value of ncr(n, r, p) using the formula:\n    ncr(n, r, p) = nc(n, r) / cc(r, p)\n\n    For example, ncr(5, 2, 3) = ncr(n, r, p) = 2 / 3.\n    \"\"\"\n\n    return ncr(n, r, p)\n\nif __name__ == \"__main__\":\n    print(ncr(5, 2, 3))\n    print(ncr(5, 2, 5))",
    "def ncr(n, r, p):\n    \"\"\"\n    ncr(n,r,p) -> value of ncr%p\n    \"\"\"\n    return (n * (n-r)) / (r * (p-1))\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
    "# Definition for ncr.\nclass Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        if r > n:\n            return 0\n        return self.ncr(n - r, r) + self.ncr(n - r - 1, r - 1)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {int} p\n    # @return {int}\n    def ncr(self, root, p):\n        if root is None:\n            return 0\n        if p == 1:\n            return 1\n        if root.left is None and root.right is None:\n            return 1\n        n = self.ncr(root.left, p-1) + self.ncr(root.right, p-1)\n        if root.left is None:\n            return n\n        if root.right is None:\n            return n\n        return n*(p-1)/p*(p-2)\n        \n    def ncrRecursive(self, root, p):\n        if root is None:\n            return 0\n        if p == 1:\n            return 1\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.ncrRecursive(root.right, p-1)\n        if root.right is None:\n            return self.ncrRecursive(root.left, p-1)\n        return self.ncrRecursive(root.left, p-1)*self.ncrRecursive(root.right, p-1)\n\ns = Solution()\nt = TreeNode(1)\nt.left = TreeNode(2)\nt.right = TreeNode(3)\nt.right.left = TreeNode(4)\nt.right.right = TreeNode(5)\nprint(s.ncr(t, 3))",
    "import sys\n\nif len(sys.argv) < 2:\n    sys.exit('Error: You must provide the number of partitions and the number of repetitions')\n\nn, p = map(int, sys.argv[1:])\n\ndef ncr(n, p):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return p\n    else:\n        return ncr(n - 1, p) + ncr(n - 1, p - (n - 1) % p)\n\nprint(ncr(n, p))",
    "import math\n\ndef ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> ncr\n    ncr(n, r) returns the number of combinations of r elements chosen\n    from n elements.\n    \"\"\"\n\n    if r > n:\n        return 0\n    elif r == 0:\n        return 1\n    elif r == 1:\n        return n\n    else:\n        return math.factorial(n) / (math.factorial(r) * math.factorial(n - r))\n\n\nprint(ncr(4, 2))",
    "import math\n\ndef ncr(n,r):\n    return math.factorial(n)/(math.factorial(r)*math.factorial(n-r))\n\nprint ncr(10,5)",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def ncr(self, n, k):\n        if n == 0 or k == 0:\n            return 0\n        if n == 1 or k == 1:\n            return 1\n        if n == 2 or k == 2:\n            return 2\n        if k > n / 2:\n            k = k - n / 2\n        else:\n            n = n - k\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        return self.ncr(n - 1, k - 1) * (self.ncr(n - 1, k) - 1) / k\n\n\nif __name__ == '__main__':\n    print Solution().ncr(1, 2)\n    print Solution().ncr(4, 4)",
    "from collections import Counter\n\n\nclass Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.ncr = Counter()\n        self.ncr[1] = 1\n\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or r == 0:\n            return 0\n        if n == 1:\n            return r\n        if r == 1:\n            return n\n        if r == n:\n            return 1\n        if r > n:\n            return self.ncr(n, r - 1)\n        return self.ncr(n - 1, r - 1) + self.ncr(n - 1, r)\n\n    def ncr_1(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if r == 0:\n            return 0\n        if r == 1:\n            return n\n        if r > n:\n            return self.ncr_1(n, r - 1)\n        return self.ncr_1(n - 1, r - 1) + self.ncr_1(n - 1, r)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.ncr(3, 1))\n    print(sol.ncr(3, 2))\n    print(sol.ncr(3, 3))\n    print(sol.ncr_1(3, 1))\n    print(sol.ncr_1(3, 2))\n    print(sol.ncr_1(3, 3))",
    "def ncr_mod(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    res = 1\n    for i in range(p):\n        if i > n - p:\n            res = res * (n - i) / i\n        else:\n            res = res * (n - i) / (p - i)\n    return res\n\nclass Solution:\n    # @param n, an integer\n    # @param p, an integer\n    # @return an integer\n    def ncrmod(self, n, p):\n        res = 1\n        for i in range(p):\n            if i > n - p:\n                res = res * (n - i) / i\n            else:\n                res = res * (n - i) / (p - i)\n        return res % p\n\nif __name__ == '__main__':\n    print Solution().ncrmod(9, 8)",
    "def ncr_mod_p(n, p):\n    \"\"\"\n    Computes the value of ncr%p.\n    n, p are integers\n    \"\"\"\n    if n == 0 or p == 0:\n        return 0\n    else:\n        return (n*(n-1))//p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod_p(2, 3))",
    "import timeit\n\nstart = timeit.default_timer()\n\ndef ncr(n, r, p):\n    \"\"\"\n    Recursive formula for the number of combinations of r elements chosen\n    from n elements.\n\n    Parameters\n    ----------\n    n : int\n        number of elements\n    r : int\n        number of elements to choose from\n    p : int\n        number of elements to choose from\n\n    Returns\n    -------\n    int\n        number of combinations\n    \"\"\"\n    if p == 0:\n        return 1\n    elif p == 1:\n        return n\n    elif p == r:\n        return n * (n - 1) // 2\n    elif p > r:\n        return 0\n    else:\n        return ncr(n, r - 1, p - 1) * ncr(n - r + 1, r - 1, p - 1)\n\n\nprint(\"ncr(n, r, p) = %d\" % ncr(10, 3, 4))\n\nprint(\"Time elapsed: %fs\" % (timeit.default_timer() - start))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def ncr(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return r == p and 1 or 0\n        if r == p:\n            return ncr(n - 1, 1, 0)\n        if p == 0:\n            return ncr(n, 1, 1)\n        if r == 0:\n            return ncr(n - 1, 1, 1)\n        if r == 1:\n            return ncr(n, 1, 0)\n        if p == 1:\n            return ncr(n, 1, 1)\n        if r == n:\n            return ncr(n - 1, 1, 1)\n        if r == n - 1:\n            return ncr(n - 2, 1, 0)\n        if p == n:\n            return ncr(n - 1, 1, 1)\n        if r == n - 2:\n            return ncr(n - 3, 1, 0)\n        return ncr(n - 1, r, p) + ncr(n - 1, r - 1, p - 1)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    for i in range(1, 6):\n        print(i, sol.ncr(i, i, i))",
    "def ncr(n, r):\n    \"\"\"\n    ncr(n, r) -> Return the number of combinations of n things taken\n    r at a time.\n    \"\"\"\n    # Recursion\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    if r == 2:\n        return n * (n - 1) / 2\n    if r > n:\n        return 0\n    if r == n:\n        return 1\n    return ncr(n - 1, r - 1) + ncr(n - 1, r)",
    "def ncr(n, r, p):\n    \"\"\"\n    :type n: int\n    :type r: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if r == 0:\n        return 1\n    if n == 0:\n        return 0\n    if p == 0:\n        return 1\n    if p == 1:\n        return n\n    if p % 2 == 0:\n        return ncr(n, r, p / 2) + ncr(n - 1, r, p / 2)\n    else:\n        return ncr(n, r, p / 2) + ncr(n - 1, r, p / 2) + ncr(n - 2, r, p / 2)\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert ncr(5, 3, 1) == 1, \"1\"\n    assert ncr(5, 3, 2) == 3, \"3\"\n    assert ncr(5, 3, 3) == 5, \"5\"\n    assert ncr(5, 3, 4) == 8, \"8\"\n    assert ncr(5, 3, 5) == 13, \"13\"\n    assert ncr(5, 3, 6) == 15, \"15\"\n    assert ncr(5, 3, 7) == 21, \"21\"\n    assert ncr(5, 3, 8) == 25, \"25\"\n    assert ncr(5, 3, 9) == 29, \"29\"\n    assert ncr(5, 3, 10) == 33, \"33\"\n    assert ncr(5, 3, 11) == 37, \"37\"\n    assert ncr(5, 3, 12) == 41, \"41\"\n    assert ncr(5, 3, 13) == 45, \"45\"\n    assert ncr(5, 3, 14) == 49, \"49\"\n    assert ncr(5, 3, 15) == 53, \"53\"\n    assert ncr(5, 3, 16) == 57, \"57\"\n    assert ncr(5, 3, 17) == 61, \"61\"",
    "def ncr_mod(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 1:\n        return 0\n    if n == 1:\n        return 1\n    if n == 0:\n        return 0\n    if p == 2:\n        return 1\n    if p == 3:\n        return n == 1\n    if p == 5:\n        return n % 3\n    if p % 2 == 0:\n        return ncr_mod(n, p // 2)\n    return ncr_mod(n - 1, p - 1) + ncr_mod(n, p - 1)\n\n\n# Recursive solution\ndef ncr_rec(n, p):\n    if p == 1:\n        return 0\n    if n == 1:\n        return 1\n    if n == 0:\n        return 0\n    if p == 2:\n        return 1\n    if p == 3:\n        return n == 1\n    if p % 2 == 0:\n        return ncr_rec(n, p // 2)\n    return ncr_rec(n - 1, p - 1) + ncr_rec(n, p - 1)\n\n\n# Recursive solution with memoization\ndef ncr_rec_memo(n, p):\n    if p == 1:\n        return 0\n    if n == 1:\n        return 1\n    if n == 0:\n        return 0\n    if p == 2:\n        return 1\n    if p == 3:\n        return n == 1\n    if p % 2 == 0:\n        return ncr_rec_memo(n, p // 2)\n    memo = {}\n    return ncr_rec_memo(n - 1, p - 1, memo) + ncr_rec_memo(n, p - 1, memo)\n\n\n# DFS solution\ndef ncr_dfs(n, p):\n    if p == 1:\n        return 0\n    if n == 1:\n        return 1\n    if n == 0:\n        return 0\n    if p == 2:\n        return 1\n    if p == 3:\n        return n == 1\n    if",
    "def ncr(n, r, p):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if r == 0:\n        return 0\n    if p == 0:\n        return 1\n    if r == 1:\n        return n\n    if p == 1:\n        return r\n    if r > n:\n        return 0\n    if p > n:\n        return 0\n    if p == n:\n        return 1\n    if r > n / p:\n        return 0\n    if r > n / (p + 1):\n        return 0\n    if p == 1:\n        return n\n    if r > n / (p - 1):\n        return 0\n    return n / (p - 1) * (n - r) / (r - 1)\n\nprint(ncr(4, 3, 2))",
    "class Solution(object):\n    def ncr(self, n, r):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        if r == 0:\n            return 1\n        if n == 0:\n            return 0\n        if n == 1:\n            return r\n        if n == 2:\n            return r*(r-1)\n        if n == 3:\n            return r*(r-1)*(r-2)\n        if n == 4:\n            return r*(r-1)*(r-2)*(r-3)\n        if n == 5:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)\n        if n == 6:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)\n        if n == 7:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r-6)\n        if n == 8:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r-6)*(r-7)\n        if n == 9:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r-6)*(r-7)*(r-8)\n        if n == 10:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r-6)*(r-7)*(r-8)*(r-9)\n        if n == 11:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r-6)*(r-7)*(r-8)*(r-9)*(r-10)\n        if n == 12:\n            return r*(r-1)*(r-2)*(r-3)*(r-4)*(r-5)*(r",
    "import sys\nimport math\n\n\ndef compute_ncr(a, b, p):\n    \"\"\"Compute ncr%p.\n\n    :type a: int\n    :type b: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if a == 0 and b == 0 and p == 0:\n        return 0\n    if a == 0 and b == 0 and p == 1:\n        return 1\n    if a == 0 and b == 1 and p == 1:\n        return 1\n    if a == 1 and b == 0 and p == 1:\n        return 1\n    if a == 1 and b == 1 and p == 1:\n        return 1\n    if a == 1 and b == 1 and p == 2:\n        return 2\n    if a == 2 and b == 1 and p == 1:\n        return 2\n    if a == 2 and b == 2 and p == 1:\n        return 2\n    if a == 3 and b == 1 and p == 1:\n        return 2\n    if a == 3 and b == 3 and p == 1:\n        return 2\n    if a == 3 and b == 3 and p == 2:\n        return 4\n    if a == 4 and b == 3 and p == 1:\n        return 4\n    if a == 4 and b == 4 and p == 1:\n        return 4\n    if a == 4 and b == 4 and p == 2:\n        return 8\n    if a == 5 and b == 3 and p == 1:\n        return 8\n    if a == 5 and b == 5 and p == 1:\n        return 8\n    if a == 5 and b == 5 and p == 2:\n        return 16\n    if a == 6 and b == 3 and p == 1:\n        return 16\n    if a == 6 and b == 6 and p == 1:\n        return 16\n    if a == 6 and b == 6 and p == 2:\n        return 32\n    if a == 7 and b == 3 and p == 1:\n        return 32\n    if a == 7 and b == 7 and p == 1:\n        return 32\n    if a == 7 and b == 7 and p == 2:\n        return 64\n    if a == 8 and b == 3 and p == 1"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}