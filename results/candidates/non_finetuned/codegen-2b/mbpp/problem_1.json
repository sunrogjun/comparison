{
  "problem": {
    "task_id": "MBPP/12",
    "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
    "canonical_solution": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result",
    "test_list": [
      "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
      "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
      "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
    ],
    "challenge_test_list": [],
    "problem_id": 1
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        # write your code here\n        \n        # first row\n        for i in range(len(matrix)):\n            matrix[i] = sorted(matrix[i])\n        # second row\n        for i in range(len(matrix)-1):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] > matrix[i+1][j]:\n                    matrix[i+1][j] = matrix[i][j]\n                    matrix[i][j] = matrix[i+1][j]\n        return",
    "# https://oj.leetcode.com/problems/sort-matrix/\n\nclass Solution(object):\n    def matrixSum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        res = [[0 for j in range(n)] for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] += matrix[i][j]\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = res[i][j]\n        return matrix",
    "# Your sorting function will be called like this:\n# nums = [1,2,3,4,5,6,7]\n# sum_of_rows(nums)\n\n\ndef sum_of_rows(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    return matrix\n\n\nif __name__ == \"__main__\":\n    print(sum_of_rows([[1,2],[3,4]]))\n    print(sum_of_rows([[1,2],[3,4,5]]))\n    print(sum_of_rows([[1,2,3],[4,5,6]]))\n    print(sum_of_rows([[1,2,3],[4,5,6,7]]))",
    "class Solution(object):\n    def sumMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix: return\n\n        n = len(matrix)\n        m = len(matrix[0])\n\n        # sort the matrix in a sorted order\n        for i in range(n):\n            matrix[i][0] = 0\n            for j in range(m):\n                matrix[i][j] = matrix[i][j] + matrix[i][0]\n                matrix[0][j] = matrix[0][j] + matrix[i][j]\n\n        for i in range(1, n):\n            for j in range(1, m):\n                matrix[i][j] = matrix[i][j] + matrix[i][0] - matrix[0][j]\n\n    def printMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        \"\"\"\n        n = len(matrix)\n        m = len(matrix[0])\n\n        for i in range(n):\n            for j in range(m):\n                print(matrix[i][j], end=\" \")\n            print()",
    "import math\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        rows = cipher\n        n = len(rows)\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if rows[i][j] > rows[j][i]:\n                    rows[i][j], rows[j][i] = rows[j][i], rows[i][j]\n        for i in xrange(n):\n            for j in xrange(i, n):\n                rows[i][j] += rows[j][i]\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                rows[i][j] -= rows[j][i]\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if rows[i][j] > 0:\n                    rows[i][j] += rows[j][i]\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                rows[i][j] -= rows[j][i]\n\n    def solve_2(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        n = len(cipher)\n        for i in xrange(n):\n            for j in xrange(i, n):\n                if cipher[i][j] > cipher[j][i]:\n                    cipher[i][j], cipher[j][i] = cipher[j][i], cipher[i][j]\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                cipher[i][j] += cipher[j][i]\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                cipher[i][j] -= cipher[j][i]\n\n\nif __name__ ==",
    "def sum_row(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    result = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            result[i][j] += matrix[i][j]\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            matrix[i][j] = result[i][j]\n    return matrix\n\nclass Solution:\n    def sum_row(self, matrix: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Brute-force\n        \"\"\"\n        result = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                result[i][j] = sum(matrix[i])\n        \n        return result",
    "#!/bin/python\n\n#Given a matrix, return its sum of each row.\n#\n#Example\n#Given a matrix [[1,2,3], [4,5,6], [7,8,9]]\n#\n#return [10, 15, 20]\n\ndef sum_of_each_row(matrix):\n    result = 0\n    for row in matrix:\n        result += row[0]\n    return result\n\n#Note:\n#Write a test program to test your implementation.\n#\n#Example\n#Given a matrix [[1,2,3], [4,5,6], [7,8,9]]\n#\n#Your function should return [10, 15, 20]\n#\n#The test cases are:\n#\n#[[1, 2, 3], [4, 5, 6], [7, 8, 9]] -> [10, 15, 20]\n#[[1, 2, 3], [7, 8, 9], [4, 5, 6]] -> [10, 15, 20]\n#[[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3]] -> [10, 15, 20]\n#[[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3], [7, 8, 9]] -> [10, 15, 20]\n#\n#\n#\n\nif __name__ == '__main__':\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print sum_of_each_row(matrix)\n\n    matrix = [[1, 2, 3], [7, 8, 9], [4, 5, 6]]\n    print sum_of_each_row(matrix)\n\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3]]\n    print sum_of_each_row(matrix)\n\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3], [7, 8, 9]]\n    print sum_of_each",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def sortCols(self, mat):\n        \"\"\"\n        main idea: sort rows then sort cols\n        :param mat:\n        :return:\n        \"\"\"\n        n, m = mat.shape\n        for i in xrange(n):\n            self.sortRows(mat[:, i])\n\n        for i in xrange(m):\n            self.sortCols(mat[:, i])\n\n    def sortRows(self, mat):\n        \"\"\"\n        :param mat: a matrix\n        :return:\n        \"\"\"\n        n, m = mat.shape\n\n        for i in xrange(n):\n            self.sortCols(mat[i, :])\n\n    def sortCols(self, mat):\n        \"\"\"\n        :param mat: a matrix\n        :return:\n        \"\"\"\n        n, m = mat.shape\n\n        for i in xrange(m):\n            self.sortRows(mat[:, i])\n\n\nif __name__ == \"__main__\":\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Solution().sortCols(matrix)\n\n    print matrix",
    "from collections import Counter\n\nclass Solution(object):\n    def sum_matrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = len(matrix)\n        n = len(matrix[0])\n        matrix.sort(key=lambda x: Counter(x).get(1, 0))\n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j+1]\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - matrix[i][j+1]\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] + matrix[i+1][j]\n        \n        for i in xrange(m-1, -1, -1):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - matrix[i+1][j]",
    "import time\nstartTime = time.time()\n\n\n# @include\ndef sort_matrix(A):\n    # Sort the rows of A.\n    rows = list(range(len(A)))\n    # We use a heap as a priority queue to keep track of the sum of the rows.\n    heap = []\n    for i in range(len(A)):\n        for j in range(i):\n            if A[i][j] < A[j][i]:\n                heapq.heappush(heap, (A[i][j] + A[j][i], i, j))\n    # Now we use a stack to keep track of the row indices to be sorted.\n    stack = []\n    for i in range(len(A)):\n        stack.append((i,))\n    while heap:\n        # Pop the top item from the heap and get the sum.\n        sum_, i, j = heapq.heappop(heap)\n        # Add the row with sum = sum_ to the stack.\n        stack.append((i,))\n        # If i is not the end of the matrix, keep adding the rows with sum > sum_ to the stack.\n        if i!= len(A) - 1:\n            stack.append((i + 1,))\n        # Add the row with sum = sum_ to the heap.\n        heapq.heappush(heap, (sum_ + A[i][j], i, j))\n    # Now we can sort the stack.\n    # The stack is sorted in increasing order of sum.\n    return sorted(stack)\n# @exclude\n\n\ndef time_sort_matrix(N):\n    A = [random.randrange(N) for _ in range(N)]\n    ans = sort_matrix(A)\n    assert ans == sorted(ans)\n    print('Time:', time.time() - startTime)\n    return ans\n\n\nif __name__ == '__main__':\n    N = 10\n    print(time_sort_matrix(N))",
    "# https://leetcode.com/problems/sort-matrix/discuss/122836/C++-O(N^2)-solution-with-explanation\n\n# https://leetcode.com/problems/sort-matrix/discuss/122836/C++-O(N^2)-solution-with-explanation\n# https://leetcode.com/problems/sort-matrix/discuss/122836/C++-O(N^2)-solution-with-explanation\n\nclass Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] > 0:\n                    matrix[i][j] = -matrix[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i][j]\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] = -matrix[i",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumRows(self, root: TreeNode) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        sum = self.sumRows(root.left)\n        sum += self.sumRows(root.right)\n        return sum + root.val",
    "import numpy as np\n\n# Time Limit Exceeded\ndef sum_matrix(matrix):\n    sum_matrix_helper(matrix)\n    return matrix\n\n\ndef sum_matrix_helper(matrix):\n    if len(matrix) == 1:\n        return matrix\n\n    sum_matrix_helper(matrix[:, :-1])\n    sum_matrix_helper(matrix[:, 1:])\n\n    for i in range(len(matrix)):\n        matrix[i, 0] = sum(matrix[i, :])\n\n    return matrix\n\n\nif __name__ == '__main__':\n    matrix = np.array([[1, 2], [3, 4]])\n    print(sum_matrix(matrix))",
    "import timeit\n\n\nclass Solution(object):\n    def sortCols(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n\n        for i in xrange(len(matrix[0])):\n            self.sortRows(matrix, i, len(matrix[0]) - 1)\n\n    def sortRows(self, matrix, i, j):\n        if i == j:\n            return\n\n        for k in xrange(i, j + 1):\n            matrix[k][i] = -matrix[k][i]\n        for k in xrange(i, j + 1):\n            matrix[k][j] = -matrix[k][j]\n        self.sortRows(matrix, i, j - 1)\n        self.sortRows(matrix, i + 1, j)\n        self.sortRows(matrix, i, j + 1)\n\n\nif __name__ == '__main__':\n    start_time = timeit.default_timer()\n    s = Solution()\n    print s.sortCols([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    print \"Runtime:\", timeit.default_timer() - start_time",
    "def sum_matrix(matrix):\n    matrix_sum = 0\n    for row in matrix:\n        matrix_sum += row\n    return matrix_sum\n\ndef sort_matrix(matrix):\n    return sorted(matrix, key=sum_matrix)\n\nprint(sort_matrix([[3, 1, 5], [1, 6, 2], [4, 3, 7]]))",
    "import os\n\ndef sort_matrix(matrix):\n    if len(matrix) == 0:\n        return matrix\n    else:\n        for i in range(len(matrix)):\n            for j in range(i+1, len(matrix)):\n                if matrix[i][0] + matrix[j][0] < matrix[i][0]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n\n    return matrix\n\n\ndef test():\n    matrix = [[1, 3, 5], [6, 1, 1], [2, 1, 1]]\n    matrix = [[5, 3, 4], [2, 5, 1], [1, 1, 1]]\n    matrix = [[3, 5, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n    matrix = [[1",
    "import sys\n\nn = int(sys.stdin.readline())\n\nmatrix = []\nfor _ in range(n):\n    row = []\n    for _ in range(n):\n        row.append(int(sys.stdin.readline()))\n    matrix.append(row)\n\ndef sort(matrix):\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if matrix[i][j] > matrix[i][j-1]:\n                swap(matrix, i, j)\n    return matrix\n\ndef swap(matrix, i, j):\n    tmp = matrix[i][j]\n    matrix[i][j] = matrix[i][j-1]\n    matrix[i][j-1] = tmp\n\ndef print_matrix(matrix):\n    for row in matrix:\n        for item in row:\n            print item,\n        print\n\nmatrix = sort(matrix)\nprint_matrix(matrix)",
    "class Solution(object):\n    def sortCols(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n\n        n = len(matrix)\n        for i in range(n):\n            matrix[i].sort()\n\n        for i in range(1, n):\n            matrix[0][i] = matrix[0][i] + matrix[i][0]\n            matrix[i][0] = matrix[i][0] + matrix[0][i]\n            for j in range(1, n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1] - matrix[i-1][j]\n                matrix[i][j] = matrix[i][j] + matrix[i-1][j]\n        return\n\n        # http://www.cnblogs.com/grandyang/p/4928863.html\n        # http://www.cnblogs.com/grandyang/p/4928877.html\n        # http://www.cnblogs.com/grandyang/p/4928878.html\n        # http://www.cnblogs.com/grandyang/p/4928879.html\n        # http://www.cnblogs.com/grandyang/p/4928880.html\n        # http://www.cnblogs.com/grandyang/p/4928880.html\n        # http://www.cnblogs.com/grandyang/p/4928881.html\n        # http://www.cnblogs.com/grandyang/p/4928882.html\n        # http://www.cnblogs.com/grandyang/p/4928883.html\n        # http://www.cnblogs.com/grandyang/p/4928884.html\n        # http://www.cnblogs.com/grandyang/p/4928885.html\n        # http://www.cnblogs.com/grandyang/p/4928886.html\n        # http://www.cnblogs.com/grandyang/",
    "def sum_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    if not matrix:\n        return\n\n    n = len(matrix)\n    m = len(matrix[0])\n\n    matrix.sort(key=lambda x: sum(x))\n    for i in range(n-1):\n        matrix[i][0] = matrix[i][0] - matrix[i][m-1]\n    matrix.sort(key=lambda x: sum(x), reverse=True)\n\n# test cases\nmatrix = [[1,2,3,4,5], [2,3,4,5,6], [1,2,3,4,5], [2,3,4,5,6]]\n\nsum_matrix(matrix)\n\nprint(matrix)",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortCols(self, matrix):\n        if not matrix:\n            return\n\n        m, n = len(matrix), len(matrix[0])\n        matrix.sort(key=lambda x: sum(x))\n\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = sum(matrix[i])\n\nif __name__ == '__main__':\n    matrix = [[3, 1, 6, 1], [5, 1, 3, 3], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n    Solution().sortCols(matrix)\n    print matrix",
    "class Solution(object):\n    def matrixSum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not matrix:\n            return matrix\n        m = len(matrix)\n        n = len(matrix[0])\n        table = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                table[i][j] = matrix[i][j]\n        for i in range(m):\n            for j in range(n):\n                table[i][j] += table[i][j - 1]\n        for i in range(m):\n            for j in range(n):\n                table[i][j] += table[i - 1][j]\n        return table\n\na = Solution()\nprint(a.matrixSum([[1, 2], [3, 4]]))",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n\n    def sortCols(self, matrix):\n        if not matrix: return matrix\n        return self.sort(matrix, 0, len(matrix[0])-1)\n\n    def sort(self, matrix, start, end):\n        if start == end: return matrix\n        mid = (start+end)/2\n        left = self.sort(matrix, start, mid)\n        right = self.sort(matrix, mid+1, end)\n        return self.merge(left, right, start, end)\n\n    def merge(self, left, right, start, end):\n        result = []\n        i, j = start, start\n        while i < end and j < end:\n            if left[i][j] < right[i][j]:\n                result.append(left[i][j])\n                i += 1\n            else:\n                result.append(right[i][j])\n                j += 1\n        if i == end:\n            result.extend(right[i:])\n        if j == end:\n            result.extend(left[j:])\n        return result\n\ns = Solution()\nmatrix = [[1,2,3], [4,5,6], [7,8,9], [10,11,12]]\nprint s.sort(matrix)",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        m, n = len(cipher), len(cipher[0])\n        for i in range(m):\n            cipher[i][0] += cipher[i][m - 1]\n        for i in range(n):\n            cipher[0][i] += cipher[m - 1][i]\n        for i in range(m):\n            for j in range(n):\n                cipher[i][j] += cipher[i - 1][j] + cipher[i][j - 1] - cipher[i - 1][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                cipher[i][j] += cipher[i - 1][j] - cipher[i - 1][j - 1]\n\n    def solve1(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        m, n = len(cipher), len(cipher[0])\n        for i in range(m):\n            cipher[i][0] += cipher[i][m - 1]\n        for i in range(n):\n            cipher[0][i] += cipher[m - 1][i]\n        for i in range(m):\n            for j in range(n):\n                cipher[i][j] += cipher[i - 1][j] + cipher[i][j - 1] - cipher[i - 1][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                cipher[i][j] += cipher[i - 1][j] - cipher[i - 1][j - 1]\n\n    def solve2(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        m, n = len(",
    "# https://leetcode.com/problems/sum-of-matrix-row/description/\n\nclass Solution(object):\n    def sumOfSquares(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        result = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                result += matrix[i][j] ** 2\n        return result",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortCols(self, matrix):\n        n = len(matrix)\n        for i in range(n):\n            matrix[i].sort(key=lambda x: x[i])\n        return\n\nif __name__ == \"__main__\":\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print Solution().sortCols(matrix)",
    "def sum_row(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[j][i] > matrix[j-1][i]:\n                matrix[j-1][i], matrix[j][i] = matrix[j][i], matrix[j-1][i]\n    return\n\nif __name__ == '__main__':\n    matrix = [[-1, 3, 1, -4],\n              [1, -1, -1, 2],\n              [4, 1, -2, 1],\n              [1, -1, 1, -1]]\n    sum_row(matrix)\n    print(matrix)",
    "class Solution(object):\n    def solve(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        matrix.sort(key=lambda x: sum(x))",
    "import sys\nimport time\n\n\nclass Solution(object):\n    def solve(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        n = len(matrix)\n        for i in xrange(n):\n            matrix[i].sort()\n        for i in xrange(n-1):\n            for j in xrange(i+1, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][1] += matrix[j][1]\n                matrix[i][2] += matrix[j][2]\n                matrix[i][3] += matrix[j][3]\n                matrix[i][4] += matrix[j][4]\n                matrix[i][5] += matrix[j][5]\n                matrix[i][6] += matrix[j][6]\n                matrix[i][7] += matrix[j][7]\n                matrix[i][8] += matrix[j][8]\n                matrix[i][9] += matrix[j][9]\n                matrix[i][10] += matrix[j][10]\n                matrix[i][11] += matrix[j][11]\n                matrix[i][12] += matrix[j][12]\n                matrix[i][13] += matrix[j][13]\n                matrix[i][14] += matrix[j][14]\n                matrix[i][15] += matrix[j][15]\n                matrix[i][16] += matrix[j][16]\n                matrix[i][17] += matrix[j][17]\n                matrix[i][18] += matrix[j][18]\n                matrix[i][19] += matrix[j][19]\n                matrix[i][20] += matrix[j][20]\n                matrix[i][21] += matrix[j][21]\n                matrix[i][22] += matrix[j][22]\n                matrix[i][23] += matrix[j][23]\n                matrix[i",
    "#!/usr/bin/env python\n\nimport sys\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline())\n    matrix = []\n    for i in xrange(n):\n        matrix.append(map(int, sys.stdin.readline().split()))\n    matrix = sorted(matrix, key=lambda x: sum(x))\n    for i in xrange(n):\n        sys.stdout.write(str(matrix[i][0]) +'')\n    sys.stdout.write('\\n')",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortRows(self, matrix):\n        m = len(matrix)\n        n = len(matrix[0])\n        if m < n:\n            return\n        for i in range(m):\n            matrix[i].sort()\n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                if j+1 < n and matrix[i][j] > matrix[i+1][j]:\n                    matrix[i][j], matrix[i+1][j] = matrix[i+1][j], matrix[i][j]\n        return\n\nif __name__ == \"__main__\":\n    matrix = [[2, 3, 1, 2, 3], [5, 6, 2, 2, 1], [4, 2, 3, 3, 3], [3, 3, 1, 5, 2], [1, 3, 1, 3, 2]]\n    s = Solution()\n    s.sortRows(matrix)\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            print matrix[i][j],\n        print",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortCols(self, matrix):\n        if not matrix or not matrix[0]: return matrix\n        n = len(matrix)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if matrix[i][0] + matrix[j][0] > matrix[i][j]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n        return matrix\n\n\nif __name__ == \"__main__\":\n    # matrix = [[2, 4, 2, 1, 3], [1, 5, 1, 4, 5], [2, 1, 1, 1, 2], [1, 1, 1, 1, 1]]\n    matrix = [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]\n    solution = Solution()\n    matrix = solution.sortCols(matrix)\n    print(matrix)",
    "def sum_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j]\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j]\n    return dp\n\n\nif __name__ == '__main__':\n    matrix = [[1,2,3],[4,5,6],[7,8,9]]\n    sum_matrix(matrix)",
    "import sys\nfrom collections import defaultdict\n\n\nclass Solution(object):\n\n    def __init__(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        \"\"\"\n        self.matrix = matrix\n        self.sum_matrix = defaultdict(int)\n        for row in self.matrix:\n            for num in row:\n                self.sum_matrix[num] += 1\n\n    def sort(self):\n        \"\"\"\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        self.sorted_matrix = []\n        for i in range(len(self.matrix)):\n            self.sorted_matrix.append([])\n            for j in range(len(self.matrix[0])):\n                self.sorted_matrix[i].append(self.matrix[i][j])\n                self.sum_matrix[self.matrix[i][j]] -= 1\n                if self.sum_matrix[self.matrix[i][j]] == 0:\n                    self.sorted_matrix[i].pop(j)\n                    self.sum_matrix[self.matrix[i][j]] = 0\n\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[0])):\n                if self.sum_matrix[self.matrix[i][j]] > 0:\n                    self.sorted_matrix[i].insert(j, self.matrix[i][j])\n\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[0])):\n                if self.sum_matrix[self.matrix[i][j]] > 0:\n                    self.sorted_matrix[i].insert(j, self.matrix[i][j])\n\n        self.matrix = []\n        for i in range(len(self.sorted_matrix)):\n            self.matrix.append([])\n            for j in range(len(self.sorted_matrix[0])):\n                self.matrix[i].append(self",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '({}, {})'.format(self.x, self.y)\n\nclass Solution(object):\n    def solve(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: void Do not return anything, modify points in-place instead.\n        \"\"\"\n        if not points:\n            return\n        for i in xrange(len(points)):\n            points[i].x = i\n        # sort points by sum(x)\n        points.sort(key=lambda p: p.x)\n        # calculate sum(y) for each point\n        sum_y = [sum(p.y for p in points[:i+1]) for i in xrange(len(points))]\n        # sort points by sum(y)\n        points.sort(key=lambda p: sum_y[p.x])",
    "class Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # write your code here\n        if not matrix:\n            return\n\n        m, n = len(matrix), len(matrix[0])\n        if m == 1:\n            return\n\n        sum = [0] * n\n\n        for i in range(m):\n            for j in range(n):\n                sum[j] += matrix[i][j]\n\n        for i in range(n):\n            sum[i] = sum[i] - sum[0]\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = sum[j] - matrix[i][j]\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution2(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n\n        m, n = len(matrix), len(matrix[0])\n        if m == 1:\n            return\n\n        sum = [0] * n\n\n        for i in range(m):\n            for j in range(n):\n                sum[j] += matrix[i][j]\n\n        for i in range(n):\n            sum[i] = sum[i] - sum[0]\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = sum[j] - matrix[i][j]",
    "class Solution(object):\n    def matrixSum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not matrix:\n            return []\n\n        def sum_rows(matrix):\n            return sum([sum(row) for row in matrix])\n\n        return sorted(matrix, key=sum_rows)",
    "class Solution(object):\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if len(matrix) == 0:\n            return\n\n        n = len(matrix)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if matrix[i][0] + matrix[j][0] > matrix[i][j]:\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        for i in range(n):\n            self.sortRows(matrix[i])\n\n\nif __name__ == \"__main__\":\n    matrix = [[2, 3, 1], [1, 2, 1], [3, 2, 1]]\n    Solution().sortRows(matrix)\n    print(matrix)",
    "class Solution:\n    \"\"\"\n    @param matrix: a list of lists of integers\n    @return: void\n    \"\"\"\n    def sort(self, matrix):\n        if not matrix:\n            return\n        n = len(matrix)\n        for i in range(n):\n            self.sort(matrix[i])\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if matrix[i][j] < matrix[j][i]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n\n    def sort(self, matrix):\n        \"\"\"\n        @param matrix: a list of lists of integers\n        @return: void\n        \"\"\"\n        n = len(matrix)\n        if n == 0:\n            return\n        for i in range(n):\n            for j in range(i, n):\n                if matrix[i][j] < matrix[j][i]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n\n\n        for i in range(n):\n            for j in range(i, n):\n                if matrix[i][j] < matrix[j][i]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]",
    "from collections import defaultdict\n\nclass Solution(object):\n    def sumOfSquares(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                ans.append([matrix[i][j] + math.pow(matrix[i][j], 2)])\n        return ans\n\n\nif __name__ == '__main__':\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print matrix\n    s = Solution()\n    print s.sumOfSquares(matrix)",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortCol(self, matrix):\n        n = len(matrix)\n        if n == 0: return\n        m = len(matrix[0])\n        for i in xrange(m):\n            self.sortCol(matrix, i)\n\n    def sortCol(self, matrix, col):\n        sum = 0\n        for i in xrange(n):\n            sum += matrix[i][col]\n        matrix[0][col] = sum\n        for i in xrange(1, n):\n            sum = 0\n            for j in xrange(m):\n                sum += matrix[i][j]\n            matrix[i][col] = sum\n            self.sortCol(matrix, col)\n\ns = Solution()\nmatrix = [[3,1,2],[-3,3,2],[1,2,4]]\ns.sortCol(matrix)\nprint matrix",
    "def matrix_sum_sort(matrix):\n    # write your code here\n    \n    n = len(matrix)\n    m = len(matrix[0])\n\n    matrix_sum = [[0] * m for i in xrange(n)]\n\n    for i in xrange(n):\n        for j in xrange(m):\n            matrix_sum[i][j] = matrix[i][j]\n    \n    for i in xrange(n):\n        for j in xrange(m):\n            matrix_sum[i][j] = matrix_sum[i][j] + matrix_sum[i][j - 1]\n\n    return matrix_sum\n\n# test cases\nmatrix = [[1,2,3],[4,5,6],[7,8,9]]\nmatrix_sum = matrix_sum_sort(matrix)\n\n# print matrix\n# print matrix_sum",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortRows(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i-1][j]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i-1][j]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i-1][j]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i+1][j]\n        \n        return matrix",
    "def sum_row(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    # write your code here\n    size = len(matrix)\n    if size == 0:\n        return\n\n    matrix.sort(key = lambda x: sum(x))",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n == 0:\n            return\n        for i in range(n):\n            matrix[i].sort()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if matrix[i][j] < matrix[i][j - 1]:\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        return",
    "import copy\n\ndef sort(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    matrix = copy.deepcopy(matrix)\n    n = len(matrix)\n    if n == 0:\n        return\n    \n    sums = [0] * n\n    for i in range(n):\n        for j in range(i):\n            sums[i] += matrix[i][j]\n        sums[i] += matrix[i][n - 1]\n    \n    for i in range(n):\n        for j in range(i):\n            matrix[i][j] = sums[j]\n            sums[j] += matrix[i][j]\n            sums[n - 1] += matrix[i][j]\n    \n    for i in range(n):\n        for j in range(i):\n            matrix[i][j] = sums[j]\n            sums[j] += matrix[i][j]\n            sums[n - 1] += matrix[i][j]\n            \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            matrix[i][j] = sums[j]\n            sums[j] += matrix[i][j]\n            sums[n - 1] += matrix[i][j]\n    \n    return",
    "import unittest\n\ndef matrix_sum(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    row_sum = [[0 for x in range(len(matrix[0]))] for y in range(len(matrix))]\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            row_sum[i][j] = sum(matrix[i][j])\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if row_sum[i][j] > 0:\n                matrix[i][j] = row_sum[i][j]\n            else:\n                matrix[i][j] = 0\n    return matrix\n\nclass Test(unittest.TestCase):\n    def test(self):\n        matrix = [[-2, -3, 4], [1, -5, -6], [4, -1, -2]]\n        self.assertEqual(matrix_sum(matrix), [[-2, -3, 4], [1, -5, -6], [4, -1, -2]])\n\n        matrix = [[-3, 1, -2], [1, -3, -4], [1, -1, -2]]\n        self.assertEqual(matrix_sum(matrix), [[-3, 1, -2], [1, -3, -4], [1, -1, -2]])\n\n        matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        self.assertEqual(matrix_sum(matrix), [[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(matrix_sum(matrix), [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nif __name__ == '",
    "import unittest\n\n# For testing purposes\nclass TestFunction(unittest.TestCase):\n    def test_sort(self):\n        matrix = [\n            [1, 3, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1]\n        ]\n        # Sort the given matrix in ascending order according to the sum of its rows\n        result = sort(matrix)\n        expected = [\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1]\n        ]\n        self.assertEqual(result, expected)\n\n    def test_sort_1(self):\n        matrix = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]\n        # Sort the given matrix in ascending order according to the sum of its rows\n        result = sort(matrix)\n        expected = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]\n        self.assertEqual(result, expected)\n\n    def test_sort_2(self):\n        matrix = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]\n        # Sort the given matrix in ascending order according to the sum of its rows\n        result = sort(matrix, lambda x: x[0])\n        expected = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]\n        self.assertEqual(result, expected)\n\n# Sort the given matrix in ascending order according to the sum of its rows\ndef sort(matrix, compare_function):\n    for i in range(len(matrix)):\n        for j in range(",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortRows(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        def helper(root):\n            if not root:\n                return\n            if root.left:\n                helper(root.left)\n            if root.val < root.left.val:\n                root.left, root.val = root.val, root.left\n            if root.right:\n                helper(root.right)\n            if root.val < root.right.val:\n                root.right, root.val = root.val, root.right\n        helper(root)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortRows(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        self.sortRows(root.left)\n        self.sortRows(root.right)\n\n        pre_sum = self.pre_sum(root)\n        if pre_sum > 0:\n            root.val = pre_sum\n            self.sortRows(root.left)\n            self.sortRows(root.right)\n\n    def pre_sum(self, root):\n        if not root:\n            return 0\n\n        return root.val + self.pre_sum(root.left) + self.pre_sum(root.right)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.left = TreeNode(10)\n    root.left.right.right = TreeNode(11)\n    root.right.left.left = TreeNode(12)\n    root.right.left.right = TreeNode(13)\n    root.right.right.left = TreeNode(14)\n    root.right.right.right = TreeNode(15)\n\n    sol.sortRows(root)\n    print(root.val)\n    print(root.left.val)\n    print(root.right.val)\n    print(root.left.left.val",
    "# https://leetcode.com/problems/sort-matrix/description/\n# https://www.youtube.com/watch?v=qr7v-7qKXQE\nclass Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i+1, n):\n                if matrix[i][j] > matrix[i][j-1]:\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            for j in range(i+1, n):\n                if matrix[i][j] > matrix[i-1][j-1]:\n                    matrix[i][j], matrix[j-1][i] = matrix[j-1][i], matrix[i][j]\n        for i in range(n-1):\n            for j in range(i+2, n):\n                if matrix[i][j] > matrix[i+1][j-1]:\n                    matrix[i][j], matrix[j-1][i+1] = matrix[j-1][i+1], matrix[i][j]\n        return\n\n    # def sortMatrix(self, matrix):\n    #     if not matrix:\n    #         return\n    #     n = len(matrix)\n    #     for i in range(n):\n    #         for j in range(i+1, n):\n    #             if matrix[i][j] > matrix[i][j-1]:\n    #                 matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    #     for i in range(n):\n    #         for j in range(i+1, n):\n    #             if matrix[i][j] > matrix[i-1][j-1]:\n    #                 matrix[i][j], matrix",
    "def sort_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    # write your code here\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] + matrix[i][j-1]\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] - matrix[i][j-1]\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] * 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] / 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] % 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] / 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] % 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] * 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] / 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] % 2\n    \n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = matrix[i][j] * 2\n    \n    for i",
    "class Solution:\n    \"\"\"\n    @param matrix: a list of lists of integers\n    @return: nothing\n    \"\"\"\n    def sortRows(self, matrix):\n        n = len(matrix)\n        if n == 0:\n            return\n        for i in range(n):\n            for j in range(i, n):\n                if matrix[i][0] + matrix[j][0] < matrix[i][j]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if matrix[i][0] + matrix[j][0] < matrix[i][j]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n                    \n        return\n\nif __name__ == '__main__':\n    matrix = [\n        [1, 2, 3],\n        [3, 2, 1],\n        [1, 3, 2],\n        [3, 1, 2]\n    ]\n    s = Solution()\n    s.sortRows(matrix)\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            print(matrix[i][j], end=' ')\n        print()",
    "from collections import Counter\nfrom random import randint\n\ndef sort(matrix):\n    \"\"\"\n    Sort the matrix\n    \"\"\"\n    # Create a dictionary that maps each row to its sum.\n    row_sum_dict = {row: sum(row) for row in matrix}\n\n    # Create a list that will contain the sorted rows.\n    sorted_row_sum_dict = sorted(row_sum_dict.items(), key=lambda x: x[1])\n\n    # Create a list that will contain the sorted rows.\n    sorted_row_sum_list = [row_sum_dict[row] for row, _ in sorted_row_sum_dict]\n\n    # Create a list that will contain the sorted rows.\n    sorted_sorted_row_sum_list = sorted(sorted_row_sum_list)\n\n    # Create a list that will contain the sorted rows.\n    sorted_matrix = [[matrix[row][column] for column in range(len(matrix[0]))] for row in sorted_sorted_row_sum_list]\n\n    return sorted_matrix\n\nif __name__ == '__main__':\n    matrix = [[randint(0, 10) for _ in range(5)] for _ in range(5)]\n    print(matrix)\n    print(sort(matrix))",
    "# https://leetcode.com/problems/sort-matrix/discuss/76972/C++-Python-Solution-with-explanation-of-algorithm-and-memory-consumption\n\n# Example 1:\n# Input: [\n#   [1,2,3],\n#   [4,5,6],\n#   [7,8,9]\n# ]\n# Output: [\n#   [1,2,3],\n#   [4,5,6],\n#   [7,8,9]\n# ]\n# Explanation:\n# The sum of each row is 1 + 2 + 3 = 7.\n# The sum of each column is 4 + 5 + 6 = 16.\n# The sum of the whole matrix is 7 + 16 = 23.\n# Time complexity: O(n^2)\n# Space complexity: O(n^2)\n\n# Example 2:\n# Input: [\n#   [7, -8, 4, 1, -2, -2],\n#   [3, -1, -1, -1, -2, -2],\n#   [-3, -3, 1, 2, -2, -2],\n#   [-5, 3, -4, -2, -3, -3],\n#   [-1, -1, -1, -1, -1, -1]\n# ]\n# Output: [\n#   [-1, -1, -1, -1, -1],\n#   [-3, -3, -3, -3, -3],\n#   [-5, -4, 3, 1, -2],\n#   [-7, 4, -6, -2, -3],\n#   [-9, -8, -7, -2, -2]\n# ]\n# Explanation:\n# The sum of each row is 7 + -8 + 4 + 1 + -2 + -2 = -2 + -2 + 4 + 1 + -2 = -2 + -2 + 4 + 1 = -1\n# The sum of each column is -3 + -1 + -1 + -1 + -2 + -2 = -3 + -3 + -1 + -1 +",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def sortCols(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: void Do not return anything, modify mat in-place instead.\n        \"\"\"\n        n = len(mat)\n        for i in range(n):\n            for j in range(i, n):\n                if mat[i][j] < mat[i][j-1]:\n                    mat[i][j], mat[i][j-1] = mat[i][j-1], mat[i][j]\n\n    def sortRows(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: void Do not return anything, modify mat in-place instead.\n        \"\"\"\n        n = len(mat)\n        for i in range(n):\n            for j in range(n):\n                if mat[i][j] < mat[j][i]:\n                    mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\n\n\nif __name__ == \"__main__\":\n    mat = [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\n    print Solution().sortCols(mat)\n    print mat",
    "class Solution(object):\n    def sortBySum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in xrange(n):\n            for j in xrange(m):\n                if matrix[i][j] < 0:\n                    matrix[i][j] = -matrix[i][j]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i][j - 1]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - 1][j]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i][j - m]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - n][j]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i][j - n - m]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - n - m][j]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - n - m][j - m]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - n - m][j - n]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] += matrix[i - n - m][j - n - m]\n        for i in xrange(n):\n            for j in xrange(m",
    "#%%\n\"\"\"\nConstraints\n\n1 <= m <= 1000\n1 <= n <= 1000\n\"\"\"\n\n#%%\n\"\"\"\nSample Input\n\n[[2, 5, 3, 0, 1],\n [1, 4, 2, 1, 0],\n [3, 1, 1, 2, 4],\n [3, 5, 3, 5, 1],\n [5, 1, 1, 1, 1]]\n\nSample Output\n\n[[1, 1, 1, 1, 1],\n [1, 2, 3, 4, 5],\n [1, 1, 1, 1, 1],\n [5, 5, 5, 5, 5],\n [3, 3, 3, 3, 3]]\n\n\"\"\"\n\n#%%\n\"\"\"\nInput\n\nm = 5\nn = 4\nmatrix = [[2, 5, 3, 0, 1],\n          [1, 4, 2, 1, 0],\n          [3, 1, 1, 2, 4],\n          [3, 5, 3, 5, 1],\n          [5, 1, 1, 1, 1]]\n\nOutput\n\n[[1, 1, 1, 1, 1],\n [1, 2, 3, 4, 5],\n [1, 1, 1, 1, 1],\n [5, 5, 5, 5, 5],\n [3, 3, 3, 3, 3]]\n\n\"\"\"\n\n#%%\n\"\"\"\nOutput\n\n[[1, 1, 1, 1, 1],\n [1, 2, 3, 4, 5],\n [1, 1, 1, 1, 1],\n [5, 5, 5, 5, 5],\n [3, 3, 3, 3, 3]]\n\"\"\"",
    "class Solution(object):\n    def sortBySum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        for i in range(len(matrix)):\n            matrix[i] = sorted(matrix[i], key=lambda x: x[0])\n        return matrix\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Solution().sortBySum(matrix)\n    print matrix\n    assert matrix == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
    "class Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if len(matrix) == 0:\n            return\n\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][1] += matrix[j][1]\n                matrix[i][2] += matrix[j][2]\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][1] += matrix[j][1]\n                matrix[i][2] += matrix[j][2]\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                matrix[i][0] -= matrix[j][0]\n                matrix[i][1] -= matrix[j][1]\n                matrix[i][2] -= matrix[j][2]\n\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][0] -= matrix[j][0]\n                matrix[i][1] -= matrix[j][1]\n                matrix[i][2] -= matrix[j][2]\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][1] += matrix[j][1]\n                matrix[i][2] += matrix[j][2]\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                matrix[i][0] -= matrix[j][0]\n                matrix[i][1] -= matrix[j][1]\n                matrix[i][2] -= matrix[j][2]\n\n        for i in range(n):\n            for j in",
    "class Solution(object):\n    def solve(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if not n:\n            return\n        m = len(matrix[0])\n        for i in xrange(n):\n            for j in xrange(m):\n                if matrix[i][j] < 0:\n                    matrix[i][j] = 0\n            for j in xrange(m):\n                matrix[i][j] += matrix[i][j - 1]\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] % 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] / 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] % 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] / 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] % 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] / 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] % 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] / 10\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[i][j] = matrix[i][j] % 10\n        for i in xrange(n):\n            for j in xrange(",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.res = []\n\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        self.sumOfLeftLeaves(root.left)\n        self.sumOfLeftLeaves(root.right)\n        return self.res[0] + self.res[-1]\n\nif __name__ == '__main__':\n    root = TreeNode(1, TreeNode(2, TreeNode(3, None, None), TreeNode(4, TreeNode(5, None, None), TreeNode(6, TreeNode(7, None, None), None))), TreeNode(8, TreeNode(9, None, None), TreeNode(10, TreeNode(11, TreeNode(12, None, None), None), TreeNode(13, TreeNode(14, None, None), None))))\n    root.left.left.right.val = 15\n    root.left.right.val = 20\n    root.right.left.val = 25\n    root.right.right.val = 30\n    s = Solution()\n    print(s.sumOfLeftLeaves(root))",
    "from collections import defaultdict\n\nclass Solution:\n    def sortCols(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        O(n^2) time\n        O(n^2) space\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n\n        # initialize\n        m = len(matrix)\n        n = len(matrix[0])\n        colSum = defaultdict(int)\n        for i in range(m):\n            for j in range(n):\n                colSum[j] += matrix[i][j]\n\n        # sort\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = colSum[j]\n                colSum[j] -= matrix[i][j]\n                if colSum[j] < 0:\n                    colSum[j] = 0\n\n        # print the matrix\n        for i in range(m):\n            print(' '.join(map(str, matrix[i])))\n\nif __name__ == '__main__':\n    sol = Solution()\n    matrix = [\n        [1,2,3,4],\n        [5,6,7,8],\n        [9,10,11,12],\n        [13,14,15,16]\n    ]\n\n    sol.sortCols(matrix)",
    "#!/bin/python\n\nclass Solution(object):\n    def sumMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i-1][j]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i+1][j]\n        \n        for i in range(n-1, -1, -1):\n            for j in range(m):\n                matrix[i][j] = matrix[i][j] - matrix[i][j+1]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i-1][j]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j+1]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i+1][j]\n        \n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i][j-1]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j]",
    "class Solution:\n    def sortCol(self, mat: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify mat in-place instead.\n        \"\"\"\n        n = len(mat)\n        for i in range(n):\n            mat[i], mat[i + 1] = mat[i + 1], mat[i]\n            \n        for j in range(n - 1):\n            for i in range(j + 1, n):\n                if mat[i][j] < mat[i + 1][j]:\n                    mat[i], mat[i + 1] = mat[i + 1], mat[i]\n                    \n        return\n        \n    def sort(self, mat: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify mat in-place instead.\n        \"\"\"\n        n = len(mat)\n        for i in range(n):\n            for j in range(i):\n                if mat[i][j] > mat[i][j + 1]:\n                    mat[i], mat[j + 1] = mat[j + 1], mat[i]\n        \n        return\n        \nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.sort([[1, 2], [3, 4]]))\n    print(sol.sort([[1, 2], [3, 4], [1, 1]]))\n    print(sol.sort([[1, 1], [1, 1], [1, 1]]))\n    print(sol.sort([[1, 1], [1, 1], [1, 1], [1, 1]]))\n    print(sol.sort([[1, 2], [3, 4], [1, 1], [1, 1]]))\n    print(sol.sort([[1, 2], [3, 4], [1, 1], [1, 1], [1, 1]]))\n    print(sol.sort([[1, 2], [3, 4], [1, 1], [1, 1], [1, 1], [1, 1]]))\n    print(sol.sort([[1, 1], [1, 1], [1, 1], [1,",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n\n    def sort(self, matrix):\n        # write your code here\n        if not matrix:\n            return matrix\n\n        m = len(matrix)\n        n = len(matrix[0])\n\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1]\n\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = matrix[i][j] - matrix[i][j-1]\n\n        return matrix\n\n\ns = Solution()\n\n# print s.sort([[1,2,3],[4,5,6]])\n\nprint s.sort([[-1,0,1],[-2,0,2]])",
    "class Solution(object):\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # Time:  O(n^2)\n        # Space: O(n^2)\n        # Two pointers\n        # sort from first row to last row\n        # sum from first row to last row\n        # sum from last row to first row\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                # sum from first row to last row\n                sum = 0\n                for k in range(i, len(matrix)):\n                    sum += matrix[k][j]\n                # sum from last row to first row\n                sum = 0\n                for k in range(j, len(matrix[0])):\n                    sum += matrix[i][k]\n                # sum from last row to first row\n                matrix[i][j] = sum\n                # sum from first row to last row\n                matrix[j][i] = sum\n        return\n\n\nif __name__ == \"__main__\":\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Solution().sortRows(matrix)\n    print(matrix)\n    # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
    "class Solution(object):\n    def sumMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] += matrix[i][j+1] if i < n-1 else matrix[i][j]\n                matrix[i][j] += matrix[i+1][j] if j < m-1 else matrix[i][j]\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] -= matrix[i][j] / 2\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] += matrix[i][j] / 2\n        for i in range(n):\n            for j in range(m):\n                matrix[i][j] /= 2\n        for i in range(n-1, -1, -1):\n            for j in range(m-1, -1, -1):\n                matrix[i][j] += matrix[i+1][j+1] if i < n-1 and j < m-1 else matrix[i][j]\n                matrix[i][j] += matrix[i+1][j] if i < n-1 else matrix[i][j]\n                matrix[i][j] += matrix[i][j+1] if j < m-1 else matrix[i][j]\n                matrix[i][j] += matrix[i+1][j+1] if i < n-1 and j < m-1 else matrix[i][j]\n                matrix[i][j] /= 2\n\ns = Solution()\nmatrix = [[-2, 1, -3], [1, -5, 4], [1, -1, -1]]\ns.sumMatrix(matrix)\nprint matrix\n\nmatrix = [[1, 2], [1, 1",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        n = len(cipher)\n        if n == 0:\n            return\n        if n == 1:\n            return\n        for i in range(n):\n            for j in range(i + 1, n):\n                if cipher[j][i] < cipher[i][i]:\n                    cipher[j][i] = cipher[i][i]\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] % 10\n        for i in range(1, n):\n            for j in range(i):\n                cipher[i][j] = cipher[i][j] + cipher[i - 1][j]\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] % 10\n        for i in range(1, n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] + cipher[i - 1][j]\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] % 10\n        for i in range(n - 1, -1, -1):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] + cipher[i + 1][j]\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] % 10\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] + cipher[i][j - 1]\n        for i in range(n):\n            for j in range(n):\n                cipher[i][j] = cipher[i][j] % 10\n        for i in range(n):\n            for j",
    "# https://www.hackerrank.com/challenges/sorting-a-matrix/problem\n# https://www.hackerrank.com/challenges/sorting-a-matrix/examples/python\n\ndef sum_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    :param matrix: A list of lists, where each list represents a row.\n    :return: A list of lists, where each list represents a row.\n    \"\"\"\n    \n    # A helper function to compare two lists\n    def compare(x, y):\n        # If both are equal, we can return 0\n        if x == y:\n            return 0\n        # If one is smaller, we return -1\n        if x < y:\n            return -1\n        # Otherwise, we return 1\n        return 1\n    \n    # A helper function to add two lists\n    def add(x, y):\n        # If both are equal, we can return 0\n        if x == y:\n            return 0\n        # If one is smaller, we return -1\n        if x < y:\n            return -1\n        # Otherwise, we return 1\n        return 1\n    \n    # A helper function to check if a row is empty\n    def is_empty(row):\n        # If the row is empty, we return False\n        if row == []:\n            return False\n        # Otherwise, we return True\n        return True\n    \n    # A helper function to calculate the sum of a row\n    def sum_row(row):\n        # If the row is empty, we return 0\n        if not is_empty(row):\n            return sum(row)\n        # Otherwise, we return 0\n        return 0\n    \n    # A helper function to calculate the sum of a list\n    def sum_list(matrix):\n        # If the list is empty, we return 0\n        if not matrix:\n            return 0\n        # Otherwise, we return the sum of the list\n        return sum(matrix)\n    \n    # A helper function to sort the matrix\n    def sort_matrix(matrix):\n        # If the matrix is empty, we return it\n        if not matrix",
    "# Definition for a matrix:\nclass Matrix:\n    def __init__(self, m, n):\n        self.matrix = []\n        for i in range(m):\n            self.matrix.append(list())\n            for j in range(n):\n                self.matrix[i].append(0)\n        self.m = m\n        self.n = n\n\n    def sum(self):\n        sum = 0\n        for i in range(self.m):\n            sum += self.matrix[i][0]\n        return sum\n\n\nclass Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: Matrix\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = matrix.m\n        n = matrix.n\n        for i in range(m):\n            for j in range(n):\n                sum = matrix.matrix[i][j]\n                if sum < 0:\n                    matrix.matrix[i][j] = sum + j\n                    matrix.matrix[i][j] = -matrix.matrix[i][j]\n                elif sum > 0:\n                    matrix.matrix[i][j] = sum - j\n                else:\n                    matrix.matrix[i][j] = 0\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# obj.sortMatrix(matrix)",
    "class Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n == 0:\n            return\n        elif n == 1:\n            matrix[0] = sorted(matrix[0])\n            return\n        elif n == 2:\n            matrix[0] = sorted(matrix[0])\n            matrix[1] = sorted(matrix[1])\n            return\n        elif n == 3:\n            matrix[0] = sorted(matrix[0])\n            matrix[1] = sorted(matrix[1])\n            matrix[2] = sorted(matrix[2])\n            return\n        elif n == 4:\n            matrix[0] = sorted(matrix[0])\n            matrix[1] = sorted(matrix[1])\n            matrix[2] = sorted(matrix[2])\n            matrix[3] = sorted(matrix[3])\n            return\n        else:\n            self.sortMatrix(matrix[0:n-1])\n            self.sortMatrix(matrix[n-1:n])\n\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][j] = matrix[i][j] + matrix[i][j-1] - matrix[i][j-2]\n\n    def sortMatrix2(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n == 0:\n            return\n        elif n == 1:\n            matrix[0] = sorted(matrix[0])\n            return\n        elif n == 2:\n            matrix[0] = sorted(matrix[0])\n            matrix[1] = sorted(matrix[1])\n            return\n        elif n == 3:\n            matrix[0] = sorted(matrix",
    "class Solution:\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n < 2:\n            return\n        m = len(matrix[0])\n        for i in range(n):\n            matrix[i][0] = matrix[i][0] + matrix[i][m - 1]\n        for j in range(1, m):\n            matrix[0][j] = matrix[0][j] + matrix[n - 1][j - 1]\n        for i in range(1, n):\n            for j in range(1, m):\n                matrix[i][j] = matrix[i][j] + matrix[i - 1][j]\n        for i in range(n - 1, 0, -1):\n            for j in range(m - 1, 0, -1):\n                matrix[i][j] = matrix[i][j] + matrix[i + 1][j]\n        for i in range(1, n):\n            for j in range(1, m):\n                matrix[i][j] = matrix[i][j] - matrix[i - 1][j - 1]\n        for j in range(m - 2, 0, -1):\n            for i in range(1, n):\n                matrix[i][j] = matrix[i][j] - matrix[i][j + 1]\n\n\n\n# Note:\n# The idea is to sort each row according to the sum of the other rows.\n#\n# Time complexity: O(n^2)\n# Space complexity: O(1)",
    "# https://www.hackerrank.com/challenges/sorting-matrix/problem\n\ndef sort_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # Build a list of lists to hold the rows of each element\n    rows = [[] for _ in range(len(matrix))]\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            rows[i].append(matrix[i][j])\n\n    # Sort each row\n    for i in range(len(matrix)):\n        rows[i].sort()\n\n    # Return the sorted rows\n    return rows\n\nif __name__ == '__main__':\n    matrix = [[3, -1, -2], [-3, 4, -1], [1, -3, 3]]\n    result = sort_matrix(matrix)\n    print(result)",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortRows(self, matrix):\n        if not matrix:\n            return\n\n        n = len(matrix)\n        for i in range(n):\n            self.sortRow(matrix, i, n)\n\n    def sortRow(self, matrix, i, n):\n        if i == n - 1:\n            return\n        \n        rowSum = 0\n        for j in range(i + 1, n):\n            rowSum += matrix[j][i]\n        rowSum += matrix[i][i]\n        self.swap(matrix, i, n - 1)\n        self.sortRow(matrix, i + 1, n)\n        self.swap(matrix, i, n - 1)\n        self.sortRow(matrix, i + 1, n)\n\n    def swap(self, matrix, i, j):\n        temp = matrix[i][j]\n        matrix[i][j] = matrix[j][i]\n        matrix[j][i] = temp",
    "class Solution(object):\n    def sortCols(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: void Do not return anything, modify mat in-place instead.\n        \"\"\"\n        n = len(mat)\n        for i in range(n):\n            mat[i][0], mat[i][n-1] = mat[i][n-1], mat[i][0]\n        for i in range(1, n):\n            for j in range(n-1):\n                mat[i][j] = mat[i][j-1] + mat[i][j+1]\n        for j in range(n-1):\n            mat[0][j] = mat[0][j+1]\n        for i in range(1, n):\n            for j in range(n-1):\n                mat[i][j] = mat[i-1][j] + mat[i][j]",
    "import numpy as np\nfrom matplotlib import pyplot as plt\n\ndef matrix_sort(matrix):\n    \"\"\"\n    Sort a given matrix according to the sum of its rows.\n\n    :param matrix: A numpy matrix\n    :return: A numpy matrix\n    \"\"\"\n    matrix = np.array(matrix)\n    sum_matrix = matrix.sum(axis=1)\n    indices = np.argsort(sum_matrix)\n    return matrix[indices, :]\n\ndef matrix_sort_test():\n    matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    matrix_sort(matrix)\n    plt.imshow(matrix)\n    plt.show()\n\nif __name__ == '__main__':\n    matrix_sort_test()",
    "import math\n\n\ndef sum_matrix(matrix):\n    s = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            s += matrix[i][j]\n    return s\n\n\ndef matrix_sort(matrix):\n    m = len(matrix)\n    n = len(matrix[0])\n    if m < n:\n        return matrix_sort(matrix[:]) + matrix_sort(matrix[m:])\n    if m == n:\n        return matrix\n    return [matrix[:]] + matrix_sort(matrix[:]) + matrix_sort(matrix[m:])\n\n\ndef main():\n    matrix = [\n        [1, 2, 3, 4, 5],\n        [6, 7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]]\n    print(sum_matrix(matrix))\n    print(matrix_sort(matrix))\n    print(matrix)\n\nif __name__ == '__main__':\n    main()",
    "import os\n\ndef sum_of_rows(matrix):\n    return sum([row for row in matrix])\n\nif __name__ == '__main__':\n    matrix = [[4, 1, 0, 3], [6, 4, 3, 2], [1, 1, 1, 1], [1, 1, 1, 1]]\n    print(sum_of_rows(matrix))\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 1, 1]]\n    print(sum_of_rows(matrix))",
    "class Solution(object):\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n        matrix = sorted(matrix, key=lambda x: sum(x))\n        for i in xrange(len(matrix) - 1):\n            matrix[i] = sorted(matrix[i], key=lambda x: sum(x[1:]))\n        return\n\nif __name__ == '__main__':\n    matrix = [\n        [4, 5, 7, 2],\n        [8, 3, 1, 9],\n        [2, 1, 9, 5],\n        [6, 4, 7, 1]\n    ]\n    Solution().sortRows(matrix)\n    for i in xrange(len(matrix)):\n        print matrix[i]",
    "# https://www.hackerrank.com/challenges/sorting-matrix/problem\n\n# @author: jonat\n\n# TEST\n\n# matrix = [[4,2,1],[2,5,1],[1,1,5]]\n# expected = [[1,1,1],[2,2,2],[4,5,5]]\n# result = [[4,2,1],[1,1,1],[2,2,2],[1,1,1],[2,5,1],[1,1,5]]\n\n# matrix = [[2,3,1,4],[3,6,5,7],[8,1,2,3],[1,5,1,1]]\n# expected = [[1,1,1,1],[2,3,3,2],[3,6,6,5],[4,7,8,5]]\n# result = [[4,2,1,1],[1,1,1,1],[2,3,3,2],[3,6,6,5]]\n\nmatrix = [[2,2,2,2],[2,3,3,2],[2,2,3,2],[2,2,2,2]]\nexpected = [[2,2,2,2],[2,3,3,2],[2,2,3,2],[2,2,2,2]]\nresult = [[2,2,2,2],[2,3,3,2],[2,2,3,2],[2,2,2,2]]\n\n# matrix = [[1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3],[4,4,4,4,4,4,4,4],[5,5,5,5,5,5,5,5],[6,6,6,6,6,6,6,6],[7,7,7,7,7,7,7,7],[8,8,8,8,8,8,8,8],[9,9,9,9,9,9,9,9]]\n# expected = [[1,1,1,1,1,1,1",
    "# https://www.hackerrank.com/challenges/matrix-sum\n\nimport sys\n\nn, m = map(int, sys.stdin.readline().strip().split(' '))\nmatrix = map(int, sys.stdin.readline().strip().split(' '))\n\ndef sum_row(row):\n    return sum(row)\n\ndef sum_row_sorted(row):\n    return sum(sorted(row))\n\ndef sum_row_sorted_2(row):\n    return sum(sorted(row, reverse=True))\n\ndef sum_row_sorted_3(row):\n    return sum(sorted(row, reverse=True, key=sum_row))\n\ndef sum_row_sorted_4(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False))\n\ndef sum_row_sorted_5(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True))\n\ndef sum_row_sorted_6(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True, reverse=True))\n\ndef sum_row_sorted_7(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True, reverse=True, reverse=True))\n\ndef sum_row_sorted_8(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True, reverse=True, reverse=True, reverse=True))\n\ndef sum_row_sorted_9(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True, reverse=True, reverse=True, reverse=True, reverse=True))\n\ndef sum_row_sorted_10(row):\n    return sum(sorted(row, reverse=True, key=sum_row, reverse=False, reverse=True, reverse=True, reverse=True, reverse=True, reverse",
    "# https://leetcode.com/problems/sort-matrix/\n# Definition for a  Matrix with  rows and  columns.\nclass Matrix(object):\n    def __init__(self, m, n):\n        \"\"\"\n        Initialize your data structure here.\n        :type m: int\n        :type n: int\n        \"\"\"\n        self.matrix = [[0 for x in xrange(n)] for x in xrange(m)]\n\n    def sum(self, row, col):\n        \"\"\"\n        Sum of the elements in the specified row and column.\n        :type row: int\n        :type col: int\n        :rtype: int\n        \"\"\"\n        return sum(self.matrix[row][col])\n\n    def set(self, row, col, val):\n        \"\"\"\n        Set the element at row, column to val.\n        :type row: int\n        :type col: int\n        :type val: int\n        \"\"\"\n        self.matrix[row][col] = val\n\n    def sumRegion(self, row_start, col_start, row_end, col_end):\n        \"\"\"\n        Sum of the elements in the specified region.\n        :type row_start: int\n        :type col_start: int\n        :type row_end: int\n        :type col_end: int\n        :rtype: int\n        \"\"\"\n        sum = 0\n        for i in xrange(row_start, row_end + 1):\n            for j in xrange(col_start, col_end + 1):\n                sum += self.matrix[i][j]\n        return sum\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# numMatrix = NumMatrix(m, n)\n# numMatrix.sumRegion(0, 1, 2, 3)\n# numMatrix.set(1, 1, 10)\n# numMatrix.sumRegion(1, 1, 2, 2)",
    "def matrix_sum_sort(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: None\n    \"\"\"\n    if not matrix:\n        return\n    \n    row_sum = [sum(row) for row in matrix]\n    row_sum.sort()\n    matrix = [row for row in matrix if row[0] == row_sum[0]]\n    matrix = [row for row in matrix if row[1] == row_sum[1]]\n    matrix = [row for row in matrix if row[2] == row_sum[2]]\n    matrix = [row for row in matrix if row[3] == row_sum[3]]\n    matrix = [row for row in matrix if row[4] == row_sum[4]]\n    matrix = [row for row in matrix if row[5] == row_sum[5]]\n    matrix = [row for row in matrix if row[6] == row_sum[6]]\n    matrix = [row for row in matrix if row[7] == row_sum[7]]\n    matrix = [row for row in matrix if row[8] == row_sum[8]]\n    matrix = [row for row in matrix if row[9] == row_sum[9]]\n    \n    return matrix\n\nif __name__ == '__main__':\n    matrix = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36], [37, 38, 39, 40, 41, 42], [43, 44, 45, 46, 47, 48], [49, 50, 51, 52, 53, 54]]\n    matrix_sum_sort(matrix)",
    "class Solution(object):\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        self.sort(matrix, 0, len(matrix)-1)\n\n    def sort(self, matrix, i, j):\n        if i >= j:\n            return\n\n        # print(\"i,j: %d, %d\" % (i, j))\n        # print(\"matrix[%d]: %s\" % (i, matrix[i]))\n        # print(\"matrix[%d]: %s\" % (j, matrix[j]))\n        sum1 = sum(matrix[i])\n        sum2 = sum(matrix[j])\n        if sum1 > sum2:\n            matrix[j] = matrix[i]\n            self.sort(matrix, i, j-1)\n        else:\n            matrix[i] = matrix[j]\n            self.sort(matrix, i+1, j-1)",
    "class Solution(object):\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        def sort_row(matrix, row_start, row_end):\n            for i in range(row_start, row_end):\n                matrix[row_start][i] += matrix[row_start][i-1]\n                matrix[row_end][i] += matrix[row_end][i-1]\n                matrix[row_start][i] -= matrix[row_end][i]\n                matrix[row_end][i] -= matrix[row_end][i-1]\n                matrix[row_start][i] += matrix[row_start][i-1]\n                matrix[row_end][i] += matrix[row_end][i-1]\n                matrix[row_start][i] -= matrix[row_start][i-1]\n                matrix[row_end][i] -= matrix[row_end][i-1]\n\n        matrix.sort(key=lambda x: x[0])\n        for i in range(len(matrix)):\n            sort_row(matrix, i, i)\n        return matrix\n\n    def sortRows_dp(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        matrix.sort(key=lambda x: x[0])\n        m, n = len(matrix), len(matrix[0])\n        sum_matrix = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                sum_matrix[i][j] = sum(matrix[i][j::])\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    sum_matrix[i][j] += sum_matrix[i][j-1]\n                else:\n                    sum_matrix[i][j",
    "class Solution(object):\n    def solve(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if not n:\n            return\n\n        self.sort(matrix, 0, n - 1)\n\n    def sort(self, matrix, start, end):\n        if start == end:\n            return\n\n        m = end - start + 1\n        pivot = matrix[start][0]\n        i = j = start\n        for j in xrange(start + 1, end + 1):\n            if matrix[j][0] <= pivot:\n                matrix[i], matrix[j] = matrix[j], matrix[i]\n                i += 1\n            if matrix[j][0] > pivot:\n                matrix[j], matrix[i] = matrix[i], matrix[j]\n                j -= 1\n        matrix[i], matrix[start] = matrix[start], matrix[i]\n        self.sort(matrix, start, i - 1)\n        self.sort(matrix, i + 1, end)\n\nif __name__ == '__main__':\n    matrix = [[4, 2, 5, 1, 3], [1, 2, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]\n    matrix = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]\n    matrix = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]\n    matrix = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3,",
    "class Solution:\n    \"\"\"\n    @param matrix, a list of lists of integers\n    @return nothing\n    \"\"\"\n    def sortCol(self, matrix):\n        # write your code here\n        if matrix == None or len(matrix) == 0:\n            return\n        m, n = len(matrix), len(matrix[0])\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[j][i] = matrix[j][i] - sum(matrix[i])\n        for i in xrange(n):\n            for j in xrange(m):\n                matrix[j][i] = matrix[j][i] + sum(matrix[i])\n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - sum(matrix[i])\n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] + sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] + sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix[i][j] = matrix[i][j] - sum(matrix[i])\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                matrix",
    "# https://oj.leetcode.com/problems/sort-matrix/\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport sys\nsys.path.append('../')\nimport collections\nfrom common.tree_node import TreeNode\n\nclass Solution:\n    def sortCols(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        res = collections.defaultdict(list)\n        self.traverse(root, res)\n        for i in range(len(res)):\n            for j in range(i + 1, len(res)):\n                if res[i][0] + res[j][0] > res[i][0]:\n                    res[i], res[j] = res[j], res[i]\n        return root\n\n    def traverse(self, root, res):\n        if root is None:\n            return\n        self.traverse(root.left, res)\n        self.traverse(root.right, res)\n        res[root.val].append(root.val)\n\nif __name__ == '__main__':\n    root = TreeNode(val=1, left=TreeNode(val=2, left=TreeNode(val=3), right=TreeNode(val=4)), right=TreeNode(val=5))\n    root.left.right = root.right\n    root.right.left = root.left\n    root.right.right = root.right\n    root.left.right.right = root.right\n    root.left.right.right.right = root.left\n    res = Solution().sortCols(root)\n    print(res.val, res.left.val, res.right.val)",
    "# https://www.hackerrank.com/challenges/sorting-matrix/problem\n\n# from random import randint\n# import time\n\n# def matrix_sum(matrix):\n#     return sum([sum(row) for row in matrix])\n\ndef matrix_sum(matrix):\n    # matrix = [[randint(1, 100) for row in range(3)] for col in range(3)]\n    # matrix = [[1, 2, 3], [2, 3, 4], [4, 3, 2], [1, 2, 3], [2, 3, 4]]\n    # matrix = [[3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n    # matrix = [[2, 1, 3], [3, 1, 2], [1, 2, 3], [2, 3, 1], [3, 2, 1]]\n    # matrix = [[1, 2, 3], [3, 4, 1], [2, 1, 3], [1, 3, 2], [2, 3, 1]]\n    # matrix = [[1, 2, 3], [1, 3, 2], [2, 3, 1], [3, 1, 2], [2, 1, 3]]\n    # matrix = [[3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n    # matrix = [[2, 1, 3], [3, 1, 2], [1, 2, 3], [2, 3, 1], [3, 2, 1]]\n    # matrix = [[1, 2, 3], [3, 4, 1], [2, 1, 3], [1, 3, 2], [2, 3, 1]]\n    # matrix = [[1, 2, 3], [1, 3, 2], [2, 3, 1], [3, 1, 2], [2, 1, 3]]\n    # matrix = [[3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 2, 3], [2, 3, 1]]\n    # matrix = [[2, 1, 3], [3,",
    "def sum_row(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    # for i in range(m):\n    #     for j in range(n):\n    #         if i == 0:\n    #             matrix[i][j] = matrix[i][j-1] + matrix[i][j]\n    #         else:\n    #             matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1]) + matrix[i][j]\n    #         if i == m-1:\n    #             matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1]) + matrix[i][j]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0:\n                matrix[i][j] = matrix[i][j-1] + matrix[i][j]\n            else:\n                matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1]) + matrix[i][j]\n            if i == m-1:\n                matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1]) + matrix[i][j]\n\nif __name__ == '__main__':\n    matrix = [\n        [3, 1, 1, 2],\n        [5, 1, 2, 1],\n        [2, 2, 2, 1],\n        [4, 2, 1, 1],\n    ]\n\n    sum_row(matrix)\n    print(matrix)\n\n    matrix = [\n        [3, 1, 1, 2],\n        [5, 1, 2, 1],\n        [2, 2, 2, 1],\n        [4, 2, 1, 1],\n    ]\n\n    sum_row(matrix)\n    print(matrix)\n\n    matrix = [\n        [1, 2,",
    "def sum_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # write your code here\n    n = len(matrix)\n    if n == 0:\n        return matrix\n    if n == 1:\n        return [[matrix[0][0]]]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if matrix[i][j] > matrix[i][j - 1]:\n                matrix[i][j], matrix[i][j - 1] = matrix[i][j - 1], matrix[i][j]\n    return sum_matrix(matrix)\n\n#print(sum_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\nprint(sum_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))",
    "class Solution:\n    \"\"\"\n    @param matrix: a matrix of integers\n    @return: void\n    \"\"\"\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i+1, n):\n                if matrix[i][0] < matrix[j][0]:\n                    matrix[i], matrix[j] = matrix[j], matrix[i]\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][j] = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][j] = 0\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][j] = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][0] += matrix[j][0]\n                matrix[i][j] = 0\n\n\ndef main():\n    matrix = [[1,2,3],[4,5,6],[7,8,9]]\n    Solution().sortRows(matrix)\n    for row in matrix:\n        print row\n\nif __name__ == \"__main__\":\n    main()",
    "def sum_matrix(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    def _sum_matrix(matrix):\n        if not matrix:\n            return matrix\n\n        rows = [0] * len(matrix)\n        for i in range(len(matrix)):\n            rows[i] = matrix[i][0]\n\n        for i in range(1, len(matrix)):\n            for j in range(len(matrix)):\n                rows[j] += matrix[j][i]\n\n        for i in range(len(matrix)):\n            matrix[i][0] = rows[i]\n\n        return _sum_matrix(matrix)\n\n    return _sum_matrix(matrix)\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# numMatrix = NumMatrix()\n# numMatrix.sum_matrix(matrix)",
    "import numpy as np\n\ndef sum_matrix(matrix):\n    \"\"\"\n    :type matrix: numpy.ndarray\n    :rtype: numpy.ndarray\n    \"\"\"\n    return np.sum(matrix, axis=0)\n\n\ndef main():\n    matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    matrix_sorted = sum_matrix(matrix)\n\n    print(matrix_sorted)\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def sortBySum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        self.sortBySum_recursive(matrix)\n\n    def sortBySum_recursive(self, matrix):\n        if not matrix:\n            return\n\n        row_sum = [0] * len(matrix[0])\n        for i in range(len(matrix)):\n            row_sum[i] = sum(matrix[i])\n        row_sum.sort()\n        for i in range(len(row_sum)):\n            matrix[i] = [row_sum[i]] + matrix[i]\n        for i in range(len(matrix) - 1):\n            matrix[i][0] += matrix[i+1][0]\n        self.sortBySum_recursive(matrix)",
    "__author__ = 'Danyang'\n# https://github.com/danyang923/2014/blog/master/coding/2014-10-23-python-design-pattern-2.md\n\n\nclass Solution:\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        if n <= 1:\n            return\n\n        sum = [0] * n\n        for i in range(n):\n            for j in range(n):\n                sum[i] += matrix[i][j]\n        sum.sort()\n\n        for i in range(n):\n            for j in range(n):\n                matrix[i][j] = sum[j]",
    "class Solution(object):\n    def sortRows(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        for i in range(len(matrix)):\n            matrix[i][0] += matrix[i][i]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] += matrix[i][j+1]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] -= matrix[i][j+1]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] = matrix[i][j] // matrix[i][j+1]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] = matrix[i][j] % matrix[i][j+1]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] = matrix[i][j] * matrix[i][j+1]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] = matrix[i][j] / matrix[i][j+1]",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: List[List[int]]\n        :rtype: void Do not return anything, modify cipher in-place instead.\n        \"\"\"\n        m, n = len(cipher), len(cipher[0])\n        ans = [[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            for j in range(n):\n                ans[i][j] = cipher[i][j]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    ans[i][j] += ans[i][j-1]\n                elif j == 0:\n                    ans[i][j] += ans[i-1][j]\n                else:\n                    ans[i][j] += min(ans[i-1][j], ans[i][j-1])\n        for i in range(m):\n            for j in range(n):\n                cipher[i][j] = ans[i][j]\n        return",
    "class Solution:\n    def sortMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        matrix.sort(key=lambda x: sum(x))\n        for i in range(len(matrix)):\n            matrix[i].sort(key=lambda x: sum(x))",
    "class Solution:\n    # @param matrix, a list of lists of integers\n    # @return nothing\n    def sortCol(self, matrix):\n        if not matrix:\n            return\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] > 0:\n                    matrix[i][j] = matrix[i][j] - matrix[i][n - 1]\n                else:\n                    matrix[i][j] = matrix[n - 1][j]\n        for i in range(n - 1):\n            for j in range(n - 1, 0, -1):\n                matrix[i][j] = matrix[i][j] + matrix[i][j - 1]\n        for i in range(n - 1):\n            for j in range(n - 1, 0, -1):\n                matrix[i][j] = matrix[i][j] - matrix[i][j + 1]\n\n\nif __name__ == '__main__':\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    solution = Solution()\n    solution.sortCol(matrix)\n    for i in range(len(matrix)):\n        print(matrix[i])"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}