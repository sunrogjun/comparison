{
  "problem": {
    "task_id": "MBPP/152",
    "prompt": "Write a function to sort the given array by using merge sort.",
    "canonical_solution": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n",
    "test_list": [
      "assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]",
      "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]",
      "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]"
    ],
    "challenge_test_list": [],
    "problem_id": 141
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeSort(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        mid = self.mergeSort(head.next)\n        head.next = self.mergeSort(head)\n        mid.next = self.mergeSort(mid.next)\n        return head",
    "import random\n\ndef merge(arr, left, mid, right):\n    \"\"\"\n    Given the left and right subarrays, merge them into a single sorted array.\n    \"\"\"\n    n = left + right\n    result = [0] * (n + 1)\n    p = 0\n    for i in range(left, right + 1):\n        if p + 1 < mid and arr[i] < arr[p + 1]:\n            result[p + 1] = arr[i]\n            p += 1\n        else:\n            result[p] = arr[i]\n            p += 1\n    return result\n\ndef merge_sort(arr):\n    \"\"\"\n    Merge sort is a divide and conquer algorithm that sorts a list of lists of\n    numbers by dividing the list into two sublists, then sorting each sublist\n    using the merge sort algorithm.\n    \"\"\"\n    if len(arr) == 0:\n        return arr\n    else:\n        left = 0\n        right = len(arr) - 1\n        while left < right:\n            mid = left + (right - left) / 2\n            if arr[mid] < arr[right]:\n                right = mid\n            else:\n                left = mid + 1\n        arr = merge(arr, left, right, len(arr) - 1)\n        return arr\n\ndef print_sorted(arr):\n    \"\"\"\n    Print the sorted array.\n    \"\"\"\n    for i in range(0, len(arr)):\n        print(arr[i], end=\" \")\n    print()\n\nif __name__ == '__main__':\n    arr = [random.randint(0, 100) for i in range(100)]\n    print_sorted(arr)\n    arr = merge_sort(arr)\n    print_sorted(arr)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        mid = head\n        left = head.next\n        right = head.next.next\n        while right is not None:\n            mid = self.merge(left, mid, right)\n            left = left.next\n            right = right.next\n        return mid\n    \n    def merge(self, left, mid, right):\n        if left is None:\n            return right\n        if right is None:\n            return left\n        if left.val < mid.val:\n            left.next = self.merge(left.next, mid, right)\n            return left\n        else:\n            mid.next = self.merge(left, mid, right)\n            return mid\n\nif __name__ == \"__main__\":\n    head = ListNode(3)\n    head.next = ListNode(10)\n    head.next.next = ListNode(9)\n    head.next.next.next = ListNode(20)\n    head.next.next.next.next = ListNode(15)\n    head.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next.next.next = ListNode(1)\n    head.next.next.next.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(5)\n    head.next.next.",
    "def merge_sort(arr):\n    \"\"\"\n    Merge sort is a divide and conquer algorithm.\n\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge sort is a divide and conquer algorithm.\n\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left[0])\n            left = left[1:]\n        else:\n            result.append(right[0])\n            right = right[1:]\n\n    if left:\n        result.extend(left)\n    if right:\n        result.extend(right)\n    return result\n\nif __name__ == '__main__':\n    arr = [1, 3, 2, 4, 5, 7, 6]\n    print(merge_sort(arr))",
    "def merge(arr):\n    if len(arr) < 2:\n        return arr\n    p = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < p:\n            p = arr[i]\n        else:\n            arr[i], arr[0] = arr[0], arr[i]\n    return arr\n\ndef merge_sort(arr):\n    if len(arr) == 1:\n        return arr\n    p = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < p:\n            p = arr[i]\n        else:\n            arr[i], arr[0] = arr[0], arr[i]\n    arr = merge(arr)\n    return arr\n\ndef test():\n    arr = [4, 5, 3, 2, 1]\n    print(merge_sort(arr))\n\nif __name__ == '__main__':\n    test()",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    if i < len(left):\n        result.extend(left[i:])\n    if j < len(right):\n        result.extend(right[j:])\n    return result\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(arr)\n    print(merge_sort(arr))\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print(arr)\n    print(merge_sort(arr))\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n    print(arr)\n    print(merge_sort(arr))\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n    print(arr)\n    print(merge_sort(arr))\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,",
    "def merge_sort(arr):\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    merge_sort(left)\n    merge_sort(right)\n\n    i = 0\n    j = 0\n    k = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    if i < len(left):\n        arr[k:k+len(left)] = left[i:]\n    else:\n        arr[k:k+len(right)] = right[j:]\n\n    return arr\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 1, 4, 5, 6]\n    print(merge_sort(arr))",
    "def merge_sort(arr):\n    \"\"\"\n    Input:\n    arr = [6, 2, 3, 1, 4, 8, 7]\n\n    Output:\n    arr = [1, 2, 3, 4, 6, 7, 8]\n    \"\"\"\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    res = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            res.append(left[i])\n            i += 1\n        else:\n            res.append(right[j])\n            j += 1\n    res.extend(left[i:])\n    res.extend(right[j:])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print merge_sort([6, 2, 3, 1, 4, 8, 7])",
    "\"\"\"\nFor the given array, we have the following information:\n\n- The size of the array is N.\n- The size of each element of the array is 1-100.\n- The elements of the array are randomly generated.\n\"\"\"\n\n\"\"\"\nExample:\n\nInput:\n    [[3,2,1,5],\n     [7,6,4,8],\n     [1,2,3,4]]\n\nOutput:\n    [[1,2,3,4],\n     [1,2,3,5],\n     [1,2,4,5],\n     [1,3,4,5],\n     [2,3,4,5],\n     [3,4,5,5]]\n\"\"\"\n\nclass Solution(object):\n    def mergeSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(A) <= 1:\n            return A\n        mid = len(A) // 2\n        left = self.mergeSort(A[:mid])\n        right = self.mergeSort(A[mid:])\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        \"\"\"\n        :type left: List[int]\n        :type right: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        while len(left) and len(right):\n            if left[0] <= right[0]:\n                ans.append(left.pop(0))\n            else:\n                ans.append(right.pop(0))\n        ans += left + right\n        return ans\n\nif __name__ == \"__main__\":\n    assert Solution().mergeSort([3,2,1,5]) == [1,2,3,5]\n    assert Solution().mergeSort([7,6,4,8]) == [4,6,7,8]\n    assert Solution().mergeSort([1,2,3,4]) == [1,2,3,4]",
    "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: void\n    \"\"\"\n    def sort(self, nums):\n        if len(nums) < 2:\n            return\n\n        self.merge(nums, 0, len(nums) - 1)\n\n    def merge(self, nums, start, end):\n        if start < end:\n            mid = start + (end - start) / 2\n            self.merge(nums, start, mid)\n            self.merge(nums, mid + 1, end)\n            self.merge(nums, start, mid)\n\n\nif __name__ == '__main__':\n    nums = [3, 2, 1, 5, 6, 4]\n    s = Solution()\n    s.sort(nums)\n    print nums",
    "import random\n\ndef merge_sort(arr):\n    \"\"\"\n    Merge sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        left = merge_sort(left)\n        right = merge_sort(right)\n\n        return merge(left, right)\n\n\ndef merge(left, right):\n    \"\"\"\n    Merge sort helper\n    \"\"\"\n    result = []\n\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\n\nif __name__ == \"__main__\":\n    array = [random.randint(0, 10) for _ in range(1000)]\n    print(array)\n    print(\"Merge sort:\", merge_sort(array))\n    print(\"Merge sort:\", merge(array[:int(len(array) / 2)], array[int(len(array) / 2):]))",
    "def merge_sort(arr):\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return merge_sort(left) + arr[:mid] + merge_sort(right)\n\ndef test():\n    assert merge_sort([1,3,2]) == [1,2,3]\n    assert merge_sort([2,5,1,3]) == [1,2,3,5]\n    assert merge_sort([2,1,5,3,4]) == [1,2,3,4,5]\n    assert merge_sort([]) == []\n    assert merge_sort([3,2,1]) == [1,2,3]\n    assert merge_sort([1,1,1,2,3]) == [1,1,2,3]\n    assert merge_sort([3,1,2,1]) == [1,2,3]\n\nif __name__ == '__main__':\n    test()",
    "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = arr[:mid]\n        right = arr[mid:]\n        left_result = mergeSort(left)\n        right_result = mergeSort(right)\n        return merge(left_result, right_result)\n\n\ndef merge(left, right):\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\n\ndef main():\n    arr = [6, 3, 7, 4, 2, 5, 1]\n    print(arr)\n    arr_sorted = mergeSort(arr)\n    print(arr_sorted)\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def merge(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        mid = self.getMid(head)\n        left = self.merge(head)\n        right = self.merge(mid)\n        return self.merge(left, mid, right)\n\n    def getMid(self, head):\n        p1 = head\n        p2 = head\n        while p1 and p2:\n            if p1.val > p2.val:\n                p1 = p1.next\n            else:\n                p2 = p2.next\n        return p1\n\n\nif __name__ == '__main__':\n    n1 = ListNode(1)\n    n2 = ListNode(2)\n    n3 = ListNode(3)\n    n4 = ListNode(4)\n    n5 = ListNode(5)\n    n6 = ListNode(6)\n    n7 = ListNode(7)\n    n8 = ListNode(8)\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    n4.next = n5\n    n5.next = n6\n    n6.next = n7\n    n7.next = n8\n    n8.next = None\n\n    s = Solution()\n    res = s.merge(n1)\n    while res:\n        print res.val\n        res = res.next\n    print",
    "class Solution(object):\n    def merge(self, left, right):\n        \"\"\"\n        :type left: List[int]\n        :type right: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(left) == 0 or len(right) == 0:\n            return []\n        if len(left) == 1:\n            return [left[0]] + right\n        if len(right) == 1:\n            return left + [right[0]]\n        mid = len(left) // 2\n        left = self.merge(left[:mid], right[:mid])\n        right = self.merge(left[mid:], right[mid:])\n        return left + right\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.merge([1], [2])\n    print solution.merge([1,2,3,4,5], [2,3,4,5,6])\n    print solution.merge([1,2], [2,3])\n    print solution.merge([1,2,3], [1,2,3,4])\n    print solution.merge([1,2,3], [2,3,4])\n    print solution.merge([1,2,3,4,5], [2,3,4,5,6])\n    print solution.merge([1,2,3,4,5], [2,3,4,5,6,7])\n    print solution.merge([1,2,3,4,5], [2,3,4,5,6,7,8])\n    print solution.merge([1,2,3,4,5], [2,3,4,5,6,7,8,9])",
    "class Solution(object):\n    def mergeSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        if len(arr) <= 1:\n            return\n        mid = len(arr) // 2\n        self.mergeSort(arr[:mid])\n        self.mergeSort(arr[mid:])\n        self.merge(arr[:mid], arr[mid:])\n        \n    def merge(self, left, right):\n        \"\"\"\n        :type left: List[int]\n        :type right: List[int]\n        :rtype: void Do not return anything, modify left and right in-place instead.\n        \"\"\"\n        p = 0\n        q = 0\n        r = 0\n        while p < len(left) and q < len(right):\n            if left[p] <= right[q]:\n                left[r] = left[p]\n                p += 1\n            else:\n                left[r] = right[q]\n                q += 1\n            r += 1\n        while p < len(left):\n            left[r] = left[p]\n            p += 1\n            r += 1\n        while q < len(right):\n            right[r] = right[q]\n            q += 1\n            r += 1",
    "\"\"\"\nMerge sort\nMerge sort is a simple sorting algorithm that uses recursion to sort\nthe array.\n\"\"\"\ndef mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = mergeSort(arr[:mid])\n        right = mergeSort(arr[mid:])\n        return merge(left, right)\n\n\n\"\"\"\nMerge\nMerge is a simple sorting algorithm that uses recursion to sort\nthe array.\n\"\"\"\ndef merge(left, right):\n    if len(left) == 0 or len(right) == 0:\n        return left + right\n    else:\n        return merge(left[0:len(left)/2] + right[0:len(right)/2] + left[len(left)/2:],\n                     merge(left[len(left)/2:], right[len(right)/2:]))\n\n\n\"\"\"\nTest\nTest cases for merge sort.\n\"\"\"\ndef test():\n    arr = [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    print(mergeSort(arr))\n\n\nif __name__ == \"__main__\":\n    test()",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def mergeSort(self, num):\n        if len(num) == 1:\n            return\n        mid = len(num) / 2\n        left = self.mergeSort(num[:mid])\n        right = self.mergeSort(num[mid:])\n        return self.merge(left, right, num)\n\n    def merge(self, left, right, num):\n        result = []\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                k += 1\n        while i < len(left):\n            result.append(left[i])\n            i += 1\n        while j < len(right):\n            result.append(right[j])\n            j += 1\n            k += 1\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.mergeSort([3,4,1,2,5,7])",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    return [x for x in left] + [x for x in right]\n\narr = [10, 20, 30, 40, 50]\nprint(merge_sort(arr))",
    "import random\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    res = []\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            res.append(left[i])\n            i += 1\n        else:\n            res.append(right[j])\n            j += 1\n    res += left[i:]\n    res += right[j:]\n    return res\n\narr = [random.randint(0, 10000) for _ in range(1000)]\nprint(merge_sort(arr))",
    "def merge(arr):\n    \"\"\"\n    Merge sort\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return merge(left) + arr + merge(right)\n\ndef merge_sort(arr):\n    \"\"\"\n    Merge sort\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return merge_sort(left) + arr + merge_sort(right)\n\n\ndef main():\n    print merge_sort([1,3,2,4,5,7])\n\nif __name__ == \"__main__\":\n    main()",
    "import sys\n\n\ndef merge_sort(array):\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n\n    result.extend(left)\n    result.extend(right)\n\n    return result\n\n\nif __name__ == '__main__':\n    n = int(sys.argv[1]) if len(sys.argv) > 1 else 1000000\n\n    array = [random.randint(0, n) for _ in range(n)]\n\n    print('Array: {}'.format(array))\n    print('Merge sort: {}'.format(merge_sort(array)))",
    "def merge_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) / 2\n    left_arr, right_arr = [], []\n    left_arr, right_arr = arr[:mid], arr[mid:]\n    left_arr, right_arr = merge_sort(left_arr), merge_sort(right_arr)\n    return merge(left_arr, right_arr)\n\ndef merge(left_arr, right_arr):\n    \"\"\"\n    :type left_arr: List[int]\n    :type right_arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            result.append(left_arr[i])\n            i += 1\n        else:\n            result.append(right_arr[j])\n            j += 1\n    if i < len(left_arr):\n        result.extend(left_arr[i:])\n    if j < len(right_arr):\n        result.extend(right_arr[j:])\n    return result\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(arr)\n    merge_sort(arr)\n    print(arr)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution:\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        if head.next:\n            return self.mergeSort(head.next)\n        node1 = head\n        node2 = head.next\n        while node1 and node2:\n            if node1.val > node2.val:\n                node1, node2 = node2, node1\n            node1 = node1.next\n            node2 = node2.next\n        if node1:\n            node1.next = self.mergeSort(node1.next)\n        return head\n\n\n# Note:\n# Recursion is not good for merge sort.\n# Use a stack to hold the nodes.",
    "def sort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        middle = len(arr) / 2\n        left = sort(arr[:middle])\n        right = sort(arr[middle:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    left_head = left[0]\n    right_head = right[0]\n    merged = []\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            k += 1\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n        k += 1\n    return merged\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr7 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr9 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr10 = [1, 2, 3, 4, 5, 6, 7, 8, 9,",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        mid = head\n        left = head.next\n        while left and left.next:\n            mid = mid.next\n            left = left.next.next\n\n        right = mid.next\n\n        # merge sort\n        head.next = None\n        mid.next = None\n        self.mergeSort(left)\n        self.mergeSort(right)\n        self.merge(head, left, right)\n\n        return head\n\n    def merge(self, head, left, right):\n        while left and right:\n            if left.val < right.val:\n                head.next = left\n                left = left.next\n            else:\n                head.next = right\n                right = right.next\n\n        head.next = left or right\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    head = ListNode(2)\n    head.next = ListNode(5)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(4)\n\n    head = s.mergeSort(head)\n    while head:\n        print(head.val)\n        head = head.next",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def merge(self, num):\n        \"\"\"\n        merge sort\n        \"\"\"\n        if len(num) <= 1:\n            return num\n\n        mid = len(num) / 2\n        left = self.merge(num[:mid])\n        right = self.merge(num[mid:])\n        res = []\n        i = 0\n        j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                res.append(left[i])\n                i += 1\n            else:\n                res.append(right[j])\n                j += 1\n        res.extend(left[i:])\n        res.extend(right[j:])\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    a = [1,3,5,6,8,9]\n    a = [1,3,5,6,8,9]\n    a = [1,3,5,6,8,9]\n    print(s.merge(a))",
    "class Solution(object):\n    def mergeSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        if len(arr) < 2:\n            return\n        mid = len(arr) // 2\n        left = self.mergeSort(arr[:mid])\n        right = self.mergeSort(arr[mid:])\n        arr[:] = left + right\n\nif __name__ == '__main__':\n    sol = Solution()\n    arr = [1, 2, 3, 4, 5, 6]\n    sol.mergeSort(arr)\n    print(arr)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        else:\n            if head.next:\n                self.mergeSort(head.next)\n                head.next = self.mergeSort(head.next)\n                return head\n            else:\n                return head\n\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        else:\n            newHead = self.mergeSort(head)\n            return newHead",
    "import unittest\nfrom merge_sort import merge_sort\nfrom copy import deepcopy\n\nclass TestMergeSort(unittest.TestCase):\n\n    def test_merge_sort(self):\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]), [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n        self.assertEqual(merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n\n    def test_deepcopy(self):\n        a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n        b = deepcopy(a)\n        merge_sort(a)\n        merge_sort(b)\n        self.assertEqual(a, b)\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def merge(self, left, right):\n        \"\"\"\n        :type left: List[int]\n        :type right: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(left) == 0:\n            return right\n        if len(right) == 0:\n            return left\n        mid = len(left) // 2\n        left_new = self.merge(left[:mid], right[:mid])\n        right_new = self.merge(left[mid:], right[mid:])\n        return self.merge(left_new, right_new)\n\n    def mergeSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) <= 1:\n            return nums\n        left = self.mergeSort(nums[:len(nums)//2])\n        right = self.mergeSort(nums[len(nums)//2:])\n        return self.merge(left, right)\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    s = Solution()\n    print(s.mergeSort(nums))",
    "class Solution:\n    # @param nums: a list of integers\n    # @return: nothing\n    def mergeSort(self, nums):\n        if len(nums) < 2:\n            return\n        mid = len(nums) / 2\n        self.mergeSort(nums[:mid])\n        self.mergeSort(nums[mid:])\n        self.merge(nums, 0, mid, len(nums))\n\n    def merge(self, nums, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        while i <= mid and j <= right:\n            if nums[i] <= nums[j]:\n                nums[k] = nums[i]\n                i += 1\n            else:\n                nums[k] = nums[j]\n                j += 1\n            k += 1\n        while i <= mid:\n            nums[k] = nums[i]\n            k += 1\n            i += 1\n        while j <= right:\n            nums[k] = nums[j]\n            k += 1\n            j += 1\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [2,3,1,4,5,7]\n    sol.mergeSort(nums)\n    print(nums)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        if len(head.next) < 2:\n            return self.mergeSort(head.next)\n\n        mid = head\n        left = head.next\n        right = left.next\n        head.next = None\n        while left and right:\n            if left.val <= right.val:\n                mid.next = left\n                left = left.next\n            else:\n                mid.next = right\n                right = right.next\n\n        if left:\n            mid.next = left\n\n        mid = self.mergeSort(head)\n        mid.next = self.mergeSort(right)\n        return mid\n\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1)\n    l2 = ListNode(2)\n    l3 = ListNode(3)\n    l4 = ListNode(4)\n    l1.next = l2\n    l2.next = l3\n    l3.next = l4\n    l4.next = None\n\n    solution = Solution()\n    l = solution.mergeSort(l1)\n    while l:\n        print(l.val, end='')\n        l = l.next",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def merge(self, intervals):\n        if not intervals:\n            return []\n        if len(intervals) == 1:\n            return intervals\n        middle = len(intervals) // 2\n        left = self.merge(intervals[:middle])\n        right = self.merge(intervals[middle:])\n        return [Interval(min(left[0].start, right[0].start),\n                         max(left[-1].end, right[-1].end))]\n\nif __name__ == '__main__':\n    intervals = [Interval(0, 2), Interval(5, 7), Interval(10, 12)]\n    solution = Solution()\n    print solution.merge(intervals)",
    "class MergeSort(object):\n    \"\"\"\n    MergeSort is a recursive function that sorts a list using merge sort algorithm.\n    \"\"\"\n    def __init__(self, list):\n        self.list = list\n\n    def sort(self):\n        if len(self.list) <= 1:\n            return\n        middle = len(self.list) // 2\n        self.merge(0, middle, self.list)\n        self.merge(middle, len(self.list), self.list)\n\n    def merge(self, start, end, list):\n        if start < end:\n            mid = (start + end) // 2\n            left = self.merge(start, mid, list)\n            right = self.merge(mid + 1, end, list)\n            self.merge_recursive(start, end, left, right, list)\n\n    def merge_recursive(self, start, end, left, right, list):\n        i = start\n        j = end - 1\n        k = start\n        while i <= j:\n            if left[i] < right[j]:\n                list[k] = left[i]\n                i += 1\n            else:\n                list[k] = right[j]\n                j -= 1\n            k += 1\n        while i <= end:\n            list[k] = left[i]\n            i += 1\n            k += 1\n        while j >= 0:\n            list[k] = right[j]\n            j -= 1\n            k += 1\n\n\ndef main():\n    print(MergeSort([6, 2, 5, 1, 3]).sort())\n\nif __name__ == '__main__':\n    main()",
    "def merge_sort(arr):\n    \"\"\"\n    Sort the given array using merge sort.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    middle = len(arr) / 2\n    left = arr[:middle]\n    right = arr[middle:]\n    return merge_sort(left) + arr + merge_sort(right)\n\n\nif __name__ == \"__main__\":\n    print merge_sort([1, 2, 3, 4, 5, 6, 7])",
    "# Merge Sort\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    res = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            res.append(left[i])\n            i += 1\n        else:\n            res.append(right[j])\n            j += 1\n    res.extend(left[i:])\n    res.extend(right[j:])\n    return res\n\n# Merge Sort\ndef merge_sort_recursive(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge_sort_recursive(arr[:mid])\n    right = merge_sort_recursive(arr[mid:])\n    return merge_recursive(left, right)\n\ndef merge_recursive(left, right):\n    res = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            res.append(left[i])\n            i += 1\n        else:\n            res.append(right[j])\n            j += 1\n    res.extend(left[i:])\n    res.extend(right[j:])\n    return res\n\n# Merge Sort\ndef merge_sort_iterative(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge_sort_iterative(arr[:mid])\n    right = merge_sort_iterative(arr[mid:])\n    return merge_iterative(left, right)\n\ndef merge_iterative(left, right):\n    res = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):",
    "import random\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right\n\nif __name__ == '__main__':\n    arr = random.sample(range(1, 10), 10)\n    print(arr)\n    print(\"merge sort:\", merge_sort(arr))",
    "def merge_sort(array):\n    \"\"\"\n    Given an array, sort it using merge sort.\n\n    Time Complexity: O(n log n)\n    \"\"\"\n    if len(array) < 2:\n        return array\n    else:\n        mid = len(array) / 2\n        left = merge_sort(array[:mid])\n        right = merge_sort(array[mid:])\n        return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge two sorted arrays into a new array.\n\n    Time Complexity: O(n log n)\n    \"\"\"\n    merged = []\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            k += 1\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n        k += 1\n    return merged",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n#         self.is_overlapped = False\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def merge(self, intervals):\n        if len(intervals) == 0:\n            return []\n        if len(intervals) == 1:\n            return intervals\n        middle = int(len(intervals) / 2)\n        left = self.merge(intervals[:middle])\n        right = self.merge(intervals[middle:])\n        return self.merge_helper(left, right)\n\n    def merge_helper(self, left, right):\n        if len(left) == 0:\n            return right\n        if len(right) == 0:\n            return left\n        if left[0].end < right[0].start:\n            return self.merge_helper(left, right)\n        if left[0].end >= right[0].start:\n            return [left[0]]\n        if left[0].end < right[0].start:\n            return self.merge_helper(left[1:], right)\n        if left[0].end >= right[0].start:\n            left[0].start = max(left[0].start, right[0].start)\n            left[0].end = min(left[0].end, right[0].end)\n            return left[1:]\n        if left[0].end >= right[0].start:\n            left[0].end = min(left[0].end, right[0].end)\n            return left[1:]\n        if left[0].end < right[0].start:\n            return self.merge_helper(left, right[1:])\n        if left[0].end >= right[0].start:\n            left[0].start = max(left[0].start, right[0].start)\n            left[0].end = min(left[0].end, right[0].",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return intervals\n\n        left = []\n        right = []\n        cur = 0\n        for i in intervals:\n            if i.start < left[-1].end:\n                left.append(i)\n            else:\n                right.append(i)\n                cur += 1\n        if cur == 0:\n            return left\n        if cur == 1:\n            return right\n\n        mid = len(left) / 2\n        cur = 0\n        while cur < mid:\n            left[cur].start = max(left[cur].start, left[cur + 1].start)\n            left[cur].end = min(left[cur].end, left[cur + 1].end)\n            cur += 1\n        left[mid].start = max(left[mid].start, left[cur - 1].start)\n        left[mid].end = min(left[mid].end, left[cur - 1].end)\n        return left\n\n    def mergeSort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return intervals\n\n        if len(intervals) == 1:\n            return intervals\n\n        left = self.mergeSort(intervals[:len(intervals) // 2])\n        right = self.mergeSort(intervals[len(intervals) // 2:])\n        return self.merge(left + right)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    intervals = [Interval(0, 2), Interval(5, 10), Interval(15, 20)]\n    print(sol.mergeSort(intervals))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeSort(self, head: ListNode) -> ListNode:\n        \"\"\"\n        Merge sort.\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        else:\n            head.next = self.mergeSort(head.next)\n            return head\n\n    def merge(self, head: ListNode, p: ListNode, q: ListNode) -> ListNode:\n        if p is None and q is None:\n            return head\n        if p is None:\n            return q\n        if q is None:\n            return p\n        if p.val < q.val:\n            p.next = self.merge(p.next, q, p)\n            return p\n        else:\n            q.next = self.merge(p, q.next, p)\n            return q\n        \n    def mergeSort(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        else:\n            head.next = self.mergeSort(head.next)\n            return self.merge(head, head, head)\n\nif __name__ == '__main__':\n    head = ListNode(0)\n    head.next = ListNode(1)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next",
    "class MergeSort(object):\n    def __init__(self, array):\n        self.array = array\n\n    def sort(self):\n        self.merge_sort(self.array, 0, len(self.array) - 1)\n\n    def merge_sort(self, arr, low, high):\n        if low >= high:\n            return\n\n        mid = (low + high) // 2\n        self.merge_sort(arr, low, mid)\n        self.merge_sort(arr, mid + 1, high)\n        self.merge_sort_recur(arr, low, mid, high)\n\n    def merge_sort_recur(self, arr, low, mid, high):\n        if low < mid and mid < high:\n            arr[low], arr[mid], arr[high] = \\\n                arr[mid], arr[low], arr[high]\n            low += 1\n            high -= 1\n            mid += 1\n            arr[low], arr[mid], arr[high] = \\\n                arr[mid], arr[low], arr[high]\n        else:\n            return",
    "def mergeSort(alist):\n    \"\"\"\n    Merge sort a list using the merge function.\n    \"\"\"\n    if len(alist) <= 1:\n        return alist\n    \n    mid = len(alist) // 2\n    left = mergeSort(alist[:mid])\n    right = mergeSort(alist[mid:])\n    \n    return merge(left, right)\n    \ndef merge(left, right):\n    \"\"\"\n    Merge the two sorted lists left and right using the merge function.\n    \"\"\"\n    merged = []\n    \n    while left and right:\n        if left[0] < right[0]:\n            merged.append(left[0])\n            left.pop(0)\n        else:\n            merged.append(right[0])\n            right.pop(0)\n            \n    if left:\n        merged.extend(left)\n    if right:\n        merged.extend(right)\n    \n    return merged\n\nalist = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nprint(mergeSort(alist))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        mid = head\n        left = head.next\n        right = left.next\n        while left and right:\n            if left.val < right.val:\n                mid.next = left\n                left = left.next\n            else:\n                mid.next = right\n                right = right.next\n            mid = mid.next\n        mid.next = left or right\n        return self.mergeSort(head)",
    "# Merge sort\ndef merge(arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            arr[k] = arr[i]\n            i += 1\n        else:\n            arr[k] = arr[j]\n            j += 1\n        k += 1\n\n    if i > mid:\n        arr[k] = arr[mid]\n\n    if j > right:\n        while i <= mid:\n            arr[k] = arr[i]\n            i += 1\n            k += 1\n    else:\n        while j <= right:\n            arr[k] = arr[j]\n            j += 1\n            k += 1\n\n    return k\n\ndef mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) / 2\n\n        arr = merge(arr, left, mid, right)\n        left = mid + 1\n        right = mid\n\n    return arr\n\n# Merge sort\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) / 2\n\n        arr = merge_sort(arr)\n        arr = merge(arr, left, mid, right)\n        left = mid + 1\n        right = mid\n\n    return arr\n\narr = [7, 8, 1, 4, 5, 2, 3, 9, 6]\n\nprint(arr)\n\narr = mergeSort(arr)\n\nprint(arr)\n\narr = merge_sort(arr)\n\nprint(arr)",
    "def sort(arr):\n  if len(arr) <= 1:\n    return arr\n  else:\n    mid = len(arr) / 2\n    left = sort(arr[:mid])\n    right = sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n  result = []\n  while left and right:\n    if left[0] <= right[0]:\n      result.append(left.pop(0))\n    else:\n      result.append(right.pop(0))\n  result += left + right\n  return result",
    "def merge(arr):\n    \"\"\"\n    Given an array of n elements, return the sorted array.\n    \"\"\"\n    length = len(arr)\n    if length <= 1:\n        return arr\n\n    mid = int(length / 2)\n\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge(left)\n    right = merge(right)\n\n    return merge_sort(left + right)\n\ndef merge_sort(arr):\n    \"\"\"\n    Given an array of n elements, return the sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = int(len(arr) / 2)\n\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort(left)\n    right = merge_sort(right)\n\n    return merge(left + right)\n\nif __name__ == \"__main__\":\n    print merge([4,5,6,7,8])",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def mergeSort(self, nums):\n        if len(nums) <= 1:\n            return\n        mid = len(nums) / 2\n        self.mergeSort(nums[:mid])\n        self.mergeSort(nums[mid:])\n        self.merge(nums, 0, mid, len(nums) - 1)\n\n    def merge(self, nums, left, mid, right):\n        # base case\n        if left >= right:\n            return\n        # merge two subarrays\n        i = left\n        j = mid + 1\n        k = left\n        while i <= mid and j <= right:\n            if nums[i] <= nums[j]:\n                nums[k] = nums[i]\n                i += 1\n            else:\n                nums[k] = nums[j]\n                j += 1\n            k += 1\n        while i <= mid:\n            nums[k] = nums[i]\n            i += 1\n            k += 1\n        while j <= right:\n            nums[k] = nums[j]\n            j += 1\n            k += 1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [1,2,3,4,5,6,7]\n    solution.mergeSort(nums)\n    print nums",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        Merge sort\n\n        - Use two pointers\n        - Merge two lists\n        - Keep track of the largest value\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        p1 = head\n        p2 = head.next\n        p3 = p2.next\n        while p3:\n            # The next node is smaller than the current node, move p3 to the next\n            if p3.val <= p1.val:\n                p1 = p1.next\n                p3 = p3.next\n            # The next node is greater than the current node, move p1 to the next\n            else:\n                p2 = p2.next\n                p1 = p1.next\n                p3 = p3.next\n\n        # If p1 is smaller, move p2 to the end of the list\n        if p1.val < p2.val:\n            p2 = p1\n            p1 = p2.next\n        # If p1 is greater, move p1 to the end of the list\n        else:\n            p1 = p2\n            p2 = p1.next\n        # If p1 is not the last node, move p2 to the end of the list\n        if p2:\n            p2 = p2.next\n        # Move p1 to the last node of the list\n        p1.next = None\n        head = p1\n\n        # Merge two lists\n        while p1 and p2:\n            if p1.val < p2.val:\n                p1.next = p2\n                p2 = p2.next\n            else:\n                p1.next = p1\n                p1 = p1.next\n            p1 = p1.next\n\n        return head\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)",
    "from collections import deque\n\n\ndef merge_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    elif len(arr) == 2:\n        if arr[0] < arr[1]:\n            return [arr[0], arr[1]]\n        else:\n            return [arr[1], arr[0]]\n    else:\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    \"\"\"\n    :type left: List[int]\n    :type right: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result += left + right\n    return result\n\n\nif __name__ == '__main__':\n    assert merge_sort([2, 5, 6, 3, 4]) == [2, 3, 4, 5, 6]\n    assert merge_sort([5, 6, 4, 3, 2]) == [2, 3, 4, 5, 6]\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 6, 3, 4, 2]) == [2, 3, 4, 5, 6]\n    assert merge_sort([2, 3, 4, 5, 6]) == [2, 3, 4, 5, 6]\n    assert merge_sort([2, 5, 6, 3, 4]) == [2, 3, 4, 5, 6]\n    assert merge_sort([5, 6, 4, 3, 2]) == [2, 3, 4",
    "class Solution:\n    # @param nums, a list of integers\n    # @return nothing\n    def mergeSort(self, nums):\n        if len(nums) < 2:\n            return nums\n        mid = len(nums) / 2\n        left = self.mergeSort(nums[:mid])\n        right = self.mergeSort(nums[mid:])\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        result = []\n        while left and right:\n            if left[0] < right[0]:\n                result.append(left.pop(0))\n            else:\n                result.append(right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n\nif __name__ == \"__main__\":\n    nums = [2,5,7,4,6,7]\n    Solution().mergeSort(nums)\n    print(nums)",
    "def mergeSort(arr):\n    \"\"\"\n    >>> mergeSort([1, 2, 3, 4, 5])\n    >>> mergeSort([1, 2, 3, 4, 5])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([2, 3, 4, 5, 1])\n    >>> mergeSort([",
    "\"\"\"\nMerge sort is a divide and conquer algorithm.\n\"\"\"\n\ndef mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    left = arr[:len(arr)/2]\n    right = arr[len(arr)/2:]\n    return mergeSort(left) + mergeSort(right)\n\n\"\"\"\n>>> mergeSort([4, 5, 6, 7, 8])\n[4, 5, 6, 7, 8]\n\n>>> mergeSort([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n\n>>> mergeSort([1, 2, 3])\n[1, 2, 3]\n\"\"\"\n\ndef main():\n    print mergeSort([4, 5, 6, 7, 8])\n    print mergeSort([1, 2, 3, 4, 5])\n    print mergeSort([1, 2, 3])\n\nif __name__ == \"__main__\":\n    main()",
    "from common import merge, sort\n\n\ndef merge_sort(arr):\n    \"\"\"\n    Sort the given array using merge sort.\n    :param arr: The given array.\n    :return: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\ndef sort_array(arr):\n    \"\"\"\n    Sort the given array using merge sort.\n    :param arr: The given array.\n    :return: The sorted array.\n    \"\"\"\n    return merge_sort(arr)\n\n\nif __name__ == \"__main__\":\n    arr = [5, 6, 3, 4, 1, 2]\n    print(sort_array(arr))",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def sort(self, intervals: 'List[Interval]') -> 'List[Interval]':\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        self.sort_rec(intervals, 0, len(intervals))\n        return intervals\n\n    def sort_rec(self, intervals, start, end):\n        if end - start <= 1:\n            return\n\n        mid = (start + end) / 2\n        self.sort_rec(intervals, start, mid)\n        self.sort_rec(intervals, mid, end)\n        self.merge(intervals, start, mid, end)\n        return\n\n    def merge(self, intervals, start, mid, end):\n        result = []\n        i = start\n        j = mid + 1\n        while i < mid and j < end:\n            if intervals[i].start <= intervals[j].start:\n                result.append(intervals[i])\n                i += 1\n            else:\n                result.append(intervals[j])\n                j += 1\n\n        if i < mid:\n            result.extend(intervals[i:mid])\n        elif j < end:\n            result.extend(intervals[j:end])\n\n        intervals[start:end] = result",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def merge(self, A):\n        \"\"\"\n        merge sort\n        \"\"\"\n        if len(A) <= 1:\n            return\n\n        pivot = A[0]\n        left = []\n        right = []\n\n        for i in range(1, len(A)):\n            if A[i] <= pivot:\n                left.append(A[i])\n            else:\n                right.append(A[i])\n\n        self.merge(left)\n        self.merge(right)\n\n        for i in range(0, len(A)):\n            A[i] = self.merge_sort(A[i])\n\n    def merge_sort(self, A):\n        \"\"\"\n        use merge sort to sort\n        \"\"\"\n        if len(A) <= 1:\n            return A\n\n        mid = len(A) / 2\n        left = A[:mid]\n        right = A[mid:]\n\n        left = self.merge_sort(left)\n        right = self.merge_sort(right)\n\n        return self.merge(left + right)",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def mergeSort(self, num):\n        if not num:\n            return\n        mid = len(num)//2\n        left = self.mergeSort(num[:mid])\n        right = self.mergeSort(num[mid:])\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        result = []\n        while left and right:\n            if left[0] <= right[0]:\n                result.append(left.pop(0))\n            else:\n                result.append(right.pop(0))\n        result += left + right\n        return result\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.mergeSort([1, 3, 2, 5, 4, 7]))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        left = head\n        right = head.next\n        while right and right.next:\n            left = self.mergeSort(left.next)\n            right = right.next.next\n        if left is None:\n            return right\n        if right is None:\n            return left\n        left = self.mergeSort(left)\n        right = self.mergeSort(right)\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        if left is None:\n            return right\n        if right is None:\n            return left\n        if left.val <= right.val:\n            left.next = self.merge(left.next, right)\n            return left\n        right.next = self.merge(left, right.next)\n        return right",
    "def merge(arr, low, mid, high):\n    if low < mid:\n        arr[low:high] = merge(arr, low, mid, low + (high - mid))\n    if mid < high:\n        arr[low:high] = merge(arr, low, mid, mid + (high - mid))\n    return arr\n\ndef merge_sort(arr):\n    \"\"\"\n    >>> merge_sort([1, 2, 3, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge_sort([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    if not arr:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, 0, mid, len(right))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "class MergeSort:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def sort(self):\n        if len(self.arr) < 2:\n            return\n        else:\n            middle = len(self.arr) / 2\n            self.sort_by_middle(0, middle - 1)\n            self.sort_by_middle(middle, len(self.arr) - 1)\n\n    def sort_by_middle(self, start, end):\n        if end - start < 2:\n            return\n        else:\n            mid = (end + start) / 2\n            self.merge(start, mid, end)\n\n    def merge(self, start, mid, end):\n        self.arr[start:end + 1] = self.merge_helper(start, mid, end)\n\n    def merge_helper(self, start, mid, end):\n        # The array is already sorted\n        if mid == start:\n            return self.arr[start:end + 1]\n        # The array is already sorted\n        elif mid == end:\n            return self.arr[start:end + 1]\n        # The array is not sorted\n        else:\n            left = self.arr[start:mid + 1]\n            right = self.arr[mid + 1:end + 1]\n            return self.merge_helper(start, mid, end) + left + right\n\n    def print_arr(self):\n        print(self.arr)\n\nif __name__ == \"__main__\":\n    arr = [5, 7, 4, 3, 2, 6]\n    ms = MergeSort(arr)\n    ms.sort()\n    ms.print_arr()",
    "def merge_sort(arr):\n    \"\"\"\n    Input: A list of integers\n    Output: A sorted list\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    \"\"\"\n    Input: A list of integers\n    Output: A sorted list\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left[0])\n            left = left[1:]\n        else:\n            result.append(right[0])\n            right = right[1:]\n    result += left\n    result += right\n    return result\n\n\nif __name__ == \"__main__\":\n    arr = [6, 3, 1, 8, 2, 5, 7, 4]\n    print(merge_sort(arr))",
    "def merge_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    :type left: List[int]\n    :type right: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    while len(left)!= 0 and len(right)!= 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result",
    "class Solution:\n    # @param nums: a list of integers\n    # @return: nothing\n    def mergeSort(self, nums):\n        if len(nums) < 2:\n            return\n        \n        mid = len(nums) / 2\n        self.mergeSort(nums[:mid])\n        self.mergeSort(nums[mid:])\n        \n        i = 0\n        j = 0\n        while i < len(nums) and j < len(nums):\n            if nums[i] < nums[j]:\n                nums[j + 1] = nums[i]\n                i = i + 1\n            else:\n                nums[j + 1] = nums[j]\n                j = j + 1\n        \n        nums[j + 1:len(nums)] = nums[i:]\n    \n    \nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print solution.mergeSort(nums)",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def mergeSort(self, intervals):\n        if len(intervals) <= 1:\n            return intervals\n        mid = len(intervals) / 2\n        left = self.mergeSort(intervals[:mid])\n        right = self.mergeSort(intervals[mid:])\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i].start < right[j].start:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    intervals = [[0, 4], [2, 6], [3, 7], [4, 8]]\n    print(solution.mergeSort(intervals))",
    "class Solution(object):\n    def mergeSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) < 2:\n            return\n        mid = len(nums) // 2\n        self.mergeSort(nums[:mid])\n        self.mergeSort(nums[mid:])\n        self.merge(nums, 0, mid, len(nums))\n\n    def merge(self, nums, left, right, index):\n        \"\"\"\n        :type nums: List[int]\n        :type left: int\n        :type right: int\n        :type index: int\n        :rtype: void\n        \"\"\"\n        if left >= right:\n            return\n        mid = left + (right - left) // 2\n        i, j = left, mid\n        k = index\n        while i < mid and j < right:\n            if nums[i] <= nums[j]:\n                nums[k] = nums[i]\n                i += 1\n            else:\n                nums[k] = nums[j]\n                j += 1\n            k += 1\n        while i < mid:\n            nums[k] = nums[i]\n            i += 1\n            k += 1\n        while j < right:\n            nums[k] = nums[j]\n            j += 1\n            k += 1",
    "from collections import deque\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    merge the given arrays.\n\n    :type left: list\n    :type right: list\n    :rtype: list\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left[0])\n            left.pop(0)\n        else:\n            result.append(right[0])\n            right.pop(0)\n    result.extend(left)\n    result.extend(right)\n    return result\n\nif __name__ == '__main__':\n    arr = [10, 4, 7, 2, 5, 9, 3, 1, 6, 8]\n    print(merge_sort(arr))",
    "def merge_sort(arr, left, right):\n    if left < right:\n        mid = left + (right - left) / 2\n        merge_sort(arr, left, mid)\n        merge_sort(arr, mid + 1, right)\n        merge(arr, left, mid, right)\n\ndef merge(arr, left, mid, right):\n    out = []\n    i = left\n    j = mid + 1\n    k = left\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            out.append(arr[i])\n            i += 1\n        else:\n            out.append(arr[j])\n            j += 1\n    while i <= mid:\n        out.append(arr[i])\n        i += 1\n    while j <= right:\n        out.append(arr[j])\n        j += 1\n    for i in range(left, right):\n        arr[i] = out[i]\n\ndef test():\n    a = [1, 5, 7, 2, 3, 6, 4, 8]\n    merge_sort(a, 0, len(a) - 1)\n    print a\n\nif __name__ == '__main__':\n    test()",
    "# Merge sort\n# merge sort is a simple sorting algorithm\n# it can be implemented in linear time.\n# It sorts the array in O(n log n) time.\n# It can be implemented in linear time.\n# https://en.wikipedia.org/wiki/Merge_sort\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    middle = len(arr) / 2\n    left = merge_sort(arr[:middle])\n    right = merge_sort(arr[middle:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    print(merge_sort(arr))",
    "from merge_sort import merge_sort\n\ndef sort(arr):\n    \"\"\"\n    Sorts the given array using merge sort.\n    :param arr: A list of integers.\n    :return: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = sort(arr[:mid])\n        right = sort(arr[mid:])\n        return merge_sort(left, right)\n\nif __name__ == '__main__':\n    arr = [4, 3, 5, 1, 2, 6, 8]\n    print(sort(arr))",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        if len(intervals) == 1:\n            return intervals\n        \n        mid = len(intervals) / 2\n        left, right = intervals[:mid], intervals[mid:]\n        \n        left = self.merge(left)\n        right = self.merge(right)\n        \n        return self.merge_sort(left + right)\n\n    def merge_sort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        if len(intervals) == 1:\n            return intervals\n        \n        mid = len(intervals) / 2\n        left, right = intervals[:mid], intervals[mid:]\n        \n        left = self.merge_sort(left)\n        right = self.merge_sort(right)\n        \n        return self.merge_sort(left + right)\n\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        if len(intervals) == 1:\n            return intervals\n        \n        left, right = intervals[:len(intervals) / 2], intervals[len(intervals) / 2:]\n        \n        left = self.merge(left)\n        right = self.merge(right)\n        \n        return self.merge_sort(left + right)\n\n    def merge_sort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        if len(inter",
    "import time\n\n\ndef merge_sort(array):\n    if len(array) <= 1:\n        return array\n    else:\n        mid = len(array) // 2\n        left = merge_sort(array[:mid])\n        right = merge_sort(array[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n\n\nif __name__ == \"__main__\":\n    array = [2, 5, 1, 3, 4]\n    print(merge_sort(array))\n    print(\"time:\", time.time() - start)",
    "def mergeSort(arr):\n    \"\"\"\n    Merge sort is a simple sorting algorithm that divides the input array\n    into two parts: an array of lower values and an array of higher values.\n    It then calls itself recursively on each part.\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = mergeSort(arr[:mid])\n        right = mergeSort(arr[mid:])\n        return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge the two sorted arrays into one sorted array.\n    \"\"\"\n    result = []\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            k += 1\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n    return result",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        mid = head\n        left = head\n        right = head.next\n        while left and right:\n            if left.val < right.val:\n                mid = mid.next\n                left = left.next\n            else:\n                right = right.next\n        \n        if left:\n            self.mergeSort(head)\n        elif right:\n            self.mergeSort(right)\n        else:\n            return head\n        \n        return self.merge(left, mid, right)\n\n    def merge(self, left, mid, right):\n        head = ListNode(0)\n        cur = head\n        while left and right:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        if left:\n            cur.next = left\n        elif right:\n            cur.next = right\n        \n        return head.next",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def mergeSort(self, head):\n        if not head or not head.next:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        return self.mergeSort(slow) + fast",
    "def merge_sort(arr):\n    if len(arr) < 2:\n        return arr\n    middle = len(arr) / 2\n    left = merge_sort(arr[:middle])\n    right = merge_sort(arr[middle:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef test_merge_sort():\n    arr = [10, 20, 30, 40, 50]\n    assert merge_sort(arr) == [10, 20, 30, 40, 50]\n\nif __name__ == \"__main__\":\n    test_merge_sort()",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        result = []\n        start = intervals[0].start\n        end = intervals[0].end\n        for i in xrange(1, len(intervals)):\n            if intervals[i].start < start:\n                result.append(Interval(start, end))\n                start = intervals[i].start\n            end = max(end, intervals[i].end)\n        result.append(Interval(start, end))\n        return result\n\n    def mergeSort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        result = self.merge(intervals)\n        return self.mergeSort(result)",
    "import collections\n\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        \n        def merge(left, right):\n            result = []\n            while left and right:\n                if left.start < right.start:\n                    result.append(left)\n                    left = left.next\n                elif left.start > right.start:\n                    result.append(right)\n                    right = right.next\n                else:\n                    result.append(Interval(min(left.start, right.start), max(left.end, right.end)))\n                    left = left.next\n                    right = right.next\n            if left:\n                result.append(left)\n            if right:\n                result.append(right)\n            return result\n\n        result = []\n        for interval in intervals:\n            if not result or interval.end <= result[-1].end:\n                result.append(interval)\n            else:\n                result = merge(result, merge(interval, result[-1]))\n        return result",
    "def mergeSort(arr):\n    if len(arr) < 2:\n        return arr\n    \n    mid = len(arr) / 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    merged = []\n    \n    while left and right:\n        if left[0] <= right[0]:\n            merged.append(left.pop(0))\n        else:\n            merged.append(right.pop(0))\n    \n    merged.extend(left)\n    merged.extend(right)\n    \n    return merged\n\ndef main():\n    print mergeSort([1, 3, 4, 2, 5])\n\nif __name__ == '__main__':\n    main()",
    "def mergeSort(arr):\n    \"\"\"\n    Input: An unsorted array.\n    Output: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    mergeSort(left)\n    mergeSort(right)\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge the two sorted subarrays left and right.\n\n    Input: An unsorted array and two sorted subarrays.\n    Output: The merged array.\n    \"\"\"\n    merged = []\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n    return merged\n\ndef mergeSort(arr):\n    \"\"\"\n    Input: An unsorted array.\n    Output: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    mergeSort(left)\n    mergeSort(right)\n    return merge(left, right)\n\nif __name__ == '__main__':\n    arr = [2, 6, 5, 8, 1, 3]\n    print mergeSort(arr)",
    "def merge_sort(arr):\n    if len(arr) < 2:\n        return arr\n    else:\n        mid = len(arr) / 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 2, 5, 4, 7]\n    print merge_sort(arr)",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def merge(self, A, B):\n        \"\"\"\n        :type A: List[Interval]\n        :type B: List[Interval]\n        :rtype: None\n        \"\"\"\n        if len(A) == 0 and len(B) == 0:\n            return\n        elif len(A) == 0:\n            B.sort(key=lambda x: x.start)\n            return\n        elif len(B) == 0:\n            A.sort(key=lambda x: x.start)\n            return\n        else:\n            p = A[0].start\n            r = A[0].end\n            l = B[0].start\n            k = B[0].end\n            while p <= r and l <= k:\n                if p <= l:\n                    A.insert(0, Interval(p, l))\n                    p = l + 1\n                else:\n                    B.insert(0, Interval(l, k))\n                    l = k + 1\n                k = max(k, r)\n                r = p\n        self.merge(A[1:], B[1:])\n        return\n\n# Note:\n# 1. Merge sort is easy to understand and easy to understand.\n# 2. Merge sort is easy to understand and easy to understand.\n# 3. Merge sort is easy to understand and easy to understand.\n# 4. Merge sort is easy to understand and easy to understand.\n# 5. Merge sort is easy to understand and easy to understand.\n# 6. Merge sort is easy to understand and easy to understand.\n# 7. Merge sort is easy to understand and easy to understand.\n# 8. Merge sort is easy to understand and easy to understand.\n# 9. Merge sort is easy to understand and easy to understand.\n# 10. Merge sort is easy to understand and easy to understand.\n# 11. Merge sort is easy to understand and easy to understand.\n# 12. Merge sort is easy to understand and easy to understand.\n# 13. Merge sort is easy to understand and easy to understand",
    "def mergeSort(a):\n    \"\"\"\n    Sort the given array by using merge sort.\n    \n    :type a: List[int]\n    :rtype: void\n    \"\"\"\n    if len(a) <= 1:\n        return\n    mid = len(a) / 2\n    \n    left = mergeSort(a[:mid])\n    right = mergeSort(a[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge the two sorted arrays into a sorted array.\n    \n    :type left: List[int]\n    :type right: List[int]\n    :rtype: void\n    \"\"\"\n    result = []\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            k += 1\n    \n    result += left[i:]\n    result += right[j:]\n    \n    return result",
    "def merge_sort(A):\n    if len(A) <= 1:\n        return A\n    else:\n        mid = len(A)//2\n        left = merge_sort(A[:mid])\n        right = merge_sort(A[mid:])\n        return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            k += 1\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n        k += 1\n    return result\n\nif __name__ == \"__main__\":\n    A = [4, 5, 6, 7, 8, 9]\n    print(merge_sort(A))",
    "class Solution(object):\n    def mergeSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: None Do not return anything, modify arr in-place instead.\n        \"\"\"\n        if len(arr) <= 1:\n            return\n        mid = len(arr) / 2\n        left = self.mergeSort(arr[:mid])\n        right = self.mergeSort(arr[mid:])\n        return self.merge(arr, left, right)\n\n    def merge(self, arr, left, right):\n        i, j, k = 0, 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1",
    "def merge_sort(arr):\n    \"\"\"\n    Sort the given array by using merge sort.\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    mid = len(arr) / 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right, arr)\n\ndef merge(left, right, arr):\n    \"\"\"\n    Merge the given two sorted lists using merge sort.\n    :type left: List[int]\n    :type right: List[int]\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    if len(left) == 0 or len(right) == 0:\n        return\n    if len(left) == 1:\n        arr = merge(left[0], right, arr)\n        return\n    if len(right) == 1:\n        arr = merge(left, right[0], arr)\n        return\n    # sort the left and right lists\n    left.sort()\n    right.sort()\n    # create a new list that will be the merged list\n    merged = []\n    # add the first elements of the left and right lists to the new list\n    merged.extend(left)\n    merged.extend(right)\n    # sort the new list\n    merged.sort()\n    # add the merged list to the array\n    arr = merged\n    return\n\ndef merge_sort_recursive(arr):\n    \"\"\"\n    Sort the given array by using recursive merge sort.\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    if len(arr) <= 1:\n        return\n    # create a new list that will be the merged list\n    merged = []\n    # add the first elements of the left and right lists to the new list\n    merged.extend(arr)\n    # sort the new list\n    merged.sort()\n    # add the merged list to the array\n    arr = merged\n    # recursively call the function\n    merge_sort_recursive(arr[:len(arr",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        nums1, m, nums2 = nums1[:m], m, nums2[:n]\n        nums1, nums2 = nums1[m:], nums2[n:]\n        for i in range(m):\n            nums1[i] = nums1[i] + nums2[i]\n        res = []\n        for i in range(m):\n            res.append(nums1[i])\n        return res\n\n    def merge_sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) < 2:\n            return nums\n        mid = len(nums) // 2\n        left = self.merge_sort(nums[:mid])\n        right = self.merge_sort(nums[mid:])\n        return self.merge(left, mid, right, len(nums))\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().merge(nums, len(nums), []))",
    "def merge(arr):\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) / 2\n    left = merge(arr[:mid])\n    right = merge(arr[mid:])\n    return merge_sort(left, right)\n\ndef merge_sort(left, right):\n    if left == None or right == None:\n        return left, right\n    if left.length() <= right.length():\n        return merge_sort(left, right)\n    else:\n        return merge_sort(left, merge_sort(left.slice(0, left.length()/2), right.slice(0, right.length()/2)))\n\ndef main():\n    arr = [2, 3, 1, 5, 4, 6]\n    print(merge(arr))\n\nif __name__ == \"__main__\":\n    main()",
    "import random\nimport copy\n\ndef merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = merge_sort(array[:mid])\n        right = merge_sort(array[mid:])\n        return merge(left, right)\n    else:\n        return array\n\ndef merge(left, right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result\n\ndef main():\n    array = random.sample(range(1, 100), 10)\n    print(array)\n    print('Merge sort:')\n    print(merge_sort(array))\n\nif __name__ == '__main__':\n    main()",
    "def mergeSort(a):\n    if len(a) < 2:\n        return a\n\n    mid = len(a) / 2\n    left = mergeSort(a[:mid])\n    right = mergeSort(a[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n\nif __name__ == \"__main__\":\n    a = [3, 1, 2, 4, 5, 6]\n    print(mergeSort(a))",
    "from collections import defaultdict\nfrom math import ceil\nfrom random import sample\n\n\ndef merge_sort(array):\n    \"\"\"\n    Sort the given array using merge sort.\n\n    :type array: List[int]\n    :rtype: None\n    \"\"\"\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n    left_array = merge_sort(array[:mid])\n    right_array = merge_sort(array[mid:])\n\n    return merge(left_array, right_array)\n\n\ndef merge(left_array, right_array):\n    \"\"\"\n    Merge the two sorted arrays.\n\n    :type left_array: List[int]\n    :type right_array: List[int]\n    :rtype: None\n    \"\"\"\n    merged_array = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left_array) and right_index < len(right_array):\n        if left_array[left_index] <= right_array[right_index]:\n            merged_array.append(left_array[left_index])\n            left_index += 1\n        else:\n            merged_array.append(right_array[right_index])\n            right_index += 1\n\n    while left_index < len(left_array):\n        merged_array.append(left_array[left_index])\n        left_index += 1\n\n    while right_index < len(right_array):\n        merged_array.append(right_array[right_index])\n        right_index += 1\n\n    return merged_array\n\n\ndef merge_sort_recursive(array):\n    \"\"\"\n    Sort the given array using recursive merge sort.\n\n    :type array: List[int]\n    :rtype: None\n    \"\"\"\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n    left_array = merge_sort_recursive(array[:mid])\n    right_array = merge_sort_recursive(array[mid:])\n\n    return merge_recursive(left_array, right_array)\n\n\ndef merge_recursive",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        \n        left = self.mergeSort(head.next)\n        right = self.mergeSort(head.next.next)\n        \n        if left is None:\n            return right\n        if right is None:\n            return left\n        \n        return self.merge(head, left, right)\n    \n    def merge(self, head, left, right):\n        if left is None:\n            return right\n        if right is None:\n            return left\n        \n        if left.val > right.val:\n            head.next = self.merge(head, left, right)\n        else:\n            head.next = self.merge(head, right, left)\n        \n        return head",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n    while len(left)!= 0 and len(right)!= 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    if len(left)!= 0:\n        result.extend(left)\n    if len(right)!= 0:\n        result.extend(right)\n    return result\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 3, 7, 9, 2, 1]\n    print(merge_sort(arr))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        head1 = self.mergeSort(head.next)\n        head2 = self.mergeSort(head)\n        return self.merge(head1, head2)\n\n    def merge(self, head1, head2):\n        if not head1:\n            return head2\n        if not head2:\n            return head1\n        if head1.val <= head2.val:\n            head1.next = self.merge(head1.next, head2)\n            return head1\n        else:\n            head2.next = self.merge(head2.next, head1)\n            return head2",
    "\"\"\"\nImplementation of merge sort.\n\"\"\"\ndef merge(arr, low, mid, high):\n    if low < mid:\n        if high < mid:\n            # Recursively call merge to sort left and right sub-arrays\n            merge(arr, low, low+mid, high)\n            merge(arr, low+mid, low, high+mid)\n        else:\n            # Recursively call merge to sort left sub-array\n            merge(arr, low, low+mid, high)\n        \n    # Recursively call merge to sort right sub-array\n    merge(arr, low+mid, low, high+mid)\n    \n    # Merge the left and right sub-arrays\n    i = low\n    j = low + mid\n    k = low\n    l = low + mid\n    while i < low+mid and j < high+mid:\n        if arr[i] <= arr[j]:\n            arr[k] = arr[i]\n            i += 1\n        else:\n            arr[k] = arr[j]\n            j += 1\n        k += 1\n        \n    # Copy the remaining elements of left sub-array\n    while i < low+mid:\n        arr[k] = arr[i]\n        i += 1\n        k += 1\n    \n    # Copy the remaining elements of right sub-array\n    while j < high+mid:\n        arr[k] = arr[j]\n        j += 1\n        k += 1\n        \ndef merge_sort(arr, low, high):\n    if low < high:\n        # Recursively call merge_sort to sort left and right sub-arrays\n        merge_sort(arr, low, low+high)\n        merge_sort(arr, low+high, high)\n        \n        # Merge the left and right sub-arrays\n        i = low\n        j = low + high\n        k = low\n        l = low + high\n        while i < low+high:\n            if j < high:\n                if arr[i] <= arr[j]:\n                    arr[k] = arr[i]\n                    i += 1\n                else:\n                    arr[k] = arr[j",
    "import sys\nsys.setrecursionlimit(1000000)\n\n\ndef merge(arr, low, mid, high):\n    \"\"\"\n    Merge sort algorithm.\n    \"\"\"\n    if low < mid:\n        # Recurse\n        if high < mid:\n            # Recurse\n            # Recurse\n            if low < high:\n                # Recurse\n                if arr[low] > arr[mid]:\n                    # Recurse\n                    # Recurse\n                    # Recurse\n                    arr[low], arr[mid] = arr[mid], arr[low]\n                # Recurse\n                # Recurse\n                # Recurse\n                arr[mid + 1:high + 1] = merge(arr[low:mid + 1], low, mid, high)\n            # Recurse\n            arr[mid + 1:high + 1] = merge(arr[mid:high + 1], low, mid, high)\n        else:\n            # Recurse\n            # Recurse\n            arr[low:high + 1] = merge(arr[low:high + 1], low, mid, high)\n    # Recurse\n    # Recurse\n    arr[:high + 1] = merge(arr[:high + 1], low, low, high)\n\n\ndef merge_sort(arr):\n    \"\"\"\n    Merge sort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        return merge(left, 0, mid, len(right))\n\n\nif __name__ == '__main__':\n    arr = [4, 1, 6, 1, 9, 1, 3, 1, 4, 5, 1, 7, 8, 1, 2, 3, 1]\n    print(merge_sort(arr))",
    "def mergeSort(arr):\n    \"\"\"\n    Merge sort\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Merge sort\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left)\n    result.extend(right)\n    return result",
    "from common.array_helper import get_array_by_size\n\n\ndef merge_sort(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: void\n    \"\"\"\n    if len(array) < 2:\n        return\n    left_array = get_array_by_size(len(array) // 2)\n    right_array = get_array_by_size(len(array) - len(left_array))\n    left_array.extend(array[:len(left_array)])\n    right_array.extend(array[len(left_array):])\n    merge_sort(left_array)\n    merge_sort(right_array)\n    merge_sort_helper(left_array, right_array)\n\n\ndef merge_sort_helper(left_array, right_array):\n    if len(left_array) == 0 or len(right_array) == 0:\n        return\n    if left_array[0] > right_array[0]:\n        left_array[0], right_array[0] = right_array[0], left_array[0]\n        merge_sort_helper(left_array[1:], right_array)\n    else:\n        merge_sort_helper(left_array, right_array[1:])\n        merge_sort_helper(left_array[:1], right_array)",
    "def merge(arr, left, mid, right):\n    \"\"\"\n    Merge sort the given array using the given left and right indices.\n    \"\"\"\n    \n    if left < mid:\n        merge(arr, left, mid, right)\n    elif left > mid:\n        merge(arr, left, mid - 1, right)\n    elif right > mid:\n        merge(arr, left, mid, right - 1)\n    else:\n        return\n\n    # Merge the two halves of the array.\n    i, j = left, mid\n    k = left\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            arr[k] = arr[i]\n            i += 1\n        else:\n            arr[k] = arr[j]\n            j += 1\n        k += 1\n    \n    # Copy the remaining elements of the first half.\n    while i <= mid:\n        arr[k] = arr[i]\n        i += 1\n        k += 1\n    \n    # Copy the remaining elements of the second half.\n    while j <= right:\n        arr[k] = arr[j]\n        j += 1\n        k += 1\n\n\ndef sort(arr):\n    \"\"\"\n    Sort the given array using merge sort.\n    \"\"\"\n    \n    if len(arr) < 2:\n        return\n\n    # Split the array into two halves.\n    left = 0\n    right = len(arr) - 1\n\n    # Merge the two halves of the array.\n    merge(arr, left, right)\n\n    # Sort the two halves of the array.\n    sort(arr[:left])\n    sort(arr[right:])\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    sort(arr)\n    print arr",
    "import random\n\ndef merge_sort(arr):\n    \"\"\"\n    >>> merge_sort([])\n    []\n    >>> merge_sort([1])\n    [1]\n    >>> merge_sort([1, 2])\n    [1, 2]\n    >>> merge_sort([1, 2, 3])\n    [1, 2, 3]\n    >>> merge_sort([3, 1, 2])\n    [1, 2, 3]\n    >>> merge_sort([3, 1, 2, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> merge_sort([3, 1, 2, 4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    >>> merge_sort([3, 1, 2, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge_sort([3, 1, 2, 4, 5, 6, 7, 8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    \"\"\"\n\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    >>> merge([])\n    []\n    >>> merge([1])\n    [1]\n    >>> merge([1, 2])\n    [1, 2]\n    >>> merge([1, 2, 3])\n    [1, 2, 3]\n    >>> merge([3, 1, 2])\n    [1, 2, 3]\n    >>> merge([3, 1, 2, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> merge([3, 1, 2, 4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    >>> merge([3, 1, 2, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge([3, 1, 2, 4, 5, 6, 7,"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}