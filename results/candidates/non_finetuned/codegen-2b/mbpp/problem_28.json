{
  "problem": {
    "task_id": "MBPP/39",
    "prompt": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
    "canonical_solution": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")",
    "test_list": [
      "assert rearange_string(\"aab\")==('aba')",
      "assert rearange_string(\"aabb\")==('abab')",
      "assert rearange_string(\"abccdd\")==('cdabcd')"
    ],
    "challenge_test_list": [],
    "problem_id": 28
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def canRearrangeLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        dic = {}\n        for i in range(len(s)):\n            dic[s[i]] = i\n        for i in range(len(s)):\n            if s[i] in dic and dic[s[i]]!= i:\n                return False\n        return True",
    "# https://www.hackerrank.com/challenges/string-rearrange/problem\n\ndef rearrange(s):\n    # write your code here\n    letters = list(s)\n    for i in range(len(letters)):\n        for j in range(i+1, len(letters)):\n            if letters[i] == letters[j] and i!= j:\n                letters[i], letters[j] = letters[j], letters[i]\n                return \"\".join(letters)\n    return \"No such string\"\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(rearrange(s))",
    "class Solution(object):\n    def isPossible(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        if len(s) == 1:\n            return True\n        for i in xrange(len(s) - 1):\n            if s[i] == s[i+1]:\n                return False\n        return True",
    "class Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        return self.canPermute(s[1:], s[0], s[-1])\n\n    def canPermute(self, s, a, b):\n        if len(s) == 0:\n            return True\n        if a == s[0] and b == s[-1]:\n            return self.canPermute(s[1:-1], s[0], s[-1])\n        return self.canPermute(s[1:], a, b) and self.canPermute(s[:-1], a, b)",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s1)!= len(s3) or len(s2)!= len(s3):\n            return False\n        if s1 == s2:\n            return True\n        if s1 == s3:\n            return True\n        if s2 == s3:\n            return True\n        if len(s1) == 0:\n            return False\n        if len(s2) == 0:\n            return False\n        if len(s3) == 0:\n            return False\n        if s1[0] == s2[0] and s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3[1:])\n        if s1[-1] == s2[-1] and s1[-1] == s3[-1]:\n            return self.isInterleave(s1[:-1], s2[:-1], s3[:-1])\n        if s1[-1] == s3[-1] and s1[-1] == s2[-1]:\n            return self.isInterleave(s1[:-1], s2[:-1], s3[:-1])\n        if s1[0] == s3[0] and s1[0] == s2[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3[1:])\n        if s2[0] == s3[0] and s2[0] == s1[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3[1:])\n        if s1[-1] == s3[-1] and s1[-1] == s2[-1]:\n            return self.isInterleave(s1[:-1], s2[:-1], s",
    "def can_rearrange(string):\n    \"\"\"\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    from collections import Counter\n    mapping = Counter(string)\n    for i, j in mapping.iteritems():\n        if i!= j:\n            return False\n    return True",
    "def can_rearrange(str):\n    if len(str) < 2:\n        return False\n\n    if str[0]!= str[-1]:\n        return False\n\n    for i in range(1, len(str) - 1):\n        if str[i] == str[i - 1] and str[i] == str[i + 1]:\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    print can_rearrange(\"aabb\")\n    print can_rearrange(\"aaabb\")\n    print can_rearrange(\"aaaabb\")\n    print can_rearrange(\"aaaabbb\")\n    print can_rearrange(\"aaabbb\")\n    print can_rearrange(\"aaabbbb\")\n    print can_rearrange(\"aaabbbbb\")",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.canPermuteString_recursive(s, 0, len(s) - 1)\n\n    def canPermuteString_recursive(self, s, left, right):\n        if left >= right:\n            return True\n\n        if left == right - 1:\n            if s[left]!= s[right]:\n                return False\n            return True\n\n        # if they are not adjacent\n        if s[left]!= s[right - 1]:\n            return False\n\n        return self.canPermuteString_recursive(s, left + 1, right - 1) or self.canPermuteString_recursive(s, left, right - 1)\n\n\nif __name__ == '__main__':\n    s = \"abc\"\n    print Solution().canPermuteString(s)",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n\n        # Use two pointers to check if there are two adjacent characters\n        for i in range(0, len(s)):\n            if i + 1 < len(s) and s[i] == s[i + 1]:\n                return False\n            if i + 2 < len(s) and s[i] == s[i + 2]:\n                return False\n\n        # Use two pointers to check if there are two adjacent characters\n        for i in range(0, len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n            if s[i] == s[i + 2]:\n                return False\n\n        return True\n\nif __name__ == \"__main__\":\n    print Solution().canRearrange(\"aabccc\")",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        for i in xrange(len(s)):\n            if s[i] == s[i-1]:\n                return False\n        return True\n\n    def canPermuteString2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        for i in xrange(len(s)):\n            if s[i] == s[i-1]:\n                return False\n            if s[i-1] == s[i+1]:\n                return False\n        return True\n\n    def canPermuteString3(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        for i in xrange(len(s)):\n            if s[i] == s[i-1]:\n                return False\n            if s[i-1] == s[i+1]:\n                return False\n            if s[i-1] == s[i-2]:\n                return False\n        return True\n\n    def canPermuteString4(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        for i in xrange(len(s)):\n            if s[i] == s[i-1]:\n                return False\n            if s[i-1] == s[i+1]:\n                return False\n            if s[i-2] == s[i-1]:\n                return False\n            if s[i-2] == s[i+1]:\n                return False\n            if s[i-1] == s[i-3]:\n                return False\n            if s[i-1] == s[i-2]:\n                return False\n            if s[i-2] == s[i-3]:\n                return False\n        return True",
    "#!/bin/python\n\nimport re\n\ndef is_possible(s):\n    return len(s) > 2 and len(s) % 2 == 0 and len(s) >= 3 and all(ord(c) <= ord('z') and ord(c) >= ord('a') for c in s) and s[0]!= s[-1]\n\ndef main():\n    s = 'azceg'\n    print(is_possible(s))\n    s = 'abcdef'\n    print(is_possible(s))\n    s = 'abcdeg'\n    print(is_possible(s))\n\nif __name__ == '__main__':\n    main()",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        Rearrange by two char\n        :param s: str\n        :return: bool\n        \"\"\"\n        if len(s) <= 1:\n            return True\n\n        s_set = set(s)\n        if len(s_set) == 1:\n            return True\n\n        s_set = sorted(s_set)\n\n        # print s_set\n\n        for i in range(len(s_set)):\n            if i > 0 and s_set[i - 1] == s_set[i]:\n                return False\n\n        return True\n\n\nif __name__ == \"__main__\":\n    s = \"cba\"\n    print Solution().canRearrange(s)",
    "def is_possible(str):\n    for i in range(len(str) - 1):\n        if str[i] == str[i+1]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    str = 'abc'\n    print(is_possible(str))",
    "class Solution:\n    # @param s, a string\n    # @return a boolean\n    def canPermute(self, s):\n        if len(s) < 2:\n            return True\n\n        if s[0] == s[-1]:\n            return False\n\n        return self.canPermute(s[1:]) and self.canPermute(s[:-1])\n\n\nif __name__ == '__main__':\n    print Solution().canPermute('b')",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        else:\n            count = {}\n            for c in s:\n                if c not in count:\n                    count[c] = 1\n                else:\n                    count[c] += 1\n            for c in s:\n                if c in count and count[c] == 2:\n                    return False\n            return True",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :param s: str\n        :return: bool\n        \"\"\"\n        if len(s) == 1:\n            return False\n        # build a dictionary for the first char of each letter\n        d = {}\n        for c in s:\n            d[c] = d.get(c, 0) + 1\n        # build a dictionary for the second char of each letter\n        d2 = {}\n        for c in s:\n            d2[c] = d2.get(c, 0) + 1\n\n        # check if adjacent chars are different\n        for i in range(len(s)-1):\n            if d[s[i]] == d2[s[i+1]]:\n                return False\n        return True\n\n\nif __name__ == \"__main__\":\n    print Solution().canPermuteString(\"a\")",
    "# https://www.hackerrank.com/challenges/two-characters\n\nimport sys\nimport math\n\ndef can_rearrange(s):\n    letters = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0, 'i': 0, 'j': 0, 'k': 0, 'l': 0,'m': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0,'s': 0, 't': 0, 'u': 0, 'v': 0, 'w': 0, 'x': 0, 'y': 0, 'z': 0}\n    \n    for i in range(len(s)):\n        letters[s[i]] += 1\n    \n    for i in range(len(s)):\n        if letters[s[i]] == 1:\n            letters[s[i]] = 0\n    \n    count = 0\n    for i in range(len(s)):\n        if letters[s[i]] == 1:\n            count += 1\n    \n    return count % 2 == 0\n\nif __name__ == '__main__':\n    s = input().strip()\n    print(can_rearrange(s))",
    "#\n# Given a string, you need to write a function to check if the string can be rearranged so that two characters that are adjacent to each other are different.\n#\n# Example 1:\n# Input: \"aab\"\n# Output: True\n# Explanation: It's possible to rearrange it to \"bab\".\n# Example 2:\n# Input: \"aba\"\n# Output: False\n# Explanation: It's not possible to rearrange it to \"bab\"\n# Example 3:\n# Input: \"abb\"\n# Output: True\n# Explanation: It's possible to rearrange it to \"aab\" or \"bba\".\n#\n# Note:\n# The input string will have length in range [1, 1000].\n# The string contains only lowercase letters.\n#\n\nclass Solution(object):\n    def canIarrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n        s_len = len(s)\n        if s_len == 1:\n            return True\n        if s_len == 2:\n            return False\n        left_is_different = False\n        for i in range(1, s_len - 1):\n            if s[i - 1] == s[i]:\n                left_is_different = True\n                break\n        if not left_is_different:\n            return False\n        right_is_different = False\n        for j in range(s_len - 2, -1, -1):\n            if s[j + 1] == s[j]:\n                right_is_different = True\n                break\n        if not right_is_different:\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    s = \"aab\"\n    print solution.canIarrange(s)\n    s = \"aba\"\n    print solution.canIarrange(s)\n    s = \"abb\"\n    print solution.canIarrange(s)\n    s = \"aab\"\n    print solution.canIarrange(s)\n    s = \"abb\"\n    print solution.canI",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s1)!= len(s3) or len(s2)!= len(s3):\n            return False\n        # print s1, s2, s3\n        dic = {}\n        for i in range(len(s1)):\n            if s1[i] not in dic:\n                dic[s1[i]] = {}\n            if s2[i] not in dic[s1[i]]:\n                dic[s1[i]][s2[i]] = {}\n            if s3[i] not in dic[s1[i]][s2[i]]:\n                dic[s1[i]][s2[i]][s3[i]] = {}\n            if dic[s1[i]][s2[i]][s3[i]][s1[i+1]]:\n                return True\n            if dic[s1[i]][s2[i]][s3[i]][s2[i+1]]:\n                return True\n        return False",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param s, a string\n    # @return a boolean\n    def isSameString(self, s):\n        if not s: return True\n        if len(s) == 1: return True\n        for i in range(len(s) - 1):\n            if s[i] == s[i+1]:\n                return False\n        return True\n    \n    def isSameString1(self, s):\n        if not s: return True\n        if len(s) == 1: return True\n        if s[0] == s[-1]:\n            return False\n        for i in range(len(s) - 1):\n            if s[i] == s[i+1]:\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isSameString1(\"aab\")\n    print s.isSameString1(\"aa\")\n    print s.isSameString1(\"aa\")\n    print s.isSameString1(\"ab\")\n    print s.isSameString1(\"abb\")\n    print s.isSameString1(\"aabbc\")\n    print s.isSameString1(\"aabbccd\")\n    print s.isSameString1(\"abccd\")\n    print s.isSameString1(\"abbccd\")\n    print s.isSameString1(\"abbccdd\")\n    print s.isSameString1(\"abbccdde\")\n    print s.isSameString1(\"abbccddee\")",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n\n        # sort the string\n        s.sort()\n\n        # check if the string is sorted\n        for i in xrange(len(s)):\n            if s[i-1] > s[i]:\n                return False\n\n        return True",
    "# https://leetcode.com/problems/rearrange-string-to-make-it-palindrome/discuss/441324/C++-O(n)\n# https://leetcode.com/problems/rearrange-string-to-make-it-palindrome/discuss/441325/C++-O(n)\nclass Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # This is a brute-force approach, which is inefficient.\n        # We could do something more efficient.\n        for i in range(len(s)):\n            for j in range(len(s) - i - 1):\n                if s[j:j + i] == s[i + j:i + j + 1]:\n                    return True\n        return False",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        # count adjacent chars\n        count = collections.Counter(s)\n        n = len(s)\n        adj_chars = set()\n\n        for c, count in count.items():\n            for i in range(n):\n                if count[s[i]] == 1:\n                    adj_chars.add(s[i])\n                    break\n                else:\n                    count[s[i]] -= 1\n        return len(adj_chars) == 2\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.canPermute(\"aab\")\n    print s.canPermute(\"bbbb\")\n    print s.canPermute(\"\")",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# \u4ee5\u4e0b\u662f\u6700\u521d\u7684\u65b9\u6cd5\n# def can_rearrange(s):\n#     # \u5982\u679cs\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u6bcf\u4e2a\u5b57\u7b26\u90fd\u53ef\u4ee5\u88ab\u62fc\u63a5\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\n#     if len(s) > 1:\n#         for i in xrange(len(s)):\n#             for j in xrange(i + 1, len(s)):\n#                 if s[i] == s[j]:\n#                     return False\n#     else:\n#         return True\n\n# \u4ee5\u4e0b\u662f\u5206\u6790\u6cd5\n# def can_rearrange(s):\n#     # \u5982\u679cs\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u6bcf\u4e2a\u5b57\u7b26\u90fd\u53ef\u4ee5\u88ab\u62fc\u63a5\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\n#     if len(s) > 1:\n#         for i in xrange(len(s)):\n#             for j in xrange(i + 1, len(s)):\n#                 if s[i] == s[j]:\n#                     return False\n#     else:\n#         return True\n\n# \u4ee5\u4e0b\u662f\u7b80\u5355\u7684\u65b9\u6cd5\n# def can_rearrange(s):\n#     # \u5982\u679cs\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u6bcf\u4e2a\u5b57\u7b26\u90fd\u53ef\u4ee5\u88ab\u62fc\u63a5\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\n#     if len(s) > 1:\n#         for i in xrange(len(s)):\n#             for j in xrange(i + 1, len(s)):\n#                 if s[i] == s[j]:\n#                     return False\n#     else:\n#         return True",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        stack = []\n        for c in s:\n            if c not in stack:\n                stack.append(c)\n            else:\n                if c == stack[-1]:\n                    stack.pop()\n                else:\n                    stack.pop()\n                    stack.append(c)\n        return len(stack) == 0\n\nif __name__ == '__main__':\n    s = Solution()\n    s.canPermuteString(\"aabb\")\n    s.canPermuteString(\"abcc\")\n    s.canPermuteString(\"abcdd\")",
    "import string\n\ndef can_rearrange(string):\n    \"\"\"\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    if len(string) == 1:\n        return True\n    if string[0] not in string[1:]:\n        return False\n    if string[-1] not in string[:-2]:\n        return False\n    return True\n\nprint can_rearrange(\"aab\")\nprint can_rearrange(\"aba\")\nprint can_rearrange(\"aaab\")\nprint can_rearrange(\"aabb\")\nprint can_rearrange(\"aa\")\nprint can_rearrange(\"aaa\")\nprint can_rearrange(\"a\")\nprint can_rearrange(\"ab\")\nprint can_rearrange(\"abc\")\nprint can_rearrange(\"aab\")\nprint can_rearrange(\"aba\")\nprint can_rearrange(\"aaab\")\nprint can_rearrange(\"aabb\")\nprint can_rearrange(\"aa\")\nprint can_rearrange(\"aaa\")\nprint can_rearrange(\"a\")\nprint can_rearrange(\"ab\")\nprint can_rearrange(\"abc\")",
    "# Write your code below.\ndef check_if_possible(string):\n    \"\"\"\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    if not string:\n        return False\n\n    for i in range(len(string)):\n        for j in range(i + 1, len(string)):\n            if string[i] == string[j]:\n                return False\n    return True\n\n\n\n# Your code below:\n\n#string = \"aabbcc\"\n#print check_if_possible(string)",
    "class Solution(object):\n    def isRearrangeable(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if len(s) == 1:\n            return s[0]!= s[0]\n        for i in range(len(s)):\n            if i > 0 and s[i] == s[i-1]:\n                return False\n            if i < len(s)-1 and s[i] == s[i+1]:\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    print Solution().isRearrangeable(\"ab\")",
    "# https://leetcode.com/problems/rearrange-string-ii/description/\n\nclass Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            return True\n        if s[0] == s[1]:\n            return False\n        if s[0] == s[-1]:\n            return False\n        if s[-1] == s[-2]:\n            return False\n        return self.canRearrange(s[1:-1]) and self.canRearrange(s[1:-1] + s[0])\n\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            return True\n        if s[0] == s[-1]:\n            return False\n        if s[-1] == s[-2]:\n            return False\n        return self.canRearrange(s[1:-1]) and self.canRearrange(s[1:-1] + s[0])\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.canRearrange(\"abba\")\n    print s.canRearrange(\"abba\")\n    print s.canRearrange(\"abbc\")\n    print s.canRearrange(\"cbbb\")\n    print s.canRearrange(\"bbbb\")\n    print s.canRearrange(\"b\")",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def checkIncorrect(self, s):\n        \"\"\"\n        check whether s is incorrect\n        :param s: string\n        :return: boolean\n        \"\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and (i!= j):\n                    return True\n        return False\n\n    def checkCorrect(self, s):\n        \"\"\"\n        check whether s is correct\n        :param s: string\n        :return: boolean\n        \"\"\"\n        cnt = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and (i!= j):\n                    cnt += 1\n        return cnt % 2 == 0\n\n    def isPalindrome(self, s):\n        \"\"\"\n        check whether s is palindrome\n        :param s: string\n        :return: boolean\n        \"\"\"\n        if s == s[::-1]:\n            return True\n        else:\n            return False\n\n    def isPalindrome2(self, s):\n        \"\"\"\n        check whether s is palindrome\n        :param s: string\n        :return: boolean\n        \"\"\"\n        # s is a palindrome if and only if s[i] == s[j] for all i < j\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i]!= s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n\nif __name__ == \"__main__\":\n    assert Solution().isPalindrome(\"aacecaaa\")\n    assert Solution().isPalindrome(\"abbabbb\")\n    assert Solution().isPalindrome(\"aabb\")\n    assert Solution().isPalindrome(\"ab\")\n    assert Solution().isPalindrome(\"\")\n    assert Solution().isPalindrome(\"abcdefghijklmnopqrstuvwxyz\")\n    assert Solution().isPalindrome(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "class Solution:\n    # @param s, a string\n    # @return a boolean\n    def isInterleave(self, s, t):\n        if not s or not t:\n            return False\n        m = len(s)\n        n = len(t)\n        if m < n:\n            return False\n        if m == n:\n            return s == t\n        p = []\n        for i in xrange(n):\n            p.append([])\n            for j in xrange(m):\n                if j == 0 or j == n-1:\n                    p[i].append(1)\n                else:\n                    p[i].append(s[j-1] == t[i-1] and p[i-1][j-1] + 1 or p[i-1][j-1] + 2)\n        return p[-1][-1] == 1",
    "# Time:  O(n2)\n# Space: O(n)\n\nclass Solution(object):\n    def isInterleave(self, s1, s2, t1, t2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type t1: str\n        :type t2: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(t1)!= len(t2):\n            return False\n\n        table = [[False] * len(t2) for _ in xrange(len(s1))]\n\n        for i in xrange(len(s1)):\n            for j in xrange(len(t1)):\n                if s1[i] == t1[j] and s2[i] == t2[j]:\n                    table[i][j] = True\n                elif s1[i] == t1[j]:\n                    table[i][j] = False\n                elif s2[i] == t2[j]:\n                    table[i][j] = False\n                else:\n                    return False\n\n        return all(x for x in table if x)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.isInterleave(\"aab\", \"dbb\", \"aad\", \"cde\") is True\n    assert s.isInterleave(\"aab\", \"dbb\", \"adc\", \"cde\") is False\n    assert s.isInterleave(\"abc\", \"bcd\", \"dca\", \"bdf\") is False",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        s3 = sorted(s3)\n        s1_len = len(s1)\n        s2_len = len(s2)\n        s3_len = len(s3)\n        if s1_len == 0 or s2_len == 0 or s3_len == 0:\n            return False\n        if s1_len!= s2_len:\n            return False\n        if s1_len!= s3_len:\n            return False\n        if s1_len!= s2_len:\n            return False\n        for i in range(0, s1_len):\n            if s1[i] == s2[i]:\n                continue\n            if s1[i] == s3[i]:\n                return True\n            if s2[i] == s3[i]:\n                return True\n        return False",
    "__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        l = len(s)\n        ret = False\n        for i in range(0, l):\n            if i+1 < l and s[i] == s[i+1]:\n                ret = True\n                break\n        for j in range(0, l):\n            if j+1 < l and s[j] == s[j+1]:\n                ret = False\n                break\n        return ret\n\nif __name__ == \"__main__\":\n    assert Solution().canRearrange(\"aab\") == True\n    assert Solution().canRearrange(\"aabb\") == False\n    assert Solution().canRearrange(\"abc\") == False\n    assert Solution().canRearrange(\"abbc\") == False\n    assert Solution().canRearrange(\"abcabc\") == False\n    assert Solution().canRearrange(\"abcdefgh\") == False",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        if len(s) == 1:\n            return True\n        mapping = {}\n        for i in range(len(s)):\n            mapping[s[i]] = i\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if mapping[s[i]] == mapping[s[j]]:\n                    return False\n        return True",
    "class Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n\n        counts = collections.Counter(s)\n\n        for c1 in s:\n            for c2 in s:\n                if c1!= c2 and c1!= c2 and counts[c1] == counts[c2]:\n                    return False\n\n        return True\n\nif __name__ == \"__main__\":\n    s = Solution()\n\n    print s.canPermute(\"abccca\")\n    print s.canPermute(\"abccc\")\n    print s.canPermute(\"abcbc\")\n    print s.canPermute(\"abbba\")",
    "class Solution:\n    def canRearrange(self, s: str) -> bool:\n        if len(s) < 2:\n            return True\n\n        dp = [[False] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = True\n                    dp[j][i] = True\n        return any(dp)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.canRearrange(\"aabb\"))\n    print(sol.canRearrange(\"abba\"))\n    print(sol.canRearrange(\"abcd\"))\n    print(sol.canRearrange(\"ac\"))\n    print(sol.canRearrange(\"\"))",
    "def is_possible(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(s) == 0:\n        return False\n    if len(s) == 1:\n        return True\n    if s[0] == s[1]:\n        return is_possible(s[1:])\n    if s[0] == s[-1]:\n        return is_possible(s[1:-1])\n    return is_possible(s[1:-1]) and is_possible(s[:-1])\n\nprint is_possible('abcd')\nprint is_possible('bcda')\nprint is_possible('cad')\nprint is_possible('abcde')",
    "import string\nimport collections\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # sort string\n        s = sorted(s)\n\n        # check if there is any pair of letters that are adjacent\n        for i in range(len(s)):\n            if (i > 0 and s[i] == s[i-1]) or (i < len(s)-1 and s[i] == s[i+1]):\n                return False\n\n        # check if there is any pair of letters that are adjacent to each other\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if (i > 0 and j > 0 and s[i] == s[j-1]) or (i < len(s)-1 and j < len(s)-1 and s[i] == s[j+1]):\n                    return False\n\n        return True\n\n\nif __name__ == '__main__':\n    s = \"rabbbit\"\n    print Solution().canPermuteString(s)",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # DP\n        # dp[i][j] = True if i-1 and j-1 are different\n        # dp[i][j] = False if i-1 and j-1 are the same\n        # dp[i][j] = False if i-1 and j-2 are different\n        # dp[i][j] = False if i-1 and j+2 are different\n        # dp[i][j] = False if i-2 and j+1 are different\n        # dp[i][j] = False if i-2 and j+2 are different\n        # dp[i][j] = False if i+1 and j-1 are different\n        # dp[i][j] = False if i+1 and j-2 are different\n        # dp[i][j] = False if i+2 and j-1 are different\n        # dp[i][j] = False if i+2 and j-2 are different\n        # dp[i][j] = False if i+2 and j+1 are different\n        # dp[i][j] = False if i+2 and j+2 are different\n        # dp[i][j] = False if i-2 and j+1 are different\n        # dp[i][j] = False if i-2 and j+2 are different\n        # dp[i][j] = False if i+1 and j-2 are different\n        # dp[i][j] = False if i+1 and j-1 are different\n        # dp[i][j] = False if i-1 and j-2 are different\n        # dp[i][j] = False if i-1 and j+2 are different\n        # dp[i][j] = False if i+2 and j-1 are different\n        # dp[i][j] = False if i+2 and j-2 are different\n        # dp[i][j] = False if i-2 and j-1 is different\n        # dp[",
    "class Solution(object):\n    def canReorder(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        if s[0]!= s[-1]:\n            return False\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                return False\n        return True",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # TODO\n        return False",
    "# https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/155544/Python-solution-with-explanation\n\n# The solution is the same as the solution of the problem \"Rearrange Letters\"\n\n# Solution 1:\n# We can split the string into two parts. The first part is the number of times we need to make two characters different.\n# The second part is the number of times we need to make a character different.\n# We can solve the first part by calculating the number of different letters in the first part.\n# Then we can solve the second part by calculating the number of different letters in the second part.\n# If we can do both things, we can rearrange the string.\n\nclass Solution(object):\n    def canRearrangeLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        count1 = len(s)\n        count2 = len(s)\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[i] == s[j]:\n                    count1 -= 1\n                    count2 -= 1\n        return count1 == 0 and count2 == 0\n\n# Time:  O(n^2)\n# Space: O(1)\n# Two pointers\n# Use two pointers to track the two different characters.\n# When we find two different characters, move them by one.\n# When we find two equal characters, move both of them by one.\n# When we find a different character, move both of them by one.\n# When we find a equal character, move both of them by one.\n# When we find two equal characters, move them by one.",
    "# Your function should return true if the given string can be rearranged,\n# otherwise, return false.\n\n# Example 1:\n# Input: \"bbace\"\n# Output: true\n# Explanation: It can be rearranged as \"acebb\".\n\n# Example 2:\n# Input: \"aab\"\n# Output: false\n# Explanation: It cannot be rearranged.\n\n# Note:\n# The string length is in the range [1, 1000].\n# The characters of the string are all lowercase letters.\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        letters = [x for x in s]\n        # for i in xrange(len(letters)):\n        #     for j in xrange(i):\n        #         if letters[i] == letters[j]:\n        #             return False\n        for i in xrange(len(letters) - 1):\n            if letters[i] == letters[i + 1]:\n                return False\n        return True\n\ns = Solution()\nprint s.canPermuteString(\"bbace\")\nprint s.canPermuteString(\"aab\")",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        # s1 is a string and s2 and s3 are strings\n        if len(s1)!= len(s2) or len(s2)!= len(s3):\n            return False\n        # if the length is 0, then they are the same length\n        if len(s1) == 0 or len(s2) == 0 or len(s3) == 0:\n            return True\n        # if the length is 1, then they are the same length\n        if len(s1) == 1 or len(s2) == 1 or len(s3) == 1:\n            return s1[0] == s2[0] and s1[0] == s3[0]\n        # if the length is 2, then they are the same length\n        if len(s1) == 2 or len(s2) == 2 or len(s3) == 2:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[0] == s3[0] and s1[1] == s3[1]\n        # if the length is 3, then they are the same length\n        if len(s1) == 3 or len(s2) == 3 or len(s3) == 3:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[0] == s3[0] and s1[1] == s3[1] and s1[2] == s3[2]\n        # if the length is 4, then they are the same length\n        if len(s1) == 4 or len(s2) == 4 or len(s3) == 4:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1",
    "#\n# Implement a function to check if a given string can be rearranged so that two characters that are adjacent to each other are different.\n#\n# Example 1:\n# Input: \"aba\"\n# Output: True\n# Example 2:\n# Input: \"abc\"\n# Output: True\n# Example 3:\n# Input: \"de\"\n# Output: False\n#\n# Note:\n# The string length will be in the range [1, 1000].\n# The characters in the string only include lowercase letters.\n#\n\nclass Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        return self.isInterleaveHelper(s1, s2, s3, 0, 0, 0)\n\n    def isInterleaveHelper(self, s1, s2, s3, i1, i2, j1):\n        if i2 == len(s2) or j1 == len(s3):\n            return True\n\n        if s1[i1]!= s2[i2] or s1[i1 + 1]!= s2[i2 + 1] or s3[j1]!= s1[i1]:\n            return False\n\n        return self.isInterleaveHelper(s1, s2, s3, i1 + 1, i2, j1 + 1) or \\\n               self.isInterleaveHelper(s1, s2, s3, i1, i2 + 1, j1) or \\\n               self.isInterleaveHelper(s1, s2, s3, i1, i2, j1 + 1)",
    "class Solution:\n    \"\"\"\n    @param s: The string that we are trying to rearrange\n    @return: A string\n    \"\"\"\n    def letterCombinations(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        \n        res = []\n        self.helper(s, res, \"\")\n        return res\n        \n    def helper(self, s, res, cur):\n        if len(cur) == len(s):\n            res.append(cur)\n            return\n        \n        for i in range(len(cur)):\n            self.helper(s, res, cur + s[i])\n\nif __name__ == \"__main__\":\n    s = \"aabcc\"\n    print(Solution().letterCombinations(s))",
    "# https://leetcode.com/problems/string-to-lowercase/discuss/102848/Java-O(N)-Time-Easy-Solution-with-if-else\nclass Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        \n        if len(s) == 1:\n            return True\n        \n        for i in range(len(s)):\n            if s[i]!= s[len(s)-i-1]:\n                return False\n        \n        return True",
    "# https://leetcode.com/problems/letter-combinations-of-a-phone-number/\n\nclass Solution(object):\n    def canReconstructPhoneNumber(self, number):\n        \"\"\"\n        :type number: str\n        :rtype: bool\n        \"\"\"\n        return self.canReconstructPhoneNumber_internal(number, [])\n\n    def canReconstructPhoneNumber_internal(self, number, possible_chars):\n        if not number:\n            return True\n        for i in range(len(number)):\n            if number[i] in possible_chars:\n                possible_chars.append(number[i])\n                if len(possible_chars) == 2:\n                    return True\n                else:\n                    possible_chars = self.canReconstructPhoneNumber_internal(number[i:], possible_chars)\n        return False",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        Rearrange s to be a permutation of itself\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # use dict to store the char->index map\n        dic = {}\n        for i, c in enumerate(s):\n            dic[c] = i\n\n        # generate all possible permutations of s\n        poss = [''.join(sorted(dic.keys())) for i in xrange(len(s))]\n\n        # check each permutation\n        for p in poss:\n            if p!= s and p in dic:\n                return False\n\n        return True\n\n\nif __name__==\"__main__\":\n    s = \"abcd\"\n    print Solution().canPermuteString(s)\n    print Solution().canPermuteString(\"abcd\")",
    "# https://www.hackerrank.com/challenges/string-rearrangement\n\ndef can_rearrange(string):\n    string_length = len(string)\n    \n    for i in range(0, string_length):\n        if string[i] == string[i+1]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    string = input()\n    print(can_rearrange(string))",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s1)!= len(s3):\n            return False\n        \n        # Create a map to store the result\n        result = {}\n        \n        # Check the first string\n        for i in range(len(s1)):\n            if s1[i] not in result:\n                result[s1[i]] = {}\n            if s2[i] not in result[s1[i]]:\n                result[s1[i]][s2[i]] = {}\n            if s3[i] not in result[s1[i]][s2[i]]:\n                result[s1[i]][s2[i]][s3[i]] = False\n            if result[s1[i]][s2[i]][s3[i]]:\n                return False\n            \n            result[s1[i]][s2[i]][s3[i]] = True\n        \n        # Check the second string\n        for i in range(len(s2)):\n            if s1[i] not in result:\n                result[s1[i]] = {}\n            if s2[i] not in result[s1[i]]:\n                result[s1[i]][s2[i]] = {}\n            if s3[i] not in result[s1[i]][s2[i]]:\n                result[s1[i]][s2[i]][s3[i]] = False\n            if result[s1[i]][s2[i]][s3[i]]:\n                return False\n            \n            result[s1[i]][s2[i]][s3[i]] = True\n        \n        # Check the third string\n        for i in range(len(s3)):\n            if s1[i] not in result:\n                result[s1[i]] = {}",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s2)!= len(s3):\n            return False\n        # dp[i][j] is true if s1[i:j] is interleave with s2[:j] and s3[:i]\n        # dp[i][j] is false if s1[i:j] is not interleave\n        dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\n        # dp[i][j] is true if s1[i:j] is interleave with s2[:j] and s3[:i]\n        # dp[i][j] is false if s1[i:j] is not interleave\n        for i in range(len(s1)+1):\n            for j in range(len(s2)+1):\n                if i == 0 or j == 0:\n                    dp[i][j] = False\n                elif s1[i-1] == s2[j-1] and s1[i-1] == s3[i-1]:\n                    dp[i][j] = dp[i-1][j-1] or dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[len(s1)][len(s2)]\n\nif __name__ == \"__main__\":\n    s1 = \"abcd\"\n    s2 = \"dcba\"\n    s3 = \"bacd\"\n    s = \"abcdb\"\n    print Solution().isInterleave(s1, s2, s3)\n    print Solution().isInterleave(s1, s2, s3)\n    print Solution().isInterleave(s, s, s)\n    print Solution().isInterleave(s1, s2, s3",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            return True\n        if len(s) == 3:\n            return True\n        if len(s) == 4:\n            return True\n        if len(s) == 5:\n            return True\n        if len(s) == 6:\n            return True\n        if len(s) == 7:\n            return True\n        if len(s) == 8:\n            return True\n        if len(s) == 9:\n            return True\n        if len(s) == 10:\n            return True\n        if len(s) == 11:\n            return True\n        if len(s) == 12:\n            return True\n        if len(s) == 13:\n            return True\n        if len(s) == 14:\n            return True\n        if len(s) == 15:\n            return True\n        if len(s) == 16:\n            return True\n        if len(s) == 17:\n            return True\n        if len(s) == 18:\n            return True\n        if len(s) == 19:\n            return True\n        if len(s) == 20:\n            return True\n        if len(s) == 21:\n            return True\n        if len(s) == 22:\n            return True\n        if len(s) == 23:\n            return True\n        if len(s) == 24:\n            return True\n        if len(s) == 25:\n            return True\n        if len(s) == 26:\n            return True\n        if len(s) == 27:\n            return True\n        if len(s) == 28:\n            return True\n        if len(s) == 29:\n            return True\n        if len(s) == 30:\n            return True\n        if len(s) == 31:\n            return True\n        if len(s) == 32:\n            return True\n        if len(s) == 33:",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        return self.helper(s, 0, len(s) - 1)\n    \n    def helper(self, s, start, end):\n        if start == end:\n            return True\n        \n        if start + 1 >= end:\n            return False\n        \n        if s[start] == s[end]:\n            if self.helper(s, start + 1, end - 1):\n                return True\n            \n        return False",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n\n        return self.canPermuteString(s[1:], s[0])\n\n\n    def canPermuteString(self, s, curr):\n        if len(s) == 0:\n            return True\n\n        if curr == s[0]:\n            return self.canPermuteString(s[1:], s[0])\n\n        return self.canPermuteString(s[1:], curr) and not self.canPermuteString(s[1:], s[0])\n\n\ns = Solution()\nprint s.canPermuteString(\"abc\")\nprint s.canPermuteString(\"abb\")\nprint s.canPermuteString(\"cab\")\nprint s.canPermuteString(\"caa\")\nprint s.canPermuteString(\"abbc\")",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        count = {}\n        for i in range(len(s)):\n            count[s[i]] = count.get(s[i], 0) + 1\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j]:\n                    count[s[i]] -= 1\n                    if count[s[i]] == 0:\n                        return False\n        return True",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        letters = set(s)\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    letters.discard(s[i])\n                    letters.discard(s[j])\n                    break\n        return len(letters) == 0",
    "# https://www.hackerrank.com/challenges/sorting-strings/problem\n\nimport collections\nimport unittest\n\ndef sortString(s):\n    result = collections.defaultdict(int)\n    for i in range(len(s)):\n        for j in range(len(s) - i - 1):\n            if s[j + 1] == s[j]:\n                result[s[j]] += 1\n    return result\n\ndef canBeRearranged(s):\n    result = sortString(s)\n    for k, v in result.items():\n        if v == 0:\n            return False\n    return True\n\nclass TestCode(unittest.TestCase):\n    def test_canBeRearranged(self):\n        s = \"aabbcc\"\n        self.assertTrue(canBeRearranged(s))\n        s = \"bbccca\"\n        self.assertFalse(canBeRearranged(s))\n        s = \"bbcccaaa\"\n        self.assertFalse(canBeRearranged(s))\n        s = \"aaabbcc\"\n        self.assertFalse(canBeRearranged(s))\n        s = \"aaabbcccc\"\n        self.assertFalse(canBeRearranged(s))\n        s = \"ccbbb\"\n        self.assertFalse(canBeRearranged(s))\n        s = \"ccbba\"\n        self.assertFalse(canBeRearranged(s))\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.is_valid(s)\n\n    def is_valid(self, s):\n        if not s:\n            return True\n        stack = []\n        for i in range(len(s)):\n            if i == 0 or s[i - 1]!= s[i]:\n                stack.append(s[i])\n            else:\n                if len(stack) == 1:\n                    return False\n                stack.pop()\n        return True",
    "#!/bin/python\n\nclass Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        return self.canPermute(s[1:]) or self.canPermute(s[:-1])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.canPermute(\"aab\")\n    print sol.canPermute(\"bbca\")\n    print sol.canPermute(\"cba\")",
    "def can_rearrange(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(s) < 2:\n        return True\n\n    # find adjacent chars\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s):\n            if s[i] == s[j]:\n                break\n            j += 1\n        # if adjacent chars found, we can rearrange\n        if j - i > 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint can_rearrange('aabbcc')",
    "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param s, a string\n    # @return a boolean\n    def isPossible(self, s):\n        if len(s) == 0:\n            return True\n        if len(s) == 1:\n            return s[0]!= s[0]\n        l = [True] * 26\n        for i in range(len(s)):\n            l[ord(s[i]) - 97] = False\n        for i in range(len(s)):\n            if l[ord(s[i]) - 97]:\n                return False\n        return True",
    "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_can_rearrange_string(self):\n        self.assertTrue(can_rearrange_string(\"aabbcc\"))\n        self.assertTrue(can_rearrange_string(\"abbcc\"))\n        self.assertTrue(can_rearrange_string(\"abbccdd\"))\n        self.assertTrue(can_rearrange_string(\"abbcd\"))\n        self.assertFalse(can_rearrange_string(\"aabbcd\"))\n        self.assertFalse(can_rearrange_string(\"abbcd\"))\n        self.assertFalse(can_rearrange_string(\"aabb\"))\n        self.assertFalse(can_rearrange_string(\"\"))\n        self.assertFalse(can_rearrange_string(\"aabbbbcc\"))\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if s1 == s2 or s2 == s3 or s1 == s3:\n            return True\n        s1 = ''.join(s1)\n        s2 = ''.join(s2)\n        s3 = ''.join(s3)\n        if s1 == s2 or s2 == s3 or s1 == s3:\n            return True\n        dic = {}\n        for i in range(len(s1)):\n            dic[s1[i]] = i\n        for i in range(len(s2)):\n            dic[s2[i]] = i\n        for i in range(len(s3)):\n            dic[s3[i]] = i\n        return self.isInterleave(s1, s2[::-1], s3[::-1]) and self.isInterleave(s1, s2, s3[::-1]) and self.isInterleave(s1, s2[::-1], s3)",
    "class Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n\n        n = len(s)\n        # print('s: ', s)\n        # print('n: ', n)\n\n        # check if all letters are different\n        for i in range(n):\n            if s[i] == s[i+1]:\n                return False\n        return True\n\n\nif __name__ == '__main__':\n    print(Solution().canPermute('ab'))\n    print(Solution().canPermute('aaa'))\n    print(Solution().canPermute('abc'))\n    print(Solution().canPermute('aabb'))\n    print(Solution().canPermute('abbb'))\n    print(Solution().canPermute('abcde'))\n    print(Solution().canPermute('abcdef'))\n    print(Solution().canPermute('abcdeff'))\n    print(Solution().canPermute('abcdeffg'))\n    print(Solution().canPermute('abcdeffgh'))\n    print(Solution().canPermute('abcdeffgh'))\n    print(Solution().canPermute('abcdeffghi'))\n    print(Solution().canPermute('abcdeffghii'))\n    print(Solution().canPermute('abcdeffghiii'))\n    print(Solution().canPermute('abcdeffghiiii'))\n    print(Solution().canPermute('abcdeffghiiiij'))\n    print(Solution().canPermute('abcdeffghiiij'))\n    print(Solution().canPermute('abcdeffghiiiij'))\n    print(Solution().canPermute('abcdeffghiiij'))\n    print(Solution().canPermute('abcdeffghiiiij'))\n    print(Solution().canPermute('abcdeffghiiij'))\n    print(Solution().canPermute('abcdeffghiiiij'))\n    print(",
    "class Solution(object):\n    def canRearrange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        \n        if s[0] == s[-1]:\n            return False\n        \n        for i in range(1, len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n            \n        return True",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        \n        # find the first two adjacent characters\n        first = -1\n        for i in range(len(s)):\n            if first == -1 and s[i] == s[i+1]:\n                first = i\n        \n        # find the last two adjacent characters\n        last = -1\n        for i in range(len(s)):\n            if last == -1 and s[i] == s[i-1]:\n                last = i\n        \n        # if the two adjacent characters are the same, then we can just return false\n        if first == last:\n            return False\n        \n        # if the two adjacent characters are different, then we need to check if we can\n        # rearrange the two adjacent characters to one character\n        if first > last:\n            # swap the last two characters\n            s[last], s[last+1] = s[last+1], s[last]\n        else:\n            # swap the first two characters\n            s[first], s[first+1] = s[first+1], s[first]\n        \n        return self.canPermuteString(s)",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s1)!= len(s3):\n            return False\n        return self.isInterleave(s2, s1, s3) or self.isInterleave(s1, s2, s3) or self.isInterleave(s1, s3, s2)\n\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1) == 0:\n            return True\n        if len(s2) == 0:\n            return False\n        if len(s3) == 0:\n            return False\n        if s1[0]!= s2[0] or s1[0]!= s3[0]:\n            return False\n        return self.isInterleave(s1[1:], s2[1:], s3[1:]) or self.isInterleave(s1[1:], s3[1:], s2[1:]) or self.isInterleave(s2[1:], s1[1:], s3[1:])",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        else:\n            return self.canPermuteString(s[1:]) and not self.isAdjacent(s[0], s[1]) and not self.isAdjacent(s[0], s[-1]) and not self.isAdjacent(s[-1], s[1])\n\n    def isAdjacent(self, a, b):\n        return a == b - 1 or a == b + 1 or a == b - 10 or a == b + 10\n\n\nif __name__ == \"__main__\":\n    print Solution().canPermuteString(\"abcd\")",
    "# https://leetcode.com/problems/rearrange-string-to-make-it-balanced/description/\n\nclass Solution(object):\n    def is_balanced(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        stack = []\n        for c in s:\n            if c == '(' or c == '{' or c == '[':\n                stack.append(c)\n            elif c == ')' or c == '}' or c == ']':\n                if len(stack) == 0 or stack[-1]!= c:\n                    return False\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0",
    "# https://www.hackerrank.com/challenges/string-rearrangement/problem\n\ndef canRearrange(string):\n    \"\"\"\n    Input: string = \"abc\"\n    Output: True\n    \"\"\"\n    letters = string[:]\n    for i in range(len(letters)-1):\n        if letters[i] == letters[i+1]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    string = input()\n    print(canRearrange(string))",
    "import string\n\ndef is_possible(s):\n    \"\"\"\n    Returns true if the given string can be rearranged, otherwise false.\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    letters = set(string.ascii_lowercase)\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                letters.remove(s[i])\n            else:\n                break\n    return len(letters) == 0\n\nprint(is_possible('aabb'))\nprint(is_possible('bbab'))\nprint(is_possible('abbba'))\nprint(is_possible('aaabb'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abbba'))\nprint(is_possible('abb",
    "class Solution(object):\n    def canReorderLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n        for i in range(n):\n            if s[i]!= s[n - i - 1]:\n                return False\n        return True",
    "class Solution(object):\n    def isRearrangeable(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        for i in range(1, len(s) - 1):\n            if s[i] == s[i - 1] and s[i + 1] == s[i]:\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    assert Solution().isRearrangeable(\"bcd\")\n    assert Solution().isRearrangeable(\"abcd\")\n    assert Solution().isRearrangeable(\"aac\")\n    assert Solution().isRearrangeable(\"\")\n    assert Solution().isRearrangeable(\"a\")\n    assert Solution().isRearrangeable(\"aab\")\n    assert Solution().isRearrangeable(\"abb\")",
    "class Solution:\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        c1, c2 = '', ''\n        for i in range(len(s)):\n            if s[i] == s[i+1]:\n                c1 += s[i]\n                c2 += s[i+1]\n            else:\n                c1 += s[i+1]\n                c2 += s[i]\n            if c1 == c2:\n                return False\n        return True\n\n\nif __name__ == \"__main__\":\n    s = \"abbc\"\n    s = \"abbbc\"\n    s = \"abbbcabbc\"\n    print(Solution().canPermute(s))",
    "# https://leetcode.com/problems/string-rearrange-letters/description/\n\nclass Solution(object):\n    def canRearrangeLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        table = {}\n        for i in range(len(s)):\n            if s[i] not in table:\n                table[s[i]] = i\n            else:\n                table[s[i]] = table[s[i]] + 1\n        for i in range(len(s)):\n            if table[s[i]] - 1 == i:\n                return True\n        return False",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return True\n        \n        # a, b, c, d\n        # a, b, c, d, e, f, g, h\n        # a, b, c, d, e, f, g, h, i, j\n        # a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        # a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        # a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        # a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q,",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        l = []\n        for i in range(len(s)):\n            l.append(s[i])\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if l[i] == l[j]:\n                    return False\n                if l[i] == l[j-1] and l[j]!= l[j-1]:\n                    return False\n        return True",
    "class Solution:\n    def canRearrange(self, s: str) -> bool:\n        if len(s) < 2:\n            return True\n\n        res = []\n        for i in range(len(s)):\n            cur = s[i]\n            if cur in res:\n                continue\n            for j in range(i + 1, len(s)):\n                if s[j] == cur:\n                    res.append(cur)\n                    break\n            else:\n                res.append(cur)\n\n        return len(res) == len(s) - 1\n\n\nif __name__ == \"__main__\":\n    print(Solution().canRearrange(\"ba\"))\n    print(Solution().canRearrange(\"abc\"))\n    print(Solution().canRearrange(\"abca\"))\n    print(Solution().canRearrange(\"b\"))\n    print(Solution().canRearrange(\"\"))\n    print(Solution().canRearrange(\"aa\"))\n    print(Solution().canRearrange(\"abcd\"))\n    print(Solution().canRearrange(\"bacd\"))",
    "class Solution:\n    # @param s, a string\n    # @return a boolean\n    def isInterleave(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(t):\n            return False\n        \n        # Check if the first and last character of t are the same\n        if s[0]!= t[-1]:\n            return False\n        \n        # Check if the characters of s are in the same order as t\n        for i in range(len(s)):\n            if s[i]!= t[i]:\n                return False\n        \n        # Check if the letters of s can be rearranged to t\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        \n        return True\n\nif __name__ == '__main__':\n    print Solution().isInterleave('abcd', 'dcba')",
    "# Definition for a character.\nclass Character(object):\n    def __init__(self, ch):\n        self.ch = ch\n\n    def __str__(self):\n        return self.ch\n\nclass Solution(object):\n    def isPossible(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and (i-1 >= 0 and s[i-1]!= s[j]):\n                    return False\n        return True",
    "# Definition for a character:\n# class Character:\n#     def __init__(self, ch: str=''):\n#         self.ch = ch\n#         self.previous = None\n\nclass Solution(object):\n    def canPermute(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # DP\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        if len(s) == 0:\n            return True\n\n        # store the previous and current indices of each character\n        previous = [0] * len(s)\n        current = [0] * len(s)\n        for i in range(len(s)):\n            if s[i] == s[current[previous[i]]]:\n                previous[i] += 1\n            else:\n                previous[i] = 0\n                current[i] = i\n\n        # return true if the current character can be swapped with the previous one\n        for i in range(len(s)):\n            if current[i]!= i:\n                return False\n\n        # return true if the current character can be swapped with the previous one\n        for i in range(len(s)):\n            if previous[i]!= i:\n                return False\n\n        return True",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            if s[0] == s[1]:\n                return False\n            else:\n                return True\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        return True\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.canPermuteString('abc'))\n    print(s.canPermuteString('aba'))\n    print(s.canPermuteString('abb'))\n    print(s.canPermuteString('aa'))\n    print(s.canPermuteString('a'))\n    print(s.canPermuteString('aa'))\n    print(s.canPermuteString('aba'))\n    print(s.canPermuteString('bba'))\n    print(s.canPermuteString('bab'))\n    print(s.canPermuteString('bba'))\n    print(s.canPermuteString('bba'))\n    print(s.canPermuteString('abab'))\n    print(s.canPermuteString('baba'))\n    print(s.canPermuteString('baab'))\n    print(s.canPermuteString('baab'))\n    print(s.canPermuteString('bbaa'))\n    print(s.canPermuteString('bbaa'))\n    print(s.canPermuteString('bbbb'))\n    print(s.canPermuteString('bbbb'))\n    print(s.canPermuteString('abbb'))\n    print(s.canPermuteString('abbb'))\n    print(s.canPermuteString('babb'))\n    print(s.canPermuteString('babb'))\n    print(s.canPer",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        \n        # check if letters are adjacent\n        for i in range(len(s)):\n            if i == 0:\n                continue\n            \n            if s[i] == s[i-1]:\n                return False\n            \n        # check if every letter can be swapped\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    return False\n        \n        return True",
    "# https://leetcode.com/problems/rearrange-letters/description/\n\nclass Solution(object):\n    def canRearrangeLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        return self.check(s)\n\n    def check(self, s):\n        if len(s) == 1:\n            return True\n        if s[0] == s[1]:\n            return self.check(s[1:])\n        else:\n            return False\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.canRearrangeLetters(\"aabbcc\")\n    print s.canRearrangeLetters(\"aabbccdd\")\n    print s.canRearrangeLetters(\"aabbccdde\")\n    print s.canRearrangeLetters(\"aabbccddee\")\n    print s.canRearrangeLetters(\"aabbccddeeff\")\n    print s.canRearrangeLetters(\"aabbccddeeffgg\")",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1:\n            return True\n        # s = \"abcd\"\n        # permutations = self.permutations(s)\n        # return self.isPermutation(s, permutations)\n        \n        # print s\n        # print self.isPermutation(s, s)\n        # print self.isPermutation(s, self.permutations(s))\n        \n        # print self.isPermutation(s, self.permutations(s))\n        # return self.isPermutation(s, self.permutations(s))\n        \n        # print self.isPermutation(s, s)\n        \n        # print self.isPermutation(s, self.permutations(s))\n        \n        # print self.isPermutation(s, self.permutations(s))\n        # return self.isPermutation(s, self.permutations(s))\n        \n        return False\n        \n    def permutations(self, s):\n        if len(s) == 1:\n            return [[s]]\n        \n        res = []\n        for i in range(len(s)):\n            for perm in self.permutations(s[:i]):\n                for p in self.permutations(s[i+1:]):\n                    res.append(perm + p)\n        return res\n        \n    def isPermutation(self, s1, s2):\n        if len(s1)!= len(s2):\n            return False\n        res = [[] for _ in range(len(s1))]\n        for i in range(len(s1)):\n            res[i].append(s1[i])\n        for i in range(len(s2)):\n            if s2[i] not in res[i]:\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.canPermuteString(\"abcd\")\n    s.canPermuteString(\"abc",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        s1 = s1.upper()\n        s2 = s2.upper()\n        s3 = s3.upper()\n        for i in range(len(s1)):\n            if s1[i] == s2[i]:\n                if s1[i] == s3[i]:\n                    return True\n                else:\n                    continue\n            else:\n                if s1[i+1] == s2[i] and s2[i] == s3[i]:\n                    return True\n                else:\n                    continue\n        return False",
    "class Solution:\n    # @param s, a string\n    # @return a boolean\n    def isScramble(self, s):\n        if len(s) == 0:\n            return False\n        if len(s) == 1:\n            return True\n        \n        i = 0\n        while i < len(s):\n            if s[i] == s[i+1]:\n                i += 2\n            else:\n                break\n        \n        if i == len(s):\n            return True\n        \n        j = len(s) - 1\n        while j >= 0:\n            if s[i] == s[j]:\n                j -= 2\n            else:\n                break\n        \n        return j == -1\n        \nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isScramble(\"a\")\n    print s.isScramble(\"aa\")\n    print s.isScramble(\"aba\")\n    print s.isScramble(\"aba\")",
    "# https://www.hackerrank.com/challenges/sorting-string/problem\n\ndef is_possible(s):\n    if len(s) == 1:\n        return False\n    if s[0] == s[1]:\n        return False\n    if s[0] == s[-1]:\n        return False\n    return True\n\n# Your Solution here:\n\ndef is_possible(s):\n    if len(s) == 1:\n        return False\n    if s[0] == s[1]:\n        return False\n    if s[0] == s[-1]:\n        return False\n    for i in range(1, len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    s = input()\n    print(is_possible(s))",
    "# https://www.hackerrank.com/challenges/can-i-get-my-string-together/problem\n\ndef can_get_string(str):\n    for i in range(len(str)):\n        for j in range(i+1, len(str)):\n            if str[i] == str[j]:\n                return False\n    return True\n\nif __name__ == \"__main__\":\n    str = input().strip()\n    print(can_get_string(str))",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if s1 == s2:\n            return True\n\n        if s1 == s3:\n            return True\n\n        if s2 == s3:\n            return True\n\n        if len(s1)!= len(s2) or len(s2)!= len(s3):\n            return False\n\n        s1 = s1.lower()\n        s2 = s2.lower()\n        s3 = s3.lower()\n\n        dic = {}\n        for i in range(len(s1)):\n            dic[s1[i]] = i\n        for i in range(len(s2)):\n            dic[s2[i]] = i\n        for i in range(len(s3)):\n            dic[s3[i]] = i\n\n        def rec(i, j):\n            if i >= len(s1) or j >= len(s2) or i >= j:\n                return False\n            if s1[i] == s2[j]:\n                if s1[i] in dic and s1[i] in dic[s2[j]]:\n                    return rec(i + 1, dic[s1[i]]) or rec(dic[s1[i]], j + 1)\n                else:\n                    return rec(i + 1, j)\n            else:\n                if s1[i] in dic and s2[j] in dic[s1[i]]:\n                    return rec(i, dic[s1[i]]) or rec(i, j + 1)\n                else:\n                    return rec(i, j)\n        return rec(0, 0)\n\n    def isInterleave2(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        s1 = s1.lower()",
    "class Solution(object):\n    def canPermuteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        dic = {}\n        for i in range(len(s)):\n            dic[s[i]] = i\n        return self.canPermuteStringHelper(s, dic)\n\n    def canPermuteStringHelper(self, s, dic):\n        if len(s) == 1:\n            return True\n        for i in range(len(s)):\n            if dic[s[i]]!= i+1:\n                return False\n        return self.canPermuteStringHelper(s[0:len(s)-1], dic)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.canPermuteString('abcd')\n    print s.canPermuteString('abbcd')\n    print s.canPermuteString('abcde')\n    print s.canPermuteString('abcdef')\n    print s.canPermuteString('abcdefg')",
    "def is_possible(s):\n    if len(s) < 2:\n        return False\n    if s.count('a') == 1 and s.count('b') == 1:\n        return True\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j] and (i-j) == 1:\n                return False\n    return True\n\n#print(is_possible('aaabb'))\n#print(is_possible('ab'))\n#print(is_possible('aa'))\n#print(is_possible('bb'))\n#print(is_possible('bb'))\n#print(is_possible('ab'))\n\n# Test cases:\n# is_possible('aabb') -> True\n# is_possible('abb') -> False\n# is_possible('aa') -> True\n# is_possible('aa') -> False\n# is_possible('bb') -> True\n# is_possible('bb') -> False\n# is_possible('ab') -> True\n# is_possible('ab') -> False\n# is_possible('aaabb') -> True\n# is_possible('ababb') -> False\n# is_possible('abb') -> True\n# is_possible('abb') -> False\n# is_possible('aa') -> True\n# is_possible('aa') -> False\n# is_possible('bb') -> True\n# is_possible('bb') -> False\n# is_possible('ab') -> True\n# is_possible('ab') -> False\n# is_possible('aabb') -> True\n# is_possible('ababb') -> False\n# is_possible('abb') -> True\n# is_possible('abb') -> False\n# is_possible('aa') -> True\n# is_possible('aa') -> False\n# is_possible('bb') -> True\n# is_possible('bb') -> False\n# is_possible('ab') -> True\n# is_possible('ab') -> False\n# is_possible('aabb') -> True\n#",
    "#!/bin/python\n\nclass Solution:\n    # @param s, a string\n    # @return a boolean\n    def canPermute(self, s):\n        if len(s) < 2:\n            return True\n        \n        # find the first char\n        first = s[0]\n        \n        # find the last char\n        last = s[-1]\n        \n        # find the second char that is adjacent to the first\n        second = s[1]\n        \n        # check if adjacent chars are different\n        if first == second and s[0]!= s[-1]:\n            return False\n        \n        # check if adjacent chars are different\n        if first == last and s[0]!= s[-2]:\n            return False\n        \n        # check if adjacent chars are different\n        if first == last and s[0]!= s[-3]:\n            return False\n        \n        # if we have reached here, we can permute\n        return True",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param s, a string\n    # @return a boolean\n    def canPermute(self, s):\n        result = True\n        # check for the first 2 characters\n        if s[0]!= s[1]:\n            result = False\n            return result\n\n        # check for the middle 2 characters\n        for i in range(2, len(s) - 1):\n            if s[i - 1] == s[i]:\n                result = False\n                return result\n\n        # check for the last 2 characters\n        if s[-1]!= s[-2]:\n            result = False\n            return result\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")\n    print s.canPermute(\"abbc\")\n    print s.canPermute(\"babcb\")\n    print s.canPermute(\"abbbc\")",
    "def can_rearrange(str):\n    \"\"\"\n    :type str: str\n    :rtype: bool\n    \"\"\"\n    if len(str) < 2:\n        return True\n    for i in range(1, len(str)):\n        if str[i-1] == str[i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    print can_rearrange(\"abccccc\")\n    print can_rearrange(\"abcabc\")\n    print can_rearrange(\"abccc\")\n    print can_rearrange(\"abcc\")\n    print can_rearrange(\"abc\")\n    print can_rearrange(\"abc\")\n    print can_rearrange(\"aabbcccc\")\n    print can_rearrange(\"abccc\")\n    print can_rearrange(\"abcabc\")",
    "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1)!= len(s2) or len(s2)!= len(s3):\n            return False\n\n        if len(s1) == 0:\n            return True\n\n        if len(s2) == 0:\n            return False\n\n        if s1[0] == s2[0] and s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3[1:]) or self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:]) or self.isInterleave(s1[1:], s2[1:], s3)\n\n        if s1[0] == s3[0] and s1[0] == s2[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3[1:]) or self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:]) or self.isInterleave(s1[1:], s2[1:], s3)\n\n        if s1[0] == s2[0] and s1[0]!= s3[0]:\n            return self.isInterleave(s1[1:], s2[1:], s3) or self.isInterleave(s1, s2[1:], s3[1:]) or self.isInterleave(s1[1:], s2[1:], s3)\n\n        if s1[0]!= s2[0] and s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1",
    "import unittest\n\nclass Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        return self.isInterleave(s1, s2, s3, 0, 0) and self.isInterleave(s1, s2, s3, 0, 1) and self.isInterleave(s1, s2, s3, 0, 2)\n\n    def isInterleave(self, s1, s2, s3, index1, index2):\n        if index1 == len(s1) and index2 == len(s2) and index2 == len(s3):\n            return True\n\n        if index1 == len(s1) or index2 == len(s2) or index2 == len(s3):\n            return False\n\n        if s1[index1] == s2[index2] and self.isInterleave(s1, s2, s3, index1 + 1, index2 + 1):\n            return True\n\n        if s2[index1] == s3[index2] and self.isInterleave(s1, s2, s3, index1 + 1, index2 + 1):\n            return True\n\n        return False\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/interleaving-strings/solution/\n\n# Approach #1: Brute Force [Accepted]\n# Complexity Analysis\n# Time Complexity: O(m*n*l)\n# Space Complexity: O(m*n*l)\n\n# 10ms 100%\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() == 0 || s2.length() == 0 || s3.length() == 0) {\n            return false;",
    "class Solution:\n    # @param s, a string\n    # @return a boolean\n    def canPermute(self, s):\n        count = {}\n        for i in range(len(s)):\n            if s[i] in count:\n                count[s[i]] += 1\n            else:\n                count[s[i]] = 1\n        for i in range(len(s)):\n            if count[s[i]] == 1:\n                return False\n        return True"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}