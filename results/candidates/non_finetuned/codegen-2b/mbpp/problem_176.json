{
  "problem": {
    "task_id": "MBPP/187",
    "prompt": "Write a function to find the longest common subsequence for the given two sequences.",
    "canonical_solution": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))",
    "test_list": [
      "assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4",
      "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3",
      "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2"
    ],
    "challenge_test_list": [],
    "problem_id": 176
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import collections\n\nclass Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        if len(s) == 0 or len(t) == 0:\n            return ''\n\n        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(n):\n            for j in range(m):\n                if s[i] == t[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                elif dp[i + 1][j] > dp[i][j + 1]:\n                    dp[i + 1][j + 1] = dp[i][j + 1]\n                else:\n                    dp[i + 1][j + 1] = dp[i + 1][j]\n        \n        maxLen = 0\n        maxI = 0\n        maxJ = 0\n        for i in range(n):\n            for j in range(m):\n                if dp[i + 1][j + 1] > maxLen:\n                    maxLen = dp[i + 1][j + 1]\n                    maxI = i\n                    maxJ = j\n        \n        return s[maxI - 1:maxI + maxLen]\n\nif __name__ == '__main__':\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    t = \"abcdefghijklmnopqrstuvwxyz\"\n    print(Solution().longestCommonSubsequence(s, t))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return 0\n        m = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        for i in range(1, len(A) + 1):\n            m[i][0] = 0\n        for j in range(1, len(B) + 1):\n            m[0][j] = 0\n        for i in range(1, len(A) + 1):\n            for j in range(1, len(B) + 1):\n                if A[i - 1] == B[j - 1]:\n                    m[i][j] = m[i - 1][j - 1] + 1\n                else:\n                    m[i][j] = max(m[i - 1][j], m[i][j - 1])\n        return m[-1][-1]\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3, 4, 5]\n    B = [1, 2, 3, 4]\n    print(Solution().longestCommonSubsequence(A, B))",
    "class Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        if not s1 or not s2:\n            return ''\n\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in xrange(m + 1)]\n        for i in xrange(m):\n            for j in xrange(n):\n                if s1[i] == s2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return ''.join([str(dp[m][n]) for _ in xrange(m)])",
    "#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#!/usr/bin/env python\n\n#",
    "import collections\n\nclass Solution(object):\n    def findLcs(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        m, n = len(s), len(t)\n        if m == 0:\n            return t\n        if n == 0:\n            return s\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return \"\".join(s[i-1] for i in range(m+1) if dp[i][n] > dp[m][n-1])\n\n\nif __name__ == \"__main__\":\n    print Solution().findLcs(\"abc\", \"cba\")",
    "def lcs(seq1, seq2):\n    \"\"\"\n    Find the longest common subsequence between two sequences.\n    seq1 and seq2 are lists of string.\n\n    Time Complexity: O(|seq1|+|seq2|)\n    Space Complexity: O(|seq1|+|seq2|)\n    \"\"\"\n    if len(seq1) == 0 or len(seq2) == 0:\n        return ''\n    if len(seq1) < len(seq2):\n        seq1, seq2 = seq2, seq1\n    if seq1[0] == seq2[0]:\n        return lcs(seq1[1:], seq2[1:]) + seq1[0]\n    else:\n        return lcs(seq1[1:], seq2) + seq1[0]\n\nif __name__ == '__main__':\n    print lcs('a', 'ab')\n    print lcs('a', 'aab')\n    print lcs('a', 'aab')\n    print lcs('abc', 'ab')\n    print lcs('abc', 'ab')",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: int\n        \"\"\"\n        m, n = len(str1), len(str2)\n        if m == 0 or n == 0:\n            return 0\n        dp = [[0] * (n + 1) for _ in xrange(m + 1)]\n        for i in xrange(m + 1):\n            for j in xrange(n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: int\n        \"\"\"\n        str1_l = len(str1)\n        str2_l = len(str2)\n        str1_dict = {}\n        str2_dict = {}\n        str1_list = []\n        str2_list = []\n        for i in range(str1_l):\n            if str1_dict.get(str1[i]) is None:\n                str1_dict[str1[i]] = str1_list.append(str1[i])\n            else:\n                str1_list.append(str1_dict[str1[i]])\n            if str2_dict.get(str2[i]) is None:\n                str2_dict[str2[i]] = str2_list.append(str2[i])\n            else:\n                str2_list.append(str2_dict[str2[i]])\n        str1_list.sort()\n        str2_list.sort()\n        max_length = 0\n        for i in range(str1_l):\n            if str1_list[i] == str2_list[i]:\n                max_length = max(max_length, i + 1)\n        return max_length",
    "#!/usr/bin/python\n\n#!/usr/bin/python\n\nclass Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {integer}\n\n    def longestCommonSubsequence(self, s, t):\n        # write your code here\n        if not s or not t:\n            return 0\n\n        m = len(s)\n        n = len(t)\n\n        dp = [[0] * n for i in range(m)]\n\n        for i in range(m):\n            dp[i][0] = i\n\n        for j in range(n):\n            dp[0][j] = j\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    s = \"ABCBDAB\"\n    t = \"ADB\"\n    print Solution().longestCommonSubsequence(s, t)",
    "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/longest-common-subsequence/problem\n\nimport collections\n\n\nclass Solution(object):\n\n    def __init__(self, sequence1, sequence2):\n        self.sequence1 = sequence1\n        self.sequence2 = sequence2\n\n    def longestCommonSubsequence(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        def get_subsequence(seq1, seq2):\n            \"\"\"\n            :type seq1: List[int]\n            :type seq2: List[int]\n            :rtype: List[int]\n            \"\"\"\n            if len(seq1) == 0 or len(seq2) == 0:\n                return []\n            else:\n                max_len = max(len(seq1), len(seq2))\n                return [seq1[i:i + max_len] for i in range(0, len(seq1) + len(seq2) - max_len)]\n\n        def get_longest_subsequence(seq1, seq2):\n            \"\"\"\n            :type seq1: List[int]\n            :type seq2: List[int]\n            :rtype: List[int]\n            \"\"\"\n            if len(seq1) == 0 or len(seq2) == 0:\n                return []\n            else:\n                return [seq1[i:i + 1] for i in range(0, len(seq1) + len(seq2) - 1)]\n\n        def get_common_subsequence(seq1, seq2):\n            \"\"\"\n            :type seq1: List[int]\n            :type seq2: List[int]\n            :rtype: List[int]\n            \"\"\"\n            if len(seq1) == 0 or len(seq2) == 0:\n                return []\n            else:\n                return [seq1[i:i + 1] for i in range(0, len(seq1)) if seq1[i] == seq2[i]]\n\n        def get_lcs(seq1, seq2):\n            \"\"\"\n            :type seq1: List[int]\n            :type seq2: List[int]",
    "class Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # naive solution\n        # return ''.join(sorted(s))\n\n        # solution with hashmap\n        # return ''.join(sorted([k for k, v in self.find_common(s, t) if v]))\n\n        # solution with dp\n        # return ''.join(sorted([k for k, v in self.dp(s, t) if v]))\n\n        # solution with dp and hashmap\n        # return ''.join(sorted([k for k, v in self.dp_hashmap(s, t) if v]))\n\n        # solution with hashmap and dp\n        # return ''.join(sorted([k for k, v in self.dp_hashmap_dp(s, t) if v]))\n\n        # solution with hashmap and dp and hashmap\n        # return ''.join(sorted([k for k, v in self.dp_hashmap_dp_hashmap(s, t) if v]))\n\n        # solution with hashmap and dp and hashmap and hashmap\n        # return ''.join(sorted([k for k, v in self.dp_hashmap_dp_hashmap_hashmap(s, t) if v]))\n\n    def find_common(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: dict[str, int]\n        \"\"\"\n        m = len(s)\n        n = len(t)\n        if m == 0 or n == 0:\n            return {}\n\n        dp = {}\n        for i in xrange(m):\n            dp[s[i]] = 0\n        for i in xrange(n):\n            dp[t[i]] = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if i == 0 or j == 0:\n                    dp[s[i]] = max(dp[s[i]], dp[t[j]]) + 1",
    "from collections import defaultdict\n\nclass Solution(object):\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: str\n        \"\"\"\n        max_length = 0\n        for i in range(len(A)):\n            max_length = max(max_length, len(A[i]))\n            max_length = max(max_length, len(B[i]))\n        max_length = max(max_length, len(A[0]))\n        max_length = max(max_length, len(B[0]))\n        # The maximum length of the LCS is the length of the longest common subsequence\n        # of the two sequences.\n        # We can assume that the longest common subsequence of A and B is the longest\n        # common subsequence of A and B[:i].\n        # We can assume that the longest common subsequence of A and B[:i] is the longest\n        # common subsequence of A[:i] and B[:i].\n        # We can also assume that the longest common subsequence of A[:i] and B[:i] is\n        # the longest common subsequence of A[:i] and B[:i].\n        # Since the longest common subsequence of A and B[:i] is the longest common\n        # subsequence of A and B[:i], the length of the longest common subsequence of\n        # A and B is the length of the longest common subsequence of A and B[:i].\n        # We can also assume that the length of the longest common subsequence of A and\n        # B[:i] is the length of the longest common subsequence of A and B[:i].\n        # So the maximum length of the longest common subsequence is the length of the\n        # longest common subsequence of A and B[:i].\n        # We can also assume that the length of the longest common subsequence of A and\n        # B[:i] is the length of the longest common subsequence of A and B[:i].\n        # The length of the longest common subsequence of A and B[:i] is the length of",
    "import unittest\nfrom typing import List\n\nclass Solution:\n    def longestCommonSubsequence(self, s1: str, s2: str) -> List[str]:\n        m = len(s1)\n        n = len(s2)\n\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n\n        for i in range(m):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n\n        res = []\n        i = m - 1\n        j = n - 1\n        while i >= 0 and j >= 0:\n            if s1[i] == s2[j]:\n                res.append(s1[i])\n                i -= 1\n                j -= 1\n            else:\n                if dp[i][j] > dp[i + 1][j]:\n                    i -= 1\n                else:\n                    j -= 1\n\n        return res\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/longest-common-subsequence/solution/\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public List<String> longestCommonSubsequence(String s1, String s2) {\n        List<String> res = new ArrayList();\n        int m = s1.length(), n = s2.length();\n\n        // dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        int[][",
    "import unittest\n\nclass Solution:\n    # @param {string[]} strs\n    # @return {string}\n    def longestCommonSubsequence(self, strs):\n        if len(strs) == 0 or len(strs) == 1:\n            return strs[0]\n\n        n = len(strs)\n        m = len(strs[0])\n\n        dp = [[0] * (m+1) for i in range(n+1)]\n        dp[0][0] = 0\n\n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if strs[i-1][j-1] == strs[i-1][j]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n        result = \"\"\n        for i in range(n):\n            for j in range(m):\n                if dp[i+1][j+1] > dp[i][j]:\n                    result += strs[i][j]\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/longest-common-subsequence/solution/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n# 5ms 100%\nclass Solution {\n    public String longestCommonSubsequence(String[] strs) {\n        if (strs.length == 0 || strs.length == 1) return strs[0];\n        int n = strs.length;\n        int m = strs[0].length();\n        int[][] dp = new int",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if len(str1) == 0 or len(str2) == 0:\n            return \"\"\n        l1, r1 = 0, len(str1) - 1\n        l2, r2 = 0, len(str2) - 1\n        max_len = 0\n        max_len_str = \"\"\n        while l1 <= r1 and l2 <= r2:\n            if str1[l1] == str2[l2]:\n                max_len_str += str1[l1]\n                l1 += 1\n                l2 += 1\n            elif str1[l1] < str2[l2]:\n                l1 += 1\n            else:\n                l2 += 1\n        return max_len_str\n\n    def longestCommonSubsequence2(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if len(str1) == 0 or len(str2) == 0:\n            return \"\"\n        l1, r1 = 0, len(str1) - 1\n        l2, r2 = 0, len(str2) - 1\n        max_len = 0\n        max_len_str = \"\"\n        while l1 <= r1 and l2 <= r2:\n            if str1[l1] == str2[l2]:\n                max_len_str += str1[l1]\n                l1 += 1\n                l2 += 1\n            elif str1[l1] < str2[l2]:\n                l1 += 1\n            else:\n                l2 += 1\n        return max_len_str",
    "import collections\n\ndef longest_common_subsequence(s1, s2):\n    \"\"\"\n    Write a function to find the longest common subsequence for the given two sequences.\n\n    :type s1: str\n    :type s2: str\n    :rtype: int\n    \"\"\"\n    table = collections.defaultdict(list)\n\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            if s1[i] == s2[j]:\n                table[i][j] = 1\n    return max(max(table[i]) for i in range(len(s1)))",
    "import unittest\n\nfrom longest_common_subsequence import longest_common_subsequence\n\n\nclass TestLongestCommonSubsequence(unittest.TestCase):\n    def test_longest_common_subsequence_empty_sequences(self):\n        self.assertEqual(longest_common_subsequence(''), '')\n\n    def test_longest_common_subsequence_one_sequence(self):\n        self.assertEqual(longest_common_subsequence('a'), 'a')\n\n    def test_longest_common_subsequence_two_sequences(self):\n        self.assertEqual(longest_common_subsequence('abc'), 'cba')\n\n    def test_longest_common_subsequence_two_sequences_with_one_empty_sequence(self):\n        self.assertEqual(longest_common_subsequence('a', ''), 'a')\n\n    def test_longest_common_subsequence_two_sequences_with_one_empty_sequence_and_one_non_empty_sequence(self):\n        self.assertEqual(longest_common_subsequence('a', 'bc'), 'abc')\n\n    def test_longest_common_subsequence_two_sequences_with_one_non_empty_sequence(self):\n        self.assertEqual(longest_common_subsequence('ab', 'c'), 'abc')\n\n    def test_longest_common_subsequence_two_sequences_with_one_non_empty_sequence_and_one_non_empty_sequence(self):\n        self.assertEqual(longest_common_subsequence('ab', 'cbc'), 'abc')\n\n    def test_longest_common_subsequence_two_sequences_with_one_non_empty_sequence_and_one_empty_sequence(self):\n        self.assertEqual(longest_common_subsequence('ab', 'c'), 'abc')\n\n    def test_longest_common_subsequence_two_sequences_with_two_non_empty_sequences(self):\n        self.assertEqual(longest_common_subsequence('ab', 'ac'), 'ac')\n\n    def",
    "class Solution:\n    # @param {string} str1\n    # @param {string} str2\n    # @return {string}\n    def longestCommonSubsequence(self, str1, str2):\n        if len(str1) == 0:\n            return str2\n        if len(str2) == 0:\n            return str1\n        if str1[0]!= str2[0]:\n            return self.longestCommonSubsequence(str1, str2[1:])\n        subseq = []\n        longest_subseq = []\n        for i in range(len(str1)):\n            for j in range(len(str2)):\n                if str1[i] == str2[j]:\n                    subseq.append(str1[i])\n                    longest_subseq.append(str1[i])\n                    if len(subseq) > len(longest_subseq):\n                        longest_subseq = subseq\n                    subseq = []\n                else:\n                    subseq.append(str2[j])\n            if len(subseq) > len(longest_subseq):\n                longest_subseq = subseq\n            subseq = []\n        return ''.join(longest_subseq)",
    "# https://oj.leetcode.com/problems/longest-common-subsequence/\n# Given two sequences, you need to find the longest common subsequence\n# of the two sequences.\n\n# A subsequence of a sequence S is a list\n# consisting of all elements of S that do not appear in any other subsequence\n# of S.\n\n# Example 1:\n# Input:\n# s1 = \"PAYPALISHIRING\"\n# s2 = \"PAYPALISHIRINGSHIRING\"\n# Output:\n# \"PAHNAPLSIIGYIRSHING\"\n# Note:\n# s1 and s2 only contain lowercase letters.\n# Length of both s1 and s2 is 1000.\n# The length of each input string s1 and s2 is 1000.\n# s1 and s2 only contain lowercase letters.\n\n\nclass Solution:\n    # @param s1, s2: two string\n    # @return: the length of the longest common subsequence of s1 and s2\n    def longestCommonSubsequence(self, s1, s2):\n        m = [[0] * len(s2) for _ in range(len(s1))]\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if s1[i] == s2[j]:\n                    m[i][j] = 1 + m[i - 1][j - 1]\n        return ''.join([s for s in m[-1]])\n\n\nif __name__ == '__main__':\n    assert Solution().longestCommonSubsequence('PAYPALISHIRING', 'PAYPALISHIRINGSHIRING') == 'PAHNAPLSIIGYIRSHING'",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def lcs(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        m = len(s1)\n        n = len(s2)\n        if m == 0 or n == 0:\n            return \"\"\n        if m == 1 or n == 1:\n            return s1 if m == 1 else s2 if n == 1 else \"\"\n        res = []\n        for i in range(m):\n            lcs = self.lcs(s1[i+1:], s2)\n            if lcs:\n                res.append(lcs)\n        return \"\".join(res)\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.lcs(\"abcd\", \"abc\") == \"abc\"\n    assert solution.lcs(\"abcd\", \"abcde\") == \"abcde\"\n    assert solution.lcs(\"abcd\", \"abce\") == \"abce\"\n    assert solution.lcs(\"abcd\", \"abdce\") == \"\"\n    assert solution.lcs(\"abcd\", \"\") == \"\"\n    assert solution.lcs(\"abcd\", \"abcd\") == \"abcd\"\n    assert solution.lcs(\"abcd\", \"a\") == \"a\"\n    assert solution.lcs(\"abcd\", \"abcdcd\") == \"abcd\"",
    "class Solution:\n    # @return a string\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if len(str1) < len(str2):\n            return self.longestCommonSubsequence(str2, str1)\n        else:\n            lcs = []\n            for i in range(len(str1)):\n                for j in range(len(str2)):\n                    if str1[i] == str2[j]:\n                        if len(lcs) == 0 or len(lcs[-1]) < j - i:\n                            lcs.append(str2[j:])\n                        else:\n                            lcs[-1] = lcs[-1][:j - i] + str2[j:]\n            return ''.join(lcs)",
    "def longest_common_subsequence(seq1, seq2):\n    if len(seq1) < len(seq2):\n        return longest_common_subsequence(seq2, seq1)\n\n    dp = [[0] * (len(seq2) + 1) for i in range(len(seq1) + 1)]\n\n    for i in range(1, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n    return dp[-1][-1]\n\n\nclass Solution:\n    def longestCommonSubsequence(self, seq1, seq2):\n        \"\"\"\n        :type seq1: str\n        :type seq2: str\n        :rtype: int\n        \"\"\"\n        m = len(seq1)\n        n = len(seq2)\n        dp = [[0] * (n + 1) for i in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n\n        for j in range(n + 1):\n            dp[0][j] = j\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if seq1[i - 1] == seq2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n        return dp[-1][-1]",
    "import collections\n\n# A sequence is a list of characters.\ndef longest_common_subsequence(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) == 0 or len(b) == 0:\n        return \"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = list(a)\n    b = list(b)\n    # The lengths of the two sequences.\n    m = len(a)\n    n = len(b)\n    # The maximum length of the subsequences.\n    max_length = 0\n    # The list of all possible subsequences.\n    result = []\n    # The list of all possible subsequences of length 1.\n    subsequence_length_1 = []\n    # The list of all possible subsequences of length 2.\n    subsequence_length_2 = []\n    # The list of all possible subsequences of length 3.\n    subsequence_length_3 = []\n    # The list of all possible subsequences of length 4.\n    subsequence_length_4 = []\n    # The list of all possible subsequences of length 5.\n    subsequence_length_5 = []\n    # The list of all possible subsequences of length 6.\n    subsequence_length_6 = []\n    # The list of all possible subsequences of length 7.\n    subsequence_length_7 = []\n    # The list of all possible subsequences of length 8.\n    subsequence_length_8 = []\n    # The list of all possible subsequences of length 9.\n    subsequence_length_9 = []\n    # The list of all possible subsequences of length 10.\n    subsequence_length_10 = []\n    # The list of all possible subsequences of length 11.\n    subsequence_length_11 = []\n    # The list of all possible subsequences of length 12.\n    subsequence_length_12 = []\n    # The list of all possible subsequences of length 13.\n    subsequence_length_13 = []\n    # The list of all possible subsequences of length 14.\n    subsequence_length_14 = []\n    # The",
    "#\n# 1. The longest common subsequence is a subsequence of both sequences that is the longest possible subsequence of both sequences.\n#    We can think of the longest common subsequence as the longest subsequence of the longest common subsequence of the two sequences.\n#    If we have two sequences of length n and k, the longest common subsequence is a subsequence of length n that is the longest possible subsequence of length k.\n#\n#    We can find the longest common subsequence of two sequences by iterating from the start of the first sequence to the end of the second sequence,\n#    and checking whether there is a character in the first sequence that is the same as the character in the second sequence at each iteration.\n#\n#    The longest common subsequence is the longest subsequence of the longest common subsequence of the two sequences.\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abc\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"def\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcde\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcd\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abbc\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcd\" is \"abcd\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcdef\" is \"abcdef\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcde\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcde\" is \"abc\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcd\" is \"abcd\".\n#\n#    For example, the longest common subsequence of the two sequences \"abc\" and \"abcde\" is \"abcde\".\n#\n#    For example,",
    "import collections\n\ndef lcs(s1, s2):\n    \"\"\"\n    :type s1: str\n    :type s2: str\n    :rtype: str\n    \"\"\"\n    # dp[i][j] = the longest common subsequence ending at i and j\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(len(s1) + 1):\n        for j in range(len(s2) + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[len(s1)][len(s2)]\n\nprint(lcs('abcd', 'abcd'))\nprint(lcs('abcd', 'bcde'))\nprint(lcs('abcd', 'bdc'))",
    "import collections\n\ndef lcs(s1, s2):\n    \"\"\"\n    Given two strings, return the longest common subsequence.\n\n    For example,\n    lcs(\"flower\", \"lemon\") -> \"fl\"\n    lcs(\"dog\", \"racecar\") -> \"dog\"\n    lcs(\"flower\", \"lemon apples grape\") -> \"gappl\"\n    \"\"\"\n    m = [[0] * len(s2) for _ in range(len(s1))]\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            if s1[i] == s2[j]:\n                m[i][j] = m[i-1][j-1] + 1\n            elif m[i][j] < m[i-1][j]:\n                m[i][j] = m[i-1][j]\n    return \"\".join([chr(i) for i in m[-1]])\n\ndef lcs_iter(s1, s2):\n    \"\"\"\n    Given two strings, return the longest common subsequence.\n\n    For example,\n    lcs_iter(\"flower\", \"lemon\") -> [\"fl\", \"l\"]\n    lcs_iter(\"dog\", \"racecar\") -> [\"d\", \"r\"]\n    lcs_iter(\"flower\", \"lemon apples grape\") -> [\"gappl\", \"gapp\", \"lapp\", \"l\", \"l\"]\n    \"\"\"\n    m = collections.defaultdict(list)\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            if s1[i] == s2[j]:\n                m[i].append(j)\n            elif m[i]:\n                m[i].append(m[i][0])\n    return list(map(lambda x: \"\".join(x), m.values()))\n\nif __name__ == \"__main__\":\n    print(lcs(\"dog\", \"racecar\"))\n    print(lcs(\"dog\", \"racecar\"))\n    print(lcs(\"dog\", \"racecar\"))\n    print(lcs_iter(\"dog\", \"racecar",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        m = len(s)\n        n = len(t)\n        # Initialize the result array\n        result = [0] * (m + n)\n        # Initialize the index array\n        index = [-1] * (m + n)\n        # Initialize the visited array\n        visited = [False] * (m + n)\n        # Initialize the length of the current longest subsequence\n        curr_length = 0\n        # Start the recursive algorithm\n        self.dfs(s, t, index, visited, result, curr_length)\n        return ''.join(result)\n\n    def dfs(self, s, t, index, visited, result, curr_length):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type index: list[int]\n        :type visited: list[bool]\n        :type result: list[int]\n        :type curr_length: int\n        \"\"\"\n        # If the current length is greater than the max length of the longest common subsequence,\n        # then return the longest common subsequence\n        if curr_length > len(result):\n            return\n        # If the current length is equal to the max length of the longest common subsequence,\n        # then we need to compare the two subsequences\n        if curr_length == len(result):\n            # If the current subsequence is equal to the given subsequence,\n            # then we need to compare the two subsequences and update the result\n            if s == t:\n                # Update the result array\n                for i in range(curr_length):\n                    result[i] = index[i]\n                # Update the visited array\n                for i in range(curr_length):\n                    visited[index[i]] = True\n                # Update the current length\n                curr_length += 1\n            # Otherwise, we just need to compare the two subsequences",
    "import collections\nimport sys\n\nclass Solution(object):\n    def lcs(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        s1 = s1.split(' ')\n        s2 = s2.split(' ')\n        lcs = collections.deque()\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if s1[i] == s2[j]:\n                    lcs.append((s1[i], s2[j]))\n        lcs.append((s1[-1], s2[-1]))\n        return''.join(lcs)\n\n    def lcs2(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        m = len(s1)\n        n = len(s2)\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        dp[0][0] = 1\n        for i in range(1, m+1):\n            dp[i][0] = 1\n        for j in range(1, n+1):\n            dp[0][j] = 1\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if s1[i-1] == s2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return''.join([str(i) for i in dp[m][n]])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.lcs2('a', 'b')\n    print s.lcs2('a', 'a')\n    print s.lcs2('ab', 'abc')",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if len(str1) == 0:\n            return str2\n        if len(str2) == 0:\n            return str1\n\n        lcs_table = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]\n        for i in range(1, len(str1) + 1):\n            for j in range(1, len(str2) + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    lcs_table[i][j] = lcs_table[i - 1][j - 1] + 1\n                else:\n                    lcs_table[i][j] = max(\n                        lcs_table[i - 1][j],\n                        lcs_table[i][j - 1]\n                    )\n        return ''.join(str(lcs_table[len(str1)][len(str2)]))\n\n\nif __name__ == '__main__':\n    print Solution().longestCommonSubsequence('abc', 'bcd')",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = []\n\n    def lcs(self, s, t):\n        \"\"\"\n        :param s: str\n        :param t: str\n        :return: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return \"\"\n        if s[0] == t[0]:\n            return s[0] + self.lcs(s[1:], t[1:])\n        else:\n            return self.lcs(s[1:], t)\n\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :param s: str\n        :param t: str\n        :return: str\n        \"\"\"\n        self.ans = []\n        self.lcs(s, t)\n        return ''.join(self.ans)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.lcs(\"abc\", \"cba\")\n    print s.ans",
    "# Write a function to find the longest common subsequence for the given two sequences.\n#\n# A subsequence of a sequence is a list of all the characters in the original sequence\n# that are located at a distance of 1 from the end of the original sequence.\n#\n# For example, the longest common subsequence of \"ABC\" and \"ACB\" is \"ABC\".\n#\n# The longest common subsequence of \"ABC\" and \"ACB\" is \"ABC\".\n#\n# The longest common subsequence of \"ABC\" and \"ABC\" is \"ABC\".\n#\n# Given two strings, s1 and s2, determine the length of the longest common subsequence.\n#\n# s1 and s2 are both non-empty strings.\n#\n# Example 1:\n#\n# Input: s1 = \"AB\", s2 = \"CBA\"\n# Output: 3\n# Explanation:\n# The longest common subsequence is \"ABC\"\n# Example 2:\n#\n# Input: s1 = \"ABC\", s2 = \"BAC\"\n# Output: 3\n# Explanation:\n# The longest common subsequence is \"ABC\"\n# Example 3:\n#\n# Input: s1 = \"ABC\", s2 = \"ABC\"\n# Output: 1\n# Explanation:\n# The longest common subsequence is \"ABC\"\n#\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        if len(s1) == 0 or len(s2) == 0:\n            return 0\n        dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j -",
    "#!/usr/bin/env python\n\nfrom itertools import combinations\n\ndef lcs(s, t):\n    \"\"\"\n    :param s: str\n    :param t: str\n    :return: str\n    \"\"\"\n    if len(s) < len(t):\n        return lcs(t, s)\n    if len(s) == 0:\n        return t\n    if len(t) == 0:\n        return s\n    if s[0]!= t[0]:\n        return lcs(t, s[1:])\n    return lcs(s[1:], t[1:])\n\ndef main():\n    s = 'ABCDEFG'\n    t = 'ABABEG'\n    print lcs(s, t)\n\nif __name__ == '__main__':\n    main()",
    "# https://leetcode.com/problems/longest-common-subsequence/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, first, second):\n        \"\"\"\n        :type first: str\n        :type second: str\n        :rtype: int\n        \"\"\"\n        first_len = len(first)\n        second_len = len(second)\n        max_len = 0\n        first_index = 0\n        second_index = 0\n        while first_index < first_len and second_index < second_len:\n            if first[first_index] == second[second_index]:\n                max_len = max(max_len, first_index + second_index + 1)\n                first_index += 1\n                second_index += 1\n            elif first[first_index] < second[second_index]:\n                first_index += 1\n            else:\n                second_index += 1\n        return max_len",
    "class Solution:\n    # @param s, a string\n    # @param t, a string\n    # @return a list of lists of string\n    def longestCommonSubsequence(self, s, t):\n        if len(s) == 0 or len(t) == 0:\n            return []\n\n        # find the max of s and t\n        maxLen = min(len(s), len(t))\n        # maxLen = max(len(s), len(t))\n\n        # initialize the result\n        result = [[0] * maxLen for _ in range(len(s))]\n\n        # fill the result\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    result[i][j] = 1 + result[i-1][j-1]\n\n        # return the longest common subsequence\n        return result\n\n\nif __name__ == \"__main__\":\n    print Solution().longestCommonSubsequence(\"abcd\", \"dcba\")",
    "def lcs(a, b):\n    \"\"\"\n    >>> lcs('abc', 'cba')\n    'abc'\n    >>> lcs('abc', 'abcd')\n    'abcd'\n    >>> lcs('abc', 'acbd')\n    'abc'\n    >>> lcs('abc', 'bacd')\n    'abc'\n    >>> lcs('abc', 'bac')\n    'bac'\n    >>> lcs('abc', 'b')\n    'b'\n    >>> lcs('abc', '')\n    ''\n    >>> lcs('', 'abc')\n    ''\n    \"\"\"\n    if len(a) == 0 or len(b) == 0:\n        return ''\n    lcs = ''\n    for i in range(len(a)):\n        for j in range(len(b)):\n            if a[i] == b[j]:\n                if len(lcs) < i + j + 1:\n                    lcs = a[i:j+1]\n    return lcs\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# @include\ndef longest_common_subsequence(a, b):\n    # Find longest common subsequence for a and b.\n    # If no common subsequence is found, return 0.\n    def get_subsequence(a, b):\n        # Find the first index of a in b.\n        start_index = -1\n        for i, c in enumerate(b):\n            if c == a:\n                start_index = i\n                break\n        if start_index == -1:\n            return 0\n        # Find the first index of a in b after start_index.\n        end_index = -1\n        for i, c in enumerate(b[start_index + 1:]):\n            if c == a:\n                end_index = i\n                break\n        # Find the subsequence b[start_index:end_index].\n        return b[start_index:end_index]\n\n    # Find the longest common subsequence for a and b.\n    return max(get_subsequence(a[0], b[0]), get_subsequence(a[1], b[1])) + 1\n# @exclude\n\n\ndef main():\n    a = \"abc\"\n    b = \"acb\"\n    assert longest_common_subsequence(a, b) == 2\n    a = \"a\"\n    b = \"a\"\n    assert longest_common_subsequence(a, b) == 1\n\n\nif __name__ == \"__main__\":\n    main()",
    "# https://oj.leetcode.com/problems/longest-common-subsequence/\n# Given two strings s and t, find the longest common subsequence of s and t.\n# A common subsequence of a string is a subsequence of that string where all the elements appear somewhere in the subsequence, and the order of elements doesn't matter.\n# The longest common subsequence of a and b is the longest subsequence of a that is a subsequence of b.\n# If there is no common subsequence, return an empty string \"\".\n#\n# Example 1:\n# Input: s = \"abc\", t = \"adb\"\n# Output: \"ad\"\n# Example 2:\n# Input: s = \"abc\", t = \"dbc\"\n# Output: \"\"\n# Example 3:\n# Input: s = \"abc\", t = \"cdc\"\n# Output: \"c\"\n# Note:\n# s and t both have length at most 50,000.\n# s and t both consist of only lowercase English letters.\n# All the inputs are guaranteed to be unique strings.\n#\n\n# 2017.05.18\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # t = s[0:len(t)]\n        # t = t[0:len(t)-1]\n        # t = t[0:len(t)-1]\n        # t = t[1:len(t)]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        # t = t[1:len(t)-1]\n        #",
    "# -*- coding:utf-8 -*-\n\nclass Solution:\n    # @param {string[]} strs\n    # @param {string} str1\n    # @param {string} str2\n    # @return {string}\n    def longestCommonSubsequence(self, strs, str1, str2):\n        n1, n2 = len(str1), len(str2)\n        if n1 == 0 or n2 == 0:\n            return ''\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            dp[i][0] = i\n        for j in range(1, n2 + 1):\n            dp[0][j] = j\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ''.join(map(str, dp[n1][n2]))\n\n    def longestCommonSubsequence_2(self, strs, str1, str2):\n        \"\"\"\n        :type strs: List[str]\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        # Solution 1:\n        # dp = [[0] * (len(str2) + 1) for _ in range(len(strs) + 1)]\n        # dp[0][0] = 0\n        # for i in range(1, len(strs) + 1):\n        #     dp[i][0] = i\n        # for j in range(1, len(str2) + 1):\n        #     dp[0][j] = j\n        # for i in range(1, len(strs) + 1):\n        #     for j in range(1, len(str2) + 1):",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def longestCommonSubsequence(self, root, p, q):\n        if root is None:\n            return None\n\n        if root.val == p.val or root.val == q.val:\n            return root\n        if root.val < p.val or root.val < q.val:\n            return self.longestCommonSubsequence(root.right, p, q)\n        else:\n            return self.longestCommonSubsequence(root.left, p, q)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(5)), TreeNode(4, TreeNode(5), TreeNode(6)))\n    p = TreeNode(1, TreeNode(2), TreeNode(3))\n    q = TreeNode(1, TreeNode(2), TreeNode(3))\n    print(s.longestCommonSubsequence(root, p, q))",
    "class Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        if s1 == '' or s2 == '':\n            return ''\n        m = [[0] * len(s2) for i in range(len(s1))]\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if s1[i] == s2[j]:\n                    m[i][j] = m[i-1][j-1] + 1\n        return ''.join(str(i) for i in m[-1])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestCommonSubsequence('abc', 'cba')\n    print s.longestCommonSubsequence('abcd', 'cde')\n    print s.longestCommonSubsequence('abc', 'bac')\n    print s.longestCommonSubsequence('a', 'a')",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        if len(s) == 0 or len(t) == 0:\n            return \"\"\n\n        m = len(s)\n        n = len(t)\n        dp = [[0] * n for i in range(m)]\n        ans = \"\"\n\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n        for i in range(m):\n            for j in range(n):\n                ans += str(dp[i][j])\n\n        return ans\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestCommonSubsequence(\"hello\", \"ll\"))\n    print(sol.longestCommonSubsequence(\"hello\", \"hello\"))\n    print(sol.longestCommonSubsequence(\"hello\", \"h\"))",
    "class Solution:\n    # @param a, a string\n    # @param b, a string\n    # @return a list of strings\n    def longestCommonSubsequence(self, a, b):\n        if a == \"\" or b == \"\":\n            return []\n        if a == b:\n            return [a]\n        if len(a) < len(b):\n            return self.longestCommonSubsequence(b, a)\n        if len(b) < len(a):\n            return self.longestCommonSubsequence(a, b)\n        result = []\n        i = 0\n        j = 0\n        while i < len(a) and j < len(b):\n            if a[i] == b[j]:\n                result.append(a[i])\n                i += 1\n                j += 1\n            elif a[i] < b[j]:\n                i += 1\n            else:\n                j += 1\n        return result\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    b = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = solution.longestCommonSubsequence(a, b)\n    print(result)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        # if s1 == s2, return s1\n        if len(s1) == 0 or len(s2) == 0:\n            return \"\"\n\n        # dp[i] is the max length of LCS of s1[:i] and s2[:i]\n        dp = [0] * (len(s2) + 1)\n        for i in range(len(s1)):\n            for j in range(len(s2) + 1):\n                if j == 0 or s1[i] == s2[j - 1]:\n                    dp[j] = max(dp[j], dp[j - 1] + 1)\n        return s1[:dp[-1]]\n\n\nif __name__ == \"__main__\":\n    s1 = \"aaab\"\n    s2 = \"aad\"\n    print Solution().longestCommonSubsequence(s1, s2)",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport time\nimport sys\n\n\nclass Solution(object):\n    def __init__(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        \"\"\"\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.max_len = 0\n        self.max_idx = 0\n        self.max_len_cache = []\n\n    def get_max_len(self):\n        return self.max_len\n\n    def get_max_idx(self):\n        return self.max_idx\n\n    def get_max_len_cache(self):\n        return self.max_len_cache\n\n    def get_max_len_cache_len(self):\n        return len(self.max_len_cache)\n\n    def get_max_idx_cache_len(self):\n        return len(self.max_idx_cache)\n\n    def get_max_len_cache_idx(self):\n        return self.max_len_cache[-1]\n\n    def get_max_idx_cache_idx(self):\n        return self.max_idx_cache[-1]\n\n    def get_max_len_cache_num(self):\n        return self.max_len_cache[-1]\n\n    def get_max_idx_cache_num(self):\n        return self.max_idx_cache[-1]\n\n    def get_max_len_cache_idx_num(self):\n        return self.max_len_cache[-1]\n\n    def get_max_idx_cache_idx_num(self):\n        return self.max_idx_cache[-1]\n\n    def get_max_len_cache_idx_num_idx(self):\n        return self.max_len_cache[-1]\n\n    def get_max_idx_cache_idx_num_idx(self):\n        return self.max_idx_cache",
    "import math\nimport collections\n\ndef lcs(s1, s2):\n    \"\"\"\n    Write a function to find the longest common subsequence for the given two sequences.\n\n    Input\n        s1: string\n        s2: string\n\n    Output\n        The length of the longest common subsequence.\n\n    Example\n        >>> lcs(\"abcd\", \"bcd\")\n        3\n        >>> lcs(\"abcd\", \"cd\")\n        3\n        >>> lcs(\"abcd\", \"ab\")\n        0\n        >>> lcs(\"abc\", \"c\")\n        2\n        >>> lcs(\"abcd\", \"bc\")\n        2\n        >>> lcs(\"abcd\", \"cd\")\n        2\n        >>> lcs(\"abcd\", \"ab\")\n        0\n        >>> lcs(\"abc\", \"c\")\n        1\n        >>> lcs(\"abcd\", \"cd\")\n        1\n        >>> lcs(\"abcd\", \"ab\")\n        0\n        >>> lcs(\"abc\", \"c\")\n        0\n    \"\"\"\n    if len(s1) == 0 or len(s2) == 0:\n        return 0\n\n    if len(s1) == 1 or len(s2) == 1:\n        return 1\n\n    if s1[0]!= s2[0]:\n        return 0\n\n    if s1[0] == s2[0]:\n        return 1\n\n    return max(lcs(s1[1:], s2[1:]), lcs(s1[1:], s2[:len(s2) - 1])) + 1\n\nif __name__ == '__main__':\n    s1 = \"abc\"\n    s2 = \"c\"\n\n    print(\"The length of the longest common subsequence is: {}\".format(lcs(s1, s2)))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param A a list of integer\n    # @param B a list of integer\n    # @return a list of integer\n    def longestCommonSubsequence(self, A, B):\n        # Write your code here\n        if len(A) == 0:\n            return B\n        elif len(B) == 0:\n            return A\n        if len(A) == 1:\n            return B[0]\n        if len(B) == 1:\n            return A[0]\n        if A[0] > B[0]:\n            return self.longestCommonSubsequence(B, A)\n        if A[0] < B[0]:\n            return self.longestCommonSubsequence(A, B)\n        if A[1] > B[1]:\n            return self.longestCommonSubsequence(B, A)\n        if A[1] < B[1]:\n            return self.longestCommonSubsequence(A, B)\n        return max(self.longestCommonSubsequence(A[1:], B[1:]), self.longestCommonSubsequence(A[1:], B))\n\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return 0\n        if len(A) == 1 or len(B) == 1:\n            return max(A[0], B[0])\n        if A[0] > B[0]:\n            return self.longestCommonSubsequence(B, A)\n        if A[0] < B[0]:\n            return self.longestCommonSubsequence(A, B)\n        if A[1] > B[1]:\n            return self.longestCommonSubsequence(B, A)\n        if A[1] < B[1]:\n            return self.longestCommonSubsequence(",
    "class Solution:\n    # @param A, a list of integers\n    # @param B, a list of integers\n    # @return an integer\n    def longestCommonSubsequence(self, A, B):\n        if len(A) == 0 or len(B) == 0:\n            return 0\n\n        if len(A) < len(B):\n            return self.longestCommonSubsequence(B, A)\n\n        m = [[0] * len(B) for _ in range(len(A))]\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    m[i][j] = m[i - 1][j - 1] + 1\n                else:\n                    m[i][j] = max(m[i - 1][j], m[i][j - 1])\n\n        return m[-1][-1]\n\n\nif __name__ == '__main__':\n    print(Solution().longestCommonSubsequence([\"aba\", \"xyz\", \"xyz\"], [\"xyz\", \"xyz\", \"abc\"]))",
    "class Solution:\n    # @param A, a list of integers\n    # @param B, a list of integers\n    # @return a list of integers\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [[0] * len(B) for _ in range(len(A) + 1)]\n        for i in range(1, len(A) + 1):\n            for j in range(1, len(B) + 1):\n                if A[i - 1] == B[j - 1]:\n                    result[i][j] = result[i - 1][j - 1] + 1\n                elif result[i - 1][j] > result[i][j - 1]:\n                    result[i][j] = result[i - 1][j]\n        return result[-1]",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        s1 = [0] * len(str1)\n        s2 = [0] * len(str2)\n        for i in range(len(str1)):\n            s1[i] = max(s1[i - 1], s2[i])\n            s1[i] = max(s1[i], str1[i])\n            s2[i] = max(s2[i - 1], str2[i])\n            s2[i] = max(s2[i], s1[i])\n        return \"\".join(str(s) for s in s1)",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return ''\n\n        d = defaultdict(int)\n        for i in range(len(s)):\n            d[s[i]] += 1\n\n        for i in range(len(t)):\n            d[t[i]] -= 1\n\n        result = ''\n        for i in range(len(s)):\n            if d[s[i]] > 0:\n                result += s[i]\n            if d[t[i]] > 0:\n                result += t[i]\n        return result\n\n\nif __name__ == '__main__':\n    print Solution().longestCommonSubsequence('abc', 'bca')",
    "# The longest common subsequence is a subsequence of the first sequence that is a subsequence of the second sequence.\n# If a subsequence is not a common subsequence of two sequences, then it is called a \"prohibited subsequence\".\n# The longest common subsequence of two sequences is the longest subsequence of the first sequence that is a subsequence of the second sequence.\n# If a subsequence is not a common subsequence of two sequences, then it is called a \"prohibited subsequence\".\n# Given two strings, s1 and s2, find the longest common subsequence of s1 and s2.\n#\n# Example 1:\n# Input: s1 = \"AAB\", s2 = \"ABA\"\n# Output: \"AAB\"\n# Explanation:\n# The longest common subsequence is \"AAB\".\n#\n# Example 2:\n# Input: s1 = \"ABA\", s2 = \"AAB\"\n# Output: \"ABA\"\n# Explanation:\n# The longest common subsequence is \"ABA\".\n#\n# Example 3:\n# Input: s1 = \"ABA\", s2 = \"BAA\"\n# Output: \"BAA\"\n# Explanation:\n# The longest common subsequence is \"BAA\".\n#\n# Note:\n# s1 and s2 will have length at most 100.\n# s1 and s2 will only contain lowercase letters.\n#\n# Companies\n# Facebook\n# Related Topics\n# BFS\n# Similar Questions\n# Longest Substring Without Repeating Characters\n#\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        if len(s1) == 0 or len(s2) == 0:\n            return \"\"\n\n        # if one string is empty, return the other\n        if len(s1) == 0:",
    "class Solution:\n    # @param a, a string\n    # @param b, a string\n    # @return a string\n    def longestCommonSubsequence(self, a, b):\n        if not a or not b: return \"\"\n        m, n = len(a), len(b)\n        maxlen = 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if a[i - 1] == b[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                maxlen = max(maxlen, dp[i][j])\n        return \"\".join(map(lambda x: str(x), dp[m][n]))\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestCommonSubsequence(\"abcd\", \"dcba\")\n    print s.longestCommonSubsequence(\"abc\", \"abc\")\n    print s.longestCommonSubsequence(\"abc\", \"dabc\")",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: str\n        \"\"\"\n        def dfs(root1, root2):\n            if not root1:\n                return ''\n            lcs = ''\n            if root1.val == root2.val:\n                lcs = lcs + str(root1.val)\n                dfs(root1.left, root2.left)\n                dfs(root1.right, root2.right)\n            else:\n                dfs(root1.left, root2)\n                dfs(root1.right, root2)\n            return lcs\n        return dfs(root1, root2)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if str1 == \"\" or str2 == \"\":\n            return \"\"\n        length1 = len(str1)\n        length2 = len(str2)\n        # initialize\n        dp = [[0] * (length2 + 1) for _ in range(length1 + 1)]\n        # for each element in str1, fill the corresponding cell in dp\n        for i in range(length1):\n            dp[i][0] = i\n        # for each element in str2, fill the corresponding cell in dp\n        for j in range(length2):\n            dp[0][j] = j\n        # for each element in str1, fill the corresponding cell in dp\n        for i in range(1, length1):\n            for j in range(1, length2):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return \"\".join(map(lambda x: str(x), dp[length1 - 1][length2 - 1]))",
    "__author__ = 'Danyang'\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        n1, n2 = len(s1), len(s2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return \"\".join(str(x) for x in dp[-1][-1:])\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestCommonSubsequence(\"ABCD\", \"DCBA\") == \"DCBA\"",
    "# https://leetcode.com/problems/longest-common-subsequence/discuss/180577/Java-O(n)-Time-Solution\n\nimport unittest\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        m = [[0 for x in range(len(s1) + 1)] for x in range(len(s2) + 1)]\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    m[i][j] = m[i - 1][j - 1] + 1\n                else:\n                    m[i][j] = max(m[i - 1][j], m[i][j - 1])\n        return ''.join([''.join(map(str, x)) for x in m[-1]])\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/longest-common-subsequence/solution/\n\n# 10:54 - 10:58\n# 1ms 100%\nclass Solution {\n    public String longestCommonSubsequence(String s1, String s2) {\n        if (s1.length() == 0 || s2.length() == 0) {\n            return \"\";\n        }\n        int[] m = new int[s2.length() + 1];\n        m[0] = 0;\n        for (int i = 1; i <= s2.length(); i++) {\n            for (int j = 1; j <= s1.length(); j++) {\n                if (s1.charAt(j - 1) == s2.charAt(i - 1)) {\n                    m[i] = Math.max(m[i], m",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        if not s1 or not s2:\n            return \"\"\n        if len(s1) < len(s2):\n            s1, s2 = s2, s1\n        res = []\n        for i in range(len(s1)):\n            if s1[i] == s2[0]:\n                res.append(s1[i:])\n                s1 = s1[i+1:]\n                s2 = s2[1:]\n            else:\n                break\n        if s1:\n            res.append(s1)\n        return ''.join(res)\n\ns = Solution()\nprint s.longestCommonSubsequence(\"abc\", \"adb\")",
    "# TLE\ndef longestCommonSubsequence(s1, s2):\n    n = len(s1)\n    m = len(s2)\n    if n == 0 or m == 0:\n        return []\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return dp[n][m]\n\n\nif __name__ == '__main__':\n    print(longestCommonSubsequence('abc', 'bca'))\n    print(longestCommonSubsequence('abcd', 'abcde'))",
    "# @author: Junaid P. Khandarpani\n# @since: September 2016\n# @date: 15/09/2016\n# @link: https://leetcode.com/problems/longest-common-subsequence/description/\n\nimport collections\nimport heapq\n\n# @return: a list of common subsequences\ndef find_lcs(seq1, seq2):\n    \"\"\"\n    :param seq1: a string\n    :param seq2: a string\n    :return: a list of common subsequences\n    \"\"\"\n    lcs = collections.defaultdict(list)\n    for i in range(len(seq1)):\n        for j in range(len(seq2)):\n            if seq1[i] == seq2[j]:\n                lcs[i+1].append(j+1)\n    return lcs\n\n# @return: a list of common subsequences\ndef find_lcs_recursive(seq1, seq2):\n    \"\"\"\n    :param seq1: a string\n    :param seq2: a string\n    :return: a list of common subsequences\n    \"\"\"\n    lcs = collections.defaultdict(list)\n    for i in range(len(seq1)):\n        for j in range(len(seq2)):\n            if seq1[i] == seq2[j]:\n                lcs[i+1].append(j+1)\n                if i!= 0:\n                    lcs[i+1].extend(lcs[i-1])\n    return lcs\n\n# @return: a list of common subsequences\ndef find_lcs_heap(seq1, seq2):\n    \"\"\"\n    :param seq1: a string\n    :param seq2: a string\n    :return: a list of common subsequences\n    \"\"\"\n    lcs = collections.defaultdict(list)\n    for i in range(len(seq1)):\n        for j in range(len(seq2)):\n            if seq1[i] == seq2[j]:\n                lcs[i+1].append(j+1)\n                heapq.heappush(lcs[i+1], (j+1, i+1",
    "class Solution:\n    # @param {string} s1\n    # @param {string} s2\n    # @return {string}\n    def longestCommonSubsequence(self, s1, s2):\n        if not s1 or not s2:\n            return ''\n        if len(s1) < len(s2):\n            return self.longestCommonSubsequence(s2, s1)\n        if len(s1) == len(s2):\n            return s1\n        if s1[-1] == s2[-1]:\n            return s1[:-1] + s2[:-1] + s1[-1]\n        s1_pos = [0]\n        s2_pos = [0]\n        s1_len = len(s1)\n        s2_len = len(s2)\n        result = ''\n        for i in range(s1_len):\n            for j in range(s2_len):\n                if s1[i] == s2[j]:\n                    if i == 0 or j == 0 or s1[i - 1]!= s2[j - 1]:\n                        s1_pos.append(i)\n                        s2_pos.append(j)\n                        result += s1[i]\n                    else:\n                        if len(s1_pos) > len(s2_pos):\n                            result += s1[i]\n                            s1_pos.pop()\n                        else:\n                            result += s2[j]\n                            s2_pos.pop()\n                else:\n                    break\n        return result\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestCommonSubsequence(\"a\", \"b\") == \"ab\"\n    assert Solution().longestCommonSubsequence(\"\", \"\") == ''\n    assert Solution().longestCommonSubsequence(\"a\", \"a\") == \"a\"\n    assert Solution().longestCommonSubsequence(\"a\", \"aa\") == \"aa\"\n    assert Solution().longestCommonSubsequence(\"aaa\", \"aaaa\") == \"aaaa\"",
    "def lcs(seq1, seq2):\n\tm = [[0 for j in range(len(seq2)+1)] for i in range(len(seq1)+1)]\n\n\tfor i in range(len(seq1)+1):\n\t\tfor j in range(len(seq2)+1):\n\t\t\tif seq1[i] == seq2[j]:\n\t\t\t\tm[i][j] = 1\n\t\t\telif m[i-1][j] > 0:\n\t\t\t\tm[i][j] = m[i-1][j] + 1\n\t\t\telse:\n\t\t\t\tm[i][j] = 0\n\n\treturn m[len(seq1)][len(seq2)]\n\nif __name__ == '__main__':\n\tseq1 = \"ABCD\"\n\tseq2 = \"BCDE\"\n\n\tprint lcs(seq1, seq2)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        # This is a recursive solution.\n        # The problem is that we can't use the same node twice in the same level.\n        # So we use a stack to store all nodes.\n        # And the output is the length of the longest common subsequence.\n        # We can use the stack to record the length of the longest common subsequence\n        # for the current node and the node to the left and the node to the right.\n        # This algorithm can be improved to O(n*m) time and space.\n        # We can also use the two pointers to record the start and end position of the longest common subsequence.\n        # The problem is that we can't use the stack to record the length of the longest common subsequence\n        # for the current node and the node to the left and the node to the right.\n        # So we use a dynamic programming solution to solve this problem.\n        # The problem is that the length of the longest common subsequence is\n        # the sum of the length of the longest common subsequence of the left and the right\n        # nodes.\n        # The problem is that we can't use the stack to record the length of the longest common subsequence\n        # for the current node and the node to the left and the node to the right.\n        # So we use a dynamic programming solution to solve this problem.\n        # The problem is that the length of the longest common subsequence is\n        # the sum of the length of the longest common subsequence of the left and the right\n        # nodes.\n        # The problem is that we can't use the stack to record the length of the longest common subsequence\n        # for the current node and the node to the left and the node to the right.\n        # So we use a dynamic programming solution to solve this problem.\n        # The problem is that the length of the longest common subsequence is",
    "# https://www.hackerrank.com/challenges/longest-common-subsequence/problem\n\ndef find_longest_common_subsequence(s1, s2):\n    if not s1 or not s2:\n        return 0\n\n    # Build the table of all possible substrings\n    table = [0] * (len(s1) + 1)\n    for i in range(len(s1) + 1):\n        table[i] = [0] * (len(s2) + 1)\n        for j in range(len(s2) + 1):\n            table[i][j] = table[i - 1][j] + 1 if s1[i - 1] == s2[j - 1] else 0\n\n    # Find the maximum of the table\n    max_len = 0\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if table[i][j] > max_len:\n                max_len = table[i][j]\n    return max_len\n\n\n# Test Cases\ns1 = \"PAYPALISHIRING\"\ns2 = \"HIPPO\"\nprint(find_longest_common_subsequence(s1, s2))\n\ns1 = \"PAYPALISHIRING\"\ns2 = \"HIPPO\"\nprint(find_longest_common_subsequence(s1, s2))\n\ns1 = \"A\"\ns2 = \"A\"\nprint(find_longest_common_subsequence(s1, s2))\n\ns1 = \"PAYPALISHIRING\"\ns2 = \"PAYPALISHIRING\"\nprint(find_longest_common_subsequence(s1, s2))\n\ns1 = \"A\"\ns2 = \"A\"\nprint(find_longest_common_subsequence(s1, s2))",
    "# https://leetcode.com/problems/longest-common-subsequence/discuss/2914/C%2B%2B-solution-using-a-bst-with-o(n)\n# The solution is O(n*log(n))\n# Time: O(n^2)\n# Space: O(n)\n\n# DP solution\n# Time: O(n^2)\n# Space: O(n)\nclass Solution(object):\n    def lcs(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        if not str1:\n            return str2\n        if not str2:\n            return str1\n        max_len = max(len(str1), len(str2))\n        dp = [[0] * (max_len + 1) for _ in range(len(str1) + 1)]\n        for i in range(1, len(str1) + 1):\n            dp[i][0] = 0\n        for j in range(1, len(str2) + 1):\n            dp[0][j] = 0\n        for i in range(1, len(str1) + 1):\n            for j in range(1, len(str2) + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ''.join([str(i) for i in dp[-1]])",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        two pointers\n\n        :param s: str\n        :param t: str\n        :return: str\n        \"\"\"\n        m, n = len(s), len(t)\n        if m == 0 or n == 0:\n            return \"\"\n        if m == 1 or n == 1:\n            return max(s, t)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n        return \"\".join(map(lambda x: str(x), dp[m][n]))\n\n\nif __name__ == \"__main__\":\n    s = \"abc\"\n    t = \"bca\"\n    print Solution().longestCommonSubsequence(s, t)",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        # dp[i][j] is the longest common subsequence ending at i and j\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]",
    "import unittest\nfrom common_substring import lcs\n\nclass TestLongestCommonSubsequence(unittest.TestCase):\n    def test_lcs(self):\n        self.assertEqual(lcs('abc', 'abc'), 3)\n        self.assertEqual(lcs('abc', 'bac'), 2)\n        self.assertEqual(lcs('abc', 'acb'), 2)\n        self.assertEqual(lcs('abc', 'xbc'), 1)\n        self.assertEqual(lcs('abc', 'xabc'), 1)\n        self.assertEqual(lcs('abc', 'abx'), 1)\n        self.assertEqual(lcs('abc', 'xab'), 1)\n        self.assertEqual(lcs('abc', 'axbc'), 1)\n        self.assertEqual(lcs('abc', 'axb'), 2)\n        self.assertEqual(lcs('abc', 'xab'), 2)\n        self.assertEqual(lcs('abc', 'xabc'), 2)\n        self.assertEqual(lcs('abc', 'abx'), 2)\n        self.assertEqual(lcs('abc', 'xab'), 2)\n        self.assertEqual(lcs('abc', 'xabc'), 2)\n        self.assertEqual(lcs('abc', 'abc'), 3)\n        self.assertEqual(lcs('abc', 'acb'), 2)\n        self.assertEqual(lcs('abc', 'axb'), 2)\n        self.assertEqual(lcs('abc', 'abx'), 1)\n        self.assertEqual(lcs('abc', 'xab'), 1)\n        self.assertEqual(lcs('abc', 'xabc'), 1)\n        self.assertEqual(lcs('abc', 'abx'), 2)\n        self.assertEqual(lcs('abc', 'xab'), 2)\n        self.assertEqual(lcs('abc', 'xabc'), 2)\n\nif __name__ == '__main__':\n    unittest.main()",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lcs(self, A, B):\n        \"\"\"\n        :param A: list\n        :param B: list\n        :return: list\n        \"\"\"\n        lens = [[0 for _ in range(len(B)+1)] for _ in range(len(A)+1)]\n\n        for i in range(len(A)):\n            lens[i][0] = 1\n            for j in range(1, len(B)+1):\n                lens[i][j] = max(lens[i][j-1], lens[i-A[i-1]][j-1])\n\n        for i in range(len(B)):\n            lens[-1][i] = 1\n            for j in range(1, len(A)+1):\n                lens[-1][i] = max(lens[-1][i], lens[-1][i-B[i-1]])\n\n        return lens[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().lcs(['aba', 'xyz'], ['xyz', 'abc', 'xzy']) == 3\n\n    assert Solution().lcs(['abcd', 'xyz'], ['xyz', 'abc', 'xzy']) == 3",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        if len(s) == 0:\n            return t\n        if len(t) == 0:\n            return s\n\n        m = [[0] * len(t) for _ in range(len(s))]\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    m[i][j] = 1 + m[i-1][j-1]\n        return \"\".join([\"\" for _ in range(len(s) + len(t))])\n\n\nif __name__ == \"__main__\":\n    print Solution().longestCommonSubsequence(\"a\", \"b\")",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        m = len(str1)\n        n = len(str2)\n        dp = [[0 for i in xrange(n+1)] for j in xrange(m+1)]\n        for i in xrange(1, m+1):\n            for j in xrange(1, n+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[m][n]",
    "#!/usr/bin/env python\n\nimport sys\n\ndef get_longest_common_subsequence(sequence1, sequence2):\n    if sequence1 is None or sequence2 is None:\n        return \"\"\n    if len(sequence1) == 0 or len(sequence2) == 0:\n        return \"\"\n    if len(sequence1) == 1 or len(sequence2) == 1:\n        return sequence1[0]\n    result = \"\"\n    for i in range(0, len(sequence1)):\n        for j in range(0, len(sequence2)):\n            if sequence1[i] == sequence2[j]:\n                if i == 0 or j == 0:\n                    result += sequence1[i]\n                else:\n                    result += sequence1[i] + sequence2[j]\n    return result\n\ndef get_longest_common_subsequence_recursion(sequence1, sequence2):\n    if sequence1 is None or sequence2 is None:\n        return \"\"\n    if len(sequence1) == 0 or len(sequence2) == 0:\n        return \"\"\n    if len(sequence1) == 1 or len(sequence2) == 1:\n        return sequence1[0]\n    result = \"\"\n    for i in range(0, len(sequence1)):\n        for j in range(0, len(sequence2)):\n            if sequence1[i] == sequence2[j]:\n                if i == 0 or j == 0:\n                    result += sequence1[i]\n                else:\n                    result += sequence1[i] + sequence2[j]\n                    result = get_longest_common_subsequence_recursion(sequence1[i+1:], sequence2[j+1:])\n    return result\n\ndef test():\n    assert get_longest_common_subsequence(\"abc\", \"abc\") == \"abc\"\n    assert get_longest_common_subsequence(\"abc\", \"def\") == \"abc\"\n    assert get_longest_common_subsequence(\"abc\", \"xyz\") == \"\"\n    assert get_longest_common_subsequence_recursion(\"abc\", \"abc\") == \"abc\"\n    assert get_longest_common_subsequence",
    "# The longest common subsequence of a string S and a string T is the longest subsequence of S\n# that is also a subsequence of T, i.e. the longest common subsequence of all the substrings of S\n# that are also subsequences of T.\n#\n# The longest common subsequence of a string S and an empty string is the empty string.\n#\n# The longest common subsequence of an empty string and a string T is the empty string.\n#\n# For example,\n#\n# s = \"abc\", t = \"bcd\"\n#\n# The longest common subsequence of s and t is \"bc\".\n#\n# s = \"abc\", t = \"\"\n#\n# The longest common subsequence of s and t is \"\".\n#\n# s = \"\", t = \"abc\"\n#\n# The longest common subsequence of s and t is \"\".\n#\n# Given two strings s and t of equal length, return the longest common subsequence.\n#\n# Note:\n#\n# The length of s and t is in the range [1, 10000].\n# The length of s and t is in the range [1, 200].\n# s and t do not contain the character '\\n'.\n#\n# Example 1:\n#\n# Input:\n# s = \"abc\", t = \"bcd\"\n#\n# Output:\n# \"bc\"\n# Example 2:\n#\n# Input:\n# s = \"abc\", t = \"\"\n#\n# Output:\n# \"\"\n# Example 3:\n#\n# Input:\n# s = \"\", t = \"abc\"\n#\n# Output:\n# \"\"\n# Example 4:\n#\n# Input:\n# s = \"\", t = \"\"\n#\n# Output:\n# \"\"\n\n# Time:  O(m * n)\n# Space: O(m + n)\n#\n# Iterative\n#\n#    1. find longest common substring of s and t\n#    2. compare the longest common substring to the beginning of t\n#    3. if the longest common substring is a substring of t, return it\n#\n# Dynamic\n#\n#    1. find longest common substring of s and t\n#    2. compare the longest",
    "#!/usr/bin/python\n\nclass Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: int\n        \"\"\"\n        # http://www.cnblogs.com/grandyang/p/4499961.html\n        m1, m2 = 0, 0\n        for i in range(len(str1)):\n            if str1[i]!= str2[i]:\n                m1 = max(m1, 1)\n            else:\n                m2 = max(m2, 1)\n        return max(m1, m2)\n\nif __name__ == \"__main__\":\n    print Solution().longestCommonSubsequence(\"abc\", \"cab\")",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {integer}\n    def longestCommonSubsequence(self, p, q):\n        if p is None:\n            return 0\n        if q is None:\n            return 1\n        if p.val < q.val:\n            return self.longestCommonSubsequence(q, p)\n        if p.val > q.val:\n            return self.longestCommonSubsequence(p, q)\n        if p.val == q.val:\n            return max(self.longestCommonSubsequence(p.left, q.left), self.longestCommonSubsequence(p.right, q.right)) + 1\n        return max(self.longestCommonSubsequence(p.left, q.left), self.longestCommonSubsequence(p.right, q.right))",
    "import collections\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if not s or not t:\n            return 0\n        if len(s) == 0 or len(t) == 0:\n            return 0\n\n        result = collections.defaultdict(int)\n        m = len(s)\n        n = len(t)\n\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    result[i, j] = result[i - 1, j - 1] + 1\n        return max(result.values())\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestCommonSubsequence('abcd', 'dcba')",
    "class Solution(object):\n    def findLCSS(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        n1 = len(s1)\n        n2 = len(s2)\n        if n1 == 0 or n2 == 0:\n            return \"\"\n        dp = [0] * (n1 + 1)\n        for i in range(n1):\n            dp[i] = i\n        for i in range(n2):\n            dp[0] = i\n            for j in range(1, n1):\n                if s1[i] == s2[j-1]:\n                    dp[j] = dp[j-1]\n                else:\n                    dp[j] = max(dp[j], dp[j-1])\n        return \"\".join(str(i) for i in dp)",
    "# Example 1:\n# Input:\n# s1 = \"abcd\", s2 = \"dcae\"\n# Output:\n# 2\n# Explanation:\n# The longest common subsequence is \"dca\", which is of length 2.\n# Example 2:\n# Input:\n# s1 = \"abcd\", s2 = \"dcbae\"\n# Output:\n# 3\n# Explanation:\n# The longest common subsequence is \"dcba\", which is of length 3.\n# Example 3:\n# Input:\n# s1 = \"a\", s2 = \"ab\"\n# Output:\n# 1\n# Explanation:\n# The longest common subsequence is \"\", which is of length 0.\n# Example 4:\n# Input:\n# s1 = \"\", s2 = \"\"\n# Output:\n# 0\n# Example 5:\n# Input:\n# s1 = \"\", s2 = \"a\"\n# Output:\n# 0\n# Example 6:\n# Input:\n# s1 = \"\", s2 = \"ab\"\n# Output:\n# 0\n# Example 7:\n# Input:\n# s1 = \"abc\", s2 = \"abcd\"\n# Output:\n# 0\n# Example 8:\n# Input:\n# s1 = \"abcd\", s2 = \"abc\"\n# Output:\n# 0\n# Note:\n# s1 and s2 will both have length 1 or N.\n# s1 and s2 will have length 1 or N but not both.\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        if not s1 or not s2:\n            return 0\n        if s1 == s2:\n            return len(s1)\n        if len(s1) == 0:\n            return 0\n        if len(s2) == 0:\n            return 0\n        if s1[0] == s2[0]:\n            return 1 + self.longestCommonSubsequence(s1[1:], s2[1:])\n        else:\n            return max(self.longest",
    "class Solution:\n    \"\"\"\n    @param A: A list of integers\n    @param B: A list of integers\n    @return: The length of the longest common subsequence\n    \"\"\"\n    def longestCommonSubsequence(self, A, B):\n        if len(A) < 1 or len(B) < 1:\n            return 0\n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        for i in range(1, len(A) + 1):\n            for j in range(1, len(B) + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]\n\nif __name__ == \"__main__\":\n    assert Solution().longestCommonSubsequence([1, 3, 2], [3, 2, 4, 1]) == 3\n    assert Solution().longestCommonSubsequence([1, 3, 2], [3, 2, 4, 1, 3]) == 5",
    "import sys\n\n# The following is the longest common subsequence.\ndef longest_common_subsequence(s1, s2):\n    if len(s1) == 0 or len(s2) == 0:\n        return \"\"\n\n    # The length of the longest common subsequence is the\n    # length of the shortest of the two.\n    lcs = min(len(s1), len(s2))\n\n    # The longest common subsequence is the longest common subsequence\n    # of the longest common subsequence.\n    return longest_common_subsequence(s1[:lcs], s2[:lcs]) + s1[:lcs] + s2[:lcs]\n\n\nif __name__ == \"__main__\":\n    # This is the first example.\n    s1 = \"abcd\"\n    s2 = \"abcde\"\n    assert(longest_common_subsequence(s1, s2) == \"cde\")\n\n    # This is the second example.\n    s1 = \"abcd\"\n    s2 = \"bcd\"\n    assert(longest_common_subsequence(s1, s2) == \"abcd\")\n\n    # This is the third example.\n    s1 = \"abcd\"\n    s2 = \"dcb\"\n    assert(longest_common_subsequence(s1, s2) == \"dcb\")\n\n    # This is the fourth example.\n    s1 = \"abcd\"\n    s2 = \"acd\"\n    assert(longest_common_subsequence(s1, s2) == \"acd\")\n\n    # This is the fifth example.\n    s1 = \"abcd\"\n    s2 = \"bcd\"\n    assert(longest_common_subsequence(s1, s2) == \"abcd\")\n\n    # This is the sixth example.\n    s1 = \"abcd\"\n    s2 = \"cde\"\n    assert(longest_common_subsequence(s1, s2) == \"abcd\")\n\n    # This is the seventh example.\n    s1 = \"abcd\"\n    s2 = \"cdea\"\n    assert(longest_common_subsequence(s1",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def longestCommonSubsequence(self, root, p, q):\n        if not root:\n            return []\n        if not p or not q:\n            return [root]\n        if root.val == p.val or root.val == q.val:\n            return [root]\n        if root.val < p.val or root.val < q.val:\n            return []\n        if root.val > p.val and root.val > q.val:\n            return []\n        res = []\n        if p.val > root.val:\n            res += self.longestCommonSubsequence(root.left, p, q)\n        if q.val > root.val:\n            res += self.longestCommonSubsequence(root.right, p, q)\n        if p.val == root.val:\n            res.append(root)\n        if q.val == root.val:\n            res.append(root)\n        return res\n\nif __name__ == '__main__':\n    print Solution().longestCommonSubsequence([1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5]).sort()",
    "# https://oj.leetcode.com/problems/longest-common-subsequence/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        if len(t) == 0:\n            return 0\n        if len(s) == 1:\n            return len(t)\n        if len(t) == 1:\n            return len(s)\n        if s[0] == t[0]:\n            return self.longestCommonSubsequence(s[1:], t[1:]) + 1\n        else:\n            return self.longestCommonSubsequence(s[1:], t) + 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestCommonSubsequence(\"pwwkew\", \"wkepow\")\n    print s.longestCommonSubsequence(\"pwwkew\", \"ewpow\")\n    print s.longestCommonSubsequence(\"pwwkew\", \"pwkew\")\n    print s.longestCommonSubsequence(\"pwwkew\", \"pwwkew\")\n    print s.longestCommonSubsequence(\"pwwkew\", \"ewpowew\")",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return \"\"\n\n        d = defaultdict(lambda: 0)\n        for i in range(len(s)):\n            d[s[i]] += 1\n        for j in range(len(t)):\n            d[t[j]] += 1\n\n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if d[s[i - 1]] == 0 or d[t[j - 1]] == 0:\n                    dp[i][j] = 0\n                elif d[s[i - 1]] < d[t[j - 1]]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return \"\".join(str(x) for x in dp[m][n])",
    "# A common subsequence is a subsequence that occurs in both sequences.\n# A longest common subsequence is a subsequence that occurs in both sequences and is longer than the longest common subsequence.\n\n# For example, if the two sequences are \"abcd\" and \"abc\", then the longest common subsequence is \"abc\",\n# and the longest common subsequence of \"abc\" and \"abc\" is \"abc\", so the longest common subsequence is \"abc\".\n\n# Given two strings s and t, return the longest common subsequence of s and t.\n\n# Note:\n# s and t have length at most 100.\n# s and t only contain lowercase letters.\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return \"\"\n        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        return \"\".join([chr(i + ord('a')) for i in range(m)])\n\nif __name__ == \"__main__\":\n    print Solution().longestCommonSubsequence(\"abcd\", \"abc\")\n    print Solution().longestCommonSubsequence(\"abcd\", \"bcd\")\n    print Solution().longestCommonSubsequence(\"abcd\", \"cd\")\n    print Solution().longestCommonSubsequence(\"abcd\", \"ac\")",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lcs(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return ''\n\n        # write your code here\n        d = {}\n        m, n = len(s), len(t)\n        for i in range(m + 1):\n            d[i] = {}\n            for j in range(n + 1):\n                d[i][j] = 0\n                if i == 0 or j == 0:\n                    d[i][j] = 0\n                elif s[i - 1] == t[j - 1]:\n                    d[i][j] = d[i - 1][j - 1] + 1\n                else:\n                    d[i][j] = max(d[i - 1][j], d[i][j - 1])\n\n        ret = ''\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    ret += s[i]\n                elif s[i - 1] == t[j - 1]:\n                    ret += s[i - 1]\n                else:\n                    ret += s[i - 1] + s[i]\n        return ret\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    s = f.readline()\n    t = f.readline()\n    # t = sys.stdin.readline()\n\n    result = solution.lcs(s, t)\n    # result = \"\"\n    print(result)\n    f.close()",
    "import collections\n\n\ndef lcs(seq1, seq2):\n    \"\"\"\n    :type seq1: List[str]\n    :type seq2: List[str]\n    :rtype: int\n    \"\"\"\n    dic = collections.defaultdict(list)\n    for s in seq1:\n        dic[s].append(0)\n    for s in seq2:\n        dic[s].append(0)\n    maxlen = 0\n    for s in seq1:\n        for i in range(len(s)):\n            dic[s[:i]].append(i)\n        for j in range(len(s)):\n            dic[s[i:]][j] = dic[s[:i]][j]\n        for i in range(len(s)):\n            for j in range(len(s)):\n                if dic[s[i:j+1]][j] > dic[s[i:j+1]][i]:\n                    dic[s[i:j+1]][j] = dic[s[i:j+1]][i]\n                    if dic[s[i:j+1]][j] > maxlen:\n                        maxlen = dic[s[i:j+1]][j]\n    return maxlen\n\n\nif __name__ == '__main__':\n    print(lcs(['a', 'b', 'c', 'd'], ['a', 'b', 'd', 'e']))\n    print(lcs(['a', 'b', 'c', 'd'], ['a', 'b', 'd', 'e', 'f']))\n    print(lcs(['a', 'b', 'c', 'd'], ['a', 'b', 'd', 'e', 'f', 'g']))\n    print(lcs(['a', 'b', 'c', 'd'], ['a', 'b', 'd', 'e', 'f', 'g', 'h']))",
    "__author__ = 'Daniel'\n\nclass Solution(object):\n    def findLongestCommonSubsequence(self, strs1, strs2):\n        \"\"\"\n        :type strs1: List[str]\n        :type strs2: List[str]\n        :rtype: int\n        \"\"\"\n        if len(strs1) < 1 or len(strs2) < 1:\n            return 0\n\n        # \u521d\u59cb\u5316\n        m = len(strs1)\n        n = len(strs2)\n        ans = 0\n        s1 = [0 for i in range(m + 1)]\n        s2 = [0 for i in range(n + 1)]\n\n        # \u5bf9\u7b2c\u4e00\u4e2a\u7ed3\u679c\u8fdb\u884c\u627e\n        for i in range(m):\n            if strs1[i] in strs2:\n                s1[i + 1] = s1[i] + 1\n                s2[i + 1] = s2[i] + 1\n                ans = max(ans, s1[i + 1])\n\n        # \u8ba1\u7b97\u5f53\u524d\u7684\u7ed3\u679c\n        for j in range(n):\n            if strs2[j] in strs1:\n                s1[j + 1] = s1[j] + 1\n                s2[j + 1] = s2[j] + 1\n                ans = max(ans, s1[j + 1])\n\n        # \u8ba1\u7b97\u5f53\u524d\u7684\u7ed3\u679c\n        for i in range(m):\n            for j in range(n):\n                if strs1[i] == strs2[j]:\n                    s1[i + 1] = s1[i] + 1\n                    s2[j + 1] = s2[j] + 1\n                    ans = max(ans, s1[i + 1])\n\n        return ans\n\nif __name__ == '__main__':\n    strs1 = ['abc', 'cde', 'dab']\n    strs2 = ['a', 'b', 'c']\n    sol = Solution()\n    print",
    "class Solution(object):\n    def longestCommonSubsequence(self, A, B):\n        \"\"\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: int\n        \"\"\"\n        # TODO:\n        # 1. write the algorithm\n        # 2. implement the solution\n        # 3. test the solution\n        # 4. write the test cases\n        # 5. write the test cases\n        # 6. write the test cases\n        return max(len(A), len(B))\n\n\nif __name__ == '__main__':\n    assert Solution().longestCommonSubsequence(['cat', 'hat'], ['hat', 'hat']) == 2\n    assert Solution().longestCommonSubsequence(['abc', 'def'], ['def', 'ghi']) == 2\n    assert Solution().longestCommonSubsequence(['abc', 'def'], ['def', 'def']) == 1",
    "import unittest\n\nclass Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: int\n        \"\"\"\n        length1 = len(str1)\n        length2 = len(str2)\n        dp = [[0 for j in range(length2 + 1)] for i in range(length1 + 1)]\n        for i in range(length1):\n            for j in range(length2):\n                if str1[i] == str2[j]:\n                    dp[i+1][j+1] = dp[i][j] + 1\n                else:\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])\n        return dp[length1][length2]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/longest-common-subsequence/solution/\n#\nApproach #1: Dynamic Programming [Accepted]\nComplexity Analysis\nTime Complexity: O(M + N) for each step of the algorithm\nSpace Complexity: O(M + N) for each step of the algorithm\n\n# 9ms 100%\nclass Solution {\n    public int longestCommonSubsequence(String str1, String str2) {\n        int m = str1.length();\n        int n = str2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(",
    "class Solution:\n    # @param A, a list of integers\n    # @param B, a list of integers\n    # @return an integer\n    def longestCommonSubsequence(self, A, B):\n        if not A or not B:\n            return 0\n        m = len(A)\n        n = len(B)\n        table = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            table[i][0] = i\n        for j in range(n + 1):\n            table[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    table[i][j] = table[i - 1][j - 1]\n                else:\n                    table[i][j] = max(table[i][j - 1], table[i - 1][j])\n        return table[m][n]\n\nif __name__ == '__main__':\n    A = [1, 2, 3]\n    B = [1, 2]\n    s = Solution()\n    print s.longestCommonSubsequence(A, B)",
    "# https://leetcode.com/problems/longest-common-subsequence/\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return 0\n\n        def dfs(s, t):\n            if len(s) == 0:\n                return 0\n            if len(t) == 0:\n                return len(s)\n            if t[0] == s[0]:\n                return 1 + dfs(s[1:], t[1:])\n            else:\n                return dfs(s[1:], t)\n\n        return dfs(s, t)",
    "from collections import Counter\nimport timeit\n\n\ndef lcs(a, b):\n    \"\"\"\n    a is a list of numbers\n    b is a list of numbers\n    return the length of the longest common subsequence\n    \"\"\"\n    # build a dictionary of the elements of a and b\n    a_dict = dict(zip(a, range(len(a))))\n    b_dict = dict(zip(b, range(len(b))))\n    # build a dictionary of the elements of a and b\n    # that are not in a or b\n    diff = set(a) - set(b)\n    # build a dictionary of the elements of a and b\n    # that are in a but not in b\n    common = set(a).intersection(b) - set(diff)\n    # build a dictionary of the elements of a and b\n    # that are in b but not in a\n    diff_b = set(b).difference(set(a))\n    # find the longest common subsequence\n    # of a and b\n    return max(len(list(x for x in common if x in a_dict)), len(list(x for x in common if x in b_dict)))\n\n\nif __name__ == '__main__':\n    start = timeit.default_timer()\n    print(lcs([1, 2, 3], [2, 3, 1]))\n    print(timeit.default_timer() - start)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if s == t:\n            return len(s)\n        ls = len(s)\n        lt = len(t)\n        dp = [[0] * (lt+1) for _ in range(ls+1)]\n        for i in range(ls+1):\n            for j in range(lt+1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[ls][lt]",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        m = len(str1)\n        n = len(str2)\n        dp = [[0 for i in range(m+1)] for j in range(n+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]",
    "class Solution(object):\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        m = len(str1)\n        n = len(str2)\n        if m == 0 or n == 0:\n            return \"\"\n\n        matrix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    matrix[i][j] = matrix[i - 1][j - 1] + 1\n                else:\n                    matrix[i][j] = max(matrix[i - 1][j], matrix[i][j - 1])\n\n        return \"\".join(chr(matrix[m][n]) for _ in range(m + n + 1))\n\nif __name__ == \"__main__\":\n    assert Solution().longestCommonSubsequence(\"ABC\", \"BCA\") == \"BC\"\n    assert Solution().longestCommonSubsequence(\"\", \"\") == \"\"\n    assert Solution().longestCommonSubsequence(\"\", \"ABC\") == \"\"\n    assert Solution().longestCommonSubsequence(\"ABC\", \"\") == \"\"\n    assert Solution().longestCommonSubsequence(\"\", \"ABC\") == \"\"\n    assert Solution().longestCommonSubsequence(\"ABC\", \"ABC\") == \"ABC\"\n    assert Solution().longestCommonSubsequence(\"ABC\", \"ABCD\") == \"ABC\"\n    assert Solution().longestCommonSubsequence(\"ABCD\", \"ABC\") == \"ABC\"",
    "# https://leetcode.com/problems/longest-common-subsequence/discuss/56637/C%2B%2B-Python-and-Python-Dynamic-Programming-with-Dictionary\n\n# DP\nclass Solution:\n    def longestCommonSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        m = len(str1)\n        n = len(str2)\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\n        for i in range(m+1):\n            for j in range(n+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]",
    "# https://leetcode.com/problems/longest-common-subsequence/description/\n# source: https://leetcode.com/problems/longest-common-subsequence/discuss/352952/Python-Solution\n\nimport collections\nclass Solution(object):\n    def lcs(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        m = collections.defaultdict(list)\n        for i in range(len(s1)):\n            m[s1[i]].append(i)\n        for i in range(len(s2)):\n            m[s2[i]].append(i)\n        longest = ''\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if m[s1[i]][j] == m[s2[j]][i]:\n                    if len(m[s1[i]]) > len(m[s2[j]]):\n                        longest = s1[i:m[s1[i]][-1]]\n                    else:\n                        longest = s2[j:m[s2[j]][-1]]\n                    break\n        return longest\n\n\nif __name__ == '__main__':\n    assert Solution().lcs('eggs', 'bacon') == 'bacon'\n    assert Solution().lcs('beet', 'apple') == 'beet'\n    assert Solution().lcs('orange', 'banana') == 'banana'\n    assert Solution().lcs('apple', 'banana') == 'banana'\n    assert Solution().lcs('apple', 'banana') == 'banana'\n    assert Solution().lcs('orange', 'banana') == 'orange'\n    assert Solution().lcs('orange', 'apple') == 'orange'\n    assert Solution().lcs('orange', 'orange') == 'orange'\n    assert Solution().lcs('banana', 'apple') == 'banana'\n    assert Solution().lcs('banana', 'banana') == 'banana'",
    "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {string}\n    def longestCommonSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if not s or not t:\n            return \"\"\n\n        m, n = len(s), len(t)\n        if m == 0 or n == 0:\n            return \"\"\n\n        # map[i][j] = longest common subsequence of s[0:i] and t[0:j]\n        map = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    map[i][j] = map[i - 1][j - 1] + 1\n                else:\n                    map[i][j] = max(map[i - 1][j], map[i][j - 1])\n\n        max_len = 0\n        i = 0\n        j = 0\n        while i < m and j < n:\n            if s[i] == t[j]:\n                i += 1\n                j += 1\n                max_len = max(max_len, map[i][j])\n            elif map[i][j] > map[i][j - 1]:\n                i += 1\n                max_len = max(max_len, map[i][j])\n            else:\n                j += 1\n                max_len = max(max_len, map[i][j])\n        return s[:max_len]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.longestCommonSubsequence(\"abc\", \"bcd\")",
    "def lcs(a, b):\n    \"\"\"\n    For two strings, return the longest common subsequence.\n    \"\"\"\n    m = [[0] * (len(b) + 1)] * (len(a) + 1)\n    for i in range(len(a) + 1):\n        for j in range(len(b) + 1):\n            if i == 0 or j == 0:\n                m[i][j] = 0\n            elif a[i - 1] == b[j - 1]:\n                m[i][j] = m[i - 1][j - 1] + 1\n            else:\n                m[i][j] = max(m[i - 1][j], m[i][j - 1])\n    return m[len(a)][len(b)]\n\na = \"abcd\"\nb = \"bcd\"\nprint(lcs(a, b))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestCommonSubsequence(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: str\n        \"\"\"\n        if s1 == \"\" or s2 == \"\":\n            return \"\"\n        if s1 == s2:\n            return s1\n        ret = \"\"\n        i = 0\n        j = 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s2[j]:\n                ret += s1[i]\n                i += 1\n                j += 1\n            elif s1[i] < s2[j]:\n                i += 1\n            else:\n                j += 1\n        return ret",
    "__author__ = 'Danyang'\nclass Solution:\n    def lcs(self, s, t):\n        \"\"\"\n        :param s: str\n        :param t: str\n        :return: str\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return \"\"\n\n        # store the longest common subsequence\n        lcs = \"\"\n        # store the first char of s\n        s_start = s[0]\n        # store the first char of t\n        t_start = t[0]\n\n        # iterate through the longest common subsequence\n        for i in range(len(s)):\n            # if the current char of s is different from the current char of t\n            if s[i]!= t[i]:\n                # if the current char of s is larger than the current char of t\n                if s[i] > t[i]:\n                    # if the current char of s is the first char of s\n                    if s_start == s[i]:\n                        # if the current char of t is the first char of t\n                        if t_start == t[i]:\n                            # extend the longest common subsequence\n                            lcs += s[i]\n                        # if the current char of t is not the first char of t\n                        else:\n                            # if the current char of t is not the first char of t\n                            if t_start!= t[i]:\n                                # extend the longest common subsequence\n                                lcs += t[i]\n                    # if the current char of s is not the first char of s\n                    else:\n                        # if the current char of t is the first char of t\n                        if t_start == t[i]:\n                            # if the current char of s is not the first char of s\n                            if s_start!= s[i]:\n                                # extend the longest common subsequence\n                                lcs += s[i]\n                        # if the current char of t is not the first char of t\n                        else:\n                            # if the current char of t is not the first char of t\n                            if s_start!= s[i]:\n                                # extend the longest common subsequence\n                                lcs += t[i]\n                # if the current char of s is smaller than the current char"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}