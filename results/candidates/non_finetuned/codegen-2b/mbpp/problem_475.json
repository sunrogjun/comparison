{
  "problem": {
    "task_id": "MBPP/486",
    "prompt": "Write a function to compute binomial probability for the given number.",
    "canonical_solution": "def nCr(n, r): \r\n\tif (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ",
    "test_list": [
      "assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185",
      "assert binomial_probability(11, 6, 2.0/4) == 0.2255859375",
      "assert binomial_probability(12, 7, 3.0/5) == 0.227030335488"
    ],
    "challenge_test_list": [],
    "problem_id": 475
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import unittest\n\nclass Solution:\n    # @return a float\n    def getBinomialProbability(self, n, k):\n        if k > n:\n            return 1.0\n        if k == 0 or k == n:\n            return 1.0\n        if k == 1 or k == n - 1:\n            return 1.0\n        if k == n:\n            return 0.0\n        if k == 1:\n            return (1.0 / n)\n        if k == n - 1:\n            return (1.0 / n)\n        if k == n - 2:\n            return (1.0 / (n - 2))\n        if k == n - 3:\n            return (1.0 / (n - 3))\n        if k > n - 3:\n            return 0.0\n        if k > n - 2:\n            return 0.0\n        if k > n - 1:\n            return 0.0\n        if k > n:\n            return 0.0\n        if k > 0:\n            return 1.0 - (1.0 / (n - k))\n        if k > 1:\n            return 1.0 - (1.0 / (n - k + 1))\n        if k > 2:\n            return 1.0 - (1.0 / (n - k + 2))\n        if k > 3:\n            return 1.0 - (1.0 / (n - k + 3))\n        return 0.0\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n        print Solution().getBinomialProbability(3, 1)\n        print Solution().getBinomialProbability(3, 3)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/binomial-coefficient/solution/\n\n# DFS\n# 10ms 100%\nclass Solution {\n    public double getBinomialProbability(int n, int k) {\n        if (k == 0 || k == n) return 1.0;",
    "def binomial(n, k):\n    \"\"\"\n    n is the number of objects, k is the number of trials.\n    Returns the probability that at least one object is chosen with\n    probability 1/n.\n    \"\"\"\n    return (k + 1) * (n - k) / (k * (n - 1))\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    print(binomial(n, k))",
    "from collections import Counter\n\nclass Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def binomial(self, n, k):\n        # Write your code here\n        res = 1\n        for i in range(1, k+1):\n            res *= n - i + 1\n            res /= i + 1\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(5, 3)",
    "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def binomialCoefficient(self, n):\n        if n < 0:\n            return 0\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        total = 1\n        for i in range(4, n+1):\n            total *= i\n        return total\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomialCoefficient(5)",
    "# https://www.hackerrank.com/challenges/binomial-coefficient/problem\n\nimport math\n\ndef binomial(n, k):\n    # n is the number of trials, k is the number of successes.\n    # We are computing the number of trials that have exactly k successes.\n    # We are computing the number of trials that have at least k successes.\n    if k == 0:\n        return 1\n    elif k == 1:\n        return n\n    elif k == n:\n        return 1\n    elif k > n:\n        return 0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\nif __name__ == '__main__':\n    print(binomial(2, 3))\n    print(binomial(4, 3))\n    print(binomial(5, 3))\n    print(binomial(6, 3))\n    print(binomial(7, 3))\n    print(binomial(8, 3))",
    "from collections import namedtuple\n\nclass Binomial(namedtuple(\"Binomial\", [\"n\", \"k\", \"p\"])):\n    \"\"\"\n    A namedtuple representing the binomial distribution.\n    \"\"\"\n    __slots__ = ()\n\n    def __new__(cls, n, k, p):\n        return super().__new__(cls, n, k, p)\n\n    @classmethod\n    def from_probabilities(cls, n, k, p):\n        return cls(n, k, p)\n\n    def to_probabilities(self):\n        return self.p\n\n    def to_probabilities_str(self):\n        return \"p(%d, %d) = %f\" % (self.n, self.k, self.p)\n\n    def __str__(self):\n        return self.to_probabilities_str()\n\n    def __repr__(self):\n        return self.to_probabilities_str()\n\n    def __eq__(self, other):\n        return self.p == other.p\n\n    def __ne__(self, other):\n        return self.p!= other.p\n\n    def __lt__(self, other):\n        return self.p < other.p\n\n    def __le__(self, other):\n        return self.p <= other.p\n\n    def __gt__(self, other):\n        return self.p > other.p\n\n    def __ge__(self, other):\n        return self.p >= other.p\n\n    def __hash__(self):\n        return hash(self.p)",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def binomial(self, n, k):\n        if k > n:\n            return 0\n        res = 1\n        for i in range(2, k+1):\n            res *= (n-i+1)//i\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.binomial(1, 2))",
    "# https://leetcode.com/problems/binomial-coefficient/\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k > n:\n            return 0.0\n        return (1.0 + (1.0 - 1.0 / k)) ** n / (1.0 - 1.0 / k)\n\nif __name__ == '__main__':\n    assert Solution().binomial(5, 3) == 1.0\n    assert Solution().binomial(5, 4) == 0.0\n    assert Solution().binomial(5, 5) == 1.0\n    assert Solution().binomial(5, 6) == 0.0\n    assert Solution().binomial(5, 7) == 0.0\n    assert Solution().binomial(5, 8) == 0.0\n    assert Solution().binomial(5, 9) == 0.0\n    assert Solution().binomial(5, 10) == 1.0\n    assert Solution().binomial(5, 11) == 0.0\n    assert Solution().binomial(5, 12) == 0.0\n    assert Solution().binomial(5, 13) == 0.0\n    assert Solution().binomial(5, 14) == 0.0\n    assert Solution().binomial(5, 15) == 1.0",
    "from collections import Counter\nfrom math import factorial\n\n\ndef binomial_probability(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k == 0:\n        return 1\n    if k == 1:\n        return float(n) / factorial(n)\n    if k > n:\n        return 0\n    p = 1\n    for i in range(1, k):\n        p *= factorial(n - i) / factorial(i)\n    return p\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    print(binomial_probability(10, 2))\n    print(binomial_probability(10, 3))\n    print(binomial_probability(10, 4))\n    print(binomial_probability(10, 5))\n    print(binomial_probability(10, 6))\n    print(binomial_probability(10, 7))\n    print(binomial_probability(10, 8))\n\n\nif __name__ == '__main__':\n    main()",
    "# https://leetcode.com/problems/binomial-coefficient/\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1.0\n        if n < 0 or k < 0:\n            return 0.0\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return n\n        if k == n:\n            return 1.0\n        if k > n:\n            return 0.0\n        if n == k:\n            return 1.0\n        return (n * self.binomial(n - 1, k - 1)) / (k + 1)",
    "import math\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return math.exp(self.fact(n) - self.fact(k) - self.fact(n - k))\n    def fact(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: float\n        \"\"\"\n        return math.factorial(n)\n\n# Note:\n# The probability of the event happening is (1/k) * (1/n - 1/k)",
    "import math\n\n\ndef binomial_probability(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    return math.factorial(n) / math.factorial(n-k) / math.factorial(k) / math.factorial(n-k-k)\n\n\nif __name__ == '__main__':\n    print binomial_probability(100, 20)",
    "from math import log\n\ndef binomial(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    return (1.0 * (n + 1)) ** k * (k + 1) / ((n + 1) * (n + k + 1))\n\ndef binomial_probability(n, k):\n    return binomial(n, k) * (1 - binomial(n - k, k))\n\ndef main():\n    print binomial(3, 2)\n\nif __name__ == \"__main__\":\n    main()",
    "from __future__ import annotations\n\nimport math\n\n\ndef binomial_probability(number: int, n: int, k: int) -> float:\n    \"\"\"\n    For the given number of students and k, compute the binomial probability.\n\n    :param number: The number of students.\n    :param n: The number of students.\n    :param k: The number of students.\n    :return: The binomial probability.\n    \"\"\"\n    # Assumes that number is an integer greater than 0.\n    prob = 1\n    for i in range(k):\n        prob *= math.factorial(n - i) / math.factorial(i) / math.factorial(n - i - i)\n    return prob\n\n\nif __name__ == \"__main__\":\n    assert binomial_probability(10, 5, 3) == 0.0625\n    assert binomial_probability(10, 5, 4) == 0.125\n    assert binomial_probability(10, 5, 5) == 0.25\n    assert binomial_probability(10, 5, 6) == 0.5\n    assert binomial_probability(10, 5, 7) == 0.75\n    assert binomial_probability(10, 5, 8) == 1",
    "class Solution:\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k > n or k < 0:\n            return 0\n        if k == 0:\n            return 1\n        if k == n:\n            return 1\n        return self.binomial(n, k-1) * self.binomial(n-1, k-1) / (self.factorial(n) * self.factorial(k))\n\n    def factorial(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return n\n        return n * self.factorial(n-1)\n\nif __name__ == \"__main__\":\n    print Solution().binomial(4, 3)",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    n is an integer, k is an integer\n    returns the binomial probability of n\n    \"\"\"\n    return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))\n\ndef main():\n    n = int(input(\"Enter the number of trials: \"))\n    k = int(input(\"Enter the number of successes: \"))\n    print(\"The probability of \", n, \" trials with \", k, \" successes is \", binomial(n, k))\n\nif __name__ == '__main__':\n    main()",
    "import numpy as np\n\n\ndef binomial(n, k):\n    \"\"\"\n    Computes the binomial probability for the given number of trials and\n    the number of successes.\n    \"\"\"\n    return np.exp(np.log(np.binomial(n, k)) - np.log(n) - np.log(k))\n\n\ndef main():\n    \"\"\"\n    A simple test program to demonstrate the function.\n    \"\"\"\n    print(binomial(4, 3))\n    print(binomial(4, 1))\n    print(binomial(4, 0))\n    print(binomial(4, 2))\n    print(binomial(4, 3))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from collections import Counter\n\ndef binomial(n, k):\n    \"\"\"\n    Returns the binomial coefficient for the given number of trials and\n    the number of successes.\n\n    For example, the binomial coefficient for 4 trials and 2 successes\n    is 2.0 and the binomial coefficient for 4 trials and 3 successes\n    is 3.0.\n    \"\"\"\n\n    return reduce(lambda x, y: x * y, (n - k + i) for i in range(k + 1)) / (n + 1)\n\n\ndef binomial_prob(n, k):\n    \"\"\"\n    Returns the probability that the number of successes is k.\n\n    For example, the probability that the number of successes is 2 is\n    1/3 and the probability that the number of successes is 3 is 2/3.\n    \"\"\"\n\n    return binomial(n, k) / (binomial(n, k) + binomial(n - k, k))\n\n\ndef main():\n    \"\"\"\n    Tests the binomial_prob function.\n    \"\"\"\n\n    # Tests the binomial_prob function\n    n = 4\n    k = 2\n    assert binomial_prob(n, k) == 0.75\n    n = 4\n    k = 3\n    assert binomial_prob(n, k) == 0.25\n    n = 4\n    k = 4\n    assert binomial_prob(n, k) == 0.25\n\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return (float(1) / (k + 1)) * (float(1) - (float(1) / (n + 1))) * (float(1) - (float(1) / (k + n)))\n\n\nif __name__ == '__main__':\n    assert Solution().binomial(3, 1) == 1\n    assert Solution().binomial(3, 2) == 0\n    assert Solution().binomial(3, 3) == 0\n    assert Solution().binomial(3, 4) == 0\n    assert Solution().binomial(3, 5) == 0\n    assert Solution().binomial(5, 1) == 1\n    assert Solution().binomial(5, 2) == 0\n    assert Solution().binomial(5, 3) == 0\n    assert Solution().binomial(5, 4) == 0\n    assert Solution().binomial(5, 5) == 1",
    "import numpy as np\n\ndef binomial_probability(n, k):\n    \"\"\"\n    For a given number of people and number of events,\n    return the probability of a given number of events.\n\n    >>> binomial_probability(5, 2)\n    0.6\n    >>> binomial_probability(10, 10)\n    0.1\n    >>> binomial_probability(10, 5)\n    0.1\n    >>> binomial_probability(5, 5)\n    0.25\n    >>> binomial_probability(1, 1)\n    1.0\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    if k == n:\n        return 1\n\n    return np.power(1 - np.power(np.exp(-1), n - k), k)\n\n\ndef binomial_probability_2(n, k):\n    \"\"\"\n    For a given number of people and number of events,\n    return the probability of a given number of events.\n\n    >>> binomial_probability_2(5, 2)\n    0.6\n    >>> binomial_probability_2(10, 10)\n    0.1\n    >>> binomial_probability_2(10, 5)\n    0.1\n    >>> binomial_probability_2(5, 5)\n    0.25\n    >>> binomial_probability_2(1, 1)\n    1.0\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    if k == n:\n        return 1\n\n    return np.power(np.exp(-1), n - k) / np.power(1 - np.exp(-1), k)\n\n\ndef binomial_probability_3(n, k):\n    \"\"\"\n    For a given number of people and number of events,\n    return the probability of a given number of events.\n\n    >>> binomial_probability_3(5, 2)\n    0.6\n    >>> binomial_probability_3(10, 10)\n    0.1\n    >>> binomial_",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        numerator = 1\n        denominator = 1\n        for i in range(1, k+1):\n            numerator *= n - k + i\n            denominator *= i\n        return float(numerator)/denominator\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(3, 1)\n    print s.binomial(3, 2)\n    print s.binomial(3, 3)\n    print s.binomial(4, 3)\n    print s.binomial(4, 2)\n    print s.binomial(4, 4)",
    "from math import log\nfrom typing import List\n\nclass Solution:\n    def binomial(self, n: int, k: int) -> float:\n        \"\"\"\n        O(n) space\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n < 0 or k < 0:\n            return 0.0\n        if n == 0 or k == 0:\n            return 1.0\n        if k > n:\n            return 0.0\n        if k == n:\n            return 1.0\n        if k > n / 2:\n            k = k - n\n            return self.binomial(n, k) * self.binomial(n - k, n - k)\n        return self.binomial(n - k, n - k) / self.binomial(n, k)\n\n\n    def binomial(self, n: int, k: int) -> float:\n        \"\"\"\n        O(n) space\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n < 0 or k < 0:\n            return 0.0\n        if k > n:\n            return 0.0\n        if k == 0 or k == n:\n            return 1.0\n        if k == 1 or k == n - 1:\n            return 1.0\n        if k > n / 2:\n            k = k - n\n            return self.binomial(n, k) * self.binomial(n - k, n - k)\n        return self.binomial(n - k, n - k) / self.binomial(n, k)\n\n\n\nclass Solution2:\n    def binomial(self, n: int, k: int) -> float:\n        \"\"\"\n        O(n) space\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n < 0 or k < 0:\n            return 0.0\n        if n == 0 or k == 0:\n            return 1.0\n        if k > n:\n            return 0.0\n        if k == n:\n            return 1.0\n        if k == 1 or k",
    "def binom_prob(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    return math.exp(n * math.log(n) + k * math.log(k) - n * math.log(n - k) - k * math.log(k))\n\nif __name__ == '__main__':\n    assert binom_prob(1, 1) == 1\n    assert binom_prob(2, 1) == 1\n    assert binom_prob(2, 2) == 0.5\n    assert binom_prob(3, 2) == 0.25\n    assert binom_prob(4, 2) == 0.125\n    assert binom_prob(5, 2) == 0.0625\n    assert binom_prob(6, 2) == 0.03125\n    assert binom_prob(7, 2) == 0.015625\n    assert binom_prob(8, 2) == 0.0078125\n    assert binom_prob(9, 2) == 0.00390625\n    assert binom_prob(10, 2) == 0.001953125\n    assert binom_prob(11, 2) == 0.0009765625\n    assert binom_prob(12, 2) == 0.00048828125",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        ans = 1\n        for i in range(n):\n            ans *= float(k + 1) / float(i + 1)\n        return ans\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.binomial(2, 3)",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return (1 - math.e ** (-1 * k * n)) / (1 - math.e ** (-1 * n))\n\nif __name__ == '__main__':\n    assert Solution().binomial(10, 6) == 0.16666666666666666",
    "class Solution:\n    \"\"\"\n    @param num: An integer\n    @return: The binomial coefficient\n    \"\"\"\n    def binomial(self, n, k):\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n        if k == n - 1:\n            return 1\n        if k == n:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 4\n        return (self.binomial(n - 1, k - 1) + self.binomial(n - 2, k - 2)) * self.binomial(n - 1, k)\n\n\nif __name__ == \"__main__\":\n    print Solution().binomial(3, 2)",
    "def binomial_probability(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k > n or k < 0:\n        return 0.0\n    else:\n        return 1.0/(math.factorial(k)*math.factorial(n-k))\n\nif __name__ == \"__main__\":\n    print(binomial_probability(5, 3))\n    print(binomial_probability(6, 3))\n    print(binomial_probability(7, 3))\n    print(binomial_probability(8, 3))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n\n        p = 1.0\n        for i in range(1, k + 1):\n            p *= (n - i + 1) / i\n\n        return p",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {number}\n    def getProb(self, root):\n        if not root:\n            return 1\n\n        res = 1\n        prob = self.getProb(root.left)\n        if prob > 0:\n            res = prob * self.getProb(root.right)\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))\n    print s.getProb(root)",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def binomial(self, n, k):\n        if n == 0 or k == 0:\n            return 1\n        return self.binomial(n - 1, k) * self.binomial(n, k - 1)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def probability(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if not root:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return float(root.val) / (1 + self.probability(root.left, 1) + self.probability(root.right, 1))\n        if k == 2:\n            return float(root.val) / (1 + self.probability(root.left, 2) + self.probability(root.right, 2))\n        if k == 3:\n            return float(root.val) / (1 + self.probability(root.left, 3) + self.probability(root.right, 3))\n        if k == 4:\n            return float(root.val) / (1 + self.probability(root.left, 4) + self.probability(root.right, 4))\n        if k == 5:\n            return float(root.val) / (1 + self.probability(root.left, 5) + self.probability(root.right, 5))\n        if k == 6:\n            return float(root.val) / (1 + self.probability(root.left, 6) + self.probability(root.right, 6))\n        if k == 7:\n            return float(root.val) / (1 + self.probability(root.left, 7) + self.probability(root.right, 7))\n        if k == 8:\n            return float(root.val) / (1 + self.probability(root.left, 8) + self.probability(root.right, 8))\n        if k == 9:\n            return float(root.val) / (1 + self.probability(root.left",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return pow(1.0, n) / (pow(1.0, k) * pow(1.0, n-k))\n\n\nif __name__ == \"__main__\":\n    assert Solution().binomial(5, 2) == 0.5\n    assert Solution().binomial(5, 5) == 1.0\n    assert Solution().binomial(10, 5) == 0.5",
    "def binomial_probability(n, k):\n    \"\"\"\n    Compute binomial probability for the given number.\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    return (binom(n, k) / factorial(n))\n\ndef binomial_probability_old(n, k):\n    \"\"\"\n    Compute binomial probability for the given number.\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    return 1 - math.exp(n * math.log(1 - math.pow(1 - k, n)))\n\ndef factorial(n):\n    \"\"\"\n    Compute factorial for the given number.\n    \"\"\"\n    if n < 0:\n        return 0\n    return math.factorial(n)\n\nif __name__ == \"__main__\":\n    print binomial_probability(10, 3)",
    "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def binomial(self, n, k):\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        else:\n            return self.binomial(n-1, k-1) * self.binomial(n-1, k)",
    "__author__ = 'Libao Jin'\n__date__ = 'December 1st, 2015'\n\n'''\n    Example 1:\n    Input:\n        2\n    Output:\n        0.6\n    Explanation:\n        There are two ways to get the probability:\n            1. 1/2 * (1 - 1/2) = 0.6\n            2. 1/2 * (1 - 1/2) = 0.4\n'''\n\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == n:\n            return 1\n        if k > n:\n            return 0\n        return (float(k) * self.binomial(n - 1, k - 1)) / (float(n - k))\n\n\ndef main():\n    n = 2\n    k = 3\n    print(Solution().binomial(n, k))\n\n\nif __name__ == '__main__':\n    main()",
    "#!/usr/bin/env python\n\n# @include\ndef binomial_prob(n, k):\n    return binom(n, k) / (binom(n, k) + binom(n - k, k))\n# @exclude\n\n\nif __name__ == \"__main__\":\n    assert binomial_prob(3, 1) == 0.25\n    assert binomial_prob(3, 2) == 0.25\n    assert binomial_prob(3, 3) == 0.25\n    assert binomial_prob(3, 4) == 0.25\n    assert binomial_prob(3, 5) == 0.25\n    assert binomial_prob(3, 6) == 0.25\n    assert binomial_prob(3, 7) == 0.25\n    assert binomial_prob(3, 8) == 0.25\n    assert binomial_prob(3, 9) == 0.25\n    assert binomial_prob(3, 10) == 0.25\n    assert binomial_prob(3, 100) == 0.25\n    assert binomial_prob(3, 1000) == 0.25\n    assert binomial_prob(3, 1001) == 0.25\n    assert binomial_prob(3, 1023) == 0.25\n    assert binomial_prob(3, 1025) == 0.25\n    assert binomial_prob(3, 1024) == 0.25\n    assert binomial_prob(3, 1026) == 0.25\n    assert binomial_prob(3, 1027) == 0.25\n    assert binomial_prob(3, 1028) == 0.25\n    assert binomial_prob(3, 1029) == 0.25\n    assert binomial_prob(3, 1030) == 0.25\n    assert binomial_prob(3, 1031) == 0.25\n    assert binomial_prob(3, 1032) == 0.25\n    assert binomial_prob(3, 1033) == 0.25\n    assert binomial_prob(3, 1034) == 0.25\n    assert",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def binom(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        elif n == k:\n            return 1\n        else:\n            return self.binom(n - 1, k) + self.binom(n - 1, k - 1)\n\nif __name__ == '__main__':\n    s = Solution()\n    assert 1 == s.binom(3, 1)\n    assert 1 == s.binom(4, 2)\n    assert 1 == s.binom(5, 3)\n    assert 1 == s.binom(6, 4)\n    assert 1 == s.binom(7, 5)\n    assert 0 == s.binom(8, 6)\n    assert 0 == s.binom(9, 7)\n    assert 1 == s.binom(10, 8)\n    assert 0 == s.binom(11, 9)\n    assert 0 == s.binom(12, 10)\n    assert 1 == s.binom(13, 11)\n    assert 0 == s.binom(14, 12)\n    assert 0 == s.binom(15, 13)\n    assert 0 == s.binom(16, 14)\n    assert 0 == s.binom(17, 15)\n    assert 0 == s.binom(18, 16)\n    assert 0 == s.binom(19, 17)\n    assert 0 == s.binom(20, 18)\n    assert 0 == s.binom(21, 19)\n    assert 0 == s.binom(22, 20)\n    assert 0 == s.binom(23, 21)\n    assert 0 == s.binom(24, 22)\n    assert 0 == s.binom(25, 23)\n    assert 0 == s.binom(26, 24)\n    assert 0 == s.binom",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k > n:\n            return 0.0\n        if k == 0 or k == n:\n            return 1.0\n        if k == 1:\n            return float(n) / (n + 1)\n        prob = 1.0\n        for i in xrange(2, n + 1):\n            prob *= float(i - k) / i\n        return prob",
    "import math\nimport random\n\n\ndef binomial_probability(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0 or k == n:\n        return 1.0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef binomial_probability_2(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0 or k == n:\n        return 1.0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef binomial_probability_3(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0 or k == n:\n        return 1.0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef binomial_probability_4(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0 or k == n:\n        return 1.0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef binomial_probability_5(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if k == 0 or k == n:\n        return 1.0\n    return math.factorial",
    "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param {integer} num\n    # @return {integer}\n    def getProb(self, num):\n        if num == 0:\n            return 1\n        if num == 1:\n            return 0\n        if num == 2:\n            return 0.5\n        prob = 0\n        for i in range(2, num + 1):\n            prob += (1 - prob) / (i * (i - 1))\n        return prob\n\nif __name__ == \"__main__\":\n    assert Solution().getProb(0) == 1\n    assert Solution().getProb(1) == 0\n    assert Solution().getProb(2) == 0.5\n    assert Solution().getProb(3) == 0.1666\n    assert Solution().getProb(4) == 0.0\n    assert Solution().getProb(5) == 0.0\n    assert Solution().getProb(6) == 0.0\n    assert Solution().getProb(7) == 0.0\n    assert Solution().getProb(8) == 0.0\n    assert Solution().getProb(9) == 0.0\n    assert Solution().getProb(10) == 0.0\n    assert Solution().getProb(11) == 0.0\n    assert Solution().getProb(12) == 0.0\n    assert Solution().getProb(13) == 0.0\n    assert Solution().getProb(14) == 0.0\n    assert Solution().getProb(15) == 0.0\n    assert Solution().getProb(16) == 0.0\n    assert Solution().getProb(17) == 0.0\n    assert Solution().getProb(18) == 0.0\n    assert Solution().getProb(19) == 0.0\n    assert Solution().getProb(20) == 0.0\n    assert Solution().getProb(21) == 0.0",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    Compute binomial probability.\n    n - number of trials\n    k - number of successes\n    \"\"\"\n    if k < 0 or n < k:\n        return 0\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\ndef main():\n    n = int(input())\n    k = int(input())\n    print(binomial(n, k))\n\nif __name__ == '__main__':\n    main()",
    "# https://en.wikipedia.org/wiki/Binomial_probability\n\n# 1. Counting\n\n# 1.1 Counting\n# 1.1.1 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.2 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.3 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.4 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.5 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.6 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.7 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.8 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.9 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.10 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.11 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.12 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.13 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.14 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.15 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.16 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.17 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.18 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.19 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.20 Counting the number of ways to choose k elements from a set of N elements\n# 1.1.21 Counting the number of ways to choose k elements from",
    "# https://www.hackerrank.com/challenges/binomial-coefficient/problem\n\n# pylint: disable=R0914\n\ndef binomial(n, k):\n    \"\"\"\n    Calculate binomial coefficient for a given number and k.\n\n    :param n: The number to calculate binomial coefficient for.\n    :param k: The number of ways to choose n.\n    :return: The binomial coefficient for the given number and k.\n    \"\"\"\n    if k > n:\n        return 0\n\n    if k == 0:\n        return 1\n\n    if k == 1:\n        return n\n\n    if k > n:\n        return 0\n\n    return binomial(n, k-1) * binomial(n-k, k)\n\n\nif __name__ == '__main__':\n    test_cases = [\n        (4, 2),\n        (5, 3),\n        (6, 4),\n        (7, 5),\n        (8, 6),\n        (9, 7),\n        (10, 8),\n        (20, 10)\n    ]\n\n    for test_case in test_cases:\n        n, k = test_case\n        print('{0} {1}'.format(binomial(n, k), binomial(n, k)))",
    "#!/usr/bin/python\n\ndef binomial_prob(n, k):\n    \"\"\"\n    n: the number of trials.\n    k: the number of successes.\n    \"\"\"\n    # n * (n-1) * (n-2) *... * 1\n    return (n * (n - 1) * (n - 2) *... * 1) / (k + n - 1)\n\nif __name__ == \"__main__\":\n    print binomial_prob(5, 3)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def getProbability(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        res = 1\n        self.getProbability(root.left)\n        self.getProbability(root.right)\n        self.getProbability(root.right)\n        res = res * self.getProbability(root.left)\n        return res\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    root.right.right.left = TreeNode(6)\n    root.right.right.right = TreeNode(7)\n    root.right.right.right.left = TreeNode(8)\n    root.right.right.right.right = TreeNode(9)\n    root.right.right.right.right.left = TreeNode(10)\n    root.right.right.right.right.right = TreeNode(11)\n\n    res = Solution().getProbability(root)\n    print(res)",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def binomial(self, n, k):\n        if k > n:\n            return 0\n        return self.binomial_rec(n, k, 1)\n\n    def binomial_rec(self, n, k, res):\n        if k == 0:\n            return res\n        if k == 1:\n            return res * (n + 1)\n        return self.binomial_rec(n - 1, k - 1, res * (n + 1))\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(10, 2)",
    "__author__ = 'Danyang'\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        elif k == n:\n            return 1\n\n        return self.binomial(n - 1, k - 1) * self.binomial(n - 1, k) / (k - 1) / (n - k + 1)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "import math\n\n\ndef binomial_probability(x, n, p):\n    \"\"\"\n    Compute the binomial probability for the given number of successes and\n    the probability of success.\n\n    :param x: number of successes\n    :param n: number of trials\n    :param p: probability of success\n    :return: binomial probability\n    \"\"\"\n    if p == 0:\n        return 1.0\n    if x == 0:\n        return 0.0\n    if x < 0 or n < 0 or p < 0:\n        return 0.0\n    if n == 0 or p == 1:\n        return 1.0\n    if x >= n:\n        return 0.0\n\n    return math.factorial(n) / (math.factorial(x) * math.factorial(n-x) * math.factorial(x-n) * math.factorial(n-x-n+x+1)) * p\n\n\ndef binomial_probability_naive(x, n, p):\n    \"\"\"\n    Compute the binomial probability for the given number of successes and\n    the probability of success.\n\n    :param x: number of successes\n    :param n: number of trials\n    :param p: probability of success\n    :return: binomial probability\n    \"\"\"\n    if p == 0:\n        return 1.0\n    if x == 0:\n        return 0.0\n    if x < 0 or n < 0 or p < 0:\n        return 0.0\n    if n == 0 or p == 1:\n        return 1.0\n    if x >= n:\n        return 0.0\n\n    return math.factorial(n) / (math.factorial(x) * math.factorial(n-x) * math.factorial(x-n) * math.factorial(n-x-n+x+1))\n\n\ndef binomial_probability_fast(x, n, p):\n    \"\"\"\n    Compute the binomial probability for the given number of successes and\n    the probability of success.\n\n    :param x: number of successes\n    :param n: number of trials\n    :param p: probability of success\n    :return: binomial probability\n    \"\"\"",
    "# https://www.hackerrank.com/challenges/binomial-coefficients/problem\n#\n# Hint:\n#  - The algorithm is quite simple, just use the same code for the\n#    different cases (n = 0, 1, 2,...).\n\nimport collections\n\n\ndef binomial_coefficients(n):\n    \"\"\"\n    Compute the binomial coefficients for the given number.\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n\n    result = [1]\n    for i in range(2, n + 1):\n        result.append(i)\n        for j in range(i, n + 1):\n            result[j] = result[j] * (i - j) / (j + 1)\n    return result\n\n\ndef binomial_coefficients_iter(n):\n    \"\"\"\n    Compute the binomial coefficients for the given number.\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n\n    result = collections.defaultdict(int)\n    result[0] = 1\n    for i in range(1, n + 1):\n        result[i] = i * result[i - 1]\n    return result\n\n\ndef binomial_coefficients_iter_2(n):\n    \"\"\"\n    Compute the binomial coefficients for the given number.\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n\n    result = collections.defaultdict(int)\n    result[0] = 1\n    for i in range(1, n + 1):\n        result[i] = i * result[i - 1]\n    return result\n\n\nif __name__ == '__main__':\n    print(binomial_coefficients(0))\n    print(binomial_coefficients(1))\n    print(binomial_coefficients(2))\n    print(binomial_coefficients(3))\n    print(binomial_coefficients(4))\n    print(binomial_coefficients(5))\n    print(binomial_coefficients(6))\n    print(binomial_coefficients(7))\n    print(binomial_coefficients(8))\n    print(binomial_coefficients",
    "import math\n\ndef binomial_prob(n, k):\n    \"\"\"\n    For given number of n, and k, compute binomial probability.\n    \"\"\"\n    if k > n or k < 0:\n        return 0\n    else:\n        return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\nif __name__ == '__main__':\n    assert binomial_prob(5, 1) == 1\n    assert binomial_prob(5, 2) == 0\n    assert binomial_prob(5, 3) == 0.5\n    assert binomial_prob(5, 4) == 0.16666666666666666\n    assert binomial_prob(5, 5) == 0\n    assert binomial_prob(5, 6) == 0\n    assert binomial_prob(5, 7) == 0.0\n    assert binomial_prob(5, 8) == 0\n    assert binomial_prob(5, 9) == 0\n    assert binomial_prob(5, 10) == 0\n    assert binomial_prob(5, 11) == 0\n    assert binomial_prob(5, 12) == 0\n    assert binomial_prob(5, 13) == 0\n    assert binomial_prob(5, 14) == 0\n    assert binomial_prob(5, 15) == 0\n    assert binomial_prob(5, 16) == 0\n    assert binomial_prob(5, 17) == 0\n    assert binomial_prob(5, 18) == 0\n    assert binomial_prob(5, 19) == 0\n    assert binomial_prob(5, 20) == 0\n    assert binomial_prob(5, 21) == 0\n    assert binomial_prob(5, 22) == 0\n    assert binomial_prob(5, 23) == 0\n    assert binomial_prob(5, 24) == 0\n    assert binomial_prob(5, 25) == 0\n    assert binomial_prob(5, 26) == 0\n    assert binomial_prob(5, 27) == 0",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n == k:\n            return 1.0\n        if n < k:\n            return 0\n        if n - k == k:\n            return 1.0\n        return (self.binomial(n, k) * self.binomial(n - k, n - k - k + 1)\n                / self.binomial(n - k, k))\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(4, 2)\n    print s.binomial(4, 3)",
    "import math\nimport sys\n\ndef binomial_prob(number, k):\n    \"\"\"\n    :type number: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    return math.exp(math.log(math.factorial(number)) + math.log(math.factorial(k)) - math.log(math.factorial(number - k)))\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    k = int(sys.stdin.readline())\n    print binomial_prob(n, k)",
    "def binomial(n, k):\n    \"\"\"\n    For a given number n, return the probability of k successes in n\n    trials.\n    \"\"\"\n    return (1.0 * (k + 1) * (n - k) / (k + 1))\n\ndef binomial_pdf(n, k):\n    \"\"\"\n    For a given number n, return the probability density function for k\n    successes in n trials.\n    \"\"\"\n    return (binomial(n, k) / n)\n\ndef binomial_cdf(n, k):\n    \"\"\"\n    For a given number n, return the cumulative distribution function for k\n    successes in n trials.\n    \"\"\"\n    return (1.0 * (n - k) / (k + 1))\n\ndef binomial_cdf_inv(x, n):\n    \"\"\"\n    For a given number n, return the inverse of the cumulative distribution\n    function for k successes in n trials.\n    \"\"\"\n    return (n - x)\n\ndef binomial_inv_pdf(x, n):\n    \"\"\"\n    For a given number n, return the inverse probability density function for\n    k successes in n trials.\n    \"\"\"\n    return (binomial_cdf_inv(x, n) / n)\n\ndef binomial_inv_cdf(x, n):\n    \"\"\"\n    For a given number n, return the inverse cumulative distribution function\n    for k successes in n trials.\n    \"\"\"\n    return (n - x)\n\ndef binomial_inv_cdf_inv(x, n):\n    \"\"\"\n    For a given number n, return the inverse of the inverse cumulative\n    distribution function for k successes in n trials.\n    \"\"\"\n    return (x)\n\ndef binomial_inv_cdf_inv_pdf(x, n):\n    \"\"\"\n    For a given number n, return the inverse of the inverse probability density\n    function for k successes in n trials.\n    \"\"\"\n    return (binomial_cdf_inv_pdf(x, n) / n)\n\ndef binomial_inv_cdf_inv_pdf_inv(x, n):\n    \"\"\"\n    For a given number n, return the inverse of the inverse probability",
    "import math\nimport random\n\n\ndef binom(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef binom_cnt(n, k):\n    return binom(n, k) * (1 if k == 0 else binom_cnt(n - 1, k - 1) + binom_cnt(n - 1, k))\n\n\ndef binom_prob(n, k):\n    return binom_cnt(n, k) / float(n)\n\n\ndef main():\n    for i in range(1, 20):\n        for j in range(1, 20):\n            print(binom(i, j), binom_prob(i, j))\n\n\nif __name__ == '__main__':\n    main()",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def binom(self, n, k):\n        \"\"\"\n        :param n: integer\n        :param k: integer\n        :return: float\n        \"\"\"\n        return binom(n, k)\n\n    def binom_recursive(self, n, k):\n        \"\"\"\n        :param n: integer\n        :param k: integer\n        :return: float\n        \"\"\"\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return float(n) / (n + 1)\n        return (self.binom_recursive(n - 1, k - 1) + self.binom_recursive(n - 1, k)) / (n + 1)\n\n    def binom_iterative(self, n, k):\n        \"\"\"\n        :param n: integer\n        :param k: integer\n        :return: float\n        \"\"\"\n        return (self.binom(n - 1, k - 1) + self.binom(n - 1, k)) / (n + 1)\n\n    def binom_DP(self, n, k):\n        \"\"\"\n        :param n: integer\n        :param k: integer\n        :return: float\n        \"\"\"\n        dp = [0.0] * (n + 1)\n        dp[0] = 1.0\n        for i in range(1, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - k]) / (i + 1)\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    print Solution().binom_iterative(5, 3)",
    "#!/usr/bin/env python\n\nimport math\n\ndef binomial_prob(n, k):\n    \"\"\"\n    Returns the binomial probability of n successes with k successes.\n    \"\"\"\n    if n == 0 and k == 0:\n        return 1.0\n    if n == k:\n        return math.factorial(n) / math.factorial(n - k)\n    if k == 0:\n        return 0\n    if k == 1:\n        return 1.0\n    if n > k:\n        return binomial_prob(n - 1, k)\n    if n < k:\n        return binomial_prob(n + 1, k - 1)\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    print binomial_prob(2, 2)\n\nif __name__ == '__main__':\n    main()",
    "from math import exp\n\ndef binom(n, k):\n    \"\"\"\n    Write a function to compute binomial probability for the given number.\n    \"\"\"\n    if n == 0 or k == 0:\n        return 1\n    if k > n:\n        return 0\n    if k == n:\n        return 1\n    return exp(sum([binom(n - i, i) * binom(k, i) for i in range(k + 1)]))\n\ndef binom_test(n, k):\n    \"\"\"\n    Write a function to test binomial probability for the given number.\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    return 1 - exp(-1 * sum([binom(n - i, i) * binom(k, i) for i in range(k + 1)]))\n\ndef main():\n    print binom(3, 2)\n    print binom_test(3, 2)\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {number}\n    def getProb(self, root):\n        if not root:\n            return 1\n        \n        # Recursive\n        if root.left:\n            left = self.getProb(root.left)\n        else:\n            left = 0\n        \n        if root.right:\n            right = self.getProb(root.right)\n        else:\n            right = 0\n        \n        return (left * right) / (root.val + left + right)\n\nif __name__ == \"__main__\":\n    root = TreeNode(val=5, left=TreeNode(val=1, left=None, right=TreeNode(val=3, left=None, right=None)), right=TreeNode(val=1, left=None, right=TreeNode(val=2, left=None, right=None)))\n    print Solution().getProb(root)\n    print Solution().getProb(None)\n    print Solution().getProb(TreeNode())",
    "from collections import Counter\n\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def binomial(self, n, k):\n        if k > n:\n            return 1\n        if k == 0 or k == n:\n            return 1\n        if k == 1:\n            return n\n        if k == n - 1:\n            return 1\n        if k > n / 2:\n            return self.binomial(n, n - k)\n        return self.binomial(n - 1, k - 1) * self.binomial(n - 1, k)\n\n\nif __name__ == \"__main__\":\n    print Solution().binomial(4, 2)",
    "def binomial(n, k):\n    \"\"\"\n    Compute binomial probability for the given number.\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    if n == 0 or k == 0:\n        return 1\n    if k == 1:\n        return n\n    if n == k:\n        return 1\n    else:\n        return binomial(n - 1, k) * binomial(n - 1, k - 1)\n\nif __name__ == '__main__':\n    print binomial(4, 1)",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    For given number n and k, return the binomial probability.\n    \"\"\"\n    return math.factorial(n) / math.factorial(k) / math.factorial(n-k)\n\nif __name__ == '__main__':\n    print binomial(7, 3)",
    "def binomial_probability(n, k):\n    \"\"\"\n    n - number of trials\n    k - number of successes\n    \"\"\"\n    if k == 0:\n        return 1.0\n    elif k == 1:\n        return (n > 0) and n or 0\n    elif k == n:\n        return 1.0\n    else:\n        return (binomial_probability(n - 1, k - 1) +\n                binomial_probability(n - 1, k))\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    print(binomial_probability(3, 3))\n\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return (1.0 * pow(2, n) / (pow(2, n - 1) * pow(2, k) * pow(2, n - k)))\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(3, 3)",
    "import numpy as np\nfrom scipy.special import binom\n\n\nclass Probability:\n\n    def __init__(self):\n        self.bins = np.arange(1, 11)\n        self.probs = np.zeros(11)\n\n    def binomial(self, n, p):\n        return binom(n, p)\n\n    def binomial_prob(self, n, p):\n        return self.binomial(n, p)\n\n    def binomial_prob_array(self, n, p):\n        return self.binomial_prob(n, p) / self.binomial(n, p)\n\n    def binomial_prob_array_np(self, n, p):\n        return self.binomial_prob_np(n, p) / self.binomial_np(n, p)\n\n    def binomial_prob_np(self, n, p):\n        return np.sum(self.binomial_prob_np_np(n, p))\n\n    def binomial_prob_np_np(self, n, p):\n        return np.array(self.binomial_prob_np_np(n, p))\n\n    def binomial_prob_np_np_np(self, n, p):\n        return np.array(self.binomial_prob_np_np(n, p))\n\n    def binomial_prob_np_np_np_np(self, n, p):\n        return np.array(self.binomial_prob_np_np(n, p))\n\n    def binomial_prob_np_np_np_np_np(self, n, p):\n        return np.array(self.binomial_prob_np_np(n, p))\n\n\nclass ProbabilityTest(unittest.TestCase):\n\n    def test_binomial(self):\n        prob = Probability()\n        self.assertEqual(prob.binomial(2, 0.5), 1)\n        self.assertEqual(prob.binomial(2, 0.1), 0)\n        self.assertEqual(prob.binomial(3,",
    "import math\n\ndef binomial_probability(n, k):\n    \"\"\"\n    Returns the probability of getting k items out of n items.\n    \"\"\"\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\n\n# Your binomial_probability function should return 0.0 if n = 0 or k = 0.\n# It should return 1.0 if n = 1 or k = 1.\n# It should return the probability of getting k items out of n items.",
    "#!/usr/bin/env python\n\nimport numpy as np\n\ndef binomial_prob(n, k):\n    \"\"\"\n    Compute the binomial probability for the given number and number of trials.\n    n - number of trials\n    k - number of successes\n    \"\"\"\n    return np.exp(np.log(np.binom(n, k)) + np.log(1 - np.binom(n - k, n - k)))\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter number of trials: \"))\n    k = int(input(\"Enter number of successes: \"))\n    print(binomial_prob(n, k))",
    "# https://www.tutorialspoint.com/python/python_math.htm\n# https://www.tutorialspoint.com/python/python_math_functions.htm\n\ndef binomial(n, k):\n    # this will return the binomial coefficient for n and k\n    # https://www.tutorialspoint.com/python/python_math_functions.htm\n    return reduce(lambda x, y: x * y, list(range(1, k + 1))) / reduce(lambda x, y: x * (y - k), list(range(1, k + 1)))\n\ndef binomial_probability(n, k):\n    # this will return the binomial probability for n and k\n    # https://www.tutorialspoint.com/python/python_math_functions.htm\n    return binomial(n, k) / (binomial(n, k) + binomial(n - k, k))\n\ndef binomial_probability_1(n, k):\n    # this will return the binomial probability for n and k\n    # https://www.tutorialspoint.com/python/python_math_functions.htm\n    return binomial(n, k) / (binomial(n, k) + binomial(n - k, k))\n\ndef binomial_probability_2(n, k):\n    # this will return the binomial probability for n and k\n    # https://www.tutorialspoint.com/python/python_math_functions.htm\n    return binomial(n, k) / (binomial(n, k) + binomial(n - k, k))\n\ndef binomial_probability_3(n, k):\n    # this will return the binomial probability for n and k\n    # https://www.tutorialspoint.com/python/python_math_functions.htm\n    return binomial(n, k) / (binomial(n, k) + binomial(n - k, k))\n\ndef binomial_probability_4(n, k):\n    # this will return the binomial probability for n and k\n    # https://www.tutorialspoint.",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    n is the number of trials, k is the number of successes\n    \"\"\"\n    if n == 0 or k == 0:\n        return 0\n    else:\n        return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\nif __name__ == \"__main__\":\n    print(binomial(4, 2))",
    "# https://www.hackerrank.com/challenges/binomial-coefficients/problem\n\nimport math\n\ndef binom_coeff(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n# Complete the function below.\ndef binom_coeff_2(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\nif __name__ == '__main__':\n    n = int(input())\n    k = int(input())\n    print(binom_coeff(n, k))\n    print(binom_coeff_2(n, k))",
    "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def binomial(self, n, k):\n        if n == k:\n            return 1\n        if n < k:\n            return 0\n        return self.binomial(n-1, k-1) * self.binomial(n-1, k)\n\nif __name__ == '__main__':\n    print Solution().binomial(5, 2)",
    "class Solution:\n    \"\"\"\n    @param n: An integer\n    @return: The binomial coefficient\n    \"\"\"\n    def binomial(self, n, k):\n        \"\"\"\n        @param n: An integer\n        @param k: An integer\n        @return: The binomial coefficient\n        \"\"\"\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        elif k == n:\n            return 1\n        elif k > n:\n            return 0\n        else:\n            return self.binomial(n - 1, k - 1) * self.binomial(n - 1, k) * self.binomial(n - 1, k - 1)",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        # base case\n        if n == 0 or k == 0:\n            return 1\n\n        # recursive case\n        return (self.binomial(n - 1, k) + self.binomial(n, k - 1)) / (1 + self.binomial(n, k))\n\nif __name__ == \"__main__\":\n    assert Solution().binomial(10, 2) == 1.0\n    assert Solution().binomial(10, 4) == 0.5\n    assert Solution().binomial(10, 10) == 0.25\n    assert Solution().binomial(10, 0) == 1.0",
    "def binomial_prob(n, k):\n    return factorial(n) / (factorial(k) * factorial(n - k))\n\n# Time:  O(k * n)\n# Space: O(n)\n# DP\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n + 1):\n            dp[i] = dp[i - 1] * k / (i + 1)\n        return dp[n]",
    "import math\n\nclass Solution:\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return math.exp(self.log_binomial(n, k))\n\n    def log_binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k < 0:\n            return self.log_binomial(n, n + k) - self.log_binomial(n, k)\n\n        if k == 0:\n            return 0\n\n        if k == 1:\n            return math.log(n)\n\n        if k == n:\n            return math.log(math.factorial(n))\n\n        return self.log_binomial(n, k - 1) + self.log_binomial(n - 1, k - 1)\n\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k < 0:\n            return self.binomial(n, n + k) - self.binomial(n, k)\n\n        if k == 0:\n            return 1\n\n        if k == 1:\n            return n\n\n        if k == n:\n            return math.factorial(n)\n\n        return self.binomial(n, k - 1) + self.binomial(n - 1, k - 1)\n\n\nif __name__ == \"__main__\":\n    assert Solution().binomial(3, 2) == 2.0\n    assert Solution().binomial(10, 1) == 10.0\n    assert Solution().binomial(10, 10) == 1.0\n    assert Solution().binomial(10, 11) == 0.0\n    assert Solution().binomial(10, 0) == 1.0",
    "from __future__ import print_function\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        return pow(2, n) / (pow(2, k) * pow(2, n - k))\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.binomial(10, 3))",
    "def binomial(n, k):\n    \"\"\"\n    Given n and k, return the probability of k successes in n trials.\n\n    Example\n    Given n = 20, k = 5, return 0.25.\n\n    Constraints\n    n > 0\n    k > 0\n    n >= k\n\n    Tags: Math, Backtracking\n    \"\"\"\n    if n == 0:\n        return 0\n    elif k == 0:\n        return 1\n    elif k == 1:\n        return float(n) / (n + 1)\n    else:\n        return (binomial(n - 1, k - 1) + binomial(n - 1, k)) / (n + 1)",
    "class Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def binomial(self, n, k):\n        if k == 0 or k == n:\n            return 1\n        if k < 0:\n            return 0\n        if k > n:\n            return 0\n        if k > n - k:\n            return 0\n        if k == n - k:\n            return 1\n        return self.binomial(n - k, k) * self.binomial(n - k - 1, n - k - 1)\n\nif __name__ == \"__main__\":\n    print Solution().binomial(4, 2)",
    "import numpy as np\n\ndef binomial_probability(n, k):\n    \"\"\"\n    Compute binomial probability for the given number.\n    n - number of trials\n    k - number of successes\n    \"\"\"\n    return np.exp(np.sum(np.log(n) + k * np.log(1 - n) - k * np.log(k) - n * np.log(n - k) + np.log(2 * np.pi))) / (1 - np.exp(-n * np.log(n)))\n\n\ndef main():\n    print(binomial_probability(5, 2))\n    print(binomial_probability(7, 3))\n    print(binomial_probability(7, 4))\n    print(binomial_probability(10, 3))\n    print(binomial_probability(10, 4))\n    print(binomial_probability(10, 5))\n    print(binomial_probability(10, 6))\n\nif __name__ == '__main__':\n    main()",
    "def binomial_probability(number, n, p):\n    \"\"\"\n    number, n and p are integers\n    Returns the binomial probability for number to be in\n    the range [0, number] given n and p.\n    \"\"\"\n    \n    if n <= 0 or p <= 0 or p > 1:\n        return 0\n\n    return pow(p, n) * pow(1-p, number) / factorial(n)",
    "import math\n\ndef binom(n, k):\n    \"\"\"\n    n is a positive integer, k is a non-negative integer.\n\n    Return the binomial coefficient C(n, k).\n\n    Example 1:\n\n    Input: n = 3, k = 2\n    Output: 1\n\n    Example 2:\n\n    Input: n = 3, k = 1\n    Output: 3\n\n    Example 3:\n\n    Input: n = 1, k = 0\n    Output: 1\n\n    Example 4:\n\n    Input: n = 5, k = 3\n    Output: 6\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    if k == 0:\n        return 1\n    if n == 0:\n        return 1\n    if n == k:\n        return 1\n    if k == 1:\n        return n\n    if n == k + 1:\n        return 1\n    if k == 1:\n        return n * (n - 1) / 2\n    if k == 2:\n        return n * (n - 1) * (2 * n - 1) / 6\n    if k == 3:\n        return n * (n - 1) * (2 * n - 1) * (3 * n - 2) / 18\n    if k == 4:\n        return n * (n - 1) * (2 * n - 1) * (3 * n - 2) * (4 * n - 3) / 72\n    if k == 5:\n        return n * (n - 1) * (2 * n - 1) * (3 * n - 2) * (4 * n - 3) * (5 * n - 4) / 140\n    if k == 6:\n        return n * (n - 1) * (2 * n - 1) * (3 * n - 2) * (4 * n - 3) * (5 * n - 4) * (6 * n - 5) / 280\n    if k == 7:\n        return n * (n - 1) * (2 * n - 1) * (3 * n - 2) * (4 * n - 3) * (5 * n - 4) * (6 * n - 5) * (7 * n - 6) / 469\n    if k == 8:",
    "import math\n\nclass Solution(object):\n    def getBinomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if n < k:\n            return 0.0\n        return math.factorial(n) / math.factorial(n - k) / math.factorial(k)",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    Compute binomial probability for the given number.\n\n    n: the number of trials.\n    k: the number of successes.\n    \"\"\"\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\nif __name__ == '__main__':\n    print(binomial(3, 2))\n    print(binomial(100, 25))",
    "import numpy as np\n\n\ndef binomial(n, k):\n    \"\"\"\n    :param n: int\n    :param k: int\n    :return: float\n    \"\"\"\n    if n < 0 or k < 0:\n        return 0\n    if k == 0:\n        return 1\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    return binomial(n, k - 1) * (n - k + 1) / k\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    n = int(input())\n    k = int(input())\n    print(binomial(n, k))\n\n\nif __name__ == \"__main__\":\n    main()",
    "import os\nfrom collections import defaultdict\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        ans = 1\n        for i in range(1, k+1):\n            ans *= (n - i + 1) / i\n        return ans\n\n\ndef load_cases():\n    cases = defaultdict(lambda: defaultdict(lambda: None))\n    cases[1][0] = 1\n    cases[1][1] = 1\n    cases[2][0] = 1\n    cases[2][1] = 1\n    cases[2][2] = 1\n    cases[3][0] = 1\n    cases[3][1] = 1\n    cases[3][2] = 1\n    cases[3][3] = 1\n    cases[4][0] = 1\n    cases[4][1] = 1\n    cases[4][2] = 1\n    cases[4][3] = 1\n    cases[4][4] = 1\n    cases[5][0] = 1\n    cases[5][1] = 1\n    cases[5][2] = 1\n    cases[5][3] = 1\n    cases[5][4] = 1\n    cases[5][5] = 1\n    cases[6][0] = 1\n    cases[6][1] = 1\n    cases[6][2] = 1\n    cases[6][3] = 1\n    cases[6][4] = 1\n    cases[6][5] = 1\n    cases[6][6] = 1\n    cases[7][0] = 1\n    cases[7][1] = 1\n    cases[7][2] = 1\n    cases[7][3] = 1\n    cases[7][4] = 1\n    cases[7][5] = 1\n    cases[7][6] = 1\n    cases[7][7] = 1\n    cases[8][0] = 1\n    cases[8][1] = 1\n    cases[8][2] = 1\n    cases[8][3] = 1\n    cases[8][4]",
    "from collections import namedtuple\n\nfrom math import factorial\n\n# Helper class\nBinomial = namedtuple('Binomial', ['probability', 'number'])\n\n# Helper function to convert list of binomials to dictionary\ndef binomial_to_dict(binomials):\n    binomials_dict = {}\n    for binomial in binomials:\n        binomials_dict[binomial.number] = binomial.probability\n    return binomials_dict\n\n# Helper function to compute binomial probability\ndef binomial_probability(number, probability_dict):\n    return probability_dict[number]\n\n# Binomial probability\ndef binomial_probability_wrapper(binomials, number):\n    return sum(binomial_probability(number, binomial) for binomial in binomials)\n\n# Binomial probability\ndef binomial_probability_wrapper2(binomials, number):\n    return sum(binomial_probability(binomial.number, binomial.probability) for binomial in binomials)\n\n# Test cases\ndef test_binomial_probability_wrapper():\n    binomials = [\n        Binomial(probability=0.2, number=1),\n        Binomial(probability=0.2, number=2),\n        Binomial(probability=0.2, number=3),\n        Binomial(probability=0.2, number=4)\n    ]\n\n    binomial_probability_wrapper(binomials, 1)\n    binomial_probability_wrapper(binomials, 4)\n\ndef test_binomial_probability_wrapper2():\n    binomials = [\n        Binomial(probability=0.2, number=1),\n        Binomial(probability=0.2, number=2),\n        Binomial(probability=0.2, number=3),\n        Binomial(probability=0.2, number=4)\n    ]\n\n    binomial_probability_wrapper2(binomials, 1)\n    binomial_probability",
    "import math\n\ndef binomial(n, k):\n    \"\"\"\n    Computes the binomial probability for the given number and k.\n\n    @param n: number of trials\n    @param k: number of successes\n    @return: the probability\n    \"\"\"\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert binomial(5, 1) == 1.0, \"One\"\n    assert binomial(5, 2) == 0.5, \"Two\"\n    assert binomial(5, 3) == 0.25, \"Three\"\n    assert binomial(5, 4) == 0.125, \"Four\"\n    assert binomial(5, 5) == 0.0625, \"Five\"\n    assert binomial(5, 6) == 0.03125, \"Six\"\n    assert binomial(5, 7) == 0.015625, \"Seven\"\n    assert binomial(5, 8) == 0.0078125, \"Eight\"\n    assert binomial(5, 9) == 0.00390625, \"Nine\"\n    assert binomial(5, 10) == 0.001953125, \"Ten\"\n    assert binomial(5, 11) == 0.0009765625, \"Eleven\"\n    assert binomial(5, 12) == 0.00048828125, \"Twelve\"\n    assert binomial(5, 13) == 0.000244140625, \"Thirteen\"\n    assert binomial(5, 14) == 0.0001220703125, \"Fourteen\"\n    assert binomial(5, 15) == 0.00006103515625, \"Fifteen\"\n    assert binomial(5, 16) == 0.000030517578125, \"Sixteen\"\n    assert binomial(5, 17) == 0.0000152587890625, \"Seventeen\"\n    assert binomial(5, 18) == 0.00006103515625, \"Eighteen\"\n    assert binomial(5, 19) == 0.000030517578",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :param n: an integer\n        :param k: an integer\n        :return: a float\n        \"\"\"\n        return 1.0 * (1.0 ** n) / (factorial(n) * factorial(k) * factorial(n - k))\n\n    def factorial(self, n):\n        \"\"\"\n        :param n: an integer\n        :return: a float\n        \"\"\"\n        if n == 0:\n            return 1.0\n        elif n == 1:\n            return 1.0\n        else:\n            return n * self.factorial(n - 1)\n\n\nif __name__ == \"__main__\":\n    print Solution().binomial(4, 1)",
    "def binomial_probability(n, k):\n    \"\"\"\n    Given a number n and k, return the probability of k items in a set\n    with n items.\n    \"\"\"\n    probability = 1\n    for i in range(1, k + 1):\n        probability *= float(n - i + 1)/i\n        probability /= float(i + 1)\n    return probability\n\nif __name__ == \"__main__\":\n    print binomial_probability(3, 2)",
    "# https://en.wikipedia.org/wiki/Binomial_probability\n# http://www.math.ucla.edu/~apw/stat/binom.html\n# http://www.math.ucla.edu/~apw/stat/binom.html\n\nimport math\n\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Returns the probability of k successes in n trials with probability p.\n    \"\"\"\n    return math.factorial(n) / math.factorial(n - k) / math.factorial(k) / math.factorial(n - k - k) / math.factorial(k) / math.factorial(n - k) / math.factorial(p * k)\n\n\ndef main():\n    print(binomial_probability(5, 2, 0.2))\n    print(binomial_probability(3, 3, 0.4))\n    print(binomial_probability(3, 2, 0.2))\n    print(binomial_probability(4, 4, 0.8))\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {integer} num\n    # @return {integer}\n    def binomial(self, n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return self.binomial(n-1, k-1) + self.binomial(n-1, k)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    n = int(input())\n    k = int(input())\n    print(s.binomial(n, k))",
    "import sys\n\ndef binomial_probability(n, k):\n    \"\"\"\n    Compute binomial probability for the given number and k.\n\n    @param n: The number.\n    @param k: The number of trials.\n\n    @return: The binomial probability for the given number and k.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n    prob = 1\n    for i in range(1, k+1):\n        prob *= (n - i + 1) / (i + 1)\n    return prob\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    n = int(sys.stdin.readline())\n    k = int(sys.stdin.readline())\n    print binomial_probability(n, k)\n\nif __name__ == \"__main__\":\n    main()",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :param n: an integer\n        :param k: an integer\n        :return: a float\n        \"\"\"\n        if k == 0:\n            return 1\n\n        if k == 1:\n            return float(n) / float(k)\n\n        ans = 1\n        for i in range(1, n+1):\n            ans = ans * (n - i + 1) / i\n        return ans\n\n\nif __name__ == \"__main__\":\n    Solution().binomial(7, 3)",
    "class Solution(object):\n    def binomial(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if k > n:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == n:\n            return 1\n        if k == n + 1:\n            return 1\n        return self.binomial(n - 1, k - 1) * self.binomial(n - 1, k)\n\nif __name__ == \"__main__\":\n    assert Solution().binomial(10, 1) == 1\n    assert Solution().binomial(10, 5) == 0.16666666666666666",
    "def binomial_prob(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k == 1:\n        return float(n) / float(k + 1)\n    elif k == n:\n        return float(n) / float(k)\n    else:\n        return float(n - k + 1) / float(k + 1)\n\n\n# Your binomial_prob solution here.",
    "import math\n\ndef binomial_probability(n, k):\n    '''\n    n: an integer, the number of trials\n    k: an integer, the number of successes\n    '''\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))\n\n\ndef main():\n    n = int(input())\n    k = int(input())\n    print(binomial_probability(n, k))\n\nif __name__ == '__main__':\n    main()",
    "# https://www.hackerrank.com/challenges/binomial-coefficient/problem\n\n\ndef binomial_coefficient(n, k):\n    \"\"\"\n    :param n:\n    :param k:\n    :return:\n    \"\"\"\n    return binom(n, k) / binom(n, k + 1)\n\n\ndef binom(n, k):\n    \"\"\"\n    :param n:\n    :param k:\n    :return:\n    \"\"\"\n    return (1 + (n - k + 1) * (n - k) / 2) / (1 + (n - k) * (n - k + 1) / 2)",
    "def binomial_probability(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    # n! / (n-k)!\n    return float(n) / (float(n-k) + 1)\n\nif __name__ == '__main__':\n    n = int(input())\n    k = int(input())\n    print(binomial_probability(n, k))",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return a double\n    def binomial(self, n, k):\n        return 1.0 * (1.0 * n)**k * (1.0 * k) / (1.0 * (n - k + 1))\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.binomial(2, 1)\n    print s.binomial(2, 2)\n    print s.binomial(2, 3)\n    print s.binomial(2, 4)\n    print s.binomial(2, 5)\n    print s.binomial(2, 6)\n    print s.binomial(2, 7)\n    print s.binomial(2, 8)\n    print s.binomial(2, 9)\n    print s.binomial(2, 10)",
    "def binomial(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: float\n    \"\"\"\n    return (1.0 * n) ** k / (factorial(k) * factorial(n - k))\n\n# Your binomial function should return the same output as the following.\n\ndef binomial(n, k):\n    return (1.0 * n) ** k / (factorial(k) * factorial(n - k))\n\nif __name__ == '__main__':\n    print(binomial(10, 4))",
    "# https://oj.leetcode.com/problems/binomial-coefficient/\n\nclass Solution(object):\n    def binomialCoefficient(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k > n or k < 0:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        if k == 1:\n            return n\n        if k == n:\n            return 1\n        # TODO\n        return 0\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.binomialCoefficient(5, 2)\n    print s.binomialCoefficient(5, 3)\n    print s.binomialCoefficient(5, 4)\n    print s.binomialCoefficient(5, 5)\n    print s.binomialCoefficient(5, 6)\n    print s.binomialCoefficient(5, 7)"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}