{
  "problem": {
    "task_id": "MBPP/469",
    "prompt": "Write a function to find the maximum profit earned from a maximum of k stock transactions",
    "canonical_solution": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]",
    "test_list": [
      "assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10",
      "assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7",
      "assert max_profit([10, 6, 8, 4, 2], 2) == 2"
    ],
    "challenge_test_list": [],
    "problem_id": 458
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def maxProfit(k, priceList):\n    # write your code here\n    profit = 0\n    if not priceList:\n        return profit\n    for i in range(len(priceList)):\n        if i == 0 or priceList[i] > priceList[i-1]:\n            profit += priceList[i] - priceList[i-1]\n    return profit\n\nif __name__ == \"__main__\":\n    priceList = [1, 3, 1, 2, 1, 3]\n    print maxProfit(3, priceList)",
    "#!/usr/bin/python\n\nimport sys\n\ndef max_profit(k):\n    if k == 1:\n        return 0\n    else:\n        return max_profit(k - 1) + max(k)\n\n\n# TODO:\n# 1) Implement recursive solution\n# 2) Implement non-recursive solution\n\nif __name__ == '__main__':\n    try:\n        k = int(sys.argv[1])\n    except:\n        k = 1\n    print(max_profit(k))",
    "def max_profit(n, k):\n\tprofit = 0\n\tstock_price = [0] * n\n\tstock_price[0] = 1\n\t\n\t#print stock_price\n\tfor i in range(1, n):\n\t\tfor j in range(i + 1, n):\n\t\t\tif stock_price[j] - stock_price[i] > profit:\n\t\t\t\tprofit = stock_price[j] - stock_price[i]\n\t\t\tif stock_price[j] - stock_price[i] < 0:\n\t\t\t\tstock_price[j] = stock_price[i]\n\t\n\treturn profit\n\nif __name__ == '__main__':\n\tprint max_profit(3, 3)",
    "# https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/\n\nclass Solution:\n    # @param k, an integer\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, k, prices):\n        max_profit = 0\n        p = 0\n        for i in range(len(prices)):\n            if i == k - 1:\n                p = max(p, prices[i] - prices[i - 1])\n            else:\n                p = max(p, prices[i] - prices[i - 1])\n            max_profit = max(max_profit, p)\n        return max_profit\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxProfit(3, [5, 10, 20]))\n    print(s.maxProfit(2, [1, 2, 3]))\n    print(s.maxProfit(2, [2, 3, 3]))\n    print(s.maxProfit(3, [3, 4, 5]))\n    print(s.maxProfit(3, [3, 3, 3]))\n    print(s.maxProfit(3, [5, 10, 20]))\n    print(s.maxProfit(2, [1, 2, 3]))\n    print(s.maxProfit(2, [2, 3, 3]))\n    print(s.maxProfit(3, [3, 4, 5]))\n    print(s.maxProfit(3, [3, 3, 3]))",
    "# Your code should be as fast as possible.\n\ndef maxProfit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    # Sort the prices by their first element.\n    prices.sort()\n\n    # Initialize the profit to 0.\n    maxProfit = 0\n\n    # Loop from the second element to the end of the list.\n    for i in xrange(k, len(prices)):\n        # If the first element of the current price is less than the current price,\n        # we cannot sell the current stock.\n        if prices[i] < prices[i - 1]:\n            continue\n\n        # If the current price is greater than the previous price, we can sell the current stock.\n        # Otherwise, we can't sell the current stock.\n        if prices[i] > prices[i - 1]:\n            maxProfit += prices[i] - prices[i - 1]\n\n    return maxProfit\n\n# Your code should be as fast as possible.\n\ndef maxProfit_2(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    # Sort the prices by their first element.\n    prices.sort()\n\n    # Initialize the profit to 0.\n    maxProfit = 0\n\n    # Loop from the second element to the end of the list.\n    for i in xrange(k, len(prices)):\n        # If the first element of the current price is less than the current price,\n        # we cannot sell the current stock.\n        if prices[i] < prices[i - 1]:\n            continue\n\n        # If the current price is greater than the previous price, we can sell the current stock.\n        # Otherwise, we can't sell the current stock.\n        if prices[i] > prices[i - 1]:\n            maxProfit += prices[i] - prices[i - 1]\n            continue\n\n        # If the current price is equal to the previous price, we can sell the current stock.\n        maxProfit += prices[i] - prices[i - 1]\n\n    return maxProfit",
    "def maxProfit(k, prices):\n    if len(prices) < k:\n        return 0\n    maxProfit = 0\n    for i in range(k):\n        maxProfit += max(0, prices[i] - min(prices[i+1:]))\n    return maxProfit\n\nprint(maxProfit(2, [3, 5, 10, 12, 15]))\nprint(maxProfit(3, [1, 2, 3, 4, 5, 6]))",
    "# Todo\n# 1. Write a function to calculate maximum profit for a maximum of k stock transactions\n\n# Notes\n# 1. All stock transactions are of the form [buy, quantity, price]\n# 2. The price of a stock transaction is always greater than or equal to 0\n# 3. The quantity of a stock transaction is always greater than or equal to 1\n# 4. The price of a stock transaction is always greater than or equal to the price of the previous transaction\n\n# References\n# 1. https://www.youtube.com/watch?v=Fwj1Vhj6uW4\n# 2. https://www.youtube.com/watch?v=eZ7fQx6ZjXs\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        if not k:\n            return max(prices)\n\n        # sort the prices\n        prices.sort()\n\n        # keep track of the minimum price\n        min_price = prices[0]\n\n        # keep track of the maximum price\n        max_price = prices[0]\n\n        # keep track of the maximum profit\n        max_profit = 0\n\n        for i in range(1, k):\n            min_price = min(prices[i - 1], min_price)\n            max_price = max(prices[i], max_price)\n            max_profit = max(max_profit, max_price - min_price)\n\n        return max_profit\n\n\nif __name__ == '__main__':\n    print(Solution().maxProfit(2, [2, 3, 5, 7]))\n    print(Solution().maxProfit(2, [2, 3, 4, 6, 7]))",
    "# https://www.hackerrank.com/challenges/maximumprofit/problem\n\nimport sys\n\n\ndef max_profit(k, prices):\n    max_profit = 0\n    for i in range(k):\n        min_profit = max_profit\n        min_profit = min_profit + prices[i]\n        max_profit = max(max_profit, min_profit)\n    return max_profit\n\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    prices = [int(x) for x in sys.stdin.readline().split()]\n    print(max_profit(n, prices))",
    "import sys\nsys.setrecursionlimit(100000)\n\ndef maxProfit(k, prices):\n    # print(k, prices)\n    if k == 1:\n        return max(prices)\n    elif k == 2:\n        return max(prices) - min(prices)\n    elif k == 3:\n        return max(prices) - min(prices) - min(prices[:k])\n    else:\n        return max(prices) - min(prices) - maxProfit(k-1, prices)\n\ndef test():\n    print(maxProfit(3, [5, 7, 4, 3, 2, 5, 2, 1, 3, 6, 7, 9]))\n    print(maxProfit(2, [5, 7, 4, 3, 2, 5, 2, 1, 3, 6, 7, 9]))\n    print(maxProfit(1, [5, 7, 4, 3, 2, 5, 2, 1, 3, 6, 7, 9]))\n    print(maxProfit(0, [5, 7, 4, 3, 2, 5, 2, 1, 3, 6, 7, 9]))\n\nif __name__ == '__main__':\n    test()",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        buy_price = 0\n        buy_index = 0\n        sell_index = len(prices) - 1\n        while buy_index < sell_index:\n            sell_price = prices[sell_index]\n            while sell_index > buy_index and prices[sell_index] <= buy_price:\n                sell_index -= 1\n            buy_price = sell_price\n            max_profit = max(max_profit, sell_index - buy_index)\n            while buy_index < sell_index and prices[buy_index] <= buy_price:\n                buy_index += 1\n        return max_profit\n\n\nif __name__ == \"__main__\":\n    k = int(input())\n    prices = list(map(int, input().split()))\n    print(Solution().maxProfit(k, prices))",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        \n        # for each stock, there are two ways to make profit:\n        # 1. buy stock and sell other stock.\n        # 2. buy other stock and sell stock.\n        #\n        # when we have two ways to make profit, we can only make profit by using the most profit.\n        # we can choose which way to make profit first.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by buying stock and selling other stock.\n        # if we make profit, we can increase the profit by buying other stock and selling stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by buying other stock and selling stock.\n        # if we make profit, we can increase the profit by buying stock and selling other stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # we can make profit by buying other stock and selling stock.\n        # we can increase the profit by buying stock and selling other stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by buying other stock and selling stock.\n        # if we make profit, we can increase the profit by buying stock and selling other stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by buying other stock and selling stock.\n        # if we make profit, we can increase the profit by buying other stock and selling other stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by buying other stock and selling other stock.\n        # if we make profit, we can increase the profit by buying other stock and selling other stock.\n        # the profit in this way is the difference of the two ways.\n        \n        # for each stock, we can make profit by",
    "import math\n\n# Returns the maximum profit made from n transactions\ndef maxProfit(n, k):\n    # Base case\n    if n == 0:\n        return 0\n\n    # Base case\n    if k == 0:\n        return n\n        \n    # Base case\n    if k == 1:\n        return max(n-1, 0)\n    \n    # Base case\n    if n == 1:\n        return k\n\n    # Base case\n    if k == 1:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 2:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 2:\n        return k\n\n    # Base case\n    if k == 2:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 3:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 3:\n        return k\n\n    # Base case\n    if k == 3:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 4:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 4:\n        return k\n\n    # Base case\n    if k == 4:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 5:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 5:\n        return k\n\n    # Base case\n    if k == 5:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 6:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 6:\n        return k\n\n    # Base case\n    if k == 6:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 7:\n        return max(n-1, 0)\n\n    # Base case\n    if n == 7:\n        return k\n\n    # Base case\n    if k == 7:\n        return max(n-1, 0)\n\n    # Base case\n    if k == 8:\n        return max(n",
    "#!/usr/bin/python\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# --- Day 3: Maximum Profit ---\n# \n# You have a limited number of stock transactions that you can execute. Each transaction\n# results in a profit. The profit is the sum of the profits of all transactions minus the\n# profits of the first transaction.\n# \n# For example, if you have a transaction that buys 2 shares of stock A, and then sells 3\n# shares of stock B, the profit is 6 - 4 = 2.\n# \n# For example, if you have a transaction that buys 3 shares of stock A, and then sells 1\n# share of stock B, the profit is 9 - 1 = 8.\n# \n# Given an integer k, how many transactions do you need to execute to achieve the maximum\n# profit?\n# \n# --- Part Two ---\n# \n# After a transaction, the price of the stock increases by k. If you sell the stock, the\n# price decreases by k.\n# \n# For example, after selling 2 shares of stock A, the price of stock A is 7.\n# \n# After selling 1 share of stock B, the price of stock B is 6.\n# \n# For example, after selling 3 shares of stock A, the price of stock A is 4.\n# \n# After selling 1 share of stock B, the price of stock B is 9.\n# \n# Find the maximum profit.\n# \n# --- Part Three ---\n# \n# After you execute the first transaction, you have profit = k.\n# \n# After you execute the second transaction, you have profit = k + k.\n# \n# After you execute the third transaction, you have profit = k + k + k.\n# \n#...\n# \n# In total, you have executed 3 transactions and the total profit is k + k + k.\n# \n# --- Part Four ---\n# \n# What is the maximum profit if you execute the transactions in any order?\n# \n# --- Part Five ---\n# \n# After you execute the first transaction, you have profit = k.\n# \n# After you execute the second transaction, you have profit = k + k.",
    "import sys\n\ndef maxProfit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    maxProfit = 0\n    for i in range(k, len(prices)):\n        if prices[i] > prices[i-1]:\n            maxProfit += prices[i] - prices[i-1]\n    return maxProfit\n\nif __name__ == '__main__':\n    k, prices = map(int, sys.stdin.readline().split(' '))\n    print maxProfit(k, map(int, sys.stdin.readline().split(' ')))",
    "def maxProfit(k, arr):\n    if k == 0:\n        return 0\n\n    if len(arr) == 0:\n        return 0\n    \n    if len(arr) == 1:\n        return arr[0]\n\n    s1 = arr[0]\n    s2 = arr[1]\n    \n    for i in range(2, k+1):\n        if s1 > s2:\n            s1 -= arr[i]\n        else:\n            s2 += arr[i]\n        \n    return max(s1, s2)\n\n# test cases\narr = [1,2,3]\nk = 1\nprint maxProfit(k, arr)\n\narr = [1,2,3,4,5,6,7]\nk = 2\nprint maxProfit(k, arr)\n\narr = [1,2,3,4,5,6,7,8,9,10]\nk = 3\nprint maxProfit(k, arr)",
    "#!/usr/bin/env python\n\ndef maxProfit(k, arr):\n    if not arr:\n        return 0\n\n    if k == 1:\n        return arr[0]\n    else:\n        maxProfit = 0\n        profit = 0\n        for i in range(len(arr)):\n            profit += arr[i]\n            if profit < 0:\n                profit = 0\n            else:\n                maxProfit = max(maxProfit, profit)\n                profit = 0\n        maxProfit = max(maxProfit, profit)\n        return maxProfit\n\nif __name__ == '__main__':\n    k = int(raw_input())\n    arr = [int(x) for x in raw_input().split()]\n    print maxProfit(k, arr)",
    "import math\n\ndef maxProfit(k, prices):\n\tprofit = 0\n\tfor i in range(0, k):\n\t\tprofit = max(profit, prices[i] - min(prices[:i]))\n\treturn profit\n\nif __name__ == '__main__':\n\tprices = [100, 95, 80, 65, 80, 80, 70, 80, 75]\n\tprint maxProfit(3, prices)\n\tprint maxProfit(5, prices)\n\tprint maxProfit(10, prices)",
    "import math\n\ndef maxProfit(k, transactions):\n    \"\"\"\n    :type k: int\n    :type transactions: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    if k == 0:\n        return 0\n    dp = [0] * (k + 1)\n    for i in range(len(transactions)):\n        for j in range(i + 1, len(transactions)):\n            dp[i] = max(dp[i], transactions[i][j] + max(dp[j]))\n    return dp[-1]\n\nif __name__ == '__main__':\n    print maxProfit(3, [ [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [3, 4, 5]])\n    print maxProfit(3, [ [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [3, 4, 5]])",
    "class Solution:\n    # @param {integer[]} prices\n    # @param {integer} k\n    # @return {integer}\n    def maxProfit(self, prices, k):\n        if len(prices) < k:\n            return 0\n\n        max_profit = 0\n        profit = 0\n        for i in range(k):\n            profit = max(profit, max_profit)\n            max_profit = max(max_profit, prices[i] - min(prices[0:i]))\n        return profit\n\nsolution = Solution()\n\nprices = [5, 7, 1, 3, 6, 4]\nk = 3\nprint solution.maxProfit(prices, k)",
    "from collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    @param k: The maximum of the transaction\n    @param prices: Given n stock prices\n    @return: The maximum profit\n    \"\"\"\n    def maxProfit(self, k, prices):\n        if k == 0:\n            return 0\n        dp = [defaultdict(int) for i in range(k)]\n        for i in range(len(prices)):\n            for j in range(i + 1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] + prices[i])\n        return max(dp[-1])\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.maxProfit(2, [7, 1, 5, 3, 6, 4]))\n    print(sol.maxProfit(3, [3, 1, 5, 3, 6, 4]))\n    print(sol.maxProfit(4, [3, 1, 5, 3, 6, 4]))\n    print(sol.maxProfit(5, [3, 1, 5, 3, 6, 4]))",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        profit = 0\n        for i in range(k):\n            profit = max(profit, max(0, prices[i+1] - prices[i]))\n        return profit\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxProfit(4, [3, 1, 5, 2])\n    print solution.maxProfit(4, [3, 2, 5, 1])\n    print solution.maxProfit(4, [3, 2, 1, 5])\n    print solution.maxProfit(4, [1, 2, 3, 4])",
    "def max_profit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if k == 0:\n        return 0\n    else:\n        profits = []\n        for i in range(k, len(prices)):\n            profits.append(max(prices[i] - prices[i-1], 0))\n        return max(profits)\n\nprices = [2,4,6,8,10,12,14,16,18,20]\n\nprint(max_profit(4, prices))",
    "class Solution:\n    # @param k, an integer\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, k, prices):\n        profit = 0\n        if k == 0:\n            return profit\n        if len(prices) == 1:\n            return prices[0]\n        # sort the list\n        prices.sort()\n        for i in range(1, len(prices)):\n            profit = max(profit, prices[i] - prices[i - 1])\n        return profit\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxProfit(1, [5, 1])\n    print solution.maxProfit(2, [1, 2, 5])\n    print solution.maxProfit(3, [1, 2, 3, 4, 5])\n    print solution.maxProfit(4, [1, 2, 3, 4, 5])",
    "def maxProfit(k, prices):\n    profit = 0\n    for i in range(k):\n        maxProfit = max(maxProfit, profit + prices[i])\n        profit = max(profit, maxProfit - prices[i])\n    return profit\n\nprint maxProfit(3, [1, 2, 3, 4, 5, 6])\nprint maxProfit(5, [1, 2, 3, 4, 5])\nprint maxProfit(3, [1, 2, 3])",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n\n        if len(prices) < k:\n            return 0\n\n        maxProfit = 0\n        stock = 0\n        for price in prices:\n            stock += 1\n            maxProfit = max(maxProfit, stock * (price - prices[-1]))\n\n        return maxProfit\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxProfit(3, [1, 2, 3])\n    print s.maxProfit(1, [1])\n    print s.maxProfit(2, [1, 2])\n    print s.maxProfit(3, [1, 2, 3])",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k <= 0:\n            return 0\n        \n        profit = 0\n        \n        while k > 0:\n            profit += k\n            k -= 1\n            \n        return profit\n\nif __name__ == '__main__':\n    assert Solution().maxProfit(3) == 1\n    assert Solution().maxProfit(5) == 2\n    assert Solution().maxProfit(7) == 4\n    assert Solution().maxProfit(9) == 5",
    "class Solution:\n    # @param {integer[]} prices\n    # @param {integer} k\n    # @return {integer}\n    def maxProfit(self, prices, k):\n        if k < 1 or len(prices) < k:\n            return 0\n\n        # find the max profit\n        max_profit = 0\n        for i in xrange(k):\n            max_profit = max(max_profit, self.max_profit(prices, i, k))\n\n        return max_profit\n\n    def max_profit(self, prices, i, k):\n        if i < k - 1:\n            return max(self.max_profit(prices, i + 1, k) - prices[i], 0)\n        else:\n            return max(prices[i] - prices[i - k], 0)",
    "def maxProfit(k, prices):\n    maxProfit = 0\n    for i in range(k):\n        maxProfit = max(maxProfit, max(prices[0:i+1]))\n    return maxProfit",
    "def max_profit(k, transactions):\n    \"\"\"\n    :type k: int\n    :type transactions: List[List[int]]\n    :rtype: int\n    \"\"\"\n    dp = [[0] * len(transactions) for _ in xrange(k)]\n    for i in xrange(k):\n        for j in xrange(len(transactions)):\n            if i == 0 or transactions[j][i - 1] <= transactions[j][i]:\n                dp[i][j] = transactions[j][i]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + transactions[j][i]\n    return max(dp[k - 1])\n\nif __name__ == '__main__':\n    print max_profit(2, [[1, 2, 3], [4, 5, 6], [1, 2, 3]])\n    print max_profit(3, [[1, 2, 3], [4, 5, 6], [1, 2, 3]])\n    print max_profit(5, [[1, 2, 3], [4, 5, 6], [1, 2, 3]])",
    "from functools import reduce\nimport timeit\n\n\ndef max_profit(k, transactions):\n    \"\"\"\n    :type k: int\n    :type transactions: List[List[int]]\n    :rtype: int\n    \"\"\"\n    transactions = sorted(transactions, key=lambda x: x[0])\n    transactions = [t for t in transactions if t[1] > 0]\n    transactions.sort(key=lambda x: x[1], reverse=True)\n    ans = 0\n    for i in range(k):\n        ans = max(ans, transactions[i][0] + transactions[i][1])\n        while transactions[i+1:][0] > 0 and transactions[i+1:][1] > 0:\n            ans = max(ans, transactions[i+1:][0] + transactions[i+1:][1])\n    return ans\n\n\nif __name__ == '__main__':\n    print(timeit.timeit(\"max_profit(3, [[0, 0], [1, 1], [1, 2], [2, 1], [2, 2]], \"\n                        \" [[0, 2], [0, 4], [1, 3], [1, 5], [2, 3], [2, 6], [3, 4], [3, 7]])\",\n                        setup=\"from __main__ import max_profit\", number=1))",
    "import math\n\ndef maxProfit(k):\n    # Complete this function\n    profit = 0\n    for i in range(1,k):\n        profit = max(profit, max(i,k-i) * (k-i))\n    return profit\n\nif __name__ == \"__main__\":\n    print maxProfit(3)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    # @param {integer} k\n    # @param {TreeNode} root\n    # @return {integer}\n    def maxProfit(self, k, root):\n        # write your code here\n        if k <= 0:\n            return 0\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        if not root.left and root.right:\n            return max(self.maxProfit(k, root.right), root.val + root.right.val)\n        if root.left and not root.right:\n            return max(self.maxProfit(k, root.left), root.val + root.left.val)\n        if root.left and root.right:\n            return max(self.maxProfit(k, root.left), self.maxProfit(k, root.right), root.val + root.left.val + root.right.val)",
    "# Time:  O(n^2)\n# Space: O(n)\n\n# DFS\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        if k == 0:\n            return 0\n        if len(prices) < k:\n            return 0\n        \n        for i in range(len(prices) - k + 1):\n            cur_max = 0\n            for j in range(i, i + k):\n                cur_max += max(0, prices[j] - prices[j + 1])\n            max_profit = max(max_profit, cur_max)\n        return max_profit\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        if k == 0:\n            return 0\n        if len(prices) < k:\n            return 0\n        \n        for i in range(len(prices) - k + 1):\n            cur_max = 0\n            for j in range(i, i + k):\n                cur_max += max(0, prices[j] - prices[j + 1])\n            max_profit = max(max_profit, cur_max)\n        return max_profit\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if len(prices) < k:\n            return 0\n        \n        min_price = min(prices)\n        max_profit = 0\n        for i in range(len(prices) - k + 1):\n            cur_max = 0\n            for",
    "def maxProfit(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 0:\n        return 0\n    if n == 2:\n        return k\n    return max(maxProfit(n-1, k) + k, maxProfit(n-1, k-1) + k)\n\nprint maxProfit(3, 1)\nprint maxProfit(3, 2)\nprint maxProfit(3, 3)\nprint maxProfit(3, 4)\nprint maxProfit(3, 5)\nprint maxProfit(3, 6)\nprint maxProfit(3, 7)\nprint maxProfit(3, 8)\nprint maxProfit(3, 9)",
    "# -*- coding: utf-8 -*-\n\n# list of stock transactions\nstock_transactions = [\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    [1, 3, 5, 7, 9],\n    [2, 4, 6, 8],\n    [1, 2, 3, 4, 6, 8],\n    [1, 5, 6, 7, 8, 9, 10],\n    [1, 2, 3, 4, 5, 6, 7, 9],\n    [1, 2, 3, 4, 5, 6, 7, 8, 10],\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n]\n\n# function to find maximum profit\ndef max_profit(stock_transactions):\n    # list of profit and profit_max\n    profit = []\n    profit_max = 0\n    for i in range(len(stock_transactions)):\n        # list of stock transactions\n        stock_transactions_copy = stock_transactions[:]\n        stock_transactions_copy.pop(i)\n        stock_transactions_copy.sort()\n        stock_transactions_copy.reverse()\n        stock_transactions_copy.insert(0, stock_transactions[i][0])\n        stock_transactions_copy.insert(0, stock_transactions[i][-1])\n        stock_transactions_copy.sort()\n        stock_transactions_copy.reverse()\n        profit_tmp = 0\n        for j in range(len(stock_transactions_copy)):\n            if stock_transactions_copy[j] > stock_transactions_copy[j + 1]:\n                profit_tmp += stock_transactions_copy[j] - stock_transactions_copy[j + 1]\n        profit.append(profit_tmp)\n        if profit_tmp > profit_max:\n            profit_max = profit_tmp\n    return profit_max\n\n# test cases\nprint max_profit(stock_transactions)\nprint max_profit(stock_transactions[:1])\nprint max_profit(stock_transactions[:2])\nprint max_profit",
    "# Time:  O(k*n^2)\n# Space: O(k*n)\n\n# The max profit is the maximum of the following two cases:\n# 1. If we have a stock transaction, we need to sell the stock at the highest price to gain profit.\n# 2. If we don't have a stock transaction, we can only buy the stock at the lowest price to earn profit.\n#\n# For each stock transaction, we need to determine the profit we can achieve.\n# The profit we can achieve can be as small as 1, or as large as the maximum profit we can achieve.\n#\n# For example, consider the following transactions:\n# 1, 2, 3\n# 1, 3, 4\n# 1, 2, 5\n# If we have a stock transaction, we can sell the stock at the highest price to gain profit.\n# If we don't have a stock transaction, we can only buy the stock at the lowest price to earn profit.\n#\n# The profit we can achieve is at least 1.\n# The profit we can achieve is at most the maximum profit we can achieve.\n#\n# Note:\n# 1. The stock transactions will only be 1, 2, 3,..., k in the input.\n# 2. 1 <= k <= 1000\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices or not k:\n            return 0\n        if not prices:\n            return 0\n        if k == 1:\n            return max(prices[0] - prices[1], prices[0] - prices[1])\n        if k == 2:\n            return max(prices[0] - prices[1], prices[0] - prices[2])\n        if k == 3:\n            return max(prices[0] - prices[1], prices[0] - prices[2], prices[0] - prices[3])\n        if k == 4:\n            return max(prices[0] - prices[1], prices[0] - prices[2], prices[0] - prices[3], prices[0] - prices[4])\n        if k ==",
    "import math\n\ndef maxProfit(k):\n    \"\"\"\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if k == 1:\n        return 0\n    maxProfit = 0\n    for i in range(k):\n        maxProfit = max(maxProfit, (k - i) * (maxProfit + (k - i - 1) * (maxProfit + (k - i - 2) * (maxProfit + (k - i - 3)))) / 2)\n    return maxProfit\n\nif __name__ == '__main__':\n    k = int(input())\n    print(maxProfit(k))",
    "def maxProfit(k, price, low, high):\n    \"\"\"\n    :type k: int\n    :type price: List[int]\n    :type low: List[int]\n    :type high: List[int]\n    :rtype: int\n    \"\"\"\n    profit = 0\n    for i in range(k):\n        low[i] = price[i]\n        profit += max(0, high[i] - low[i])\n        high[i] = price[i]\n    return profit\n\nif __name__ == '__main__':\n    k = int(input())\n    price = [int(x) for x in input().split()]\n    low = [0] * k\n    high = [0] * k\n    maxProfit = maxProfit(k, price, low, high)\n    print(maxProfit)",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fileencoding=utf-8\n\nimport sys\n\ndef maxProfit(n, k):\n    # write your code here\n    dp = [0] * (k + 1)\n    for i in range(k + 1):\n        dp[i] = i * (i + 1)\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if dp[j] > i + dp[j - 1]:\n                dp[j] = i + dp[j - 1]\n    return dp[k]\n\nif __name__ == \"__main__\":\n    print maxProfit(10, 3)\n    print maxProfit(100, 100)\n    print maxProfit(101, 100)",
    "import collections\nimport heapq\n\ndef maxProfit(k, prices):\n    if len(prices) < k:\n        return 0\n    minProfit = 0\n    maxProfit = 0\n    heap = collections.deque()\n    heapq.heappush(heap, (0,0))\n    for i in range(k):\n        price = heapq.heappop(heap)\n        minProfit = max(minProfit, price[0])\n        maxProfit = max(maxProfit, price[0] + price[1])\n        heapq.heappush(heap, (price[0], price[1] + prices[i]))\n    return maxProfit\n\nif __name__ == '__main__':\n    k = int(input())\n    prices = list(map(int, input().rstrip().split()))\n    print(maxProfit(k, prices))",
    "import sys\n\n# Complete the maxProfit function below.\ndef maxProfit(k, arr):\n    maxProfit = 0\n    for i in range(len(arr)):\n        if i == 0:\n            maxProfit = max(maxProfit, arr[i])\n        else:\n            maxProfit = max(maxProfit, arr[i] + maxProfit(k - 1, arr[i:]))\n    return maxProfit\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6]\n    print(maxProfit(4, arr))",
    "# Your function will be called as such:\n# numProfit = maxProfit(k, prices)\n# The inputs will be represented as a list of integers\n# 0 <= k <= 100\n# The values in the list are non-negative integers\n# The list [0, -5, -3, 6, -4] represents the following transaction history:\n# -5 -> -3\n# -3 -> -1 -> -4\n# -1 -> -4\n# -4 -> 6\n# Your function should return the maximum profit.\n\n# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {integer} k\n    # @param {integer[]} prices\n    # @return {integer}\n    def maxProfit(self, k, prices):\n        # write your code here\n        if len(prices) == 0:\n            return 0\n        if len(prices) == 1:\n            return prices[0]\n        if k == 1:\n            return max(prices[0], max(prices[1], prices[2]))\n        if k == 2:\n            return max(prices[0], max(prices[1], max(prices[2], prices[3])))\n        ans = 0\n        for i in range(1, k):\n            ans = max(ans, max(prices[i-1], prices[i]) - prices[i])\n        return ans",
    "# O(N^2)\ndef maxProfit(k, transactions):\n    if len(transactions) <= 1:\n        return 0\n    if len(transactions) == 2:\n        return transactions[0][1] - transactions[1][1]\n    min_price = min(transactions)\n    max_profit = min_price[1]\n    for i in range(2, len(transactions)):\n        if min_price[1] > transactions[i][1]:\n            min_price = transactions[i]\n            max_profit = min_price[1]\n    for i in range(len(transactions)):\n        if transactions[i][1] > max_profit:\n            max_profit = transactions[i][1]\n    return max_profit\n\nif __name__ == \"__main__\":\n    print maxProfit(3, [\n        [1, 1],\n        [2, 1],\n        [3, 2],\n        [4, 1],\n        [5, 2],\n        [6, 1],\n        [7, 1],\n        [8, 3],\n        [9, 2],\n        [10, 2],\n        [11, 1],\n        [12, 1],\n        [13, 2],\n        [14, 1],\n        [15, 1],\n        [16, 2],\n        [17, 1],\n        [18, 1],\n        [19, 1],\n        [20, 1],\n        [21, 2],\n        [22, 1],\n        [23, 1],\n        [24, 2],\n        [25, 1],\n        [26, 1],\n        [27, 2],\n        [28, 1],\n        [29, 1],\n        [30, 2],\n        [31, 1],\n        [32, 1],\n        [33, 2],\n        [34, 1],\n        [35, 1],\n        [36, 2],\n        [37, 1],\n        [38, 1],\n        [39, 2],\n        [40, 1],\n        [41, 1],\n        [42, 2],\n        [43, 1],\n        [44, 1],",
    "def maxProfit(k, prices):\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(prices) - min(prices)\n    else:\n        if prices[k-1] > prices[k-2]:\n            return maxProfit(k-1, prices) + prices[k-1] - prices[k-2]\n        else:\n            return maxProfit(k-1, prices)\n\nprices = [1, 3, 2, 2, 4, 3, 1]\nprint(maxProfit(5, prices))",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(k + 1)]\n        for i in range(k + 1):\n            for j in range(i, k + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        return dp[k][k]\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxProfit(2) == 0\n    assert Solution().maxProfit(3) == 4\n    assert Solution().maxProfit(4) == 7",
    "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        if k == 1:\n            return max(prices[0] - min(prices[1:]), 0)\n        dp = [-1] * len(prices)\n        dp[0] = max(prices[0] - min(prices[1:]), 0)\n        for i in range(1, len(prices)):\n            dp[i] = max(dp[i - 1], dp[i - 1] + prices[i] - min(prices[:i]))\n        return max(dp)\n\ndef maxProfit(self, k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if not prices:\n        return 0\n    if k == 1:\n        return max(prices[0] - min(prices[1:]), 0)\n    dp = [0] * len(prices)\n    dp[0] = max(prices[0] - min(prices[1:]), 0)\n    for i in range(1, len(prices)):\n        dp[i] = max(dp[i - 1], dp[i - 1] + prices[i] - min(prices[:i]))\n    return max(dp)\n\n# Note:\n#   dp[i] is the maximum profit if you can buy at index i and sell at index i+1\n#   dp[i] = max(dp[i - 1] - prices[i - 1] + prices[i], dp[i - 1] + prices[i])\n#   dp[i] = max(dp[",
    "def maxProfit(k):\n    \"\"\"\n    :type k: int\n    :rtype: int\n    \"\"\"\n    \n    if k == 1:\n        return 0\n    \n    return maxProfit(k-1) + k",
    "def maxProfit(k, prices):\n    # Write your code here\n    if k==0:\n        return 0\n    else:\n        maxProfit = 0\n        for i in range(k):\n            maxProfit = max(maxProfit,maxProfit(k-1,prices))\n            if i==0:\n                maxProfit += prices[i]\n            else:\n                maxProfit = max(maxProfit,maxProfit(k-1,prices)-prices[i])\n        return maxProfit\n\n# Test Cases\nk=2\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))\nk=3\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))\nk=4\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))\nk=5\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))\nk=6\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))\nk=7\nprices=[5,10,3,15,7]\nprint(maxProfit(k,prices))",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {integer[]} prices\n    # @param {integer} k\n    # @return {integer}\n    def maxProfit(self, prices, k):\n        if len(prices) == 1:\n            return 0\n        if k == 1:\n            return max(prices) - min(prices)\n        if k == 2:\n            return max(prices[0], max(prices[1:])) - min(prices[:-1])\n        if len(prices) < k:\n            return 0\n        # left max, right max\n        left_max_profit = self.maxProfit(prices[:k-1], k-1)\n        right_max_profit = self.maxProfit(prices[k-1:], k-1)\n        return max(left_max_profit, right_max_profit) + max(prices[k-1], max(prices[k-2:]) - min(prices[:-k+1]))",
    "# https://www.codewars.com/kata/max-profit-from-k-stock-transactions/train/python\n\ndef max_profit(k, items):\n    # Write your code here\n    profit = 0\n    for i in range(k):\n        for j in range(i+1, k):\n            profit += items[j] - items[i]\n    return profit",
    "def maxProfit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if k <= 0:\n        return 0\n    maxProfit = 0\n    for i in range(k, len(prices)):\n        diff = prices[i] - prices[i - k]\n        if diff > 0:\n            maxProfit = max(maxProfit, diff)\n    return maxProfit\n\n# Note:\n# There is only one possible solution for this problem.\n# If you use the maxProfit function, you will find the maximum profit in a single transaction.\n# If you use the minProfit function, you will find the minimum profit in a single transaction.\n# If you use the maxProfit2 function, you will find the maximum profit in a multiple transactions.\n# If you use the minProfit2 function, you will find the minimum profit in a multiple transactions.",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @param k, integer\n    # @return an integer\n    def maxProfit(self, root, k):\n        if not root:\n            return 0\n        if not k:\n            return 0\n        if k == 1:\n            return max(root.val, root.val) - min(root.val, root.val)\n\n        max_profit = 0\n        max_profit_so_far = root.val\n        max_profit_so_far_left = self.maxProfit(root.left, k - 1)\n        max_profit_so_far_right = self.maxProfit(root.right, k - 1)\n        if max_profit_so_far_left > 0:\n            max_profit += max_profit_so_far_left\n        if max_profit_so_far_right > 0:\n            max_profit += max_profit_so_far_right\n\n        return max_profit",
    "# Returns the maximum profit\n# @param k: the number of stock transactions\n# @param prices: an array of price\ndef maxProfit(k, prices):\n    profit = 0\n    while k > 0:\n        k -= 1\n        if k > 0:\n            profit += prices[k]\n            k -= 1\n    return profit\n\nif __name__ == '__main__':\n    prices = [1, 2, 3, 4, 5]\n    print maxProfit(5, prices)",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        profit = 0\n        for i in xrange(k):\n            profit = max(profit, self.maxProfit(k-1))\n        return profit\n\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        for i in xrange(k):\n            max_profit = max(max_profit, self.maxProfit(k-1))\n        return max_profit\n\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return 1\n        max_profit = 0\n        for i in xrange(1, k):\n            max_profit = max(max_profit, self.maxProfit(k-1))\n        return max_profit",
    "# Your function should return the maximum profit.\n\n# Note:\n# The cost of each transaction is represented by a positive integer.\n# The cost of a transaction with cost = 0 is considered 0.\n# You may assume that the cost of all transactions taken is positive.\n\n# Example 1:\n# Input:\n# k = 2\n# [[1,0],[0,1]]\n# Output: 1\n# Explanation: The maximum profit is 1.\n# Example 2:\n# Input:\n# k = 3\n# [[1,0],[0,1],[0,1]]\n# Output: 3\n# Explanation: The maximum profit is 3.\n# Example 3:\n# Input:\n# k = 5\n# [[1,0],[0,1],[0,1],[0,1],[0,1]]\n# Output: 5\n# Explanation: The maximum profit is 5.\n# Example 4:\n# Input:\n# k = 1\n# [[1,0]]\n# Output: 0\n# Example 5:\n# Input:\n# k = 2\n# [[0,1],[1,0]]\n# Output: 1\n# Example 6:\n# Input:\n# k = 3\n# [[0,1],[1,0],[1,0]]\n# Output: 3\n# Example 7:\n# Input:\n# k = 5\n# [[0,1],[1,0],[1,0],[1,0],[1,0]]\n# Output: 5\n# Note:\n# 1 <= k <= 100\n# 0 <= k <= 100000\n\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if k == 0:\n            return 0\n        if len(prices) == 0:\n            return 0\n\n        max_profit = 0\n        max_profit_index = 0\n        max_profit_value = 0\n\n        for i in range(1, len(prices)):\n            max_profit_value = max(max_profit_value, prices[i] - prices[max_profit_index])\n            max_profit = max(max_profit, max_profit_value)\n            if prices[i] > prices[max_profit_index]:\n                max_profit_",
    "def maxProfit(stock, k):\n    \"\"\"\n    :type stock: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if k == 1:\n        return max(stock)\n    \n    maxProfit = 0\n    for i in range(k):\n        maxProfit = max(maxProfit, max(stock) - min(stock[i+1:]))\n    return maxProfit\n\nif __name__ == '__main__':\n    stock = [1, 2, 3, 4, 5]\n    k = 2\n    print(maxProfit(stock, k))",
    "def maxProfit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[float]\n    :rtype: int\n    \"\"\"\n    if k == 0:\n        return 0\n\n    # k is the number of transactions\n    # k - 1 is the number of transactions left\n    # k - 1 - 1 is the number of transactions not left\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0) is the maximum profit\n    \n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0)\n    # 1 - 1 - 1 is the number of transactions that were not purchased\n    # max(1 - 1 - 1, 0",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        profit = 0\n        sells = 0\n        sell_prices = [0] * k\n        for price in prices:\n            if sells < k:\n                sell_prices[sells] = price\n                sells += 1\n            else:\n                sell_prices[sells-1] = max(sell_prices[sells-1], price)\n                profit += sell_prices[sells-1] - sell_prices[sells-2]\n        return profit",
    "def max_profit(n, k):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(k):\n            dp[i] = max(dp[i], dp[i - j] + 1)\n    return dp[n]",
    "import sys\n\ndef maxProfit(k):\n    # write your code here\n    if k <= 0:\n        return 0\n    dp = [[0]*k for _ in xrange(k)]\n    for i in xrange(k):\n        dp[i][0] = 1\n        for j in xrange(i+1,k):\n            dp[i][j] = max(dp[i][j-1], dp[i][j-1]+1)\n    return dp[-1][-1]\n\nif __name__ == '__main__':\n    k = int(sys.argv[1])\n    print(maxProfit(k))",
    "import sys\n\ndef maxProfit(k):\n    if k == 1:\n        return 0\n    elif k == 2:\n        return k\n    else:\n        # find the maximum profit in the first k transactions\n        profit = k\n        for i in range(2, k+1):\n            # calculate the profit in the next k transactions\n            if i <= k-1:\n                profit = max(profit, k-i+1)\n            else:\n                break\n        return profit\n\nif __name__ == '__main__':\n    # test cases\n    cases = [\n        (1, 0),\n        (2, 2),\n        (3, 6),\n        (4, 12),\n        (5, 20),\n        (6, 24),\n        (7, 24),\n        (8, 24),\n        (9, 24),\n        (10, 24),\n        (11, 24),\n        (12, 24),\n        (13, 24),\n        (14, 24),\n        (15, 24),\n        (16, 24),\n        (17, 24),\n        (18, 24),\n        (19, 24),\n        (20, 24),\n        (21, 24),\n        (22, 24),\n        (23, 24),\n        (24, 24),\n        (25, 24),\n        (26, 24),\n        (27, 24),\n        (28, 24),\n        (29, 24),\n        (30, 24),\n        (31, 24),\n        (32, 24),\n        (33, 24),\n        (34, 24),\n        (35, 24),\n        (36, 24),\n        (37, 24),\n        (38, 24),\n        (39, 24),\n        (40, 24),\n        (41, 24),\n        (42, 24),\n        (43, 24),\n        (44, 24),\n        (45, 24),\n        (46, 24),\n        (47, 24),\n        (48, 24),\n        (49, 24),\n        (50, 24),\n        (51, 24),\n        (52, 24),\n        (53, 24),\n        (54, 24",
    "# https://www.hackerrank.com/challenges/maximizing-transactions/problem\n# https://www.hackerrank.com/challenges/maximizing-transactions/submissions/code/10381385\n\n# I didn't do the problem myself, but I did find a way to do it.\n\ndef maxProfit(k, prices):\n    # Your code should return the maximum profit.\n    # Note that the input prices is a list of integers\n    # and the output is a list of integers.\n    # For example, if prices = [10, 20, 30, 40], then the output should be [40, 40, 30, 20].\n    # If prices is empty, then the output should be empty.\n\n    # The idea is to keep track of the maximum profit for each stock and then\n    # keep track of the maximum profit for each day.\n    # For example, if prices = [10, 20, 30, 40], then the maximum profit for each day\n    # is [20, 20, 20, 20].\n    # Then, keep track of the maximum profit for each day and keep track of the maximum\n    # profit for each stock.\n    # For example, if prices = [10, 20, 30, 40], then the maximum profit for each day\n    # is [20, 20, 20, 20], and the maximum profit for each stock is [40, 40, 40, 40].\n    # If prices is empty, then the maximum profit for each stock is [0, 0, 0, 0].\n\n    # The time complexity is O(n^2) where n is the number of prices.\n    # The space complexity is O(n).\n\n    # You can think of the maximum profit as an integer \"value\" and the number of\n    # days as an integer \"count\".\n    # For example, if prices = [10, 20, 30, 40], then the maximum profit for each day\n    # is [20, 20, 20, 20], and the maximum profit for each stock is [40, 40, 40, 40].\n    # If prices is empty, then the maximum profit for each stock is [0, 0, 0, 0].\n    #\n    # Note:\n    # 1. The maximum profit for a stock is the maximum profit for",
    "import numpy as np\n\n# Example 1\n# Input: k = 2, prices = [1,2,5,4]\n# Output: 4\n# Example 2\n# Input: k = 3, prices = [1,2,3,4,5]\n# Output: 8\n# Example 3\n# Input: k = 4, prices = [1,2,3,4,5,6,7,8]\n# Output: 18\n\ndef max_profit(k, prices):\n    if k == 1:\n        return max(prices)\n    if k == 2:\n        return max(prices) - min(prices)\n    if k == 3:\n        return max(prices) - min(prices) + max(prices[2:])\n    if k == 4:\n        return max(prices) - min(prices) + max(prices[2:]) - max(prices[:2])\n    if k == 5:\n        return max(prices) - min(prices) + max(prices[2:]) - max(prices[:2]) - max(prices[3:])\n    if k == 6:\n        return max(prices) - min(prices) + max(prices[2:]) - max(prices[:2]) - max(prices[3:]) - max(prices[:3])\n    if k == 7:\n        return max(prices) - min(prices) + max(prices[2:]) - max(prices[:2]) - max(prices[3:]) - max(prices[:3]) - max(prices[4:])\n    if k == 8:\n        return max(prices) - min(prices) + max(prices[2:]) - max(prices[:2]) - max(prices[3:]) - max(prices[:3]) - max(prices[4:]) - max(prices[:4])\n\nprices = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(max_profit(3, prices))\n\nprices = [1, 2, 3, 4, 5, 6",
    "#!/usr/bin/python\n\nimport sys\n\ndef maxProfit(n, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return n\n    if k == 2:\n        return max(0, n-1)\n    if k > 2 and k <= n:\n        left = maxProfit(n, k-1)\n        right = maxProfit(n-k+1, k-1)\n        return max(left, right)\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    k = int(sys.stdin.readline())\n    print maxProfit(n, k)",
    "def max_profit(k, stock):\n    \"\"\"\n    :type k: int\n    :type stock: List[int]\n    :rtype: int\n    \"\"\"\n    if k == 1:\n        return max(stock)\n\n    low, high = 0, 0\n    for i in range(k):\n        if stock[i] > low:\n            low = stock[i]\n        elif stock[i] < high:\n            high = stock[i]\n\n    return max(low, high - stock[k - 1])\n\nif __name__ == \"__main__\":\n    print(max_profit(2, [5, 6, 4, 3, 2, 8]))\n    print(max_profit(3, [5, 6, 4, 3, 2, 8]))",
    "# https://www.hackerrank.com/challenges/max-profit\n\n# import math\n\n# def maxProfit(k, prices):\n#     if k == 1:\n#         return max(prices)\n#     else:\n#         return max(prices) + maxProfit(k-1, prices)\n\ndef maxProfit(k, prices):\n    # Returns the maximum profit possible in a k stock transaction\n    maxProfit = 0\n    for i in range(k):\n        maxProfit = max(maxProfit, maxProfit(k-1, prices[i:]))\n    return maxProfit\n\nif __name__ == '__main__':\n    k = int(input())\n    prices = list(map(int, input().rstrip().split(' ')))\n    print(maxProfit(k, prices))",
    "#!/usr/bin/python\n\nimport sys\n\ndef maxProfit(k, prices):\n    maxProfit = 0\n    for i in range(k, len(prices)):\n        for j in range(i, len(prices)):\n            if prices[j] > prices[i]:\n                maxProfit = max(maxProfit, prices[j] - prices[i])\n    return maxProfit\n\nif __name__ == '__main__':\n    n = int(sys.argv[1])\n    prices = map(int, raw_input().split())\n    print maxProfit(n, prices)",
    "# Your code here\n\ndef maxProfit(k, prices):\n    if k == 1:\n        return max(prices) - min(prices)\n    if k == 2:\n        return max(prices) - min(prices) + max(prices[0], prices[1])\n    if k == 3:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2])\n    if k == 4:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3])\n    if k == 5:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4])\n    if k == 6:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4], prices[5])\n    if k == 7:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4], prices[5], prices[6])\n    if k == 8:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4], prices[5], prices[6], prices[7])\n    if k == 9:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4], prices[5], prices[6], prices[7], prices[8])\n    if k == 10:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[2], prices[3], prices[4], prices[5], prices[6], prices[7], prices[8], prices[9])\n    if k == 11:\n        return max(prices) - min(prices) + max(prices[0], prices[1], prices[",
    "from collections import defaultdict\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        if k == 0:\n            return 0\n        res = 0\n        prices.sort()\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            else:\n                max_profit += min_price - prices[i]\n                min_price = prices[i]\n        return max_profit\n\n\nif __name__ == '__main__':\n    print Solution().maxProfit(2, [3, 4, 1, 2, 3])\n    print Solution().maxProfit(3, [2, 4, 1, 2, 3])",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) < k:\n            return 0\n        profit = 0\n        max_profit = 0\n        for i in range(k, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n            else:\n                profit += prices[i] - prices[i - 1] + 1\n            max_profit = max(max_profit, profit)\n        return max_profit",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        max_profit = 0\n        prices = [0] * k\n        for i in range(k):\n            prices[i] = i + 1\n        for i in range(k, len(prices)):\n            max_profit = max(max_profit, prices[i] - prices[i - 1])\n        return max_profit",
    "# max_profit(3, [1,2,1,3,2,5]) == 6\n\ndef max_profit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if not prices or k < 2:\n        return 0\n    dp = [0] * k\n    max_profit = 0\n    for i in range(k):\n        max_profit = max(max_profit, dp[i] + max(prices[i:]))\n        dp[i] = max_profit\n        for j in range(i+1, k):\n            dp[j] = max(dp[j], dp[i] + max(prices[j:]))\n    return max_profit\n\n# max_profit(3, [1,2,1,3,2,5]) == 6\n\n# max_profit(2, [1,2,1,3,2,5]) == 6\n\n# max_profit(3, [1,2,1,3,2,5]) == 6\n\n# max_profit(5, [1,2,1,3,2,5]) == 6\n\n# max_profit(6, [1,2,1,3,2,5]) == 6\n\n# max_profit(7, [1,2,1,3,2,5]) == 6\n\n# max_profit(8, [1,2,1,3,2,5]) == 6\n\n# max_profit(9, [1,2,1,3,2,5]) == 6\n\n# max_profit(10, [1,2,1,3,2,5]) == 6\n\n# max_profit(11, [1,2,1,3,2,5]) == 6\n\n# max_profit(12, [1,2,1,3,2,5]) == 6\n\n# max_profit(13, [1,2,1,3,2,5]) == 6\n\n# max_profit(14, [1,2,1,3,2,5]) == 6\n\n# max_profit(15, [1,2,1",
    "class Solution:\n    # @param {integer[]} prices\n    # @param {integer} k\n    # @return {integer}\n    def maxProfit(self, prices, k):\n        if k == 1:\n            return max(prices[1] - prices[0], 0)\n        if k == 2:\n            return max(prices[2] - prices[1], 0)\n        profit = 0\n        for i in range(1, len(prices) - k + 1):\n            for j in range(i + 1, i + k):\n                profit = max(profit, prices[i] - prices[j])\n        return profit\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxProfit([2, 3, 1], 2)\n    print s.maxProfit([2, 3, 1], 3)\n    print s.maxProfit([2, 3, 1], 4)\n    print s.maxProfit([1, 2, 3, 4], 1)\n    print s.maxProfit([1, 2, 3, 4], 2)\n    print s.maxProfit([1, 2, 3, 4], 3)\n    print s.maxProfit([1, 2, 3, 4], 4)\n    print s.maxProfit([1, 2, 3, 4, 5], 1)\n    print s.maxProfit([1, 2, 3, 4, 5], 2)\n    print s.maxProfit([1, 2, 3, 4, 5], 3)\n    print s.maxProfit([1, 2, 3, 4, 5], 4)\n    print s.maxProfit([1, 2, 3, 4, 5], 5)",
    "import sys\n\n# Complete the maxProfit function below.\ndef maxProfit(k):\n    profit = 0\n    arr = []\n    for i in range(k):\n        arr.append(0)\n    for i in range(k):\n        arr[i] += i\n    for i in range(k):\n        arr[i] += i\n    for i in range(k):\n        if i!= 0:\n            arr[i] = arr[i-1] + arr[i] - i\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:\n            arr[i] += arr[i-1]\n    for i in range(k):\n        if i!= 0:",
    "import collections\n\n# Your code here\nclass Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/max-profit-flip-k-cards/discuss/81621/Python-using-recursion-and-stacks-for-an-algorithm-for-flipping-k-cards\n        # recursion\n        def maxProfit(self, k):\n            if k == 0:\n                return 0\n            return max(self.maxProfit(k-1) - self.maxProfit(k-2), 0)\n        # stack\n        def maxProfit(self, k):\n            if k == 0:\n                return 0\n            return max(self.maxProfit(k-1) - self.maxProfit(k-2) + self.maxProfit(k-3), 0)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxProfit(5)",
    "# https://oj.leetcode.com/problems/max-profit/discuss/2496/C++-DP-solution-using-two-dimensions-with-a-binary-tree\n\n# https://www.youtube.com/watch?v=HhqxmNvZ7Yc\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0 or len(prices) == 0:\n            return 0\n        n = len(prices)\n        if k == 1:\n            return max(prices[0] - prices[1], 0)\n        if k == 2:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], 0))\n        if k == 3:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], max(prices[2] - prices[3], 0)))\n        if k == 4:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], max(prices[2] - prices[3], max(prices[3] - prices[4], 0))))\n        if k == 5:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], max(prices[2] - prices[3], max(prices[3] - prices[4], max(prices[4] - prices[5], 0))))\n        if k == 6:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], max(prices[2] - prices[3], max(prices[3] - prices[4], max(prices[4] - prices[5], max(prices[5] - prices[6], 0))))))\n        if k == 7:\n            return max(prices[0] - prices[1], max(prices[1] - prices[2], max(prices",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        \n        max_profit = 0\n        for i in range(len(prices)):\n            if i > 0:\n                max_profit = max(max_profit, prices[i] - prices[i-1])\n            else:\n                max_profit = max(max_profit, prices[i])\n        return max_profit\n\n# Note:\n# If the last price is same with the previous, then the profit is max_profit - price",
    "import sys\n\nclass Solution:\n    # @param {integer} k\n    # @param {integer} prices[]\n    # @return {integer}\n    def maxProfit(self, k, prices):\n        if k < 1:\n            return 0\n        max_profit = 0\n        profit = 0\n        for i in range(0, k):\n            profit = max(profit, prices[i] - max_profit)\n            max_profit = max(max_profit, profit)\n        return max_profit\n\nif __name__ == '__main__':\n    solution = Solution()\n    k, prices = map(int, sys.stdin.readline().strip().split(' '))\n    print solution.maxProfit(k, prices)",
    "import math\n\ndef maxProfit(k, prices):\n    \"\"\"\n    :type k: int\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if k == 1:\n        return 0\n    if k == 2:\n        return max(prices) - min(prices)\n    p = maxProfit(k - 1, prices)\n    for i in range(k - 1):\n        p = max(p, max(prices[i], prices[i + 1]) - min(prices[i], prices[i + 1]))\n    return p\n\nprint(maxProfit(3, [1, 2, 3]))",
    "# https://leetcode.com/problems/max-profit-ii/\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        profit = 0\n        max_profit = 0\n        i = 0\n        while i < len(prices):\n            max_profit = max(max_profit, prices[i] - prices[i - 1])\n            profit = max(profit, max_profit)\n            i += 1\n        return profit",
    "import math\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        profit = 0\n        for i in xrange(len(prices)):\n            if i == 0 or prices[i] - prices[i-1] > 0:\n                profit += prices[i] - prices[i-1]\n                max_profit = max(max_profit, profit)\n                profit = 0\n            else:\n                profit += prices[i] - prices[i-1]\n                max_profit = max(max_profit, profit)\n                profit = 0\n        return max_profit\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxProfit(2, [5, 3, 6, 2, -1])\n    print s.maxProfit(2, [5, 3, 6, 2, -2])\n    print s.maxProfit(2, [5, 3, 6, 2, -3])\n    print s.maxProfit(2, [5, 3, 6, 2, -4])\n    print s.maxProfit(2, [5, 3, 6, 2, -5])",
    "import sys\nimport math\nimport timeit\nimport os\nimport random\nimport string\n\ndef max_profit(k):\n    \"\"\"\n    :type k: int\n    :rtype: int\n    \"\"\"\n    stock_1 = 0\n    stock_2 = 0\n    stock_3 = 0\n    stock_4 = 0\n    stock_5 = 0\n    stock_6 = 0\n    stock_7 = 0\n    stock_8 = 0\n    stock_9 = 0\n    stock_10 = 0\n\n    stock_1 = stock_1 + 1\n    stock_2 = stock_2 + 1\n    stock_3 = stock_3 + 1\n    stock_4 = stock_4 + 1\n    stock_5 = stock_5 + 1\n    stock_6 = stock_6 + 1\n    stock_7 = stock_7 + 1\n    stock_8 = stock_8 + 1\n    stock_9 = stock_9 + 1\n    stock_10 = stock_10 + 1\n\n    profit_1 = stock_1 * stock_2\n    profit_2 = stock_2 * stock_3\n    profit_3 = stock_3 * stock_4\n    profit_4 = stock_4 * stock_5\n    profit_5 = stock_5 * stock_6\n    profit_6 = stock_6 * stock_7\n    profit_7 = stock_7 * stock_8\n    profit_8 = stock_8 * stock_9\n    profit_9 = stock_9 * stock_10\n\n    profit_10 = stock_10 * stock_1\n\n    profit_total = profit_1 + profit_2 + profit_3 + profit_4 + profit_5 + profit_6 + profit_7 + profit_8 + profit_9 + profit_10\n\n    return profit_total\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    start = timeit.default_timer()\n\n    k = int(input())\n    print(max_profit(k))\n\n    end = timeit.default_timer()\n    print(\"Time elapsed: \" + str(end - start))\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution:\n    # @param {integer} k\n    # @param {integer[]} prices\n    # @return {integer}\n    def maxProfit(self, k, prices):\n        if k > len(prices):\n            return 0\n        elif k == len(prices):\n            return max(prices)\n        else:\n            dp = [0] * k\n            dp[0] = max(prices[0], 0)\n            for i in range(1, k):\n                dp[i] = max(dp[i-1], dp[i-1] + prices[i])\n            return max(dp)\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxProfit(2, [7, 1, 5, 3, 6, 4])\n    print solution.maxProfit(3, [7, 1, 5, 3, 6, 4])\n    print solution.maxProfit(4, [7, 1, 5, 3, 6, 4])",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) <= k:\n            return 0\n        max_profit = 0\n        for i in xrange(k):\n            max_profit = max(max_profit, max(prices[:i]))\n            max_profit += min(prices[i+1:])\n        return max_profit\n\nif __name__ == '__main__':\n    print Solution().maxProfit(2, [1,2,3,4,5])\n    print Solution().maxProfit(3, [1,2,3,4,5])\n    print Solution().maxProfit(4, [1,2,3,4,5])",
    "def maxProfit(k, price, priceChange):\n    # write your code here\n    if k == 0:\n        return 0\n    elif k == 1:\n        return max(priceChange)\n    else:\n        maxProfit = 0\n        for i in xrange(k-1):\n            maxProfit = max(maxProfit, max(priceChange[i], priceChange[i+1]))\n        return maxProfit\n\nprint maxProfit(3, [1,2,3,4,5], [1,1,1,1,1,1,1,1,1,1])\nprint maxProfit(5, [1,2,3,4,5], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])\nprint maxProfit(10, [1,2,3,4,5], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])\nprint maxProfit(30, [1,2,3,4,5], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        if len(prices) == 0 or k == 0:\n            return max_profit\n        if k == 1:\n            max_profit = max(prices)\n            return max_profit\n        else:\n            min_price = prices[0]\n            max_profit = 0\n            for i in range(1, len(prices)):\n                max_profit = max(max_profit, prices[i] - min_price)\n                min_price = min(prices[i], min_price)\n            return max_profit",
    "#!/usr/bin/env python\n\ndef maxProfit(k, prices):\n    # write your code here\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(prices) - min(prices)\n    p = prices[0]\n    for i in range(1, k):\n        p = max(p, prices[i] - min(prices[0:i]))\n    return p\n\nif __name__ == '__main__':\n    print maxProfit(2, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(3, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(4, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(5, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(6, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(7, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(8, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(9, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(10, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(11, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(12, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(13, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit(14, [2, 3, 3, 4, 4, 5, 6, 6, 6, 6])\n    print maxProfit",
    "import heapq\n\ndef max_profit(k, prices):\n    max_profit = 0\n    if k > len(prices):\n        return max_profit\n    \n    heapq.heappush(prices, 0)\n    for i in range(k):\n        max_profit = max(max_profit, heapq.heappop(prices) + max_profit)\n    return max_profit\n\nif __name__ == '__main__':\n    prices = [10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 20, 20]\n    print max_profit(3, prices)",
    "import time\nstart_time = time.time()\n\nclass Solution:\n    # @param {integer} k\n    # @param {integer[]} prices\n    # @return {integer}\n    def maxProfit(self, k, prices):\n        if len(prices) <= 1:\n            return 0\n        if k == 0:\n            return 0\n        if k == 1:\n            return max(prices) - min(prices)\n        start = min(prices)\n        end = max(prices)\n        profit = 0\n        for i in range(k):\n            profit += max(end, start) - min(end, start)\n            start = max(end, start)\n            end = max(end, start)\n        return profit\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxProfit(0, [0, 0, 0, 0])\n    print s.maxProfit(1, [0, 1, 2, 0])\n    print s.maxProfit(2, [0, 0, 0, 0, 0, 0, 0, 0])\n    print s.maxProfit(3, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    print s.maxProfit(4, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    print s.maxProfit(5, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    print s.maxProfit(6, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    print s.maxProfit(7, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
    "import math\n\n# Recursive solution\ndef maxProfit(k, prices):\n    if k == 0:\n        return 0\n    else:\n        return maxProfit(k-1, prices) + max(prices[k-1], prices[k-1] + prices[k])\n\n# DP solution\ndef maxProfit_dp(k, prices):\n    profit = 0\n    for i in range(len(prices)):\n        for j in range(i+1, len(prices)):\n            if k > 0:\n                profit = max(profit, prices[i] + prices[j] - prices[k-1])\n            k -= 1\n    return profit\n\n# Dynamic Programming solution\ndef maxProfit_dp(k, prices):\n    profit = 0\n    # DP[i] stores the maximum profit for the first i transactions\n    dp = [0] * k\n    for i in range(k):\n        # DP[i] stores the maximum profit for the first i transactions\n        dp[i] = max(dp[i], prices[i])\n        # DP[i+1] stores the maximum profit for the first i transactions + the maximum profit from the i+1th transaction\n        dp[i+1] = max(dp[i+1], prices[i] + dp[i])\n    # DP[-1] stores the maximum profit for the last k transactions\n    dp[-1] = max(dp[-1], prices[-1])\n    return max(dp)\n\n# DP solution\ndef maxProfit_dp(k, prices):\n    profit = 0\n    # DP[i] stores the maximum profit for the first i transactions\n    dp = [0] * k\n    for i in range(k):\n        # DP[i] stores the maximum profit for the first i transactions\n        dp[i] = max(dp[i], prices[i])\n        # DP[i+1] stores the maximum profit for the first i transactions + the maximum profit from the i+1th transaction\n        dp[i+1] = max(dp[i+1], prices[i] + dp[i])\n    # DP[-1] stores the maximum profit for the last k transactions",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return 0\n\n        maxProfit = 0\n        for i in xrange(1, k + 1):\n            maxProfit = max(maxProfit, max(0, k - i) + k - i)\n        return maxProfit\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxProfit(1) == 0\n    assert Solution().maxProfit(2) == 0\n    assert Solution().maxProfit(3) == 3\n    assert Solution().maxProfit(4) == 3\n    assert Solution().maxProfit(5) == 7\n    assert Solution().maxProfit(6) == 7",
    "# Your code should complete in O(nk) time and O(1) memory.\n\ndef max_profit(n, k):\n    return max(max(max_profit_helper(n, k, [0]*n, [0]*n),\n                   max_profit_helper(n, k, [0]*(n-1), [1]*(n-1))),\n               max_profit_helper(n, k, [1]*(n-1), [0]*(n-1)))\n\ndef max_profit_helper(n, k, prices, profits):\n    if k == 0:\n        return profits[0]\n    if k == 1:\n        return max(profits[0], prices[0])\n    if k == 2:\n        return max(profits[0], profits[1], prices[0], prices[1])\n    if k == 3:\n        return max(profits[0], profits[1], profits[2], prices[0], prices[1], prices[2])\n    if k == 4:\n        return max(profits[0], profits[1], profits[2], profits[3], prices[0], prices[1], prices[2], prices[3])\n    return max(profits[0], profits[1], profits[2], profits[3], profits[4], prices[0], prices[1], prices[2], prices[3], prices[4])\n\n# Test Cases\n\ndef test_case0():\n    assert(max_profit(5, 0) == 0)\n\ndef test_case1():\n    assert(max_profit(5, 1) == 1)\n\ndef test_case2():\n    assert(max_profit(5, 2) == 1)\n\ndef test_case3():\n    assert(max_profit(5, 3) == 2)\n\ndef test_case4():\n    assert(max_profit(5, 4) == 3)\n\ndef test_case5():\n    assert(max_profit(5, 5) == 3)\n\ndef test_case6():\n    assert(max_profit(5, 6) == 3)\n\ndef test_case7():\n    assert(max_profit(5",
    "def maxProfit(stockTransaction):\n    \"\"\"\n    :type stockTransaction: List[int]\n    :rtype: int\n    \"\"\"\n    stockTransaction.sort()\n    maxProfit = 0\n    for i in range(len(stockTransaction)):\n        if i == 0:\n            maxProfit = stockTransaction[i]\n        else:\n            if stockTransaction[i] < stockTransaction[i-1]:\n                maxProfit += stockTransaction[i-1]\n            else:\n                maxProfit += stockTransaction[i]\n    return maxProfit\n\n\nif __name__ == '__main__':\n    stockTransaction = [1,3,5,6,8,10]\n    print(maxProfit(stockTransaction))\n\n    stockTransaction = [1,2,3,4,5,6]\n    print(maxProfit(stockTransaction))",
    "# Your function will take as its input an array of integers representing the number of\n# transactions of a given stock\n# and an integer representing the number of stocks\n# The function should return an integer representing the maximum profit\n#\n# Example 1:\n# Input:\n# nums = [2, 3, 1]\n# k = 2\n# Output: 3\n# Explanation:\n# The maximum profit is 3.\n# Example 2:\n# Input:\n# nums = [2, 2, 3, 3, 3, 1]\n# k = 2\n# Output: 6\n# Explanation:\n# The maximum profit is 6.\n# Example 3:\n# Input:\n# nums = [1, 2, 3]\n# k = 3\n# Output: 0\n# Explanation:\n# There is no transaction of value 3.\n# Example 4:\n# Input:\n# nums = [1, 2, 3]\n# k = 1\n# Output: 1\n# Explanation:\n# There is only one transaction of value 1,\n# and it is the only transaction of value 1.\n# Example 5:\n# Input:\n# nums = [1, 2, 3]\n# k = 0\n# Output: 0\n# Explanation:\n# There are no transactions of value 1,\n# and there is no transaction of value 3.\n\n\nclass Solution(object):\n    def maxProfit(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        min_profit = nums[0]\n        max_profit = nums[0]\n        for i in range(1, len(nums)):\n            if min_profit > nums[i]:\n                min_profit = nums[i]\n            if max_profit < nums[i]:\n                max_profit = nums[i]\n        return max_profit - min_profit",
    "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef max_profit(k, prices):\n    if k == 0:\n        return 0\n    return max_profit(k - 1, prices) + max(prices[k - 1:])\n\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# print max_profit(10, [1, 2,",
    "# https://oj.leetcode.com/problems/max-profit-partitioning/\n# Time:  O(k*n^2)\n# Space: O(k*n)\n\n# Greedy\n# Time:  O(k*n)\n# Space: O(n)\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        if k > len(prices):\n            return 0\n        for i in range(k):\n            if i == 0:\n                result = max(prices[i], result)\n            else:\n                result = max(prices[i], result + prices[i-1])\n        return result\n\n# My 2nd\n# Time:  O(k*n^2)\n# Space: O(k*n)\nclass Solution2(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        if k > len(prices):\n            return 0\n        for i in range(k):\n            if i == 0:\n                result = max(prices[i], result)\n            else:\n                result = max(prices[i], result + prices[i-1])\n        return result",
    "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if len(prices) == 0:\n            return 0\n\n        maxProfit = 0\n        minPrice = prices[0]\n        for i in xrange(1, len(prices)):\n            if prices[i] < minPrice:\n                minPrice = prices[i]\n            maxProfit += max(0, minPrice - prices[i])\n\n        return maxProfit\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxProfit(0, []) == 0\n    assert Solution().maxProfit(1, [1]) == 1\n    assert Solution().maxProfit(1, [1,2]) == 2\n    assert Solution().maxProfit(3, [3, 4, 5, 1, 2]) == 7\n    assert Solution().maxProfit(4, [1, 2, 3, 4, 5]) == 7",
    "class Solution(object):\n    def maxProfit(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return max(self.maxProfit(k - 1), self.maxProfit(k - 2))\n        profit = 0\n        while k > 1:\n            profit += self.maxProfit(k - 1)\n            k -= 1\n        return profit\n\nif __name__ == \"__main__\":\n    assert Solution().maxProfit(1) == 0\n    assert Solution().maxProfit(2) == 2\n    assert Solution().maxProfit(3) == 2\n    assert Solution().maxProfit(4) == 7\n    assert Solution().maxProfit(5) == 7\n    assert Solution().maxProfit(6) == 7\n    assert Solution().maxProfit(7) == 7\n    assert Solution().maxProfit(8) == 15\n    assert Solution().maxProfit(9) == 15",
    "class Solution:\n    # @param {integer} k\n    # @param {integer}[] price\n    # @return {integer}\n    def maxProfit(self, k, price):\n        if k == 0:\n            return 0\n        if k == 1:\n            return price[0]\n        if k == 2:\n            return max(price[1] - price[0], price[2] - price[1])\n        dp = [[0 for j in xrange(k+1)] for i in xrange(k+1)]\n        dp[0][0] = price[0]\n        dp[0][1] = price[1]\n        dp[0][2] = price[2]\n        for i in xrange(1, k+1):\n            for j in xrange(i+1, k+1):\n                if j == 1:\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + price[i]\n                elif j == 2:\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + price[i]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2], dp[i-2][j-1]) + price[i]\n        return dp[-1][-1]\n\ns = Solution()\nprint s.maxProfit(2, [4, 5, 7, 3, 6])",
    "class Solution:\n    # @param k, an integer\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, k, prices):\n        if len(prices) < k:\n            return 0\n        sell_price = prices[0]\n        sell_profit = 0\n        buy_price = prices[0]\n        buy_profit = 0\n        for i in range(1, k):\n            if sell_price > buy_price:\n                sell_profit += sell_price - buy_price\n                buy_price = sell_price\n                buy_profit = sell_profit\n            sell_price = prices[i]\n            sell_profit = 0\n            buy_price = prices[i]\n            buy_profit = 0\n        return sell_profit + buy_profit\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxProfit(1, [5, 7, 10])\n    print s.maxProfit(3, [2, 3, 7, 12, 15])\n    print s.maxProfit(4, [5, 7, 10, 15])\n    print s.maxProfit(6, [2, 3, 7, 12, 15, 20])"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}