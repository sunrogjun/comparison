{
  "problem": {
    "task_id": "MBPP/74",
    "prompt": "Write a function to check whether it follows the sequence given in the patterns array.",
    "canonical_solution": "def is_samepatterns(colors, patterns):    \r\n    if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True",
    "test_list": [
      "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ",
      "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ",
      "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False "
    ],
    "challenge_test_list": [],
    "problem_id": 63
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def check_follow_pattern(patterns, str):\n    for pattern in patterns:\n        if str.find(pattern)!= -1:\n            return True\n    return False\n\n# patterns = [\n#     'abc',\n#     'abb',\n#     'abcabb',\n#     'abbc',\n#     'abbbbc',\n#     'bbc',\n#     'bbb',\n#     'bbbabbb',\n#     'abbcabbc',\n#     'abbbbbbc',\n#     'abbbbbbbabbbbbbbbbbc',\n#     'abbbbbbbbbabbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "def check_following_sequence(patterns, n):\n    \"\"\"\n    :type patterns: List[str]\n    :type n: int\n    :rtype: bool\n    \"\"\"\n    following = [0] * n\n    following[0] = 1\n    for i in range(1, n):\n        following[i] = 0\n        for j in range(i):\n            following[i] += following[j]\n        following[i] %= 1000000007\n    for pattern in patterns:\n        for j in range(len(pattern)):\n            following[j] ^= pattern[j]\n    for i in range(n):\n        if following[i]!= 0:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    print(check_following_sequence([], 3))\n    print(check_following_sequence([], 4))\n    print(check_following_sequence([], 5))\n    print(check_following_sequence([], 6))\n    print(check_following_sequence([], 7))\n    print(check_following_sequence([], 8))\n    print(check_following_sequence([], 9))\n    print(check_following_sequence([], 10))\n    print(check_following_sequence([], 11))\n    print(check_following_sequence([], 12))\n    print(check_following_sequence([], 13))\n    print(check_following_sequence([], 14))\n    print(check_following_sequence([], 15))\n    print(check_following_sequence([], 16))\n    print(check_following_sequence([], 17))\n    print(check_following_sequence([], 18))\n    print(check_following_sequence([], 19))\n    print(check_following_sequence([], 20))\n    print(check_following_sequence([], 21))\n    print(check_following_sequence([], 22))\n    print(check_following_sequence([], 23))\n    print(check_following_sequence([], 24))\n    print(check_following_sequence([], 25))\n    print",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def checkInclusion(self, intervals, patterns):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # Use binary search to find the start and end of a given interval.\n        # If the start or end is not in the given interval, return False.\n        if len(intervals) == 0:\n            return False\n        start, end = intervals[0]\n        for i, pattern in enumerate(patterns):\n            if start > pattern[0] or end < pattern[1]:\n                return False\n            start, end = min(start, pattern[0]), max(end, pattern[1])\n        return True",
    "# https://leetcode.com/problems/check-binary-search-tree/discuss/152455/Java-O(n)-Time-O(n)-Space-O(n)-DP-solution\n# https://leetcode.com/problems/check-binary-search-tree/discuss/152456/Java-O(n)-Time-O(n)-Space-O(n)-DP-solution\n# https://leetcode.com/problems/check-binary-search-tree/discuss/152457/Java-O(n)-Time-O(n)-Space-O(n)-DP-solution\n# https://leetcode.com/problems/check-binary-search-tree/discuss/152458/Java-O(n)-Time-O(n)-Space-O(n)-DP-solution\n\nfrom common.tree_node import TreeNode\n\nclass Solution:\n    # @param root, a tree node\n    # @return a boolean\n    def isValidBST(self, root):\n        if root is None:\n            return True\n\n        if not self.isValidBST(root.left):\n            return False\n\n        if not self.isValidBST(root.right):\n            return False\n\n        return True\n\n    def isValidBST(self, root):\n        if root is None:\n            return True\n\n        if root.left is None:\n            return True\n\n        if root.val > root.left.val:\n            return False\n\n        return self.isValidBST(root.left) and self.isValidBST(root.right)\n\n\nif __name__ == '__main__':\n    solution = Solution()\n\n    root = TreeNode(10)\n    root.left = TreeNode(5)\n    root.right = TreeNode(15)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(20)\n\n    print(solution.isValidBST(root))",
    "def check_follows(patterns, string):\n    if len(string)!= len(patterns):\n        return False\n    for i in range(len(string)):\n        if string[i]!= patterns[i]:\n            return False\n    return True\n\n# Your CheckFollows function should accept the following arguments:\n# patterns: a list of strings\n# string: a string\n# Returns a boolean\n\ndef check_follows(patterns, string):\n    if len(string)!= len(patterns):\n        return False\n    for i in range(len(string)):\n        if string[i]!= patterns[i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    print(check_follows([], \"\"))\n    print(check_follows(['a'], \"aa\"))\n    print(check_follows(['a','b'], \"aabb\"))\n    print(check_follows(['a','b','c'], \"aabbcc\"))\n    print(check_follows(['a','b','c','d'], \"aabbccdd\"))",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven a string, check whether it follows the same pattern in a sequence of strings.\n\nThe pattern is a string of lowercase letters.\n\nThe string pattern can be empty, which means it follows any string.\n\nThe pattern string can have multiple letters in a row, such as \"ababbabc\", \"abc\".\n\nExample 1:\n\nInput:\npattern = \"abbbc\",\nstring = \"ababbabc\"\n\nOutput: true\nExplanation: The string \"ababbabc\" follows the pattern \"abbbc\".\n\nExample 2:\n\nInput:\npattern = \"aabbcc\",\nstring = \"ababbabc\"\n\nOutput: false\nExplanation: The string \"ababbabc\" doesn't follow the pattern \"aabbcc\".\n\nExample 3:\n\nInput:\npattern = \"aabbcc\",\nstring = \"aabbbcc\"\n\nOutput: true\nExplanation: The string \"aabbbcc\" follows the pattern \"aabbcc\".\n\nExample 4:\n\nInput:\npattern = \"aabbcc\",\nstring = \"ababbbcc\"\n\nOutput: false\nExplanation: The string \"ababbbcc\" doesn't follow the pattern \"aabbcc\".\n\nExample 5:\n\nInput:\npattern = \"aabbcc\",\nstring = \"abc\"\n\nOutput: true\nExplanation: The string \"abc\" follows the pattern \"aabbcc\".\n\"\"\"\n\n\nclass Solution:\n    # @param {string} pattern\n    # @param {string} string\n    # @return {boolean}\n    def checkPattern(self, pattern, string):\n        pattern_len = len(pattern)\n        string_len = len(string)\n        if pattern_len > string_len:\n            return False\n        for i in range(pattern_len):\n            if pattern[i]!= string[i]:\n                if i > 0 and pattern[i-1] == pattern[i]:\n                    continue\n                return False\n        return True\n\n    def checkPattern2(self, pattern, string):\n        pattern_len = len(pattern)\n        string_len = len(string",
    "#!/usr/bin/env python\n\nimport re\n\ndef is_valid(patterns, s):\n    if len(patterns) == 0:\n        return True\n    if len(s)!= len(patterns[0]):\n        return False\n    for i in range(len(patterns)):\n        if patterns[i] == s[i]:\n            continue\n        else:\n            return False\n    return True\n\ndef main():\n    patterns = [\"abcd\", \"dcba\", \"dcbac\", \"bac\", \"bcaa\", \"cbad\"]\n    s = \"dacdb\"\n    print is_valid(patterns, s)\n\nif __name__ == \"__main__\":\n    main()",
    "def check_follows_patterns(patterns, string):\n    if string == '':\n        return False\n\n    for pattern in patterns:\n        if string[0] == pattern[0]:\n            if pattern[1] == 0:\n                return True\n            elif string[0] == pattern[1]:\n                return check_follows_patterns(patterns, string[1:])\n            else:\n                return False\n        else:\n            if string[0] == pattern[2]:\n                return check_follows_patterns(patterns, string[1:])\n            else:\n                return False\n    return False\n\ndef check_follows_patterns_recursive(patterns, string):\n    if string == '':\n        return False\n\n    if check_follows_patterns_recursive(patterns, string[1:]):\n        return True\n\n    for pattern in patterns:\n        if string[0] == pattern[0]:\n            if pattern[1] == 0:\n                return True\n            elif string[0] == pattern[1]:\n                return check_follows_patterns_recursive(patterns, string[1:])\n            else:\n                return False\n        else:\n            if string[0] == pattern[2]:\n                return check_follows_patterns_recursive(patterns, string[1:])\n            else:\n                return False\n    return False\n\ndef check_follows_patterns_recursive_v2(patterns, string):\n    if string == '':\n        return False\n\n    if check_follows_patterns_recursive(patterns, string[1:]):\n        return True\n\n    for pattern in patterns:\n        if string[0] == pattern[0]:\n            if pattern[1] == 0:\n                return True\n            elif string[0] == pattern[1]:\n                return check_follows_patterns_recursive(patterns, string[1:])\n            else:\n                return False\n        else:\n            if string[0] == pattern[2]:\n                return check_follows_patterns_recursive(patterns, string[1:])\n            else:\n                return False\n    return",
    "def check_sequence(patterns, seq):\n    for i in range(len(patterns)):\n        if seq[i]!= patterns[i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    patterns = [2,3,5,6]\n    seq = [2,3,5,6,7,8]\n    print check_sequence(patterns, seq)",
    "#!/usr/bin/env python\n\nimport re\n\ndef check_follows_pattern(patterns, text):\n    \"\"\"\n    Check if text follows any of the patterns.\n\n    :param patterns: A list of patterns\n    :param text: Text to check\n    :return: True if the text follows any of the patterns, otherwise False.\n    \"\"\"\n    for pattern in patterns:\n        if re.search(pattern, text) is not None:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [\n        r\"^[a-zA-Z]+$\",\n        r\"^[a-zA-Z0-9]+$\"\n    ]\n    text = \"abcd\"\n    print check_follows_pattern(patterns, text)",
    "def check_sequence(patterns, s):\n    s_len = len(s)\n    for i in range(0, s_len):\n        if patterns[i][0]!= s[i]:\n            return False\n    return True\n\ndef main():\n    patterns = [['a', 'a'], ['a', 'b'], ['b', 'b'], ['b', 'a']]\n    s = 'ababbc'\n    print check_sequence(patterns, s)\n\nif __name__ == '__main__':\n    main()",
    "def check_patterns(patterns, s):\n    # print(s)\n    for pattern in patterns:\n        # print(pattern)\n        if pattern[0] == s[0]:\n            if pattern[1] == s[1]:\n                if pattern[2] == s[2]:\n                    if pattern[3] == s[3]:\n                        if pattern[4] == s[4]:\n                            if pattern[5] == s[5]:\n                                if pattern[6] == s[6]:\n                                    if pattern[7] == s[7]:\n                                        return True\n    return False\n\ndef test_check_patterns():\n    # test cases\n    patterns = [\n        [1,1,1,1,1],\n        [1,1,2,1,1],\n        [1,2,1,1,1],\n        [1,2,2,1,1],\n        [1,2,3,1,1],\n        [1,3,1,1,1],\n        [1,3,2,1,1],\n        [1,3,3,1,1],\n        [1,3,3,2,1],\n        [1,3,3,3,1],\n        [1,3,3,3,2],\n        [1,3,3,3,3],\n        [2,1,1,1,1],\n        [2,2,1,1,1],\n        [2,2,2,1,1],\n        [2,2,3,1,1],\n        [2,3,1,1,1],\n        [2,3,2,1,1],\n        [2,3,3,1,1],\n        [2,3,3,2,1],\n        [2,3,3,3,1],\n        [2,3,3,3,2],\n        [2,3,3,3,3],\n        [3,1,1,1,1],\n        [3,2,1,1,1],\n        [3,2,2,1,1],\n        [3,2,3,1,1",
    "# https://www.hackerrank.com/challenges/sudoku/problem\n\nimport unittest\nfrom typing import List\n\nclass Solution:\n    def checkValid(self, board: List[List[str]], patterns: List[List[str]]) -> bool:\n        def solve(board, pattern, pos):\n            if board[pos] == '.':\n                return False\n\n            if pattern[pos] == '.':\n                return True\n\n            if board[pos] == pattern[pos]:\n                return solve(board, pattern, pos + 1) or solve(board, pattern, pos - 1) or solve(board, pattern, pos + 3) or solve(board, pattern, pos + 2) or solve(board, pattern, pos - 2) or solve(board, pattern, pos - 3)\n            else:\n                return False\n\n        for pos in range(9):\n            if board[pos] == '.':\n                return solve(board, patterns[0], pos)\n\n        return False\n\n\nclass SolutionTest(unittest.TestCase):\n    def test_sample_input(self):\n        self.assertTrue(Solution().checkValid(\n            board=[['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.'],\n                   ['.','.','.','.','.','.','.','.']],\n            patterns=[['.','.','.','.','.','.','.','.'],\n                      ['.','.','.','.','.','.','.','.'],\n                      ['.','.','.','.','.','.','.','.'],\n                      ['.','.','.','",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def check(self, root: TreeNode, patterns: List[List[int]]):\n        \"\"\"\n        :type root: TreeNode\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not patterns:\n            return False\n        if root.val not in patterns[0]:\n            return self.check(root.left, patterns[1:])\n        if root.val not in patterns[-1]:\n            return self.check(root.right, patterns[:-1])\n        return True\n\n    # @param root, a tree node\n    # @param patterns, a list of list of integers\n    # @return a boolean\n    def check2(self, root, patterns):\n        if not root:\n            return True\n        if not patterns:\n            return False\n        if root.val not in patterns[0]:\n            return self.check2(root.left, patterns[1:])\n        if root.val not in patterns[-1]:\n            return self.check2(root.right, patterns[:-1])\n        return True\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n\n    print(Solution().check(root, [[1, 2, 3]]))\n    print(Solution().check(root, [[1, 2, 3], [2, 3, 4]]))\n    print(Solution().check(root, [[1, 2, 3], [2, 3, 4], [3, 4, 5]]))\n    print(Solution().check(root, [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]))\n    print(Solution",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: ListNode) -> bool:\n        def helper(head):\n            if not head:\n                return True\n            if head.next:\n                return helper(head.next)\n            if head.val == head.next.val:\n                return helper(head.next.next)\n            return False\n\n        return helper(head)",
    "import re\nimport unittest\n\n\ndef pattern_follows_sequence(patterns, string):\n    for pattern in patterns:\n        if re.search(pattern, string):\n            return True\n    return False\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertTrue(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabcabc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabcabcabc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabcabc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabc'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'a'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'aa'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'aaa'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'aaaaa'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'aaaa'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'a'))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], ''))\n        self.assertFalse(pattern_follows_sequence([r'a', r'b', r'c'], 'abcabcabcabc'",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return True\n        p = head\n        q = head\n        while p:\n            p = p.next\n            q = q.next\n            if p:\n                p = p.next\n            else:\n                break\n        \n        while q:\n            if p:\n                if q.val!= p.val:\n                    return False\n                p = p.next\n            q = q.next\n            if p:\n                p = p.next\n            else:\n                break\n        return True",
    "def check_pattern(patterns, s):\n    for i in range(0, len(patterns)):\n        if s[i] == patterns[i]:\n            continue\n        else:\n            return False\n    return True\n\ndef check_patterns(patterns, s):\n    for i in range(0, len(patterns)):\n        if check_pattern(patterns[i], s[i:]):\n            return True\n    return False\n\npatterns = [\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],\n    ['a','b','c",
    "# https://www.hackerrank.com/challenges/ctci-following-sequence/problem\n# https://www.codewars.com/kata/following-sequence-in-a-given-array/train/python\n\ndef is_following_sequence(sequence, patterns):\n    if len(sequence)!= len(patterns):\n        return False\n    for i in range(len(sequence)):\n        if sequence[i]!= patterns[i]:\n            return False\n    return True\n\ndef main():\n    patterns = [1, 2, 3, 1, 2]\n    sequence = [1, 2, 3, 1, 2]\n\n    print(is_following_sequence(sequence, patterns))\n\nif __name__ == \"__main__\":\n    main()",
    "# https://leetcode.com/problems/valid-anagram/description/\n\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(t):\n            return False\n        m = [[0] * len(t) for i in range(len(s))]\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if s[i] == t[j]:\n                    m[i][j] = 1\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if m[i][j]:\n                    for k in range(len(s)):\n                        if m[k][j] and s[k] == t[i]:\n                            m[k][j] = 0\n        for i in range(len(s)):\n            if m[i][0]:\n                return False\n        return True\n\n\ns = Solution()\nprint(s.isAnagram('anagram', 'nagaram'))",
    "# http://www.tutorialspoint.com/python/python_strings_and_regex.htm\ndef pattern_matching(patterns, string):\n    \"\"\"\n    patterns: list of strings\n    string: a string\n    return: boolean\n    \"\"\"\n    if not string:\n        return False\n    if not patterns:\n        return True\n    for pattern in patterns:\n        if string.find(pattern) >= 0:\n            return True\n    return False\n\n# https://stackoverflow.com/questions/22752729/how-to-check-if-a-string-is-a-valid-email-address-in-python\ndef is_email(email):\n    \"\"\"\n    email: string\n    return: boolean\n    \"\"\"\n    if len(email) > 0 and email[0] == '\"' and email[-1] == '\"':\n        email = email[1:-1]\n    if not email:\n        return False\n    if email[0] == '.':\n        return False\n    if '@' not in email:\n        return False\n    if '.' not in email:\n        return False\n    if'' not in email:\n        return False\n    if ',' not in email:\n        return False\n    if '..' in email:\n        return False\n    return True\n\n# https://stackoverflow.com/questions/19102085/how-to-check-if-string-is-a-valid-email-address-in-python\ndef is_email_address(email_address):\n    \"\"\"\n    email_address: string\n    return: boolean\n    \"\"\"\n    if email_address is None or email_address == \"\":\n        return False\n    if is_email(email_address):\n        return True\n    if email_address.find(\"@\") == -1:\n        return False\n    if email_address.find(\".\") == -1:\n        return False\n    if email_address.find(\" \")!= -1:\n        return False\n    if email_address.find(\".\")!= -1:\n        return False\n    if email_address.find(\"..\")!= -1:\n        return False\n    return True",
    "class Solution(object):\n    def checkPattren(self, patterns, s):\n        \"\"\"\n        :type patterns: List[List[str]]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0:\n            return s == ''\n        for pattern in patterns:\n            if len(pattern) == 1:\n                if s[:len(pattern)] == pattern:\n                    return True\n            elif len(pattern) == 2:\n                if s[:len(pattern)] == pattern[0] and s[-len(pattern):] == pattern[1]:\n                    return True\n            elif len(pattern) > 2:\n                if self.checkPattren(pattern[:len(pattern)-1], s[:len(pattern)-1]):\n                    return True\n                if self.checkPattren(pattern[1:], s[-len(pattern):]):\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.checkPattren([['a', 'b', 'c'], ['a', 'b'], ['a', 'c']])\n    print solution.checkPattren([['a'], ['a'], ['a']])\n    print solution.checkPattren([['a'], ['a']])",
    "import re\n\ndef check_patterns(patterns):\n    \"\"\"\n    Check whether it follows the sequence given in the patterns array.\n\n    Input:\n        patterns: a list of strings.\n    Output:\n        A boolean value, True if the pattern is followed, False otherwise.\n    \"\"\"\n    for pattern in patterns:\n        if re.match(pattern, '0'):\n            return True\n        else:\n            return False\n\nif __name__ == '__main__':\n    patterns = ['11', '10', '111', '110', '101', '100', '111', '110', '101', '100']\n    print check_patterns(patterns)\n    patterns = ['11', '10', '111', '110', '101', '100', '111', '110', '101', '100']\n    print check_patterns(patterns)\n    patterns = ['1', '0', '11', '10', '111', '110', '101', '100', '111', '110', '101', '100']\n    print check_patterns(patterns)",
    "def is_sorted(patterns):\n    sorted_list = sorted(patterns)\n    return sorted_list == patterns\n\ndef check(patterns, string):\n    \"\"\"\n    Check whether string follows the given pattern.\n    \"\"\"\n    if is_sorted(patterns):\n        for pattern in patterns:\n            if string.startswith(pattern):\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [['a', 'b', 'c'], ['c', 'a', 'b'], ['b', 'c', 'a']]\n    string = 'abbc'\n    assert check(patterns, string) == True\n    string = 'ccb'\n    assert check(patterns, string) == True\n    string = 'abc'\n    assert check(patterns, string) == False\n    string = 'abcba'\n    assert check(patterns, string) == False\n    string = 'abcba'\n    assert check(patterns, string) == True",
    "import re\nimport unittest\n\n\nclass Solution(object):\n    def is_pattern_match(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not patterns:\n            return True\n        if s == patterns[0]:\n            return True\n        return self.is_pattern_match(patterns[1:], s)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/pattern-matching/solution/\n\n# DFS\n# 4ms 100%\nclass Solution {\n    public boolean isPatternMatch(String[] patterns, String s) {\n        if (patterns.length == 0) return true;\n        if (s.length()!= patterns[0].length()) return false;\n        if (patterns.length == 1) return s.equals(patterns[0]);\n        if (s.equals(patterns[1])) return isPatternMatch(patterns, s.substring(1));\n        return isPatternMatch(patterns, s.substring(1)) && isPatternMatch(patterns, s.substring(0, s.length() - 1));\n    }\n}\n\n# DP\n# 11ms 98.39%\nclass Solution {\n    public boolean isPatternMatch(String[] patterns, String s) {\n        if (patterns == null || patterns.length == 0) return true;\n        if (s == null || s.length() == 0) return false;\n        int n = s.length();\n        int[][] dp = new int[patterns.length][n + 1];\n        for (int i = 0; i < patterns.length; i++) {\n            for (int j = 0; j < n; j++) {\n                if (patterns[i].charAt(j) == s.charAt(j)) dp[i][j + 1] = 1;",
    "def check_sequence(patterns, num):\n    \"\"\"\n    :type patterns: List[List[int]]\n    :type num: int\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return True\n    if num == 0:\n        return False\n    for i in range(len(patterns)):\n        if patterns[i][0] == 0:\n            if check_sequence(patterns[i:], num - 1):\n                return True\n        elif patterns[i][0] == 1:\n            if check_sequence(patterns[i:], num - 1):\n                return False\n    return True\n\n\n# Your CheckSequence object will be instantiated and called as such:\n# obj = CheckSequence()\n# param_1 = obj.check_sequence(patterns,num)",
    "def pattern_follows(patterns, target):\n    for pattern in patterns:\n        if target == pattern:\n            return True\n    return False\n\ndef pattern_follows_slow(patterns, target):\n    for pattern in patterns:\n        if target == pattern:\n            return True\n    return False\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert pattern_follows([1, 2, 3], 1), \"1 should follow 1, 2, 3\"\n    assert pattern_follows([1, 3, 2], 1), \"1 should follow 3, 2\"\n    assert pattern_follows([1, 2, 3], 3), \"3 should follow 1, 2, 3\"\n    assert not pattern_follows([1, 2, 3], 4), \"4 should not follow 1, 2, 3\"\n    assert not pattern_follows([1, 2, 3], 1), \"1 should not follow 1, 2, 3\"",
    "class Solution(object):\n    def checkPattren(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0:\n            return True\n\n        if len(s) < len(patterns[0]):\n            return False\n\n        for i in range(len(patterns[0])):\n            if patterns[0][i]!= s[i]:\n                return False\n\n        for pattern in patterns[1:]:\n            if len(s) < len(pattern):\n                return False\n\n            for i in range(len(pattern)):\n                if pattern[i]!= s[i]:\n                    return False\n\n        return True",
    "patterns = [\n    [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],\n    [1, 1, 1, 0, 1, 1, 1, 0, 1,",
    "import unittest\n\nfrom collections import defaultdict\n\n\nclass TestCases(unittest.TestCase):\n\n    def test_patterns_1(self):\n        self.assertTrue(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"]]))\n\n    def test_patterns_2(self):\n        self.assertTrue(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"]]))\n\n    def test_patterns_3(self):\n        self.assertTrue(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"]]))\n\n    def test_patterns_4(self):\n        self.assertTrue(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"]]))\n\n    def test_patterns_5(self):\n        self.assertTrue(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"], [\"C\", \"B\", \"A\"], [\"B\", \"A\", \"C\"]]))\n\n    def test_patterns_6(self):\n        self.assertFalse(is_sequence_valid([[\"A\", \"B\", \"C\"], [\"C\",",
    "class Solution:\n    # @param {string[]} patterns\n    # @param {string} s\n    # @return {boolean}\n    def checkPatterns(self, patterns, s):\n        if not patterns or len(s)!= len(patterns):\n            return False\n        for i in range(len(patterns)):\n            if s[i]!= patterns[i]:\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.checkPatterns([], \"a\") == False\n    assert s.checkPatterns([1], \"a\") == False\n    assert s.checkPatterns([1,2], \"a\") == False\n    assert s.checkPatterns([1,2,3], \"a\") == False\n    assert s.checkPatterns([1,2,3], \"aa\") == False\n    assert s.checkPatterns([1,2,3], \"aab\") == False\n    assert s.checkPatterns([1,2,3], \"aabb\") == False\n    assert s.checkPatterns([1,2,3,4], \"aabbcc\") == False\n    assert s.checkPatterns([1,2,3,4], \"aabbcccc\") == False\n    assert s.checkPatterns([1,2,3,4], \"aabbccdd\") == False\n    assert s.checkPatterns([1,2,3,4], \"aabbccdddd\") == False\n    assert s.checkPatterns([1,2,3,4,5], \"aabbccdddddd\") == False\n    assert s.checkPatterns([1,2,3,4,5], \"aabbccdddddeeeee\") == False\n    assert s.checkPatterns([1,2,3,4,5], \"aabbccdddddeeeeefffff\") == True\n    assert s.checkPatterns([1,2,3,4,5], \"aabbccdddddeeeeefffffaaaaabbbbbbbbbbbbb\") == True\n    assert s.checkPatterns([1,2,3,4,5], \"aabbccdddddeeeeefffffaaaa",
    "import re\n\n\ndef is_sequence(patterns, seq):\n    \"\"\"\n    :type patterns: list[str]\n    :type seq: str\n    :rtype: bool\n    \"\"\"\n    for pattern in patterns:\n        if re.match(pattern, seq):\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    patterns = [\"[a-z]*\", \"*\"]\n    seq = \"aaabbcc\"\n    print(is_sequence(patterns, seq))",
    "def check(patterns, seq):\n    s = len(seq)\n    if s == 0: return False\n    for i in range(s):\n        if patterns[i][0]!= seq[i]: return False\n    return True\n\ndef main():\n    patterns = [[0,0], [1,0], [0,1], [1,1]]\n    print(check(patterns, [1,0,0,0]))\n    print(check(patterns, [0,0,0,1]))\n    print(check(patterns, [1,0,0,1]))\n    print(check(patterns, [0,1,0,1]))\n    print(check(patterns, [1,1,0,0]))\n    print(check(patterns, [1,0,1,0]))\n    print(check(patterns, [0,1,1,0]))\n    print(check(patterns, [1,1,1,0]))\n    print(check(patterns, [1,0,1,1]))\n    print(check(patterns, [0,1,1,1]))\n    print(check(patterns, [1,1,1,1]))\n\nif __name__ == '__main__':\n    main()",
    "import re\nimport string\n\npatterns = [\n    [r\"a\", r\"b\", r\"c\", r\"d\", r\"e\", r\"f\", r\"g\", r\"h\", r\"i\", r\"j\", r\"k\", r\"l\", r\"m\", r\"n\", r\"o\", r\"p\", r\"q\", r\"r\", r\"s\", r\"t\", r\"u\", r\"v\", r\"w\", r\"x\", r\"y\", r\"z\"],\n    [r\"b\", r\"c\", r\"d\", r\"e\", r\"f\", r\"g\", r\"h\", r\"i\", r\"j\", r\"k\", r\"l\", r\"m\", r\"n\", r\"o\", r\"p\", r\"q\", r\"r\", r\"s\", r\"t\", r\"u\", r\"v\", r\"w\", r\"x\", r\"y\", r\"z\"],\n    [r\"c\", r\"d\", r\"e\", r\"f\", r\"g\", r\"h\", r\"i\", r\"j\", r\"k\", r\"l\", r\"m\", r\"n\", r\"o\", r\"p\", r\"q\", r\"r\", r\"s\", r\"t\", r\"u\", r\"v\", r\"w\", r\"x\", r\"y\", r\"z\"],\n    [r\"d\", r\"e\", r\"f\", r\"g\", r\"h\", r\"i\", r\"j\", r\"k\", r\"l\", r\"m\", r\"n\", r\"o\", r\"p\", r\"q\", r\"r\", r\"s\", r\"t\", r\"u\", r\"v\", r\"w\", r\"x\", r\"y\", r\"z\"],\n    [r\"e\", r\"f\", r\"g\", r\"h\", r\"i\", r\"j\", r\"k\", r\"l\", r\"m\", r\"n\", r\"o\", r\"p\", r\"q\", r\"r\", r\"s\", r\"t\", r\"u\", r\"v\", r\"w\", r\"x\", r\"y\", r\"z\"],\n    [r\"",
    "def check_sequence(patterns):\n    for pattern in patterns:\n        pattern_re = re.compile(pattern)\n        for line in sys.stdin:\n            line = line.strip()\n            if pattern_re.match(line) is None:\n                return False\n    return True\n\nif __name__ == \"__main__\":\n    patterns = [\n        '[A-Za-z]{1}',\n        '[0-9]{1}',\n        '[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}',\n        '[0-9]{1}[0-",
    "# https://leetcode.com/problems/check-if-a-binary-search-tree-is-bst/discuss/8812/Python-solution-with-explanation\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        # Recursive solution\n        # return self.isValidBSTRecursive(root)\n\n        # Iterative solution\n        # return self.isValidBSTIterative(root)\n\n    def isValidBSTRecursive(self, root):\n        if not root:\n            return True\n\n        left, right = root.left, root.right\n        # Check if the left subtree is valid BST\n        if not self.isValidBSTRecursive(left):\n            return False\n        # Check if the right subtree is valid BST\n        if not self.isValidBSTRecursive(right):\n            return False\n        # Check if the root is valid BST\n        return root.val <= max(left.val, right.val)\n\n    def isValidBSTIterative(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n\n        # Traverse left subtree\n        if not self.isValidBSTIterative(root.left):\n            return False\n        # Traverse right subtree\n        if not self.isValidBSTIterative(root.right):\n            return False\n        # Traverse the root\n        return root.val <= max(root.left.val, root.right.val)\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    print Solution().isValidBST",
    "import os\n\ndef check_follows(patterns, file_path):\n    \"\"\"\n    Check whether the file at file_path follows the pattern.\n\n    :param patterns: a list of patterns\n    :param file_path: the file to check\n    :return: boolean\n    \"\"\"\n    with open(file_path) as f:\n        for pattern in patterns:\n            if pattern not in f.read():\n                return False\n    return True\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    patterns = [\n        \"a\",\n        \"bb\",\n        \"ccc\"\n    ]\n    for p in patterns:\n        print(\"The file {0} follows the pattern {1}\".format(p, check_follows(patterns, p)))\n\nif __name__ == \"__main__\":\n    main()",
    "import re\n\ndef check_follows_sequence(patterns, s):\n    \"\"\"\n    :type patterns: List[str]\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if not s:\n        return False\n    return check_follows_sequence_recur(patterns, s, [])\n\n\ndef check_follows_sequence_recur(patterns, s, follow_stack):\n    \"\"\"\n    :type patterns: List[str]\n    :type s: str\n    :type follow_stack: List[str]\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return True\n    if len(patterns) == 1:\n        if patterns[0] == s:\n            return True\n    if len(follow_stack) == 0:\n        follow_stack.append(s)\n        return check_follows_sequence_recur(patterns[1:], follow_stack, follow_stack)\n    if not re.match(patterns[0], s):\n        return False\n    return check_follows_sequence_recur(patterns[1:], follow_stack, follow_stack)\n\n\nif __name__ == '__main__':\n    patterns = [\n        'abcd',\n        'abbc',\n        'abbbb',\n        'ababbbbb',\n        'abbbbbbbabbbbbbb',\n        'abbbbbbbbabbbbbbbbbabbbbbbbbbbbbbbbbbb',\n        'abbbbbbbbabbbbbbbbabbbbbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "import re\n\ndef check(patterns, text):\n    \"\"\"\n    :type patterns: List[str]\n    :type text: str\n    :rtype: bool\n    \"\"\"\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [\n        'abcd',\n        'ac',\n        'bacd',\n        'bcad',\n        'aacd',\n        'a',\n        'bc',\n        'abc',\n        'bca',\n        'acb',\n        'acd',\n        'adc',\n        'bcd',\n        'bca',\n        'bcad',\n        'aadc',\n        'bacd',\n        'abcad',\n        'abcd',\n        'acbd',\n        'acd',\n        'adc',\n        'adb',\n        'acdb',\n        'adbc',\n        'adbca',\n        'adbcad',\n        'abcd',\n        'abcd',\n        'adbca',\n        'acbcd',\n        'acbd',\n        'abcd',\n        'abcad',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',\n        'aacd',",
    "class Solution:\n    # @param {string[]} patterns\n    # @param {string} s\n    # @return {boolean}\n    def checkPatterns(self, patterns, s):\n        # write code here\n        if len(patterns) == 0:\n            return True\n        if s == patterns[0]:\n            return self.checkPatterns(patterns[1:], s[1:])\n        else:\n            return self.checkPatterns(patterns[1:], s)\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.checkPatterns([\"a\",\"b\"], \"b\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"c\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"a\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"abbc\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"ababbc\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"aabbbc\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"ababbbbccc\")\n    print solution.checkPatterns([\"a\",\"b\",\"c\"], \"ababbbbbbccc\")",
    "class Solution(object):\n    def checkPatterns(self, patterns):\n        \"\"\"\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not patterns: return True\n        s = [0] * len(patterns)\n        for i in range(len(patterns)):\n            for j in range(len(patterns[i])):\n                s[i] += patterns[i][j]\n            s[i] %= 1000000007\n        for i in range(len(patterns)):\n            if s[i]!= 0: return False\n        return True\n\na = Solution()\nprint(a.checkPatterns([[2,3,2,1],[1,2,1,2]]))\nprint(a.checkPatterns([[2,3,2,1],[1,2,1,1]]))",
    "def is_following_sequence(patterns, seq):\n    \"\"\"\n    patterns: list of lists of integers\n    seq: list of integers\n    return: True or False\n    \"\"\"\n    if len(seq)!= len(patterns):\n        return False\n    for i in range(len(seq)):\n        if seq[i]!= patterns[i][0] and patterns[i][0]!= patterns[i+1][0]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    patterns = [[0, 1, 1], [0, 1, 1], [1, 1, 0], [1, 1, 1]]\n    seq = [0, 0, 1, 1]\n    print(is_following_sequence(patterns, seq))",
    "class Solution(object):\n    def check(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0 or len(s) == 0:\n            return False\n        if s[0]!= patterns[0]:\n            return False\n        return self.check(patterns[1:], s[1:]) and self.check(patterns[:-1], s[:-1])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.check([\"abc\", \"def\", \"ghi\"], \"fghi\")\n    print sol.check([\"a\", \"ab\", \"abc\", \"b\"], \"cba\")\n    print sol.check([\"a\", \"b\", \"ab\", \"c\"], \"cba\")",
    "def is_sequence(patterns, sequence):\n    \"\"\"\n    Input:\n        patterns: A list of all possible sequences.\n        sequence: The sequence to check.\n\n    Output:\n        A boolean value.\n    \"\"\"\n\n    length = len(sequence)\n    for i in range(length):\n        if sequence[i] == patterns[i]:\n            continue\n        else:\n            return False\n\n    return True\n\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n\n    sequence = 'ABCD'\n    patterns = ['ABCD', 'ACBD', 'BACD', 'BCAD', 'ACDB', 'BDCA', 'BDCA']\n    print(is_sequence(patterns, sequence))\n\n\n\nif __name__ == \"__main__\":\n    main()",
    "def check_following(patterns, word):\n    for pattern in patterns:\n        if word == pattern:\n            return True\n        elif word.startswith(pattern):\n            return True\n        elif word.endswith(pattern):\n            return True\n    return False\n\ndef main():\n    patterns = [\n        \"ab\", \"aacg\", \"aca\", \"ace\", \"acg\", \"b\", \"c\", \"cgt\", \"t\", \"tt\",\n        \"atcga\", \"atgc\", \"cagt\", \"cat\", \"agt\", \"acgt\", \"act\", \"tga\", \"tat\",\n        \"aga\", \"agt\", \"aagga\", \"aagt\", \"agat\", \"catg\", \"tgga\", \"tggt\", \"ggat\",\n        \"gggt\", \"agct\", \"agtc\", \"aagc\", \"aagcg\", \"aaggc\", \"aaggt\", \"agtgg\", \"agtct\",\n        \"agctt\", \"aact\", \"aactg\", \"aagat\", \"aagatg\", \"agatgc\", \"agatgg\", \"agatct\",\n        \"agcttg\", \"agcttc\", \"agtatc\", \"agttac\", \"agttat\", \"agtatg\", \"agtatc\", \"agttag\",\n        \"agttat\", \"agtatg\", \"agttat\", \"agtttg\", \"agtttc\", \"agtctt\", \"agtctg\", \"agtctc\",\n        \"agtctt\", \"agcttg\", \"agcttc\", \"agcttt\", \"agcttgt\", \"agcttct\", \"agctctg\", \"agctctc\",\n        \"agctctt\", \"agctctg\", \"agctctc\", \"agctctt\", \"agcgtat\", \"agcgtac\", \"agcgtat\", \"agcgtgc\",\n        \"agcgtct\", \"agcgttg\", \"agcgttc\", \"agcgtct\", \"agcgctt\", \"agcgctg\", \"agc",
    "def is_sequence(patterns, s):\n    \"\"\"\n    :type patterns: List[List[str]]\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return False\n    if len(patterns) == 1:\n        return True\n    if s == patterns[0][0]:\n        return is_sequence(patterns[1:], s[1:])\n    else:\n        return is_sequence(patterns[1:], s)\n\nif __name__ == '__main__':\n    assert is_sequence(['a', 'b', 'c', 'd'], 'abbd') == True\n    assert is_sequence(['a', 'b', 'c', 'd'], 'acbd') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'acdb') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'adcb') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'adcb') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'aadc') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'aabb') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'ab') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'aabbbbbb') == False\n    assert is_sequence(['a', 'b', 'c', 'd'], 'abcccccc') == False",
    "def is_sequence(s, patterns):\n    \"\"\"\n    :type s: str\n    :type patterns: list[str]\n    :rtype: bool\n    \"\"\"\n    stack = []\n    for i in range(len(s)):\n        if i < len(patterns) and s[i] == patterns[i]:\n            stack.append(s[i])\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                if stack[-1]!= patterns[i]:\n                    return False\n                stack.pop()\n    return len(stack) == 0\n\ns = 'a'\npatterns = ['a','b','c']\n\nprint(is_sequence(s, patterns))",
    "import collections\n\nclass Solution:\n    def check(self, patterns: List[str], s: str) -> bool:\n        def is_valid(p: str, s: str) -> bool:\n            if p[0]!= s[0]:\n                return False\n            return all(i in 'abc' for i in p[1:])\n\n        def match_pattern(p: str, s: str) -> bool:\n            if p[0]!= s[0]:\n                return False\n            return all(i in 'abc' for i in p[1:])\n\n        return any(is_valid(pattern, s) for pattern in patterns) and any(match_pattern(pattern, s) for pattern in patterns)\n\ns = Solution()\nprint(s.check(['a','b','c'], 'a'))\nprint(s.check(['a','b','c'], 'ac'))\nprint(s.check(['a','b','c'], 'abc'))\nprint(s.check(['a','b','c'], 'aa'))\nprint(s.check(['a','b','c'], 'bb'))\nprint(s.check(['a','b','c'], 'bbb'))\nprint(s.check(['a','b','c'], 'bbbc'))\nprint(s.check(['a','b','c'], 'cc'))\nprint(s.check(['a','b','c'], 'ccccc'))\nprint(s.check(['a','b','c'], 'aab'))\nprint(s.check(['a','b','c'], 'abab'))\nprint(s.check(['a','b','c'], 'abbb'))\nprint(s.check(['a','b','c'], 'bbbb'))\nprint(s.check(['a','b','c'], 'babbb'))\nprint(s.check(['a','b','c'], 'bbbbb'))\nprint(s.check(['a','b','c'], 'babbbb'))\nprint(s.check(['a','b','c'], 'bbbbbb'))",
    "import re\nfrom collections import Counter\n\ndef check(patterns, s):\n    \"\"\"\n    :type patterns: List[str]\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return True\n\n    pattern = patterns[0]\n    pattern = re.compile(pattern)\n    match = pattern.match(s)\n    if match is None:\n        return False\n\n    if len(patterns) == 1:\n        return True\n\n    index = 1\n    while index < len(s):\n        if check(patterns[index:], s[index:]):\n            return True\n\n        index += 1\n    return False\n\nif __name__ == '__main__':\n    patterns = ['a', 'bb', 'b', 'ccc', 'cc']\n    s = 'abbbccccc'\n\n    print(check(patterns, s))",
    "def check_patterns(patterns):\n    for pattern in patterns:\n        if check_pattern(pattern):\n            return True\n    return False\n\ndef check_pattern(pattern):\n    return check_pattern_1(pattern) or check_pattern_2(pattern)\n\ndef check_pattern_1(pattern):\n    if pattern[0] == pattern[1]:\n        return True\n    if pattern[0] == pattern[2]:\n        return True\n    if pattern[0] == pattern[3]:\n        return True\n    if pattern[0] == pattern[4]:\n        return True\n    if pattern[0] == pattern[5]:\n        return True\n    if pattern[0] == pattern[6]:\n        return True\n    if pattern[0] == pattern[7]:\n        return True\n    if pattern[0] == pattern[8]:\n        return True\n    if pattern[0] == pattern[9]:\n        return True\n    if pattern[0] == pattern[10]:\n        return True\n    if pattern[0] == pattern[11]:\n        return True\n    if pattern[0] == pattern[12]:\n        return True\n    if pattern[0] == pattern[13]:\n        return True\n    if pattern[0] == pattern[14]:\n        return True\n    if pattern[0] == pattern[15]:\n        return True\n    if pattern[0] == pattern[16]:\n        return True\n    if pattern[0] == pattern[17]:\n        return True\n    if pattern[0] == pattern[18]:\n        return True\n    if pattern[0] == pattern[19]:\n        return True\n    if pattern[0] == pattern[20]:\n        return True\n    if pattern[0] == pattern[21]:\n        return True\n    if pattern[0] == pattern[22]:\n        return True\n    if pattern[0] == pattern[23]:\n        return True\n    if pattern[0] == pattern[24]:\n        return True\n    if pattern[0] == pattern[25]:\n        return True\n    if pattern[0] == pattern[26]:\n        return True\n    if pattern[0] == pattern[27]:\n        return True\n    if pattern[0]",
    "def check(patterns):\n\tif patterns == None:\n\t\treturn False\n\tfor pattern in patterns:\n\t\tif check_pattern(pattern, patterns):\n\t\t\treturn True\n\treturn False\n\ndef check_pattern(pattern, patterns):\n\tif pattern == None:\n\t\treturn False\n\tif pattern.startswith('|'):\n\t\treturn check_pattern(pattern[1:], patterns)\n\tif pattern.startswith('*'):\n\t\treturn check_pattern(pattern[1:], patterns)\n\tif pattern.startswith('?'):\n\t\treturn False\n\tif pattern.startswith('!'):\n\t\treturn True\n\tif pattern == '*':\n\t\treturn True\n\tif pattern == '?':\n\t\treturn False\n\tif pattern.startswith('/'):\n\t\treturn check_pattern(pattern[1:], patterns)\n\tif pattern.endswith('/'):\n\t\treturn check_pattern(pattern[:-1], patterns)\n\tif pattern.endswith('*'):\n\t\treturn check_pattern(pattern[:-1], patterns)\n\tif pattern.endswith('?'):\n\t\treturn False\n\tif pattern.endswith('!'):\n\t\treturn True\n\tif pattern.startswith('?') or pattern.startswith('!'):\n\t\treturn False\n\tif pattern.endswith('/'):\n\t\treturn False\n\tif pattern.startswith('/'):\n\t\treturn True\n\tif pattern.startswith('|'):\n\t\treturn False\n\treturn True\n\ndef test_patterns():\n\tassert check(['a']) == False\n\tassert check(['a', 'b']) == False\n\tassert check(['a', 'b', 'c']) == False\n\tassert check(['a', 'b', 'c', 'd']) == False\n\tassert check(['a', 'b', 'c', 'd', 'e']) == False\n\tassert check(['a', 'b', 'c', 'd', 'e', 'f']) == False\n\tassert check(['a', 'b', 'c', 'd', 'e', 'f', 'g']) == False\n\tassert check(['a',",
    "def check(patterns, s):\n    \"\"\"\n    :type patterns: List[str]\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    # Write your code here\n    return s == ''.join(reversed(patterns))\n\nif __name__ == '__main__':\n    patterns = ['abc', 'bcd', 'cde']\n    s = 'abcdefg'\n    print(check(patterns, s))\n    s = 'dabcdefg'\n    print(check(patterns, s))",
    "import unittest\n\nclass TestSequence(unittest.TestCase):\n    def test_sequence_1(self):\n        self.assertTrue(sequence([1,2,3], [1,3,2]))\n\n    def test_sequence_2(self):\n        self.assertTrue(sequence([1,2,3], [3,1,2]))\n\n    def test_sequence_3(self):\n        self.assertFalse(sequence([1,2,3], [2,1,3]))\n\n    def test_sequence_4(self):\n        self.assertFalse(sequence([1,2,3], [3,2,1]))\n\n    def test_sequence_5(self):\n        self.assertFalse(sequence([1,2,3], [1,3,2]))\n\n    def test_sequence_6(self):\n        self.assertFalse(sequence([1,2,3], [3,1,2]))\n\n    def test_sequence_7(self):\n        self.assertFalse(sequence([1,2,3], [3,2,1]))\n\n    def test_sequence_8(self):\n        self.assertFalse(sequence([1,2,3], [2,1,3]))\n\n    def test_sequence_9(self):\n        self.assertFalse(sequence([1,2,3], [3,2,1]))\n\n    def test_sequence_10(self):\n        self.assertFalse(sequence([1,2,3], [1,3,2]))\n\n    def test_sequence_11(self):\n        self.assertFalse(sequence([1,2,3], [3,1,2]))\n\n    def test_sequence_12(self):\n        self.assertFalse(sequence([1,2,3], [3,2,1]))\n\n    def test_sequence_13(self):\n        self.assertFalse(sequence([1,2,3], [2,1,3]))\n\n    def test_sequence_14(self):\n        self.assertFalse(sequence([1,2,3], [3,2,1]))\n\n    def test_sequence_15(self):\n        self.assertFalse",
    "# https://leetcode.com/problems/check-if-bst-is-balanced/discuss/7910/Python-solution-using-recursion-and-stack-in-O(n)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isBalancedRec(node):\n            if not node:\n                return True\n            if isBalancedRec(node.left):\n                if isBalancedRec(node.right):\n                    return True\n            return False\n        return isBalancedRec(root)",
    "def is_sequence(patterns, word):\n    for pattern in patterns:\n        if word.startswith(pattern):\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [\n        \"at\",\n        \"a\",\n        \"by\",\n        \"on\",\n        \"on\",\n        \"the\",\n        \"the\",\n        \"of\",\n        \"of\",\n        \"to\",\n        \"to\",\n        \"with\",\n        \"with\",\n        \"and\",\n        \"and\",\n        \"are\",\n        \"are\",\n        \"as\",\n        \"as\",\n        \"at\",\n        \"at\",\n        \"be\",\n        \"be\",\n        \"by\",\n        \"by\",\n        \"for\",\n        \"for\",\n        \"from\",\n        \"from\",\n        \"of\",\n        \"of\",\n        \"on\",\n        \"on\",\n        \"or\",\n        \"or\",\n        \"to\",\n        \"to\",\n        \"with\",\n        \"with\",\n        \"in\",\n        \"in\",\n        \"into\",\n        \"into\",\n        \"is\",\n        \"is\",\n        \"it\",\n        \"it\",\n        \"of\",\n        \"of\",\n        \"on\",\n        \"on\",\n        \"that\",\n        \"that\",\n        \"this\",\n        \"this\",\n        \"to\",\n        \"to\",\n        \"with\",\n        \"with\",\n        \"by\",\n        \"by\",\n        \"of\",\n        \"of\",\n        \"with\",\n        \"with\",\n        \"and\",\n        \"and\",\n        \"as\",\n        \"as\",\n        \"be\",\n        \"be\",\n        \"from\",\n        \"from\",\n        \"for\",\n        \"for\",\n        \"of\",\n        \"of\",\n        \"on\",\n        \"on\",\n        \"or\",\n        \"or\",\n        \"with\",\n        \"with\",\n        \"as\",\n        \"as\",\n        \"at\",\n        \"at\",\n        \"by\",\n        \"by\",\n        \"for\",\n        \"for\",",
    "#!/usr/bin/python\n\nimport re\nimport sys\n\n# Complete the following function\ndef is_pattern_follows(patterns, sequence):\n    if not sequence:\n        return False\n    if len(patterns) == 1:\n        return sequence[0] == patterns[0]\n    else:\n        for i in range(len(sequence)):\n            if is_pattern_follows(patterns[i], sequence[:i+1]):\n                return True\n    return False\n\n# Driver program\nif __name__ == \"__main__\":\n    fptr = open(sys.argv[1], \"r\")\n    patterns = []\n    for line in fptr:\n        patterns.append(line.strip())\n    sequence = []\n    for line in sys.stdin:\n        sequence.append(line.strip())\n    print is_pattern_follows(patterns, sequence)",
    "from collections import deque\nimport re\n\ndef is_pattern_followed(patterns, word):\n    word = word.lower()\n    if not patterns:\n        return True\n    if len(patterns) == 1:\n        return re.match(patterns[0], word)\n    if not word:\n        return False\n    pattern_queue = deque([word])\n    for pattern in patterns:\n        while pattern_queue:\n            next_word = pattern_queue.popleft()\n            if re.match(pattern, next_word):\n                pattern_queue.appendleft(next_word)\n                break\n            else:\n                if not next_word:\n                    return False\n                pattern_queue.appendleft(next_word)\n    return True\n\nif __name__ == \"__main__\":\n    patterns = [\n        \"ab\",\n        \"abc\",\n        \"bbb\",\n        \"cc\",\n        \"ddd\",\n        \"d\"\n    ]\n    word = \"bbbabbbabccdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",
    "def check(patterns, string):\n    \"\"\"\n    Check whether the string follows the given pattern.\n    \"\"\"\n    i = 0\n    for p in patterns:\n        if string[i]!= p[0]:\n            return False\n        i += 1\n    return True\n\n# Your CheckPatterns function should return true if it is passed valid input, and\n# false otherwise.",
    "from collections import Counter\n\ndef is_pattern_follows(patterns, text):\n    \"\"\"\n    :type patterns: List[str]\n    :type text: str\n    :rtype: bool\n    \"\"\"\n    counter = Counter(text)\n    for pattern in patterns:\n        if pattern in counter:\n            return True\n        if pattern == '*':\n            return False\n    return False\n\nif __name__ == '__main__':\n    text = 'abcabcabc'\n    patterns = [\n        'abc',\n        'abcabc',\n        'abcabcabcabc',\n        'abcabcabcabcabcabc',\n        'abcabcabcabcabcabcabcabc',\n        'abcabcabcabcabcabcabcabcabcabc',\n        'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc'\n    ]\n    print(is_pattern_follows(patterns, text))",
    "import re\nimport collections\n\n\ndef check_following_sequence(patterns, word):\n    \"\"\"\n    :type patterns: List[str]\n    :type word: str\n    :rtype: bool\n    \"\"\"\n    following_sequence = collections.deque()\n    for p in patterns:\n        following_sequence.append(word[:len(p)])\n        word = word[len(p):]\n\n    if not following_sequence:\n        return True\n    else:\n        if not following_sequence[0] == word:\n            return False\n        else:\n            return check_following_sequence(patterns[1:], word)\n\n\ndef main():\n    patterns = [\"\", \"\", \"\", \"\", \"\", \"\"]\n    word = \"following\"\n    print(check_following_sequence(patterns, word))\n\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def dfs(self, node, pattern):\n        if pattern is None:\n            return True\n        if pattern[0] == node.val:\n            if self.dfs(node.left, pattern[1:]):\n                return True\n            if self.dfs(node.right, pattern[1:]):\n                return True\n        return False\n\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if not self.dfs(root, [root.val]):\n            return False\n        return self.dfs(root, [root.val] + [root.left.val] + [root.right.val])\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(9)\n    print solution.isValidBST(root)",
    "def pattern_follows(patterns, string):\n    \"\"\"\n    :type patterns: List[str]\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    for pattern in patterns:\n        if pattern in string:\n            return True\n    return False\n\nif __name__ == '__main__':\n    patterns = [\n        \"abba\",\n        \"abcd\",\n        \"dcba\",\n        \"deac\",\n        \"cbadc\",\n        \"abcbc\",\n        \"ababcd\",\n        \"ababdc\",\n        \"acacb\",\n        \"cbcbcb\",\n        \"bacdbc\",\n        \"bacadc\",\n        \"acbcbd\",\n        \"bbcacd\",\n        \"abcdac\",\n        \"cbadac\",\n        \"dcbacd\",\n        \"cdcbac\",\n        \"cdcadc\",\n        \"cdbcad\",\n        \"cdbdac\",\n        \"abcdac\",\n        \"bacdbc\",\n        \"acbdbc\",\n        \"acdcdc\",\n        \"adcdbc\",\n        \"adcdac\",\n        \"adcdbd\",\n        \"adddbc\",\n        \"dbacdc\",\n        \"dbcdac\",\n        \"dbdacd\",\n        \"dbddbc\",\n        \"dbdbcd\",\n        \"dbdbdc\",\n        \"dbdcbd\",\n        \"dcdbac\",\n        \"dcdbbc\",\n        \"dcdbbd\",\n        \"dcddbc\",\n        \"dcddbd\",\n        \"dcddbc\",\n        \"dcddbd\",\n        \"dcdddbc\",\n        \"dcdddbd\",\n        \"dddbcd\",\n        \"dddbdc\",\n        \"dddcbd\",\n        \"ddddbc\",\n        \"ddddbd\",\n        \"dddddc\",\n        \"dddddd\"\n    ]\n\n    print(pattern_follows(patterns, \"dacdbd\"))",
    "class Solution:\n    def checkPatterns(self, patterns: List[List[int]]) -> bool:\n        \"\"\"\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0:\n            return True\n        \n        pattern_num = len(patterns)\n        max_num = 0\n        for i in range(pattern_num):\n            max_num = max(max_num, len(patterns[i]))\n        \n        max_num = max_num - 1\n        \n        # print(max_num)\n        \n        max_num_list = [0] * max_num\n        max_num_list[0] = 1\n        \n        for i in range(1, max_num):\n            max_num_list[i] = max_num_list[i-1] * 2\n        \n        \n        for i in range(pattern_num):\n            max_num_list[len(patterns[i])-1] -= 1\n            \n        for i in range(pattern_num):\n            for j in range(len(patterns[i])):\n                if patterns[i][j]!= max_num_list[j]:\n                    return False\n        \n        return True",
    "import re\n\n\ndef check_following_sequence(patterns):\n    \"\"\"\n    :type patterns: List[str]\n    :rtype: bool\n    \"\"\"\n    if not patterns:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[0]):\n        return False\n    if len(patterns) == 1:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[1]):\n        return False\n    if len(patterns) == 2:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[2]):\n        return False\n    if len(patterns) == 3:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[3]):\n        return False\n    if len(patterns) == 4:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[4]):\n        return False\n    if len(patterns) == 5:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[5]):\n        return False\n    if len(patterns) == 6:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[6]):\n        return False\n    if len(patterns) == 7:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[7]):\n        return False\n    if len(patterns) == 8:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[8]):\n        return False\n    if len(patterns) == 9:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[9]):\n        return False\n    if len(patterns) == 10:\n        return True\n    if not re.match(\"^[a-zA-Z]*$\", patterns[10",
    "from collections import deque\n\ndef valid_sequence(patterns, word):\n    \"\"\"\n    :type patterns: List[str]\n    :type word: str\n    :rtype: bool\n    \"\"\"\n    if not word:\n        return False\n\n    for pattern in patterns:\n        if not pattern:\n            continue\n\n        if word[0]!= pattern[0]:\n            return False\n\n        if len(word) == 1:\n            return True\n\n        if valid_sequence(patterns, word[1:]):\n            return True\n\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [\"abcd\", \"dcba\", \"dcbac\"]\n\n    word = \"dcbabcd\"\n    print(valid_sequence(patterns, word))\n\n    word = \"dcbabcd\"\n    print(valid_sequence(patterns, word))",
    "def check_patterns(patterns):\n    patterns = list(patterns)\n    for i in range(len(patterns)):\n        if patterns[i]!= patterns[i-1]:\n            return False\n    return True\n\ndef main():\n    patterns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(check_patterns(patterns))\n\nif __name__ == '__main__':\n    main()",
    "def check_patterns(patterns):\n    for i in range(len(patterns)):\n        for j in range(i + 1, len(patterns)):\n            if patterns[i] == patterns[j]:\n                return False\n    return True\n\ndef main():\n    patterns = [\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    print(check_patterns(patterns))\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    # @param patterns, a list of string\n    # @param s, a string\n    # @return a boolean\n    def checkPatterns(self, patterns, s):\n        for p in patterns:\n            if s.startswith(p):\n                return True\n        return False",
    "def check_patterns(patterns):\n    for i in range(len(patterns)):\n        if not check_pattern(patterns[i]):\n            return False\n    return True\n\ndef check_pattern(pattern):\n    if pattern[0] == pattern[1]:\n        return True\n    else:\n        return False\n\npatterns = [\n    \"ABCABC\",\n    \"AABBCC\",\n    \"ABCDBCD\"\n]\n\npatterns = [\n    \"ABCABC\",\n    \"ABCDBCD\",\n    \"AABBCC\"\n]\n\npatterns = [\n    \"ABCABC\",\n    \"AABBCC\",\n    \"ABCDBCD\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"ABCABC\",\n    \"AABBCC\",\n    \"ABCDBCD\"\n]\n\npatterns = [\n    \"ABCDBCD\",\n    \"AABBCC\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"\n]\n\npatterns = [\n    \"AABBCC\",\n    \"ABCDBCD\",\n    \"ABCABC\"",
    "def check_sequence(patterns, s):\n    \"\"\"\n    Returns True if the string s follows the sequence given in the patterns array.\n    Otherwise returns False.\n    \"\"\"\n\n    for pattern in patterns:\n        if s.startswith(pattern):\n            return True\n    return False\n\nif __name__ == '__main__':\n    patterns = [['ab', 'cde'], ['abc', 'def']]\n    s = 'abcde'\n    print check_sequence(patterns, s)",
    "# https://leetcode.com/problems/check-if-bst-is-balanced/discuss/136534/Python-with-Trie-and-Stack-and-Recursion\n# https://leetcode.com/problems/check-if-bst-is-balanced/discuss/136534/python-with-trie-and-stack-and-recursion-and-backtracking\n# https://leetcode.com/problems/check-if-bst-is-balanced/discuss/136534/python-with-trie-and-stack-and-recursion-and-backtracking\n\nclass Solution(object):\n    def isBalancedBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/check-if-bst-is-balanced/discuss/136534/python-with-trie-and-stack-and-recursion-and-backtracking\n        def is_balanced(root):\n            stack = []\n            if root is None:\n                return True\n            stack.append(root)\n            while len(stack) > 0:\n                node = stack.pop()\n                if node.left is None and node.right is None:\n                    return True\n                elif node.left is not None and node.right is not None:\n                    if node.left.val < node.right.val:\n                        stack.append(node.left)\n                    else:\n                        stack.append(node.right)\n                else:\n                    if node.left is not None:\n                        stack.append(node.left)\n                    else:\n                        stack.append(node.right)\n        return is_balanced(root)\n\nclass Solution(object):\n    def isBalancedBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/check-if-bst-is-balanced/discuss/136534/python-with-trie-and-stack-and-recursion-and-backtracking\n        def is",
    "def is_sorted(patterns):\n    for i in range(1, len(patterns)):\n        if patterns[i][0] < patterns[i-1][0]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    patterns = [\n        [1,3,1],\n        [1,2,1,2],\n        [1,2,2],\n        [1,3],\n        [1,4],\n        [2,3],\n        [2,4],\n        [3,4],\n        [1,1,1],\n        [1,1,2],\n        [1,2,1,2],\n        [1,2,2,2],\n        [1,3,1,2],\n        [1,3,2],\n        [1,3,3],\n        [1,4,1],\n        [1,4,2],\n        [1,4,3],\n        [1,4,4],\n        [2,1,1,2],\n        [2,1,2,2],\n        [2,2,2,2],\n        [2,3,2],\n        [2,4,2],\n        [3,1,1,2],\n        [3,1,2,2],\n        [3,2,2,2],\n        [3,3,2],\n        [3,4,2],\n        [4,1,1,2],\n        [4,1,2,2],\n        [4,2,2,2],\n        [4,3,2],\n        [4,4,2],\n    ]\n    print(is_sorted(patterns))",
    "import re\n\npatterns = [\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"C\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"A\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"T\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"G\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"G\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"T\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"A\"],\n    [r\"^[a-zA-Z]{3}$\", \"C\", \"C\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"A\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"T\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"G\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"C\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"G\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"A\"],\n    [r\"^[a-zA-Z]{3}$\", \"T\", \"T\"],\n    [r\"^[a-zA-Z]{3}$\", \"T\", \"A\"],\n    [r\"^[a-zA-Z]{3}$\", \"T\", \"C\"],\n    [r\"^[a-zA-Z]{3}$\", \"T\", \"G\"],\n    [r\"^[a-zA-Z]{3}$\", \"T\", \"T\"],\n    [r\"^[a-zA-Z]{3}$\", \"A\", \"A\"],\n    [r",
    "from collections import deque\nimport unittest\n\nclass Solution(object):\n    def checkPattern(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0:\n            return s == \"\"\n\n        stack = deque()\n        for i in xrange(len(patterns[0])):\n            if patterns[0][i] == \"^\":\n                stack.appendleft(\"\")\n            else:\n                stack.append(patterns[0][i])\n\n        while stack:\n            if s[0]!= stack.pop():\n                return False\n            if len(s) == 1:\n                return True\n            s = s[1:]\n\n        return False\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/check-pattern/solution/\n\n# 7ms 99.42%\nclass Solution {\n    public boolean checkPattern(String[] patterns, String s) {\n        if (patterns.length == 0) return s.length() == 0;\n        if (patterns.length == 1) return s.length() == 1 && patterns[0].equals(\"^\");\n\n        Deque<String> stack = new LinkedList<>();\n        for (String pattern : patterns[0].split(\"\")) {\n            if (pattern.equals(\"^\")) stack.add(\"\");\n            else stack.add(pattern);\n        }\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            if (s.length()!= 1 ||!stack.getLast().equals(\"\")) return false;\n            stack.removeLast();\n            sb.append(s.charAt(0));\n            s = s.substring(1);\n        }\n        return s.length() == 0;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public boolean checkPattern",
    "# http://www.geeksforgeeks.org/check-whether-a-given-sequence-follows-the-sequence-given-in-the-patterns/\n\n# TODO: write tests\n\ndef check_sequence(seq, pattern):\n    \"\"\"\n    Check whether seq follows the pattern.\n\n    Inputs:\n    seq - a string\n    pattern - a list of strings.\n\n    Outputs:\n    True or False\n    \"\"\"\n\n    for item in pattern:\n        if seq.startswith(item):\n            return True\n        else:\n            return False\n\n    return True\n\nif __name__ == '__main__':\n    # TODO: write tests\n    print(check_sequence(\"abc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aab\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"abb\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"ab\", [\"a\", \"b\"]))\n    print(check_sequence(\"ab\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"b\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"abcd\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"d\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"abb\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aaabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))\n    print(check_sequence(\"aabbcc\", [\"a\", \"b\", \"c\"]))",
    "#!/usr/bin/env python\n\ndef check_patterns(patterns):\n    pattern_string = \"\"\n    for p in patterns:\n        pattern_string += p[0]\n        pattern_string += p[1]\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"\n    pattern_string += \" \"",
    "import unittest\n\n# class Solution:\n#     # @param {string[]} patterns\n#     # @param {string} s\n#     # @return {boolean}\n#     def checkPatterns(self, patterns, s):\n#         \"\"\"\n#         :type patterns: List[str]\n#         :type s: str\n#         :rtype: bool\n#         \"\"\"\n#         if len(s) == 0:\n#             return False\n#         for pattern in patterns:\n#             if s.startswith(pattern):\n#                 return True\n#         return False\n\nclass Solution(object):\n    def checkPatterns(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        for pattern in patterns:\n            if s.startswith(pattern):\n                return True\n        return False\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/check-if-string-follows-the-pattern/solution/\n#\n# 1. BFS\n# 1.1 Using a list as a queue\n# 1.2 Start from the end of the string.\n# 1.3 If the string contains the pattern, return true.\n# 1.4 Otherwise, return false.\n# 1.5 When a pattern is found, move to the next position.\n# 1.6 When the end of the string is reached, return true.\n#\n# 1.1. Start from the end of the string.\n# 1.2. If the string contains the pattern, return true.\n# 1.3. Otherwise, return false.\n# 1.4. When a pattern is found, move to the next position.\n# 1.5. When the end of the string is reached, return true.\n#\n# Time:  O(n)\n# Space: O(n)\n#\nclass Solution",
    "import re\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def checkPattern(self, root, patterns):\n        \"\"\"\n        :type root: TreeNode\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        if not patterns:\n            return False\n\n        if root.val!= patterns[0][0]:\n            return False\n\n        return self.checkPattern(root.left, patterns[1:]) and self.checkPattern(root.right, patterns[1:])",
    "patterns = [\n    [0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,",
    "# -*- coding: utf-8 -*-\n\nimport re\nfrom collections import defaultdict\n\n\nclass Solution:\n    def isPattern(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # dp[i][j]: whether s[0:i] is pattern[0:j]\n        dp = [[False for _ in xrange(len(s))] for _ in xrange(len(patterns))]\n        for i, p in enumerate(patterns):\n            for j, c in enumerate(p):\n                if c == s[i]:\n                    dp[i][j] = True\n        return dp[0][0]\n\n    def isPattern2(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # dp[i][j]: whether s[0:i] is pattern[0:j]\n        dp = [[False for _ in xrange(len(s))] for _ in xrange(len(patterns))]\n        for i, p in enumerate(patterns):\n            for j, c in enumerate(p):\n                if c == s[i]:\n                    dp[i][j] = True\n        return dp[0][0]\n\n    def isPattern3(self, patterns, s):\n        \"\"\"\n        :type patterns: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # dp[i][j]: whether s[0:i] is pattern[0:j]\n        dp = [[False for _ in xrange(len(s))] for _ in xrange(len(patterns))]\n        for i, p in enumerate(patterns):\n            for j, c in enumerate(p):\n                if c == s[i]:\n                    dp[i][j] = True\n        return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    # patterns = [\n    #     \"ABAB\",",
    "def pattern_follows(patterns, s):\n    for i in range(len(s)):\n        for j in range(len(patterns)):\n            if s[i] == patterns[j][0]:\n                if pattern_follows(patterns[j][1:], s[i+1:]) is True:\n                    return True\n    return False\n\n#patterns = [['a','b'],['a','b','a'],['a','b','c']]\n#s = 'bacd'\n#pattern_follows(patterns, s)",
    "def is_pattern_followed(patterns, word):\n    \"\"\"\n    :type patterns: list[str]\n    :type word: str\n    :rtype: bool\n    \"\"\"\n    # base cases\n    if word == '':\n        return True\n    if len(word) == 1:\n        return patterns[word[0]]\n    if word[0] not in patterns:\n        return False\n    return is_pattern_followed(patterns, word[1:]) or is_pattern_followed(patterns, word[1:])\n\ndef main():\n    patterns = [\n        'abcde',\n        'bcde',\n        'cde',\n        'de',\n        'abcde',\n        'abcde'\n    ]\n    word = 'abcde'\n    print('The word', word, 'follows the following pattern?', is_pattern_followed(patterns, word))\n\nif __name__ == '__main__':\n    main()",
    "#!/bin/python\n\n# https://www.hackerrank.com/challenges/patterns-in-a-string/problem\n\n# Write a function to check whether a given string follows the given sequence.\n# A valid string must follow the sequence at the beginning, and the sequence at the end.\n\n# Example\n# Input:\n# patterns = [\n#     'abcd',\n#     'bcd',\n#     'abc',\n#     'ab',\n#     'cde',\n#     'def',\n#     'def'\n# ]\n# Input:\n# s = 'abcdef'\n# patterns = [\n#     'abcdef',\n#     'bcdef',\n#     'cdef',\n#     'def',\n#     'ef',\n#     'f'\n# ]\n# Output: True\n# Explanation: 'abcdef' is a valid string with the given pattern.\n\n# Note:\n# The string s will have length in range [1, 500].\n# The pattern array patterns will have length in range [1, 500].\n# The pattern array patterns will only contain lowercase letters.\n\nclass Solution(object):\n    def checkPatterns(self, s, patterns):\n        \"\"\"\n        :type s: str\n        :type patterns: List[str]\n        :rtype: bool\n        \"\"\"\n        # If s is empty, return false.\n        if len(s) == 0:\n            return False\n        # If patterns is empty, return true.\n        if len(patterns) == 0:\n            return True\n\n        # If the first pattern is empty, return true.\n        if len(patterns[0]) == 0:\n            return True\n\n        # If s does not start with the first pattern, return false.\n        if s[0]!= patterns[0]:\n            return False\n\n        # If the second pattern is empty, return true.\n        if len(patterns[1]) == 0:\n            return True\n\n        # If s does not end with the second pattern, return false.\n        if s[-1]!= patterns[1]:\n            return False\n\n        # Otherwise, return true.\n        return True\n\nif __name__ == \"__main__\":",
    "# https://leetcode.com/problems/follow-the-sequence/description/\n\nclass Solution(object):\n    def isFollowingPattern(self, patterns, target):\n        \"\"\"\n        :type patterns: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if len(patterns) == 0:\n            return False\n\n        n = len(patterns)\n\n        def is_subsequence(pattern):\n            for i in range(len(pattern)):\n                if pattern[i]!= target[i]:\n                    return False\n            return True\n\n        for i in range(n):\n            if is_subsequence(patterns[i]):\n                if i == 0:\n                    return True\n                else:\n                    if is_subsequence(patterns[i - 1]):\n                        return True\n                    else:\n                        return False\n            else:\n                return False",
    "import re\nimport unittest\n\n\nclass Solution:\n    def checkPatterns(self, patterns: List[List[int]]) -> bool:\n        def is_valid(s):\n            if s is None or len(s) == 0:\n                return False\n            s = list(s)\n            for p in patterns:\n                if s[:len(p)] == p:\n                    return True\n            return False\n\n        return all(is_valid(s) for s in patterns)\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([[1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]], True)\n        self._test([[1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7]], False)\n\n    def _test(self, patterns, expected):\n        actual = Solution().checkPatterns(patterns)\n        self.assertEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def check(patterns, words):\n    \"\"\"\n    :type patterns: List[str]\n    :type words: List[str]\n    :rtype: bool\n    \"\"\"\n    result = True\n    for p, w in zip(patterns, words):\n        if w[-len(p):]!= p:\n            result = False\n    return result\n\nif __name__ == '__main__':\n    patterns = [\n        'abcd',\n        'cabd',\n        'cdab',\n        'bacd',\n        'bcda',\n        'adcb',\n        'adca',\n        'adbc',\n        'acbd',\n        'acbd',\n        'cbad',\n        'badc',\n        'bacd',\n        'badc',\n        'abcd',\n        'abcde',\n        'abcd',\n        'abcd',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abcde',\n        'abc",
    "def check_patterns(patterns):\n    for pattern in patterns:\n        if pattern[0] == pattern[1]:\n            return True\n    return False\n\ndef main():\n    patterns = [\n        [1, 2, 3, 4, 5, 6],\n        [1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1",
    "def is_sequence(patterns, s):\n    \"\"\"\n    :type patterns: List[str]\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if not patterns:\n        return True\n    if s == patterns[0]:\n        return is_sequence(patterns[1:], s[1:])\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    patterns = [\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",\n        \"SAP\",",
    "# https://leetcode.com/problems/valid-anagram/\n\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(t):\n            return False\n        dict = {}\n        for c in s:\n            if c not in dict:\n                dict[c] = 1\n            else:\n                dict[c] += 1\n        for c in t:\n            if c not in dict:\n                return False\n            else:\n                if dict[c] > 1:\n                    return False\n                dict[c] -= 1\n        return True",
    "import re\ndef pattern_match(pattern, string):\n    \"\"\"\n    pattern: string of characters, e.g. 'abcd'\n    string: string to be checked against the pattern, e.g. 'abcdef'\n    \"\"\"\n    for i in range(len(pattern)):\n        if pattern[i] == string[i]:\n            continue\n        else:\n            return False\n    return True\n\npatterns = [\n    [ \"ab\", \"bc\", \"cd\", \"da\", \"ac\", \"bc\" ],\n    [ \"bcd\", \"cd\", \"dc\", \"da\", \"ad\", \"bc\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\", \"e\", \"f\" ],\n    [ \"bc\", \"c\", \"d\", \"e\" ],\n    [ \"bcd\", \"cd\", \"d\", \"e\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\" ],\n    [ \"ab\", \"bc\", \"cd\", \"da\", \"ac\", \"bc\" ],\n    [ \"bcd\", \"cd\", \"dc\", \"da\", \"ad\", \"bc\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\", \"e\", \"f\" ],\n    [ \"bc\", \"c\", \"d\", \"e\" ],\n    [ \"bcd\", \"cd\", \"d\", \"e\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\" ],\n    [ \"ab\", \"bc\", \"cd\", \"da\", \"ac\", \"bc\" ],\n    [ \"bcd\", \"cd\", \"dc\", \"da\", \"ad\", \"bc\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\", \"e\", \"f\" ],\n    [ \"bc\", \"c\", \"d\", \"e\" ],\n    [ \"bcd\", \"cd\", \"dc\", \"da\", \"ad\", \"bc\" ],\n    [ \"bcde\", \"cde\", \"de\", \"d\" ],\n    [ \"ab\", \"bc\", \"cd\", \"da\", \"ac\", \"bc\" ],\n    [ \"bcd\", \"cd\", \"dc\", \"da\", \"ad\", \"bc\" ],",
    "def check_follows_pattern(patterns, sequence):\n    \"\"\"\n    :type patterns: List[str]\n    :type sequence: str\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return sequence == ''\n    elif len(patterns) == 1:\n        return sequence == patterns[0]\n    else:\n        return any(map(lambda x: x in sequence, patterns))\n\n\ndef check_follows_pattern2(patterns, sequence):\n    \"\"\"\n    :type patterns: List[str]\n    :type sequence: str\n    :rtype: bool\n    \"\"\"\n    if len(patterns) == 0:\n        return sequence == ''\n    elif len(patterns) == 1:\n        return sequence == patterns[0]\n    else:\n        return sequence.startswith(patterns[0]) or sequence.endswith(patterns[-1])\n\n\nif __name__ == '__main__':\n    patterns = [\n        '',\n        'ab',\n        'abc',\n        'abcd',\n        'abbc',\n        'abbcabbc',\n        'abbcabbcabbcabbcabbc',\n        'abbcabbcabbcabbcabbcabbcabbcabbc',\n        'abbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbcabbc",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root, patterns):\n        \"\"\"\n        :type root: TreeNode\n        :type patterns: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if len(patterns) == 0:\n            return True\n        for i in range(len(patterns)):\n            if root.val < patterns[i][0]:\n                return False\n            if root.val > patterns[i][len(patterns[i])-1]:\n                return False\n        return self.isValidBST(root.left, patterns[:i]) and self.isValidBST(root.right, patterns[i:])",
    "# import the library\nimport re\nimport sys\n\n# define the pattern\npatterns = [\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3, 4, 5],\n    [1, 2, 3,",
    "def check(patterns, str):\n    if str == '':\n        return True\n    for pattern in patterns:\n        if str[0] == pattern[0] and str[1] == pattern[1]:\n            return check(patterns, str[2:])\n        else:\n            return False\n\npatterns = [['a', 'b'], ['c'], ['a', 'b'], ['d']]\n\nstr = 'bbbbb'\n\nprint(check(patterns, str))",
    "def is_sequence(n, patterns):\n    if n == 1:\n        return True\n    elif patterns[n-1] == 0:\n        return False\n    else:\n        return is_sequence(n-1, patterns)\n\ndef test_is_sequence():\n    assert is_sequence(3, [1,0,1])\n    assert not is_sequence(3, [1,1,1])\n    assert not is_sequence(3, [1,0,1,1])\n    assert not is_sequence(3, [1,1,0,1])\n    assert not is_sequence(3, [1,1,1,0])\n    assert not is_sequence(3, [1,1,1,1])\n    assert not is_sequence(3, [1,0,0,0])\n    assert not is_sequence(3, [1,1,1,1,1])\n\nif __name__ == '__main__':\n    test_is_sequence()",
    "# https://leetcode.com/problems/valid-anagram/\n# Definition for a valid anagram.\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(t):\n            return False\n        s_dict = {}\n        t_dict = {}\n        for c in s:\n            s_dict[c] = s_dict.get(c, 0) + 1\n        for c in t:\n            t_dict[c] = t_dict.get(c, 0) + 1\n        for c in s_dict:\n            if s_dict[c]!= t_dict[c]:\n                return False\n        return True",
    "def is_sequence(patterns, s):\n    \"\"\"\n    Returns True if s follows the patterns, False otherwise.\n    patterns is a list of tuples where the first element is a pattern and the second element is the index of the pattern in the list.\n    For example, is_sequence([(1, 2), (3, 4)], \"1234\") returns True.\n    For example, is_sequence([(1, 3), (2, 3)], \"1234\") returns False.\n    \"\"\"\n    if len(patterns) == 0:\n        return True\n    for i in range(len(patterns)):\n        if s[0]!= patterns[i][0]:\n            return False\n        s = s[1:]\n    return is_sequence(patterns[len(patterns) - 1:], s)\n\nif __name__ == \"__main__\":\n    patterns = [(1, 2), (3, 4)]\n    print(is_sequence(patterns, \"1234\"))\n    patterns = [(1, 3), (2, 3)]\n    print(is_sequence(patterns, \"1234\"))",
    "import re\n\ndef check_patterns(patterns,s):\n    for pattern in patterns:\n        if re.search(pattern, s):\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    patterns = [['[0-9]','[0-9]*'],['[A-Z]','[A-Z]*'],['[a-z]','[a-z]*'],['[^A-Z]','[^A-Z]*'],['[^a-z]','[^a-z]*']]\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    print check_patterns(patterns,s)",
    "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.patterns = [\n            [1, 1, 0, 1],\n            [0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]\n        ]\n\n    def test_is_palindrome(self):\n        self.assertTrue(is_palindrome(self.patterns))\n\n    def test_is_palindrome_false(self):\n        self.assertFalse(is_palindrome([\n            [1, 1, 0, 1],\n            [0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0],\n            [1, 1, 1, 1],\n            [1, 0, 0, 1],\n            [1, 0, 1, 1]\n        ]))\n\n    def tearDown(self):\n        pass\n\nif __name__ == '__main__':\n    unittest.main()",
    "def check_sequence(patterns, n):\n    \"\"\"\n    n is the length of the sequence.\n    patterns is a list of strings that represent the sequence.\n    For example, if patterns = [\"A\", \"B\", \"C\"], then the sequence will be AABBCCC.\n    \"\"\"\n    # write your code here\n    if n <= 0:\n        return False\n    if len(patterns) == 0:\n        return False\n    if n == 1:\n        if patterns[0] == '':\n            return True\n        else:\n            return False\n    if len(patterns) == 1:\n        if patterns[0] == '':\n            return True\n        else:\n            return False\n    if n == 2:\n        if patterns[0] == '' and patterns[1] == '':\n            return True\n        else:\n            return False\n    if len(patterns) == 2:\n        if patterns[0] == '' and patterns[1] == '':\n            return True\n        else:\n            return False\n    if n == 3:\n        if patterns[0] == '' and patterns[1] == '' and patterns[2] == '':\n            return True\n        else:\n            return False\n    if len(patterns) == 3:\n        if patterns[0] == '' and patterns[1] == '' and patterns[2] == '':\n            return True\n        else:\n            return False\n    if n == 4:\n        if patterns[0] == '' and patterns[1] == '' and patterns[2] == '' and patterns[3] == '':\n            return True\n        else:\n            return False\n    if len(patterns) == 4:\n        if patterns[0] == '' and patterns[1] == '' and patterns[2] == '' and patterns[3] == '':\n            return True\n        else:\n            return False\n    if n == 5:\n        if patterns[0] == '' and patterns[1] == '' and patterns[2] == '' and patterns[3] == '' and patterns[4] == '':\n            return True\n        else:\n            return False\n    if len(patterns) == 5:\n        if patterns[0] == '' and patterns"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}