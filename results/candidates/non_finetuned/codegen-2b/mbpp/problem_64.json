{
  "problem": {
    "task_id": "MBPP/75",
    "prompt": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
    "canonical_solution": "def find_tuples(test_list, K):\r\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res)) ",
    "test_list": [
      "assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'",
      "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'",
      "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'"
    ],
    "challenge_test_list": [],
    "problem_id": 64
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import collections\n\ndef find_divisible_tuples(tuples, k):\n    divisible_tuples = collections.defaultdict(list)\n    for t in tuples:\n        divisible_tuples[t[0]].append(t[1:])\n\n    return [t for t in divisible_tuples.values() if all(x % k == 0 for x in t)]\n\nprint(find_divisible_tuples([(1, 2, 3), (2, 3, 4), (2, 4, 5)], 2))\nprint(find_divisible_tuples([(1, 2, 3), (2, 3, 4), (2, 4, 5), (3, 4, 5)], 2))",
    "def divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if all(map(lambda x: x % k == 0, t))]",
    "def find_divisible_tuples(tuples, k):\n    for tuple_id, tuple_obj in enumerate(tuples):\n        for element in tuple_obj:\n            if element % k!= 0:\n                return []\n    return tuples\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2, 3),\n        (1, 2, 3),\n        (2, 3, 4),\n        (1, 2, 3),\n        (1, 2, 3),\n        (2, 3, 4),\n        (1, 2, 3),\n        (1, 2, 3),\n        (2, 3, 4)\n    ]\n    print find_divisible_tuples(tuples, 2)",
    "class Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return self.find_divisible_tuples(nums, k)\n\n    def find_divisible_tuples(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        if len(nums) == 1:\n            return [nums[0]]\n        if k == 1:\n            return [x for x in nums if x % k == 0]\n        if k == 2:\n            return [x for x in nums if all(x % i == 0 for i in range(1, k))]\n        if k == 3:\n            return [x for x in nums if all(i % x == 0 for i in range(1, k))]\n        return self.find_divisible_tuples(nums[1:], k-1) + [nums[0]] + self.find_divisible_tuples(nums[1:], k-1)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findDivisibleTuple([1,2,3,4,5], 3))\n    print(s.findDivisibleTuple([1,2,3,4,5], 6))\n    print(s.findDivisibleTuple([1,2,3,4,5], 7))\n    print(s.findDivisibleTuple([1,2,3,4,5], 8))\n    print(s.findDivisibleTuple([1,2,3,4,5], 9))",
    "#!/usr/bin/env python\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [[t for t in t if t[i] % k == 0 for i in range(len(t))] for t in tuples]\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [2, 4, 6], [3, 6, 9]]\n    print(find_divisible_tuples(tuples, 2))\n    print(find_divisible_tuples(tuples, 3))\n    print(find_divisible_tuples(tuples, 4))",
    "#!/usr/bin/env python\n\nfrom itertools import combinations\nimport unittest\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n\nclass Test(unittest.TestCase):\n    def test_get_divisors(self):\n        self.assertEqual(get_divisors(10), [1,2,3,5,7,10])\n        self.assertEqual(get_divisors(13), [1,3,7,13])\n        self.assertEqual(get_divisors(10), get_divisors(100))\n        self.assertEqual(get_divisors(100), get_divisors(1000))\n\nif __name__ == '__main__':\n    unittest.main()",
    "import collections\nfrom itertools import tee, islice\n\ndef divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple[int]]\n    :type k: int\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    divisible_tuples = []\n    for tup in tuples:\n        divisible_tuples.append(tup[:-1])\n        divisible_tuples.append(tup[-1::-1])\n    return [tup for tup in islice(divisible_tuples, 0, None, k) if not any(tup[i] % k for i in range(len(tup)))]\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (2, 4), (3, 6), (6, 8), (9, 12), (12, 15)]\n    k = 2\n    print(divisible_tuples(tuples, k))",
    "def all_divisible(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result\n\nclass Solution:\n    # @param tuples, a list of tuple\n    # @param k, an integer\n    # @return a list of tuple\n    def allDivisible(self, tuples, k):\n        result = []\n        for t in tuples:\n            if all(x % k == 0 for x in t):\n                result.append(t)\n        return result\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    tuples = [\n        (1, 2, 3),\n        (2, 4, 6),\n        (3, 6, 9),\n        (4, 9, 12),\n        (5, 10, 15),\n        (6, 12, 18),\n        (7, 15, 21),\n        (8, 18, 24),\n        (9, 21, 27),\n        (10, 24, 30),\n        (11, 27, 33),\n        (12, 30, 36),\n        (13, 33, 39),\n        (14, 36, 42),\n        (15, 39, 45),\n        (16, 42, 48),\n        (17, 45, 51),\n        (18, 48, 54),\n        (19, 51, 57),\n        (20, 54, 60),\n        (21, 57, 63),\n        (22, 60, 66),\n        (23, 63, 69),\n        (24, 66, 72),\n        (25, 69, 75),\n        (26, 72, 78),\n        (27, 75, 81),\n        (28, 78, 84),\n        (29, 81, 87),\n        (30, 84, 90),\n        (31, 87, 93),\n        (32, 90, 96),\n        (33, 93, 99),\n        (34, 96, 102),\n        (35",
    "def find_divisible_tuples(tuples, k):\n    # Complete this function\n    #input: tuples is a list of tuples, k is an integer\n    #output: a list of tuples, where all elements are divisible by k\n    #\n    # Example:\n    #\n    # Input: [(1,2),(4,5),(7,8),(9,10)]\n    # k = 3\n    #\n    # Output: [(1,2),(4,5),(7,8)]\n    #\n    # Example:\n    #\n    # Input: [(1,2),(3,4),(5,6),(7,8)]\n    # k = 3\n    #\n    # Output: [(1,2),(3,4)]\n\n    # Sort the tuples\n    tuples.sort()\n    # Create a dictionary to store tuples that are divisible by k\n    divisible_tuples = {}\n    for t in tuples:\n        # If the number of elements is less than k, then the tuple is not divisible by k\n        if len(t) < k:\n            continue\n        # Else, add the tuple to the dictionary\n        divisible_tuples.setdefault(t, []).append(t)\n    # Return the list of tuples that are divisible by k\n    return list(divisible_tuples.values())\n\n\nif __name__ == \"__main__\":\n    tuples = [(1,2),(4,5),(7,8),(9,10)]\n    k = 3\n    print(find_divisible_tuples(tuples, k))",
    "#!/bin/python\n\ndef find_divisible_tuples(arr, k):\n    divisible_tuples = []\n    for i in range(0, len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i][0] % k == 0 and arr[j][0] % k == 0:\n                divisible_tuples.append(arr[i])\n                divisible_tuples.append(arr[j])\n    return divisible_tuples\n\nif __name__ == \"__main__\":\n    arr = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    k = 3\n    print find_divisible_tuples(arr, k)",
    "# https://leetcode.com/problems/find-all-divisible-triplets/description/\n\nclass Solution(object):\n    def findDivisibleTriplets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        if len(nums) == 0:\n            return result\n\n        if k == 1:\n            for i in range(len(nums)):\n                if nums[i] % k == 0:\n                    result.append([nums[i], nums[i], nums[i]])\n        else:\n            for i in range(len(nums)):\n                if nums[i] % k == 0:\n                    for j in range(i + 1, len(nums)):\n                        if nums[j] % k == 0:\n                            result.append([nums[i], nums[j], nums[j]])\n                            result.append([nums[j], nums[i], nums[i]])\n        return result",
    "# https://www.hackerrank.com/challenges/tuple-queries\n\n\ndef find_divisible(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [tuple for tuple in tuples if all(x % k == 0 for x in tuple)]\n\n\nif __name__ == '__main__':\n    t = int(input().strip())\n    for a0 in range(t):\n        n = int(input().strip())\n        tuples = [list(map(int, input().strip().split(' '))) for _ in range(n)]\n        k = int(input().strip())\n        print(*find_divisible(tuples, k))",
    "def divisible_tuples(tuples, k):\n    return filter(lambda t: all(map(lambda x: x % k == 0, t)), tuples)\n\n\ndef main():\n    tuples = [(1,2,3),(2,3,4),(5,6,7)]\n    print(divisible_tuples(tuples, 2))\n\nif __name__ == '__main__':\n    main()",
    "from collections import defaultdict\n\nclass Solution(object):\n    def allDivisors(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(1, n+1):\n            if n % i == 0:\n                if n / i == k:\n                    result.append(i)\n                for j in range(i+1, n+1):\n                    if n % j == 0:\n                        if n / j == k:\n                            result.append(j)\n        return result\n\ns = Solution()\ns.allDivisors(100, 6)\nprint s.allDivisors(500, 6)",
    "def findDivisibleTuple(tupleList, k):\n    # write your code here\n    return\n\ndef main():\n    tupleList = [\n        (1, 1, 1),\n        (1, 2, 4),\n        (2, 2, 2),\n        (3, 3, 6),\n        (4, 4, 4),\n        (5, 5, 5)\n    ]\n    findDivisibleTuple(tupleList, 3)\n\nif __name__ == '__main__':\n    main()",
    "def all_divisible(tuples, k):\n    for t in tuples:\n        if sum(t) % k!= 0:\n            return False\n    return True\n\ndef all_divisible_test(tuples, k):\n    for t in tuples:\n        if sum(t) % k!= 0:\n            return False\n    return True\n\ndef main():\n    tuples = [(1,2,3),(2,3,4),(3,4,5)]\n    k = 3\n    print(all_divisible(tuples, k))\n    print(all_divisible_test(tuples, k))\n\nif __name__ == '__main__':\n    main()",
    "def tuplesDivisibleByK(tuples, k):\n    for t in tuples:\n        if not all(x % k == 0 for x in t):\n            return False\n    return True\n\ndef main():\n    tuples = [\n        ([1, 2, 3], 3),\n        ([4, 2, 4], 2),\n        ([2, 2, 2], 2),\n        ([3, 1, 1, 2, 2], 1),\n        ([1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),\n        ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1),",
    "def allDivisors(tuples, k):\n    for i in range(len(tuples)):\n        for j in range(len(tuples[i])):\n            if tuples[i][j] % k == 0:\n                yield tuples[i]\n                break\n\ndef main():\n    testCases = [((1,2,3), 3), ((1,2,3,4,5), 3), ((1,2,3,4,5,6,7,8,9), 3)]\n    for t in testCases:\n        print(\"Test case #{}: {}\".format(t[0][0], allDivisors(t[0], t[1])))\n\nif __name__ == \"__main__\":\n    main()",
    "def find_divisible_tuples(tuples, k):\n    divisible_tuples = []\n    for t in tuples:\n        divisible_tuples.append(tuple([x for x in t if x % k == 0]))\n    return divisible_tuples\n\ndef main():\n    tuples = [\n        (1, 2),\n        (3, 4),\n        (5, 6),\n        (7, 8),\n        (9, 10),\n        (11, 12),\n        (13, 14),\n        (15, 16),\n        (17, 18),\n        (19, 20),\n        (21, 22),\n        (23, 24),\n        (25, 26),\n        (27, 28),\n        (29, 30),\n        (31, 32),\n        (33, 34),\n        (35, 36),\n        (37, 38),\n        (39, 40),\n        (41, 42),\n        (43, 44),\n        (45, 46),\n        (47, 48),\n        (49, 50),\n        (51, 52),\n        (53, 54),\n        (55, 56),\n        (57, 58),\n        (59, 60),\n        (61, 62),\n        (63, 64),\n        (65, 66),\n        (67, 68),\n        (69, 70),\n        (71, 72),\n        (73, 74),\n        (75, 76),\n        (77, 78),\n        (79, 80),\n        (81, 82),\n        (83, 84),\n        (85, 86),\n        (87, 88),\n        (89, 90),\n        (91, 92),\n        (93, 94),\n        (95, 96),\n        (97, 98),\n        (99, 100),\n        (101, 102),\n        (103, 104),\n        (105, 106),\n        (107, 108),\n        (109, 110),\n        (111, 112),\n        (113, 114),\n        (115, 116),\n        (117, 118),\n        (119, 120),\n        (121, 122),\n        (123, 124),",
    "#!/bin/python\n\ndef find_divisible_tuples(tuples, k):\n    if k == 0:\n        return []\n    divisible_tuples = []\n    for tuple in tuples:\n        if all(x % k == 0 for x in tuple):\n            divisible_tuples.append(tuple)\n    return divisible_tuples\n\ndef main():\n    tuples = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (6, 7, 8)]\n    k = 3\n    divisible_tuples = find_divisible_tuples(tuples, k)\n    print(divisible_tuples)\n    \nif __name__ == '__main__':\n    main()",
    "import sys\nsys.setrecursionlimit(10000)\n\ndef divisible_tuples(tuples, k):\n    if len(tuples) == 0:\n        return []\n    if len(tuples) == 1:\n        return [tuples[0]]\n    res = []\n    for t in tuples:\n        for i in range(len(t)):\n            if t[i] % k!= 0:\n                break\n        else:\n            res.append(t)\n    return res\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tuples = []\n    for i in range(n):\n        t = map(int, sys.stdin.readline().split())\n        tuples.append(t)\n    print(divisible_tuples(tuples, k))\n\nif __name__ == '__main__':\n    main()",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    # Write your code here\n    result = []\n    for t in tuples:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result\n\ndef main():\n    tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    print(find_divisible_tuples(tuples, 3))\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def findDivisibleTuple(self, A, k):\n        \"\"\"\n        :type A: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not A:\n            return []\n\n        ans = []\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if A[i][j] % k == 0:\n                    ans.append([A[i][j], A[i][j]/k, A[i][j]/k * k])\n        return ans",
    "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'k v')\n\nclass Solution:\n    def findDivisors(self, tuples: List[Tuple], k: int) -> List[Tuple]:\n        divisors = [1]\n        for t in tuples:\n            if t.v % k == 0:\n                divisors.append(t)\n            else:\n                divisors.append(tuple(divisors))\n        return divisors",
    "import collections\n\ndef find_divisible_tuples(tuples, k):\n    return [tuple for t in tuples for i in t if i % k == 0]\n\ntuples = [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7)]\n\nprint(find_divisible_tuples(tuples, 3))",
    "from collections import defaultdict\n\ndef get_divisors(n):\n    d = defaultdict(int)\n    for i in range(1, n+1):\n        d[i] = i\n    for i in range(2, n+1):\n        d[i] += d[i-1]\n    return d\n\ndef get_divisors_from_tuples(tuples):\n    return set(t for t in tuples for i in range(1, len(t)+1) if get_divisors(i) & set(t))\n\ndef main():\n    tuples = [(1,2),(3,4),(5,6),(7,8),(9,10)]\n    divisors = get_divisors_from_tuples(tuples)\n    print(len(divisors))\n    for i in range(2, 10):\n        print(i, get_divisors_from_tuples((x, i) for x in tuples))\n\nif __name__ == '__main__':\n    main()",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # Write your code here\n    return []\n\n\nif __name__ == \"__main__\":\n    tuples = [\n        ([1, 3, 4, 5], 4),\n        ([1, 3, 4, 6], 2),\n        ([1, 3, 5, 7], 3),\n        ([1, 2, 3, 4, 5, 6, 7], 2)\n    ]\n    for t in tuples:\n        print(t)\n        print(find_divisible_tuples(t, 3))",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n\n    def __iter__(self):\n        return iter(self.x)\n\n    def __str__(self):\n        return str(self.x)\n\n# Your Tuple object will be instantiated and called as such:\n# obj = Tuple(x)\n# param_1 = obj.x\n# param_2 = obj.__iter__()\n# param_3 = obj.__str__()\n\n# Write a function named divisible_tuple to find all tuples which have all elements divisible by k from the given list of tuples.\n# The input is a list of tuples.\n# The input is guaranteed to be a list of tuples.\n# Return a list of tuples.\n# Example:\n\n# Input:\n# [\n#   (2,3,4),\n#   (3,2,3),\n#   (6,2,1),\n#   (6,5,4)\n# ]\n# k = 4\n# Output:\n# [(2,3,4),(6,2,1)]\n# [(3,2,3),(6,2,1)]\n# [(6,2,1)]\n# [(6,5,4)]\n\n# Note:\n# The length of the given list of tuples will be in the range [1, 1000].\n# The given list of tuples won't have duplicates.\n# k will be an integer in the range [1, 1000].\n\nclass Solution(object):\n    def divisibleTuple(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        return self.find(tuples, k)\n\n    def find(self, tuples, k):\n        res = []\n        for t in tuples:\n            if t[0] % k == 0 and t[1] % k == 0 and t[2] % k == 0:\n                res.append(t)\n        return res\n\n# Your Solution object will be instantiated and called as",
    "def get_all_divisible_tuples(tuples, k):\n    divisors = [1] * k\n    for t in tuples:\n        for i in range(1, k):\n            divisors[i] *= t[i]\n    divisors = [divisors[i] for i in range(k)]\n    return [t for t in tuples if all(divisors[i] % t[i] == 0 for i in range(k))]\n\ndef get_all_divisible_tuples_2(tuples, k):\n    divisors = [1] * k\n    for t in tuples:\n        for i in range(1, k):\n            divisors[i] *= t[i]\n    divisors = [divisors[i] for i in range(k)]\n    return [t for t in tuples if all(divisors[i] % t[i] == 0 for i in range(k))]\n\ndef main():\n    tuples = [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 3, 6), (1, 2, 3, 7), (1, 2, 3, 8)]\n    print(get_all_divisible_tuples(tuples, 3))\n    print(get_all_divisible_tuples_2(tuples, 3))\n\nif __name__ == '__main__':\n    main()",
    "import unittest\n\nclass Solution(object):\n    def allPairsDivisibleByK(self, arr, k):\n        \"\"\"\n        :type arr: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def all_pairs(arr):\n            res = []\n            for i in range(len(arr)):\n                for j in range(len(arr)):\n                    if arr[i][j] % k == 0:\n                        res.append([arr[i][j], arr[j][i]])\n            return res\n\n        return all_pairs(arr)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "def get_divisible_tuples(list_of_tuples, k):\n    \"\"\"\n    Input:\n        list_of_tuples: a list of tuples\n        k: an integer\n    Output:\n        a list of tuples\n    \"\"\"\n    divisible_tuples = []\n    for tuple in list_of_tuples:\n        if all(map(lambda x: x % k == 0, tuple)):\n            divisible_tuples.append(tuple)\n    return divisible_tuples\n\nif __name__ == \"__main__\":\n    list_of_tuples = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    k = 3\n    print(get_divisible_tuples(list_of_tuples, k))",
    "def find_divisible_tuples(tuples, k):\n    divisors = [x for x in range(1, k+1)]\n    for tuple in tuples:\n        for i in range(len(tuple)):\n            if tuple[i] not in divisors:\n                divisors.append(tuple[i])\n    return divisors\n\n\nif __name__ == '__main__':\n    tuples = [\n        ([1, 2, 3], 3),\n        ([1, 2, 3, 4, 5], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], 3),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], 3)\n    ]\n    print(find_divisible_tuples(tuples, 3))",
    "from itertools import chain\n\nclass Solution(object):\n    def findDivisors(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [i for i in nums if all(n % i == 0 for n in nums)]\n\nclass Solution2(object):\n    def findDivisors(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [i for i in nums if all(n % i == 0 for n in nums)]",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if all(i % k == 0 for i in t)]\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (5, 6), (7, 8), (9, 10), (11, 12)]\n    print(find_divisible_tuples(tuples, 3))\n    print(find_divisible_tuples(tuples, 4))",
    "class Solution:\n    # @param {integer[]} arr\n    # @param {integer} k\n    # @return {integer[][]}\n    def findDivisibleTuple(self, arr, k):\n        def findTuple(arr, start, end):\n            if start == end:\n                return [arr[start]]\n            else:\n                middle = (start + end) / 2\n                left = findTuple(arr, start, middle)\n                right = findTuple(arr, middle + 1, end)\n                return left + right\n        return findTuple(arr, 0, len(arr) - 1)",
    "import math\n\ndef find_divisible_tuple(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [tuple for t in tuples for i in t if i % k == 0]\n\ndef main():\n    tuples = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    k = 3\n    print(find_divisible_tuple(tuples, k))\n\nif __name__ == '__main__':\n    main()",
    "def getDivisibleTuple(tuples, k):\n    # write your code here\n    divisors = [i for i in range(1, k+1) if all(t[i] % j == 0 for j in range(1, k+1))]\n    return [(t[i], t[j]) for t in tuples for i in range(len(t)) if t[i] not in divisors]\n\nclass Solution(object):\n    def findDivisors(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return getDivisibleTuple(nums, k)",
    "from collections import defaultdict\nimport time\n\n\ndef find_tuples(lst, k):\n    \"\"\"\n    :type lst: List[tuple]\n    :type k: int\n    :rtype: List[tuple]\n    \"\"\"\n    d = defaultdict(list)\n    for t in lst:\n        for i in t:\n            d[i % k].append(t)\n    return [t for t in d.values() if t]\n\n\ndef test_case1():\n    lst = [(1, 2), (3, 4), (5, 6)]\n    k = 3\n    print(find_tuples(lst, k))\n\n\ndef time_func(n):\n    return time.clock()\n\n\ndef main():\n    t = time.time()\n    test_case1()\n    print(time_func(t))\n\n\nif __name__ == '__main__':\n    main()",
    "import collections\nimport itertools\n\ndef divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [tuple(map(lambda x: x % k, t)) for t in tuples]\n\nclass Solution:\n    def findDivisibleTuple(self, tuples: List[List[int]], k: int) -> List[List[int]]:\n        return divisible_tuples(tuples, k)\n\nif __name__ == '__main__':\n    s = Solution()\n    tuples = [ [1, 2, 3, 4, 5], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [5, 5, 5, 5, 5], [6, 6, 6, 6, 6], [7, 7, 7, 7, 7], [8, 8, 8, 8, 8], [9, 9, 9, 9, 9], [10, 10, 10, 10, 10] ]\n    k = 3\n    print(s.findDivisibleTuple(tuples, k))",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    count = [0] * len(tuples)\n    for t in tuples:\n        for i in range(len(t)):\n            count[i] += t[i] % k\n    return [t for i, t in enumerate(tuples) if count[i] % k == 0]\n\nif __name__ == '__main__':\n    tuples = [(1,2),(3,4),(2,2),(5,3)]\n    print(find_divisible_tuples(tuples, 2))",
    "import itertools\n\ndef find_divisible_tuples(tuples, k):\n    return [tuple(i) for i in itertools.combinations(tuples, k) if all(i % x == 0 for x in tuples)]\n\nif __name__ == '__main__':\n    tuples = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7)]\n    print find_divisible_tuples(tuples, 3)",
    "from collections import defaultdict\nimport timeit\n\n\nclass Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k == 1:\n            return [tuple(x) for x in nums]\n        res = defaultdict(list)\n        for t in nums:\n            res[t[0] % k].append(t)\n        return [tuple(x) for x in res.values()]\n\n\nif __name__ == \"__main__\":\n    start = timeit.default_timer()\n    print(Solution().findDivisibleTuple([(1, 2, 3), (2, 3, 4), (4, 5, 6)], 2))\n    print(timeit.default_timer() - start)",
    "def find_divisible(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [tuple(i % k for i in t) for t in tuples]",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\nclass Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        for i in range(len(nums)):\n            nums[i] = Tuple(nums[i])\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j].x % nums[i].x == 0 and nums[j].x % k == 0:\n                    result.append(nums[j])\n        return result\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [\n        (1,2),\n        (2,3),\n        (3,4),\n        (4,5),\n        (5,6),\n        (6,7),\n        (7,8),\n        (8,9),\n        (9,10),\n        (10,11),\n        (11,12),\n        (12,13),\n        (13,14),\n        (14,15),\n        (15,16),\n        (16,17),\n        (17,18),\n        (18,19),\n        (19,20),\n        (20,21),\n        (21,22),\n        (22,23),\n        (23,24),\n        (24,25),\n        (25,26),\n        (26,27),\n        (27,28),\n        (28,29),\n        (29,30),\n        (30,31),\n        (31,32),\n        (32,33),\n        (33,34),\n        (34,35),\n        (35,36),\n        (36,37),\n        (37,38),\n        (38,39),",
    "#!/usr/bin/env python\n\nimport sys\nimport itertools\n\ndef findDivisibleTuple(tupleList, k):\n    result = []\n    for i in range(len(tupleList)):\n        for j in range(len(tupleList[i])):\n            if tupleList[i][j] % k == 0:\n                result.append(tupleList[i][:])\n                break\n    return result\n\nif __name__ == '__main__':\n    if len(sys.argv)!= 3:\n        sys.exit(\"Usage: %s <input file> <output file>\" % sys.argv[0])\n    inputFile = sys.argv[1]\n    outputFile = sys.argv[2]\n    with open(inputFile, 'r') as f:\n        lines = f.readlines()\n    tuples = []\n    for line in lines:\n        tuple = line.strip().split(',')\n        tuples.append(tuple)\n    with open(outputFile, 'w') as f:\n        for i in range(len(tuples)):\n            tuple = findDivisibleTuple(tuples[i], 3)\n            f.write(\"%s\\n\" % tuple)",
    "import collections\n\nclass Solution:\n    # @param {List[List[int]]} arr\n    # @param {integer} k\n    # @return {List[List[int]]}\n\n    def allPairsDivisible(self, arr, k):\n        # write your code here\n        if len(arr) == 0 or k == 0:\n            return []\n        result = collections.defaultdict(list)\n        for i in range(len(arr)):\n            for j in range(i, len(arr)):\n                if arr[i][j] % k == 0:\n                    result[arr[i][j]].append((arr[i], arr[j]))\n        return list(result.values())\n\n\nif __name__ == \"__main__\":\n    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21]]\n    k = 2\n    s = Solution()\n    result = s.allPairsDivisible(arr, k)\n    print(result)",
    "import math\nimport copy\nimport collections\n\ndef get_divisible_tuples(tuples, k):\n    \"\"\"\n    >>> get_divisible_tuples([(1, 2), (3, 4)], 2)\n    [(2, 4)]\n    \"\"\"\n    divisors = set()\n    for t in tuples:\n        num = t[0]\n        den = t[1]\n        while num % k == 0:\n            divisors.add(num)\n            num = num // k\n        while den % k == 0:\n            divisors.add(den)\n            den = den // k\n    return divisors\n\nclass Solution:\n    def get_divisible_tuples(self, k, tuples):\n        \"\"\"\n        :type k: int\n        :type tuples: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.get_divisible_tuples_recursive(k, tuples)\n\n    def get_divisible_tuples_recursive(self, k, tuples):\n        if len(tuples) == 0:\n            return []\n        if len(tuples) == 1:\n            return [(t[0] // k, t[1] // k) for t in tuples]\n        if len(tuples) == 2:\n            return [(t[0] // k, t[1] // k) for t in tuples]\n        if k <= 1:\n            return [(t[0] // k, t[1] // k) for t in tuples]\n        result = []\n        for t in tuples:\n            for divisor in get_divisible_tuples(tuples, k):\n                if divisor[0] * k == divisor[1]:\n                    result.append(t)\n        return result\n\n    def get_divisible_tuples_iterative(self, k, tuples):\n        if len(tuples) == 0:\n            return []\n        if len(tuples) == 1:\n            return [(t[0] // k, t[1] // k) for t in tuples]\n        if len(tu",
    "import collections\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[][]}\n    def findDivisibleTuple(self, nums, k):\n        return self.findDivisibleTuple1(nums, k)\n\n    def findDivisibleTuple1(self, nums, k):\n        # Write your code here\n        res = []\n        for i in range(len(nums)):\n            tup = collections.namedtuple('tup', 'a b')\n            tup.a = nums[i]\n            tup.b = k\n            res.append(tup)\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,2,3,4,5,6]\n    k = 2\n    print(sol.findDivisibleTuple(nums, k))",
    "class Solution(object):\n    def findDivisors(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nums = sorted(nums)\n        result = []\n        for i in range(len(nums)):\n            if nums[i] % k == 0:\n                result.append(nums[i])\n        return result\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [3, 4, 6, 7]\n    k = 2\n    result = sol.findDivisors(nums, k)\n    print result",
    "# Example\n# For tuple (1, 2, 3, 4), k = 3, the output should be\n# ((1, 2, 3), (2, 3, 4))\n# For tuple (1, 2, 3, 4), k = 5, the output should be\n# ()\n# For tuple (1, 2, 3, 4), k = 6, the output should be\n# ()\n# For tuple (1, 2, 3, 4), k = 7, the output should be\n# ()\n\ndef divide_tuples_by_k(tuples, k):\n    if not tuples:\n        return tuple()\n    if not isinstance(tuples[0], tuple):\n        tuples = list(tuples)\n    result = []\n    for i in range(len(tuples)):\n        if k == 1:\n            result.append(tuples[i])\n        else:\n            for j in range(len(tuples[i])):\n                if tuples[i][j] % k == 0:\n                    result.append(tuple(tuples[i][:j] + tuple([x for x in range(j, len(tuples[i]))] + list(tuples[i][j:]))))\n                    break\n    return tuple(result)",
    "from collections import defaultdict\n\n\ndef tuples_divisible_by_k(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    divisors = defaultdict(list)\n    for t in tuples:\n        for i in range(k):\n            divisors[t[i]].append(t)\n    return [t for t in divisors.values() if len(t) > 1]",
    "from collections import defaultdict\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    # Build a mapping of tuples to their sum\n    tuple_sums = defaultdict(int)\n    for t in tuples:\n        tuple_sums[t] += 1\n    # Build a mapping of tuples to their divisibility\n    tuple_divisibility = defaultdict(int)\n    for t in tuples:\n        tuple_divisibility[t] += 1\n    # Build a mapping of tuples to their divisibility after subtracting k\n    tuple_k_divisibility = defaultdict(int)\n    for t in tuples:\n        tuple_k_divisibility[t] += tuple_sums[t] - k\n\n    # Find the tuples with the highest divisibility\n    tuples_with_high_divisibility = []\n    for t in tuple_divisibility:\n        if tuple_divisibility[t] > tuple_k_divisibility[t]:\n            tuples_with_high_divisibility.append(t)\n\n    return tuples_with_high_divisibility\n\nif __name__ == '__main__':\n    tuples = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    print(find_divisible_tuples(tuples, 3))",
    "# https://leetcode.com/problems/find-all-divisible-subsequences/discuss/191459/Python-Python-Dynamic-Programming-with-Python-and-List-of-tuples\n\nimport collections\nimport heapq\n\n\nclass Solution:\n    def all_divisible(self, nums: List[List[int]], k: int) -> List[List[int]]:\n        def dfs(i, k):\n            if i >= len(nums):\n                return [nums]\n\n            if k == 1:\n                ans = []\n                for j in range(len(nums)):\n                    if j == i:\n                        ans.append(nums[i])\n                    else:\n                        ans.append(nums[i] + nums[j])\n                return ans\n\n            ans = []\n            for j in range(len(nums)):\n                if j == i:\n                    ans.append(nums[i])\n                    continue\n                if nums[i] % k == 0 and dfs(j, k):\n                    ans.append(nums[i] + nums[j])\n            return ans\n\n        ans = []\n        for i in range(len(nums)):\n            ans.extend(dfs(i, k))\n        return ans\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [[1, 2, 3], [1, 2, 4], [1, 3, 4], [1, 2, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]\n    ans = sol.all_divisible(nums, 2)\n    print(ans)",
    "import unittest\nfrom collections import defaultdict\n\n# https://leetcode.com/problems/divisible-tuple/\nclass Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(nums, k, result):\n            if len(nums) == 0:\n                return result\n            for i in range(len(nums)):\n                for j in range(len(nums[i])):\n                    if nums[i][j] % k == 0:\n                        result.append(nums[i][j])\n                    dfs(nums[i][:j] + nums[i][j+1:], k, result)\n        result = []\n        dfs(nums, k, result)\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/divisible-tuple/solution/\n#\nApproach #1: Sort\nComplexity Analysis\nTime Complexity: O(n*k) where n is the length of the list and k is the kth element.\nSpace Complexity: O(k)\n\n# 14ms 100%\nclass Solution {\n    public List<Integer> findDivisibleTuple(List<List<Integer>> nums, int k) {\n        List<Integer> res = new ArrayList();\n        Arrays.sort(nums.get(0));\n        for (int i = 1; i < nums.size(); i++) {\n            Arrays.sort(nums.get(i));\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                if (nums.get(i).get(j) % k == 0) {\n                    res.add(nums.get(i).get(j",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return [x for x in tuples if all(divisible(x, k))]\n\ndef divisible(x, k):\n    return all(x % i == 0 for i in range(1, k))\n\ndef main():\n    tuples = [\n        [1, 2, 3],\n        [1, 2, 3, 4, 5],\n        [1, 2, 3, 4, 5, 6],\n        [1, 2, 3, 4, 5, 6, 7],\n        [1, 2, 3, 4, 5, 6, 7, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    ]\n\n    print find_divisible_tuples(tuples, 3)\n\n\nif __name__ == '__main__':\n    main()",
    "from collections import defaultdict\n\ndef divisible_tuples(tuples, k):\n    divisors = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            divisors[t[i]] += 1\n\n    for i in range(k):\n        for t in divisors:\n            if divisors[t] % i!= 0:\n                del divisors[t]\n\n    for t in divisors:\n        yield t, divisors[t]\n\ndef main():\n    tuples = [\n        (1,2,3),\n        (2,2,3),\n        (2,3,3),\n        (2,3,4),\n        (3,2,3),\n        (3,2,4),\n        (3,3,3),\n        (3,3,4),\n        (3,4,3),\n        (3,4,4),\n        (4,2,3),\n        (4,3,3),\n        (4,3,4),\n        (4,4,3),\n        (4,4,4)\n    ]\n\n    # tuples = [(i,j,k) for i in range(5) for j in range(5) for k in range(5)]\n    # print(tuples)\n\n    k = 4\n    print(list(divisible_tuples(tuples, k)))\n\nif __name__ == '__main__':\n    main()",
    "def all_divisible(tuples, k):\n    for t in tuples:\n        if all(x % k == 0 for x in t):\n            yield t\n\n\nprint all_divisible([(1, 2, 3), (2, 3, 4), (3, 4, 5)], 2)",
    "import math\n\ndef is_divisible(n, k):\n    return n % k == 0\n\ndef divisible_tuples(nums, k):\n    d = {}\n    for i in range(len(nums)):\n        if is_divisible(nums[i], k):\n            if nums[i] not in d:\n                d[nums[i]] = []\n            d[nums[i]].append(i)\n    return d\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5]\n    k = 3\n    print(divisible_tuples(nums, k))\n    k = 7\n    print(divisible_tuples(nums, k))\n    k = 4\n    print(divisible_tuples(nums, k))\n    k = 2\n    print(divisible_tuples(nums, k))",
    "# https://leetcode.com/problems/find-all-divisible-triplets/\n\n\nclass Solution:\n    # @return a tuple, (index1, index2, index3)\n    def findDivisibleTriplets(self, arr: List[int], k: int) -> List[List[int]]:\n        n = len(arr)\n        if n < 3:\n            return []\n\n        # sort the array\n        arr = sorted(arr)\n\n        # write the result to list\n        result = []\n\n        for i in range(n):\n            if i == 0:\n                start = i\n                end = i + 1\n            else:\n                start = i - 1\n                end = i\n\n            while start >= 0 and end < n:\n                if arr[start] % k == 0 and arr[end] % k == 0:\n                    result.append(arr[start:end + 1])\n                    start = end\n                end += 1\n\n        return result\n\n\ndef main():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,",
    "from collections import defaultdict\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # print(tuples)\n    # print(k)\n    result = []\n    for t in tuples:\n        # print(t)\n        num_divisible = 0\n        for i in range(len(t)):\n            if t[i] % k == 0:\n                num_divisible += 1\n        if num_divisible == len(t):\n            result.append(t)\n    return result\n\nif __name__ == '__main__':\n    tuples = [[1,2,3],[3,4,5],[5,6,7],[7,8,9],[9,10,11],[11,12,13],[13,14,15]]\n    print(find_divisible_tuples(tuples, 10))\n    print(find_divisible_tuples(tuples, 2))\n    print(find_divisible_tuples(tuples, 3))\n    print(find_divisible_tuples(tuples, 4))\n    print(find_divisible_tuples(tuples, 5))\n    print(find_divisible_tuples(tuples, 6))",
    "def find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # write your code here\n    d = collections.defaultdict(lambda: 0)\n    for t in tuples:\n        for i,j in zip(t, t[1:]):\n            d[i] += 1\n            d[j] += 1\n        d[t[-1]] += 1\n\n    tups = []\n    for i in range(k, d.values()[-1] + 1):\n        if all(d[i] % j == 0 for i, j in enumerate(d.keys())):\n            tups.append(list(d.keys()))\n    return tups",
    "# https://leetcode.com/problems/divisible-tuples/discuss/48894/Java-O(n)-time-and-O(1)-space-solution\n\n\nclass Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def is_divisible(nums, k):\n            return sum(nums) % k == 0\n\n        def find_divisible_tuples(nums, k):\n            if len(nums) == 0:\n                return []\n            for i in range(len(nums)):\n                if is_divisible(nums[i], k):\n                    yield nums[:i]\n                    yield nums[i:]\n\n        return list(find_divisible_tuples(nums, k))\n\n\nif __name__ == '__main__':\n    s = Solution()\n    # print(s.findDivisibleTuple([1, 2, 3, 4, 5, 6], 3))\n    print(s.findDivisibleTuple([1, 2, 3, 4, 5, 6], 2))",
    "# https://leetcode.com/problems/find-tuples-with-all-elements-divisible-by-k/discuss/81843/Python-Solutions-with-Python-3-and-Python-2-6-2-and-Python-3-1-9\n\nclass Solution:\n    # @param {List[List[int]]} tuples\n    # @param {integer} k\n    # @return {List[List[int]]}\n\n    def findDivisibleTuple(self, tuples, k):\n        # write your code here\n        for i in range(len(tuples)):\n            for j in range(len(tuples[0])):\n                if tuples[i][j] % k!= 0:\n                    break\n            else:\n                yield tuples[i]\n\n    def findDivisibleTuple_2(self, tuples, k):\n        # write your code here\n        for i in range(len(tuples)):\n            for j in range(len(tuples[0])):\n                if tuples[i][j] % k == 0:\n                    yield tuples[i]\n                    break\n        return\n\nif __name__ == '__main__':\n    s = Solution()\n    # print(s.findDivisibleTuple([[1,2,3], [4,5,6]], 3))\n    # print(s.findDivisibleTuple_2([[1,2,3], [4,5,6]], 3))\n    print(s.findDivisibleTuple([[1,2,3,4], [5,6,7,8]], 3))\n    print(s.findDivisibleTuple_2([[1,2,3,4], [5,6,7,8]], 3))",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def findDivisibleTuple(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        n = len(tuples)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if tuples[i][0] % k == 0 and tuples[j][0] % k == 0 and tuples[i][0]!= tuples[j][0]:\n                    res.append(tuples[i])\n                    break\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findDivisibleTuple([[1, 2], [3, 4], [5, 6]], 2)",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def findDivisors(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        res = defaultdict(set)\n        for n in nums:\n            res[n % k].add(n)\n\n        return [i for i in res.keys() if res[i] == set(nums)]",
    "import math\n\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # TODO: implement this\n\n    def is_divisible(num):\n        return math.floor(num / k) == num / k\n\n    return filter(is_divisible, tuples)",
    "from collections import defaultdict\n\n\ndef find_divisible(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # the idea is that we can simply use the defaultdict to store the\n    # results for each element\n    result = defaultdict(list)\n\n    for tuple in tuples:\n        for i in range(len(tuple)):\n            result[tuple[i]].append(tuple[:i] + tuple[i+1:])\n\n    # now we need to check if the results are all divisible by k\n    for i in range(k):\n        for r in result.values():\n            if len(r) == 1:\n                yield r[0]\n            else:\n                for j in range(len(r)):\n                    yield r[j]\n\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 6], [1, 3, 2], [1, 3, 4], [1, 3, 5], [1, 3, 6], [1, 4, 2], [1, 4, 3], [1, 4, 5], [1, 4, 6], [1, 5, 2], [1, 5, 3], [1, 5, 4], [1, 5, 6], [1, 6, 2], [1, 6, 3], [1, 6, 4], [1, 6, 5], [2, 3, 4], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6], [2, 5, 6], [3, 4, 5], [3, 4, 6], [3, 5, 6], [4, 5, 6]]\n    print(find_divisible(tuples, 6))",
    "class Solution(object):\n    def findDivisibleTuple(self, arr, k):\n        \"\"\"\n        :type arr: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(arr, k):\n            if len(arr) == 0:\n                return []\n            if len(arr) == 1:\n                return arr[0]\n            left, right = 0, len(arr) - 1\n            while left < right:\n                mid = (left + right) / 2\n                if arr[mid] % k == 0:\n                    return arr[mid:] + arr[:mid]\n                elif arr[mid] % k!= 0:\n                    right = mid\n                else:\n                    left = mid + 1\n            return arr[left:]\n\n        return dfs(arr, k)\n\nif __name__ == \"__main__\":\n    arr = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    print(Solution().findDivisibleTuple(arr, 3))",
    "import unittest\n\n\nclass Solution:\n    def findDivisibleTuple(self, tupleList, k):\n        \"\"\"\n        :type tupleList: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        for i in range(len(tupleList)):\n            for j in range(len(tupleList[i])):\n                if tupleList[i][j] % k!= 0:\n                    return []\n        return tupleList\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-divisible-tuple/solution/\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public List<List<Integer>> findDivisibleTuple(List<List<Integer>> tupleList, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (tupleList == null || tupleList.size() == 0) return result;\n\n        for (int i = 0; i < tupleList.size(); i++) {\n            for (int j = 0; j < tupleList.get(i).size(); j++) {\n                if (tupleList.get(i).get(j) % k!= 0) {\n                    result.add(tupleList.get(i));\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<List<Integer>> findDivisibleTuple(List<List<Integer>> tupleList, int k) {\n        if (tupleList == null || tupleList.size() == 0) return new ArrayList<>();\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < tupleList.size(); i++) {\n            for (int j = 0; j < tupleList.get(i).size(); j++) {\n                if (t",
    "# https://oj.leetcode.com/problems/find-common-divisors/\n# Given a list of tuples, return a list of all tuples whose elements are divisible by k.\n\n# Example:\n# Input: [(1,3),(2,4),(3,5)]\n# k=2\n# Output: [(1,3),(2,4)]\n# Note:\n# The number of tuples is [1, 2, 3,..., n], where n is the length of the given list.\n# k is a positive integer, which is in the range [1, n/2].\n# The given list is sorted in ascending order.\n\n# Follow up:\n# Could you do it without using any extra space?\n\nclass Solution(object):\n    def findCommonDiv(self, tuples, k):\n        \"\"\"\n        :type tuples: List[tuple]\n        :type k: int\n        :rtype: List[tuple]\n        \"\"\"\n        res = []\n        for t in tuples:\n            if all(x % k == 0 for x in t):\n                res.append(t)\n        return res",
    "class Solution(object):\n    def findDivisibleTuple(self, n, k, tuples):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type tuples: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if k == 1:\n            return [tuple(i) for i in tuples if i[0] % k == 0]\n        else:\n            result = []\n            for t in tuples:\n                if t[0] % k == 0 and t[1] % k == 0:\n                    result.append(t)\n            return self.findDivisibleTuple(n, k - 1, result)\n\n\n# Note:\n# This method is O(n^2)",
    "from collections import defaultdict\nimport math\n\ndef find_all_divisible_tuple(tuple_list, k):\n    # This function will return a tuple of tuples.\n    # Each tuple will have all the elements of the input tuple which are divisible by k.\n    divisible_tuples = defaultdict(set)\n    for tuple in tuple_list:\n        for i in range(len(tuple)):\n            for j in range(i+1, len(tuple)):\n                if tuple[i] % tuple[j] == 0:\n                    divisible_tuples[tuple].add((i, j))\n    return divisible_tuples\n\ndef main():\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]\n    print find_all_divisible_tuple(tuple_list, 2)\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k == 1:\n            return [x for x in nums if x % k == 0]\n        else:\n            nums_k = [nums[i] for i in range(len(nums)) if nums[i] % k == 0]\n            return self.findDivisibleTuple(nums_k, k - 1)",
    "import collections\n\ndef divisible_tuples(l, k):\n    \"\"\"\n    :type l: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    if k > len(l):\n        return []\n    if k == 0:\n        return []\n    if k == 1:\n        return [(t) for t in l]\n    \n    pairs = [[(i, j) for j in range(i, k)] for i in range(k)]\n    \n    return [t for t in l if all(map(lambda p: p[0] % p[1] == 0, pairs))]\n    \ndef main():\n    \"\"\"\n    >>> divisible_tuples([(1, 2), (2, 3), (3, 4)], 3)\n    [(1, 2), (2, 3)]\n    \"\"\"\n    t = divisible_tuples([(1, 2), (2, 3), (3, 4)], 3)\n    print t\n    \nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def findDivisibleTuple(self, nums, k):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i in xrange(len(nums)):\n            for j in xrange(len(nums[i])):\n                if nums[i][j] % k == 0:\n                    result.append([nums[i][j], k])\n                    break\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().findDivisibleTuple([[1,2,3],[4,5,6]], 3) == [[1,3],[2,3]]\n    assert Solution().findDivisibleTuple([[1,2,3],[4,5,6]], 2) == [[1,3],[2,5]]\n    assert Solution().findDivisibleTuple([[1,2,3],[4,5,6]], 4) == []\n    assert Solution().findDivisibleTuple([[1,2,3],[4,5,6]], 1) == [[1,2,3]]\n    assert Solution().findDivisibleTuple([[1,2,3],[4,5,6]], 6) == []",
    "class Solution:\n    # @param tuples, a list of tuples\n    # @param k, an integer\n    # @return a list of tuples\n    def findDivisibleTuple(self, tuples, k):\n        return [(tuple[0], tuple[1], tuple[2]) for tuple in tuples if all(x % k == 0 for x in tuple)]\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    t1 = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    t2 = [(1, 2, 3), (3, 4, 5), (5, 6, 7)]\n    t3 = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (5, 6, 7)]\n    t4 = [(1, 2, 3), (3, 4, 5), (5, 6, 7), (7, 8, 9)]\n    print solution.findDivisibleTuple(t1, 3)\n    print solution.findDivisibleTuple(t2, 3)\n    print solution.findDivisibleTuple(t3, 3)\n    print solution.findDivisibleTuple(t4, 3)\n    print solution.findDivisibleTuple(t1, 7)",
    "def get_divisible_tuples(arr, k):\n    \"\"\"\n    :type arr: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # TODO: (2/11/2017)\n\n    # sort the list\n    # arr = sorted(arr)\n\n    # if k is not divisible by any element in arr, return []\n    if k % arr[0][0]!= 0:\n        return []\n\n    # for each element in arr\n    #   if k is divisible by element, return the tuple\n    #   else, return []\n    return [tuple(arr[i]) for i, elem in enumerate(arr) if k % elem == 0]\n\nif __name__ == \"__main__\":\n    arr = [[1, 2, 3], [1, 2, 4], [2, 3, 4], [1, 2, 5], [2, 3, 5], [3, 4, 5]]\n    print(get_divisible_tuples(arr, 2))",
    "import collections\nimport random\n\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    divisible_tuples = []\n    for t in tuples:\n        if all(i % k == 0 for i in t):\n            divisible_tuples.append(t)\n    return divisible_tuples\n\n\ndef test_find_divisible_tuples():\n    tuples = [\n        (1, 2),\n        (1, 3),\n        (2, 3),\n        (2, 4),\n        (3, 4),\n        (3, 5),\n        (4, 5),\n        (4, 6),\n        (5, 6),\n        (6, 7),\n        (7, 8),\n        (8, 9),\n        (9, 10),\n        (10, 11),\n        (11, 12),\n        (12, 13),\n        (13, 14),\n        (14, 15),\n        (15, 16),\n        (16, 17),\n        (17, 18),\n        (18, 19),\n        (19, 20),\n        (20, 21),\n        (21, 22),\n        (22, 23),\n        (23, 24),\n        (24, 25),\n        (25, 26),\n        (26, 27),\n        (27, 28),\n        (28, 29),\n        (29, 30),\n        (30, 31),\n        (31, 32),\n        (32, 33),\n        (33, 34),\n        (34, 35),\n        (35, 36),\n        (36, 37),\n        (37, 38),\n        (38, 39),\n        (39, 40),\n        (40, 41),\n        (41, 42),\n        (42, 43),\n        (43, 44),\n        (44, 45),\n        (45, 46),\n        (46, 47),\n        (47, 48),\n        (48, 49),\n        (49, 50),\n        (50, 51),\n        (51,",
    "from collections import defaultdict\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    div_tuples = defaultdict(list)\n    for t in tuples:\n        div_tuples[t[0]].append(t[1:])\n    div_tuples = [x for x in div_tuples.values() if len(x) > 1]\n    return div_tuples\n\nclass Solution(object):\n    def findDivisibleTuple(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return find_divisible_tuples(tuples, k)",
    "def tuples_with_all_elements_divisible_by_k(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    result = []\n    for tuple in tuples:\n        if sum(tuple) % k == 0:\n            result.append(tuple)\n    return result\n\n# Your TupleWithAllElementsDivisibleByK solution\n# Tuples: [[1, 2, 3], [2, 3, 4], [3, 4, 5], [3, 4, 5, 6]]\n# k = 3\n# return [[1, 2, 3], [2, 3, 4], [3, 4, 5]]",
    "def findDivisible(tuples, k):\n    for t in tuples:\n        for i in range(len(t)):\n            if t[i] % k!= 0:\n                return False\n    return True\n\n# Your function should return a list of tuples.\n# Each tuple should have three elements: the first is the value of the tuple,\n# the second is the index of the tuple, and the third is the number of times\n# the value of the tuple appears in the input list.\n# If no tuples are divisible by k, return an empty list.",
    "class Solution(object):\n    def findDivisibleTuple(self, tupleList, k):\n        \"\"\"\n        :type tupleList: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the input list\n        tupleList.sort()\n        \n        # construct the result list\n        result = []\n        \n        # iterate through the input list\n        for i in range(len(tupleList)):\n            # check if the current tuple is divisible by k\n            if tupleList[i][0] % k!= 0 or tupleList[i][1] % k!= 0:\n                continue\n            \n            # add the current tuple to the result list\n            result.append(tupleList[i])\n        \n        # return the result\n        return result",
    "# https://www.hackerrank.com/challenges/divisible-sum-pairs/problem\n\ndef divisibleSumPairs(A, k):\n    \"\"\"\n    :type A: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    ans = []\n    for i in range(len(A)):\n        for j in range(i + 1, len(A)):\n            if A[i][0] % k == 0 and A[j][0] % k == 0:\n                ans.append([A[i][0], A[j][0]])\n    return ans\n\nif __name__ == \"__main__\":\n    A = [[1, 1], [2, 3], [4, 9], [8, 13], [12, 21]]\n    k = 7\n    print(divisibleSumPairs(A, k))",
    "def find_divisible_tuples(tuples, k):\n    if k == 1:\n        for t in tuples:\n            if t[0] % k == 0 and t[1] % k == 0 and t[2] % k == 0 and t[3] % k == 0:\n                yield t\n    else:\n        for t in tuples:\n            if t[0] % k == 0 and t[1] % k == 0 and t[2] % k == 0 and t[3] % k == 0:\n                for div in find_divisible_tuples(tuples, k-1):\n                    yield div\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2, 3, 4), (2, 2, 2, 2), (3, 3, 3, 3)]\n    print(find_divisible_tuples(tuples, 2))",
    "import collections\n\ndef find_divisible(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    result = []\n    for i in range(len(tuples)):\n        for j in range(len(tuples[i])):\n            if tuples[i][j] % k == 0:\n                result.append([tuples[i][j]])\n                break\n    return result\n\nif __name__ == \"__main__\":\n    tuples = [[1, 2, 3], [2, 2, 2]]\n    k = 3\n    result = find_divisible(tuples, k)\n    print(result)",
    "import unittest\n\n\ndef all_divisible(tuples, k):\n    for t in tuples:\n        for i in range(len(t)):\n            if t[i] % k!= 0:\n                return False\n    return True\n\n\nclass Test(unittest.TestCase):\n    def test_all_divisible(self):\n        self.assertTrue(all_divisible([(1, 2, 3), (2, 3, 4)], 2))\n        self.assertTrue(all_divisible([(1, 2, 3), (2, 3, 4)], 3))\n        self.assertFalse(all_divisible([(1, 2, 3), (2, 3, 4)], 5))\n        self.assertFalse(all_divisible([(1, 2, 3), (2, 3, 4)], 4))\n        self.assertTrue(all_divisible([(1, 2, 3), (2, 3, 4)], 4))\n        self.assertFalse(all_divisible([(1, 2, 3), (2, 3, 4)], 7))\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def find_divisible_tuples(tuples, k):\n\t# Your code here\n\t\n\t# tuples are tuples of (number, divisor)\n\t# return a list of tuples of (number, divisor)\n\t# which have all elements divisible by k\n\t\n\tif k < 0:\n\t\treturn []\n\t\n\tresult = []\n\tfor t in tuples:\n\t\tif k == 0:\n\t\t\treturn [t]\n\t\telif k % t[0] == 0:\n\t\t\tresult.append(t)\n\t\telse:\n\t\t\tbreak\n\t\n\tfor i in range(k // t[0]):\n\t\tresult.append((t[0] * i, t[1]))\n\t\n\treturn result",
    "# https://www.hackerrank.com/challenges/divisible-elements\n\ndef divisible_elements(tuples, k):\n    # print(tuples)\n    result = []\n    for tuple in tuples:\n        for i in range(len(tuple)):\n            if tuple[i] % k == 0:\n                result.append(tuple)\n    return result\n\n# tuples = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 5)]\n\n# tuples = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 5), ([1,2,3,4,5], 6)]\n\n# tuples = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 5), ([1,2,3,4,5], 6), ([1,2,3,4,5], 7)]\n\ntuples = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 5), ([1,2,3,4,5], 6), ([1,2,3,4,5], 7)]\n\n# tuples = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 5), ([1,2,3,4,5], 6), ([1,2,3,4,5], 7), ([1,2,3,4,5], 8)]\n\nk = 7\n\nresult = divisible_elements(tuples, k)\n\n# print(result)\n\nfor i in range(len(result)):\n    print(result[i])",
    "class Solution:\n    def findDivisibleTuple(self, A, k):\n        \"\"\"\n        :type A: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(A)\n        res = []\n        for i in range(n):\n            for j in range(i, n):\n                if A[i][j] % k == 0:\n                    res.append(A[i][j])\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    A = [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166",
    "import collections\n\n\nclass Solution:\n    def allPairsDivisibleBy(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        dic = collections.defaultdict(list)\n        for num in nums:\n            dic[num % k].append(num)\n        return [list(p) for p in dic.values()]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.allPairsDivisibleBy([1, 2, 3], 2))\n    print(sol.allPairsDivisibleBy([1, 2, 3], 3))",
    "def tuplesDivisibleByK(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # Write your code here\n    ans = []\n    for t in tuples:\n        if t[0] % k == 0:\n            ans.append(t)\n    return ans",
    "import numpy as np\n\n\ndef get_all_divisors(lst, k):\n    \"\"\"\n    :param lst: list of tuples\n    :param k: number of divisors\n    :return: all divisors of k from lst\n    \"\"\"\n    return [(i, j) for i in range(1, k+1) for j in range(1, k+1) if lst[i-1] == lst[j-1]]\n\n\ndef main():\n    lst = [(3, 5), (1, 4), (3, 1), (3, 1), (3, 2), (5, 3)]\n    divisors = get_all_divisors(lst, 3)\n    print(divisors)\n\nif __name__ == \"__main__\":\n    main()",
    "def divisible_tuples(tuples, k):\n\treturn [tuple for tuple in tuples if all(x % k == 0 for x in tuple)]\n\n# Your code here\n\nif __name__ == '__main__':\n\ttuples = [(1,2),(3,4),(5,6)]\n\tprint(divisible_tuples(tuples, 3))",
    "import timeit\n\n\nclass Solution(object):\n    def findDivisibleTuple(self, k, tuples):\n        \"\"\"\n        :type k: int\n        :type tuples: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, tuple_ in enumerate(tuples):\n            for j in range(len(tuple_)):\n                if tuple_[j] % k == 0:\n                    result.append(tuple_[:j] + tuple_[j+1:] + [k])\n        return result\n\n\nif __name__ == '__main__':\n    k = 2\n    n = 4\n    s = timeit.timeit(\"Solution().findDivisibleTuple(k, tuples)\", setup=\"from __main__ import Solution, tuples\", number=1)\n    print(k, n, s)",
    "import math\n\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # sort the tuples\n    tuples = sorted(tuples, key=lambda x: x[0])\n    # find all divisible tuples\n    divisible_tuples = []\n    for i in range(len(tuples)):\n        if math.modf(tuples[i][1] / k) == (0, 0):\n            divisible_tuples.append(tuples[i])\n    return divisible_tuples\n\n\nif __name__ == '__main__':\n    tuples = [\n        [1, 2, 3],\n        [2, 2, 3],\n        [3, 2, 3],\n        [3, 3, 3],\n        [4, 3, 3],\n        [4, 4, 3],\n        [5, 4, 3],\n        [5, 5, 3],\n        [6, 5, 3],\n        [6, 6, 3],\n        [7, 6, 3],\n        [7, 7, 3],\n        [8, 7, 3],\n        [8, 8, 3],\n        [9, 8, 3],\n        [9, 9, 3],\n        [10, 9, 3],\n        [10, 10, 3],\n        [11, 10, 3],\n        [11, 11, 3],\n        [12, 11, 3],\n        [12, 12, 3],\n        [13, 12, 3],\n        [13, 13, 3],\n        [14, 13, 3],\n        [14, 14, 3],\n        [15, 14, 3],\n        [15, 15, 3],\n        [16, 15, 3],\n        [16, 16, 3],\n        [17, 16, 3],\n        [17, 17, 3],\n        [18, 17, 3],\n        [18, 18, 3],\n        [19, 18, 3],\n        [19, 19, 3],\n        [20, 19, 3],",
    "import unittest\n\n\ndef tuples_with_all_divisible(tuples, k):\n    return [tuple(sorted(t)) for t in tuples if all(divisible(t, k))]\n\n\ndef divisible(t, k):\n    return any(i % k for i in t)\n\n\nclass Test(unittest.TestCase):\n\n    def test_tuples_with_all_divisible(self):\n        tuples = [(1, 2), (3, 4), (5, 6), (7, 8)]\n        self.assertEqual(tuples_with_all_divisible(tuples, 3), [(1, 2), (3, 4), (5, 6)])\n        self.assertEqual(tuples_with_all_divisible(tuples, 7), [(1, 2), (3, 4), (5, 6)])\n        self.assertEqual(tuples_with_all_divisible(tuples, 9), [(1, 2), (3, 4), (5, 6), (7, 8)])\n        self.assertEqual(tuples_with_all_divisible(tuples, 10), [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "# https://leetcode.com/problems/find-all-divisible-triplets/\n# Definition for a triplet\nclass Triplet(object):\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __repr__(self):\n        return str(self.x) + \" \" + str(self.y) + \" \" + str(self.z)\n\n\nclass Solution(object):\n    def findDivisibleTriplets(self, nums, k):\n        \"\"\"\n        :type nums: List[Triplet]\n        :type k: int\n        :rtype: List[Triplet]\n        \"\"\"\n        res = []\n        self.findDivisibleTriplets(nums, k, 0, 0, [], res)\n        return res\n\n    def findDivisibleTriplets(self, nums, k, idx, num, result, res):\n        if idx >= len(nums):\n            return\n        for i in range(idx, len(nums)):\n            if nums[i].x % k == 0 and nums[i].y % k == 0 and nums[i].z % k == 0:\n                result.append(nums[i])\n                self.findDivisibleTriplets(nums, k, i+1, nums[i].x, result, res)\n                self.findDivisibleTriplets(nums, k, i+1, nums[i].y, result, res)\n                self.findDivisibleTriplets(nums, k, i+1, nums[i].z, result, res)\n        return\n\n# https://leetcode.com/problems/find-all-divisible-triplets/discuss/115629/Python-DP-solution\nclass SolutionDP(object):\n    def findDivisibleTriplets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[Triplet]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in range(",
    "def divisible_tuples(tuples, k):\n    return [tuple for tuple in tuples if all(element % k == 0 for element in tuple)]\n\nclass Solution:\n    def divisibleTuples(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k == 0:\n            return []\n        result = []\n        for i in range(n):\n            for j in range(k):\n                result.append([i, j])\n        return result",
    "class Solution:\n    # @param {List[List[int]]} nums\n    # @param {int} k\n    # @return {List[List[int]]}\n    def allPairsDivisible(self, nums, k):\n        n = len(nums)\n        ret = []\n        for i in range(n):\n            for j in range(i, n):\n                if nums[i][0] % k == 0 and nums[j][0] % k == 0:\n                    ret.append([nums[i][0], nums[j][0]])\n        return ret",
    "import unittest\n\n\ndef find_divisible_tuples(tuples, k):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuples if all(i % k == 0 for i in t)]\n\n\nclass TestFindDivisibleTuples(unittest.TestCase):\n\n    def test_find_divisible_tuples(self):\n        tuples = [(1, 2, 3), (1, 2, 3, 4, 5)]\n        self.assertEqual(find_divisible_tuples(tuples, 4), [(1, 2, 3, 4), (1, 2, 3, 5)])\n        self.assertEqual(find_divisible_tuples(tuples, 5), [])\n\n\nif __name__ == '__main__':\n    unittest.main()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}