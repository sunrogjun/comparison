{
  "problem": {
    "task_id": "MBPP/54",
    "prompt": "Write a function to sort the given array by using counting sort.",
    "canonical_solution": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list",
    "test_list": [
      "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
      "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
      "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
    ],
    "challenge_test_list": [],
    "problem_id": 43
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def counting_sort(arr):\n    \"\"\"\n    >>> counting_sort([2,1,4,3])\n    [1, 2, 3, 4]\n    >>> counting_sort([2,4,3,1])\n    [1, 2, 3, 4]\n    >>> counting_sort([3,4,2,1])\n    [1, 2, 3, 4]\n    >>> counting_sort([1,4,3,2])\n    [1, 2, 3, 4]\n    >>> counting_sort([1,4,3,2,4])\n    [1, 2, 3, 4]\n    >>> counting_sort([4,2,3,1])\n    [1, 2, 3, 4]\n    >>> counting_sort([4,3,1,2])\n    [1, 2, 3, 4]\n    >>> counting_sort([4,3,1,2,4])\n    [1, 2, 3, 4]\n    >>> counting_sort([1,2,3,4,5])\n    [1, 2, 3, 4, 5]\n    >>> counting_sort([1,2,3,4,5,6,7,8,9,10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \"\"\"\n    res = [0]*len(arr)\n    for i in range(1, len(arr)):\n        res[arr[i]] = res[arr[i-1]] + 1\n    for i in range(len(arr)-1, -1, -1):\n        arr[i] = res[i]\n\ndef test_counting_sort():\n    assert counting_sort([2,1,4,3]) == [1, 2, 3, 4]\n    assert counting_sort([2,4,3,1]) == [1, 2, 3, 4]\n    assert counting_sort([3,4,2,1]) == [1, 2, 3, 4]\n    assert counting_sort([1,4,3,2]) == [1, 2, 3, 4]\n    assert counting_sort([1,4,3,2,4]) == [1,",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def sort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        n = len(intervals)\n        count = [0] * n\n        for i in xrange(n):\n            count[intervals[i].start] += 1\n        for i in xrange(n):\n            intervals[i].start = count[intervals[i].start]\n        for i in xrange(n):\n            count[intervals[i].end] += 1\n        for i in xrange(n):\n            intervals[i].end = count[intervals[i].end]\n\n    def sort2(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        n = len(intervals)\n        for i in xrange(n):\n            if intervals[i].end <= intervals[i].start:\n                # print \"swapping\", i, \"with\", (i-1)%n, \"in\", intervals\n                intervals[i], intervals[i-1] = intervals[i-1], intervals[i]\n        for i in xrange(n):\n            if intervals[i].end <= intervals[i].start:\n                # print \"swapping\", i, \"with\", (i+1)%n, \"in\", intervals\n                intervals[i], intervals[i+1] = intervals[i+1], intervals[i]\n        for i in xrange(n-1):\n            if intervals[i].start < intervals[i+1].start:\n                # print \"swapping\", i, \"with\", (i+1)%n, \"in\", intervals\n                intervals[i], intervals[i+1] = intervals[i+1], intervals[i]\n\n        for i in xrange(n-",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def countingSort(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        count = [0] * 10\n        curr = head\n        while curr:\n            count[curr.val] += 1\n            curr = curr.next\n        count.reverse()\n        curr = head\n        for i in range(len(count)):\n            curr.val, curr.next = count[i], curr\n            curr = curr.next\n        return head",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n\n        # sort each group\n        for i in range(n):\n            nums[i], nums[n-1] = nums[n-1], nums[i]\n            nums[i:n] = nums[i:n] + nums[i+1:n]\n\n        # count each group\n        count = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if nums[i] < nums[j]:\n                    count[i] += 1\n\n        # sort each group\n        for i in range(n):\n            nums[i], nums[n-1] = nums[n-1], nums[i]\n            nums[i:n] = nums[i:n] + nums[i+1:n]\n            nums[i:n] = [count[i] for i in range(n)]\n\n    def countSort2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n\n        # sort each group\n        for i in range(n):\n            nums[i], nums[n-1] = nums[n-1], nums[i]\n            nums[i:n] = nums[i:n] + nums[i+1:n]\n\n        # count each group\n        count = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if nums[i] < nums[j]:\n                    count[i] += 1\n\n        # sort each group\n        for i in range(n):\n            nums[i], nums[n-1] = nums",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def countingSort(self, num):\n        if not num:\n            return\n        cnt = [0] * len(num)\n        for i in xrange(len(num)):\n            cnt[num[i]] += 1\n        for i in xrange(len(num)):\n            num[i] = cnt[i]\n        self.countingSort(num)\n\nif __name__ == '__main__':\n    s = Solution()\n    s.countingSort([3, 2, 1, 5, 6])",
    "def count_sort(arr):\n    \"\"\"\n    Write a function to sort the given array by using counting sort.\n\n    You should not modify the original array.\n    Assume that the number of elements are well defined.\n    :param arr: The given array\n    :return: The sorted array\n    \"\"\"\n    cnt = [0] * len(arr)\n    for i in range(len(arr)):\n        cnt[arr[i]] += 1\n    for i in range(len(cnt)):\n        arr[i] = cnt[i]\n\n    return arr\n\nif __name__ == \"__main__\":\n    arr = [3, 4, 5, 1, 2]\n    print(count_sort(arr))\n    arr = [2, 4, 5, 1, 3]\n    print(count_sort(arr))",
    "class Solution:\n    # @param num, a list of integer\n    # @return void\n    def sort(self, num):\n        if len(num) == 0:\n            return\n        cnt = [0] * len(num)\n        for i in range(len(num)):\n            cnt[num[i]] += 1\n        cnt.sort()\n        for i in range(len(num)):\n            num[i] = cnt[i]\n        return num\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.sort([3,3,2,1,1,2])",
    "class Solution(object):\n    def countingSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # sort by frequency\n        n = len(nums)\n        c = [0 for i in xrange(n)]\n        for i in xrange(n):\n            c[nums[i]] += 1\n        # sort by frequency\n        for i in xrange(n):\n            for j in xrange(c[i]):\n                nums[j] = i\n        # sort by frequency\n        for i in xrange(n):\n            for j in xrange(n):\n                if c[j] > c[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n        return\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,1,2,3]\n    Solution().countingSort(nums)\n    print nums\n    # nums = [3,1,1,3,2,2]\n    # nums = [3,1,3,2,2]\n    # nums = [1,3,2,3,2,1]\n    # nums = [1,3,1,2,2,3]\n    # nums = [3,1,3,2,2]\n    # nums = [3,3,2,1,2]\n    # nums = [3,3,2,2,1]\n    # nums = [1,2,3,3,2]\n    # nums = [3,1,2,3,1]\n    # nums = [3,1,3,2,2]\n    # nums = [1,2,3,3,2]\n    # nums = [3,1,2,3,2]\n    # nums = [3,3,2,1,2]\n    # nums = [3,3,2,2,1]\n    # nums = [3,3",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        self.countSort(nums, 0, n)\n\n    def countSort(self, nums, start, end):\n        if start == end:\n            return\n        mid = (start + end) // 2\n        self.countSort(nums, start, mid)\n        self.countSort(nums, mid + 1, end)\n        for i in range(start, end):\n            nums[i] += nums[mid]\n            nums[mid] = nums[i]\n\n\nif __name__ == '__main__':\n    nums = [3, 2, 1, 0]\n    print(Solution().countSort(nums))",
    "class Solution:\n    # @param num, a list of integer\n    # @return void\n\n    # @time complexity: O(n)\n    # @space complexity: O(n)\n    def countingSort(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void\n        \"\"\"\n        count = [0] * 101\n        for i in num:\n            count[i] += 1\n\n        for i in range(101):\n            for j in range(count[i]):\n                num[j], num[count[i]-j-1] = num[count[i]-j-1], num[j]\n\n        return",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        count = [0] * 10\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        \n        #print(count)\n        for i in range(10):\n            count[i] = count[i] + 1\n            #print(count[i])\n        \n        cur = head\n        head = None\n        while cur:\n            count[cur.val] -= 1\n            if count[cur.val] == 0:\n                if head is None:\n                    head = cur\n                else:\n                    head.next = cur\n                head = None\n            cur = cur.next\n        \n        return head\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head = Solution().sortList(head)\n    while head:\n        print(head.val)\n        head = head.next",
    "import unittest\n\nfrom sorting_array import counting_sort\n\nclass TestSortingArray(unittest.TestCase):\n    def test_counting_sort(self):\n        self.assertEqual(counting_sort([1,5,9,2,1,9,8,5,1,1]), [1, 1, 2, 5, 9, 8, 9, 5, 1, 1])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def counting_sort(arr):\n    \"\"\"\n    Input:\n        arr: a list of integers\n    Output:\n        A sorted list of integers\n    Follow up:\n        Do it in O(n log n) time and O(1) extra space.\n    \"\"\"\n    n = len(arr)\n    c = [0 for i in range(n)]\n    for i in range(n):\n        c[arr[i]] += 1\n    for i in range(n):\n        arr[i] = c[i]\n    return arr\n\nif __name__ == '__main__':\n    arr = [1, 3, 2]\n    print(counting_sort(arr))",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def countingSort(self, nums):\n        n = len(nums)\n        if n < 2:\n            return\n        cnt = [0] * n\n        for i in range(n):\n            cnt[i] = nums[i]\n        for i in range(n):\n            for j in range(i+1, n):\n                if cnt[j] < cnt[i]:\n                    cnt[j] += cnt[i]\n                    cnt[i] = cnt[j]\n        for i in range(n):\n            nums[i] = cnt[i]",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        n = len(num)\n        for i in range(n):\n            for j in range(i+1, n):\n                if num[i] > num[j]:\n                    num[i], num[j] = num[j], num[i]",
    "import sys\n\ndef count_sort(a):\n    \"\"\"\n    >>> count_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    # write your code here\n    # for each element, count it and add it to the list\n    # at the same time, count the number of times the element appears\n    # if the count is greater than the current max, update the max\n    # if the count is equal to the current max, update the current max\n    # if the count is less than the current max, update the current max\n    # if the count is 0, remove the element\n    # at the end of the loop, return the sorted list\n    # if the list is empty, return an empty list\n    if a == []:\n        return []\n    c = [0] * len(a)\n    for i in range(len(a)):\n        c[a[i]] += 1\n    for i in range(len(a)):\n        if c[i] > c[i + 1]:\n            c[i + 1] = c[i]\n    for i in range(len(a)):\n        c[i] = a[i] + c[i]\n    return [a[i] for i in range(len(a)) if c[i] == c[i + 1]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "class Solution(object):\n    def countingSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            cnt = [0] * n\n            for j in range(n):\n                cnt[j] += nums[j]\n            for j in range(n):\n                nums[j] = cnt[j]\n        # print(nums)\n\n    def countingSort2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        # nums.sort()\n        for i in range(n):\n            cnt = [0] * n\n            for j in range(n):\n                cnt[j] += nums[j]\n            for j in range(n):\n                nums[j] = cnt[j]\n        # print(nums)\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,3,3,4,5]\n    print(Solution().countingSort(nums))\n    nums = [1,3,3,3,3,3,4,5]\n    print(Solution().countingSort2(nums))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def sortList(self, head):\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        count = [0] * 10\n        pre = head\n        cur = head.next\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        result = []\n        while head:\n            if count[head.val] == 1:\n                result.append(head)\n                pre = head\n            head = head.next\n        while pre:\n            if count[pre.val] == 0:\n                result.append(pre)\n                break\n            pre = pre.next\n        return result\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    print Solution().sortList(head)",
    "def counting_sort(A):\n    \"\"\"\n    Sort the given array using counting sort.\n    Input: A is a list of integers.\n    Output: The sorted array.\n    \"\"\"\n    n = len(A)\n    c = [0] * n\n    for i in range(n):\n        c[A[i]] += 1\n    for i in range(n):\n        c[i] = c[i] + 1\n    for i in range(n):\n        c[i] = A[i] + 1 - c[i]\n    c.sort()\n    B = [0] * n\n    for i in range(n):\n        B[c[i]-1] = A[i]\n    return B\n\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5]\n    print(counting_sort(A))",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of integers\n    def sort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        n = len(intervals)\n        # intervals = sorted(intervals, key=lambda x: x.start)\n        # intervals = sorted(intervals, key=lambda x: x.end)\n        # for i in range(n):\n        #     if i > 0 and intervals[i].end < intervals[i-1].end:\n        #         intervals[i], intervals[i-1] = intervals[i-1], intervals[i]\n        # print(intervals)\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(intervals, key=lambda x: x.end))\n        # print(sorted(inter",
    "class Solution(object):\n    def countSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: None\n        \"\"\"\n        self.count(A)\n        self.sort(A)\n\n    def count(self, A):\n        count = [0 for i in range(len(A))]\n        for i in range(len(A)):\n            count[A[i]] += 1\n        for i in range(len(A)):\n            A[i] = count[i]\n\n    def sort(self, A):\n        for i in range(len(A)):\n            for j in range(i, len(A)):\n                if A[i] > A[j]:\n                    A[i], A[j] = A[j], A[i]\n        return A\n\n\n\nif __name__ == \"__main__\":\n    A = [5, 4, 3, 2, 1]\n    sol = Solution()\n    sol.countSort(A)\n    print(A)",
    "def sort_by_counting_sort(arr):\n    \"\"\"\n    Input: arr is a list of integers\n    Output: The sorted array\n    \"\"\"\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = count[i]\n    return arr\n\nif __name__ == \"__main__\":\n    arr = [3, 1, 4, 2, 5, 9]\n    print(sort_by_counting_sort(arr))",
    "class Solution:\n    # @return a list of integers\n    def countingSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = [0] * len(arr)\n        for i in range(len(arr)):\n            count[arr[i]] += 1\n        for i in range(len(count)):\n            arr[i] = count[i]\n        return arr",
    "def count_sort(arr):\n    \"\"\"\n    >>> count_sort([1,3,4,2,2])\n    [1, 1, 2, 2, 3, 4]\n    >>> count_sort([])\n    []\n    >>> count_sort([1,2,3,4,5,6,7])\n    [1, 1, 2, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    counts = [0] * len(arr)\n    for i in range(len(arr)):\n        counts[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = counts[i]\n    return arr\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def countSort(A):\n    \"\"\"\n    :type A: List[int]\n    :rtype: void Do not return anything, modify A in-place instead.\n    \"\"\"\n    n = len(A)\n    c = [0] * (n + 1)\n    for i in range(1, n + 1):\n        c[A[i - 1]] += 1\n    for i in range(n):\n        A[c[A[i]] - 1] = A[i]\n        c[A[i]] -= 1\n\nif __name__ == \"__main__\":\n    A = [4, 5, 6, 7, 0, 1, 2]\n    countSort(A)\n    print(A)",
    "def counting_sort(arr):\n    \"\"\"\n    Sort the given array by using counting sort.\n    :param arr: Array to sort.\n    :return: Sorted array.\n    \"\"\"\n    n = len(arr)\n    # Sort the elements in the given array.\n    for i in range(1, n + 1):\n        # Create an array that stores the number of elements in each column.\n        count = [0] * n\n        for j in range(0, i):\n            # If the element in the j-th column is greater than the maximum\n            # element in the j-th column, then increase the number of elements\n            # in the j-th column by 1.\n            if arr[j] > arr[j + i - 1]:\n                count[j] += 1\n        # Update the maximum element in the j-th column.\n        arr[i - 1] = max(arr[i - 1], arr[j] + count[j])\n    return arr",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        p = dummy\n        while p.next is not None:\n            p = p.next\n            \n            while p.next is not None and p.next.val <= p.next.next.val:\n                p = p.next\n            \n            p.next = ListNode(0)\n            p.next.next = p.next.next.next\n            p.next.next.next = p.next\n            p.next = p.next.next\n        \n        return dummy.next",
    "class Solution(object):\n    def sortArrayByCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        cnt = [0] * n\n        for i in range(n):\n            cnt[nums[i]] += 1\n        for i in range(n):\n            cnt[i] = cnt[i] - 1\n        for i in range(n):\n            cnt[i] = nums[i] - cnt[i]\n\n        for i in range(n):\n            nums[i] = i\n\n        for i in range(n):\n            for j in range(n):\n                if cnt[j] > 0:\n                    nums[j] = i\n                    break\n        return\n\n\nif __name__ == \"__main__\":\n    nums = [2, 5, 1, 3, 3]\n    nums = [3, 2, 1, 2, 3]\n    nums = [1, 2, 2, 3]\n    nums = [1, 2, 3, 4]\n    nums = [1, 2, 3, 4, 5]\n    nums = [1, 2, 3, 4, 5, 6]\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Solution().sortArrayByCount(nums)\n    for i in nums:\n        print(i)",
    "import sys\nimport timeit\n\n\ndef counting_sort(a):\n    \"\"\"\n    Use counting sort to sort the given array.\n\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(a)\n    count = [0] * n\n    for i in range(n):\n        count[a[i]] += 1\n    for i in range(n):\n        a[i] = count[i]\n    return a\n\n\ndef main():\n    \"\"\"\n    Use counting sort to sort the given array.\n    \"\"\"\n    start = timeit.default_timer()\n    a = [10, 12, 8, 4, 1, 6, 7, 3, 2]\n    print('Using counting sort:')\n    print(counting_sort(a))\n    print(timeit.default_timer() - start,'seconds elapsed')\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def countingSort(self, head):\n        dic = {}\n        count = 0\n        while head:\n            if head.val not in dic:\n                dic[head.val] = count\n            else:\n                dic[head.val] = dic[head.val] + 1\n            count += 1\n            head = head.next\n        \n        for i in range(len(dic)):\n            dic[i] = dic[i] + 1\n        \n        res = ListNode(0)\n        cur = res\n        while dic:\n            cur.next = ListNode(dic[dic.keys()[0]])\n            cur = cur.next\n            del dic[dic.keys()[0]]\n        \n        return res.next",
    "# https://github.com/Makzk/Python-Exercises/blob/master/Counting_Sort/Counting_Sort.py\n\ndef counting_sort(arr):\n    \"\"\"\n    Sort the given array.\n    \"\"\"\n    \n    n = len(arr)\n    count = [0] * n\n    \n    for i in range(n):\n        count[arr[i]] += 1\n    \n    for i in range(n):\n        arr[i] = count[i]\n    \n    return arr\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 4, 5, 3]\n    print(arr)\n    \n    arr = [1, 4, 3, 2, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1, 2, 3, 4, 5]\n    print(arr)\n    \n    arr = [1,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def countSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        count = [0] * 10\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n\n        for i in range(1, 10):\n            for j in range(i, 10):\n                cur = head\n                while cur:\n                    if cur.val == j:\n                        cur.val = i\n                    cur = cur.next\n        return head",
    "class Solution(object):\n    def sortArrayByCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        c = [0] * n\n        for i in range(n):\n            c[i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if c[i] > c[j]:\n                    c[i], c[j] = c[j], c[i]\n        for i in range(n):\n            nums[i] = c[i]",
    "import random\n\ndef counting_sort(arr):\n    \"\"\"\n    Sort the given array using counting sort.\n\n    Input:\n    The input is an unsorted array.\n    Output:\n    The output is an array that has been sorted in increasing order.\n\n    Time Complexity: O(n^2)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(arr)\n    cnt = [0] * n\n    for i in range(n):\n        cnt[arr[i]] += 1\n    for i in range(n):\n        arr[i] = cnt[arr[i]]\n    return arr\n\nif __name__ == '__main__':\n    n = 100\n    arr = [random.randint(0, n) for i in range(n)]\n    print(arr)\n    arr = counting_sort(arr)\n    print(arr)\n    print(counting_sort(arr))",
    "__author__ = 'Danyang'\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n\n        p, n = head, 0\n        while p:\n            n += 1\n            p = p.next\n        counts = [0] * n\n        while head:\n            counts[head.val] += 1\n            head = head.next\n        for i in range(n):\n            counts[i] = counts[i] + 1\n\n        p = head\n        for i in range(n):\n            p.next = ListNode(i)\n            p = p.next\n            p.val = i\n            p.next = None\n            p = p.next\n            p.next = head\n            head = p.next\n\n        for i in range(n):\n            p.next = ListNode(counts[i])\n            p = p.next\n            p.val = i\n            p.next = None\n            p = p.next\n            p.next = head\n            head = p.next\n\n        return head",
    "# https://www.codewars.com/kata/50e9e8c6f9e0f9d9f7d5/train/python\n\ndef counting_sort(array):\n    \"\"\"\n    :param array: the given array\n    :return: the sorted array\n    \"\"\"\n    # http://www.geeksforgeeks.org/counting-sort/\n    # http://www.geeksforgeeks.org/counting-sort-dp-based-sorting/\n    # http://www.geeksforgeeks.org/counting-sort-with-extra-memory/\n    # https://www.youtube.com/watch?v=QwQ9gv2oE0E\n    # https://www.youtube.com/watch?v=iRf8o9dU8X0\n\n    # The solution is to do counting sort for each element in the array.\n    # If the value is greater than the previous value, increment the count of that element.\n    # If the value is less than the previous value, decrement the count of that element.\n    # Finally, sort the array.\n\n    count = [0] * len(array)\n    for i in range(len(array)):\n        count[array[i]] += 1\n\n    for i in range(len(array)):\n        if count[i] > 0:\n            count[i] -= 1\n            count[i - 1] += 1\n\n    for i in range(len(array)):\n        array[i] = count[i]\n\n    return array\n\nif __name__ == '__main__':\n    print(counting_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(counting_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\n    print(counting_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\n    print(counting_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def countSort(self, intervals: 'List[Interval]') -> 'List[Interval]':\n        def dfs(intervals: 'List[Interval]', index: 'int'):\n            if index >= len(intervals):\n                return\n            left = index\n            right = index\n            while left < len(intervals):\n                if intervals[left].end < intervals[right].start:\n                    intervals[left], intervals[right] = intervals[right], intervals[left]\n                    left += 1\n                else:\n                    right += 1\n            dfs(intervals, left)\n            dfs(intervals, right)\n        intervals = list(sorted(intervals, key=lambda x: x.start))\n        dfs(intervals, 0)\n        return intervals",
    "import time\n\n\ndef sort_counting(nums):\n    \"\"\"\n    >>> sort_counting([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by increasing count, then decrease count\n    nums.sort(key=lambda x: (-x[1], x[0]))\n    nums.reverse()\n\n\ndef sort_counting_2(nums):\n    \"\"\"\n    >>> sort_counting_2([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by decreasing count, then increasing count\n    nums.sort(key=lambda x: (x[0], -x[1]))\n\n\ndef sort_counting_3(nums):\n    \"\"\"\n    >>> sort_counting_3([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by decreasing count, then increasing count\n    nums.sort(key=lambda x: (x[0], -x[1]))\n    nums.reverse()\n\n\ndef sort_counting_4(nums):\n    \"\"\"\n    >>> sort_counting_4([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by decreasing count, then increasing count\n    nums.sort(key=lambda x: (-x[1], x[0]))\n    nums.reverse()\n\n\ndef sort_counting_5(nums):\n    \"\"\"\n    >>> sort_counting_5([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by decreasing count, then increasing count\n    nums.sort(key=lambda x: (x[0], -x[1]))\n    nums.reverse()\n\n\ndef sort_counting_6(nums):\n    \"\"\"\n    >>> sort_counting_6([3, 1, 4, 2])\n    [1, 2, 3, 4]\n    \"\"\"\n    # sort by decreasing count, then increasing count\n    nums.sort(key=lambda x: (x[0], -",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = [0 for _ in range(len(nums))]\n        for i in range(len(nums)):\n            count[nums[i]] += 1\n        for i in range(len(nums)):\n            nums[i] = count[i]\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countSort([3,1,5,2,6]))",
    "def count_sort(arr):\n    \"\"\"\n    Write a function to sort the given array by using counting sort.\n    \"\"\"\n    count = [1 for i in range(len(arr))]\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                arr[j], arr[i] = arr[i], arr[j]\n                count[i] += 1\n    return count\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9]\n    print(count_sort(arr))\n    arr = [1,2,3,4,5,6,7,8,9,10]\n    print(count_sort(arr))",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def sort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        for i in range(len(intervals)):\n            if intervals[i].end == intervals[i].start:\n                intervals[i].end += 1\n                intervals[i].start = 0\n        for i in range(len(intervals)):\n            j = i\n            while j >= 0 and intervals[j].start < intervals[i].start:\n                intervals[j + 1].end = intervals[i].end\n                intervals[j + 1].start = intervals[i].start\n                intervals[i].start = intervals[j].start\n                intervals[i].end = intervals[j].end\n                j -= 1\n            if j < 0:\n                intervals[i].end = intervals[i].start\n            else:\n                intervals[i].end = intervals[j + 1].end\n\nif __name__ == '__main__':\n    intervals = [Interval(0, 2), Interval(3, 5), Interval(1, 3)]\n    Solution().sort(intervals)\n    print(intervals)",
    "import unittest\n\n# https://leetcode.com/problems/counting-sort-array/description/\n# https://leetcode.com/problems/counting-sort-array/discuss/78963/Simple-python-solution-using-recursion-with-two-passes-and-explaination\n\n\ndef counting_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        min_val = arr[i]\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < min_val:\n                min_val = arr[j]\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        counting_sort(arr[i + 1:])\n\nclass Solution:\n    def sort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        counting_sort(arr)\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/counting-sort-array/solution/\n\n# 0ms 100%\nclass Solution {\n    public void sort(int[] arr) {\n        if (arr == null || arr.length == 0) return;\n        int[] count = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            count[arr[i]]++;\n        }\n        for (int i = arr.length - 1; i >= 0; i--) {\n            arr[i] = count[arr[i]]--;\n        }\n        sort(arr, 0, arr",
    "def counting_sort(arr):\n    \"\"\"\n    For an array of integers, using counting sort.\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    n = len(arr)\n    count = [0] * n\n    for i in range(n):\n        count[arr[i]] += 1\n    for i in range(n):\n        arr[i] = count[i]",
    "import unittest\n\nclass Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        cnt = [0] * n\n        for i in xrange(n):\n            cnt[nums[i]] += 1\n        \n        for i in xrange(n):\n            cnt[i] = cnt[i] + cnt[i + 1]\n        \n        for i in xrange(n):\n            nums[i] = i\n            for j in xrange(n):\n                if cnt[j] > 0:\n                    nums[i] = j\n                    break\n        \n        return\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/counting-sort/solution/\n#\nApproach #1: Counting Sort [Accepted]\nComplexity Analysis\nTime Complexity: O(n log n), where n is the number of elements in the array.\nSpace Complexity: O(n), the size of the array.\n\n# 1ms 99.65%\nclass Solution {\n    public void countSort(int[] nums) {\n        int n = nums.length;\n        int[] cnt = new int[n];\n        for (int i = 0; i < n; i++) {\n            cnt[nums[i]]++;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            cnt[i] = cnt[i] + cnt[i + 1];\n        }\n        \n        for (int i = 0; i < n; i++) {\n            nums[i] = i;\n            for (int j = 0; j < n; j++) {\n                if (cnt[j] > 0) {",
    "class Solution:\n    # @param nums, a list of integers\n    # @return nothing\n    def countingSort(self, nums):\n        count = [0] * len(nums)\n        for i in range(len(nums)):\n            count[nums[i]] += 1\n        for i in range(len(nums)):\n            nums[i] = count[nums[i]]\n        return nums\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [4,3,2,1,3,2,4,3,1,2,1]\n    s.countingSort(nums)\n    print(nums)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> None:\n        count = [0] * 256\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        for i in range(256):\n            count[i] = count[i] + 1\n        cur = head\n        while cur:\n            tmp = cur.val\n            cur.val = count[tmp]\n            count[tmp] = cur\n            cur = cur.next\n        head = head.val\n        while head:\n            tmp = head\n            head = count[head]\n            count[tmp] = head\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    Solution().sortList(head)\n    while head:\n        print(head.val, end=',')\n        head = head.next\n    print()",
    "def counting_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = count[i]\n\nif __name__ == '__main__':\n    arr = [2, 4, 1, 3, 5, 6, 7]\n    counting_sort(arr)\n    print arr",
    "def counting_sort(arr):\n    \"\"\"\n    Sort the given array by using counting sort.\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    # count the number of each value in the given array\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n    # write the sorted array\n    sorted_arr = [0] * len(arr)\n    for i in range(len(arr)):\n        sorted_arr[count[i]-1] = arr[i]\n        count[arr[i]] -= 1\n    return sorted_arr\n\nif __name__ == \"__main__\":\n    arr = [1,3,2,5,4]\n    print(counting_sort(arr))\n    arr = [1,2,3]\n    print(counting_sort(arr))",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        # print nums\n        # print nums[n-1]\n        cnt = [0] * n\n        for i in xrange(n):\n            cnt[i] = nums[i]\n        # print cnt\n        for i in xrange(n-1, -1, -1):\n            for j in xrange(n-i-1, -1, -1):\n                if cnt[j] < cnt[j+1]:\n                    cnt[j], cnt[j+1] = cnt[j+1], cnt[j]\n                    # print cnt\n        # print cnt\n        for i in xrange(n):\n            nums[i] = cnt[i]\n        # print nums\n        # print nums[n-1]\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    sol.countSort([3, 2, 1, 0])",
    "def countingSort(A):\n    \"\"\"\n    Write a function to sort the given array by using counting sort.\n\n    Your counting sort algorithm should do the following:\n    1. Initialize the counts array to be a zero-initialized array of size\n       equal to the size of the array.\n    2. For each element in the array, increment the value at the same index\n       of the counts array by 1.\n    3. Return the final counts array.\n    \"\"\"\n    counts = [0] * len(A)\n    for i in range(len(A)):\n        counts[i] = A[i]\n    for i in range(len(A)):\n        for j in range(i, len(A)):\n            if counts[j] < counts[i]:\n                counts[j] += 1\n                counts[i] -= 1\n                if counts[i] == 0:\n                    return counts\n    raise ValueError(\"Counting sort failed.\")\n\n\n# Example 1:\n\nA = [3, 2, 4, 1]\nB = [1, 3, 2, 4]\n\nprint(countingSort(A))\nprint(countingSort(B))",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def countingSort(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        count = [0] * len(num)\n        for i in range(len(num)):\n            count[num[i]] += 1\n\n        for i in range(len(count)):\n            for j in range(i+1, len(count)):\n                if count[j] < count[i]:\n                    count[i], count[j] = count[j], count[i]\n                    print(count)\n\n    def countingSort2(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        count = [0] * len(num)\n        for i in range(len(num)):\n            count[num[i]] += 1\n\n        for i in range(len(count)):\n            for j in range(i+1, len(count)):\n                if count[j] < count[i]:\n                    count[i], count[j] = count[j], count[i]\n                    print(count)\n\n    def countingSort3(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        count = [0] * len(num)\n        for i in range(len(num)):\n            count[num[i]] += 1\n\n        for i in range(len(count)):\n            for j in range(i+1, len(count)):\n                if count[j] < count[i]:\n                    count[i], count[j] = count[j], count[i]\n                    print(count)\n\n    def countingSort4(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: void Do not return anything, modify num in-place instead.\n        \"\"\"\n        count = [0] * len(num",
    "def sort_array(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: void\n    \"\"\"\n    count = [0] * len(array)\n    for i in range(len(array)):\n        count[array[i]] += 1\n    for j in range(len(array)):\n        array[j] = count[j]\n        count[j] = 0\n    return array\n\n\nif __name__ == '__main__':\n    array = [2, 5, 6, 1, 3, 4, 7, 8]\n    print(sort_array(array))",
    "def counting_sort(arr):\n    \"\"\"\n    For each element in arr, count the number of elements equal to it and store them into the list cnt.\n    For example: arr = [4, 1, 5, 6, 7] then cnt = [1, 3, 5, 4, 6].\n    Then sort the list by the elements in cnt.\n    \"\"\"\n    cnt = [0] * len(arr)\n    for i in range(len(arr)):\n        cnt[arr[i]] += 1\n    res = [0] * len(arr)\n    for i in range(len(arr)):\n        res[cnt[i] - 1] = arr[i]\n    return res\n\nif __name__ == \"__main__\":\n    arr = [4, 1, 5, 6, 7]\n    print(counting_sort(arr))",
    "import unittest\n\ndef count_sort(arr):\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n\n    for i in range(len(count)):\n        arr[i] = count[i]\n    return arr\n\nclass TestCntSort(unittest.TestCase):\n    def test_count_sort(self):\n        arr = [3, 1, 2, 5, 4]\n        expected = [1, 2, 3, 4, 5]\n        self.assertEqual(expected, count_sort(arr))\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "import collections\n\ndef count_sort(a):\n    \"\"\"\n    Input: an unsorted array a of integers\n    Output: the sorted array a\n    \"\"\"\n    # count the number of occurrences of each number\n    counts = collections.Counter(a)\n    # build a dictionary mapping each number to its number of occurrences\n    count_to_number = {value: key for key, value in counts.items()}\n\n    # sort by the number of occurrences of the number\n    sorted_by_count = sorted(count_to_number.items(),\n                             key=lambda x: x[1],\n                             reverse=True)\n    # convert the dictionary into an array of integers\n    sorted_by_count = [x[0] for x in sorted_by_count]\n    # return the sorted array\n    return sorted_by_count\n\nif __name__ == \"__main__\":\n    print(count_sort([-2, 0, 3, -1, -2, 1, 2, 0]))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        counts = [0] * 256\n        while head:\n            counts[head.val] += 1\n            head = head.next\n\n        for i in range(256):\n            counts[i] = counts[i] + counts[i + 1]\n            counts[i + 1] = counts[i]\n\n        cur = head\n        for i in range(256):\n            cur.val = i\n            cur = cur.next\n            cur.val = counts[i]\n\n        return head",
    "import unittest\n\n\nclass Solution:\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        c = [0] * n\n        for i in range(n):\n            c[i] = 1\n        for i in range(n):\n            j = nums[i]\n            while j > 0:\n                c[j] += 1\n                j -= c[j]\n        for i in range(n):\n            nums[i] = c[i]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/counting-sort/solution/\n#\n# Approach: Counting sort\n#\n# Time: O(n^2)\n# Space: O(n)\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#",
    "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return\n        count = [0] * n\n        for i in range(1, n):\n            count[i] = count[i-1] + nums[i]\n        for i in range(n-2, -1, -1):\n            nums[i], nums[count[i]] = nums[count[i]], nums[i]\n            count[i], count[i-1] = count[i-1], count[i]\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 2]\n    Solution().sort(nums)\n    print(nums)\n    # [1, 1, 2, 3]",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def countingSort(self, nums):\n        n = len(nums)\n        count = [0] * n\n        for i in range(n):\n            count[nums[i]] += 1\n\n        for i in range(n):\n            for j in range(count[i]):\n                nums[j] = i\n            count[i] = 0\n\n        for i in range(n):\n            for j in range(i):\n                nums[j] = nums[j] - i\n\n        return nums\n\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def countingSort2(self, nums):\n        n = len(nums)\n        count = [0] * n\n        for i in range(n):\n            count[nums[i]] += 1\n\n        for i in range(n):\n            for j in range(count[i]):\n                nums[j] = i\n            count[i] = 0\n\n        for i in range(n):\n            for j in range(n):\n                nums[j] = nums[j] - i",
    "# https://leetcode.com/problems/counting-sort/discuss/2550/Python-O(n)-space-and-O(n)-time-solution\n# https://leetcode.com/problems/counting-sort-ii/discuss/2550/Python-O(n)-space-and-O(n)-time-solution\n\n\nclass Solution(object):\n    def sortCountingSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        count = [0] * n\n        for i in range(n):\n            count[nums[i]] += 1\n\n        for i in range(n):\n            nums[i] = count[i]\n\n        count = [0] * n\n        for i in range(n):\n            count[nums[i]] += 1\n        for i in range(n):\n            nums[i] = count[i] - 1\n\n    def sortCountingSort2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n\n    def sortCountingSort3(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n\n    def sortCountingSort4(self, nums):\n        \"\"\"",
    "def counting_sort(arr):\n    \"\"\"\n    For the given array arr, write a function that returns the sorted\n    array.\n\n    Your function should use the following steps:\n\n    1. Make an empty list to store the sorted elements.\n    2. For each element in the array, increment the value of the\n    current element in the list by 1.\n    3. If the current element in the list is greater than the number\n    of elements in the array, append the current element to the end\n    of the list.\n    4. Sort the list using the original array as a reference.\n\n    For example, if arr is [1,3,5,2,4], your function should return\n    [1,2,3,4,5].\n    \"\"\"\n    return arr\n\n\ndef main():\n    assert counting_sort([1,3,5,2,4]) == [1,2,3,4,5]\n\n\nif __name__ == '__main__':\n    main()",
    "def counting_sort(arr):\n    \"\"\"\n    >>> arr = [2, 1, 6, 3, 4, 5]\n    >>> counting_sort(arr)\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    cnt = [0] * len(arr)\n    for i in range(1, len(arr)):\n        cnt[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = cnt[i]\n    return arr\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        count = [0] * 256\n        pre = ListNode(0)\n        pre.next = head\n        cur = pre\n        while cur.next:\n            count[cur.next.val] += 1\n            cur = cur.next\n        for i in range(256):\n            cur = pre\n            while cur and count[cur.val] == i:\n                cur = cur.next\n            if cur:\n                cur.next = head\n                head = cur\n        return pre.next",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        O(n log n)\n        \"\"\"\n        if not head or not head.next:\n            return head\n        count = [0] * 32\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        cur = head\n        while cur:\n            cur.val = count[cur.val]\n            cur = cur.next\n        return head\n\n    def sortList2(self, head: ListNode) -> ListNode:\n        \"\"\"\n        O(n log n)\n        \"\"\"\n        if not head or not head.next:\n            return head\n        count = [0] * 32\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        cur = head\n        while cur:\n            cur.val = count[cur.val]\n            cur = cur.next\n        return head\n\n    def sortList3(self, head: ListNode) -> ListNode:\n        \"\"\"\n        O(n log n)\n        \"\"\"\n        if not head or not head.next:\n            return head\n        count = [0] * 32\n        cur = head\n        while cur:\n            count[cur.val] += 1\n            cur = cur.next\n        cur = head\n        while cur:\n            cur.val = count[cur.val]\n            cur = cur.next\n        return head\n\n\nclass Solution2:\n    \"\"\"\n    O(n)\n    \"\"\"\n    def sortList(self, head: ListNode) -> ListNode:\n        cur = head\n        while cur:\n            cur.val, cur.next = cur.val, cur.next\n            cur = cur.next\n        return head\n\nclass Solution3:\n    \"\"\"\n    O(n)\n    \"\"\"\n    def sortList(self, head: ListNode) -> ListNode:\n        cur = head\n        while cur:",
    "def counting_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    n = len(arr)\n    count = [0] * n\n    for i in range(n):\n        count[arr[i]] += 1\n    for i in range(n):\n        arr[i] = count[i]\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6]\n    counting_sort(arr)\n    print arr\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    counting_sort(arr)\n    print arr\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    counting_sort(arr)\n    print arr\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    counting_sort(arr)\n    print arr\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,",
    "def counting_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    # count the number of times each element appears in the array\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n\n    # generate the sort key for each element\n    for i in range(len(arr)):\n        arr[i] = count[i]\n\n    # sort the array\n    sorted_arr = sorted(arr)\n\n    # print the sorted array\n    for element in sorted_arr:\n        print(element)",
    "class Solution(object):\n    def countingSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # write your code here\n        nums.sort()\n        count = [1] * len(nums)\n        for i in range(len(nums)):\n            count[nums[i]] += 1\n        for i in range(len(nums)):\n            nums[i] = count[i]\n\nif __name__ == '__main__':\n    print Solution().countingSort([3,2,1,2,5,3,4])",
    "class Solution(object):\n    def countingSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        n = len(arr)\n        s = [0] * n\n        for i in range(n):\n            s[arr[i]] += 1\n        for i in range(n):\n            arr[i] = s[arr[i]]\n        \n        # Recursion\n        # Recursion is the fastest way to do counting sort.\n        # We can do counting sort by recursion.\n        # When we reach the end of the array, we can just sort the rest.\n        # When we reach the end of the sub-array, we can just sort the rest.\n        # When we reach the end of the sub-sub-array, we can just sort the rest.\n        # We can do the recursion until we reach the end of the array.\n        # We can do the recursion until we reach the end of the sub-array.\n        # We can do the recursion until we reach the end of the sub-sub-array.\n        # We can do the recursion until we reach the end of the sub-sub-sub-array.\n        # In this way, we can do the recursion until we reach the end of the array.\n        # For example, we can do the recursion to sort [3,2,1,4,5] to [1,2,3,4,5].\n        # We can do the recursion to sort [3,2,1,4,5] to [1,3,2,4,5].\n        # We can do the recursion to sort [3,2,1,4,5] to [1,2,3,4,5].\n        # We can do the recursion to sort [3,2,1,4,5] to [1,3,2,4,5].\n        # We can do the recursion to sort [3,2,1,4,5] to [1,2,3,4,5].\n        # We can do the recursion to sort [3,2,1,4,5] to [1,2,",
    "def count_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    cnt = [0 for i in range(len(arr))]\n    for i in range(len(arr)):\n        cnt[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = cnt[i]\n    return arr\n\n\n# Your CountingSort object will be instantiated and called as such:\n# obj = CountingSort(arr)\n# param_1 = obj.sort(arr)",
    "# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\n# Counting sort\ndef counting_sort(A):\n    count = [0] * len(A)\n    for i in range(len(A)):\n        count[A[i]] += 1\n    for i in range(len(A)):\n        A[i] = count[i]\n    return A\n\n# Bucket sort\ndef bucket_sort(A):\n    buckets = {}\n    for i in range(len(A)):\n        if A[i] not in buckets:\n            buckets[A[i]] = []\n        buckets[A[i]].append(i)\n    for i in range(len(A)):\n        A[i] = buckets[A[i]]\n    return A\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Sorted using counting sort:\")\n    print(counting_sort(A))\n    print(\"Sorted using bucket sort:\")\n    print(bucket_sort(A))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def countSort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        # Count the number of elements in each interval.\n        intervals.sort(key=lambda interval: interval.start)\n        n = len(intervals)\n        for i in range(n - 1):\n            if intervals[i].end < intervals[i + 1].start:\n                intervals[i], intervals[i + 1] = intervals[i + 1], intervals[i]\n        # Use the number of elements in each interval to build a new interval list.\n        for i in range(n):\n            intervals[i].end = i + 1\n        # Sort the intervals.\n        intervals.sort(key=lambda interval: interval.end)\n\n    def countSort2(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        # Count the number of elements in each interval.\n        intervals.sort(key=lambda interval: interval.start)\n        n = len(intervals)\n        for i in range(n - 1):\n            if intervals[i].end < intervals[i + 1].start:\n                intervals[i], intervals[i + 1] = intervals[i + 1], intervals[i]\n        # Use the number of elements in each interval to build a new interval list.\n        for i in range(n):\n            intervals[i].end = i + 1\n        # Sort the intervals.\n        intervals.sort(key=lambda interval: interval.end)\n\n\nif __name__ == \"__main__\":\n    print Solution().countSort([Interval(0, 2), Interval(3, 5), Interval(1, 3), Interval(4, 6)])\n    print Solution().countSort2([Interval(",
    "from collections import Counter\n\ndef count_sort(arr):\n    \"\"\"\n    Input: An unsorted array arr.\n    Output: The sorted array.\n    \"\"\"\n    # Create a dictionary that counts how many times each number appears in arr\n    # using a dictionary.\n    counter = Counter(arr)\n\n    # Convert the dictionary into a list of tuples, one for each position in\n    # the array.\n    #\n    # For example, if arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], the dictionary will be\n    # {1: 3, 2: 2, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}\n    #\n    # We need to convert the dictionary into a list of tuples, one for each\n    # position in the array.\n    #\n    # For example, if arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], we need to return\n    # [(1, 3), (2, 2), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)].\n    #\n    # The dictionary can be converted back into a list of tuples using the\n    # Counter.most_common() function.\n    #\n    # For example, if arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], the dictionary will be\n    # {1: 3, 2: 2, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}\n    #\n    # We need to convert the dictionary into a list of tuples, one for each\n    # position in the array.\n    #\n    # For example, if arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], we need to return\n    # [(1, 3), (2, 2), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)].\n    #\n    # The Counter.most_common",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in xrange(len(nums)):\n            nums[i] = i\n            # n = len(nums)\n            # for j in xrange(n):\n            #     if nums[j] > nums[j+1]:\n            #         nums[j], nums[j+1] = nums[j+1], nums[j]\n            #     print i, nums\n        # for j in xrange(n):\n        #     print nums[j]\n\n        for i in xrange(len(nums)):\n            nums[i] = nums[i] + 1\n            # n = len(nums)\n            # for j in xrange(n):\n            #     if nums[j] > nums[j+1]:\n            #         nums[j], nums[j+1] = nums[j+1], nums[j]\n            #     print i, nums\n        # for j in xrange(n):\n        #     print nums[j]\n\n        for i in xrange(len(nums)):\n            nums[i] = nums[i] - 1\n            # n = len(nums)\n            # for j in xrange(n):\n            #     if nums[j] > nums[j+1]:\n            #         nums[j], nums[j+1] = nums[j+1], nums[j]\n            #     print i, nums\n        # for j in xrange(n):\n        #     print nums[j]",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        if not num:\n            return\n\n        n = len(num)\n        cnt = [0] * n\n        for i in range(n):\n            cnt[num[i]] += 1\n\n        for i in range(n):\n            num[i] = cnt[i]\n\n        self.sort(num)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 2, 3, 4, 5]\n    s.sort(nums)\n    print nums",
    "class Solution(object):\n    def countSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        A.sort()\n        return A",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def countSort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        # sort intervals by start\n        intervals = sorted(intervals, key=lambda x: x.start)\n\n        # sort intervals by end\n        intervals = sorted(intervals, key=lambda x: x.end, reverse=True)\n\n        # merge sorted intervals\n        result = []\n        previous = intervals[0]\n        for interval in intervals[1:]:\n            if interval.start < previous.end:\n                previous.end = max(previous.end, interval.end)\n            else:\n                result.append(previous)\n                previous = interval\n        result.append(previous)\n        return result\n\n\nif __name__ == '__main__':\n    intervals = [Interval(1, 3), Interval(5, 7), Interval(9, 11)]\n    print Solution().countSort(intervals)",
    "class Solution(object):\n    def sortArrayByCountingSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = [0] * len(nums)\n        for i in range(1, len(nums) + 1):\n            count[i] = count[i - 1] + nums[i - 1]\n\n        for i in range(len(nums)):\n            nums[i] = count[nums[i]]",
    "# https://oj.leetcode.com/problems/sort-an-array-by-frequency/discuss/152554/Python-Solution\n\nclass Solution(object):\n    def sortArrayByFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # the frequency of each element\n        freq = [0] * len(nums)\n        for i in range(len(nums)):\n            freq[nums[i]] += 1\n        for i in range(len(nums)):\n            nums[i] = freq[nums[i]]\n        # sort the array by the frequency\n        for i in range(len(nums) - 1, 0, -1):\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            freq[nums[i]] = freq[nums[i - 1]]\n        return",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head is None or head.next is None:\n            return head\n        else:\n            count = [0] * 10\n            curr = head\n            prev = None\n            while curr is not None:\n                count[curr.val] += 1\n                prev = curr\n                curr = curr.next\n            res = []\n            while count[0] > 0:\n                res.append(0)\n                count[0] -= 1\n            res.append(0)\n            curr = head\n            prev = None\n            while curr is not None:\n                if prev is not None:\n                    res[count[curr.val] - 1] = prev.val\n                prev = curr\n                curr = curr.next\n            return ListNode(res[0])\n\n\n# Test\ntests = [\n    ([], []),\n    ([1], [1]),\n    ([1, 2], [1, 2]),\n    ([1, 3, 2], [1, 2, 3]),\n    ([1, 3, 2, 4, 5], [1, 2, 3, 4, 5]),\n]\n\nfor arr, ans in tests:\n    sol = Solution()\n    print(arr, \"->\", sol.sortList(arr))",
    "import random\nimport unittest\n\n\ndef counting_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n    for i in range(len(count)):\n        arr[i] = count[i]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_1(self):\n        arr = [1, 3, 4, 2]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_2(self):\n        arr = [1, 3, 4, 2]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_3(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_4(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_5(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_6(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_7(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def test_8(self):\n        arr = [1, 2, 3, 4]\n        counting_sort(arr)\n        self.assertEqual(arr, [1, 2, 3, 4])\n\n    def",
    "def count_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    n = len(arr)\n    count = [0] * n\n    for i in range(n):\n        count[arr[i]] += 1\n    for i in range(n):\n        arr[i] = count[i]\n        count[arr[i]] = i\n\n\n# Your CountingSort object will be instantiated and called as such:\n# obj = CountingSort(arr)\n# param_1 = obj.sort(arr)\n\nif __name__ == '__main__':\n    arr = [2,3,1,4,5,6,7]\n    count_sort(arr)\n    print arr",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    def sortListByCount(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n\n        count = [0] * 10\n        while head:\n            count[head.val] += 1\n            head = head.next\n\n        for i in range(10):\n            for j in range(count[i]):\n                head = self.countSort(head, i)\n\n        return head\n\n    def countSort(self, head, idx):\n        if not head:\n            return None\n\n        if idx == 10:\n            return head\n\n        prev = None\n        curr = head\n        while curr:\n            if curr.val == idx:\n                prev = curr\n            curr = curr.next\n        prev.next = curr\n\n        curr = head\n        while curr:\n            if curr.val == idx:\n                prev.next = curr\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n\n        return head\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.sortListByCount(param_1)",
    "class Solution(object):\n    def countSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: void Do not return anything, modify A in-place instead.\n        \"\"\"\n        # sort by value, then by index\n        # firstly, sort by value\n        A.sort()\n        # secondly, sort by index\n        for i in xrange(len(A)):\n            A[i], A[i+1] = A[i+1], A[i]",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def sort(self, intervals):\n        \"\"\"\n        Sort the given array by using counting sort.\n        \"\"\"\n        if not intervals:\n            return intervals\n        \n        # initialize the counts\n        counts = [0] * (intervals[-1].end - intervals[-1].start + 1)\n        for interval in intervals:\n            counts[interval.start] += 1\n            counts[interval.end] -= 1\n            \n        # sort the counts\n        sorted_counts = sorted(counts)\n        \n        # update the intervals\n        for i in range(len(intervals)):\n            intervals[i].start = sorted_counts[i]\n            intervals[i].end = sorted_counts[i+1] - 1\n        \n        return intervals",
    "def sort_counting(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    count = [0] * len(nums)\n    for i in range(len(nums)):\n        count[nums[i]] += 1\n\n    for i in range(len(nums)):\n        nums[i] = count[i]\n\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]",
    "def sort_counting(arr):\n    \"\"\"\n    Input:\n        arr: a list of integers\n    Output:\n        None\n    Explanation:\n        Use counting sort to sort the array.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return\n    \n    # store the original number of each element\n    original_count = [0] * n\n    # store the number of each element\n    count = [0] * n\n    for i in range(n):\n        count[i] = arr[i]\n        original_count[i] = count[i]\n    \n    # count the number of each element\n    for i in range(n):\n        for j in range(i, n):\n            if arr[j] == arr[i]:\n                count[j] += count[i]\n    \n    # print the original number of each element\n    for i in range(n):\n        print(original_count[i], end=' ')\n    print()\n    \n    # print the number of each element\n    for i in range(n):\n        print(count[i], end=' ')\n    print()\n    \n    # replace the original number of each element with the number of each element\n    for i in range(n):\n        count[i] = original_count[i]\n    \n    # sort the array\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            if count[j] > count[j+1]:\n                count[j], count[j+1] = count[j+1], count[j]\n    \n    # print the sorted array\n    for i in range(n):\n        print(count[i], end=' ')\n    print()\n\nif __name__ == '__main__':\n    arr = [1, 3, 2, 2, 3, 4]\n    sort_counting(arr)\n    \n    arr = [1, 3, 2, 2, 3, 4, 5]\n    sort_counting(arr)",
    "import unittest\nfrom typing import List\n\nfrom sorting_by_frequency import sort_by_frequency\n\n\nclass TestSortingByFrequency(unittest.TestCase):\n    def test_counting_sort(self):\n        self.assertEqual(sort_by_frequency([2, 5, 4, 1, 3, 9, 7, 8, 0, 6, 2, 0]),\n                         [0, 2, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9])\n\n    def test_counting_sort_reverse(self):\n        self.assertEqual(sort_by_frequency([2, 5, 4, 1, 3, 9, 7, 8, 0, 6, 2, 0]),\n                         [0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9])\n\n    def test_counting_sort_empty(self):\n        self.assertEqual(sort_by_frequency([]), [])\n\n    def test_counting_sort_empty_reverse(self):\n        self.assertEqual(sort_by_frequency([1, 2, 3]), [])\n\n    def test_counting_sort_one_item(self):\n        self.assertEqual(sort_by_frequency([1]), [1])\n\n    def test_counting_sort_two_items(self):\n        self.assertEqual(sort_by_frequency([2, 5]), [2, 5])\n\n    def test_counting_sort_two_items_reverse(self):\n        self.assertEqual(sort_by_frequency([5, 2]), [2, 5])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def countSort(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        self.sortIntervals(intervals)\n        self.mergeIntervals(intervals)\n\n    def sortIntervals(self, intervals):\n        \"\"\"\n        Sort the given intervals by start point.\n        :type intervals: List[Interval]\n        :rtype: None\n        \"\"\"\n        intervals.sort(key=lambda x: x.start)\n\n    def mergeIntervals(self, intervals):\n        \"\"\"\n        Merge adjacent intervals into one.\n        :type intervals: List[Interval]\n        :rtype: None\n        \"\"\"\n        i = 0\n        while i < len(intervals):\n            if i + 1 < len(intervals) and intervals[i].end + 1 == intervals[i + 1].start:\n                intervals[i].end = intervals[i + 1].end\n                intervals.pop(i + 1)\n            else:\n                i += 1",
    "class Solution(object):\n    def countingSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        # count sort\n        cnt = [0] * len(arr)\n        for i in range(len(arr)):\n            cnt[arr[i]] += 1\n        # sort\n        for i in range(len(arr)):\n            arr[i] = cnt[arr[i]]",
    "class Solution(object):\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        count = [0] * n\n        for num in nums:\n            count[num] += 1\n        for i in range(n):\n            nums[i] = count[i]\n        # for i in range(n):\n        #     print nums[i]\n        # print '-' * 30\n        for i in range(n-1, -1, -1):\n            count[nums[i]] = i\n            nums[i] = count[i]\n        # for i in range(n):\n        #     print nums[i]\n        # print '-' * 30\n        for i in range(n-1, -1, -1):\n            nums[i] = count[nums[i]]\n        # for i in range(n):\n        #     print nums[i]\n        # print '-' * 30\n        return\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10]\n    Solution().countSort(nums)\n    for i in range(len(nums)):\n        print nums[i]",
    "import sys\n\ndef sort(arr):\n    \"\"\"\n    >>> sort([3, 2, 1])\n    >>> sort([1, 2, 3])\n    >>> sort([1, 2, 3, 2, 1])\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n\n    for i in range(len(arr)):\n        arr[i] = count[i]\n\n    return sort(arr)\n\n\nif __name__ == \"__main__\":\n    for i in range(1, int(sys.argv[1])):\n        arr = list(map(int, input().split()))\n        print(\"Case #{}: {}\".format(i, sort(arr)))",
    "def counting_sort(arr):\n    \"\"\"\n    Input: arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: sorted_arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8]\n    \"\"\"\n    count = [0] * len(arr)\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n\n    for i in range(len(arr)):\n        arr[i] = count[i]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(counting_sort(arr))",
    "class Solution:\n    # @param nums, a list of integer\n    # @return void\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Using counting sort to sort the array\n        sorted_nums = [0]*len(nums)\n        for i in range(len(nums)):\n            sorted_nums[i] = nums[i]\n        for i in range(len(nums)):\n            sorted_nums[i] += sorted_nums[i-1]\n        for i in range(len(nums)-1):\n            sorted_nums[i] += sorted_nums[i+1]\n        for i in range(len(nums)):\n            nums[i] = sorted_nums[i]\n\n# Time:  O(nlogn)\n# Space: O(n)\n# n = len(nums)\n# sort nums using counting sort\n# then reverse the sorted nums",
    "def counting_sort(arr):\n    \"\"\"\n    Sort the given array using counting sort.\n\n    :param arr: The given array to sort.\n    :return: The sorted array.\n    \"\"\"\n    if len(arr) == 0:\n        return arr\n\n    cnt = [0 for i in range(len(arr))]\n    for i in range(len(arr)):\n        cnt[arr[i]] += 1\n\n    for i in range(len(arr)):\n        arr[i] = cnt[arr[i]]\n\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [0, 1, 3, 2, 1, 1, 1]\n    print(arr)\n    print(counting_sort(arr))",
    "def counting_sort(arr):\n    \"\"\"\n    Input: an integer array arr of size n\n    Output: the sorted array arr\n    Explanation:\n    Use the following steps to sort the array arr:\n    1. Initialize a variable arr_count[n] to contain the number of elements in arr.\n    2. Initialize a variable arr_count_temp[i] to contain arr_count[i-1].\n    3. Initialize a variable j to contain 0.\n    4. For each element in arr, increment arr_count[j] by 1.\n    5. While arr_count[j] > 0:\n        6. If arr_count[j] is greater than arr_count[j+1], swap arr[j] and arr[j+1].\n        7. Decrement arr_count[j] by 1.\n        8. Increment j by one.\n    9. Return arr\n    \"\"\"\n    arr_count = [0] * len(arr)\n    for i in range(len(arr)):\n        arr_count[i] = arr_count[i - 1] + 1\n    j = 0\n    for i in range(len(arr)):\n        while arr_count[j] > 0 and arr_count[j] > arr_count[j + 1]:\n            arr_temp = arr[j]\n            arr[j] = arr[j + 1]\n            arr[j + 1] = arr_temp\n            arr_count[j] -= 1\n            arr_count[j + 1] += 1\n        j += 1\n    return arr\n\ndef counting_sort2(arr):\n    \"\"\"\n    Input: an integer array arr of size n\n    Output: the sorted array arr\n    Explanation:\n    Use the following steps to sort the array arr:\n    1. Initialize a variable arr_count[n] to contain the number of elements in arr.\n    2. Initialize a variable arr_count_temp[i] to contain arr_count[i-1].\n    3. Initialize a variable j to contain 0.\n    4. For each element in arr, increment arr_count[j] by 1.\n    5. While arr_count[j] > 0",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def sortIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        if not intervals:\n            return\n\n        # find the index of the smallest interval\n        # e.g. [1, 3] => 1\n        def getMinIndex(intervals):\n            return 0 if len(intervals) == 1 else (1 if intervals[0].start < intervals[1].start else 2)\n\n        # sort the intervals by start\n        intervals.sort(key=lambda interval: interval.start)\n        # find the index of the largest interval\n        # e.g. [1, 3] => 2\n        def getMaxIndex(intervals):\n            return len(intervals) - 1 if len(intervals) == 1 else (1 if intervals[-1].end > intervals[-2].end else 2)\n\n        # sort the intervals by end\n        intervals.sort(key=lambda interval: interval.end)\n        # find the index of the smallest interval\n        # e.g. [1, 3] => 0\n        def getMinIndex(intervals):\n            return 0 if len(intervals) == 1 else (1 if intervals[0].end < intervals[1].end else 2)\n\n        # sort the intervals by start\n        intervals.sort(key=lambda interval: interval.start)\n        # find the index of the largest interval\n        # e.g. [1, 3] => 1\n        def getMaxIndex(intervals):\n            return 0 if len(intervals) == 1 else (1 if intervals[-1].end > intervals[-2].end else 2)\n\n        # use the above functions to sort the intervals\n        for i in range(len(intervals) - 1):\n            intervals[i], intervals[i + 1] = intervals[i + 1], intervals[i]\n\n        # find the index of the smallest interval\n        # e.g. [1,",
    "def counting_sort(nums):\n    \"\"\"\n    nums: A list of integer.\n    return: nothing\n    \"\"\"\n    # write your code here\n    return\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5,6,7,8,9]\n    counting_sort(nums)\n    print(nums)",
    "class Solution(object):\n    def countSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: void Do not return anything, modify A in-place instead.\n        \"\"\"\n        n = len(A)\n        for i in range(n):\n            A[i], A[n-i-1] = A[n-i-1], A[i]\n        for i in range(n-1, 0, -1):\n            for j in range(i):\n                if A[j] > A[j+1]:\n                    A[j], A[j+1] = A[j+1], A[j]\n        for i in range(n):\n            A[i], A[n-i-1] = A[n-i-1], A[i]",
    "def sort_array(arr):\n    \"\"\"\n    Input: A list of integers.\n    Output: The sorted array.\n    \"\"\"\n    # sort the numbers\n    n = len(arr)\n    for i in range(n):\n        count = 1\n        for j in range(i+1, n):\n            if arr[j] < arr[i]:\n                arr[j], arr[i] = arr[i], arr[j]\n                count += 1\n        if count == 1:\n            return arr\n    return arr\n\nif __name__ == '__main__':\n    arr = [2, 1, 5, 3, 4, 6]\n    print sort_array(arr)",
    "import sys\n\ndef counting_sort(arr):\n    \"\"\"\n    Input:\n        arr: The array to sort.\n    Output:\n        The sorted array.\n    \"\"\"\n    count = [0 for _ in arr]\n    for i in range(len(arr)):\n        count[arr[i]] += 1\n    for i in range(len(arr)):\n        arr[i] = count[i]\n    return arr\n\nif __name__ == '__main__':\n    arr = [3,1,6,2,5,7,4]\n    print(counting_sort(arr))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}