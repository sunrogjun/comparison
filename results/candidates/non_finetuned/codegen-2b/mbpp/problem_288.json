{
  "problem": {
    "task_id": "MBPP/299",
    "prompt": "Write a function to calculate the maximum aggregate from the list of tuples.",
    "canonical_solution": "from collections import defaultdict\r\ndef max_aggregate(stdata):\r\n    temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])",
    "test_list": [
      "assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)",
      "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)",
      "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"
    ],
    "challenge_test_list": [],
    "problem_id": 288
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# https://www.hackerrank.com/challenges/max-aggregate/problem\n# https://www.hackerrank.com/challenges/max-aggregate/hints\n# https://www.hackerrank.com/challenges/max-aggregate/examples\n\n# TODO:\n# 1. Change the input to be a list of tuples\n# 2. Change the function to return the maximum aggregate from the list of tuples\n\ndef max_aggregate(data):\n    # Your code here\n    # The tuple list is stored in a list of lists\n    # The maximum aggregate is stored in a list of integers\n    # Each list represents one tuple and each integer is the maximum aggregate for that tuple\n\n    # If the data is empty, return 0\n    if not data:\n        return 0\n\n    # For each tuple, find the maximum aggregate\n    max_aggregate_list = []\n    for item in data:\n        # If the list of integers is empty, add the item to the list of integers\n        if not max_aggregate_list:\n            max_aggregate_list.append(item[1])\n        # Otherwise, add the item to the list of integers, and find the maximum value\n        else:\n            max_aggregate_list.append(max(item[1], max_aggregate_list[-1]))\n    # Return the maximum aggregate\n    return max_aggregate_list[-1]\n\n\n# Test Cases\ndata = [[(1, 2), (3, 4)], [(2, 3), (4, 5)], [(2, 3), (4, 5)], [(1, 2), (3, 4)]]\n# data = []\n# data = [(1, 2), (3, 4), (5, 6)]\n\nprint(\"Maximum aggregate from empty list: \", max_aggregate(data))\nprint(\"Maximum aggregate from list of tuples: \", max_aggregate(data))",
    "class Solution:\n    # @param {List[Tuple]} tuples\n    # @return {integer}\n    def max(self, tuples):\n        max_val = -sys.maxsize\n        for t in tuples:\n            max_val = max(max_val, t[0])\n        return max_val",
    "# https://www.hackerrank.com/challenges/max-aggregation\n# https://www.hackerrank.com/challenges/max-aggregation-ii\n\n# Problem:\n# Given a list of tuples, return the maximum aggregate\n# from the list of tuples.\n\n# Example:\n# Input:\n# [[1,2], [2,3], [3,4]]\n# Output: 4\n# Explanation:\n# The maximum aggregate is 4.\n# Note that it is possible for the list to be empty.\n\n# The input list is guaranteed to be a non-empty list of tuples.\n# The output is guaranteed to be a non-negative integer.\n\n\ndef max_aggregation(tuples):\n    # write your code here\n    if not tuples:\n        return 0\n\n    max_val = max(tuples, key=lambda t: t[0])\n    for i in range(1, len(tuples)):\n        if tuples[i][0] > max_val[0]:\n            max_val = tuples[i]\n    return max_val[0]\n\n\nif __name__ == '__main__':\n    tuples = [\n        [1, 2],\n        [2, 3],\n        [3, 4]\n    ]\n\n    print(max_aggregation(tuples))",
    "# https://www.hackerrank.com/challenges/max-aggregation\n# https://www.hackerrank.com/challenges/max-aggregation-python\n\ndef max_aggregation(tuples):\n    max_value = 0\n    for tuple in tuples:\n        max_value = max(max_value, tuple[0])\n    return max_value\n\nif __name__ == '__main__':\n    t = int(input())\n    tuples = []\n    for i in range(t):\n        tuple = tuple(map(int, input().split()))\n        tuples.append(tuple)\n    print(max_aggregation(tuples))",
    "def max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    max_index = 0\n\n    for i in range(len(tuples)):\n        sum = 0\n        for j in range(len(tuples[i])):\n            sum += tuples[i][j]\n\n        if sum > max_sum:\n            max_sum = sum\n            max_index = i\n\n    return max_sum, max_index\n\n\n\ndef main():\n    tuples = [(1, 2), (3, 4), (5, 6)]\n    print(max_aggregation(tuples))\n\n    tuples = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    print(max_aggregation(tuples))\n\n    tuples = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]\n    print(max_aggregation(tuples))\n\n\n\nif __name__ == '__main__':\n    main()",
    "# https://www.hackerrank.com/challenges/max-tuple\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\n# Definition for a tuple with arbitrary fields.\nclass Tuple(object):\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '({}, {})'.format(self.x, self.y)\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: Tuple\n        \"\"\"\n        max_x, max_y = None, None\n        for t in tuples:\n            if max_x is None or t.x > max_x:\n                max_x = t.x\n            if max_y is None or t.y > max_y:\n                max_y = t.y\n        return Tuple(max_x, max_y)\n\ns = Solution()\nprint(s.maxTuple([(1,2),(3,4),(2,3)]))\nprint(s.maxTuple([(1,2),(3,4)]))\nprint(s.maxTuple([(1,2),(1,1)]))",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n    max_val = -sys.maxsize\n    for tup in tuples:\n        max_val = max(max_val, tup[0])\n    return max_val\n\n\n# Your MaxAggregate object will be instantiated and called as such:\n# obj = MaxAggregate(tuples)\n# param_1 = obj.max_aggregate(tuples)",
    "def max_aggregation(tuples):\n    \"\"\"\n    For each tuple, calculate the maximum aggregation from the tuple.\n    \"\"\"\n    if len(tuples) == 0:\n        return 0\n    \n    max_aggregation = [0] * len(tuples[0])\n    for tuple in tuples:\n        for i in range(len(tuple)):\n            max_aggregation[i] = max(max_aggregation[i], tuple[i])\n    \n    return max(max_aggregation)\n\n\ndef test_max_aggregation():\n    assert max_aggregation([(1, 2), (1, 2)]) == 2\n    assert max_aggregation([(1, 2), (1, 1), (2, 3)]) == 3\n    assert max_aggregation([(1, 2), (1, 3), (3, 5), (1, 1)]) == 5\n    assert max_aggregation([(1, 2), (1, 2), (1, 3)]) == 3\n    assert max_aggregation([(1, 2), (1, 2), (1, 2), (1, 3)]) == 3\n\n\ndef main():\n    test_max_aggregation()\n\n\nif __name__ == \"__main__\":\n    main()",
    "from collections import defaultdict\n\nclass Solution:\n    # @param A list of tuples\n    # @return an integer\n    def maxTupleSum(self, A):\n        max_sum = -1\n        for i in A:\n            max_sum = max(max_sum, self.max_sum(i))\n        return max_sum\n\n    def max_sum(self, A):\n        max_sum = -1\n        for i in A:\n            max_sum = max(max_sum, max(i))\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    A = [(-3, -2), (-2, 1), (-1, 1), (1, 4), (1, -4)]\n    s = Solution()\n    print(s.maxTupleSum(A))\n    print(s.maxTupleSum([(1, 2)]))",
    "#!/usr/bin/env python\n\ndef max_aggregate(arr):\n    \"\"\"\n    :type arr: List[tuple]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    max_val = arr[0][0]\n    for i in range(1, len(arr)):\n        if arr[i][0] > max_val:\n            max_val = arr[i][0]\n    return max_val\n\nif __name__ == \"__main__\":\n    arr = [\n        (1, 2, 3),\n        (4, 5, 6),\n        (7, 8, 9)\n    ]\n    print(max_aggregate(arr))",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i][1] > tuples[j][1]:\n                max_value = max(max_value, tuples[i][1] + tuples[j][1])\n    return max_value\n\n# Your code should pass the following test cases.\n#\n# Case 1:\n# [[1,1],[1,1]]\n# Return: 1\n# Case 2:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 3:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 4:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 5:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 6:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 7:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 8:\n# [[1,1],[2,2]]\n# Return: 3\n# Case 9:\n# [[1,1],[2,2]]\n# Return: 3",
    "# https://www.hackerrank.com/challenges/max-aggregation\n\nimport collections\n\ndef max_aggregation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: int\n    \"\"\"\n    max_aggregation = collections.defaultdict(lambda: 0)\n    for t in tuples:\n        for k, v in t:\n            max_aggregation[k] = max(max_aggregation[k], v)\n    return max(max_aggregation.values())",
    "# TODO\n# - check if the list is sorted\n# - check if the list is unique\n# - check if the list is a single number\n# - check if the list is a single number\n# - check if the list is a single number\n\n# ----------------------------------------------------------------------------\n\ndef max_aggregate(tuple_list):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    :param tuple_list: List of tuples.\n    :type tuple_list: List[tuple]\n\n    :return: Maximum aggregate.\n    :rtype: int\n    \"\"\"\n    max_aggregate = 0\n\n    for tuple_ in tuple_list:\n        for i in range(len(tuple_)):\n            max_aggregate = max(max_aggregate, tuple_[i])\n\n    return max_aggregate\n\n# ----------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    print(max_aggregate([(1, 2, 3), (4, 5, 6), (7, 8, 9)]))\n    print(max_aggregate([(1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 2, 3)]))",
    "# https://leetcode.com/problems/max-aggregate/\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        m = 0\n        for t in tuples:\n            m = max(m, max(t.x, t.y))\n        return m",
    "# https://www.hackerrank.com/challenges/maximum-aggregate/problem\n\nimport collections\n\ndef max_aggregate(tuples):\n    # Your code here\n    if len(tuples) == 0:\n        return 0\n    m = collections.defaultdict(int)\n    for t in tuples:\n        for k,v in t.items():\n            m[k] += v\n    return max(m.values())",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(tuples) == 0:\n        return 0\n    \n    max_value = 0\n    for tuple in tuples:\n        for val in tuple:\n            max_value = max(val, max_value)\n    \n    return max_value",
    "def max_aggregate(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not tuple_list:\n        return 0\n\n    max_aggregate = 0\n    for t in tuple_list:\n        max_aggregate = max(max_aggregate, t[0] * t[1])\n\n    return max_aggregate",
    "def max_aggregate(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: Tuple\n    \"\"\"\n    if not tuple_list:\n        return None\n    max_value = tuple_list[0]\n    for tuple in tuple_list:\n        if tuple[0] > max_value[0]:\n            max_value = tuple\n    return max_value",
    "import collections\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    return max(tuple(tuple(x) for x in t) for t in tuples)\n\ndef max_aggregate_with_list(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    max_aggregate_list = collections.defaultdict(lambda: 0)\n    for t in tuples:\n        for v in t:\n            max_aggregate_list[v] += 1\n    return max(max_aggregate_list.values())\n\n# Your MaxAggregate function will be called like this:\n# max_aggregate( [(1, 2), (2, 3), (2, 5), (2, 5), (2, 2)])\n# max_aggregate_with_list([[1, 2], [2, 3], [2, 5], [2, 5], [2, 2]])",
    "# https://oj.leetcode.com/problems/maximum-aggregation/\n# tags: medium, array, basic\n\n\nclass Solution(object):\n    \"\"\"\n    @param A: a list of tuples\n    @return: an integer\n    \"\"\"\n    def maxAggregation(self, A):\n        \"\"\"\n        :type A: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        max_num, max_index = 0, 0\n        for i in range(len(A)):\n            if A[i][0] > max_num:\n                max_num, max_index = A[i][0], i\n        return max_num\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    A = [(1, 2), (2, 1), (5, 1)]\n    print s.maxAggregation(A)\n    print A",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    if len(tuples) == 0:\n        return 0\n    if len(tuples) == 1:\n        return max(tuples)\n    else:\n        return max(max_aggregate(tuples[:i+1]) for i in range(1, len(tuples)+1))\n\ndef main():\n    tuples = [\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 5),\n        (5, 6),\n        (6, 7),\n        (7, 8),\n        (8, 9),\n        (9, 10)\n    ]\n    print(max_aggregate(tuples))\n\nif __name__ == '__main__':\n    main()",
    "def max_agg(tup_list):\n    \"\"\"\n    Calculate the maximum value of an aggregation function from a list of tuples.\n\n    Args:\n        tup_list: A list of tuples containing the aggregation function and its value.\n    Returns:\n        The maximum value of the aggregation function.\n    \"\"\"\n    return max(tup_list)\n\nif __name__ == \"__main__\":\n    tup_list = [(\"min\", 1), (\"max\", 2), (\"sum\", 3)]\n    print(max_agg(tup_list))",
    "from collections import namedtuple\n\nfrom typing import List\n\nTuple = namedtuple('Tuple', 'x, y, z')\n\ndef max_tuple(tuples: List[Tuple]) -> int:\n    \"\"\"\n    :param tuples: list of tuples\n    :return: maximum value\n    \"\"\"\n    return max(tuple(tuple(x) for x in tup) for tup in tuples)\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2, 3),\n        (2, 3, 4),\n        (3, 4, 5),\n    ]\n    print(max_tuple(tuples))",
    "# https://www.hackerrank.com/challenges/max-aggregate/problem\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    return max(map(lambda x: max(x), tuples))\n\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2, 3),\n        (4, 5, 6),\n        (7, 8, 9)\n    ]\n    print(max_aggregate(tuples))",
    "def max_aggregate(list_of_tuples):\n    \"\"\"\n    Returns the maximum aggregate value from the given list of tuples.\n\n    Arguments:\n        list_of_tuples: List of tuples.\n\n    Returns:\n        The maximum aggregate value.\n\n    Examples:\n        >>> max_aggregate([(1, 2), (3, 4)])\n        4\n        >>> max_aggregate([(1, 2), (2, 3)])\n        2\n        >>> max_aggregate([(1, 2), (2, 3), (3, 4)])\n        4\n        >>> max_aggregate([(1, 2), (2, 3), (3, 4), (4, 5)])\n        5\n    \"\"\"\n    return max(list_of_tuples)\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# https://www.hackerrank.com/challenges/max-tuple/problem\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com/kata/max-tuple/\n# https://www.codewars.com",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    n = len(tuples)\n    max_val = -sys.maxsize\n    for tup in tuples:\n        max_val = max(max_val, tup[0] + tup[1])\n    return max_val",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n    def __str__(self):\n        return str(self.x)\n\n# Your Tuple object will be instantiated and called as such:\ntupleObj = Tuple(1)\ntupleObj.y = Tuple(2)\ntupleObj.y = Tuple(3)\n\ndef max_agg(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    if len(tuples) == 0:\n        return 0\n\n    max = 0\n    for tuple in tuples:\n        if tuple.y is not None:\n            max = max if tuple.y > max else tuple.y\n        else:\n            max = max if tuple.x > max else tuple.x\n\n    return max",
    "from collections import defaultdict\n\ndef max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    d = defaultdict(int)\n    for t in tuples:\n        d[t[0]] += t[1]\n    return max(d.values())\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (2, 3), (3, 4), (1, 5), (2, 6), (3, 7)]\n    print(max_aggregation(tuples))",
    "# https://www.hackerrank.com/challenges/max-aggregate\n# Time:  O(n)\n# Space: O(1)\n\nclass Solution:\n    # @param {List<Tuple<Integer, Integer>>} tuples\n    # @return {Integer}\n    def maxAggregate(self, tuples):\n        if not tuples:\n            return 0\n        max_aggregate = 0\n        for tup in tuples:\n            max_aggregate = max(max_aggregate, tup[0] + tup[1])\n        return max_aggregate\n\ns = Solution()\nprint s.maxAggregate([(1,2),(2,5),(1,5),(3,4),(2,4)])",
    "# https://www.hackerrank.com/challenges/maximum-aggregate\n# https://www.hackerrank.com/challenges/maximum-aggregate/problem\n\ndef maximum_aggregate(tuples):\n    # Write your code here\n    max_aggregate = 0\n    for i in range(len(tuples)):\n        max_aggregate = max(max_aggregate, tuples[i][0])\n        max_aggregate = max(max_aggregate, tuples[i][1])\n    return max_aggregate\n\n\nif __name__ == '__main__':\n    t = int(input())\n    tuples = list(map(lambda x: [int(x[0]), int(x[1])],\n        input().split()))\n    print(maximum_aggregate(tuples))",
    "import collections\n\ndef max_agg(tup_list):\n    \"\"\"\n    :type tup_list: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    # +++your code here+++\n    return max(tup_list)\n\n\nif __name__ == '__main__':\n    tup_list = [(1, 2), (3, 5), (1, 1), (2, 4)]\n    print(max_agg(tup_list))",
    "# https://www.hackerrank.com/challenges/max-aggregation\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\ndef max_aggregation(tuples):\n    max_so_far = -float('inf')\n    max_agg = -float('inf')\n    for i in range(len(tuples)):\n        max_agg = max(max_agg, tuples[i][0])\n        max_so_far = max(max_so_far, tuples[i][1])\n    return max_agg\n\n# Sample Input:\n# [[1,2],[3,4],[5,6]]\n# Sample Output:\n# 6\n# Explanation:\n# 1 is the maximum aggregate.\n# 6 is the sum of the maximum aggregates.",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n    result = 0\n    for t in tuples:\n        for i in t:\n            if i > result:\n                result = i\n    return result",
    "# https://www.hackerrank.com/challenges/max-aggregate/problem\n\nimport collections\nfrom collections import Counter\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    # Build a dictionary of tuples, keyed by the first element\n    tuple_map = collections.defaultdict(list)\n    for t in tuples:\n        tuple_map[t[0]].append(t)\n\n    # Build a dictionary of tuples, keyed by the sum of their elements\n    sum_map = collections.defaultdict(list)\n    for t in tuple_map.values():\n        for t in t:\n            sum_map[sum(t)].append(t)\n\n    # Find the maximum aggregate\n    max_agg = 0\n    for t in sum_map.values():\n        if len(t) > 1:\n            max_agg = max(max_agg, max(t))\n\n    return max_agg\n\n\ndef main():\n    \"\"\"\n    For each of the tuples, print the maximum aggregate.\n    \"\"\"\n    with open(\"inputs/day_17.txt\", \"r\") as f:\n        tuples = list(map(tuple, f.read().splitlines()))\n\n    print(max_aggregate(tuples))\n\nif __name__ == \"__main__\":\n    main()",
    "def max_aggregate(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: Tuple\n    \"\"\"\n    max_value = 0\n    max_index = 0\n    for i in range(len(tuple_list)):\n        if tuple_list[i][0] > max_value:\n            max_value = tuple_list[i][0]\n            max_index = i\n    return tuple_list[max_index]\n\n\nif __name__ == '__main__':\n    assert max_aggregate([(3, 1), (4, 3), (5, 1)]) == (5, 1)\n    assert max_aggregate([(3, 1), (4, 3), (5, 1), (3, 1), (4, 3)]) == (5, 1)\n    assert max_aggregate([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == (5, 5)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        max_tuple = None\n        for t in tuples:\n            if max_tuple is None or t > max_tuple:\n                max_tuple = t\n        return max_tuple.x",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        max_tuple = 0\n        for t in tuples:\n            if t.x > max_tuple:\n                max_tuple = t.x\n            if t.y is not None:\n                if t.y > max_tuple:\n                    max_tuple = t.y\n\n        return max_tuple",
    "def max_aggregate(t):\n    if len(t) == 0:\n        return 0\n    elif len(t) == 1:\n        return t[0][0]\n    else:\n        return max(t)",
    "# https://leetcode.com/problems/maximum-aggregation/\n# time complexity: O(n), where n is the number of tuples\n# space complexity: O(1)\nclass Solution(object):\n    def maxAggregation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/maximum-aggregation/discuss/208824/C++-solution-with-detailed-explanation\n        # TODO\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n\n        max_so_far = nums[0]\n        for i in range(1, n):\n            max_so_far = max(max_so_far, nums[i])\n\n        return max_so_far\n\n\nif __name__ == \"__main__\":\n    print(Solution().maxAggregation([1, 1, 2, 2, 3]))",
    "def max_aggregate(l):\n    \"\"\"\n    :type l: List[tuple]\n    :rtype: int\n    \"\"\"\n    if not l:\n        return 0\n    \n    max_val = l[0][0]\n    for t in l:\n        max_val = max(max_val, t[0])\n    return max_val",
    "# https://www.hackerrank.com/challenges/max-aggregation/problem\n\n\ndef max_aggregation(tuples):\n    max_aggregation = 0\n    for i in range(len(tuples)):\n        max_aggregation = max(max_aggregation, max_aggregation(tuples[:i]))\n        max_aggregation = max(max_aggregation, max_aggregation(tuples[i:]))\n    return max_aggregation\n\n\n# Test Cases\ntuples = [[1,2,3],[1,2,3],[2,2,2]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]\nprint(max_aggregation(tuples))\ntuples = [[1,2",
    "from collections import defaultdict\n\ndef max_aggregate(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    result = defaultdict(lambda: 0)\n    for tup in tuple_list:\n        result[tup[0]] += tup[1]\n    return max(result.values())\n\nif __name__ == '__main__':\n    tuple_list = [(1, 5), (2, 10), (2, 15), (3, 5), (4, 10), (5, 15)]\n    assert(max_aggregate(tuple_list) == 15)",
    "# -*- coding: utf-8 -*-\n\nimport math\n\ndef max_aggregate(tuple_list):\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n\n    :param tuple_list: List of tuples.\n    :type tuple_list: List[Tuple]\n    :rtype: int\n    \"\"\"\n    res = 0\n    for i in range(len(tuple_list)):\n        res = max(res, tuple_list[i][1])\n    return res\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (2, 3), (3, 4), (1, 2), (2, 3), (3, 4)]\n    print(max_aggregate(tuple_list))",
    "def max_aggregate(tuples):\n    \"\"\"\n    Input: A list of tuples.\n\n    Output: The maximum aggregate from the list of tuples.\n    \"\"\"\n    result = 0\n    for tuple in tuples:\n        result = max(result, tuple[0])\n    return result\n\n# These \"asserts\" using only for self-checking and not necessary for auto-testing\nif __name__ == '__main__':\n    assert max_aggregate([(1,), (2,), (3,)]) == 3, \"Testcase 1\"\n    assert max_aggregate([(1, 2), (2, 2), (3, 3)]) == 3, \"Testcase 2\"\n    assert max_aggregate([(1, 2), (3, 2), (2, 1)]) == 3, \"Testcase 3\"\n    assert max_aggregate([(1, 2), (2, 1), (3, 1), (1, 2)]) == 2, \"Testcase 4\"\n    assert max_aggregate([(1, 2), (2, 1), (3, 1), (1, 1)]) == 1, \"Testcase 5\"",
    "from collections import namedtuple\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :param tuples: A list of tuples, each tuple containing a string and a list of integers\n    :return: The maximum aggregate from the list of tuples\n    \"\"\"\n    def aggregate_tuple(tuple_list):\n        aggregate = tuple_list[0]\n        for t in tuple_list[1:]:\n            if t[0] > aggregate:\n                aggregate = t[0]\n        return aggregate\n    return max(map(aggregate_tuple, tuples))\n\nif __name__ == '__main__':\n    tuples = [(1, [1, 2, 3]), (2, [2, 3, 4]), (3, [3, 4, 5]), (4, [4, 5, 6]),\n              (5, [5, 6, 7]), (6, [6, 7, 8]), (7, [7, 8, 9]), (8, [8, 9, 10]),\n              (9, [9, 10, 11]), (10, [10, 11, 12])]\n    print(max_aggregate(tuples))",
    "import sys\n\ndef get_max(t):\n    return max(t)\n\ndef get_max_aggregate(t):\n    t_max = [get_max(t)]\n    for i in range(1, len(t)):\n        t_max.append(t_max[i-1] + t[i])\n    return t_max[-1]\n\nif __name__ == \"__main__\":\n    t = [(1, 2, 3), (2, 3, 5), (3, 2, 2), (4, 2, 4)]\n    print get_max(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t)\n    print get_max_aggregate(t",
    "def max_aggregate(lst):\n    \"\"\"\n    :type lst: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not lst:\n        return 0\n    return max(lst, key=lambda x: x[0])[1]",
    "# https://www.hackerrank.com/challenges/max-aggregate/problem\ndef max_aggregate(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr: return 0\n    return max(arr)\n\n# Your MaxAggregate function will be called like this:\n# f(num_tuples, arr)\n# f.argtypes = [int, List[int]]\n# f.restype = int\n# f.errcheck = lambda r, e: min(e, r)",
    "# https://www.hackerrank.com/challenges/maximum-aggregate/problem\n\ndef max_aggregate(t):\n    \"\"\"\n    :type t: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not t:\n        return 0\n    t_max = t[0]\n    for t_tuple in t:\n        if t_max[0] < t_tuple[0]:\n            t_max = t_tuple\n    return t_max[1]\n\n\n# https://www.hackerrank.com/challenges/maximum-aggregate/submissions/code/31232407",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    max_ = 0\n    for t in tuples:\n        max_ = max(max_, t[0])\n    return max_\n\n\ndef test_max_aggregate():\n    tuples = [(1, 2), (3, 4), (5, 6)]\n    assert max_aggregate(tuples) == 6\n\n\nif __name__ == '__main__':\n    test_max_aggregate()",
    "import collections\n\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: Tuple\n    \"\"\"\n    if len(tuples) == 0:\n        return None\n    if len(tuples) == 1:\n        return tuples[0]\n    if len(tuples) == 2:\n        return max(tuples)\n    return max_aggregate_helper(tuples)\n\n\ndef max_aggregate_helper(tuples):\n    if len(tuples) == 2:\n        return max(tuples)\n    if len(tuples) == 3:\n        return max(tuples, key=lambda t: t[0])\n    max_key = max(tuples, key=lambda t: t[0])\n    if max_key[1] > max_key[2]:\n        return max_key\n    return max_aggregate_helper([[1, 2, 3], max_key])\n\n\nif __name__ == '__main__':\n    tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    print(max_aggregate(tuples))",
    "from collections import namedtuple\n\nTuple = namedtuple(\"Tuple\", \"a b c\")\n\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        def max_agg(tup):\n            if tup[0] > tup[1]:\n                return tup[0]\n            elif tup[0] == tup[1]:\n                return tup[2]\n            else:\n                return tup[1]\n\n        return max(map(max_agg, tuples))\n\n\nif __name__ == '__main__':\n    tuples = [\n        Tuple(1, 2, 3),\n        Tuple(1, 3, 4),\n        Tuple(2, 2, 3),\n        Tuple(2, 3, 4),\n        Tuple(3, 2, 3),\n        Tuple(3, 3, 4)\n    ]\n\n    sol = Solution()\n    print(sol.maxTuple(tuples))",
    "# https://leetcode.com/problems/maximum-aggregation/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxAggregation(self, nums):\n        if len(nums) == 0:\n            return 0\n        # nums.sort(reverse=True)\n        max_ = nums[0]\n        max_agg = nums[0]\n        for num in nums:\n            if max_ < num:\n                max_ = num\n                max_agg = num\n            elif max_ == num:\n                max_agg = max_agg + num\n        return max_agg\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print s.maxAggregation(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print s.maxAggregation(nums)",
    "def max_aggregate(list_of_tuples):\n    \"\"\"\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6)])\n    (6, 6)\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6), (7, 8)])\n    (8, 8)\n    \"\"\"\n    return max(list_of_tuples, key=lambda tup: tup[0])\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "import collections\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) < k:\n            return 0\n        max_window = collections.deque()\n        for num in nums:\n            if len(max_window) < k:\n                max_window.append(num)\n            else:\n                if max_window[-1] < num:\n                    max_window.append(num)\n        return max(max_window)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 2)\n    print s.maxSlidingWindow([1, 2, 3], 1)\n    print s.maxSlidingWindow([1, 2, 3], 2)",
    "import collections\n\n# Definition for a tuple\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n# Solution 1: \ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # Write your code here\n    if len(tuples) == 0:\n        return 0\n    max_val = -1\n    for t in tuples:\n        if t.y < max_val:\n            max_val = t.y\n    return max_val\n\n# Test Cases\ntuples = [[2, 1, 3], [5, 3, 5], [1, 2, 1]]\nprint(max_aggregate(tuples))\n\ntuples = [[2, 1, 3], [5, 3, 5], [1, 2, 1]]\nprint(max_aggregate(tuples))\n\ntuples = [[2, 1, 3], [5, 3, 5], [1, 2, 1]]\nprint(max_aggregate(tuples))",
    "# https://leetcode.com/problems/max-aggregation/\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def maxAggregation(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if len(tuples) == 0:\n            return 0\n        if len(tuples) == 1:\n            return max(tuples[0])\n        if len(tuples) == 2:\n            return max(tuples[0]) + max(tuples[1])\n        # Use the max of max of two tuples\n        max_tuples = [max(tuples[0]), max(tuples[1])]\n        max_tuples.sort()\n        return max_tuples[0] + max_tuples[1]",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxTuple(self, nums):\n        if not nums:\n            return 0\n\n        max_val = nums[0]\n        for i in range(1, len(nums)):\n            max_val = max(max_val, nums[i])\n        return max_val\n\nif __name__ == \"__main__\":\n    print Solution().maxTuple([1,2,3])",
    "from collections import defaultdict\n\ndef max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_aggregation = defaultdict(int)\n    for t in tuples:\n        for i in t:\n            max_aggregation[i] += t[i]\n    return max(max_aggregation.values())",
    "def max_aggregate(tuples):\n    if len(tuples) == 0:\n        return 0\n    max_val = tuples[0]\n    for val in tuples[1:]:\n        if val[0] > max_val[0]:\n            max_val = val\n        elif val[1] > max_val[1]:\n            max_val = val\n    return max_val\n\n\ndef main():\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert max_aggregate([(1, 4), (2, 3), (2, 5), (3, 1), (3, 6), (4, 1), (4, 8)]) == 8, \"Example\"\n    assert max_aggregate([(1, 2), (2, 3), (2, 4), (3, 1), (3, 6), (4, 1), (4, 8)]) == 8, \"Example\"\n    assert max_aggregate([(1, 2), (2, 3), (2, 4), (3, 1), (3, 6), (4, 1), (4, 8), (5, 1)]) == 8, \"Example\"\n    assert max_aggregate([(1, 2), (2, 3), (2, 4), (3, 1), (3, 6), (4, 1), (4, 8), (5, 1), (5, 5), (6, 1), (6, 7)]) == 8, \"Example\"\n    assert max_aggregate([(1, 2), (2, 3), (2, 4), (3, 1), (3, 6), (4, 1), (4, 8), (5, 1), (5, 5), (6, 1), (6, 7), (7, 3)]) == 8, \"Example\"\n    assert max_aggregate([(1, 2), (2, 3), (2, 4), (3, 1), (3, 6), (4, 1), (4, 8), (5, 1), (5, 5), (6, 1), (6, 7), (7, 3), (8, 1)]) == 8, \"Example\"\n\nif __name__ == '__main",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n    def __repr__(self):\n        return str(self.x)\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __le__(self, other):\n        return self.x <= other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __ne__(self, other):\n        return self.x!= other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __ge__(self, other):\n        return self.x >= other.x\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        ret = 0\n        for t in sorted(tuples, key=lambda x: x.x):\n            if t.y is not None:\n                ret = max(ret, t.y)\n        return ret\n\nif __name__ == '__main__':\n    print Solution().maxTuple([(1,2),(3,4)])",
    "from collections import namedtuple\n\n\ndef max_agg(tuples):\n    \"\"\"\n    :param tuples: a list of tuples\n    :return: the maximum aggregate\n    \"\"\"\n    # TODO: implement\n    return\n\n\ndef main():\n    tuples = [(1, 2), (3, 4), (5, 6)]\n    max_agg(tuples)\n\n\nif __name__ == \"__main__\":\n    main()",
    "# https://www.hackerrank.com/challenges/max-aggregation\n# https://www.hackerrank.com/challenges/max-aggregation-ii\n# https://www.hackerrank.com/challenges/max-aggregation-iii\n\ndef max_aggregation(tup_list):\n    \"\"\"\n    :type tup_list: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tup_list:\n        return 0\n\n    max_sum = tup_list[0][0]\n    max_idx = 0\n    for i in range(1, len(tup_list)):\n        sum = tup_list[i][0]\n        if sum > max_sum:\n            max_sum = sum\n            max_idx = i\n    return max_sum\n\nif __name__ == '__main__':\n    with open(\"input.txt\") as f:\n        tup_list = [[int(x) for x in line.strip().split(\" \")] for line in f.readlines()]\n        print(max_aggregation(tup_list))",
    "from collections import Counter\n\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    return max(Counter(tuple(t) for t in tuples).values())\n\n\nif __name__ == \"__main__\":\n    assert max_aggregate([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]) == 3\n    assert max_aggregate([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]) == 3\n    assert max_aggregate([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]) == 3\n    assert max_aggregate([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]) == 3",
    "# https://www.hackerrank.com/challenges/max-aggregation/problem\n\n# Brute force\ndef max_aggregation(arr):\n    max_value = arr[0]\n    for i in arr:\n        if i > max_value:\n            max_value = i\n    return max_value\n\n# Recursion\ndef max_aggregation_recursion(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n    return max(max_aggregation_recursion(arr[:2]), max(arr[2:]))\n\n\n# Time Complexity\n# O(n)\ndef max_aggregation_time_complexity(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n    return max(max_aggregation_time_complexity(arr[:2]), max(arr[2:]))\n\n# Space Complexity\n# O(n)\ndef max_aggregation_space_complexity(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n    return max(max_aggregation_space_complexity(arr[:2]), max(arr[2:]))\n\n\n# This is the correct solution\n# O(n)\ndef max_aggregation_correct(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n    return max(max_aggregation_correct(arr[:2]), max(arr[2:]))\n\n\n# This is the best solution\n# O(n)\ndef max_aggregation_best(arr",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    def find_max(tuple):\n        max_val = tuple[0]\n        max_pos = 0\n        for i in range(1, len(tuple)):\n            if tuple[i] > max_val:\n                max_val = tuple[i]\n                max_pos = i\n        return (max_val, max_pos)\n\n    def max_aggregate_helper(tuples, max_val, max_pos):\n        for t in tuples:\n            val, pos = find_max(t)\n            if val > max_val:\n                max_val = val\n                max_pos = pos\n        return max_val, max_pos\n\n    max_val, max_pos = max_aggregate_helper(tuples, 0, 0)\n    return max_val",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: tuple\n    \"\"\"\n    return max(tuples)\n\nprint(max_aggregate([(1, 2), (4, 5), (3, 2)]))",
    "class Solution(object):\n    def maxTuple(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: int\n        \"\"\"\n        max_agg = -1\n        for i in range(len(arr)):\n            for j in range(len(arr[i])):\n                if arr[i][j] > max_agg:\n                    max_agg = arr[i][j]\n        return max_agg",
    "class Solution:\n    # @param {List[Tuple]} trees\n    # @return {Integer}\n    def maxTree(self, trees):\n        if trees:\n            left, right = trees[0]\n            max_left = self.maxTree(trees[1:])\n            max_right = self.maxTree(trees[1:])\n            return max(max_left, max_right) + max(left, right)\n        else:\n            return 0",
    "import sys\n\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    return max([t[0] for t in tuples])\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Please provide at least one input argument.\")\n        return\n\n    tuples = [tuple(map(int, input().split())) for _ in range(int(sys.argv[1]))]\n    print(max_aggregate(tuples))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for tup in tuples:\n        max_value = max(max_value, tup[0] + tup[1])\n    return max_value\n\n\ndef test_max_aggregation():\n    assert max_aggregation([(1, 2), (2, 3), (1, 4), (2, 5)]) == 6\n    assert max_aggregation([(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) == 6\n    assert max_aggregation([(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (3, 4), (4, 5)]) == 10\n\n\nif __name__ == '__main__':\n    test_max_aggregation()",
    "# https://leetcode.com/problems/maximum-aggregate-from-a-group-of-tuples/description/\n\nclass Solution:\n    # @param nums: A list of integers\n    # @return: A integer\n    def maxTuple(self, nums):\n        nums.sort()\n        return max(nums[0], nums[-1])\n        \nif __name__ == '__main__':\n    s = Solution()\n    print s.maxTuple([1, 2, 1, 3, 5, -1, -2, -3, -4, -5])",
    "def max_aggregate(tuple_list):\n    \"\"\"\n    Write a function max_aggregate that takes a list of tuples and returns\n    the maximum aggregate.\n\n    Example:\n\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6), (7, 8)])\n    8\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    >>> max_aggregate([(1, 2), (3, 4)])\n    (3, 4)\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    >>> max_aggregate([(1, 2), (3, 4), (5, 6), (7, 8)])\n    (8, 8)\n    \"\"\"\n    # +++your code here+++\n    return max(tuple_list)\n\n\n# https://www.hackerrank.com/challenges/max-aggregate/problem",
    "from collections import defaultdict\n\n\nclass Solution(object):\n    def maxTuple(self, arr):\n        \"\"\"\n        :type arr: List[tuple]\n        :rtype: int\n        \"\"\"\n        res = defaultdict(int)\n        for tup in arr:\n            for k, v in tup:\n                res[k] = max(res[k], v)\n        return max(res.values())\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxTuple([(1, 2), (3, 4)]) == 4\n    assert Solution().maxTuple([(1, 2), (2, 3), (3, 4)]) == 4\n    assert Solution().maxTuple([(1, 2), (2, 3), (3, 4), (4, 5)]) == 5\n    assert Solution().maxTuple([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 6",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: Tuple\n        \"\"\"\n        def max_agg(a, b):\n            if a > b:\n                return a\n            else:\n                return b\n        return max(map(max_agg, tuples))",
    "import collections\ndef max_agg(list):\n    \"\"\"\n    :type list: List[tuple]\n    :rtype: tuple\n    \"\"\"\n    if not list:\n        return tuple()\n    max_agg_tuple = collections.defaultdict(list).__getitem__\n    max_agg_tuple(list[0])[-1] = max(max_agg_tuple(list[0])[-1], list[0][-1])\n    return max_agg_tuple(list[0])[-1]\n\n# Your MaxAgg class should have a constructor that takes an input array of\n# tuples as an argument\nclass MaxAgg(object):\n    \"\"\"\n    Implement your MaxAgg object here.\n    \"\"\"\n    def __init__(self, list):\n        \"\"\"\n        :type list: List[tuple]\n        \"\"\"\n        self.list = list\n\n    def max_agg(self):\n        \"\"\"\n        :rtype: tuple\n        \"\"\"\n        if not self.list:\n            return tuple()\n        max_agg_tuple = collections.defaultdict(list).__getitem__\n        max_agg_tuple(self.list[0])[-1] = max(max_agg_tuple(self.list[0])[-1], self.list[0][-1])\n        return max_agg_tuple(self.list[0])[-1]\n\n# Your MaxAgg object should have a to_list method\nclass MaxAgg(object):\n    \"\"\"\n    Implement your MaxAgg object here.\n    \"\"\"\n    def __init__(self, list):\n        \"\"\"\n        :type list: List[tuple]\n        \"\"\"\n        self.list = list\n\n    def max_agg(self):\n        \"\"\"\n        :rtype: tuple\n        \"\"\"\n        if not self.list:\n            return tuple()\n        max_agg_tuple = collections.defaultdict(list).__getitem__\n        max_agg_tuple(self.list[0])[-1] = max(max_agg_tuple(self.list[0])[-1], self.list[0][-1])\n        return max_agg_",
    "# https://www.hackerrank.com/challenges/maximum-aggregate/problem\n\ndef max_aggregate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Initialize max_aggregate to -1\n    max_aggregate = -1\n    # Check if there is only one element in the list\n    if len(nums) == 1:\n        # Set max_aggregate to the only element\n        max_aggregate = nums[0]\n    # If there are more than one element\n    else:\n        # Initialize max_aggregate to -1\n        max_aggregate = -1\n        # Loop through the list of tuples\n        for i in range(0, len(nums)):\n            # Check if the current value is greater than the current max_aggregate\n            if nums[i] > max_aggregate:\n                # Set max_aggregate to the current value\n                max_aggregate = nums[i]\n    return max_aggregate\n\n# https://www.hackerrank.com/challenges/maximum-aggregate/submissions/code/5385908\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(max_aggregate(nums))",
    "import collections\nimport heapq\n\ndef max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    heap = collections.deque()\n    for i in range(len(tuples)):\n        heap.append((tuples[i][0], tuples[i][1]))\n    while heap:\n        heapq.heappop(heap)\n        for i in range(len(tuples)):\n            if tuples[i][0] < heap[0][0]:\n                heapq.heappush(heap, (tuples[i][0], tuples[i][1]))\n    return heap[0][1]\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 5),\n        (5, 6),\n        (6, 7),\n        (7, 8),\n        (8, 9),\n        (9, 10),\n        (10, 11),\n        (11, 12),\n        (12, 13),\n        (13, 14),\n        (14, 15),\n        (15, 16),\n        (16, 17),\n        (17, 18),\n        (18, 19),\n        (19, 20),\n        (20, 21),\n        (21, 22),\n        (22, 23),\n        (23, 24),\n        (24, 25),\n        (25, 26),\n        (26, 27),\n        (27, 28),\n        (28, 29),\n        (29, 30),\n        (30, 31),\n        (31, 32),\n        (32, 33),\n        (33, 34),\n        (34, 35),\n        (35, 36),\n        (36, 37),\n        (37, 38),\n        (38, 39),\n        (39, 40),\n        (40, 41),\n        (41, 42),\n        (42, 43),\n        (43, 44),\n        (44, 45),\n        (45, 46),",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    max_aggregate = 0\n    max_aggregate_index = 0\n\n    for index, tup in enumerate(tuples):\n        if tup[0] > max_aggregate:\n            max_aggregate = tup[0]\n            max_aggregate_index = index\n\n    return max_aggregate, max_aggregate_index\n\nif __name__ == '__main__':\n    tuples = [\n        (3, 3),\n        (1, 2),\n        (3, 2),\n        (1, 1)\n    ]\n\n    print(max_aggregate(tuples))",
    "import collections\n\ndef max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    def add_max_to_tuple(tuple):\n        \"\"\"\n        :type tuple: tuple\n        \"\"\"\n        if len(tuple) == 1:\n            return tuple[0]\n        max_value = max([tuple[i] for i in range(len(tuple))])\n        return max(tuple, key=lambda x: x+max_value)\n\n    return max(map(add_max_to_tuple, tuples))\n\n\ndef test_max_aggregation():\n    tuples = [(1, 2), (3, 4), (5, 6)]\n    assert max_aggregation(tuples) == 6",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: Tuple\n    \"\"\"\n    max_value = 0\n    max_index = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i][0] < tuples[j][0]:\n                if tuples[i][1] > max_value:\n                    max_value = tuples[i][1]\n                    max_index = i\n    return (max_index, max_value)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def maxTuple(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if not tuples: return 0\n        m = max(tuple.x for tuple in tuples)\n        for tuple in tuples:\n            m = max(m, tuple.x, tuple.y)\n        return m\n\ns = Solution()\nt1 = (1, 1)\nt2 = (2, 2)\nt3 = (1, 2)\nt4 = (2, 2)\nt5 = (1, 2)\nt6 = (1, 2)\nt7 = (1, 2)\nt8 = (1, 2)\nt9 = (1, 2)\nt10 = (1, 2)\nt11 = (1, 2)\nt12 = (1, 2)\nt13 = (1, 2)\nt14 = (1, 2)\nt15 = (1, 2)\nt16 = (1, 2)\nt17 = (1, 2)\nt18 = (1, 2)\nt19 = (1, 2)\nt20 = (1, 2)\nt21 = (1, 2)\nt22 = (1, 2)\nt23 = (1, 2)\nt24 = (1, 2)\nt25 = (1, 2)\nt26 = (1, 2)\nt27 = (1, 2)\nt28 = (1, 2)\nt29 = (1, 2)\nt30 = (1, 2)\nt31 = (1, 2)\nt32 = (1, 2)\nt33 = (1, 2)\nt34 = (1, 2)\nt35 = (1, 2)\nt36 = (1, 2)\nt37 = (1, 2)\nt38 = (1, 2)\nt39 = (1, 2)\nt40 = (1, 2)\nt41 = (1, 2)",
    "import collections\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    # Your code here\n    return max_aggregate_recursive(tuples)\n\n\ndef max_aggregate_recursive(tuples):\n    if not tuples:\n        return 0\n    max_ = collections.defaultdict(lambda: 0)\n    for t in tuples:\n        for k in t:\n            max_[k] = max(max_[k], t[k])\n    return max(max_)\n\n\nif __name__ == \"__main__\":\n    tuples = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8)]\n    print(max_aggregate(tuples))",
    "def max_aggregate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Write your code here\n    if not nums:\n        return 0\n    max_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n    return max_value\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(max_aggregate(nums))\n    nums = [1, 1, 1, 1, 1]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(max_aggregate(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(max_aggregate(nums))",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    return max(tuple(i) for i in tuples)\n\n\n# Your MaxAggregate solution here.",
    "def max_aggregation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    res = 0\n    for t in tuples:\n        res = max(res, t[0]*t[1])\n    return res\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSlidingWindow(self, nums, k):\n        if k == 0: return 0\n        if k == 1: return max(nums)\n        res = 0\n        for i in range(len(nums)):\n            if i-k >= 0:\n                res = max(res, nums[i-k]*nums[i])\n            if i+k < len(nums):\n                res = max(res, nums[i]*nums[i+k])\n        return res",
    "from collections import defaultdict\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    def get_max(d, key, default):\n        if key in d:\n            return max(d[key], default)\n        else:\n            return default\n\n    aggregate = defaultdict(lambda: 0)\n    for t in tuples:\n        aggregate[t[0]] += t[1]\n    return max(aggregate.values(), default=0)\n\n# Your MaxAggregate object will be instantiated and called as such:\n# obj = MaxAggregate(tuples)\n# param_1 = obj.max_aggregate(tuples)",
    "#!/usr/bin/env python\n\nimport collections\n\ndef max_aggregate(tuples):\n    \"\"\"\n    Write a function to calculate the maximum aggregate from the list of tuples.\n\n    tuples is a list of tuples, each tuple is a pair of numbers.\n    For example, [(1, 5), (2, 3), (4, 9)] is a valid input.\n\n    Return the maximum aggregate.\n    \"\"\"\n    aggregate = collections.Counter()\n    for t in tuples:\n        aggregate.update(t)\n\n    return aggregate.most_common(1)[0][0]\n\ndef main():\n    tuples = [(1, 5), (2, 3), (4, 9)]\n    print(max_aggregate(tuples))\n\nif __name__ == '__main__':\n    main()",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for i in range(len(tuples)):\n        if tuples[i][0] > max_value:\n            max_value = tuples[i][0]\n    for i in range(len(tuples)):\n        if tuples[i][1] > max_value:\n            max_value = tuples[i][1]\n    return max_value\n\n\ndef test_max_aggregate():\n    tuples = [\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 5),\n        (5, 6),\n        (6, 7),\n        (7, 8),\n        (8, 9),\n        (9, 10),\n        (10, 11),\n        (11, 12),\n        (12, 13),\n        (13, 14),\n        (14, 15),\n        (15, 16),\n        (16, 17),\n        (17, 18),\n        (18, 19),\n        (19, 20),\n        (20, 21),\n        (21, 22),\n        (22, 23),\n        (23, 24),\n        (24, 25),\n        (25, 26),\n        (26, 27),\n        (27, 28),\n        (28, 29),\n        (29, 30),\n        (30, 31),\n        (31, 32),\n        (32, 33),\n        (33, 34),\n        (34, 35),\n        (35, 36),\n        (36, 37),\n        (37, 38),\n        (38, 39),\n        (39, 40),\n        (40, 41),\n        (41, 42),\n        (42, 43),\n        (43, 44),\n        (44, 45),\n        (45, 46),\n        (46, 47),\n        (47, 48),\n        (48, 49),\n        (49, 50),\n        (50, 51),\n        (51, 52),\n        (52,",
    "# https://leetcode.com/problems/max-aggregate-from-tuples/discuss/113370/C-Python-Solution\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n        self.z = 0\n\n    def __add__(self, t):\n        self.y += t.y\n        self.z += t.z\n        return self\n\n    def __radd__(self, t):\n        self.y += t.y\n        self.z += t.z\n        return self\n\n\nclass Solution(object):\n    def maxAggregation(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        def max(a, b):\n            return max(a, b[0]) if a[0] < b[0] else b[0]\n\n        def max_aggregation(t):\n            if len(t) == 0:\n                return 0\n            max_y = max_z = t[0].z\n            for t2 in t[1:]:\n                max_y = max(max_y, t2.y)\n                max_z = max(max_z, t2.z)\n            return max_y + max_z\n\n        max_aggregation_list = list()\n        for t in tuples:\n            max_aggregation_list.append(max_aggregation(t))\n\n        return max(max_aggregation_list)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    t = (1, 1, 1)\n    t = (1, 2, 3)\n    t = (3, 1, 2)\n    t = (1, 2, 3, 4)\n    print s.maxAggregation(t)",
    "class Solution(object):\n    def maxFromTuple(self, arr):\n        \"\"\"\n        :type arr: List[tuple]\n        :rtype: int\n        \"\"\"\n        def max(x, y):\n            if x > y:\n                return x\n            elif y > x:\n                return y\n            else:\n                return x\n\n        if len(arr) == 0:\n            return 0\n        m = max(arr[0][0], arr[0][1])\n        for i in range(1, len(arr)):\n            m = max(m, max(arr[i][0], arr[i][1]))\n        return m\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxFromTuple([(1, 2), (2, 2), (2, 2)]) == 4",
    "# Example\n#\n# [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n# -> 10\n#\n# max_aggregation([(1,",
    "import unittest\n\n\ndef max_aggregate(tuples):\n    \"\"\"\n    :param tuples: list of tuples\n    :return: tuple of (max_value, max_count)\n    \"\"\"\n    max_value = 0\n    max_count = 0\n    for value, count in tuples:\n        if count > max_count:\n            max_value = value\n            max_count = count\n    return (max_value, max_count)\n\n\nclass TestMaxAggregate(unittest.TestCase):\n    \"\"\"\n    TestCase for max_aggregate\n    \"\"\"\n    def test_max_aggregate(self):\n        tuples = [(1, 1), (2, 1), (3, 1), (4, 1), (1, 2)]\n        self.assertEqual(max_aggregate(tuples), (4, 2))",
    "# https://www.hackerrank.com/challenges/max-aggregation/problem\n\nn = int(input())\n\ndef max_aggregation(arr):\n    max_aggregation = 0\n    for i in range(n):\n        max_aggregation = max(max_aggregation, arr[i][0] + arr[i][1])\n    return max_aggregation\n\narr = list(map(lambda x: map(int, x.split()), input().split()))\n\nprint(max_aggregation(arr))",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for tuple in tuples:\n        max_value = max(max_value, tuple[0])\n    return max_value\n\nclass Tuple:\n    def __init__(self, value):\n        self.value = value\n    def __lt__(self, other):\n        return self.value < other.value\n    def __gt__(self, other):\n        return self.value > other.value\n    def __eq__(self, other):\n        return self.value == other.value\n    def __repr__(self):\n        return 'Tuple(%r)' % self.value\n\ntuples = [Tuple(i) for i in range(1, 10)]\nprint max_aggregate(tuples)",
    "# https://www.hackerrank.com/challenges/max-aggregate/problem\n\n# Returns the maximum value of the list of tuples.\ndef max_aggregate(lst):\n    # If lst is empty, return 0.\n    if not lst:\n        return 0\n\n    # If the first element is greater than the rest,\n    # return the first element.\n    if lst[0][0] > lst[1][0]:\n        return lst[0][0]\n\n    # Otherwise, return the second element.\n    return lst[1][0]",
    "# https://leetcode.com/problems/maximum-aggregate/\n\nclass Solution(object):\n    def maxAggregate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/maximum-aggregate/discuss/76930/Python-with-explanation\n        def find_max(arr, low, high):\n            if low == high:\n                return arr[low]\n            mid = (low + high) / 2\n            if arr[mid] < arr[high]:\n                return find_max(arr, low, mid)\n            else:\n                return find_max(arr, mid + 1, high)\n\n        max_val = find_max(nums, 0, len(nums) - 1)\n        for i in range(len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n        return max_val",
    "def max_aggregate(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    max_value = -sys.maxsize\n    for t in tuples:\n        max_value = max(max_value, t[0])\n        max_value = max(max_value, t[1])\n\n    return max_value\n\n\n# Your MaxAggregate object will be instantiated and called as such:\n# obj = MaxAggregate(tuples)\n# param_1 = obj.max_aggregate(tuples)",
    "def max_aggregate(tups):\n    \"\"\"\n    :type tups: List[tuple]\n    :rtype: int\n    \"\"\"\n    return max([sum(tup) for tup in tups])\n\nif __name__ == '__main__':\n    tups = [\n        (1, 2, 3),\n        (2, 2, 3),\n        (3, 2, 3),\n        (1, 3, 3),\n        (2, 3, 3),\n        (3, 3, 3),\n    ]\n    assert max_aggregate(tups) == 6"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}