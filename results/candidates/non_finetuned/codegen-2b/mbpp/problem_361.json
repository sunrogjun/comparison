{
  "problem": {
    "task_id": "MBPP/372",
    "prompt": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.",
    "canonical_solution": "import heapq as hq\r\ndef heap_assending(nums):\r\n  hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result",
    "test_list": [
      "assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]",
      "assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]",
      "assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
    ],
    "challenge_test_list": [],
    "problem_id": 361
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Heap queue implementation\n# Heap queue is a queue that maintains a heap structure (for each element, its parent is the greater one in the heap)\nclass HeapQueue:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, x):\n        self.heap.append(x)\n\n    def pop(self):\n        return self.heap.pop()\n\n    def is_empty(self):\n        return self.heap == []\n\n    def size(self):\n        return len(self.heap)\n\n    def sort(self):\n        self.heapify()\n\n    def heapify(self):\n        for i in range(self.size()-1, 0, -1):\n            self.percolate(i)\n\n    def percolate(self, i):\n        x = self.heap[i]\n        while i > 0:\n            parent = (i-1) // 2\n            if self.heap[parent] < x:\n                break\n            self.heap[i] = self.heap[parent]\n            i = parent\n        self.heap[i] = x\n\n\n# My solution\n# First, we define a helper function to perform a binary search\n# Second, we define a helper function to push a value to the heap\n# Third, we define a helper function to pop a value from the heap\n# Fourth, we define a helper function to check whether the heap is empty\n# Fifth, we define a helper function to check whether the heap is sorted\n\ndef binary_search(heap, x):\n    return binary_search(heap, x, 0, len(heap) - 1)\n\ndef push(heap, x):\n    return binary_search(heap, x, 0, len(heap) - 1)\n\ndef pop(heap):\n    return heap[0]\n\ndef is_empty(heap):\n    return heap == []\n\ndef is_sorted(heap):\n    return binary_search(heap, heap[0], 0, len(heap) - 1) == len(heap) - 1\n\nclass Solution(object):\n    def sortHeap(self, nums):",
    "class Solution:\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # write your code here\n        heap = []\n        for i in range(len(nums)):\n            heap.append((nums[i], i))\n        heapq.heapify(heap)\n        for i in range(len(nums)):\n            if heap[0][1] == i:\n                heap[0] = heap[0][0], 0\n            else:\n                heap[0] = nums[heap[0][1]], 0\n                heapq.heappush(heap, (nums[i], i))\n        \n        for i in range(len(nums)):\n            nums[i] = heap[0][0]\n            heapq.heappop(heap)",
    "def heapSort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    heap = []\n    for i in range(len(arr)):\n        heap.append(arr[i])\n\n    for i in range(len(arr)):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapq.heappush(heap, arr[i])\n\n    for i in range(1, len(arr)):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapq.heappush(heap, arr[i])\n        heapq.heappop(heap)\n\n    for i in range(len(arr)):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapq.heappush(heap, arr[i])\n\n    for i in range(1, len(arr)):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapq.heappush(heap, arr[i])\n        heapq.heappop(heap)\n\nif __name__ == \"__main__\":\n    arr = [3, 5, 6, 7, 8, 9]\n    heapSort(arr)\n    print(arr)\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heapSort(arr)\n    print(arr)\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heapSort(arr)\n    print(arr)\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heapSort(arr)\n    print(arr)\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heapSort(arr)\n    print(arr)\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heapSort",
    "# https://leetcode.com/problems/sort-list-using-heap-queue/discuss/81872/Java-Solution-with-explanation\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        heapq.heapify(head)\n        prev = None\n        while head:\n            curr = heapq.heappop(head)\n            if prev:\n                prev.next = curr\n            prev = curr\n            curr = curr.next\n        return prev\n\n# Time:  O(n^2)\n# Space: O(n)\n#\n# Heap queue solution\n#\n# class Solution:\n#     def sortList(self, head):\n#         \"\"\"\n#         :type head: ListNode\n#         :rtype: ListNode\n#         \"\"\"\n#         if not head or not head.next:\n#             return head\n#         heapq.heapify(head)\n#         prev = None\n#         while head:\n#             curr = heapq.heappop(head)\n#             if prev:\n#                 prev.next = curr\n#             prev = curr\n#             curr = curr.next\n#         return prev\n\n# Time:  O(n^2)\n# Space: O(n)\n#\n# Binary Heap queue solution\n#\n# class Solution:\n#     def sortList(self, head):\n#         \"\"\"\n#         :type head: ListNode\n#         :rtype: ListNode\n#         \"\"\"\n#         if not head or not head.next:\n#             return head\n#         heapq.heapify(head)\n#         prev = None\n#         while head:\n#             curr = heapq.heappop(head)\n#             if prev:\n#                 prev.next = curr",
    "from heapq import heappush, heappop, heapify\n\ndef heapSort(alist):\n    \"\"\"\n    :type alist: List[int]\n    :rtype: void Do not return anything, modify alist in-place instead.\n    \"\"\"\n    for i in range(len(alist)-1):\n        heapify(alist, i)\n        while alist[i] > alist[2*i+1]:\n            alist[i], alist[2*i+1] = alist[2*i+1], alist[i]\n            heapify(alist, 2*i+1)\n            heapify(alist, 2*i+2)\n    return\n\n# Your HeapSort object will be instantiated and called as such:\n# obj = HeapSort(alist)\n# obj.heapSort(alist)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def heapSort(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        def build_heap(root):\n            if root.left:\n                build_heap(root.left)\n            if root.right:\n                build_heap(root.right)\n            heapify(root)\n\n        def heapify(root):\n            if not root:\n                return\n            if root.left and root.val < root.left.val:\n                root.left = heapify(root.left)\n            if root.right and root.val > root.right.val:\n                root.right = heapify(root.right)\n\n        build_heap(root)\n        while root:\n            temp = root.left\n            root.left = root.right\n            root.right = temp\n            root = root.left",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def heapify(self, root, size):\n        \"\"\"\n        :type root: TreeNode\n        :type size: int\n        :rtype: None\n        \"\"\"\n        while root is not None and root.left is not None:\n            root, left = self.sift(root, root.left, size)\n            root, right = self.sift(root, root.right, size)\n        return\n\n    def sift(self, root, node, size):\n        while node is not None:\n            while node.left is not None and node.left.val < node.val:\n                node = node.left\n            while node.right is not None and node.right.val > node.val:\n                node = node.right\n            if node.left is None:\n                node.left = node.right\n            else:\n                node.left = self.sift(node.left, node.left.right, size)\n            if node.right is None:\n                node.right = node.left\n            else:\n                node.right = self.sift(node.right, node.right.left, size)\n            node = node.right\n        return root, node\n\n\nif __name__ == \"__main__\":\n    # print Solution().heapify([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)\n    n = TreeNode(1)\n    n.left = TreeNode(2)\n    n.right = TreeNode(3)\n    n.left.left = TreeNode(4)\n    n.left.right = TreeNode(5)\n    n.right.left = TreeNode(6)\n    n.right.right = TreeNode(7)\n    n.left.right.left = TreeNode(8)\n    n.left.right.right = TreeNode(9)\n    n.right.right.left = TreeNode(10)\n    n.right.right.right = TreeNode",
    "import heapq\n\ndef sort(list):\n    \"\"\"\n    :type list: List[int]\n    :rtype: void Do not return anything, modify list in-place instead.\n    \"\"\"\n    heapq.heapify(list)\n    for i in range(len(list)):\n        list[i] = heapq.heappop(list)\n        heapq.heappush(list, list[i])\n\nif __name__ == \"__main__\":\n    list = [4, 5, 1, 3, 2]\n    sort(list)\n    print(list)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n\n    print(solution.maxDepth(root))\n    print(solution.maxDepth(None))",
    "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        heapify(nums)\n        for i in range(len(nums) - 1):\n            if nums[i] < nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n            else:\n                break\n        return\n\n    def heapify(self, nums):\n        l = len(nums)\n        for i in range(l/2-1, -1, -1):\n            self.siftdown(nums, i, l)\n\n    def siftdown(self, nums, i, l):\n        # l = len(nums)\n        while i < l:\n            left = 2*i\n            right = 2*i+1\n            if left < l and nums[left] < nums[i]:\n                left += 1\n            if right < l and nums[right] < nums[i]:\n                right += 1\n            if left < l and nums[left] < nums[right]:\n                left += 1\n            if right < l and nums[right] < nums[left]:\n                right += 1\n            if left < l and nums[left] <= nums[i]:\n                break\n            nums[i], nums[left] = nums[left], nums[i]\n            i = left\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# obj.sort(nums)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # Use heap queue to sort\n        curr = head\n        while curr:\n            # Create a new node and enqueue it to the end of the list\n            next = curr.next\n            curr.next = None\n            heapq.heappush(curr)\n            \n            # Now, curr is the last node of the list\n            while curr.next:\n                # Re-enqueue curr to the end of the list\n                curr.next = curr.next.next\n                heapq.heappush(curr)\n                \n                # curr is now the last node of the list\n                # Move curr to the end of the list\n                curr = heapq.heappop(curr)\n            \n            # curr is the last node of the list\n            curr = next\n        \n        return head",
    "from heapq import heappush, heappop\n\n\ndef sort(list):\n    heap = [0] * len(list)\n    heapq.heapify(heap)\n    for element in list:\n        heappush(heap, element)\n    return list[0:len(heap)]\n\n\nif __name__ == '__main__':\n    list = [2, 1, 5, 3, 6, 4]\n    print(sort(list))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if not head:\n            return head\n        p1 = head\n        p2 = head\n        while p1 and p2:\n            if p1.val < p2.val:\n                p1, p2 = p2, p1\n            else:\n                p1, p2 = p2, p1\n        p2.next = None\n        p1 = self.sortList(head)\n        p2 = self.sortList(p1)\n        while p1:\n            p1, p2 = p2, p1\n            p2.next = None\n            p1 = self.sortList(p2)\n        return p2",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        # build a queue\n        heap = [head]\n        while heap:\n            cur = heap.pop(0)\n            cur.next = None\n            while cur.right:\n                heapq.heappush(heap, cur.right)\n                cur = cur.right\n            heapq.heappush(heap, cur)\n            cur = heap.pop(0)\n            cur.next = None\n            while cur.left:\n                heapq.heappush(heap, cur.left)\n                cur = cur.left\n            heapq.heappush(heap, cur)\n            cur = heap.pop(0)\n            cur.next = None\n\n        return heap[0]",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        heap = []\n        node = head\n        while node:\n            heapq.heappush(heap, node.val)\n            node = node.next\n        heapq.heapify(heap)\n        node = head\n        while node and node.next:\n            while node.val < node.next.val:\n                node = node.next\n            if node.val == node.next.val:\n                node.next = node.next.next\n            else:\n                temp = node.next\n                node.next = node.next.next\n                heapq.heappush(heap, temp)\n        return head",
    "class HeapQueue:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def enqueue(self, x):\n        if self.size == 0 or x < self.heap[0]:\n            self.heap.insert(0, x)\n            self.size += 1\n        else:\n            self.heap.insert(self.size, x)\n            self.size += 1\n            self.heapify()\n\n    def dequeue(self):\n        if self.size == 0:\n            return None\n        else:\n            return self.heap.pop()\n\n    def size(self):\n        return self.size\n\n    def heapify(self):\n        n = self.size - 1\n        while n > 0:\n            self.heap[n] = self.heap[0]\n            self.heap[0] = self.heap[0].heapify()\n            n -= 1\n\ndef sort(arr):\n    heap = HeapQueue()\n    for x in arr:\n        heap.enqueue(x)\n    while heap.size() > 1:\n        heap.heapify()\n        arr[heap.size()-1], arr[0] = arr[0], arr[heap.size()-1]\n        heap.dequeue()\n        heap.heapify()\n    return arr\n\nif __name__ == '__main__':\n    arr = [10, 5, 9, 4, 2, 1]\n    print(sort(arr))",
    "from heapq import *\n\ndef heapSort(data):\n    \"\"\"\n    :type data: List[int]\n    :rtype: void Do not return anything, modify data in-place instead.\n    \"\"\"\n    heapify(data)\n    for i in xrange(len(data)):\n        data[i], data[0] = data[0], data[i]\n        heapify(data)",
    "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n\n        heap = [nums[0]]\n        for i in range(1, len(nums)):\n            if nums[i] < heap[0]:\n                heap.append(nums[i])\n            else:\n                heapq.heappush(heap, nums[i])\n\n        heapq.heapify(heap)\n        while heap:\n            print heapq.heappop(heap)\n\n\ndef main():\n    sol = Solution()\n    nums = [3, 2, 1, 6, 0, 5, 4]\n    sol.sort(nums)\n    print nums\n\nif __name__ == '__main__':\n    main()",
    "# HeapQueue\n# Heap is a kind of queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store elements from any type.\n# Heap is a queue that can store",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Use heap queue to sort the tree.\n        \"\"\"\n        if root is None:\n            return\n\n        self.sortTree(root.left)\n        self.sortTree(root.right)\n\n        while root:\n            # Find the smallest element in the queue.\n            heapq.heappop(root.left.queue)\n            heapq.heappop(root.right.queue)\n            root.val = heapq.heappop(root.queue)\n\n            if root.left:\n                heapq.heappush(root.left.queue, root.val)\n            if root.right:\n                heapq.heappush(root.right.queue, root.val)\n            root = root.left\n\n        return",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        # init queue\n        q = []\n        p = head\n        while p:\n            q.append(p)\n            p = p.next\n        heapq.heapify(q)\n\n        # sort\n        while q:\n            # remove top element from queue\n            p = q.pop()\n            # put p's next to head\n            if p.next:\n                heapq.heappush(q, p.next)\n            # put p's next to last element in queue\n            else:\n                heapq.heappush(q, head)\n                head = head.next\n        return head\n\n\nif __name__ == \"__main__\":\n    # [1,2,3,4]\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    print Solution().sortList(head)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        self.insert(head, head.next)\n        self.insert(head.next, head)\n        self.heapify(head)\n        return head\n\n    def insert(self, head, node):\n        if not head:\n            head = node\n        else:\n            curr = head\n            while curr.next:\n                if curr.next.val < node.val:\n                    curr = curr.next\n                else:\n                    break\n            curr.next = node\n        return head\n\n    def heapify(self, head):\n        curr = head\n        while curr.next and curr.next.next:\n            if curr.next.val < curr.next.next.val:\n                curr = curr.next\n            else:\n                self.swap(curr, curr.next)\n                curr = curr.next\n\n# Note:\n# This is a bit tricky, we can't use list.sort() because it is not stable.\n# If we can use list.sort() as a sort function, we can use list.reverse() to reverse the order.\n#\n# O(n) time\n# O(n) space",
    "import heapq\n\ndef sort(lst):\n    heapq.heapify(lst)\n    for i in range(len(lst)-1,0,-1):\n        heapq.heappop(lst)\n        heapq.heappush(lst,lst[i])\n\n\n\n#These \"asserts\" using only for self-checking and not necessary for auto-testing\nif __name__ == '__main__':\n    assert sort([1,3,2,5,7,9]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([9,3,7,2,5,1]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([9,3,7,5,2,1]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([1,9,7,2,3,5]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([1,9,7,5,3,2]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([1,2,3,5,7,9]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([5,7,9,2,1,3]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([9,3,7,2,5,1]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([1,9,7,2,3,5]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([1,9,7,5,2,3]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([5,7,9,2,1,3]) == [1,2,3,5,7,9], \"Example\"\n    assert sort([9,3,7,2,5,1]) == [1,2,3,5,7,9], \"",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def sortList(self, nodes):\n        \"\"\"\n        :type nodes: List[TreeNode]\n        :rtype: void Do not return anything, modify nodes in-place instead.\n        \"\"\"\n        if not nodes:\n            return\n\n        nodes.sort(key=lambda node: node.val)\n\n        queue = []\n        for node in nodes:\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        while queue:\n            parent = queue.pop(0)\n            if parent.right:\n                parent.right = self.build_min_tree(parent.right)\n                parent.right.parent = parent\n            if parent.left:\n                parent.left = self.build_min_tree(parent.left)\n                parent.left.parent = parent\n            queue.append(parent)\n\n\n    def build_min_tree(self, node):\n        if not node:\n            return node\n        if node.left:\n            node.left = self.build_min_tree(node.left)\n        if node.right:\n            node.right = self.build_min_tree(node.right)\n        return node\n\n\n# Note:\n# https://leetcode.com/problems/sort-list-ii/discuss/148878/C%2B%2B-Solution-with-O(n)-Space-Time",
    "from heapq import heappush, heappop\n\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heappush(heap, (nums[i], i))\n\n        for i in range(len(nums) - 1, -1, -1):\n            heappop(heap)\n            nums[i], nums[heap[0][1]] = nums[heap[0][1]], nums[i]",
    "def heap_sort(arr):\n    heap = []\n    for i in range(len(arr)):\n        heap.append(arr[i])\n        heapify(heap)\n    for i in range(len(arr)):\n        arr[i] = heap[0]\n        heap[0] = heap[len(heap) - 1]\n        heap[len(heap) - 1] = arr[i]\n        heapify(heap)\n    return arr\n\n\ndef heap_sort_recursive(arr):\n    if len(arr) < 2:\n        return arr\n    for i in range(len(arr) - 1):\n        arr[i], arr[i+1] = arr[i+1], arr[i]\n        heap_sort_recursive(arr)\n    return arr\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    arr = [6, 7, 8, 9, 10]\n    print(heap_sort(arr))\n    arr = [1, 2, 3, 4, 5]\n    print(heap_sort_recursive(arr))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        head = ListNode(0)\n        head.next = lists[0]\n        p = head\n        for i in range(1, len(lists)):\n            p = self.heap_sort(lists[i], p)\n        return head.next\n        \n    def heap_sort(self, head, p):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        p = self.heap_sort(head, p)\n        p = self.heap_sort(head.next, p)\n        return self.heap_sort_helper(head, p)\n    \n    def heap_sort_helper(self, head, p):\n        while head and head.next:\n            if head.next.val <= head.val:\n                head, head.next = head.next, head\n            else:\n                break\n        if not head:\n            return None\n        head.next = None\n        new_head = head\n        while new_head:\n            new_head = self.heap_sort_helper(new_head.next, p)\n            p = new_head\n        return p",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortList(self, head: TreeNode) -> TreeNode:\n        if not head or not head.left:\n            return head\n\n        heap = []\n        node = head\n        while node:\n            heap.append(node)\n            node = node.left\n        heap.reverse()\n        while heap:\n            node = heap.pop()\n            node.left = None\n            node.right = heap[-1]\n            heap.pop()\n            node = node.right\n        return head",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \"\"\"\n        Use queue to do this.\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        # Create a queue with head as its only element.\n        queue = [head]\n        \n        # Keep track of the size of the queue.\n        size = 1\n        \n        # Keep track of the last node.\n        lastNode = head\n        \n        while size > 0:\n            # Get the next element from the queue.\n            node = queue.pop(0)\n            \n            # Add the node to the last node.\n            lastNode.next = node\n            \n            # Add the node to the queue.\n            queue.append(node)\n            \n            # Update the size of the queue.\n            size += 1\n            \n            # Update the last node.\n            lastNode = node\n            \n        return lastNode",
    "class HeapQueue(object):\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.heapify()\n\n    def peek(self):\n        return self.arr[0]\n\n    def pop(self):\n        ret = self.arr.pop(0)\n        self.heapify()\n        return ret\n\n    def heapify(self):\n        l = self.size - 1\n        while l >= 0:\n            self.siftdown(l)\n            l -= 1\n\n    def siftdown(self, l):\n        while l > 0 and self.arr[l] < self.arr[0]:\n            self.arr[l], self.arr[0] = self.arr[0], self.arr[l]\n            l -= 1\n            \nif __name__ == '__main__':\n    arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap = HeapQueue(arr)\n    heap.insert(4)\n    heap.insert(1)\n    heap.insert(3)\n    heap.insert(6)\n    heap.insert(5)\n    heap.insert(2)\n    heap.insert(8)\n    heap.insert(7)\n    heap.insert(9)\n    heap.insert(0)\n    print heap.arr\n    print heap.pop()\n    print heap.arr\n    heap.heapify()\n    print heap.arr\n    heap.insert(10)\n    heap.insert(3)\n    heap.insert(9)\n    heap.insert(1)\n    heap.insert(8)\n    heap.insert(5)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(2)\n    heap.insert(0)\n    print heap.arr\n    heap.heapify()\n    print heap.arr\n    heap.pop()\n    print heap.arr\n    he",
    "def sort(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify(lst)\n    for i in range(len(lst) - 1):\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n        heapify(lst[i + 1:])\n    return lst\n\ndef heapify(lst):\n    for i in range(len(lst)):\n        if lst[i] < lst[2 * i + 1]:\n            lst[2 * i + 1], lst[i] = lst[i], lst[2 * i + 1]\n            heapify(lst[2 * i + 2:])\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5]\n    sort(lst)\n    print lst",
    "from heapq import heappush, heappop\n\nclass Solution:\n    \"\"\"\n    @param: A list of integers\n    @return: The sorted list\n    \"\"\"\n    def sort(self, A):\n        if not A: return A\n        heapq.heapify(A)\n        for i in range(len(A)):\n            heapq.heappush(A, A[i])\n            while len(A) > 1 and A[-1] > A[-2]:\n                heapq.heappop(A)\n        return A",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n\n        # Create a new node as a heap node\n        heap_node = ListNode(head.val)\n        heap_node.next = head\n        heap_node.prev = None\n\n        # Create a new queue\n        queue = []\n\n        # Add the first node to the queue\n        queue.append(heap_node)\n\n        # Iterate over the rest of the nodes and add them to the queue\n        while queue:\n            node = queue.pop(0)\n            # Add the next node to the queue\n            if node.next:\n                node.next.prev = node\n                queue.append(node.next)\n            else:\n                # The queue is empty\n                return node\n\n    def sortList_2(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n\n        # Create a new node as a heap node\n        heap_node = ListNode(head.val)\n        heap_node.next = head\n        heap_node.prev = None\n\n        # Create a new queue\n        queue = []\n\n        # Add the first node to the queue\n        queue.append(heap_node)\n\n        # Iterate over the rest of the nodes and add them to the queue\n        while queue:\n            node = queue.pop(0)\n            # Add the next node to the queue\n            if node.next:\n                node.next.prev = node\n                queue.append(node.next)\n            else:\n                # The queue is empty\n                return node\n\n    def sortList_3(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n\n        #",
    "import heapq\n\ndef sort(list):\n    \"\"\"\n    :type list: List[int]\n    :rtype: void\n    \"\"\"\n    heapq.heapify(list)\n    for i in range(len(list) - 1):\n        heapq.heappush(list, list[i])\n        while list[0] > list[1]:\n            list[0], list[1] = list[1], list[0]\n            heapq.heappop(list)\n    return\n\nif __name__ == '__main__':\n    l = [1, 3, 5, 6, 7]\n    sort(l)\n    print(l)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        heap = []\n        p = head\n        while p:\n            heap.append(p)\n            p = p.next\n        heap.sort(reverse=True)\n        p = heap[0]\n        while p:\n            if p.next:\n                p.next = p.next.next\n            else:\n                break\n            p = p.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        p1, p2 = head, head.next\n        while p2:\n            if p2.val < p1.val:\n                p1, p2 = p2, p2.next\n            else:\n                break\n        \n        p1.next = None\n        p2 = head\n        while p2:\n            if p2.val > p1.val:\n                p1.next = p2\n                p2 = p2.next\n            else:\n                p2 = p2.next\n                p1 = p1.next\n        \n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n\n        mid = self.getMid(head)\n        left = self.mergeSort(head)\n        right = self.mergeSort(mid)\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        head = None\n        while left and right:\n            if left.val <= right.val:\n                if head is None:\n                    head = ListNode(left.val)\n                    head.next = left\n                else:\n                    head.next = left\n                left = left.next\n            else:\n                if head is None:\n                    head = ListNode(right.val)\n                    head.next = right\n                else:\n                    head.next = right\n                right = right.next\n\n        if left:\n            if head is None:\n                head = ListNode(left.val)\n                head.next = left\n            else:\n                head.next = left\n        elif right:\n            if head is None:\n                head = ListNode(right.val)\n                head.next = right\n            else:\n                head.next = right\n\n        return head\n\n    def getMid(self, head):\n        count = 0\n        left = head\n        right = head\n        while left and right:\n            left = left.next\n            count += 1\n        if count % 2:\n            return left\n        return right",
    "def sort(arr):\n    heap = []\n    for i in arr:\n        heap.append(i)\n\n    while heap:\n        heapq.heappush(heap, heapq.heappop(heap))\n\n    return heap\n\n# Test Cases\narr = [1,2,3,4,5,6,7,8,9,10]\narr = [10,9,8,7,6,5,4,3,2,1]\narr = [1,2,3,4,5,6,7,8,9,10]\narr = [10,9,8,7,6,5,4,3,2,1]\narr = [2,1,3,4,5,6,7,8,9,10]\narr = [1,2,3,4,5,6,7,8,9,10]\narr = [10,9,8,7,6,5,4,3,2,1]\narr = [10,9,8,7,6,5,4,3,2,1]\n\nprint(sort(arr))",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        \n        head = ListNode(0)\n        head.next = lists[0]\n        \n        curr_head = head\n        for lst in lists[1:]:\n            curr_head = curr_head.next\n            curr_head.next = lst\n        return head.next\n\nif __name__ == \"__main__\":\n    l = [ListNode(1), ListNode(2), ListNode(3)]\n    l[0].next = l[1]\n    l[1].next = l[2]\n    l[2].next = l[3]\n    \n    s = Solution()\n    print s.mergeKLists(l)",
    "import heapq\n\n# Your Comparisons function should return a negative, 0, or positive integer if the first argument is less than, equal to, or greater than the second argument.\n#\n# Examples:\n#\n# [1,2,3] -> [-1,0,1,2,3]\n# [2,5,1] -> [-1,0,1,2,5,3]\n# [1,2,3,4,5] -> [-1,0,1,2,3,4,5]\n#\n# Assumption:\n# You can assume that the list is always sorted in ascending order\n\ndef sort(list):\n    if not list:\n        return list\n\n    n = len(list)\n\n    for i in range(n):\n        heapq.heappush(list, list[i])\n\n    for i in range(n-1):\n        heapq.heappop(list)\n\n    return list\n\n# Note:\n# You are not allowed to modify the list passed as parameter\n#\n# https://oj.leetcode.com/problems/sort-list/discuss/86517/Java-O(nlogn)-DP-solution-using-heap-queue-with-explanation",
    "import heapq\n\ndef sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    \n    if len(arr) <= 1:\n        return\n    \n    q = []\n    heapq.heapify(q)\n    \n    for i in range(len(arr)):\n        while q and arr[i] >= arr[q[0]]:\n            heapq.heappop(q)\n        heapq.heappush(q, arr[i])\n    \n    #print q\n    \n    for i in range(len(arr)):\n        arr[i] = heapq.heappop(q)\n        \n    return\n\n# Your SortAscendingInteger2 solution here.",
    "class Heap(object):\n    \"\"\"\n    Implementation of heap queue with O(n) time complexity.\n    \"\"\"\n    def __init__(self, elements):\n        self.elements = elements\n        self.size = len(elements)\n        self.heapify()\n\n    def heapify(self):\n        for i in range(self.size):\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < self.size and self.elements[i] > self.elements[left]:\n                left = self.size\n            if right < self.size and self.elements[i] > self.elements[right]:\n                right = self.size\n            if left < self.size and right < self.size and self.elements[i] > self.elements[left] and self.elements[i] > self.elements[right]:\n                self.elements[i], self.elements[left] = self.elements[left], self.elements[i]\n                self.elements[left + 1], self.elements[right + 1] = self.elements[right + 1], self.elements[left + 1]\n\n    def heap_sort(self):\n        while self.size > 1:\n            self.heapify()\n            self.elements[0], self.elements[self.size - 1] = self.elements[self.size - 1], self.elements[0]\n            self.size -= 1\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(self.elements[i], end=' ')\n        print()\n\n    def print_heap_sorted(self):\n        self.heap_sort()\n        self.print_heap()\n\n\nif __name__ == '__main__':\n    l = [5, 1, 3, 2, 6, 7, 9, 8]\n    heap = Heap(l)\n    heap.print_heap_sorted()",
    "class Solution(object):\n    def sortHeap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, nums[i])\n\n        for i in range(len(nums)):\n            nums[i] = heapq.heappop(heap)\n\n    def sortHeap2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heap.append(nums[i])\n\n        for i in range(len(nums)):\n            while len(heap) > 1 and heap[0] > heap[len(heap) - 1]:\n                heap[0], heap[len(heap) - 1] = heap[len(heap) - 1], heap[0]\n                heapq.heapify(heap)\n\n    def sortHeap3(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heap.append(nums[i])\n        for i in range(len(nums)):\n            while len(heap) > 1 and nums[heap[0]] > nums[heap[len(heap) - 1]]:\n                heap[0], heap[len(heap) - 1] = heap[len(heap) - 1], heap[0]\n                heapq.heapify(heap)",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        p = head\n        while p.next:\n            q = p.next\n            p.next = q.next\n            q.next = p\n            p = q\n\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        q = [head]\n        while q:\n            p = q.pop(0)\n            p = self.heapify(p)\n            q.append(p)\n\n        return head\n\n    def heapify(self, head):\n        if not head:\n            return head\n        p = head\n        while p.next:\n            if p.next.val < p.val:\n                p = p.next\n            else:\n                child = p.next.next\n                if child and child.val < p.val:\n                    p.next = child\n                    p = p.next\n        return p\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1)\n    l1.next = ListNode(2)\n    l1.next.next = ListNode(3)\n    l1.next.next.next = ListNode(4)\n    l1.next.next.next.next = ListNode(5)\n    l1.next.next.next.next.next = ListNode(6)\n    l1.next.next.next.next.next.next = ListNode(7)\n    l1.next.next.next.next.next.next.next = ListNode(8)\n\n    print Solution().sortList(l1)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        nodes = []\n        heap = []\n        while head:\n            nodes.append(head)\n            head = head.next\n        \n        for i in range(len(nodes)):\n            heap.append(nodes[i])\n            \n        while len(heap) > 1:\n            heap[0], heap[-1] = heap[-1], heap[0]\n            heap.pop()\n            heap.append(heap[-1])\n            \n        return nodes[0]",
    "def heapSort(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: void Do not return anything, modify lst in-place instead.\n    \"\"\"\n    heapify(lst)\n    for i in range(len(lst) - 1):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n        heapify(lst[i+1:])\n\ndef heapify(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: void Do not return anything, modify lst in-place instead.\n    \"\"\"\n    size = len(lst)\n    for i in range(size / 2, -1, -1):\n        if lst[i] > lst[2 * i]:\n            lst[i], lst[2 * i] = lst[2 * i], lst[i]\n            heapify(lst[2 * i + 1:])\n\ndef printList(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: void Do not return anything, modify lst in-place instead.\n    \"\"\"\n    for i in range(len(lst)):\n        print(lst[i], end=\" \")\n    print()\n\ndef main():\n    lst = [4, 2, 1, 5, 3, 8, 7, 9, 10, 15, 13, 12, 14]\n    heapSort(lst)\n    printList(lst)\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        q = []\n        prev = None\n        while head:\n            if prev:\n                prev.next = head\n            else:\n                q.append(head)\n            prev = head\n            head = head.next\n        \n        q.sort(key=lambda node: node.val)\n        \n        curr = q.pop()\n        while curr.next:\n            curr.next = q.pop()\n            curr = curr.next\n        return curr",
    "from heapq import *\n\ndef sort(lst):\n    \"\"\"\n    :type lst: List\n    :rtype: List\n    \"\"\"\n    heapify(lst)\n    return lst\n\ndef heapify(lst):\n    \"\"\"\n    :type lst: List\n    :rtype: List\n    \"\"\"\n    if lst is None or len(lst) < 1:\n        return\n    p = lst[0]\n    lst = lst[1:]\n    while p > 0:\n        if lst[0] < p:\n            lst[0] = lst[0] + 1\n            lst = lst[1:]\n            p = lst[0]\n        else:\n            break\n    heapify(lst)\n\ndef main():\n    lst = [3, 2, 1]\n    sort(lst)\n    print lst\n\nif __name__ == '__main__':\n    main()",
    "import heapq\n\ndef bubble_sort(lst):\n    \"\"\"\n    >>> bubble_sort([1,2,3,4,5,6,7,8,9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([3,2,1,4,5,6,7,8,9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([3,2,1,5,6,7,8,9,4])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([1,2,3,4,5,6,7,8,9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([2,1,4,3,5,6,7,8,9])\n    [2, 1, 4, 3, 5, 6, 7, 8, 9]\n    >>> bubble_sort([9,8,7,6,5,4,3,2,1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([9,8,7,6,5,4,3,2,1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([9,8,7,6,5,4,3,2,1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> bubble_sort([1,1,1,1,1,1,1,1,1])\n    [1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> bubble_sort([1,1,1,1,1,1,1,1,1])\n    [1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> bubble_sort([1,1,1,1,1,1,1,1,1])\n    [1, 1, 1, 1",
    "def heap_sort(arr):\n    heapq.heapify(arr)\n    for i in xrange(len(arr)):\n        arr[i] = heapq.heappop(arr)\n        heapq.heappush(arr, arr[i])\n    return arr\n\nif __name__ == '__main__':\n    arr = [7, 6, 5, 4, 3, 2, 1]\n    print heap_sort(arr)",
    "def sort(elements):\n    heap = [element for element in elements]\n    heapq.heapify(heap)\n    for i in range(len(elements)):\n        heapq.heappop(heap)\n        heapq.heappush(heap, elements[i])\n    return heap\n\n\nif __name__ == '__main__':\n    assert sort([-3, -2, -1, 0, 1, 2, 3]) == [-1, -2, -3, 0, 1, 2, 3]\n    assert sort([0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4]",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n\n        p = ListNode(0)\n        head = p\n        while l1 and l2:\n            if l1.val < l2.val:\n                p.next = l1\n                l1 = l1.next\n            else:\n                p.next = l2\n                l2 = l2.next\n            p = p.next\n        p.next = l1 or l2\n        return head.next",
    "from heapq import heappush, heappop\n\ndef sort_heap(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    \n    heap_arr = []\n    heap_arr.extend(arr)\n    heap_arr.sort()\n    \n    for i in range(len(arr)):\n        heappush(heap_arr, arr[i])\n    \n    for i in range(len(arr)):\n        arr[i] = heappop(heap_arr)\n        \n    \n    return",
    "def sort_heap(mylist):\n    \"\"\"\n    :type mylist: List[int]\n    :rtype: void Do not return anything, modify mylist in-place instead.\n    \"\"\"\n    if not mylist:\n        return\n\n    heapq.heapify(mylist)\n    for i in range(len(mylist)):\n        heapq.heappop(mylist)\n\n\nif __name__ == \"__main__\":\n    mylist = [4, 6, 1, 3, 2]\n    sort_heap(mylist)\n    print(mylist)",
    "from heapq import heappush, heappop\n\ndef sort(list_of_numbers):\n    \"\"\"\n    Input: list_of_numbers = [3, 1, 6, 2, 5, 7, 4]\n    Output: sorted_list = [1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    heap = []\n    for num in list_of_numbers:\n        heappush(heap, num)\n\n    for num in list_of_numbers:\n        heappop(heap)\n\n    return heap\n\nif __name__ == '__main__':\n    print sort([3, 1, 6, 2, 5, 7, 4])",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Iterative version:\n        \"\"\"\n        if not root:\n            return\n        # build a heap with the left subtree as the first element and the right subtree as the last element\n        heap = [root]\n        heap.extend(heap[:])\n        # move the left subtree to the end of the queue\n        heap.extend(heap[:])\n        # pop the root node\n        heap.pop()\n        # move the right subtree to the end of the queue\n        heap.extend(heap[:])\n        # pop the left subtree\n        heap.pop()\n        # sort the nodes\n        while heap:\n            cur = heap[0]\n            # move the current node to the end of the queue\n            heap.extend(heap[:])\n            # pop the right subtree\n            heap.pop()\n            # move the current node to the end of the queue\n            heap.extend(heap[:])\n            # pop the left subtree\n            heap.pop()\n            # update the parent node\n            cur.left = heap[0]\n            cur.right = heap[-1]\n            # update the heap with the new tree\n            heap.extend(heap[:])",
    "class Solution:\n    # @param a list of integers\n    # @return nothing\n    def heapSort(self, a):\n        heap = []\n        for i in range(len(a)):\n            heap.append(a[i])\n            while len(heap) > 1 and heap[-1] > heap[len(heap)-2]:\n                heap[-2] = heap.pop()\n                heap[-1] = heap[len(heap)-1]\n        return a\n\nif __name__ == \"__main__\":\n    s = Solution()\n    a = [10,9,8,7,6,5,4,3,2,1]\n    s.heapSort(a)\n    print a",
    "class Solution:\n    \"\"\"\n    @param nums: The integer array\n    @return: void\n    \"\"\"\n    def heapSort(self, nums):\n        # write your code here\n        heap = []\n        for i in range(len(nums)):\n            heap.append(nums[i])\n            heapify(heap, i)\n        \n        while len(heap) > 1:\n            nums[0] = heap[0]\n            nums[1] = heap[1]\n            heap[0] = heap[1]\n            heap[1] = heap[2]\n            heap[2] = heap[3]\n            heap[3] = heap[4]\n            heap[4] = heap[5]\n            heap[5] = heap[6]\n            heap[6] = heap[7]\n            heap[7] = heap[8]\n            heap[8] = heap[9]\n            heap[9] = heap[10]\n            heap[10] = heap[11]\n            heap[11] = heap[12]\n            heap[12] = heap[13]\n            heap[13] = heap[14]\n            heap[14] = heap[15]\n            heap[15] = heap[16]\n            heap[16] = heap[17]\n            heap[17] = heap[18]\n            heap[18] = heap[19]\n            heap[19] = heap[20]\n            heap[20] = heap[21]\n            heap[21] = heap[22]\n            heap[22] = heap[23]\n            heap[23] = heap[24]\n            heap[24] = heap[25]\n            heap[25] = heap[26]\n            heap[26] = heap[27]\n            heap[27] = heap[28]\n            heap[28] = heap[29]\n            heap[29] = heap[30]\n            heap[30] = heap[31]\n            heap[31] = heap[32]\n            heap[",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n\n        if not head.next:\n            return head\n\n        heap = [head]\n        while heap:\n            cur = heap.pop(0)\n            cur.next = None\n            if cur.next:\n                heap.append(cur.next)\n            cur.next = heap[0]\n            heap[0] = cur\n\n        return heap[0]\n\n\nif __name__ == \"__main__\":\n    assert Solution().sortList(ListNode(2)) == ListNode(2), \"case 1\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 2\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 3\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 4\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 5\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 6\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 7\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 8\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 9\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 10\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 11\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 12\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 13\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"case 14\"\n    assert Solution().sortList(ListNode(1)) == ListNode(1), \"",
    "class HeapQueue(object):\n\n    def __init__(self):\n        self.heap = []\n\n    def push(self, item):\n        self.heap.append(item)\n\n    def pop(self):\n        return self.heap.pop()\n\n    def peek(self):\n        return self.heap[0]\n\n    def empty(self):\n        return self.heap == []\n\n    def size(self):\n        return len(self.heap)\n\n\nclass Solution(object):\n\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = HeapQueue()\n        for n in nums:\n            heap.push(n)\n            while heap.peek() < heap.size():\n                heap.pop()\n                heap.push(heap.peek())\n        \n        for n in nums:\n            heap.push(n)\n            while heap.peek() > heap.size():\n                heap.pop()\n                heap.push(heap.peek())\n\n    def sort_heap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = HeapQueue()\n        for n in nums:\n            heap.push(n)\n            while heap.peek() > heap.size():\n                heap.pop()\n                heap.push(heap.peek())\n        \n        for n in nums:\n            heap.push(n)\n            while heap.peek() < heap.size():\n                heap.pop()\n                heap.push(heap.peek())\n\nif __name__ == \"__main__\":\n    nums = [2, 6, 1, 3, 4, 5]\n    print Solution().sort(nums)\n    print nums\n    print Solution().sort_heap(nums)\n    print nums",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if not head or not head.next:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            if slow.val < fast.val:\n                slow, fast = slow.next, fast.next\n            else:\n                slow.next, fast = fast.next, slow.next\n        slow.next = None\n        return self.sortList(head)",
    "class Solution:\n    # @param head, a list node\n    # @return nothing\n    def sortList(self, head):\n        if head is None or head.next is None:\n            return\n        \n        pivot = head\n        left = head.next\n        right = head.next.next\n        \n        while right!= None:\n            if right.data < pivot.data:\n                pivot.next = right\n                right = right.next\n                \n            else:\n                if left is None:\n                    left = right\n                else:\n                    left.next = right\n                    \n                right = right.next\n                \n        pivot.next = left\n        \n        self.sortList(left)\n        self.sortList(pivot)\n        self.sortList(right)",
    "import heapq\n\n\ndef sort_list(list_of_numbers):\n    heap = []\n    for number in list_of_numbers:\n        heapq.heappush(heap, number)\n    return heap\n\n\nif __name__ == '__main__':\n    test_list = [7, 5, 1, 3, 6, 4]\n    print(sort_list(test_list))",
    "class Solution:\n    # @param a list of integers\n    # @return nothing\n    def heapSort(self, a):\n        \"\"\"\n        :type a: List[int]\n        :rtype: void Do not return anything, modify a instead.\n        \"\"\"\n        heap = []\n        for i in range(len(a)):\n            heap.append(a[i])\n            while len(heap) > 1 and heap[0] > heap[1]:\n                heap[0], heap[1] = heap[1], heap[0]\n                heap.pop()\n            print(heap)\n        \n        \nif __name__ == \"__main__\":\n    Solution().heapSort([3,5,1,6,9])",
    "class Solution(object):\n    def merge(self, nums, lo, hi):\n        \"\"\"\n        :type nums: List[int]\n        :type lo: int\n        :type hi: int\n        :rtype: int\n        \"\"\"\n        if lo >= hi:\n            return lo\n        mid = lo + (hi - lo) / 2\n        self.merge(nums, lo, mid)\n        self.merge(nums, mid + 1, hi)\n        nums[lo], nums[mid] = nums[mid], nums[lo]\n        return lo\n\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return\n        heapify(nums, 0, n - 1)\n        while n > 1:\n            nums[0], nums[1] = nums[1], nums[0]\n            nums[n - 1], nums[n - 2] = nums[n - 2], nums[n - 1]\n            n -= 2\n            heapify(nums, 1, n - 1)",
    "from heapq import heappush, heappop, heapify\nfrom collections import deque\n\ndef heapSort(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    heapify(nums)\n    for i in range(nums[0]):\n        heappop(nums)\n        heappush(nums, i)\n    return\n\nif __name__ == '__main__':\n    print(heapSort([1,3,5,6,2,4]))\n    print(heapSort([9,3,4,5,1,6,7,8,2,3,4,5,6,7,8]))\n    print(heapSort([3,2,1,6,7,8,9,4,5,10,11]))\n    print(heapSort([2,3,5,1,4,6,7,8,9]))\n    print(heapSort([5,4,3,2,1,6,7,8,9]))\n    print(heapSort([1,3,5,6,2,4]))\n    print(heapSort([9,3,4,5,1,6,7,8,2,3,4,5,6,7,8]))\n    print(heapSort([3,2,1,6,7,8,9,4,5,10,11]))\n    print(heapSort([2,3,5,1,4,6,7,8,9]))\n    print(heapSort([5,4,3,2,1,6,7,8,9]))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        heap = []\n        p = ListNode(0)\n        p.next = head\n        heap.append(p)\n        while heap:\n            curr = heap.pop(0)\n            curr.next = None\n            if curr.next:\n                heap.append(curr.next)\n                curr.next = None\n            else:\n                return p.next\n            while curr.next:\n                if curr.next.val < curr.val:\n                    p = curr\n                    curr = curr.next\n                else:\n                    break\n            heap.append(curr)\n            curr.next = None\n        return p.next",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef sortList(self, head):\n\t\tif not head:\n\t\t\treturn head\n\n\t\t# insert into heap\n\t\theap = [head]\n\n\t\twhile len(heap) > 1:\n\t\t\theap_smaller = []\n\t\t\theap_larger = []\n\t\t\tfor i in range(len(heap) - 1):\n\t\t\t\tif heap[i].val < heap[i + 1].val:\n\t\t\t\t\theap_smaller.append(heap[i])\n\t\t\t\t\theap[i] = heap[i + 1]\n\t\t\t\telse:\n\t\t\t\t\theap_larger.append(heap[i])\n\n\t\t\tif heap_smaller:\n\t\t\t\theap[0] = heap_smaller.pop(0)\n\t\t\telse:\n\t\t\t\theap[0] = heap_larger.pop(0)\n\n\t\t\tfor i in range(len(heap) - 1):\n\t\t\t\theap[i] = heap[i + 1]\n\n\t\treturn heap[0]\n\nif __name__ == \"__main__\":\n\tsol = Solution()\n\tl1 = ListNode(5)\n\tl2 = ListNode(2)\n\tl3 = ListNode(4)\n\tl4 = ListNode(3)\n\tl5 = ListNode(1)\n\tl1.next = l2\n\tl2.next = l3\n\tl3.next = l4\n\tl4.next = l5\n\tl5.next = None\n\tprint sol.sortList(l1)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        q = []\n        p = head\n        while p:\n            q.append(p)\n            p = p.next\n        \n        head = self.make_heap(q)\n        \n        while q:\n            p = q.pop()\n            p.next = None\n            head = self.sink_heap(head, p)\n        \n        return head\n    \n    def sink_heap(self, head, p):\n        while p:\n            if not p.next:\n                return head\n            else:\n                if p.next.val > p.val:\n                    p.next, p = p.next.next, p.next\n                else:\n                    head, p = p, p.next\n                    \n        return head\n    \n    def make_heap(self, q):\n        head = ListNode(0)\n        head.next = q[0]\n        p = head\n        for i in range(len(q)):\n            p = self.sink_heap(p.next, q[i])\n        return head.next\n    \n    \nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(3)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(4)\n    \n    print(Solution().sortList(head))",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def sortList(self, root):\n        if root is None:\n            return\n\n        queue = []\n        queue.append(root)\n\n        while queue:\n            # get the first element in the queue\n            node = queue.pop(0)\n\n            # if the first element is left child, then add it to the queue and\n            # remove the node\n            if node.left:\n                queue.append(node.left)\n                node.left = None\n\n            # if the first element is right child, then add it to the queue and\n            # remove the node\n            if node.right:\n                queue.append(node.right)\n                node.right = None\n\n            # if the first element is not left or right child, then add it to\n            # the queue and remove the node\n            else:\n                # if the first element is a leaf, then remove it from the queue\n                # and add its parent to the queue\n                if node.left is None and node.right is None:\n                    queue.append(node.parent)\n                    node.parent = None\n\n                # if the first element is not a leaf, then remove it from the\n                # queue and add its parent to the queue\n                else:\n                    # remove the first element in the queue\n                    node = queue.pop(0)\n                    # if the first element is left child, then add it to the\n                    # queue and remove the node\n                    if node.left:\n                        queue.append(node.left)\n                        node.left = None\n\n                    # if the first element is right child, then add it to the\n                    # queue and remove the node\n                    if node.right:\n                        queue.append(node.right)\n                        node.right = None\n\n                    # if the first element is not left or right child, then\n                    # add it to the queue and remove the node\n                    else:\n                        # if the first element is",
    "class HeapQueue(object):\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.size = size\n        self.heap = [0] * size\n        self.heap[0] = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        self.heap[0] = x\n        heapify(0)\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.heap[0]\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.size == 1:\n            return self.heap[0]\n\n        if self.heap[0] > self.heap[1]:\n            self.heap[0], self.heap[1] = self.heap[1], self.heap[0]\n            self.heap[0] = self.heap[0] + self.heap[1]\n            self.heap[1] = self.heap[0] - self.heap[1]\n            self.heap[0] = self.heap[0] - self.heap[1]\n            heapify(0)\n        return self.heap[0]\n\n\n# Your HeapQueue object will be instantiated and called as such:\n# obj = HeapQueue(size)\n# param_1 = obj.push(x)\n# param_2 = obj.peek()\n# param_3 = obj.pop()",
    "import heapq\n\ndef sort(list):\n    for i in range(0, len(list)):\n        heapq.heappush(list, list[i])\n    return list\n\nif __name__ == '__main__':\n    assert sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert sort([1, 1]) == [1]\n    assert sort([1, 1, 1]) == [1, 1]\n    assert sort([1, 2, 3]) == [1, 2, 3]\n    assert sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert sort([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7]",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport heapq\n\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        def build_tree(head, left, right):\n            if not left and not right:\n                return None\n            if not left:\n                return TreeNode(head.val, None, right)\n            if not right:\n                return TreeNode(head.val, left, None)\n            return TreeNode(head.val, build_tree(head.next, left.left, left.right), build_tree(head.next, right.left, right.right))\n        root = build_tree(head, None, None)\n        return root\n\n\n# TESTS\nfor arr, expected in [([4,5,6,7,0,1,2,3], [0, 1, 2, 3, 4, 5, 6, 7]), ([], [])]:\n    sol = Solution()\n    actual = sol.sortedListToBST(arr)\n    print(\"Sorted list to BST:\", arr)\n    print(\"Expected:\", expected)\n    print(\"Actual:\", actual)\n    assert expected == actual",
    "class HeapQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.heap = []\n        \n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: void\n        \"\"\"\n        heapq.heappush(self.heap, x)\n        \n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        return heapq.heappop(self.heap)\n    \n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        return heapq.heappop(self.heap)\n    \n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return len(self.heap) == 0\n    \n    def is_empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return len(self.heap) == 0\n    \n    def size(self):\n        \"\"\"\n        Returns the size of the queue.\n        :rtype: int\n        \"\"\"\n        return len(self.heap)\n    \n    def sort(self):\n        \"\"\"\n        Sort the elements in the queue using heap sort.\n        :rtype: void\n        \"\"\"\n        for i in range(len(self.heap)):\n            j = i\n            while j > 0 and self.heap[j] > self.heap[j/2]:\n                self.heap[j] = self.heap[j/2]\n                j = j/2\n            self.heap[j] = self.heap[i]\n        \n    \nif __name__ == '__main__':\n    pq = HeapQueue()\n    pq.push(1)\n    pq.push(2)\n    pq.push(3)\n    pq.push(4)\n    pq.push(5",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        mid = head\n        left = head.next\n        right = head.next\n        \n        while left and right:\n            if left.val < right.val:\n                mid = mid.next\n                left = left.next\n            else:\n                right = right.next\n                \n        heapq.heappush(left, mid)\n        \n        return self.mergeSort(left)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        if head.next.next is None:\n            return head.next\n\n        list_head = head\n        list_tail = head.next\n\n        while list_tail:\n            list_tail = list_tail.next\n            list_tail.next = None\n            list_tail = list_tail.next\n\n        # Create a new head and tail, both are the same\n        list_head.next = None\n        list_tail = list_tail.next\n\n        # Sort the list\n        self.heap_sort(list_head)\n\n        # Create a new list head and tail\n        new_head = list_head\n        new_tail = list_tail.next\n\n        # Create a new list tail\n        while new_tail:\n            new_tail = new_tail.next\n            new_tail.next = None\n\n        return new_head\n\n    def heap_sort(self, head):\n        if head is None or head.next is None:\n            return head\n\n        new_head = head\n        new_tail = head\n        while new_tail.next:\n            new_tail = new_tail.next\n            new_tail.next = None\n\n            # Create a new head and tail\n            new_head = new_tail.next\n            new_tail = new_tail.next\n\n            # Sort the list\n            self.heap_sort(new_head)\n\n        return new_head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        # Create a queue\n        q = []\n        \n        # Put the head node to the queue\n        q.append(head)\n        \n        # Iterate through the rest of the nodes in the list\n        while q:\n            # Get the first node\n            node = q.pop(0)\n            \n            # If the node is the last node in the queue\n            if not q:\n                # Put the node to the end of the list\n                head.next = node\n                return head\n            \n            # If the node is not the last node in the queue\n            else:\n                # Get the next node\n                next = node.next\n                \n                # If the next node is the last node in the queue\n                if not q:\n                    # Put the next node to the end of the list\n                    node.next = None\n                    head.next = next\n                    return head\n                \n                # If the next node is not the last node in the queue\n                else:\n                    # Put the next node to the end of the list\n                    q.append(next)\n        \n        # If the queue is empty, return the head node\n        return head",
    "import collections\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heapify(nums)\n\n    def heapify(self, nums):\n        n = len(nums)\n        for i in range(n):\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < n and nums[left] < nums[i]:\n                largest = left\n            elif right < n and nums[right] < nums[i]:\n                largest = right\n            else:\n                largest = i\n            if largest!= i:\n                nums[i], nums[largest] = nums[largest], nums[i]\n                self.heapify(nums[:largest + 1])",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        # build tree\n        root = TreeNode(head.val)\n        curr = root\n        while head.next:\n            curr.left = TreeNode(head.val)\n            head = head.next\n            curr = curr.left\n        curr.right = TreeNode(head.val)\n        return self.sortedListToBST(root)",
    "from heapq import heappush, heappop\n\nclass HeapSort(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        Initialize your data structure here.\n        :type arr: List[int]\n        \"\"\"\n        self.arr = arr\n        self.n = len(arr)\n\n    def sort(self):\n        \"\"\"\n        Returns a list of integers with their original order.\n        :rtype: List[int]\n        \"\"\"\n        heap = [i for i in range(self.n)]\n        heappush(heap, self.arr[self.n-1])\n        for i in range(self.n-2, -1, -1):\n            heap[0] = self.arr[i]\n            heappush(heap, self.arr[i+1])\n            while len(heap) > 1 and self.arr[heap[0]] >= self.arr[heap[1]]:\n                heappop(heap)\n            if len(heap) > 1:\n                heappush(heap, self.arr[heap[0]])\n        return [i for i in range(self.n)]\n\n\nif __name__ == '__main__':\n    arr = [9,3,2,4,5,7,1,6,8]\n    heap = HeapSort(arr)\n    print(heap.sort())",
    "from heapq import heappush, heappop, heapify, heappushpop\n\ndef sort(list):\n    heapify(list)\n    while list:\n        heappop(list)\n        heapify(list)\n        \n    return list\n\ndef test():\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print sort(test_list)\n\nif __name__ == \"__main__\":\n    test()",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        q = []\n        p = head\n        while p:\n            q.append(p)\n            p = p.next\n        \n        p = head\n        while q:\n            p.next = q.pop(0)\n            p = p.next\n            \n        return head",
    "from heapq import heappush, heappop\n\n\nclass Solution(object):\n    def heapSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heappush(heap, nums[i])\n        for i in range(len(nums)):\n            nums[i] = heappop(heap)",
    "def sort(l):\n    heapq.heapify(l)\n    while len(l) > 1:\n        heapq.heappop(l)\n        heapq.heappush(l, l[0])\n\nif __name__ == '__main__':\n    l = [5, 4, 3, 2, 1]\n    sort(l)\n    print l",
    "# Heap Queue\n# Given a sorted array, write a function to sort it in ascending order.\n#\n# Example 1:\n# Input: [1,5,7,2,3,6,4]\n# Output: [1,2,3,4,5,6,7]\n# Explanation: 1->2, 1->3, 1->4, 2->3, 2->4, 3->4, 4->5, 5->6, 6->7\n# Example 2:\n# Input: [1,2,3,4,5,6,7]\n# Output: [1,2,3,4,5,6,7]\n# Explanation: 1->2, 1->3, 1->4, 2->3, 2->4, 3->4, 4->5, 5->6, 6->7\n# Example 3:\n# Input: [1]\n# Output: [1]\n# Explanation: 1->1\n# Note:\n# The input array is always in ascending order.\n# You may assume the array size is in the range [1,10000].\n# The input array may contain duplicates.\n\n# @param A: a list of integers\n# @return: nothing\n\n# heap sort\nclass Solution(object):\n    def sort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: void Do not return anything, modify A in-place instead.\n        \"\"\"\n        self.heapify(A)\n\n    def heapify(self, A):\n        size = len(A)\n        for i in range(size/2):\n            self.heapify_sub(A, i, size)\n\n    def heapify_sub(self, A, start, end):\n        root = start\n        left = 2 * start + 1\n        right = 2 * start + 2\n        if left < end and A[left] < A[root]:\n            root = left\n        if right < end and A[right] < A[root]:\n            root = right\n        if root!= start:\n            A[root], A[start] = A[start], A[root]\n            self.heapify_sub(A, start, root)",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        d = deque()\n        cur = head\n        while cur:\n            d.append(cur)\n            cur = cur.next\n        \n        cur = d.popleft()\n        while cur:\n            left = cur.next\n            while left and left.val <= cur.val:\n                cur.next = left.next\n                left.next = cur\n                cur = cur.next\n                left = cur.next\n            cur = d.popleft()\n        return head",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def heapify(self, node):\n        \"\"\"\n        :type node: TreeNode\n        :rtype: None Do not return anything, modify node in-place instead.\n        \"\"\"\n        if not node:\n            return\n\n        if not node.left and not node.right:\n            return\n\n        if not node.left:\n            node.left = self.maxHeapify(node.left)\n            return\n\n        if not node.right:\n            node.right = self.maxHeapify(node.right)\n            return\n\n        if node.val <= node.left.val and node.val <= node.right.val:\n            return\n\n        if node.val <= node.left.val:\n            node.left = self.maxHeapify(node.left)\n            return\n\n        if node.val <= node.right.val:\n            node.right = self.maxHeapify(node.right)\n            return\n\n\nif __name__ == '__main__':\n    tree = TreeNode(1)\n    tree.left = TreeNode(2)\n    tree.right = TreeNode(3)\n    tree.left.left = TreeNode(4)\n    tree.right.right = TreeNode(5)\n\n    s = Solution()\n    s.heapify(tree)\n\n    print tree\n    s.heapify(tree.left)\n    print tree\n    s.heapify(tree.left.left)\n    print tree",
    "def merge_sort(arr, start, end):\n    if start < end:\n        mid = (start+end)//2\n        merge_sort(arr, start, mid)\n        merge_sort(arr, mid+1, end)\n        heap_sort(arr, start, end)\n\n\ndef heap_sort(arr, start, end):\n    if start >= end:\n        return\n    mid = (start+end)//2\n    heap_sort(arr, start, mid)\n    heap_sort(arr, mid+1, end)\n    # print(arr)\n    # print(start, mid, end)\n    # print(arr[start], arr[mid], arr[end])\n    # print(heapify(arr, start, mid, end))\n    # print(arr[start], arr[mid], arr[end])\n    # print(heapify(arr, start, mid, end))\n    # print(arr[start], arr[mid], arr[end])\n\n\ndef heapify(arr, start, mid, end):\n    # print(start, mid, end)\n    while start <= mid:\n        # print(start, mid, end)\n        if start >= end:\n            break\n        if arr[start] < arr[mid]:\n            arr[mid], arr[start] = arr[start], arr[mid]\n            start += 1\n        else:\n            break\n    # print(arr)\n    return arr\n\n\ndef merge(arr, start, mid, end):\n    if start < mid or mid < end:\n        i = start\n        j = mid\n        k = start\n        while i <= mid and j <= end:\n            if arr[i] < arr[j]:\n                arr[k] = arr[i]\n                i += 1\n            else:\n                arr[k] = arr[j]\n                j += 1\n            k += 1\n        while i <= mid:\n            arr[k] = arr[i]\n            i += 1\n            k += 1\n        while j <= end:\n            arr[k] = arr[j]\n            j += 1\n            k += 1\n    # print(arr)\n    return",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # Create a new queue and store the head as the first element.\n        queue = Queue()\n        queue.push(head)\n        \n        # Iterate over the remaining elements in the list, \n        # and push them to the queue.\n        while queue.size() > 1:\n            # Get the first element from the queue.\n            first = queue.pop()\n            \n            # If the first element is the last element, \n            # then the list is already sorted.\n            if not first.next:\n                return head\n            \n            # Get the second element from the queue.\n            second = queue.pop()\n            \n            # Insert the first element into the queue.\n            queue.push(first)\n            \n            # Insert the second element into the queue.\n            queue.push(second)\n            \n        # Return the head element of the queue.\n        return queue.pop()",
    "def sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    arr.sort()\n    # Use a heap queue to store the elements.\n    heapq.heapify(arr)\n    # Use a stack to store the elements.\n    stack = []\n    for i in range(len(arr)):\n        stack.append(arr[i])\n    while len(stack) > 1:\n        # Remove the first element from the stack.\n        arr[0] = stack.pop()\n        # Use a heap queue to store the elements.\n        heapq.heappush(arr, arr[0])\n        # Add the top element to the stack.\n        stack.append(arr[0])\n        # Remove the last element from the stack.\n        arr[-1] = stack.pop()\n        # Use a heap queue to store the elements.\n        heapq.heappush(arr, arr[-1])\n    return\n\n# Test cases\narr = [1, 2, 3, 4, 5, 6]\nprint(sort(arr))\narr = [6, 5, 4, 3, 2, 1]\nprint(sort(arr))\narr = [1, 3, 5, 7, 9, 2, 4, 6, 8]\nprint(sort(arr))",
    "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sortList(self, head: TreeNode) -> TreeNode:\n        if not head:\n            return None\n        if not head.left:\n            return head\n        \n        heap = []\n        cur = head\n        while cur:\n            heapq.heappush(heap, cur)\n            cur = cur.left\n        \n        while heap:\n            cur = heapq.heappop(heap)\n            if cur.right:\n                cur.right = self.sortList(cur.right)\n            if cur.left:\n                cur.left = self.sortList(cur.left)\n            return cur\n        \n        return None",
    "def sort(arr):\n    heapify(arr)\n    for i in xrange(len(arr)-1, -1, -1):\n        heapify(arr, i)\n        arr[i], arr[0] = arr[0], arr[i]\n\n\ndef heapify(arr, i):\n    # if current element is the left child of the root\n    if i > 0 and arr[i] < arr[(i-1)//2]:\n        arr[i], arr[(i-1)//2] = arr[(i-1)//2], arr[i]\n        heapify(arr, (i-1)//2)\n\n\ndef main():\n    arr = [2, 5, 7, 9, 10, 12]\n    sort(arr)\n    print arr\n\n\nif __name__ == \"__main__\":\n    main()",
    "import collections\nfrom heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    for elem in arr:\n        heappush(heap, elem)\n    for i in range(len(arr)):\n        arr[i] = heappop(heap)\n    return arr\n\n\ndef main():\n    arr = [1, 4, 2, 3, 5, 9, 6, 7, 8, 0]\n    heap_sort(arr)\n    print(arr)\n\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        if not head.next:\n            return head\n\n        p = head\n        while p.next:\n            q = p.next\n            p.next = q.next\n            q.next = None\n            p = q\n\n        self.sortList(head)\n        return head",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport heapq\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {void} Do not return anything, modify root in-place instead.\n    def sortTree(self, root):\n        if root is None:\n            return\n        heapq.heapify(root)\n        while root:\n            if root.left and root.right:\n                if root.val > root.left.val and root.val > root.right.val:\n                    heapq.heapreplace(root, root.right)\n                    heapq.heapreplace(root, root.left)\n                elif root.val < root.left.val and root.val < root.right.val:\n                    heapq.heapreplace(root, root.left)\n                else:\n                    heapq.heapreplace(root, root.val)\n                    root = root.right\n            elif root.left:\n                heapq.heapreplace(root, root.left)\n                root = root.right\n            elif root.right:\n                heapq.heapreplace(root, root.right)\n                root = root.left\n            else:\n                break\n        heapq.heapify(root)\n\n\n# Note:\n# 1. Use heapq.heapify to build the heap\n# 2. Use heapq.heappush to insert\n# 3. Use heapq.heappop to delete\n# 4. Use heapq.heappush to insert",
    "import time\n\n\ndef heap_sort(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    lst.sort(key=lambda x: x)\n    heap_queue(lst)\n\n\ndef heap_queue(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap_queue(lst[:], 0)\n    heap_queue(lst[:], 1)\n\n\ndef main():\n    lst = [7, 1, 6, 3, 9, 4, 2, 5, 8, 0]\n    t1 = time.time()\n    heap_sort(lst)\n    t2 = time.time()\n    print(t2 - t1)\n\n\nif __name__ == '__main__':\n    main()",
    "# https://oj.leetcode.com/problems/sort-list/\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return 'null'\n        else:\n            return str(self.val)\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head is None or head.next is None:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next is not None:\n            current = prev.next\n            while current.next is not None:\n                if current.next.val < current.val:\n                    prev.next = current.next\n                else:\n                    prev.next = current\n                current = current.next\n            prev.next = current\n            prev = prev.next\n        return dummy.next\n\n# Test\nif __name__ == '__main__':\n    assert Solution().sortList(None) == None\n    assert Solution().sortList([1]) == [1]\n    assert Solution().sortList([1, 2, 3]) == [1, 2, 3]\n    assert Solution().sortList([-1, -2, -3]) == [-3, -2, -1]",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next.__repr__())\n        else:\n            return \"<empty>\"\n\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        # Create a new list which will be the head of the sorted list\n        new_head = ListNode(-1)\n        new_head.next = head\n        heap = [new_head]\n\n        # Add all elements to the heap\n        while heap:\n            curr = heap.pop(0)\n            curr.next = None\n            while curr.next:\n                curr = curr.next\n                heap.append(curr)\n                curr.next = None\n\n        # Move the elements to the original head list\n        while heap:\n            curr = heap.pop(0)\n            curr.next = head\n            head = curr\n\n        return head\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    print(sol.sortList(head))",
    "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for i in xrange(len(nums)):\n            heap.append((nums[i], i))\n            \n        while len(heap)!= 0:\n            heap.sort()\n            heap[0] = (heap[0][0], 0)\n            \n            if len(heap) > 1:\n                (heap[0][0], i) = (heap[1][0], i)\n                heap[1] = heap.pop()\n            else:\n                heap[0] = (heap[0][0], len(nums))\n                heap[1] = heap[0]\n                \n        print heap"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}