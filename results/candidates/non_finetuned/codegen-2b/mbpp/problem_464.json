{
  "problem": {
    "task_id": "MBPP/475",
    "prompt": "Write a function to sort counter by value.",
    "canonical_solution": "from collections import Counter\r\ndef sort_counter(dict1):\r\n x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter",
    "test_list": [
      "assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]",
      "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]",
      "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"
    ],
    "challenge_test_list": [],
    "problem_id": 464
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for a counter\nclass Counter:\n    def __init__(self, n):\n        \"\"\"\n        Initialize your data structure here.\n        :type n: int\n        \"\"\"\n        self.count = Counter(n)\n        self.keys = []\n    def update(self, k, v):\n        \"\"\"\n        Update the value of a counter.\n        :type k: str\n        :type v: int\n        :rtype: void\n        \"\"\"\n        if k not in self.keys:\n            self.keys.append(k)\n            self.count[k] = v\n    def getCounter(self, k):\n        \"\"\"\n        Get the value of a counter.\n        :type k: str\n        :rtype: int\n        \"\"\"\n        return self.count[k]\n    def getCount(self, k):\n        \"\"\"\n        Get the count of a counter.\n        :type k: str\n        :rtype: int\n        \"\"\"\n        return self.count.get(k, 0)\n    def reset(self):\n        \"\"\"\n        Reset the counter to 0.\n        :rtype: void\n        \"\"\"\n        self.count = Counter(0)\n    def sum(self, k):\n        \"\"\"\n        Sum of a counter.\n        :type k: str\n        :rtype: int\n        \"\"\"\n        return self.count[k] + sum(self.count.values())\n\n# Your Counter object will be instantiated and called as such:\n# obj = Counter(n)\n# obj.update(k,v)\n# param_2 = obj.getCounter(k)\n# param_3 = obj.getCount(k)\n# param_4 = obj.reset()\n# param_5 = obj.sum(k)",
    "from collections import Counter\n\nclass Solution(object):\n    def sortByCount(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = Counter(arr)\n        return sorted(cnt.items(), key=lambda x: x[1], reverse=True)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.sortByCount([2, 3, 1, 2, 4, 4, 1, 2])",
    "def counter_sort(counter):\n    \"\"\"\n    Input:\n        counter: a counter object, which is an object that has a method\n            named get(key), which returns the value of key or -1 if key is\n            not in the counter.\n    Output:\n        A sorted counter object.\n    Example:\n        >>> counter = Counter()\n        >>> counter['b'] = 3\n        >>> counter['a'] = 2\n        >>> counter_sort(counter)\n        Counter({'a': 2, 'b': 3})\n    \"\"\"\n    sorted_counter = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return Counter(sorted_counter)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Definition for a counter.\nclass Counter:\n    def __init__(self, n):\n        self.count = n\n        self.map = {}\n\n    def update(self, word):\n        if word not in self.map:\n            self.map[word] = 1\n        else:\n            self.map[word] += 1\n\n    def lookup(self, word):\n        return self.map.get(word, 0)\n\n    def set(self, word, val):\n        self.map[word] = val\n\n    def reset(self):\n        self.map.clear()\n        self.count = 0\n\nclass Solution(object):\n    def sort(self, counters):\n        \"\"\"\n        :type counters: List[Counter]\n        :rtype: List[Counter]\n        \"\"\"\n        counters.sort(key=lambda x: x.count)\n        for i in range(len(counters)):\n            counters[i].set('', 0)\n        for i in range(1, len(counters)):\n            counters[i].update('i')\n        for i in range(len(counters) - 1):\n            for j in range(i + 1, len(counters)):\n                if counters[i].lookup('i') > counters[j].lookup('i'):\n                    counters[i].set('', counters[i].count + counters[j].count)\n                    counters[i].update('i')\n                    counters[j].set('', 0)\n                    counters[j].update('i')\n        return counters",
    "class Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def counterSort(self, num):\n        if not num:\n            return num\n        if not num[0]:\n            return num\n        count = {}\n        for i in range(1, len(num)):\n            count[num[i]] = count.get(num[i], 0) + 1\n        ans = []\n        for i in range(len(num)):\n            ans.append(num[i] if count[num[i]] == 1 else num[i] + 1)\n        return ans\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.counterSort([1,2,3,4,5])\n    print s.counterSort([1,2,3,4,5,6,7,8])\n    print s.counterSort([1,2,3,4,5,6])\n    print s.counterSort([1,2,3,4,5,6,7,8,9])\n    print s.counterSort([1,2,3,4,5,6,7,8,9,10,11,12,13])\n    print s.counterSort([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sortValues(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        \n        # split into two lists\n        left = nums[:n/2]\n        right = nums[n/2:]\n        \n        # sort left list\n        self.sortValues(left)\n        \n        # merge lists\n        i = 0\n        j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[j] = left[i]\n                i += 1\n            else:\n                nums[j] = right[j]\n                j += 1\n        \n        # merge left and right lists\n        while i < len(left):\n            nums[j] = left[i]\n            i += 1\n            j += 1\n            \n        while j < len(right):\n            nums[j] = right[j]\n            j += 1",
    "import collections\nimport heapq\n\nclass Counter(collections.Counter):\n    def __init__(self, iterable=None):\n        if iterable is not None:\n            self.update(iterable)\n    def __getitem__(self, i):\n        return self.get(i, 0)\n    def __setitem__(self, i, v):\n        self.setdefault(i, 0)\n        self[i] = v\n    def update(self, iterable):\n        for i in iterable:\n            if i not in self:\n                self[i] = 0\n            self[i] += 1\n    def most_common(self, n=None):\n        if n is None:\n            n = len(self)\n        return heapq.nlargest(n, self.items(), key=lambda x: x[1])\n    def most_common_values(self, n=None):\n        return self.most_common(n)\n    def most_common_count(self, n=None):\n        return len(self.most_common(n))\n    def topk(self, k):\n        return heapq.nlargest(k, self.most_common())\n    def topk_values(self, k):\n        return self.topk(k)\n    def topk_count(self, k):\n        return len(self.topk(k))\n    def __repr__(self):\n        return \"Counter({})\".format(self.most_common())\n\n# Your Counter object will be instantiated and called as such:\n# obj = Counter(iterable)\n# param_1 = obj.most_common(n)\n# param_2 = obj.most_common_values(n)\n# param_3 = obj.most_common_count(n)\n# param_4 = obj.topk(k)\n# param_5 = obj.topk_values(k)\n# param_6 = obj.topk_count(k)",
    "from collections import Counter\n\ndef sort_counter(counter):\n    \"\"\"\n    :type counter: collections.Counter\n    :rtype: None\n    \"\"\"\n    keys = list(counter.keys())\n    keys.sort(reverse=True)\n    for key in keys:\n        counter[key] = -counter[key]\n    for key in keys:\n        counter[key] = -counter[key]\n    return counter\n\nif __name__ == '__main__':\n    counter = Counter(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    print(sort_counter(counter))\n    counter = Counter(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    print(sort_counter(counter))\n    counter = Counter(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    print(sort_counter(counter))\n    counter = Counter(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    print(sort_counter(counter))",
    "# Definition for a counter\nclass Counter:\n    def __init__(self, n):\n        self.val = n\n        self.cnt = 1\n\nclass Solution:\n    def sortByCount(self, counters):\n        \"\"\"\n        :type counters: List[Counter]\n        :rtype: List[Counter]\n        \"\"\"\n        # sort by value\n        counters.sort(key=lambda x: x.val)\n\n        # sort by count\n        counters.sort(key=lambda x: x.cnt)\n\n        return counters",
    "class Solution:\n    def sortByValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # https://discuss.leetcode.com/topic/23791/java-dp-solution-easy-to-understand\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c-simple-java-dp-solution-easy-to-understand-in-python-and-c\n        # https://discuss.leetcode.com/topic/24963/c",
    "def counter_sort(counter):\n    \"\"\"\n    :type counter: List[int]\n    :rtype: List[int]\n    \"\"\"\n    sorted_list = sorted(counter, reverse=True)\n    return sorted_list\n\nif __name__ == '__main__':\n    assert counter_sort([3,1,2,5,3,2,6]) == [3,1,2,2,3,5,6]\n    assert counter_sort([3,3,3]) == [3,3,3]\n    assert counter_sort([5,3,2,3,5,4,5,6,3,1]) == [3,2,1,3,5,5,4,5,6,3]",
    "from collections import Counter\n\ndef sort_by_value(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: List[Tuple[str, int]]\n    \"\"\"\n    sorted_counter = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counter",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: void\n    \"\"\"\n    return\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort_counter({'a': 1, 'b': 2, 'c': 3}) == {'a': 1, 'c': 3, 'b': 2}\n    assert sort_counter({'a': 1, 'b': 0, 'c': 2, 'd': 3}) == {'a': 1, 'c': 2, 'b': 0, 'd': 3}\n    assert sort_counter({'a': 2, 'b': 0, 'c': 1, 'd': 3}) == {'a': 2, 'b': 0, 'c': 1, 'd': 3}\n    assert sort_counter({'a': 2, 'b': 1, 'c': 3, 'd': 2}) == {'a': 2, 'b': 1, 'c': 3, 'd': 2}\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 4}) == {'a': 3, 'b': 2, 'c': 1, 'd': 4}\n    assert sort_counter({'a': 4, 'b': 2, 'c': 3, 'd': 1}) == {'a': 4, 'b': 2, 'c': 3, 'd': 1}",
    "from collections import Counter\n\n\nclass Solution(object):\n    def sortByCount(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnts = Counter(arr)\n        cnts.most_common(len(arr))\n        return [i[0] for i in cnts.most_common(len(arr))]",
    "from collections import Counter\n\ndef sort_by_value(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: list\n    \"\"\"\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort_by_value(Counter({2: 2, 3: 1, 1: 1})) == [('1', 2), ('2', 2), ('3', 1)]\n    assert sort_by_value(Counter({3: 1, 2: 2, 1: 3})) == [('1', 3), ('2', 2), ('3', 1)]\n    assert sort_by_value(Counter({'a': 1, 'b': 3, 'c': 2})) == [('a', 1), ('b', 3), ('c', 2)]\n    assert sort_by_value(Counter({'a': 1, 'c': 2, 'b': 3})) == [('a', 1), ('b', 3), ('c', 2)]\n    assert sort_by_value(Counter({'a': 1, 'b': 3, 'c': 2, 'd': 1})) == [('a', 1), ('b', 3), ('c', 2), ('d', 1)]\n    assert sort_by_value(Counter({'a': 1, 'b': 3, 'c': 2, 'd': 1, 'e': 1})) == [('a', 1), ('b', 3), ('c', 2), ('d', 1), ('e', 1)]",
    "import collections\n\n\ndef sort_counter_by_value(counter):\n    \"\"\"\n    :type counter: collections.Counter\n    :rtype: None\n    \"\"\"\n    for key in counter:\n        counter[key] = collections.Counter(counter[key])\n    counter_sorted = collections.OrderedDict(sorted(counter.items()))\n    for key in counter:\n        counter[key] = collections.Counter(counter_sorted[key])\n    return None",
    "from collections import Counter\nfrom itertools import tee, islice\nfrom operator import itemgetter\n\ndef sort_counter(counter):\n    \"\"\"\n    Sort a Counter by the number of occurrences of each key.\n\n    :param counter: a Counter\n    :return: a sorted Counter\n    \"\"\"\n    return Counter(islice(tee(counter.items(), 2), 0, None, 2))\n\n\ndef sort_string(string):\n    \"\"\"\n    Sort a string alphabetically.\n\n    :param string: a string\n    :return: a sorted string\n    \"\"\"\n    return string.lower()\n\ndef sort_list(list_):\n    \"\"\"\n    Sort a list by the number of occurrences of each element.\n\n    :param list_: a list\n    :return: a sorted list\n    \"\"\"\n    return sorted(list_, key=itemgetter(1), reverse=True)\n\n\ndef sort_set(set_):\n    \"\"\"\n    Sort a set by the number of occurrences of each element.\n\n    :param set_: a set\n    :return: a sorted set\n    \"\"\"\n    return sorted(set_, key=itemgetter(1), reverse=True)\n\n\ndef sort_dict(dict_):\n    \"\"\"\n    Sort a dictionary by the number of occurrences of each key.\n\n    :param dict_: a dictionary\n    :return: a sorted dictionary\n    \"\"\"\n    return dict((k, dict_[k]) for k in sorted(dict_, key=itemgetter(1), reverse=True))\n\n\nif __name__ == '__main__':\n    print(sort_counter({'a': 3, 'b': 2, 'c': 1}))\n    print(sort_string('abc'))\n    print(sort_list([1, 3, 2]))\n    print(sort_set([1, 3, 2]))\n    print(sort_dict({'a': 3, 'b': 2, 'c': 1}))",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        if len(num) <= 1:\n            return num\n        \n        # find the minimum element in num\n        min_element = min(num)\n\n        # find the smallest element in num\n        smallest_element = min(num)\n        \n        # find the largest element in num\n        largest_element = max(num)\n        \n        # reverse the smallest element\n        num.reverse()\n        \n        # reverse the largest element\n        num.reverse()\n        \n        # change the smallest element to the minimum element\n        num.reverse()\n        \n        # change the smallest element to the smallest element\n        num.reverse()\n        \n        # sort the remaining elements\n        self.sort(num)\n        \n        # return the reversed smallest element\n        return num[:1] + num[-1:]",
    "from collections import Counter\n\n\nclass Solution:\n    def counterSort(self, a):\n        \"\"\"\n        :type a: List[int]\n        :rtype: void Do not return anything, modify a in-place instead.\n        \"\"\"\n        counter = Counter(a)\n        for i in range(len(a)):\n            a[i] = counter.most_common(1)[0][0]\n\n        for i in range(len(a) - 1, -1, -1):\n            j = i\n            while j > 0 and a[j - 1] > a[j]:\n                a[j], a[j - 1] = a[j - 1], a[j]\n                j -= 1",
    "# Definition for a counter.\nclass Counter(object):\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.count = 0\n        self.value = 0\n\n    def increment(self, value):\n        \"\"\"\n        :type value: int\n        \"\"\"\n        self.count += 1\n        self.value += value\n\n    def value(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.value\n\n    def reset(self):\n        \"\"\"\n        :rtype: None\n        \"\"\"\n        self.count = 0\n        self.value = 0\n\n\nclass Solution(object):\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: Counter\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        while counter.count:\n            # find first element with value greater than the last one\n            # in the list\n            i = 0\n            while i < counter.count:\n                if counter.value(i) < counter.value(i+1):\n                    # swap\n                    counter.value(i), counter.value(i+1) = counter.value(i+1), counter.value(i)\n                else:\n                    break\n                i += 1\n\n            # if i is the last element in the list, then we have\n            # exhausted the list and we're done.\n            if i == counter.count:\n                break",
    "def sort_counter(counter):\n    \"\"\"\n    Sort a counter by the value.\n    Input:\n    counter -- a counter\n    Output:\n    sorted_counter -- sorted counter\n    \"\"\"\n    return sorted(counter, key=lambda x: x.value)\n\nif __name__ == '__main__':\n    counter = Counter([1, 2, 3, 4, 5])\n    print(sort_counter(counter))",
    "def sort_by_count(counter):\n    \"\"\"\n    :type counter: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(counter, key=lambda x: counter.count(x), reverse=True)\n\ndef sort_by_value(counter):\n    \"\"\"\n    :type counter: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(counter, reverse=True)\n\nif __name__ == \"__main__\":\n    assert sort_by_count([4, 3, 2, 1, 1]) == [1, 1, 2, 3, 4]\n    assert sort_by_value([4, 3, 2, 1, 1]) == [1, 1, 2, 3, 4]",
    "from collections import Counter\n\ndef sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: list\n    \"\"\"\n    cnt = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return [v for k, v in cnt]\n\ndef main():\n    \"\"\"\n    Sample Input\n        1\n        2\n        2\n        2\n        1\n    Sample Output\n        2\n        1\n        2\n        2\n    \"\"\"\n    counter = Counter(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\n    sort_counter(counter)\n    print(counter)\n\nif __name__ == '__main__':\n    main()",
    "from collections import Counter\n\ndef sort_by_value(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: None\n    \"\"\"\n    for key in sorted(counter.keys()):\n        counter[key] = Counter(counter[key]).most_common()[0][1]\n    return",
    "class Solution(object):\n    def counterSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def helper(nums, index):\n            if index >= len(nums):\n                return\n            # sort the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            # swap the numbers\n            #",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortByValue(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        @param root: The root of binary tree.\n        @return: The root of new binary tree.\n        \"\"\"\n        if not root:\n            return root\n        if not root.left and not root.right:\n            return root\n        if root.left:\n            root.left = self.sortByValue(root.left)\n        if root.right:\n            root.right = self.sortByValue(root.right)\n        return root\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print(Solution().sortByValue(root))",
    "from collections import Counter\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        s = '1'\n        for i in range(1, n):\n            s = self.getNext(s)\n        return s\n\n    def getNext(self, s):\n        count = Counter(s)\n        s = ''\n        for i in range(0, len(s)):\n            if count[s[i]] > 0:\n                s += str(count[s[i]])\n            else:\n                s += s[i]\n        return s\n\nif __name__ == '__main__':\n    assert Solution().countAndSay(3) == '1abcd'\n    assert Solution().countAndSay(2) == 'abcd'\n    assert Solution().countAndSay(1) == '1'\n    assert Solution().countAndSay(0) == '1'\n    assert Solution().countAndSay(1000) == '110000101000101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101110111011101",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        if len(num) <= 1:\n            return\n\n        pivot = num[0]\n        left = [i for i in num if i < pivot]\n        right = [i for i in num if i > pivot]\n\n        self.sort(left)\n        self.sort(right)\n\n        i = 0\n        j = len(num) - 1\n        while i < j:\n            if num[i] > num[j]:\n                num[i], num[j] = num[j], num[i]\n                i += 1\n            j -= 1\n        return\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.sort([1,2,3]))\n    print(sol.sort([2,3,1]))\n    print(sol.sort([1,2,3,4,5]))\n    print(sol.sort([1,2,3,4,5,6]))",
    "class Solution(object):\n    def counterSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n\n        def helper(nums, start, end):\n            if start == end:\n                return\n\n            mid = (start + end) / 2\n            nums[start], nums[mid] = nums[mid], nums[start]\n\n            helper(nums, start + 1, mid)\n            helper(nums, mid + 1, end)\n\n        helper(nums, 0, len(nums) - 1)\n\n        return\n\nif __name__ == '__main__':\n    nums = [4, 1, 2, 3]\n    nums = [1, 2, 3, 4]\n    nums = [1, 1]\n    nums = [1]\n    nums = [1]\n    nums = [1, 2, 3, 4, 5]\n    nums = [1, 2, 3, 4, 5, 6]\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    Solution().counterSort(nums)\n    print nums",
    "import collections\n\nclass Counter(collections.Counter):\n    def __init__(self, iterable=None):\n        super().__init__(iterable)\n\n    def _repr_stats(self):\n        \"\"\"\n        Return a `str` containing information about the counter's statistics.\n        \"\"\"\n        stats = collections.Counter()\n        for value in self.values():\n            stats[value] = self[value]\n        return \" \".join([\"{}={}\".format(key, value) for key, value in stats.most_common()])",
    "class Solution:\n    \"\"\"\n    @param: nums: An integer array\n    @param: k: An integer\n    @return: nothing\n    \"\"\"\n    def counterSort(self, nums, k):\n        \"\"\"\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        if k <= 0:\n            return\n\n        if k > len(nums):\n            k = len(nums)\n\n        # sort by value\n        sorted_nums = []\n        for i in range(len(nums)):\n            sorted_nums.append(nums[i])\n            for j in range(i, len(nums)):\n                if nums[j] <= nums[i]:\n                    sorted_nums[j] = nums[j] + nums[i]\n                    break\n        \n        # sort by value\n        sorted_nums.sort()\n        \n        # reverse the sorted_nums\n        for i in range(len(sorted_nums)):\n            sorted_nums[i] = sorted_nums[i] - k\n            \n        # reverse the sorted_nums\n        sorted_nums.reverse()\n        \n        # merge\n        i = 0\n        j = 0\n        while i < len(sorted_nums) and j < len(nums):\n            if sorted_nums[i] < nums[j]:\n                nums[j] = nums[j] + nums[i]\n                i += 1\n            else:\n                j += 1\n        \n        return nums\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 2, 4, 5, 6, 7]\n    k = 2\n    print(Solution().counterSort(nums, k))",
    "# Definition for a counter.\nclass Counter:\n    def __init__(self, val=0):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.count = val\n        self.dict = {}\n    def update(self, val):\n        \"\"\"\n        Update the counter to val.\n        \"\"\"\n        self.count += val - self.dict.get(val, 0)\n        self.dict[val] = self.count\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1: return \"1\"\n        \n        s = \"1\"\n        for i in range(2, n):\n            s += str(self.countAndSay(i) + self.countAndSay(i - 1))\n        return s",
    "from collections import Counter\n\n\ndef sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: list[int]\n    \"\"\"\n    sorted_counter = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return [i[0] for i in sorted_counter]\n\n\nif __name__ == '__main__':\n    counter = Counter(\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n',\n         'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\n    print(sort_counter(counter))",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not counter:\n        return []\n\n    # count how many times each number appears\n    counts = Counter(counter)\n\n    # sort the list by the number of times each number appears\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n\n    # convert the sorted list to a list of integers\n    return [i[0] for i in sorted_counts]",
    "class Solution:\n    \"\"\"\n    @param: A counter object\n    @return: A counter object\n    \"\"\"\n    def sort(self, counter):\n        # write your code here\n        res = counter.copy()\n        for i in range(1, len(res)):\n            for j in range(i):\n                if res[j] > res[j+1]:\n                    res[j], res[j+1] = res[j+1], res[j]\n        return res",
    "import collections\n\n\nclass Counter(collections.Counter):\n    \"\"\"Counter that is also sorted by value.\n\n    >>> c = Counter('aabbbcccdddeee')\n    >>> c.most_common(3)\n    [('c', 4), ('b', 3), ('a', 2)]\n    >>> c.most_common()\n    [('a', 2), ('b', 3), ('c', 4)]\n    >>> c.most_common(1)\n    [('a', 2)]\n    >>> c.most_common(1,'sorted')\n    ['sorted']\n    \"\"\"\n\n    def most_common(self, n=None, key=None):\n        \"\"\"Returns the n most common elements.\n\n        If n is None, returns all of the elements.\n\n        If key is None, returns a list of tuples containing the counts.\n\n        If key is a function, returns a list of tuples containing the counts.\n        The function is called for each element and should return a single\n        value.\n        \"\"\"\n        if n is None:\n            return list(self.most_common())\n        return super().most_common(n, key=key)",
    "class Solution(object):\n    def countSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        if not arr: return\n        n = len(arr)\n        for i in xrange(n):\n            for j in xrange(i):\n                if arr[i] < arr[j]:\n                    arr[i], arr[j] = arr[j], arr[i]\n        for i in xrange(n):\n            arr[i] = arr[i] + i\n        for i in xrange(n):\n            arr[i] = arr[i] - i\n        for i in xrange(n):\n            arr[i] = arr[i] - i\n\n\nif __name__ == \"__main__\":\n    arr = [4,3,2,1,6,0,5,7,9]\n    print arr\n    Solution().countSort(arr)\n    print arr\n    assert arr == [0,1,2,3,4,5,6,7,8]",
    "from collections import Counter\n\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return '1'\n        if n == 2:\n            return '11'\n        if n == 3:\n            return '21'\n        if n == 4:\n            return '1211'\n        if n == 5:\n            return '111221'\n        if n == 6:\n            return '2112211'\n        if n == 7:\n            return '122112211'\n        if n == 8:\n            return '11122112211'\n        if n == 9:\n            return '1211122112211'\n        if n == 10:\n            return '21122112211'\n        if n == 11:\n            return '1221122112211'\n        if n == 12:\n            return '111221122112211'\n        if n == 13:\n            return '12111221122112211'\n        if n == 14:\n            return '111221122112211122112211'\n        if n == 15:\n            return '12111221122112211122112211122112211'\n        if n == 16:\n            return '11122112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112211221112",
    "# Definition for a counter\nclass Counter:\n    def __init__(self, val=0):\n        self.val = val\n        self.count = 1\n\nclass Solution:\n    # @param a list of counter\n    # @return a list of sorted counter\n    def sort(self, a):\n        if not a:\n            return a\n\n        res = []\n        for x in a:\n            res.append(Counter(x.val))\n        res.sort(key=lambda x: x.val)\n\n        return res",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: List[int]\n    :rtype: void\n    \"\"\"\n    if not counter:\n        return\n    \n    min_value = min(counter)\n    counter.sort()\n    for i in range(len(counter) - 1):\n        if counter[i] == min_value:\n            counter[i], counter[i+1] = counter[i+1], counter[i]\n    return",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: void Do not return anything, modify counter in-place instead.\n    \"\"\"\n    counter.sort(reverse=True)\n    for i in range(1, len(counter)):\n        if counter[i-1] < counter[i]:\n            counter[i-1], counter[i] = counter[i], counter[i-1]",
    "import random\n\n# Note:\n# The counter is a list of integers.\n# The counter is initialized with random values between 0 and 1000000.\n# The function will be called 1000000 times.\n# The function should return the sorted list of counter.\n\ndef sort_counter(counter):\n    return sorted(counter)\n\ndef test():\n    counter = [random.randint(0, 1000000) for i in range(100)]\n    print(sort_counter(counter))\n\nif __name__ == '__main__':\n    test()",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        if not num:\n            return\n\n        n = len(num)\n        for i in range(1, n):\n            num[i] += num[i-1]\n        \n        for i in range(n-1, -1, -1):\n            num[i] += num[i+1]\n            num[i] -= num[i+2]\n            num[i] -= num[i+1]\n            num[i] += num[i+2]\n            \n        return\n\nif __name__ == '__main__':\n    s = Solution()\n    s.sort([3,2,1,5,6])",
    "def sort_counter(counter):\n    \"\"\"\n    >>> sort_counter([(1, 'a'), (2, 'b'), (3, 'c')])\n    [(3, 'c'), (2, 'b'), (1, 'a')]\n    >>> sort_counter([(1, 'a'), (2, 'b'), (3, 'c'), (2, 'a')])\n    [(2, 'a'), (2, 'b'), (3, 'c'), (1, 'a')]\n    >>> sort_counter([(1, 'a'), (2, 'b'), (3, 'c')])\n    [(1, 'a'), (2, 'b'), (3, 'c')]\n    \"\"\"\n    counter.sort()\n    return counter",
    "def counter_sort(counter):\n    sorted_counter = sorted(counter.items(), key=lambda kv: kv[1])\n    return sorted_counter\n\n\nclass Solution:\n    def sort_counter(self, counter):\n        \"\"\"\n        :type counter: Counter\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        return counter_sort(counter)",
    "import collections\n\n\nclass Counter(collections.Counter):\n    \"\"\"\n    A counter that can be sorted by value.\n    \"\"\"\n\n    def __init__(self, iterable=None):\n        super().__init__(iterable)\n        self.__sorted = False\n\n    def sort(self):\n        self.__sorted = True\n        super().sort()\n\n    def __lt__(self, other):\n        if not self.__sorted:\n            self.sort()\n        return super().__lt__(other)\n\n    def __le__(self, other):\n        if not self.__sorted:\n            self.sort()\n        return super().__le__(other)\n\n    def __gt__(self, other):\n        if not self.__sorted:\n            self.sort()\n        return super().__gt__(other)\n\n    def __ge__(self, other):\n        if not self.__sorted:\n            self.sort()\n        return super().__ge__(other)\n\n    def __str__(self):\n        if not self.__sorted:\n            self.sort()\n        return super().__str__()",
    "class Solution(object):\n    def sortByCount(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        counter = collections.Counter(arr)\n        arr = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n        return [x[0] for x in arr]\n\n\nif __name__ == '__main__':\n    assert Solution().sortByCount([1,2,3,4,5]) == [5, 4, 3, 2, 1]\n    assert Solution().sortByCount([1, 2, 3, 3, 2, 1]) == [1, 2, 3, 3, 2, 1]\n    assert Solution().sortByCount([1, 1, 2, 2, 3, 3]) == [1, 1, 2, 2, 3, 3]",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        def helper(arr, i, j):\n            if i == j:\n                return\n            cnt = arr[i]\n            while i < j:\n                if arr[i] < cnt:\n                    arr[i], arr[j] = arr[j], arr[i]\n                    i += 1\n                else:\n                    j -= 1\n                    arr[i] = cnt\n        \n        for i in range(len(arr)):\n            helper(arr, i, 0)\n            helper(arr, i, len(arr) - 1)",
    "def sort_by_value(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)\n\n\nif __name__ == '__main__':\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 2, 4: 2, 5: 1})) == [(5, 1), (3, 2), (2, 1), (1, 1), (1, 2)]\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 2, 6: 1})) == [(5, 2), (3, 1), (4, 1), (2, 1), (1, 1), (1, 2)]\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 2, 4: 2, 5: 1})) == [(5, 1), (3, 2), (2, 1), (1, 1), (1, 2)]\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 2, 6: 1})) == [(5, 2), (3, 1), (4, 1), (2, 1), (1, 1), (1, 2)]\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 2, 6: 1})) == [(5, 2), (3, 1), (4, 1), (2, 1), (1, 1), (1, 2)]\n    assert sort_by_value(Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 2, 6: 1})) == [(5, 2), (3, 1), (4, 1), (2, 1), (1, 1), (1, 2)]",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def sortByValue(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        if not root.left and not root.right:\n            return root\n        if not root.left:\n            root.left = self.sortByValue(root.right)\n        if not root.right:\n            root.right = self.sortByValue(root.left)\n        root.left = self.sortByValue(root.left)\n        root.right = self.sortByValue(root.right)\n        return root\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.right.right = TreeNode(7)\n    root.right.right.right.right = TreeNode(8)\n    root.right.right.right.right.right = TreeNode(9)\n    print(Solution().sortByValue(root))",
    "class Counter:\n    def __init__(self, init_value):\n        self.value = init_value\n        self.count = 1\n\n    def __repr__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __add__(self, other):\n        if self.value == other.value:\n            self.count += other.count\n        else:\n            raise TypeError('Cannot add counters with different values')\n\n    def __mul__(self, other):\n        if self.value == other.value:\n            self.count *= other.count\n        else:\n            raise TypeError('Cannot add counters with different values')\n\n    def __sub__(self, other):\n        if self.value == other.value:\n            self.count -= other.count\n        else:\n            raise TypeError('Cannot subtract counters with different values')\n\n    def __str__(self):\n        return str(self.value)\n\ndef sort_by_value(counters):\n    counters.sort()\n    for i in range(len(counters)):\n        counters[i] = Counter(counters[i])\n    for i in range(len(counters) - 1):\n        counters[i].count += counters[i + 1].count\n        counters[i].value = counters[i].value + counters[i + 1].value\n    return counters\n\nif __name__ == '__main__':\n    counters = [Counter(i) for i in range(100)]\n    print(sort_by_value(counters))",
    "import collections\n\ndef count_sort(my_list):\n    \"\"\"\n    >>> my_list = [2, 1, 4, 3, 5, 7, 6]\n    >>> count_sort(my_list)\n    [1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    counter = collections.Counter(my_list)\n    return [counter[key] for key in sorted(counter.keys())]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "import collections\n\n\nclass Solution(object):\n\n    def countSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        # nums = sorted(nums, key=lambda x: x)\n        # nums.reverse()\n        return len(nums)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 1, 6, 4, 5]\n    Solution().countSort(nums)",
    "from typing import List\n\n\nclass Solution:\n    def sortByValue(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(reverse=True)\n\n\n# TESTS\nfor nums, expected in [\n    ([1, 2, 3], [1, 3, 2]),\n    ([3, 2, 1], [1, 2, 3]),\n    ([3, 1, 2], [1, 2, 3]),\n    ([3, 1, 1], [1, 1, 3]),\n]:\n    sol = Solution()\n    sol.sortByValue(nums)\n    print(\"Sort by value\", nums, \"->\", nums)\n    assert nums == expected",
    "class Solution:\n    \"\"\"\n    @param: A counter\n    @return: A counter\n    \"\"\"\n    def sortByCount(self, counter):\n        \"\"\"\n        :type counter: Counter\n        :rtype: Counter\n        \"\"\"\n        counter.sort(key=lambda x: x.value)\n        return counter\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.sortByCount(param_1)",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        # count each value\n        counts = {}\n        for v in arr:\n            if v not in counts:\n                counts[v] = 0\n            counts[v] += 1\n        # count each key\n        keys = counts.keys()\n        keys.sort()\n        # sort by value\n        for k in keys:\n            arr[counts[k] - 1] = k\n            counts[k] = 0\n        # sort by key\n        keys.sort()\n        # print arr\n        # print counts\n        return",
    "class Solution(object):\n    def sortCounter(self, counters):\n        \"\"\"\n        :type counters: List[Counter]\n        :rtype: void Do not return anything, modify counters in-place instead.\n        \"\"\"\n        counters.sort(key=lambda x: x.value)",
    "class Solution:\n    # @param a, a list of integer\n    # @return nothing\n    def sort(self, a):\n        \"\"\"\n        Do not return anything, modify a in-place instead.\n        \"\"\"\n        if not a: return\n        \n        for i in range(len(a) - 1):\n            if a[i] > a[i+1]:\n                a[i], a[i+1] = a[i+1], a[i]\n        return\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Solution().sort(a)\n    print a",
    "class Solution(object):\n    def sortByCount(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        arr.sort(key=lambda x: -arr.count(x))\n\nif __name__ == '__main__':\n    s = Solution()\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    s.sortByCount(a)\n    print a\n    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def sortByValue(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        stack = []\n        stack.append(root)\n\n        while stack:\n            curr = stack.pop()\n            if curr.left:\n                stack.append(curr.left)\n            if curr.right:\n                stack.append(curr.right)\n            curr.left, curr.right = curr, None\n            curr.val = curr.val * 10 + curr.left.val\n            curr.left.val = curr.left.val * 10 + curr.left.left.val\n            curr.left.left.val = curr.left.left.val * 10 + curr.left.left.left.val\n            curr.left.right.val = curr.left.right.val * 10 + curr.left.right.left.val\n            curr.left.right.right.val = curr.left.right.right.val * 10 + curr.left.right.right.left.val\n            curr.left.right.right.right.val = curr.left.right.right.right.val * 10 + curr.left.right.right.right.left.val\n            curr.left.right.right.right.right.val = curr.left.right.right.right.right.val * 10 + curr.left.right.right.right.right.left.val\n            curr.left.right.right.right.right.right.val = curr.left.right.right.right.right.right.val * 10 + curr.left.right.right.right.right.right.left.val\n            curr.left.right.right.right.right.right.right.val = curr.left.",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        # Time:  O(n^2)\n        # Space: O(n^2)\n        # https://leetcode.com/problems/sort-a-counter/\n        # \u5bf9\u4e8e\u7b54\u6848\u4e3a1\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a2\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a3\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a4\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a5\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a6\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\u6570\u91cf\u4e2d\uff0c\n        # \u5982\u679c\u7b54\u6848\u4e3a7\u7684\u4e2a\u6570\uff0c\u9700\u8981\u628a\u6392\u5e8f\u7684\u6570\u91cf\u653e\u5230\u539f\u6765\u7684\ufffd",
    "def count_sort(counter):\n    \"\"\"\n    Input: a counter with integer values.\n    Output: a counter with integer values.\n    \"\"\"\n    res = []\n    for i in range(len(counter)):\n        for j in range(len(counter)):\n            if j == i:\n                continue\n            if counter[i] > counter[j]:\n                res.append(counter[i])\n                counter[i] = counter[j]\n                counter[j] = res[-1]\n    return counter\n\ndef count_sort_2(counter):\n    \"\"\"\n    Input: a counter with integer values.\n    Output: a counter with integer values.\n    \"\"\"\n    res = []\n    for i in range(len(counter)):\n        res.append(counter[i])\n        for j in range(len(counter)):\n            if j == i:\n                continue\n            if counter[i] > counter[j]:\n                counter[i] = counter[j]\n                counter[j] = res[-1]\n    return counter\n\ndef count_sort_3(counter):\n    \"\"\"\n    Input: a counter with integer values.\n    Output: a counter with integer values.\n    \"\"\"\n    res = []\n    for i in range(len(counter)):\n        res.append(counter[i])\n        for j in range(len(counter)):\n            if j == i:\n                continue\n            if counter[i] > counter[j]:\n                res[i] = counter[j]\n                counter[i] = counter[j]\n                counter[j] = res[-1]\n    return counter\n\ndef count_sort_4(counter):\n    \"\"\"\n    Input: a counter with integer values.\n    Output: a counter with integer values.\n    \"\"\"\n    res = []\n    for i in range(len(counter)):\n        res.append(counter[i])\n        for j in range(len(counter)):\n            if j == i:\n                continue\n            if counter[i] > counter[j]:\n                res[i] = counter[j]\n                counter[i] = counter[j]\n                counter[j] = res[",
    "import collections\nclass Solution(object):\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # Counter is sorted by value\n        # sort by value\n        def mysort(lst):\n            return sorted(lst, key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        counter.sort(key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        mysort(counter)\n\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # Counter is sorted by value\n        # sort by value\n        counter.sort(key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        mysort(counter)\n\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # Counter is sorted by value\n        # sort by value\n        counter.sort(key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        mysort(counter)\n\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # Counter is sorted by value\n        # sort by value\n        counter.sort(key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        mysort(counter)\n\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # Counter is sorted by value\n        # sort by value\n        counter.sort(key=lambda x: x[1], reverse=True)\n\n        # sort by value\n        mysort(counter)\n\nif __name__ == '__main__':",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def sort(self, num):\n        self.sorting(num)\n        self.sort_reverse(num)\n\n    def sorting(self, num):\n        num.sort()\n\n    def sort_reverse(self, num):\n        num.reverse()\n\nif __name__ == '__main__':\n    s = Solution()\n    s.sort([1,3,2,5,4,2])",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        n = len(arr)\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                if arr[j] < arr[i]:\n                    arr[i], arr[j] = arr[j], arr[i]",
    "from collections import Counter\n\n\ndef sort_counter(counter):\n    \"\"\"\n    :type counter: collections.Counter\n    :rtype: collections.Counter\n    \"\"\"\n    return Counter(sorted(counter.items()))",
    "import random\n\nclass Counter(object):\n    def __init__(self, nums):\n        self.nums = nums\n\n    def __repr__(self):\n        return repr(self.nums)\n\n    def __str__(self):\n        return str(self.nums)\n\n    def __iter__(self):\n        for num in self.nums:\n            yield num\n\n    def sort(self):\n        self.nums.sort()\n\n    def update(self, num):\n        self.nums.append(num)\n\n    def __eq__(self, other):\n        return self.nums == other.nums\n\n    def __ne__(self, other):\n        return self.nums!= other.nums\n\ndef test_sort_by_value():\n    c = Counter([0, 1, 3, 2, 1, 2, 0, 3])\n    c.sort()\n    assert(c.nums == [0, 1, 1, 2, 2, 3, 3, 0])\n\ndef test_sort_by_value_random():\n    c = Counter([0, 1, 3, 2, 1, 2, 0, 3])\n    random.shuffle(c.nums)\n    c.sort()\n    assert(c.nums == [0, 1, 1, 2, 2, 3, 3, 0])\n\nif __name__ == '__main__':\n    test_sort_by_value()\n    test_sort_by_value_random()",
    "class Solution:\n    def countSort(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def helper(arr, low, high):\n            if low == high:\n                return arr[low]\n            mid = (low + high) // 2\n            if arr[mid] > arr[high]:\n                low, high = high, low\n            if arr[low] > arr[mid]:\n                arr[mid], arr[low] = arr[low], arr[mid]\n            if arr[low] > arr[high]:\n                arr[low], arr[high] = arr[high], arr[low]\n            return helper(arr, low + 1, high)\n        \n        return helper(arr, 0, len(arr) - 1)",
    "class Solution:\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        def swap(a, b):\n            temp = a\n            a = b\n            b = temp\n\n        def bubble(a, b):\n            while a < b:\n                while a < b and counter[a] < counter[b]:\n                    b = b - 1\n                if a < b:\n                    counter[a], counter[b] = counter[b], counter[a]\n                    a = a + 1\n\n        def partition(a, b):\n            if a == b:\n                return a\n\n            pivot = a\n            while a < b:\n                while a < b and counter[a] < counter[pivot]:\n                    a = a + 1\n                if a < b:\n                    counter[a], counter[pivot] = counter[pivot], counter[a]\n                    pivot = pivot + 1\n            counter[pivot], counter[a] = counter[a], counter[pivot]\n            swap(pivot, a)\n            return a\n\n        for i in range(len(counter)):\n            if i == 0:\n                return\n            else:\n                a = i\n                b = i - 1\n                if counter[a] > counter[b]:\n                    counter[a], counter[b] = counter[b], counter[a]\n                    a, b = a - 1, b + 1\n                    if a < 0:\n                        break\n                    swap(a, b)\n                else:\n                    continue\n                while a < b:\n                    a = a + 1\n                    if counter[a] > counter[b]:\n                        counter[a], counter[b] = counter[b], counter[a]\n                        a, b = a - 1, b + 1\n                        if a < 0:\n                            break\n                    else:\n                        continue\n                swap(a, b)\n                bubble(a, b)\n\n\nif __name__ == \"__main__\":\n    counter = [3, 2, 1, 4, 2, 3]\n    Solution().sortCounter(counter)",
    "from collections import Counter\n\ndef sort_counter(counter):\n    return sorted(counter.items(), key=lambda x: x[1])\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([1, 2, 3, 4], [4, 3, 2, 1]),\n        ([1, 2, 2, 1], [1, 2, 2, 1]),\n        ([1, 1, 2, 2], [1, 1, 2, 2]),\n    ]\n    for test_case in test_cases:\n        assert sort_counter(*test_case) == sort_counter(*test_case)",
    "class Solution(object):\n    def sortCount(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(len(arr)):\n            result.append(arr[i])\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    result[i], result[j] = result[j], result[i]\n        return result\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.sortCount([1, 3, 2, 5, 4])",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sortByCount(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return\n\n        # Find the median of the first n/2 elements.\n        mid = n / 2\n        if n % 2 == 1:\n            # if n is odd, median is the first element.\n            # if n is even, median is the second element.\n            median = nums[mid - 1]\n        else:\n            # if n is even, median is the second element.\n            # if n is odd, median is the first element.\n            median = nums[mid]\n\n        # Partition the array into two sub-arrays.\n        i = 0\n        j = mid\n        while i < j:\n            # Partition the array into two sub-arrays.\n            while i < j and nums[i] < median:\n                i += 1\n            while i < j and nums[j] > median:\n                j -= 1\n            if i >= j:\n                break\n            # Exchange the elements of the two sub-arrays.\n            nums[i], nums[j] = nums[j], nums[i]\n            # Change the index of the elements in the sub-array.\n            i += 1\n            j -= 1\n\n        # Sort the two sub-arrays.\n        self.sortByCount(nums[:mid])\n        self.sortByCount(nums[mid:])\n\n    def sortByCount_recursive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        self.sortByCount_recursive(nums[1:])\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] < nums[j]:\n                nums[i], nums[j] = nums[j], nums[",
    "# Definition for a counter.\nclass Counter:\n    def __init__(self, counter):\n        self.counter = counter\n\n    def __repr__(self):\n        return repr(self.counter)\n\n    def __eq__(self, other):\n        return self.counter == other.counter\n\nclass Solution:\n    def sortCounter(self, counter: Counter) -> Counter:\n        \"\"\"\n        :type counter: Counter\n        :rtype: Counter\n        \"\"\"\n        self.counter = Counter(counter)\n        self.counter.counter[0] = 0\n        self.counter.counter[1] = 0\n        self.counter.counter[2] = 0\n        self.counter.counter[3] = 0\n        self.counter.counter[4] = 0\n        self.counter.counter[5] = 0\n        self.counter.counter[6] = 0\n        self.counter.counter[7] = 0\n        self.counter.counter[8] = 0\n        self.counter.counter[9] = 0\n\n        self.merge(self.counter)\n\n        return self.counter\n\n    def merge(self, counter: Counter):\n        self.counter.counter[0] += counter.counter[0]\n        self.counter.counter[1] += counter.counter[1]\n        self.counter.counter[2] += counter.counter[2]\n        self.counter.counter[3] += counter.counter[3]\n        self.counter.counter[4] += counter.counter[4]\n        self.counter.counter[5] += counter.counter[5]\n        self.counter.counter[6] += counter.counter[6]\n        self.counter.counter[7] += counter.counter[7]\n        self.counter.counter[8] += counter.counter[8]\n        self.counter.counter[9] += counter.counter[9]\n\n        for i in range(0, 10):\n            if self.counter.counter[i] > self.counter.counter[self.counter.counter.index(self.counter.counter[i])]:\n                self.counter.counter[self.counter.counter.index(self.counter.counter[i])] = self.counter",
    "class Solution(object):\n    def countSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.arr = arr\n        self.cnt = [0] * len(arr)\n        self.sorted = False\n        self.sort(0, len(arr) - 1)\n        return self.arr\n\n    def sort(self, start, end):\n        if start == end:\n            return\n        mid = start + (end - start) / 2\n        self.sort(start, mid)\n        self.sort(mid + 1, end)\n        if self.cnt[mid] < self.cnt[end]:\n            self.arr[mid], self.arr[end] = self.arr[end], self.arr[mid]\n            self.cnt[mid], self.cnt[end] = self.cnt[end], self.cnt[mid]\n        else:\n            tmp = self.arr[mid]\n            self.arr[mid] = self.arr[end]\n            self.arr[end] = tmp\n            tmp = self.cnt[mid]\n            self.cnt[mid] = self.cnt[end]\n            self.cnt[end] = tmp\n        self.sort(start, mid - 1)\n        self.sort(mid + 1, end)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 2, 1, 3, 2, 4, 5]\n    sol = Solution()\n    print(sol.countSort(arr))",
    "# Definition for a counter.\nclass Counter:\n    def __init__(self, n):\n        self.n = n\n        self.d = defaultdict(int)\n    def increment(self, key):\n        self.d[key] += 1\n    def value(self):\n        return sum(self.d.values())\n\nclass Solution:\n    def counterSort(self, counter):\n        \"\"\"\n        :type counter: Counter\n        :rtype: List[int]\n        \"\"\"\n        # sort by value\n        # sort by count\n        # sort by key\n        # sort by value, then count, then key\n        # sort by value, then key, then count\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by key, then value, then count\n        # sort by key, then value, then count\n        # sort by value, then count, then key\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by count, then value, then key\n        # sort by value, then count, then key\n        # sort by count, then value, then key\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then value, then key\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then value, then key\n        # sort by value, then count, then key\n        # sort by count, then value, then key\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then key, then value\n        # sort by value, then count, then key\n        # sort by count, then value, then key\n        # sort by value, then count, then key\n        # sort by count,",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: collections.Counter\n    :rtype: collections.Counter\n    \"\"\"\n    counter.sort(reverse=True)\n    return counter\n\nif __name__ == '__main__':\n    counter = Counter({'a': 2, 'b': 1, 'c': 2})\n    print(sort_counter(counter))",
    "def counter_sort(counter):\n    \"\"\"\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2}, {'a': 2, 'b': 3, 'c': 2, 'd': 1, 'e': 2}]\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1}, {'a': 2, 'b': 3, 'c': 2, 'd': 1}]\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2}, {'a': 2, 'b': 3, 'c': 2, 'd': 1, 'e': 2}]\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1}, {'a': 2, 'b': 3, 'c': 2, 'd': 1}]\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1, 'e': 2}, {'a': 2, 'b': 3, 'c': 2, 'd': 1, 'e': 2}]\n    >>> counter_sort({'a': 5, 'b': 3, 'c': 2, 'd': 1})\n    [{'a': 5, 'b': 3, 'c': 2, 'd': 1}, {'a': 2, 'b': 3, 'c': 2, 'd': 1}]\n    >>> counter_sort({'a': 5, 'b': 3, '",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: None\n    \"\"\"\n    counter.sort(key=lambda x: x.value)\n\n\ndef sort_counter_reverse(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: None\n    \"\"\"\n    counter.sort(reverse=True)",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        def _sort(arr, low, high):\n            if low >= high:\n                return\n            mid = low + (high - low) / 2\n            _sort(arr, low, mid)\n            _sort(arr, mid + 1, high)\n            arr[low], arr[mid] = arr[mid], arr[low]\n            arr[mid + 1], arr[high] = arr[high], arr[mid + 1]\n            _sort(arr, low, mid)\n            _sort(arr, mid + 1, high)\n\n        _sort(arr, 0, len(arr) - 1)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    s.counterSort([1, 5, 4, 2, 3])\n    print(s.counterSort([1, 5, 4, 2, 3]))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify root in-place instead.\n    def sortByValue(self, root, nums):\n        if root is None:\n            return\n        if root.left is None and root.right is None:\n            return\n        if root.left is not None and root.right is not None:\n            self.sortByValue(root.left, nums)\n            self.sortByValue(root.right, nums)\n            root.left = self.merge(nums, root.val, root.left)\n            root.right = self.merge(nums, root.val, root.right)\n        elif root.left is not None:\n            root.left = self.merge(nums, root.val, root.left)\n        elif root.right is not None:\n            root.right = self.merge(nums, root.val, root.right)\n\ndef merge(nums, val, root):\n    if root is None:\n        return root\n    if root.val < val:\n        root.left = merge(nums, val, root.left)\n    elif root.val > val:\n        root.right = merge(nums, val, root.right)\n    else:\n        root.left = merge(nums, val, root.left)\n        root.right = merge(nums, val, root.right)\n    return root\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.",
    "class Counter:\n    def __init__(self, nums):\n        self.nums = nums\n        self.counts = {}\n        for n in nums:\n            if n in self.counts:\n                self.counts[n] += 1\n            else:\n                self.counts[n] = 1\n    def update(self, val):\n        self.counts[val] += 1\n\n    def get(self, val):\n        return self.counts[val]\n\nclass Solution:\n    # @param nums, a list of integer\n    # @return a list of integer\n    def sortCount(self, nums):\n        if len(nums) == 0:\n            return []\n        cnt = Counter(nums)\n        cnt.update(-1)\n        return sorted(nums, key=cnt.get, reverse=True)\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,1,3,3,3]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,3,2,5,4]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))\n    nums = [1,2,3,4,5]\n    print(sol.sortCount(nums))",
    "from collections import Counter\n\ndef sort_counter(counter):\n    for key, value in sorted(counter.items(), key=lambda x: x[1], reverse=True):\n        print(key, value)\n\nif __name__ == '__main__':\n    counter = Counter(['a', 'b', 'c', 'd', 'e'])\n    sort_counter(counter)",
    "def sort_counter(counter):\n    \"\"\"\n    :type counter: dict\n    :rtype: None\n    \"\"\"\n    # Sort by value\n    counter_sorted = sorted(counter, key=lambda k: counter[k])\n    # Sort by key\n    counter_sorted_reverse = sorted(counter, key=lambda k: counter[k], reverse=True)\n    # Combine\n    return sorted(counter_sorted) + sorted(counter_sorted_reverse)\n\n\ndef main():\n    \"\"\"\n    >>> counter = {'a': 3, 'b': 1, 'c': 4, 'd': 2}\n    >>> sort_counter(counter)\n    ['a', 'b', 'c', 'd']\n    \"\"\"\n    counter = {'a': 3, 'b': 1, 'c': 4, 'd': 2}\n    print(sort_counter(counter))\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        \n        for i in range(len(nums)):\n            nums[i] = nums[i] * 10\n            \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        \n        for i in range(len(nums)):\n            nums[i] = nums[i] / 10\n            \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        \n        for i in range(len(nums)):\n            nums[i] = nums[i] % 10\n            \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        \n        for i in range(len(nums)):\n            nums[i] = nums[i] * 10\n            \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        for i in range(len(arr)):\n            for j in range(i):\n                if arr[j] > arr[i]:\n                    arr[j], arr[i] = arr[i], arr[j]",
    "class Counter(object):\n    def __init__(self, value, count):\n        self.value = value\n        self.count = count\n\n    def __cmp__(self, other):\n        if self.value < other.value:\n            return -1\n        elif self.value == other.value:\n            return 0\n        else:\n            return 1\n\n\nclass Solution(object):\n    def countSmaller(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n        sorted_arr = sorted(arr)\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if sorted_arr[i] > sorted_arr[j]:\n                    sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i]\n        return sum(1 for x in sorted_arr if x < arr[0])",
    "class Solution(object):\n    def sortCounter(self, counter):\n        \"\"\"\n        :type counter: List[int]\n        :rtype: void Do not return anything, modify counter in-place instead.\n        \"\"\"\n        # TODO: sort by value\n        pass",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    \"\"\"\n    @param: root: The root of binary tree\n    @return: return a tree node\n    \"\"\"\n    def sortBy(self, root: TreeNode) -> TreeNode:\n        if not root: return root\n        \n        if root.left:\n            root.left = self.sortBy(root.left)\n        if root.right:\n            root.right = self.sortBy(root.right)\n        \n        return root",
    "from typing import List\n\nclass Solution:\n    def sortCounter(self, counter: List[int]) -> List[int]:\n        \"\"\"\n        :type counter: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not counter or len(counter) == 1:\n            return counter\n        return self.sortCounter_helper(counter, 0, len(counter) - 1)\n\n    def sortCounter_helper(self, counter, start, end):\n        if start == end:\n            return counter\n        mid = start + (end - start) / 2\n        left = self.sortCounter_helper(counter, start, mid)\n        right = self.sortCounter_helper(counter, mid + 1, end)\n        return self.merge(left, right)\n\n    def merge(self, left: List[int], right: List[int]) -> List[int]:\n        res = []\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                res[k] = left[i]\n                i += 1\n            else:\n                res[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            res[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            res[k] = right[j]\n            j += 1\n            k += 1\n        return res",
    "from collections import Counter\n\ndef sort_counter(counter):\n    \"\"\"\n    :type counter: Counter\n    :rtype: Counter\n    \"\"\"\n    counter_copy = dict(counter)\n    counter_copy.sort(key=lambda x: x[1], reverse=True)\n    return Counter(counter_copy)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def sortByValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: nothing\n        \"\"\"\n        self.sorting(root)\n        return\n\n    def sorting(self, node):\n        if not node:\n            return\n        if not node.left and not node.right:\n            return node.val\n        if not node.left:\n            return self.sorting(node.right)\n        if not node.right:\n            return self.sorting(node.left)\n        if node.left.val <= node.right.val:\n            self.sorting(node.left)\n            self.sorting(node.right)\n        else:\n            self.sorting(node.right)\n            self.sorting(node.left)\n        return",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sortCounter(self, nums, target):\n        n = len(nums)\n        for i in range(n):\n            nums[i] -= target\n            while nums[i] < 0:\n                nums[i] += 100\n                nums[i] -= target\n        for i in range(n):\n            nums[i] += target\n\n    def sortCounter2(self, nums, target):\n        n = len(nums)\n        for i in range(n):\n            while nums[i] > target:\n                nums[i] -= 100\n                nums[i] += target",
    "class Solution:\n    \"\"\"\n    @param nums: A list of integer\n    @return: The sorted list\n    \"\"\"\n    def sortCounter(self, nums):\n        # write your code here\n        n = len(nums)\n        if n <= 1:\n            return nums\n        d = {}\n        for i in xrange(n):\n            d[nums[i]] = i\n        # print d\n        nums = [0] * n\n        for i in xrange(n):\n            nums[d[i]] = i\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                if nums[j] < nums[i]:\n                    nums[j], nums[i] = nums[i], nums[j]\n        # print nums\n        return nums\n\n# test\nnums = [1, 2, 3, 1]\ns = Solution()\nnums = s.sortCounter(nums)\nprint nums",
    "class Solution(object):\n    def counterSort(self, counters):\n        \"\"\"\n        :type counters: List[int]\n        :rtype: void Do not return anything, modify counters in-place instead.\n        \"\"\"\n        # TODO: Write an O(n^2) solution.\n        # TODO: Implement a binary search.\n        \n        # sort the counters in descending order\n        counters.sort(reverse=True)\n        \n        # for each counter\n        for i in range(len(counters)):\n            # for each counter in the next counter\n            for j in range(i+1, len(counters)):\n                # if the current counter is greater than the next counter\n                if counters[i] > counters[j]:\n                    # swap the two counters\n                    counters[i], counters[j] = counters[j], counters[i]",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        \n        l = 0\n        r = n - 1\n        \n        while l < r:\n            while l < r and nums[l] < nums[r]:\n                l += 1\n            while l < r and nums[r] < nums[l]:\n                r -= 1\n            nums[l], nums[r] = nums[r], nums[l]\n            \n            while l < r and nums[l] <= nums[r]:\n                l += 1\n            while l < r and nums[r] <= nums[l]:\n                r -= 1\n            \n            nums[l], nums[r] = nums[r], nums[l]\n            \n            while l < r and nums[l] <= nums[r]:\n                l += 1\n            while l < r and nums[r] <= nums[l]:\n                r -= 1\n            \n            nums[l], nums[r] = nums[r], nums[l]\n            \n            while l < r and nums[l] > nums[r]:\n                l += 1\n            while l < r and nums[r] > nums[l]:\n                r -= 1\n            \n            nums[l], nums[r] = nums[r], nums[l]\n        \n        return",
    "class Solution(object):\n    def counterSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void Do not return anything, modify arr in-place instead.\n        \"\"\"\n        l = len(arr)\n        if l <= 1:\n            return\n        \n        def helper(a, b):\n            if arr[a] < arr[b]:\n                return 1\n            if arr[a] > arr[b]:\n                return -1\n            return 0\n        \n        def helper_reverse(a, b):\n            if arr[a] > arr[b]:\n                return 1\n            if arr[a] < arr[b]:\n                return -1\n            return 0\n        \n        for i in range(l):\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            else:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            \n        for i in range(l):\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            else:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                \n        for i in range(l):\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            else:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                \n        for i in range(l):\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            else:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                \n        for i in range(l):\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr",
    "class Solution:\n    \"\"\"\n    @param: arr: The integer array\n    @return: void\n    \"\"\"\n    def sort(self, arr):\n        if not arr:\n            return\n        n = len(arr)\n        for i in xrange(n):\n            for j in xrange(i, n):\n                if arr[i] > arr[j]:\n                    arr[i], arr[j] = arr[j], arr[i]\n                    \n        for i in xrange(n):\n            self.sort(arr[i*2:i*2+2])\n            \n        \n        \nif __name__ == '__main__':\n    arr = [4,1,2,3,1,5,2,3,4]\n    s = Solution()\n    s.sort(arr)\n    print arr",
    "class Counter:\n    def __init__(self, x):\n        self.x = x\n\n    def __str__(self):\n        return str(self.x)\n\n    def __repr__(self):\n        return str(self.x)\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __ne__(self, other):\n        return self.x!= other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __le__(self, other):\n        return self.x <= other.x\n\n    def __ge__(self, other):\n        return self.x >= other.x\n\n    def __add__(self, other):\n        return self.x + other.x\n\n    def __sub__(self, other):\n        return self.x - other.x\n\n    def __mul__(self, other):\n        return self.x * other.x\n\n    def __div__(self, other):\n        return self.x / other.x\n\n    def __neg__(self):\n        return -self.x\n\ndef sort_counter(counter):\n    \"\"\"\n    Sort counter by value.\n    \"\"\"\n    return sorted(counter, key=lambda x: x.x)\n\ndef print_counter(counter):\n    \"\"\"\n    Print counter.\n    \"\"\"\n    for i in counter:\n        print(i)\n\nif __name__ == '__main__':\n    counter = [Counter(x) for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]\n    print_counter(counter)\n    sort_counter(counter)\n    print_counter(counter)",
    "from collections import Counter\n\ndef sort_counter(counter):\n    return sorted(counter.items(), key=lambda x: x[1])\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort_counter({'a': 1, 'b': 2, 'c': 1}) == [('c', 1), ('a', 1), ('b', 2)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1}) == [('b', 2), ('c', 1), ('a', 3)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 1}) == [('d', 1), ('b', 2), ('c', 1), ('a', 3)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 1, 'e': 1}) == [('e', 1), ('d', 1), ('c', 1), ('b', 2), ('a', 3)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 1, 'e': 1, 'f': 1}) == [('f', 1), ('e', 1), ('d', 1), ('c', 1), ('b', 2), ('a', 3)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1}) == [('g', 1), ('f', 1), ('e', 1), ('d', 1), ('c', 1), ('b', 2), ('a', 3)], \"sort by value\"\n    assert sort_counter({'a': 3, 'b': 2, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1}) == [('h', 1), ('g', 1), ('f', 1), ('e', 1), ('d', 1), ('c',",
    "class Solution(object):\n    def counter(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * n\n        for i in range(1, n + 1):\n            result[i] = result[i - 1] + 1\n        while k > 0:\n            k -= result[k]\n            result[k] = result[k] + 1\n        return result[:n]\n\n\nif __name__ == '__main__':\n    assert Solution().counter(3, 4) == [1, 2, 3, 4]\n    assert Solution().counter(4, 4) == [1, 1, 1, 1]"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}