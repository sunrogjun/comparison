{
  "problem": {
    "task_id": "MBPP/124",
    "prompt": "Write a function to get the angle of a complex number.",
    "canonical_solution": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle",
    "test_list": [
      "assert angle_complex(0,1j)==1.5707963267948966 ",
      "assert angle_complex(2,1j)==0.4636476090008061",
      "assert angle_complex(0,2j)==1.5707963267948966"
    ],
    "challenge_test_list": [],
    "problem_id": 113
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from math import pi\n\ndef get_angle(z):\n    \"\"\"\n    z: complex number\n    returns: the angle of z in the range of 0 to 2*pi\n    \"\"\"\n    return 2*pi*z.imag/abs(z)\n\nif __name__ == '__main__':\n    z = 1+2j\n    print(get_angle(z))\n    z = -1+2j\n    print(get_angle(z))",
    "import math\n\n# Returns the angle in radians\ndef get_angle(z):\n    return math.atan2(z.imag, z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg(z):\n    return math.degrees(get_angle(z))\n\n# Returns the angle in radians\ndef get_angle_rad(z):\n    return math.radians(get_angle(z))\n\n# Returns the angle in degrees\ndef get_angle_deg2(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad2(z):\n    return math.acos(z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg3(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad3(z):\n    return math.acos(z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg4(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad4(z):\n    return math.acos(z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg5(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad5(z):\n    return math.acos(z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg6(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad6(z):\n    return math.acos(z.real)\n\n# Returns the angle in degrees\ndef get_angle_deg7(z):\n    return math.degrees(math.acos(z.real))\n\n# Returns the angle in radians\ndef get_angle_rad7(z):\n    return math.acos(z.real)\n\n#",
    "def get_angle(z):\n    \"\"\"\n    For the complex number z, return the angle in the complex plane.\n    The value returned should be in the range [0, pi).\n    \"\"\"\n    # Write your code here\n    return -1\n\n\nif __name__ == '__main__':\n    z = complex(3, 4)\n    print(get_angle(z))",
    "# Complex number\nclass Complex:\n    \"\"\"A complex number, real part and imaginary part.\"\"\"\n    def __init__(self, real_part, imaginary_part):\n        self.real = real_part\n        self.imaginary = imaginary_part\n\n    def __repr__(self):\n        return \"Complex(real_part={}, imaginary_part={})\".format(\n            self.real, self.imaginary)\n\n    def __str__(self):\n        return \"Complex({}, {})\".format(self.real, self.imaginary)\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imaginary + other.imaginary)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imaginary - other.imaginary)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imaginary * other.imaginary,\n                       self.real * other.imaginary + self.imaginary * other.real)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imaginary == other.imaginary\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imaginary)\n\n    def __repr__(self):\n        return \"Complex(real_part={}, imaginary_part={})\".format(self.real,\n                                                                 self.imaginary)\n\n    def __str__(self):\n        return \"Complex({}, {})\".format(self.real, self.imaginary)\n\n    def __getattr__(self, name):\n        \"\"\"\n        This function is called when an attribute is not found in the object.\n        In this case, the default attribute is returned.\n        \"\"\"\n        raise AttributeError(name)\n\n    def conjugate(self):\n        return Complex(self.real, -self.imaginary)\n\n    def __pow__(self, exponent):\n        return Complex(self.real ** exponent, self.imaginary **",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    Input a complex number and get the angle of the complex number.\n\n    :type z: complex\n    :rtype: float\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\nif __name__ == '__main__':\n    test_cases = [[1, 0],\n                  [0, 1],\n                  [0, -1],\n                  [1, 1],\n                  [1, -1],\n                  [-1, 1],\n                  [-1, -1]]\n    for t in test_cases:\n        print(complex_angle(t))",
    "def angle(z):\n    \"\"\"\n    :param z: A complex number\n    :return: The angle of z in radians.\n    \"\"\"\n    return z.imag / abs(z)\n\nif __name__ == \"__main__\":\n    assert angle(complex(1, 0)) == 0\n    assert angle(complex(0, 1)) == 0\n    assert angle(complex(1, 1)) == 0.7853981633974483\n    assert angle(complex(1, -1)) == 3.141592653589793\n    assert angle(complex(1, 2)) == 0.7853981633974483\n    assert angle(complex(1, -2)) == 3.141592653589793\n    assert angle(complex(2, -1)) == 0.7853981633974483\n    assert angle(complex(2, 1)) == 0.7853981633974483\n    assert angle(complex(2, 2)) == 0.7853981633974483\n    assert angle(complex(2, -2)) == 3.141592653589793\n    assert angle(complex(3, -1)) == 3.141592653589793\n    assert angle(complex(3, 1)) == 3.141592653589793\n    assert angle(complex(3, 2)) == 3.141592653589793\n    assert angle(complex(3, -2)) == 3.141592653589793\n    assert angle(complex(4, -1)) == 3.141592653589793\n    assert angle(complex(4, 1)) == 3.141592653589793\n    assert angle(complex(4, 2)) == 3.141592653589793\n    assert angle(complex(4, -2)) == 3.141592653589793\n    assert angle(complex(5, -1)) == 3.141592653589793\n    assert angle(complex(5, 1)) == 3.141592653589793\n    assert angle(complex(5, 2)) == 3.141592653589793\n    assert angle(complex(5, -2)) == 3.141592653589793\n    assert angle(complex(6, -1)) == 3",
    "# https://www.hackerrank.com/challenges/angle-of-a-complex-number/problem\n\nimport math\n\ndef angle_of_a_complex_number(x):\n    # Complete this function\n    if x.imag == 0:\n        return math.atan2(x.real, x.real)\n    else:\n        return math.atan2(x.real, x.imag) + math.atan2(-x.imag, x.real)\n\nif __name__ == \"__main__\":\n    # https://www.hackerrank.com/challenges/angle-of-a-complex-number/submissions/code/2501983\n    s = input()\n    for i in range(s):\n        x = input().split()\n        y = int(x[0])\n        z = int(x[1])\n        print(angle_of_a_complex_number(complex(y, z)))",
    "class Complex(object):\n    \"\"\"\n    A complex number is a number with a real and imaginary part.\n    \"\"\"\n\n    def __init__(self, real=0.0, imag=0.0):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __str__(self):\n        return \"({0.real}, {0.imag})\".format(self)\n\ndef get_angle(c):\n    \"\"\"\n    Return the angle of a complex number.\n    \"\"\"\n    return 2.0 * math.atan2(c.imag, c.real)\n\nif __name__ == \"__main__\":\n    c = Complex(3.0, 4.0)\n    print(get_angle(c))\n    c = Complex(3.0, -4.0)\n    print(get_angle(c))\n    c = Complex(3.0, 4.0)\n    print(get_angle(c))",
    "from math import atan2, pi\n\n\ndef angle(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    z: the complex number you want to get the angle of.\n\n    Returns: the angle in radians.\n    \"\"\"\n    return atan2(z.imag, z.real)\n\n\ndef main():\n    \"\"\"\n    Test your function using the provided complex number.\n    \"\"\"\n    z = complex(3.0, 4.0)\n    assert angle(z) == pi/4\n    assert angle(1+z) == pi/4\n    assert angle(1+2j) == pi/4\n    assert angle(1-z) == -pi/4\n    assert angle(1-2j) == -pi/4\n    assert angle(1-3j) == -pi/4\n    assert angle(1-4j) == -pi/4\n    assert angle(1-5j) == -pi/4\n    assert angle(1-6j) == -pi/4\n    assert angle(1-7j) == -pi/4\n    assert angle(1-8j) == -pi/4\n    assert angle(1-9j) == -pi/4\n    assert angle(1-10j) == -pi/4\n    assert angle(1-11j) == -pi/4\n    assert angle(1-12j) == -pi/4\n    assert angle(1-13j) == -pi/4\n    assert angle(1-14j) == -pi/4\n    assert angle(1-15j) == -pi/4\n    assert angle(1-16j) == -pi/4\n    assert angle(1-17j) == -pi/4\n    assert angle(1-18j) == -pi/4\n    assert angle(1-19j) == -pi/4\n    assert angle(1-20j) == -pi/4\n    assert angle(1-21j) == -pi/4\n    assert angle(1-22j) == -pi/4\n    assert angle(1-23j) == -pi/4\n    assert angle(1-24j) == -pi/4\n    assert",
    "# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://www.python-course.eu/python_complex_number.php\n\n# Complex number\n# https://",
    "import math\n\ndef angle(z):\n    \"\"\"\n    Returns the angle of a complex number.\n\n    The input is a complex number, (a + bi), and the output is the\n    angle of the complex number in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\ndef main():\n    \"\"\"\n    A simple test program that takes a complex number as input and\n    displays the angle of the input number in radians.\n    \"\"\"\n    z = complex(3.1, -1.2)\n    print angle(z)\n\nif __name__ == '__main__':\n    main()",
    "def get_angle(z):\n    \"\"\"\n    z: a complex number\n    \"\"\"\n    return (math.atan(math.imag(z))*180/math.pi) % 360\n\ndef test_get_angle():\n    assert get_angle(1+1j) == 45\n    assert get_angle(1.0+1.0j) == 0\n    assert get_angle(1.0+1.0j*1e-3) == 0\n    assert get_angle(1.0+1.0j*1e-10) == 0\n    assert get_angle(1.0+1.0j*1e-20) == 0\n    assert get_angle(1.0+1.0j*1e-50) == 0\n    assert get_angle(1.0+1.0j*1e-100) == 0\n    assert get_angle(1.0+1.0j*1e-200) == 0\n    assert get_angle(1.0+1.0j*1e-500) == 0\n    assert get_angle(1.0+1.0j*1e-1000) == 0\n    assert get_angle(1.0+1.0j*1e-2000) == 0\n    assert get_angle(1.0+1.0j*1e-5000) == 0\n    assert get_angle(1.0+1.0j*1e-10000) == 0\n    assert get_angle(1.0+1.0j*1e-20000) == 0\n    assert get_angle(1.0+1.0j*1e-50000) == 0\n    assert get_angle(1.0+1.0j*1e-100000) == 0\n    assert get_angle(1.0+1.0j*1e-200000) == 0\n    assert get_angle(1.0+1.0j*1e-500000) == 0\n    assert get_angle(1.0+1.0j*1e-1000000) == 0\n    assert get_angle(1.0+1.0j*1e-2000000) == 0\n    assert get_angle(",
    "import math\n\ndef get_angle(complex_number):\n    \"\"\"\n    :type complex_number: complex\n    :rtype: float\n    \"\"\"\n    return math.atan2(complex_number.imag, complex_number.real)\n\n\nif __name__ == '__main__':\n    complex_number = complex(1, 1)\n    print(get_angle(complex_number))\n    complex_number = complex(-1, 1)\n    print(get_angle(complex_number))\n    complex_number = complex(1, -1)\n    print(get_angle(complex_number))\n    complex_number = complex(1, 0)\n    print(get_angle(complex_number))\n    complex_number = complex(-1, 0)\n    print(get_angle(complex_number))\n    complex_number = complex(0, 1)\n    print(get_angle(complex_number))\n    complex_number = complex(0, -1)\n    print(get_angle(complex_number))\n    complex_number = complex(0, 0)\n    print(get_angle(complex_number))",
    "import math\n\ndef get_angle(x):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The inputs and outputs of your function should be in radians.\n\n    :param x: The input complex number.\n    :return: The angle of x.\n    \"\"\"\n    return math.atan2(x.imag, x.real)\n\ndef test_function(input_data):\n    \"\"\"\n    Test your function with some real data.\n\n    :param input_data: The input complex number.\n    \"\"\"\n    print(\"Input: \", input_data)\n    print(\"Angle: \", get_angle(input_data))\n\nif __name__ == \"__main__\":\n    test_function(complex(1, 2))",
    "from math import acos\n\ndef get_angle(z):\n    return acos(z.real)\n\nif __name__ == \"__main__\":\n    z = complex(1, 1)\n    print(get_angle(z))",
    "import math\n\ndef get_angle(x):\n    \"\"\"\n    Get the angle of a complex number.\n    \"\"\"\n    # https://en.wikipedia.org/wiki/Complex_number#Definition\n    # https://en.wikipedia.org/wiki/Degrees_and_radians\n    return math.degrees(math.atan2(x.imag, x.real))\n\nif __name__ == '__main__':\n    print(get_angle(complex(2, 3)))\n    print(get_angle(complex(1, -1)))\n    print(get_angle(complex(-2, -3)))\n    print(get_angle(complex(-1, 1)))\n    print(get_angle(complex(0, -1)))\n    print(get_angle(complex(-1, 0)))\n    print(get_angle(complex(1, 0)))\n    print(get_angle(complex(1, 1)))\n    print(get_angle(complex(1, 2)))\n    print(get_angle(complex(1, 3)))\n    print(get_angle(complex(1, 4)))\n    print(get_angle(complex(1, 5)))\n    print(get_angle(complex(1, 6)))\n    print(get_angle(complex(1, 7)))\n    print(get_angle(complex(1, 8)))\n    print(get_angle(complex(1, 9)))\n    print(get_angle(complex(1, 10)))\n    print(get_angle(complex(1, 11)))\n    print(get_angle(complex(1, 12)))\n    print(get_angle(complex(1, 13)))\n    print(get_angle(complex(1, 14)))\n    print(get_angle(complex(1, 15)))\n    print(get_angle(complex(1, 16)))\n    print(get_angle(complex(1, 17)))\n    print(get_angle(complex(1, 18)))\n    print(get_angle(complex(1, 19)))\n    print(get_angle(complex(1, 20)))\n    print(get_angle(complex(1, 21)))\n    print(get_angle(complex(1, 22)))",
    "from __future__ import print_function\nimport math\n\nclass Complex(object):\n    \"\"\"\n    A complex number object.\n    \"\"\"\n    def __init__(self, real, imag):\n        \"\"\"\n        Initialize a complex number object.\n\n        real: float\n            The real part of the complex number.\n        imag: float\n            The imaginary part of the complex number.\n        \"\"\"\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        \"\"\"\n        Return the string representation of the complex number.\n\n        Returns:\n            str\n            The string representation of the complex number.\n        \"\"\"\n        return \"%s + %sj\" % (self.real, self.imag)\n\n    def __add__(self, other):\n        \"\"\"\n        Add two complex numbers.\n\n        other: complex\n            The other complex number.\n\n        Returns:\n            Complex\n            The sum of the two complex numbers.\n        \"\"\"\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        \"\"\"\n        Subtract two complex numbers.\n\n        other: complex\n            The other complex number.\n\n        Returns:\n            Complex\n            The difference of the two complex numbers.\n        \"\"\"\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        \"\"\"\n        Multiply two complex numbers.\n\n        other: complex\n            The other complex number.\n\n        Returns:\n            Complex\n            The product of the two complex numbers.\n        \"\"\"\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __div__(self, other):\n        \"\"\"\n        Divide two complex numbers.\n\n        other: complex\n            The other complex number.\n\n        Returns:\n            Complex\n            The quotient of the two complex numbers.\n        \"\"\"\n        return Complex(self.real * other.real + self.imag * other.imag,\n                       self.imag * other.real - self.real * other.imag)",
    "from __future__ import annotations\n\nclass Complex:\n    \"\"\"\n    Represents a complex number.\n    \"\"\"\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __repr__(self):\n        return \"({}, {})\".format(self.real, self.imag)\n\n    def __str__(self):\n        return \"({}, {})\".format(self.real, self.imag)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imag == other.imag\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((self.real, self.imag))\n\n    def __lt__(self, other):\n        return (self.real, self.imag) < (other.real, other.imag)\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __radd__(self, other):\n        return Complex(self.real + other, self.imag + other)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __rsub__(self, other):\n        return Complex(other.real - self.real, other.imag - self.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __rmul__(self, other):\n        return Complex(other.real * self.real - other.imag * self.imag,\n                       other.real * self.imag + other.imag * self.real)\n\n    def __truediv__(self, other):\n        return Complex(self.real / other.real, self.imag / other.imag)\n\n    def __rtruediv__(self, other):\n        return Complex(other.real / self.real, other.imag / self.imag)\n\n    def __",
    "def get_angle(z):\n    \"\"\"\n    For a complex number z, return the angle of z in radians.\n    \"\"\"\n    return math.atan(z.imag / z.real)",
    "def get_angle(z):\n    if abs(z) < 1:\n        return 0\n    if abs(z.imag) > abs(z.real):\n        return pi/2 - (abs(z.imag) - abs(z.real))*pi/4\n    else:\n        return (abs(z.real) - abs(z.imag))*pi/4\n\n\"\"\"\nA simple test program.\n\"\"\"\n\ndef main():\n    z = complex(1.0, 0.0)\n    print(get_angle(z))\n\nif __name__ == \"__main__\":\n    main()",
    "def get_angle(complex_num):\n    \"\"\"\n    :type complex_num: complex\n    :rtype: float\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)\n\nif __name__ == '__main__':\n    assert get_angle(complex(-2, 0)) == -math.pi/2\n    assert get_angle(complex(0, 2)) == 0\n    assert get_angle(complex(-3, 0)) == math.pi/2\n    assert get_angle(complex(0, -2)) == math.pi/2",
    "import math\n\ndef get_angle(z):\n    return math.degrees(math.atan2(math.imag(z), math.real(z)))\n\ndef main():\n    z = complex(2, -1)\n    print(get_angle(z))\n\nif __name__ == '__main__':\n    main()",
    "class Complex(object):\n    \"\"\"Complex number class.\"\"\"\n\n    def __init__(self, real=0, imag=0):\n        \"\"\"Create a complex number with real and imaginary parts.\"\"\"\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        \"\"\"Add two complex numbers.\"\"\"\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        \"\"\"Multiply two complex numbers.\"\"\"\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __sub__(self, other):\n        \"\"\"Subtract two complex numbers.\"\"\"\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __str__(self):\n        \"\"\"String representation of a complex number.\"\"\"\n        return \"(\" + str(self.real) + \", \" + str(self.imag) + \")\"\n\n    def __repr__(self):\n        \"\"\"String representation of a complex number.\"\"\"\n        return \"Complex(\" + repr(self.real) + \", \" + repr(self.imag) + \")\"\n\n\ndef get_angle(c):\n    \"\"\"Get the angle of a complex number.\"\"\"\n    return 2 * math.pi * c.imag / c.real\n\n\ndef get_angle_between(c1, c2):\n    \"\"\"Get the angle between two complex numbers.\"\"\"\n    return get_angle(c1 - c2)\n\n\ndef get_angle_between_points(p1, p2):\n    \"\"\"Get the angle between two points.\"\"\"\n    return get_angle(p1 - p2)\n\n\ndef get_angle_between_vectors(v1, v2):\n    \"\"\"Get the angle between two vectors.\"\"\"\n    return get_angle(v1.imag * v2.real + v1.real * v2.imag)\n\n\ndef get_angle_between_vectors_and_point(v1, p, v2):\n    \"\"\"Get the angle between two vectors and a point.\"\"\"",
    "import math\n\n# Complex number\nclass Complex(object):\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        return \"(\" + str(self.real) + \" + \" + str(self.imag) + \"i)\"\n\n    def __add__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real + other.real, self.imag + other.imag)\n        else:\n            raise TypeError(\"Can only add a complex number to a complex number\")\n\n    def __radd__(self, other):\n        if isinstance(other, Complex):\n            return Complex(other.real + self.real, other.imag + self.imag)\n        else:\n            raise TypeError(\"Can only add a complex number to a complex number\")\n\n    def __sub__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real - other.real, self.imag - other.imag)\n        else:\n            raise TypeError(\"Can only subtract a complex number from a complex number\")\n\n    def __rsub__(self, other):\n        if isinstance(other, Complex):\n            return Complex(other.real - self.real, other.imag - self.imag)\n        else:\n            raise TypeError(\"Can only subtract a complex number from a complex number\")\n\n    def __mul__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        else:\n            raise TypeError(\"Can only multiply a complex number with a complex number\")\n\n    def __rmul__(self, other):\n        if isinstance(other, Complex):\n            return Complex(other.real * self.real - other.imag * self.imag,\n                           other.real * self.imag + other.imag * self.real)\n        else:\n            raise TypeError(\"Can only multiply a complex number with a complex number\")\n\n    def __div__(self, other):\n        if isinstance(",
    "def get_angle(z):\n    if (z.real > 0):\n        return 2 * math.atan(z.real / z.imag)\n    else:\n        return 2 * math.atan(z.real / z.imag) + math.pi\n\n\nif __name__ == '__main__':\n    z = complex(1, -1)\n    print(get_angle(z))",
    "def get_angle(z):\n    \"\"\"\n    z: complex number\n    returns: angle in radians\n    \"\"\"\n    return z.imag * 1j\n\ndef main():\n    z = 1.0 + 0.0j\n    print(get_angle(z))\n\nif __name__ == '__main__':\n    main()",
    "def get_angle(z):\n    \"\"\"\n    For a complex number z, return the angle.\n    \"\"\"\n    real = z.real\n    imag = z.imag\n\n    # return the angle\n    if real == 0 and imag == 0:\n        return 0\n    elif real == 0 and imag > 0:\n        return np.pi/2\n    elif real == 0 and imag < 0:\n        return 3*np.pi/2\n    else:\n        return np.arctan(imag/real)\n\nif __name__ == '__main__':\n    z = complex(2, 3)\n    print get_angle(z)",
    "def get_angle(complex_number):\n    return complex(0, 1) * complex_number\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    z: complex number\n    \"\"\"\n    \n    z_abs = abs(z)\n    angle = math.atan(z.imag/z.real)\n\n    if z.imag == 0:\n        angle = 0\n\n    return angle\n\nif __name__ == \"__main__\":\n    z = complex(2, 3)\n    print(get_angle(z))",
    "import math\n\n\ndef complex_angle(z):\n    \"\"\"\n    z is a complex number, and returns the angle in radians.\n    \"\"\"\n    # The angle of a complex number is defined as the angle between the\n    # negative half-plane and the real axis.\n    if z.imag == 0:\n        # The angle is the same as the angle between the real axis and the\n        # positive half-plane.\n        return math.atan2(z.real, z.real)\n    else:\n        return math.atan2(z.imag, z.real)\n\n\nif __name__ == \"__main__\":\n    z = complex(3, 4)\n    print(\"z =\", z)\n    print(\"angle of z =\", complex_angle(z))\n    print(\"angle of (1, 0) =\", complex_angle((1, 0)))",
    "import math\n\n\ndef angle(z):\n    \"\"\"\n    Get the angle of a complex number.\n\n    z is a complex number.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\nif __name__ == '__main__':\n    assert angle(1 + 1j) == 0\n    assert angle(1j + 1) == math.pi / 2\n    assert angle(1j + 1j) == math.pi / 4\n    assert angle(1 - 1j) == math.pi / 2\n    assert angle(1 - 1j + 1j) == math.pi / 4",
    "import math\n\n# Complete the getAngle function below.\ndef getAngle(z):\n    \"\"\"\n    :type z: float\n    :rtype: float\n    \"\"\"\n    return math.acos(z.real) * 180 / math.pi\n\nif __name__ == '__main__':\n    z = complex(1.5, -2.5)\n    print(getAngle(z))",
    "from math import acos\n\ndef get_angle(x):\n    return acos(x.real)\n\n\nif __name__ == '__main__':\n    x = complex(1.5, 2.5)\n    print(get_angle(x))",
    "class Complex(object):\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __str__(self):\n        return \"({0} + {1}j)\".format(self.real, self.imag)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imag == other.imag\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imag)\n\n    def __repr__(self):\n        return \"Complex({0}, {1})\".format(self.real, self.imag)\n\ndef get_angle(z):\n    a = math.atan(z.imag / z.real)\n    if a < 0:\n        return a + 2 * math.pi\n    else:\n        return a\n\ndef get_angle_rad(z):\n    a = math.atan(z.imag / z.real)\n    if a < 0:\n        return a + 2 * math.pi\n    else:\n        return a\n\ndef main():\n    z = Complex(3, 2)\n    print(get_angle(z))\n    print(get_angle_rad(z))\n\nif __name__ == '__main__':\n    main()",
    "class Complex(object):\n    \"\"\"\n    A complex number object.\n    \"\"\"\n\n    def __init__(self, real, imag=0):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        \"\"\"\n        Add two complex numbers.\n        \"\"\"\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        \"\"\"\n        Multiply two complex numbers.\n        \"\"\"\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __eq__(self, other):\n        \"\"\"\n        Check if two complex numbers are equal.\n        \"\"\"\n        return self.real == other.real and self.imag == other.imag\n\n    def __str__(self):\n        \"\"\"\n        Print a complex number in the form of \"(real + imag * i)\"\n        \"\"\"\n        return \"(%s + %si)\" % (self.real, self.imag)\n\n    def __repr__(self):\n        \"\"\"\n        Print a complex number in the form of \"(real + imag * i)\"\n        \"\"\"\n        return \"(%s + %si)\" % (self.real, self.imag)\n\n    def __neg__(self):\n        \"\"\"\n        Negate a complex number.\n        \"\"\"\n        return Complex(-self.real, -self.imag)\n\n    def conjugate(self):\n        \"\"\"\n        Conjugate a complex number.\n        \"\"\"\n        return Complex(self.real, -self.imag)\n\n    def __abs__(self):\n        \"\"\"\n        Get the absolute value of a complex number.\n        \"\"\"\n        return abs(self)\n\n    def __div__(self, other):\n        \"\"\"\n        Divide two complex numbers.\n        \"\"\"\n        return Complex(self.real / other.real, self.imag / other.imag)\n\n    def __floordiv__(self, other):\n        \"\"\"\n        Divide two complex numbers.\n        \"\"\"\n        return Complex(self.real / other, self.imag / other)\n\n    def __t",
    "class Complex(object):\n    \"\"\"\n    A complex number object.\n    \"\"\"\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n        self.imag = imag\n\n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Complex(self.real * other, self.imag * other)\n        elif isinstance(other, Complex):\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        else:\n            raise TypeError(\"Invalid argument type\")\n\n    def __rmul__(self, other):\n        if isinstance(other, (int, float)):\n            return Complex(self.real * other, self.imag * other)\n        elif isinstance(other, Complex):\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        else:\n            raise TypeError(\"Invalid argument type\")\n\n    def __eq__(self, other):\n        return (self.real == other.real and self.imag == other.imag)\n\n    def __str__(self):\n        return \"({0}, {1})\".format(self.real, self.imag)\n\n    def __repr__(self):\n        return \"Complex({0}, {1})\".format(self.real, self.imag)\n\n    def __add__(self, other):\n        if isinstance(other, (int, float)):\n            return Complex(self.real + other, self.imag)\n        elif isinstance(other, Complex):\n            return Complex(self.real + other.real, self.imag + other.imag)\n        else:\n            raise TypeError(\"Invalid argument type\")\n\n    def __radd__(self, other):\n        if isinstance(other, (int, float)):\n            return Complex(self.real + other, self.imag)\n        elif isinstance(other, Complex):\n            return Complex(self.real + other.real,",
    "from math import acos\n\nclass Complex:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real*other.real - self.imag*other.imag,\n                       self.real*other.imag + self.imag*other.real)\n\n    def __truediv__(self, other):\n        return Complex(self.real/other.real, self.imag/other.imag)\n\n    def __str__(self):\n        return \"(\" + str(self.real) + \",\" + str(self.imag) + \")\"\n\n    def __repr__(self):\n        return \"(\" + str(self.real) + \",\" + str(self.imag) + \")\"\n\ndef angle(a):\n    return acos(a.__mul__(a))\n\ndef main():\n    a = Complex(1, 1)\n    print(angle(a))\n    print(a)\n\nif __name__ == '__main__':\n    main()",
    "def get_angle(z):\n    \"\"\"\n    z: complex number\n    return: angle in radians\n    \"\"\"\n    return z.imag / z.real\n\n\ndef test():\n    assert get_angle(1+1j) == 0.7853981633974483\n    assert get_angle(1+2j) == 1.0471975511966588\n    assert get_angle(1-2j) == 1.0471975511966588\n    assert get_angle(1-1j) == 0.7853981633974483\n    assert get_angle(1j) == 0.7853981633974483\n    assert get_angle(2j) == 1.0471975511966588\n    assert get_angle(3j) == 1.0471975511966588\n    assert get_angle(4j) == 1.0471975511966588\n    assert get_angle(5j) == 1.0471975511966588\n    assert get_angle(6j) == 1.0471975511966588\n    assert get_angle(7j) == 1.0471975511966588\n    assert get_angle(8j) == 1.0471975511966588\n    assert get_angle(9j) == 1.0471975511966588\n    assert get_angle(10j) == 1.0471975511966588\n    assert get_angle(11j) == 1.0471975511966588\n    assert get_angle(12j) == 1.0471975511966588\n    assert get_angle(13j) == 1.0471975511966588\n    assert get_angle(14j) == 1.0471975511966588\n    assert get_angle(15j) == 1.0471975511966588\n    assert get_angle(16j) == 1.0471975511966588\n    assert get_angle(17j) == 1.0471975511966588\n    assert get_angle(18j) == 1.0471975511966588\n    assert get_angle(19j) == 1.0471975511966588\n    assert get_angle(20j) == 1.0471975511966588\n    assert get_angle(21j) == 1.0471975511966588\n    assert get_",
    "import math\n\n\ndef get_angle(z):\n    \"\"\"\n    :param z: The complex number.\n    :return: The angle of z.\n    \"\"\"\n    if math.isnan(z.real) or math.isnan(z.imag):\n        return math.nan\n    return math.atan(z.imag / z.real)\n\n\nif __name__ == '__main__':\n    assert get_angle(0) == 0\n    assert get_angle(1) == 0\n    assert get_angle(1 + 2j) == math.pi / 2\n    assert get_angle(-1 + 2j) == math.pi / 2\n    assert get_angle(2) == math.pi / 2\n    assert get_angle(2j) == math.pi / 2\n    assert get_angle(2 + 3j) == math.pi / 2\n    assert get_angle(1 + 3j) == math.pi / 2\n    assert get_angle(1j) == 0\n    assert get_angle(1j + 2j) == 0\n    assert get_angle(2j) == 0\n    assert get_angle(1j + 2j + 3j) == 0\n    assert get_angle(1j + 2j + 3j) == 0",
    "from math import acos, atan2, sqrt\n\n\ndef get_angle(z):\n    \"\"\"\n    Get the angle of a complex number.\n\n    :param z: A complex number.\n    :return: The angle of z in radians.\n    \"\"\"\n    a = acos(z.imag / sqrt(z.real ** 2 + z.imag ** 2))\n    if z.real > 0:\n        return a\n    else:\n        return a + 2 * pi\n\n\nif __name__ == '__main__':\n    assert get_angle(complex(0, 1)) == 0\n    assert get_angle(complex(1, 1)) == pi / 2\n    assert get_angle(complex(1, -1)) == pi / 4\n    assert get_angle(complex(1, -1j)) == pi / 2\n    assert get_angle(complex(1, -1j)) == pi / 4\n    assert get_angle(complex(1j, 1)) == pi / 2\n    assert get_angle(complex(1j, -1)) == pi / 4\n    assert get_angle(complex(1j, -1j)) == pi / 2\n    assert get_angle(complex(1j, -1j)) == pi / 4\n    assert get_angle(complex(1j, -1)) == pi / 4\n    assert get_angle(complex(1j, 1j)) == pi / 2\n    assert get_angle(complex(1j, -1j)) == 3 * pi / 4\n    assert get_angle(complex(1j, -1)) == 3 * pi / 4\n    assert get_angle(complex(1j, -1j)) == 3 * pi / 4",
    "import math\n\n\ndef get_angle(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle = angle of z in radians\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\ndef get_angle_radians(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle = angle of z in radians\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\ndef get_angle_degrees(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle = angle of z in degrees\n    \"\"\"\n    return math.degrees(get_angle(z))\n\n\ndef get_angle_degrees_radians(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle = angle of z in degrees\n    \"\"\"\n    return math.degrees(get_angle_radians(z))\n\n\ndef get_angle_radians_degrees(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle = angle of z in degrees\n    \"\"\"\n    return math.degrees(get_angle_degrees(z))\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    z = complex(3, -4)\n    print(get_angle(z))\n    print(get_angle_radians(z))\n    print(get_angle_degrees(z))\n    print(get_angle_degrees_radians(z))\n    print(get_angle_radians_degrees(z))\n\n\nif __name__ == \"__main__\":\n    main()",
    "class ComplexNumber:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def get_angle(self):\n        return 0.0\n\n\ndef test_get_angle():\n    assert get_angle(ComplexNumber(1, 0)) == 0.0\n    assert get_angle(ComplexNumber(1, 1)) == 0.0\n    assert get_angle(ComplexNumber(1, -1)) == 0.0\n    assert get_angle(ComplexNumber(-1, 1)) == 0.0\n    assert get_angle(ComplexNumber(-1, -1)) == 0.0\n    assert get_angle(ComplexNumber(-1, 0)) == 0.0\n    assert get_angle(ComplexNumber(0, -1)) == pi/2\n    assert get_angle(ComplexNumber(0, 1)) == pi/2\n    assert get_angle(ComplexNumber(0, 0)) == 0.0\n    assert get_angle(ComplexNumber(1, 1)) == 0.0\n    assert get_angle(ComplexNumber(1, -1)) == pi\n    assert get_angle(ComplexNumber(-1, 1)) == pi\n    assert get_angle(ComplexNumber(-1, -1)) == 3*pi/2\n    assert get_angle(ComplexNumber(-1, 0)) == pi/2\n    assert get_angle(ComplexNumber(0, -1)) == pi\n    assert get_angle(ComplexNumber(0, 1)) == 3*pi/2\n    assert get_angle(ComplexNumber(0, 0)) == 0.0\n    assert get_angle(ComplexNumber(1, 2)) == pi/4\n    assert get_angle(ComplexNumber(1, -2)) == 3*pi/4\n    assert get_angle(ComplexNumber(-1, 2)) == 3*pi/4\n    assert get_angle(ComplexNumber(-1, -2)) == -3*pi/4\n    assert get_angle(ComplexNumber(2, 2)) == pi/4\n    assert get_angle(ComplexNumber(2, -2)) == -pi/4\n    assert get",
    "# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py\n# https://github.com/ljkak/interview/blob/master/solutions/solution-4.py",
    "# https://www.codeeval.com/open_challenges/113/\n\ndef get_angle(z):\n    \"\"\"\n    z = a + j * b\n    a, b real\n    a, b complex\n    \"\"\"\n    if z.imag == 0:\n        return z.real\n    else:\n        return -1 * (math.atan(z.imag / z.real) % (2 * math.pi))\n\n\ndef main():\n    \"\"\"\n    Main\n    \"\"\"\n    import sys\n    args = sys.argv[1:]\n\n    if len(args) == 0:\n        args = [1, 1]\n\n    a = float(args[0])\n    b = float(args[1])\n\n    z = complex(a, b)\n\n    print get_angle(z)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    Get the angle of a complex number.\n\n    z: A complex number\n    \"\"\"\n    a = math.atan2(z.imag, z.real)\n    if z.imag == 0:\n        return 0.0\n    return a\n\nprint get_angle(complex(1, 2))\nprint get_angle(complex(1, -2))\nprint get_angle(complex(1, 0))\nprint get_angle(complex(0, 1))\nprint get_angle(complex(0, -1))\nprint get_angle(complex(0, 0))",
    "class Complex:\n    \"\"\"\n    A complex number is a number consisting of a real number plus an\n    imaginary number.\n    \"\"\"\n    def __init__(self, real, imaginary):\n        self.real = real\n        self.imaginary = imaginary\n\n    def __str__(self):\n        return str(self.real) + \" + \" + str(self.imaginary) + \"i\"\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imaginary + other.imaginary)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imaginary * other.imaginary,\n                       self.real * other.imaginary + self.imaginary * other.real)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imaginary)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imaginary == other.imaginary\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __pow__(self, exp):\n        return Complex(self.real ** exp, self.imaginary ** exp)\n\n    def __rpow__(self, exp):\n        return Complex(self.real ** exp, self.imaginary ** exp)\n\ndef angle(c):\n    return 2 * math.atan(c.imaginary / c.real)\n\nclass TestComplex(unittest.TestCase):\n    def test_angle(self):\n        self.assertEqual(angle(Complex(3, 4)), 1.5708)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input is a complex number z.\n    The output is the angle of z in the form of a tuple of two elements.\n    The first element is the real part and the second element is the\n    imaginary part.\n    \"\"\"\n    real = z.real\n    imag = z.imag\n    if real == 0:\n        angle = (0, 0)\n    elif imag == 0:\n        angle = (math.atan2(real, -1), 0)\n    else:\n        angle = (math.atan2(real, imag), math.atan2(imag, real))\n    return angle\n\n\ndef get_angle_complex(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input is a complex number z.\n    The output is the angle of z in the form of a tuple of two elements.\n    The first element is the real part and the second element is the\n    imaginary part.\n    \"\"\"\n    real = z.real\n    imag = z.imag\n    if real == 0:\n        angle = (0, 0)\n    elif imag == 0:\n        angle = (math.atan2(real, -1), 0)\n    else:\n        angle = (math.atan2(real, imag), math.atan2(imag, real))\n    return angle\n\n\ndef get_angle_float(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input is a complex number z.\n    The output is the angle of z in the form of a tuple of two elements.\n    The first element is the real part and the second element is the\n    imaginary part.\n    \"\"\"\n    real = z.real\n    imag = z.imag\n    if real == 0:\n        angle = (0, 0)\n    elif imag == 0:\n        angle = (math.atan2(real, -1), 0)\n    else:\n        angle = (math.atan2(real, imag), math.atan2(imag, real))\n    return angle\n\n\ndef get_angle_float2(",
    "def get_angle(z):\n    \"\"\"\n    z = complex(a, b)\n    returns the angle of z.\n    \"\"\"\n    return atan2(z.imag, z.real)\n\nif __name__ == \"__main__\":\n    z = complex(1.0, 1.0)\n    print get_angle(z)",
    "# https://www.codeeval.com/open_challenges/106/\n\ndef complex_angle(complex_number):\n    \"\"\"\n    :param complex_number: A complex number\n    :return: The angle of the complex number.\n    \"\"\"\n    return math.atan2(complex_number.real, complex_number.imag)\n\n\nif __name__ == \"__main__\":\n    import sys\n    if (len(sys.argv) <= 1):\n        sys.exit(\"Please enter a filename.\")\n    with open(sys.argv[1]) as f:\n        for line in f:\n            complex_number = complex(line.split()[0], line.split()[1])\n            print(complex_angle(complex_number))",
    "from math import atan, cos, pi\n\n\ndef angle(z):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Input: A complex number\n    Output: A float number, the angle of the complex number in radians.\n    \"\"\"\n\n    return atan(z.imag / z.real)\n\n\nif __name__ == \"__main__\":\n    test_case = (1+2j, 3+4j)\n    test_case_result = angle(test_case)\n    test_case_result_expected = pi / 2\n    print(test_case_result == test_case_result_expected)",
    "from math import atan, cos, sin\n\nclass Complex:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __repr__(self):\n        return 'Complex(%r, %r)' % (self.real, self.imag)\n\n    def __str__(self):\n        return '%r + %rj' % (self.real, self.imag)\n\n    def __abs__(self):\n        return abs(self.real) + abs(self.imag)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imag == other.imag\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __pow__(self, exp):\n        if not isinstance(exp, (int, float)):\n            raise TypeError(\"Only integers and floats are valid for exponent.\")\n\n        if exp == 0:\n            return 1\n        elif exp == 1:\n            return self\n        elif exp % 2 == 0:\n            return self.__pow__(exp / 2) * self\n\n        if exp < 0:\n            exp = -exp\n            result = self.__pow__(exp)\n        else:\n            result = 1\n\n        for _ in range(exp):\n            result = result * self\n\n        return result\n\n    def conjugate(self):\n        return Complex(self.real, -self.imag)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imag)\n\n    def __get_angle(self):\n        return atan2(self.imag, self.",
    "import math\n\ndef get_angle(complex_number):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n    :rtype: float\n    :param complex_number: A complex number, for example (1 + 5.3 * j)\n    :return: The angle of the complex number\n    \"\"\"\n    # Convert complex number to polar coordinates\n    r = math.sqrt(complex_number.real ** 2 + complex_number.imag ** 2)\n    theta = math.atan2(complex_number.imag, complex_number.real)\n    # Find the angle of the polar coordinates\n    angle = theta * 180 / math.pi\n    return angle\n\nif __name__ == '__main__':\n    test_cases = [\n        (1 + 5.3j),\n        (1 + 5.3),\n        (1.0),\n        (1.0 + 5.3j),\n        (5.3 + 1j),\n        (5.3 + 5.3j),\n        (5.3 + 5.3),\n    ]\n    for test_case in test_cases:\n        print(\"The angle of {} is {}\".format(test_case, get_angle(test_case)))",
    "import math\n\ndef complex_angle(complex_number):\n    \"\"\"\n    Given a complex number, return its angle.\n    \"\"\"\n\n    real = complex_number.real\n    imag = complex_number.imag\n\n    if real == 0:\n        return math.atan2(imag, real)\n    else:\n        return math.atan2(imag, real) * 180 / math.pi\n\ndef main():\n    complex_number = complex(1, -3)\n    print complex_angle(complex_number)\n\nif __name__ == '__main__':\n    main()",
    "def get_angle(x):\n    \"\"\"\n    :param x: a complex number\n    :return: the angle of x\n    \"\"\"\n    r = abs(x)\n    if r == 0:\n        return 0\n    else:\n        return math.atan(x.imag / x.real)\n\nif __name__ == '__main__':\n    x = complex(1, 2)\n    print(get_angle(x))",
    "from math import atan2, pi, cos, sin, sqrt\n\ndef get_angle(z):\n    return atan2(z.imag, z.real)\n\ndef main():\n    for x in range(0, 10):\n        for y in range(0, 10):\n            z = complex(x, y)\n            print z, get_angle(z)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef get_angle(complex_num):\n    \"\"\"\n    Get the angle of a complex number.\n    :type complex_num: list[list[float]]\n    :rtype: float\n    \"\"\"\n    real = complex_num[0][0]\n    imag = complex_num[0][1]\n    \n    angle = math.atan2(imag, real)\n    \n    return angle\n\nif __name__ == '__main__':\n    complex_num = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0]]\n    print(get_angle(complex_num))",
    "class Complex(object):\n    \"\"\"\n    Complex number\n    \"\"\"\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __str__(self):\n        return \"Complex(%s, %s)\" % (self.real, self.imag)\n\n    def __repr__(self):\n        return \"Complex(%s, %s)\" % (self.real, self.imag)\n\n    def __sub__(self, other):\n        return self + (-1 * other)\n\n    def __pow__(self, other):\n        if other == 0:\n            return 1\n        elif other % 2 == 0:\n            return self ** (other / 2)\n        else:\n            return self ** (other / 2) * self ** (other / 2)\n\n    def __div__(self, other):\n        return self.__mul__(1 / other)\n\n    def __mod__(self, other):\n        return self.__div__(other)\n\n    def __eq__(self, other):\n        return (self.real == other.real) and (self.imag == other.imag)\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __lt__(self, other):\n        return (self.real < other.real) or (self.imag < other.imag)\n\n    def __gt__(self, other):\n        return (self.real > other.real) or (self.imag > other.imag)\n\n    def __le__(self, other):\n        return (self.real <= other.real) and (self.imag <= other.imag)\n\n    def __ge__(self, other):\n        return (self.real >= other.real) and (self.imag >= other.imag)",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    :param z: A complex number\n    :return: The angle of z in radians.\n    \"\"\"\n    # Convert to polar coordinates\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n\n    # Convert back to cartesian coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)\n\n\ndef get_angle_rad(z):\n    \"\"\"\n    :param z: A complex number\n    :return: The angle of z in radians.\n    \"\"\"\n    # Convert to polar coordinates\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n\n    # Convert back to cartesian coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)\n\n\ndef get_angle_deg(z):\n    \"\"\"\n    :param z: A complex number\n    :return: The angle of z in degrees.\n    \"\"\"\n    # Convert to polar coordinates\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n\n    # Convert back to cartesian coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)\n\n\ndef main():\n    z = complex(2, 1)\n    print(get_angle(z))\n    print(get_angle_rad(z))\n    print(get_angle_deg(z))\n\n\nif __name__ == \"__main__\":\n    main()",
    "import math\n\ndef get_angle(complex_num):\n    \"\"\"\n    :type complex_num: complex\n    :rtype: float\n    \"\"\"\n    real_part = complex_num.real\n    imag_part = complex_num.imag\n    angle = math.atan2(imag_part, real_part)\n    return angle\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(1.3, 1.4)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(1, 0)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(1, 1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(1, -1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(-1, -1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(-1, 1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(-1, 0)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(0, -1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(0, 1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(0, 0)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(0, 1)\n    print(\"The angle of \", complex_num, \" is\", get_angle(complex_num))\n    complex_num = complex(0, -1)\n    print(\"The angle of \", complex_num, \" is\", get",
    "class Complex:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __mul__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real*other.real - self.imag*other.imag,\n                           self.real*other.imag + self.imag*other.real)\n        else:\n            return Complex(self.real*other, self.imag*other)\n\n    def __rmul__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real*other.real - self.imag*other.imag,\n                           self.real*other.imag + self.imag*other.real)\n        else:\n            return Complex(self.real*other, self.imag*other)\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __radd__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __rsub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imag)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imag == other.imag\n\n    def __str__(self):\n        return \"(%s + %sj)\" % (self.real, self.imag)\n\n    def __repr__(self):\n        return \"(%s + %sj)\" % (self.real, self.imag)\n\n    def conjugate(self):\n        return Complex(self.real, -self.imag)\n\n    def __abs__(self):\n        return self.real**2 + self.imag**2\n\n    def __pow__(self, n):\n        return Complex(self.real**n, self.imag**n",
    "import math\n\n\ndef angle(z):\n    \"\"\"\n    Given a complex number z, return the angle in radians.\n    \"\"\"\n    return math.atan2(z.real, z.imag)\n\n\nif __name__ == '__main__':\n    z = complex(1, 0)\n    print(angle(z))",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    z is a complex number.\n    Return the angle in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\nif __name__ == \"__main__\":\n    z = complex(2, 3)\n    print get_angle(z)",
    "def get_angle(z):\n    \"\"\"\n    z: a complex number\n    returns: the angle of z in radians\n    \"\"\"\n    return math.atan2(math.imag(z), math.real(z))\n\nif __name__ == \"__main__\":\n    z = complex(1, 2)\n    print get_angle(z)\n    print get_angle(z + 1j)",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    Input a complex number z.\n    Return the angle of z in radians.\n    \"\"\"\n    return math.atan2(z.real, z.imag)\n\nif __name__ == \"__main__\":\n    z = complex(1, 2)\n    print complex_angle(z)",
    "class Complex:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __str__(self):\n        return \"(\" + str(self.real) + \" + \" + str(self.imag) + \"i)\"\n\n    def __repr__(self):\n        return str(self)\n\n    def conjugate(self):\n        return Complex(self.real, -self.imag)\n\nclass Angle:\n    def __init__(self):\n        self.angle = 0\n\n    def __add__(self, other):\n        return Angle(self.angle + other.angle)\n\n    def __mul__(self, other):\n        return Angle(self.angle * other.angle)\n\n    def __str__(self):\n        return \"(\" + str(self.angle) + \"\u00b0)\"\n\n    def __repr__(self):\n        return str(self)\n\n    def angle(self):\n        return self.angle * 180 / pi\n\ndef get_angle(c):\n    return Angle() + Angle(c.real) + Angle(c.imag)\n\ndef get_angle_with_real_imag(c):\n    return Angle() + Angle(c.real) + Angle(c.imag)\n\ndef get_angle_with_imag(c):\n    return Angle() + Angle(c.imag)\n\ndef get_angle_with_real(c):\n    return Angle() + Angle(c.real)\n\ndef get_angle_with_real_and_imag(c):\n    return Angle() + Angle(c.real) + Angle(c.imag)\n\nif __name__ == \"__main__\":\n    c1 = Complex(1, 1)\n    c2 = Complex(2, 2)\n    c3 = Complex(1, 2)",
    "import math\n\n\ndef get_angle(z):\n    \"\"\"\n    :param z: The complex number\n    :return: The angle in degrees\n    \"\"\"\n    return math.degrees(math.atan(z.imag / z.real))\n\n\nif __name__ == '__main__':\n    x = complex(3, 5)\n    print(get_angle(x))",
    "def get_angle(z):\n    \"\"\"\n    For a complex number z, return its angle in the complex plane.\n    \"\"\"\n    return (z.imag / z.real)\n\ndef test_get_angle():\n    assert get_angle(1) == 0\n    assert get_angle(1j) == 0\n    assert get_angle(1+1j) == 0\n    assert get_angle(1+2j) == 0\n    assert get_angle(1+3j) == 0\n    assert get_angle(1+4j) == 0\n    assert get_angle(1+5j) == 0\n    assert get_angle(1+6j) == 0\n    assert get_angle(1+7j) == 0\n    assert get_angle(1+8j) == 0\n    assert get_angle(1+9j) == 0\n    assert get_angle(1+10j) == 0\n    assert get_angle(1+11j) == 0\n    assert get_angle(1+12j) == 0\n    assert get_angle(1+13j) == 0\n    assert get_angle(1+14j) == 0\n    assert get_angle(1+15j) == 0\n    assert get_angle(1+16j) == 0\n    assert get_angle(1+17j) == 0\n    assert get_angle(1+18j) == 0\n    assert get_angle(1+19j) == 0\n    assert get_angle(1+20j) == 0\n    assert get_angle(1+21j) == 0\n    assert get_angle(1+22j) == 0\n    assert get_angle(1+23j) == 0\n    assert get_angle(1+24j) == 0\n    assert get_angle(1+25j) == 0\n    assert get_angle(1+26j) == 0\n    assert get_angle(1+27j) == 0\n    assert get_angle(1+28j) == 0\n    assert get_angle(1+29j) == 0\n    assert get_angle(1+30j) == 0\n    assert get_angle(1+31j) == 0\n    assert get",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    :param z: A complex number\n    :return: The angle of z in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\nclass TestComplexAngle(unittest.TestCase):\n    def test_complex_angle(self):\n        self.assertEqual(complex_angle(complex(2, 3)), math.pi / 2)\n        self.assertEqual(complex_angle(complex(-2, -3)), -math.pi / 2)\n        self.assertEqual(complex_angle(complex(3, 2)), math.pi / 4)\n        self.assertEqual(complex_angle(complex(-3, -2)), -math.pi / 4)\n        self.assertEqual(complex_angle(complex(2, -3)), -math.pi / 4)\n        self.assertEqual(complex_angle(complex(-2, 3)), -math.pi / 4)\n        self.assertEqual(complex_angle(complex(3, -2)), math.pi / 4)\n        self.assertEqual(complex_angle(complex(-3, 2)), math.pi / 4)\n        self.assertEqual(complex_angle(complex(-3, -2)), -math.pi / 4)\n        self.assertEqual(complex_angle(complex(3, 2)), -math.pi / 4)\n        self.assertEqual(complex_angle(complex(-3, -2)), math.pi / 4)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "import math\n\nclass Complex:\n    \"\"\"A complex number.\"\"\"\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        return \"(\" + str(self.real) + \", \" + str(self.imag) + \")\"\n\n    def __repr__(self):\n        return str(self)\n\n    def __add__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real + other.real, self.imag + other.imag)\n        else:\n            return Complex(self.real + other, self.imag)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        return self.__add__(-other)\n\n    def __rsub__(self, other):\n        return -self.__add__(other)\n\n    def __mul__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        else:\n            return Complex(self.real * other, self.imag * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __div__(self, other):\n        if isinstance(other, Complex):\n            return Complex(self.real * other.real + self.imag * other.imag,\n                           self.real * other.imag - self.imag * other.real)\n        else:\n            return Complex(self.real / other, self.imag / other)\n\n    def __rdiv__(self, other):\n        return other.__rdiv__(self)\n\n    def __truediv__(self, other):\n        return self.__div__(other)\n\n    def __rtruediv__(self, other):\n        return other.__rdiv__(self)\n\n    def conjugate(self):\n        return Complex(self.real, -self.imag)\n\n    def __eq",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    z = complex number.\n\n    Returns the angle of z in radians.\n\n    >>> complex_angle(1 + 1j)\n    (0.7853981633974483 + 0.636970198721066j)\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\ndef main():\n    \"\"\"\n    Unit tests for complex_angle().\n    \"\"\"\n    assert complex_angle(1 + 1j) == 0.7853981633974483 + 0.636970198721066j\n    assert complex_angle(1j) == 0.7853981633974483j\n    assert complex_angle(1j) == 0.7853981633974483j\n    assert complex_angle(0) == 0\n    assert complex_angle(0j) == 0j\n    assert complex_angle(0j) == 0j\n    assert complex_angle(1) == 0.7853981633974483\n    assert complex_angle(1j) == 0.7853981633974483\n    assert complex_angle(1 + 2j) == 0.7853981633974483 + 1.256637061435917j\n    assert complex_angle(1 + 2j) == 0.7853981633974483 + 1.256637061435917j\n    assert complex_angle(1j + 2j) == 0.7853981633974483j + 1.256637061435917j\n    assert complex_angle(1 + 2j) == 0.7853981633974483 + 1.256637061435917j\n    assert complex_angle(1j + 2j) == 0.7853981633974483j + 1.256637061435917j\n    assert complex_angle(2 + 3j) == 0.7853981633974483 + 1.256637061435917j\n    assert complex_angle(2 + 3j) == 0.7853981633974483 + 1.256637061435917j\n    assert complex_angle(2j + 3j) == 0.7853981633974483j",
    "from utils import complex_num_to_real_imag\n\n\ndef angle(c):\n    \"\"\"\n    Compute the angle of a complex number.\n    :type c: complex\n    :rtype: float\n    \"\"\"\n    return c.real * 180 / 3.14159\n\n\ndef main():\n    \"\"\"\n    Test cases\n    \"\"\"\n    assert angle(1 + 2j) == 90\n    assert angle(1 + 3j) == 90\n    assert angle(1 + 4j) == 90\n    assert angle(1 + 5j) == 90\n    assert angle(1 + 6j) == 90\n    assert angle(1 + 7j) == 90\n    assert angle(1 + 8j) == 90\n    assert angle(1 + 9j) == 90\n    assert angle(1 + 10j) == 90\n    assert angle(1 + 11j) == 90\n    assert angle(1 + 12j) == 90\n    assert angle(1 + 13j) == 90\n    assert angle(1 + 14j) == 90\n    assert angle(1 + 15j) == 90\n    assert angle(1 + 16j) == 90\n    assert angle(1 + 17j) == 90\n    assert angle(1 + 18j) == 90\n    assert angle(1 + 19j) == 90\n    assert angle(1 + 20j) == 90\n    assert angle(1 + 21j) == 90\n    assert angle(1 + 22j) == 90\n    assert angle(1 + 23j) == 90\n    assert angle(1 + 24j) == 90\n    assert angle(1 + 25j) == 90\n    assert angle(1 + 26j) == 90\n    assert angle(1 + 27j) == 90\n    assert angle(1 + 28j) == 90\n    assert angle(1 + 29j) == 90\n    assert angle(1 + 30j) == 90\n    assert angle(1 + 31j) == 90\n    assert angle(1 + 32j) == 90\n    assert angle(1 + 33j) == 90\n    assert angle(1 + 34j) == 90\n    assert angle(1 + 35j) == 90\n    assert angle(1 + 36j) == 90\n    assert angle(1 + 37j) == 90",
    "#!/usr/bin/env python\n\ndef get_angle(z):\n    \"\"\"\n    For a complex number z, return its angle.\n    \"\"\"\n    return(math.atan2(z.real, z.imag))\n\nif __name__ == \"__main__\":\n    a = complex(1, 2)\n    print(get_angle(a))\n    b = complex(-3, 4)\n    print(get_angle(b))",
    "# Definition for a complex number.\nclass Complex:\n    def __init__(self, real=0.0, imag=0.0):\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        return '(%s + %si)' % (self.real, self.imag)\n\n    def __repr__(self):\n        return 'Complex(%r, %r)' % (self.real, self.imag)\n\n    def __mul__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Complex(self.real * other, self.imag * other)\n        else:\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __div__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Complex(self.real / other, self.imag / other)\n        else:\n            return Complex(self.real / other.real, self.imag / other.imag)\n\n    def __rdiv__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Complex(other / self.real, other / self.imag)\n        else:\n            return Complex(other.real / self.real, other.imag / self.imag)\n\n    def __add__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Complex(self.real + other, self.imag)\n        else:\n            return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Complex(self.real - other, self.imag)\n        else:\n            return Complex(",
    "def get_angle(z):\n    \"\"\"\n    z: A complex number.\n    Returns: The angle of z in radians.\n    \"\"\"\n    r = z.real\n    i = z.imag\n    return (r * r + i * i) / (2 * r)\n\nprint get_angle(complex(1, 2))",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    Input:\n        z = complex number\n    Output:\n        angle in radians\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\nif __name__ == '__main__':\n    z = complex(1, 0)\n    print(complex_angle(z))",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    For a complex number z, return the angle of z in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\ndef get_angle_radians(z):\n    \"\"\"\n    For a complex number z, return the angle of z in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\ndef get_angle_degrees(z):\n    \"\"\"\n    For a complex number z, return the angle of z in degrees.\n    \"\"\"\n    return math.degrees(math.atan2(z.imag, z.real))\n\ndef get_angle_degrees_radians(z):\n    \"\"\"\n    For a complex number z, return the angle of z in degrees.\n    \"\"\"\n    return math.degrees(math.atan2(z.imag, z.real))\n\ndef get_angle_radians_degrees(z):\n    \"\"\"\n    For a complex number z, return the angle of z in degrees.\n    \"\"\"\n    return math.degrees(math.atan2(z.imag, z.real))\n\nif __name__ == \"__main__\":\n    z = complex(3, 2)\n    print(get_angle(z))\n    print(get_angle_radians(z))\n    print(get_angle_degrees(z))\n    print(get_angle_degrees_radians(z))\n    print(get_angle_radians_degrees(z))",
    "class ComplexNumber(object):\n    \"\"\"\n    A complex number class.\n    \"\"\"\n    def __init__(self, real=0, imag=0):\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        return 'ComplexNumber(real=%s, imag=%s)' % (self.real, self.imag)\n\n    def __repr__(self):\n        return 'ComplexNumber(real=%s, imag=%s)' % (self.real, self.imag)\n\n    def __add__(self, other):\n        return ComplexNumber(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        return ComplexNumber(self.real * other.real - self.imag * other.imag,\n                             self.real * other.imag + self.imag * other.real)\n\n    def __rmul__(self, other):\n        return ComplexNumber(self.real * other, self.imag * other)\n\n    def __neg__(self):\n        return ComplexNumber(self.real * -1, self.imag * -1)\n\n    def __eq__(self, other):\n        if type(other) == type(self):\n            return self.real == other.real and self.imag == other.imag\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        return self.real < other.real and self.imag < other.imag\n\n    def __gt__(self, other):\n        return self.real > other.real and self.imag > other.imag\n\n    def __le__(self, other):\n        return self.real <= other.real and self.imag <= other.imag\n\n    def __ge__(self, other):\n        return self.real >= other.real and self.imag >= other.imag\n\n    def conjugate(self):\n        return ComplexNumber(self.real, -self.imag)\n\n    def magnitude(self):\n        return self.real * self.real + self.imag * self.imag\n\n    def phase(",
    "import math\n\ndef get_angle(complex_num):\n    \"\"\"\n    :type complex_num: complex\n    :rtype: float\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    Return the angle of complex number z.\n    \"\"\"\n\n    return math.atan2(z.imag, z.real)\n\nif __name__ == '__main__':\n    \"\"\"\n    Sample runs:\n\n    >>> complex_angle(1 + 1j)\n    3.14159265358979\n    >>> complex_angle(3 + 4j)\n    1.570826355036\n    >>> complex_angle(5 + 3j)\n    0.78539816339744\n    \"\"\"\n\n    z = 1 + 1j\n    print(complex_angle(z))\n    z = 3 + 4j\n    print(complex_angle(z))\n    z = 5 + 3j\n    print(complex_angle(z))",
    "import math\n\ndef complex_angle(z):\n    \"\"\"\n    :param z: Complex number\n    :return: angle in radians\n    \"\"\"\n    if z.imag == 0:\n        return math.atan(z.real)\n    else:\n        return math.atan(z.imag/z.real)\n\n\nif __name__ == \"__main__\":\n    test_cases = [[0, 0], [0, 1], [1, 1], [0, 0.5], [0, 0.25], [0.25, 0.25], [1, 1], [1, -1], [1, 0.5], [1, 0.25], [0.25, 0.25], [0.25, 0.75], [0.75, 0.25]]\n\n    for test_case in test_cases:\n        print(complex_angle(test_case))",
    "def get_angle(z):\n    \"\"\"\n    z is a complex number.\n\n    Return the angle of z in radians.\n    \"\"\"\n    return 2 * np.arctan2(z.imag, z.real)",
    "import math\n\n\ndef get_angle(z):\n    \"\"\"\n    Get the angle of a complex number.\n\n    :param z: the complex number\n    :return: the angle in radian\n    \"\"\"\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n    return theta\n\n\nif __name__ == '__main__':\n    z = complex(3.0, 4.0)\n    print(get_angle(z))",
    "def complex_angle(z):\n    \"\"\"\n    z: complex number\n    returns: angle in radians\n    \"\"\"\n    return np.arctan(z.imag / z.real)\n\nprint(complex_angle(complex(1, 2)))\nprint(complex_angle(complex(1, -2)))\nprint(complex_angle(complex(1, 0)))\nprint(complex_angle(complex(1, 1)))\nprint(complex_angle(complex(1, -1)))\nprint(complex_angle(complex(1, -2)))\nprint(complex_angle(complex(1, 3)))\nprint(complex_angle(complex(1, -3)))",
    "class Complex(object):\n    \"\"\"\n    Complex number.\n    \"\"\"\n\n    def __init__(self, real=0.0, imag=0.0):\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        return \"(\" + str(self.real) + \" + \" + str(self.imag) + \"i)\"\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __rmul__(self, other):\n        return Complex(self.real * other, self.imag * other)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __truediv__(self, other):\n        return Complex(self.real / other.real, self.imag / other.imag)\n\n    def __eq__(self, other):\n        return (self.real == other.real and self.imag == other.imag)\n\n    def __ne__(self, other):\n        return (self.real!= other.real or self.imag!= other.imag)\n\n    def __neg__(self):\n        return Complex(-self.real, -self.imag)\n\n    def __pos__(self):\n        return self\n\n    def conjugate(self):\n        return Complex(self.real, -self.imag)\n\n    def __abs__(self):\n        return (self.real * self.real + self.imag * self.imag) ** 0.5\n\n    def angle(self):\n        \"\"\"\n        Return the angle of the complex number in radians.\n        \"\"\"\n        return (self.imag / self.abs()) * (math.pi / 2)\n\n    def polar(self):\n        \"\"\"\n        Return a tuple (r, theta), where r is the magnitude and theta is the\n        angle in radians.\n        \"\"\"\n        return (",
    "def get_angle(complex_num):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n    \"\"\"\n    return 2 * math.atan2(math.sqrt(complex_num.real ** 2 + complex_num.imag ** 2), complex_num.real)\n\ndef test():\n    assert get_angle(complex_num = complex(3, 2)) == math.pi / 4\n    assert get_angle(complex_num = complex(3, -2)) == math.pi / 4\n    assert get_angle(complex_num = complex(-3, -2)) == math.pi / 4\n    assert get_angle(complex_num = complex(-3, 2)) == math.pi / 4\n    assert get_angle(complex_num = complex(3, -2)) == math.pi / 4\n    assert get_angle(complex_num = complex(-3, -2)) == math.pi / 4\n\nif __name__ == '__main__':\n    test()",
    "def angle(z):\n    \"\"\"\n    Input: a complex number\n    Output: the angle of the complex number\n    \"\"\"\n    #complex number is always a complex number\n    #print z\n    #print type(z)\n    #print z.real\n    #print z.imag\n    #print type(z.real)\n    #print type(z.imag)\n    if z.imag == 0:\n        if z.real > 0:\n            return math.pi / 2\n        else:\n            return math.pi / 2 * 3\n    else:\n        if z.real > 0:\n            return math.acos(z.real / abs(z.imag))\n        else:\n            return math.acos(z.real / abs(z.imag)) * 3\n\ndef main():\n    test_cases = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    for test in test_cases:\n        print \"angle of \", test[0], \" is \", angle(test[0])\n\nif __name__ == '__main__':\n    main()",
    "def angle(z):\n    \"\"\"\n    >>> angle(2+3j)\n    -0.4814351265486854\n    >>> angle(2+3j)\n    -0.4814351265486854\n    \"\"\"\n    return -1*z.imag/(z.real**2+z.imag**2)\n\ndef test():\n    assert angle(2+3j) == -0.4814351265486854\n    assert angle(3+4j) == 0.4814351265486854\n    assert angle(4+5j) == 0.4814351265486854\n    assert angle(5+6j) == 0.4814351265486854\n    assert angle(6+7j) == 0.4814351265486854\n    assert angle(7+8j) == 0.4814351265486854\n    assert angle(8+9j) == 0.4814351265486854\n    assert angle(9+10j) == 0.4814351265486854\n    assert angle(10+11j) == 0.4814351265486854\n    assert angle(11+12j) == 0.4814351265486854\n    assert angle(12+13j) == 0.4814351265486854\n    assert angle(13+14j) == 0.4814351265486854\n    assert angle(14+15j) == 0.4814351265486854\n    assert angle(15+16j) == 0.4814351265486854\n    assert angle(16+17j) == 0.4814351265486854\n    assert angle(17+18j) == 0.4814351265486854\n    assert angle(18+19j) == 0.4814351265486854\n    assert angle(19+20j) == 0.4814351265486854\n    assert angle(20+21j) == 0.4814351265486854\n    assert angle(21+22j) == 0.4814351265486854\n    assert angle(22",
    "def complex_angle(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    z: The complex number.\n\n    Return the angle of z in radians.\n    \"\"\"\n    # The angle of z can be written as the arccosine of z.\n    # Since z is a complex number, z.imag can be used to get the real part.\n    return np.arctan2(z.imag, z.real)\n\nif __name__ == '__main__':\n    z = complex(1.0, 0.0)\n    print(complex_angle(z))",
    "import math\n\n# print(math.degrees(math.atan2(1, 1)))\n# print(math.degrees(math.atan2(1, 0)))\n# print(math.degrees(math.atan2(0, 1)))\n# print(math.degrees(math.atan2(0, 0)))\n# print(math.degrees(math.atan2(-1, 1)))\n# print(math.degrees(math.atan2(-1, 0)))\n# print(math.degrees(math.atan2(-1, -1)))\n# print(math.degrees(math.atan2(-1, -0)))\n# print(math.degrees(math.atan2(-0, -1)))\n# print(math.degrees(math.atan2(-0, 0)))\n# print(math.degrees(math.atan2(-0, 1)))\n# print(math.degrees(math.atan2(-0, 1)))\n# print(math.degrees(math.atan2(-0, -1)))\n# print(math.degrees(math.atan2(-0, -0)))\n# print(math.degrees(math.atan2(0, -1)))\n# print(math.degrees(math.atan2(0, 0)))\n# print(math.degrees(math.atan2(0, 1)))\n# print(math.degrees(math.atan2(0, 1)))\n# print(math.degrees(math.atan2(0, -1)))\n# print(math.degrees(math.atan2(0, -0)))\n# print(math.degrees(math.atan2(1, -1)))\n# print(math.degrees(math.atan2(1, -0)))\n# print(math.degrees(math.atan2(1, 0)))\n# print(math.degrees(math.atan2(1, 1)))\n# print(math.degrees(math.atan2(1, 1)))\n# print(math.degrees(math.atan2(1, 0)))\n# print(math.degrees(math.atan2(1, -1)))\n# print(math.degrees(math.",
    "import math\n\ndef get_angle(z):\n    \"\"\"\n    :type z: complex\n    :rtype: float\n    \"\"\"\n    return math.atan(z.imag/z.real)*180/math.pi\n\nif __name__ == \"__main__\":\n    z = complex(1, 2)\n    print get_angle(z)\n    z = complex(1, -2)\n    print get_angle(z)\n    z = complex(1, 1)\n    print get_angle(z)\n    z = complex(1, 0)\n    print get_angle(z)\n    z = complex(1, -1)\n    print get_angle(z)\n    z = complex(1, -2)\n    print get_angle(z)\n    z = complex(1, -3)\n    print get_angle(z)",
    "import math\n\ndef angle(z):\n    \"\"\"\n    Return the angle of a complex number.\n\n    >>> angle(1+1j)\n    pi/4\n    >>> angle(1-1j)\n    pi/4\n    >>> angle(1-1j*I)\n    pi/2\n    >>> angle(1-1j*I+1)\n    3*pi/4\n    >>> angle(1-1j*I-1)\n    -3*pi/4\n    >>> angle(1-1j*I-1j)\n    -pi/4\n    >>> angle(1+1j*I)\n    3*pi/4\n    >>> angle(1-1j*I-1j*I)\n    -3*pi/4\n    >>> angle(1-1j*I-1j*I-1)\n    -pi/4\n    >>> angle(1-1j*I-1j*I-1j)\n    pi/4\n    >>> angle(1+1j*I+1j*I-1)\n    -3*pi/4\n    >>> angle(1-1j*I+1j*I-1j*I-1)\n    pi/4\n    >>> angle(1-1j*I+1j*I-1j*I+1)\n    3*pi/4\n    >>> angle(1-1j*I+1j*I-1j*I+1j)\n    -pi/4\n    >>> angle(1+1j*I+1j*I+1)\n    3*pi/4\n    >>> angle(1-1j*I+1j*I+1j*I+1j)\n    -3*pi/4\n    >>> angle(1+1j*I+1j*I-1j)\n    pi/4\n    >>> angle(1-1j*I+1j*I-1j*I+1j*I)\n    -3*pi/4\n    >>> angle(1+1j*I+1j*I-1j*I+1j*I+1)\n    3*pi/4\n    >>> angle(1-1j*I",
    "import math\n\n\ndef complex_angle(z):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    z is a complex number.\n\n    Return the angle in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\n# Test Cases\nprint(\"Test Case 1:\")\nprint(complex_angle(complex(1, 2)))\nprint(\"Test Case 2:\")\nprint(complex_angle(complex(1, 0)))\nprint(\"Test Case 3:\")\nprint(complex_angle(complex(0, 1)))\nprint(\"Test Case 4:\")\nprint(complex_angle(complex(0, -1)))\nprint(\"Test Case 5:\")\nprint(complex_angle(complex(1, 1)))\nprint(\"Test Case 6:\")\nprint(complex_angle(complex(-1, 1)))\nprint(\"Test Case 7:\")\nprint(complex_angle(complex(-1, -1)))\nprint(\"Test Case 8:\")\nprint(complex_angle(complex(1, -1)))\nprint(\"Test Case 9:\")\nprint(complex_angle(complex(-1, -1)))\nprint(\"Test Case 10:\")\nprint(complex_angle(complex(0, 0)))\nprint(\"Test Case 11:\")\nprint(complex_angle(complex(0, 1)))\nprint(\"Test Case 12:\")\nprint(complex_angle(complex(1, 0)))\nprint(\"Test Case 13:\")\nprint(complex_angle(complex(0, -1)))\nprint(\"Test Case 14:\")\nprint(complex_angle(complex(1, 1)))\nprint(\"Test Case 15:\")\nprint(complex_angle(complex(-1, 1)))\nprint(\"Test Case 16:\")\nprint(complex_angle(complex(1, -1)))\nprint(\"Test Case 17:\")\nprint(complex_angle(complex(-1, -1)))",
    "import math\n\ndef get_angle(complex_num):\n    \"\"\"\n    :type complex_num: complex\n    :rtype: float\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)\n\nif __name__ == '__main__':\n    complex_num = complex(1, 1)\n    print(get_angle(complex_num))",
    "class Complex(object):\n    \"\"\"\n    A complex number with real and imaginary part.\n    \"\"\"\n\n    def __init__(self, real=0.0, imag=0.0):\n        \"\"\"\n        Initialize a new instance.\n        \"\"\"\n        self.real = real\n        self.imag = imag\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of the complex number.\n        \"\"\"\n        return \"(\" + str(self.real) + \" + \" + str(self.imag) + \"i)\"\n\n    def __repr__(self):\n        \"\"\"\n        Return a representation of the complex number.\n        \"\"\"\n        return \"Complex(\" + str(self.real) + \" + \" + str(self.imag) + \"i)\"\n\n    def __add__(self, other):\n        \"\"\"\n        Add two complex numbers.\n        \"\"\"\n        if isinstance(other, Complex):\n            return Complex(self.real + other.real, self.imag + other.imag)\n        else:\n            return NotImplemented\n\n    def __radd__(self, other):\n        \"\"\"\n        Add two complex numbers.\n        \"\"\"\n        if isinstance(other, Complex):\n            return Complex(self.real + other.real, self.imag + other.imag)\n        else:\n            return NotImplemented\n\n    def __sub__(self, other):\n        \"\"\"\n        Subtract two complex numbers.\n        \"\"\"\n        if isinstance(other, Complex):\n            return Complex(self.real - other.real, self.imag - other.imag)\n        else:\n            return NotImplemented\n\n    def __rsub__(self, other):\n        \"\"\"\n        Subtract two complex numbers.\n        \"\"\"\n        if isinstance(other, Complex):\n            return Complex(other.real - self.real, other.imag - self.imag)\n        else:\n            return NotImplemented\n\n    def __mul__(self, other):\n        \"\"\"\n        Multiply two complex numbers.\n        \"\"\"\n        if isinstance(other, Complex):\n            return Complex(self.real * other.real - self.imag * other.imag,\n                           self.",
    "# https://github.com/lh3/part-1/blob/master/complex_angle.py\n\ndef get_angle(complex_num):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input of this function is the complex number whose angle will be calculated.\n    The output is the angle in radians.\n    \"\"\"\n    radian = complex_num.imag / abs(complex_num)\n    return 2 * np.arctan(radian)\n\ndef get_angle_2(complex_num):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input of this function is the complex number whose angle will be calculated.\n    The output is the angle in radians.\n    \"\"\"\n    radian = complex_num.imag / abs(complex_num)\n    return 2 * np.arctan(radian) + np.pi / 2\n\ndef main():\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    The input of this function is the complex number whose angle will be calculated.\n    The output is the angle in radians.\n    \"\"\"\n    complex_num = complex(0.5, -1.5)\n    print(get_angle(complex_num))\n    print(get_angle_2(complex_num))\n\nif __name__ == '__main__':\n    main()",
    "def get_angle(complex_number):\n    \"\"\"\n    Input: A complex number.\n    Output: The angle of the complex number.\n    \"\"\"\n    if complex_number.real == 0:\n        if complex_number.imag == 0:\n            return 0\n        return math.pi / 2\n    elif complex_number.imag == 0:\n        return math.pi / 2\n    elif complex_number.real == -1:\n        return math.pi\n    elif complex_number.real == 1:\n        return 0\n    elif complex_number.real == 0 and complex_number.imag > 0:\n        return math.pi / 2\n    elif complex_number.real == 0 and complex_number.imag < 0:\n        return math.pi\n    elif complex_number.real < 0 and complex_number.imag == 0:\n        return math.pi * 3 / 2\n    elif complex_number.real > 0 and complex_number.imag == 0:\n        return math.pi * 5 / 2\n    elif complex_number.real > 0 and complex_number.imag < 0:\n        return math.pi * 7 / 2\n    else:\n        return math.pi * 9 / 2",
    "import math\n\n\ndef angle(z):\n    \"\"\"\n    z is complex number, the angle of z.\n    Return the angle in radians.\n    \"\"\"\n    return math.atan(z.imag / z.real)\n\n\nif __name__ == '__main__':\n    z = complex(1, 2)\n    print angle(z)",
    "def get_angle(z):\n    return (z.imag / abs(z)) * (180 / 3.141592653589793)\n\nif __name__ == \"__main__\":\n    print(get_angle(complex(3, 4)))",
    "class Complex(object):\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __radd__(self, other):\n        return Complex(other.real + self.real, other.imag + self.imag)\n\n    def __mul__(self, other):\n        return Complex(self.real * other.real - self.imag * other.imag,\n                       self.real * other.imag + self.imag * other.real)\n\n    def __rmul__(self, other):\n        return Complex(other.real * self.real - other.imag * self.imag,\n                       other.real * self.imag + other.imag * self.real)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __rsub__(self, other):\n        return Complex(other.real - self.real, other.imag - self.imag)\n\n    def __pow__(self, exponent):\n        if exponent == 0:\n            return 1\n        elif exponent % 2 == 0:\n            return self.__pow__(exponent / 2) * self\n        else:\n            return self * self.__pow__(exponent - 1)\n\n    def __str__(self):\n        return \"Complex({}, {})\".format(self.real, self.imag)\n\ndef get_angle(z):\n    \"\"\"\n    Return the angle of z.\n    \"\"\"\n    if z.imag == 0:\n        return 0.0\n    else:\n        return -1.0 * math.atan(z.imag / z.real)\n\nif __name__ == '__main__':\n    print(get_angle(Complex(1, 2)))\n    print(get_angle(Complex(1, -2)))\n    print(get_angle(Complex(-1, 2)))\n    print(get_angle(Complex(-1, -2)))",
    "def get_angle(c):\n    \"\"\"\n    :param c: a complex number\n    :return: the angle of the complex number\n    \"\"\"\n    return math.atan(c.imag / c.real)\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (1+1j),\n        (1-1j),\n        (0+1j),\n        (0-1j),\n        (1+1j*1j),\n        (1-1j*1j),\n        (1+1j*1j*1j),\n        (1-1j*1j*1j),\n        (1+1j*1j*1j*1j),\n        (1-1j*1j*1j*1j),\n        (1+1j*1j*1j*1j*1j),\n        (1-1j*1j*1j*1j*1j),\n    ]\n\n    for c in test_cases:\n        print(\"Angle of {0} is {1}\".format(c, get_angle(c)))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}