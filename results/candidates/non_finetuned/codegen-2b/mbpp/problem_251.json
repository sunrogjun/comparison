{
  "problem": {
    "task_id": "MBPP/262",
    "prompt": "Write a function to split a given list into two parts where the length of the first part of the list is given.",
    "canonical_solution": "def split_two_parts(list1, L):\r\n    return list1[:L], list1[L:]",
    "test_list": [
      "assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])",
      "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])",
      "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"
    ],
    "challenge_test_list": [],
    "problem_id": 251
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n__author__ = 'Daniel'\n\nimport unittest\n\n\nclass Solution:\n    def partition(self, nums, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type left: int\n        :type right: int\n        :rtype: List[int]\n        \"\"\"\n        if left >= right:\n            return [], []\n\n        i = left\n        j = right\n\n        pivot = nums[left]\n\n        while i < j:\n            while i < right and nums[i] < pivot:\n                i += 1\n            while j > left and nums[j] > pivot:\n                j -= 1\n\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                return [nums[left:i], nums[i:right]], [nums[j+1:right], nums[right:]]\n\n        return [nums[left:i], nums[i:right]], [nums[j+1:right], nums[right:]]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4, 5], 1, 4, [1, 2, 3, 4, 5])\n        self._test([1, 2, 3, 4, 5], 0, 3, [1, 2, 3, 4])\n        self._test([1, 2, 3, 4, 5], 1, 3, [1, 2, 3])\n        self._test([1, 2, 3, 4, 5], 1, 2, [1, 2])\n        self._test([1, 2, 3, 4, 5], 0, 1, [1])\n\n    def _test(self, nums, left, right, expect):\n        actual = Solution().partition(nums, left, right)\n        self.assertEqual(len(expect[0]), len(expect[1]))\n        self.assertEqual(len(expect[0]), len(actual[0",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def partition(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        p = dummy\n        while p.next:\n            p = p.next\n        p = dummy\n        while p.next and p.next.next:\n            q = p.next\n            if q.next.next:\n                p.next = q.next\n                q.next = q.next.next\n            else:\n                p.next = q.next\n                q.next = None\n            p = p.next\n        p.next = q.next\n        p = dummy\n        while p.next:\n            q = p.next\n            if q.next:\n                p.next = q.next\n                q.next = q.next.next\n            else:\n                p.next = None\n            p = p.next\n        return dummy.next",
    "#!/usr/bin/env python\n\nimport random\n\n# Your code here\ndef splitList(nums, k):\n    if len(nums) < k:\n        return []\n    \n    return [nums[0:k], nums[k:]]\n\ndef splitList2(nums, k):\n    if len(nums) < k:\n        return []\n    \n    k = k - 1\n    kth = random.randint(0, k)\n    return [nums[0:kth], nums[kth:]]\n    \n    \n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    k = 3\n    print splitList(nums, k)\n    print splitList2(nums, k)",
    "class Solution(object):\n    def partition(self, list, k):\n        \"\"\"\n        :type list: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = 0\n        j = 0\n        res = []\n        while i < len(list):\n            if j == k:\n                res.append(list[i:])\n                j = 0\n                i += 1\n            else:\n                res[j].append(list[i])\n                j += 1\n            i += 1\n        if j!= k:\n            res.append(list[i:])\n        return res\n\n\nif __name__ == '__main__':\n    print(Solution().partition([1, 2, 3], 2))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        delta = m - slow.val\n\n        # split first part\n        p = slow.next\n        slow.next = None\n        # split second part\n        q = p.next\n        p.next = None\n\n        return p, q\n\n\nif __name__ == \"__main__\":\n    print Solution().splitList(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 3)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        fast = head\n        while m:\n            fast = fast.next\n            m -= 1\n\n        slow.next = None\n        return head\n\n    def splitList2(self, head):\n        \"\"\"\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = None\n        return head\n\n\nif __name__ == \"__main__\":\n    assert Solution().splitList(ListNode(1, 2, 3), 2) == ListNode(1, 2, 3)\n    assert Solution().splitList(ListNode(1, 2, 3, 4), 3) == ListNode(1, 2, 3, 4)\n    assert Solution().splitList(ListNode(1, 2, 3, 4, 5), 4) == ListNode(1, 2, 3, 4, 5)\n    assert Solution().splitList(ListNode(1, 2, 3, 4, 5, 6), 5) == ListNode(1, 2, 3, 4, 5)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        main idea:\n            recursive\n            for m\n            if m<0\n                split to left\n                return\n            else\n                split to right\n                return\n        :param head: the head of linked list\n        :param m: the mth element in the list to split\n        :return: a tuple of two lists\n        \"\"\"\n        if head is None or head.next is None:\n            return head, head\n        dummy = ListNode(0)\n        dummy.next = head\n        n = 0\n        pre = dummy\n        while head.next is not None:\n            pre = pre.next\n            n += 1\n            if n == m:\n                break\n        if n == m:\n            return head, dummy.next\n        elif n < m:\n            return self.splitList(pre, m - n)\n        else:\n            return self.splitList(dummy.next, m - n)\n\n\nif __name__ == \"__main__\":\n    sln = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    for i in range(1, len(nums) + 1):\n        print(i, sln.splitList(ListNode(nums[:i]), i).val)",
    "#\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitList(self, head: ListNode, m: int) -> ListNode:\n        if m == 0:\n            return head\n        \n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            if m == 0:\n                break\n            else:\n                m -= 1\n                slow = slow.next\n        \n        if fast:\n            slow.next = fast.next\n        else:\n            slow.next = None\n        \n        return head",
    "#!/usr/bin/env python\n# coding=utf-8\n\nimport time\n\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        new_head = head\n        new_tail = head\n        next_head = head.next\n        while next_head:\n            new_head = next_head\n            next_head = next_head.next\n            new_tail = new_tail.next\n\n        new_head.next = None\n        return new_head\n\nif __name__ == \"__main__\":\n    start_time = time.time()\n    print Solution().splitList(ListNode(1, ListNode(2, ListNode(3))))\n    print time.time() - start_time",
    "class Solution(object):\n    def partition(self, nums, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type left: int\n        :type right: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if left >= right:\n            return [nums[left:right]]\n\n        pivot = self.partition(nums, left, (left + right) / 2)\n        return [nums[:left], self.partition(nums, (left + right) / 2 + 1, right)]",
    "# https://oj.leetcode.com/problems/split-list-into-two-parts/\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def splitListToParts(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # split list into 2 parts\n        left_head = head\n        right_head = head.next\n        head = head.next\n        while head and len(right_head.next) > k:\n            head, right_head = right_head, right_head.next\n        right_head.next = None\n        \n        # split list into 2 parts\n        left_head.next = right_head\n        right_head.next = None\n        \n        return left_head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def partition(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # write your code here\n        dummy = ListNode(0)\n        dummy.next = head\n        pivot = dummy\n        while pivot.next:\n            pivot = pivot.next\n        pivot = pivot.next\n        for i in range(k):\n            pivot = pivot.next\n        pivot = pivot.next\n        pivot.next = dummy.next\n        pivot.next = None\n        head = dummy.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            head2 = ListNode(0)\n            head2.next = head\n            return head2\n        if m == 0:\n            return head\n        head2 = ListNode(0)\n        head2.next = head\n        head2.next.next = head.next\n        head.next = head2.next\n        head2.val += head.val\n        head2.val /= m\n        head2.val *= 2\n        head2.val += head.val\n        return head2",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param k, an integer\n\t# @return a ListNode\n\tdef splitListToParts(self, head, k):\n\t\tif not head or not head.next:\n\t\t\treturn head\n\n\t\tdummy = ListNode(0)\n\t\tdummy.next = head\n\t\tp = dummy\n\t\twhile p.next and k > 0:\n\t\t\tp = p.next\n\t\t\tk -= 1\n\n\t\tif p.next:\n\t\t\tp.next = p.next.next\n\n\t\twhile p.next:\n\t\t\tp = p.next\n\t\t\tk -= 1\n\n\t\tp.next = None\n\t\treturn dummy.next\n\n\nif __name__ == \"__main__\":\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\n\ts = Solution()\n\tprint s.splitListToParts(head, 6)\n\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\thead.next.next.next.next.next.next = ListNode(7)\n\n\ts = Solution()\n\tprint s.splitListToParts(head, 6)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        main idea:\n            use two pointers\n            if current list is too short, split current list into two parts\n            if current list is too long, do nothing\n            if current list is OK, split current list into two parts\n        :param head: the current node of linked list\n        :param m: the length of the first list\n        :return: two lists\n        \"\"\"\n        if head is None:\n            return []\n\n        p1, p2 = head, None\n        while p1:\n            p2 = p1.next\n            if p2 is None:\n                break\n\n            p1 = p1.next\n            if p1 is None:\n                break\n\n        if p1 is None:\n            return []\n\n        p2 = p1.next\n        if p2 is None:\n            return [head, None]\n\n        # split list into two parts\n        if m < 1:\n            return [head, p2]\n\n        p2 = p2.next\n        if p2 is None:\n            return [head, p2]\n\n        if m == 1:\n            return [head, p2]\n\n        # split list into two parts\n        while p2:\n            p2 = p2.next\n            if p2 is None:\n                return [head, p2]\n\n        return [head, None]\n\n\nif __name__ == \"__main__\":\n    assert Solution().splitList([1, 2, 3, 4], 2) == [1, 2, 3, 4]",
    "import sys\n\nif len(sys.argv) < 2:\n    print(\"Please provide the input list as the first argument.\")\n    exit(1)\n\nif len(sys.argv) == 2:\n    print(\"Please provide the length of the first part as the second argument.\")\n    exit(1)\n\ndef partition(l, n):\n    \"\"\"\n    Partition a list into two parts.\n    :param l: list\n    :param n: int\n    :return: two lists\n    \"\"\"\n    # create the first list\n    first = []\n    for i in range(len(l)):\n        if i < n:\n            first.append(l[i])\n    # create the second list\n    second = []\n    for i in range(n, len(l)):\n        second.append(l[i])\n    return first, second\n\ndef main():\n    l = sys.argv[1]\n    n = int(sys.argv[2])\n    first, second = partition(l, n)\n    print(first)\n    print(second)\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        cur = dummy\n        while cur.next:\n            cur = cur.next\n            if cur.next:\n                cur.next = cur.next.next\n        p1 = dummy\n        p2 = dummy\n        while p1.next:\n            p2.next = p1.next\n            p1 = p1.next\n            p2 = p2.next\n        p2.next = None\n        p1 = dummy\n        p2 = dummy\n        while p1.next:\n            p1 = p1.next\n            p2 = p2.next\n        p1.next = None\n        p2.next = None\n        return dummy.next",
    "class Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow, fast",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/list-split\n\n# Complete the listSplit function below.\ndef listSplit(A):\n    # Complete this function\n    B=[]\n    for i in A:\n        if len(B)<len(A):\n            B.append(i)\n        else:\n            B.append(i)\n    return B",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def partition(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        p1, p2 = ListNode(0), ListNode(0)\n        p1.next = head\n        p2.next = head\n        head = head.next\n        while head is not None:\n            if len(p2.next) < k:\n                p2.next = ListNode(0)\n                p2 = p2.next\n            p2.next.next = head\n            head = head.next\n        p1.next = p2.next\n        return p1.next",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, k):\n        \"\"\"\n        K is the size of the first part.\n\n        :param head: the head node of linked list\n        :param k: the length of the first part\n        :return: the head of the first part, the rest of the linked list\n        \"\"\"\n        if not head or not k:\n            return head, None\n\n        dummy = [None]\n        dummy.append(head)\n        cur = dummy[0]\n        i = 0\n        while i < k and cur:\n            cur = cur[0]\n            i += 1\n\n        if i == k:\n            return cur, dummy[1:]\n\n        # remove the tail of the first part\n        dummy[0] = cur\n        return dummy[0], dummy[1:]\n\n    def splitList2(self, head, k):\n        \"\"\"\n        K is the size of the first part.\n\n        :param head: the head node of linked list\n        :param k: the length of the first part\n        :return: the head of the first part, the rest of the linked list\n        \"\"\"\n        if not head or not k:\n            return head, None\n\n        cur = head\n        dummy = [None]\n        dummy.append(head)\n        i = 0\n        while i < k and cur:\n            cur = cur[0]\n            i += 1\n\n        if i == k:\n            return cur, dummy[1:]\n\n        # remove the tail of the first part\n        dummy[0] = cur\n        return dummy[0], dummy[1:]\n\n\nif __name__ == \"__main__\":\n    print Solution().splitList( [1,2,3,4,5,6], 3)",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def splitList(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        if k == 1:\n            return head\n        pivot = head\n        cur = head.next\n        while cur.next is not None:\n            pivot = cur\n            cur = cur.next\n        pivot.next = None\n        return self.splitList(pivot, k-1)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Write your code here\n        if not head or not head.next:\n            return head\n        else:\n            p = head\n            q = head\n            while q.next:\n                q = q.next\n                p = p.next\n\n            i = 1\n            while p:\n                p = p.next\n                i += 1\n                if i % 2 == 0:\n                    p = p.next\n\n            p = head\n            q = head\n            while q:\n                if i % 2 == 0:\n                    p = p.next\n                else:\n                    q = q.next\n                p = p.next\n                q = q.next\n\n            p.next = None\n            return head",
    "class Solution(object):\n    def partition(self, nums, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type left: int\n        :type right: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if left >= right:\n            return [[nums[left]], []]\n        else:\n            mid = (left + right) / 2\n            head = [nums[left]]\n            tail = []\n            for i in range(mid, right):\n                tail.append(nums[i])\n            return [[head], [tail]]\n\n# TESTS\nfor nums, left, right, expected in [\n    ([1, 2, 3], 1, 3, [[1, 2, 3]]),\n    ([1, 2, 3], 1, 2, [[1, 2], [3]]),\n    ([1, 2, 3, 4, 5], 1, 3, [[1, 2, 3], [4, 5]]),\n]:\n    sol = Solution()\n    actual = sol.partition(nums, left, right)\n    print(actual)\n    assert actual == expected",
    "# Definition for a binary tree node.\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param {TreeNode} root\n\t# @param {integer} k\n\t# @return {TreeNode[]}\n\tdef kthSmallest(self, root, k):\n\t\tresult = []\n\t\tstack = [root]\n\t\twhile stack:\n\t\t\tnode = stack.pop()\n\t\t\tif node is None:\n\t\t\t\tcontinue\n\t\t\tresult.append(node)\n\t\t\tif len(stack) == 0 or node.val < stack[-1].val:\n\t\t\t\tstack.append(node.left)\n\t\t\telse:\n\t\t\t\tstack.append(node.right)\n\t\treturn result[:k]\n\nif __name__ == \"__main__\":\n\tsolution = Solution()\n\troot = TreeNode(1)\n\troot.left = TreeNode(2)\n\troot.right = TreeNode(3)\n\troot.left.left = TreeNode(4)\n\troot.left.right = TreeNode(5)\n\troot.right.left = TreeNode(6)\n\troot.right.right = TreeNode(7)\n\tprint(solution.kthSmallest(root, 2))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        pivot = head.next\n        head.next = None\n        while pivot.next is not None:\n            pivot = pivot.next\n            if pivot.next is not None:\n                pivot.next = pivot.next.next\n        pivot.next = None\n\n        head = self.splitList(head, m)\n        return head\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    print Solution().splitList(head, n)",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param {ListNode[]} nodes\n    # @param {int} m\n    # @return {ListNode[]}\n    def splitListToParts(self, nodes, m):\n        if len(nodes) == 0:\n            return []\n        if len(nodes) <= m:\n            return [nodes]\n        \n        head, tail = self.splitListToParts(nodes, m)\n        head.insert(0, nodes[0])\n        return head + tail",
    "class Solution:\n    # @return a tuple, (index of second part, length of second part)\n    def partition(self, nums, left, right):\n        i = left\n        j = right\n        while i < j:\n            while i < j and nums[i] < nums[left]:\n                i += 1\n            while i < j and nums[j] >= nums[left]:\n                j -= 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j -= 1\n        if i < right:\n            nums[i], nums[right] = nums[right], nums[i]\n        return i, j - i + 1",
    "def split_list(lst, split_len):\n    if len(lst) < split_len:\n        return lst, []\n    else:\n        return lst[:split_len], lst[split_len:]\n\ndef test_split_list():\n    assert split_list([], 1) == ([], [])\n    assert split_list([1], 1) == ([1], [])\n    assert split_list([1, 2, 3], 2) == ([1, 2], [3])\n    assert split_list([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])\n    assert split_list([1, 2, 3, 4, 5, 6], 3) == ([1, 2, 3], [4, 5, 6])\n\nif __name__ == \"__main__\":\n    test_split_list()",
    "class Solution(object):\n    def splitList(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        pre = head\n        cur = head.next\n        while cur:\n            if len(pre.next) % k:\n                cur = cur.next\n                continue\n            pre = pre.next\n            cur = cur.next\n            pre.next = cur.next\n            cur.next = None\n            pre.next.next = head\n            return pre.next\n        return head",
    "# https://www.hackerrank.com/challenges/split-a-list-into-two-parts\n\ndef split_list(lst, n):\n    res = []\n    for i in range(0, n):\n        res.append(lst.pop(0))\n    res.extend(lst)\n    return res\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    n = 3\n    print split_list(lst, n)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def splitList(self, head: ListNode, k: int) -> ListNode:\n        # write your code here\n        curr = head\n        while curr:\n            curr = curr.next\n            k -= 1\n            if k == 0:\n                break\n        \n        if k == 0:\n            return head\n        \n        newHead = ListNode(0)\n        newHead.next = head\n        prev = newHead\n        while curr:\n            curr = curr.next\n            prev.next = curr\n            prev = prev.next\n        \n        return newHead.next\n\n# Note:\n# This is a tricky question.\n# You can't split the list into two parts in O(n) time and O(1) extra space.\n# The problem is that the length of the second part is not known until you split the list.\n# You can solve it by using a stack.",
    "class Solution:\n    # @param nums: A list of integer\n    # @param k: The length of the first part\n    # @return: A list of list\n    def partition(self, nums, k):\n        if not nums:\n            return []\n\n        l = []\n        r = []\n\n        for i in range(len(nums)):\n            if len(l) >= k:\n                r.append(nums[i])\n            else:\n                l.append(nums[i])\n\n        return [l, r]\n\n\nif __name__ == '__main__':\n    s = Solution()\n\n    print s.partition([1, 2, 3, 4, 5], 3)\n    print s.partition([1, 2, 3, 4, 5], 4)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        dummy2 = dummy\n        while dummy.next:\n            dummy = dummy.next\n            dummy2 = dummy2.next\n        if dummy.next:\n            dummy.next = None\n        dummy2.next = dummy.next\n        return dummy2.next",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitIntoEvenParts(self, nums):\n        \"\"\"\n        Binary Search\n\n        :param nums: List[int]\n        :return: List[List[int]]\n        \"\"\"\n        nums = sorted(nums)\n        ans = []\n        for i in range(0, len(nums)):\n            if i == 0:\n                ans.append(nums[:i+1])\n            elif i == len(nums)-1:\n                ans.append(nums[i-1::-1])\n            else:\n                left = nums[i-1::-1]\n                right = nums[i+1::-1]\n                while left <= right:\n                    mid = left + (right-left)/2\n                    if mid in nums:\n                        ans.append([nums[i-1::-1], nums[i:mid], nums[mid+1::-1]])\n                        break\n                    elif mid > nums[-1]:\n                        ans.append([nums[i-1::-1], nums[i:mid], nums[mid+1::-1]])\n                        break\n                    elif mid < nums[-1]:\n                        ans.append([nums[i-1::-1], nums[i:mid], nums[:mid]])\n                        break\n                    else:\n                        left = mid+1\n                    if left > right:\n                        ans.append([nums[i-1::-1], nums[i:right], nums[:right]])\n                        break\n        return ans\n\n\nif __name__ == \"__main__\":\n    print Solution().splitIntoEvenParts([1,2,3])",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def splitListToParts(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not k:\n            return head\n        if not k:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        while k > 1:\n            curr = curr.next\n            k -= 1\n        while curr.next:\n            curr = curr.next\n        curr.next = None\n        return dummy.next\n\n# Note:\n# If the number of parts is k, we can split the list into k parts, and each part is a single-linked list.\n# If the number of parts is k-1, we can split the list into k-1 parts, and each part is a double-linked list.\n# If the number of parts is k+1, we can split the list into k+1 parts, and each part is a trie.",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if m == 0 or head == None:\n            return head\n        curr = head\n        for i in range(m):\n            curr = curr.next\n        left_head = curr\n        curr = head\n        for i in range(m, 0, -1):\n            curr = curr.next\n        right_head = curr\n        curr.next = None\n        return left_head, right_head",
    "class Solution:\n    # @param nums: A list of integers\n    # @return: A list of lists\n    def splitList(self, nums):\n        if not nums:\n            return [[]]\n        \n        left = []\n        right = []\n        \n        for i in range(len(nums)):\n            if i == 0:\n                left.append(nums[i])\n            elif i == len(nums) - 1:\n                right.append(nums[i])\n            else:\n                left.append(nums[i])\n                right.append(nums[i])\n        \n        return left, right",
    "#!/usr/bin/env python\n\"\"\"\nGiven a list, split the list into two parts where the length of the first part of the list is given.\n\nFor example:\nGiven a list [1,2,3,4,5], and the length of the first part is 2, the second part should be [3,4,5].\n\nNote:\nYou may assume the list's length does not exceed 10000, and the split points must be in the range of [0, 10000].\n\"\"\"\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        p = dummy\n        while p.next and p.next.next:\n            p = p.next\n            m -= 1\n            if m == 0:\n                break\n        if m == 0:\n            return dummy.next\n        p.next = None\n        return dummy.next\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nif __name__ == '__main__':\n    solution = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    print solution.splitList(head, 2)",
    "# The input is a list of integers\n# The output is a list of lists\n# The length of the first list is given\n\ndef split_list(lst, n):\n    if len(lst) < n:\n        return lst\n    else:\n        return [lst[0:n], lst[n:]]\n\n# Your function should return the list of lists that the input list is split into.\n\n# Note:\n\n# The length of the input list is given in the input.\n# The length of the first list is n and the length of the second list is n-1.\n\n# Example 1:\n\n# Input: lst = [1,2,3,4,5,6], n = 3\n# Output: [[1,2,3], [4,5,6]]\n\n# Example 2:\n\n# Input: lst = [1,2,3,4,5,6], n = 2\n# Output: [[1,2], [3,4], [5,6]]\n\n# Example 3:\n\n# Input: lst = [1,2,3,4,5,6], n = 6\n# Output: [[1,2,3,4,5,6]]",
    "import collections\nimport unittest\n\n\nclass Solution:\n    def partition(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums or nums[0] < 0 or nums[0] > k:\n            return [[]]\n        nums_len = len(nums)\n        if nums_len <= k:\n            return [[nums[:k]]]\n        if nums_len % k == 0:\n            return [[nums[i:i + k] for i in range(0, nums_len, k)]]\n        elif nums_len % k == 1:\n            return [[nums[i:i + k] for i in range(0, nums_len, k)], [nums[nums_len - k:]]]\n        else:\n            return [[nums[i:i + k] for i in range(0, nums_len, k)],\n                    [nums[nums_len - k:]]]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4, 5], 2, [[1, 2], [3, 4], [5]])\n        self._test([1, 2, 3, 4, 5], 3, [[1, 2, 3], [4, 5]])\n        self._test([1, 2, 3, 4, 5], 4, [[1, 2, 3, 4], [5]])\n        self._test([1, 2, 3, 4, 5], 5, [[1, 2, 3, 4, 5]])\n\n    def _test(self, nums, k, expected):\n        actual = Solution().partition(nums, k)\n        self.assertEqual(len(actual), len(expected))\n        for i in range(len(actual)):\n            self.assertEqual(len(actual[i]), len(expected[i]))\n            self.assertEqual(sorted(actual[i]), sorted(expected[i]))\n\n\nif __name__",
    "class Solution(object):\n    def splitIntoTwo(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return None\n        if len(nums) == 1:\n            return [nums, []]\n        \n        start = 0\n        end = 0\n        while start < len(nums):\n            end += 1\n            if end == len(nums):\n                end = 0\n            if end == start:\n                break\n            if nums[end]!= nums[start]:\n                break\n        \n        if start == len(nums) - 1:\n            return [nums[:start], nums[start:]]\n        \n        return [nums[:start], nums[start:end], nums[end:]]",
    "# https://www.hackerrank.com/challenges/split-a-list/problem\n\n# Complete the splitList function below.\ndef splitList(self, inputList, length):\n    return [inputList[:length], inputList[length:]]",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        p = head\n        q = head\n        while p.next:\n            p = p.next\n            q = q.next\n        q.next = None\n        return head\n\n    def splitList_iter(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n\n        p = head\n        q = None\n        while p:\n            p = p.next\n            if not q:\n                q = p\n            else:\n                q.next = p\n            q = p\n        return head\n\na = ListNode(1)\na.next = ListNode(2)\na.next.next = ListNode(3)\na.next.next.next = ListNode(4)\na.next.next.next.next = ListNode(5)\n\ns = Solution()\nprint s.splitList(a)\nprint s.splitList_iter(a)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def splitIntoPieces(self, A, k):\n        \"\"\"\n        Two pointers\n        :param A: list\n        :param k: int\n        :return: list\n        \"\"\"\n        if not A:\n            return []\n\n        if len(A) < k:\n            return [A]\n\n        # split\n        left = [A[0]]\n        right = [A[0]]\n        for i in xrange(1, len(A)):\n            if left[-1] + 1 == k:\n                left.append(A[i])\n                right.append(A[i])\n            else:\n                left.append(A[i])\n        return left + right\n\n\nif __name__ == \"__main__\":\n    print Solution().splitIntoPieces([1,2,3,4,5], 2)",
    "# https://oj.leetcode.com/problems/split-array-into-two-parts/\n# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport unittest\n\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {integer} sum\n    # @return {TreeNode[]}\n    def splitArray(self, root, sum):\n        return self.helper(root, sum)\n\n    def helper(self, root, sum):\n        if root is None:\n            return []\n        if root.left is None and root.right is None:\n            return [root]\n        if root.left is None:\n            if sum - root.val > 0:\n                return self.helper(root.right, sum)\n            else:\n                return [root]\n        if root.right is None:\n            if sum - root.val > 0:\n                return self.helper(root.left, sum)\n            else:\n                return [root]\n        if sum - root.val > 0:\n            return self.helper(root.left, sum)\n        else:\n            return self.helper(root.right, sum)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/split-array-into-two-parts/solution/\n#\nApproach #1: Recursion [Accepted]\nComplexity Analysis\nTime Complexity: O(N), where N is the number of nodes in the tree.\nSpace Complexity: O(N)\n\n# 6ms 100%\nclass Solution {\n    public List<TreeNode> splitArray(TreeNode root, int sum) {\n        List<TreeNode> res = new ArrayList<>();\n        if (root == null)",
    "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def partition(self, head):\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        l = head\n        r = head\n        while l.next is not None:\n            l = l.next\n            r = r.next\n        i = 0\n        while l is not None:\n            l = l.next\n            i += 1\n        p = ListNode(0)\n        p.next = head\n        head = p\n        while r is not None:\n            if i < len(r.val):\n                r = r.next\n            else:\n                p.next = r.next\n                r.next = None\n        return head\n\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\ns = Solution()\n\n# test\nhead = ListNode(0)\nhead.next = ListNode(1)\nhead.next.next = ListNode(2)\nhead.next.next.next = ListNode(3)\nhead.next.next.next.next = ListNode(4)\nhead.next.next.next.next.next = ListNode(5)\nhead.next.next.next.next.next.next = ListNode(6)\nhead.next.next.next.next.next.next.next = ListNode(7)\n\nhead = s.partition(head)\nwhile head is not None:\n    print(head.val)\n    head = head.next",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def splitListToParts(self, head, k):\n        \n        if head == None:\n            return None\n        \n        p = head\n        \n        while p!= None:\n            p = p.next\n        \n        # Get the first part\n        p = head\n        \n        while p.next!= None and len(p.next.next) < k:\n            p = p.next\n        \n        # If the length of the first part is less than k, we have to split the list\n        if len(p.next.next) < k:\n            # Split the list\n            p.next.next = p.next.next.next\n            p.next = None\n        \n        # Get the second part\n        p = head\n        \n        while p.next!= None and len(p.next.next) > k:\n            p = p.next\n        \n        # If the length of the second part is greater than k, we have to split the list\n        if len(p.next.next) > k:\n            # Split the list\n            p.next.next = p.next.next.next\n            p.next = None\n        \n        return head",
    "# https://www.hackerrank.com/challenges/split-a-list-into-two-parts/problem\n\ndef split_list(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n\n    if len(lst) == 1:\n        return [lst]\n\n    mid = len(lst) // 2\n    left = split_list(lst[:mid])\n    right = split_list(lst[mid:])\n\n    return left + [lst] + right",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:\n        if not head or not k:\n            return []\n        if k < 1:\n            return [head]\n        list_part1 = []\n        list_part2 = []\n        curr = head\n        while curr and k:\n            list_part1.append(curr)\n            curr = curr.next\n            k -= 1\n        if k == 0:\n            return [head]\n        list_part2.append(curr)\n        curr = head\n        while curr and k:\n            list_part2.append(curr)\n            curr = curr.next\n            k -= 1\n        return [list_part1, list_part2]",
    "class Solution:\n    # @param lis, a list of integers\n    # @param k, an integer\n    # @return a list of lists\n    def partition(self, lis, k):\n        if len(lis) == 0:\n            return []\n        res = []\n        start = 0\n        end = 0\n        while start < len(lis):\n            end = end + 1\n            while end < len(lis) and lis[end] == lis[end - 1]:\n                end = end + 1\n            if end - start < k:\n                res.append(lis[start:end])\n                start = end\n            else:\n                res.append(lis[start:end - k])\n                start = end - k\n        return res\n\n# Test cases\nlis = [1,2,3,4,5]\nk = 2\nprint(Solution().partition(lis, k))\nlis = [1,2,3,4,5]\nk = 3\nprint(Solution().partition(lis, k))\nlis = [1,2,3,4,5]\nk = 6\nprint(Solution().partition(lis, k))",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {integer} n\n    # @return {TreeNode[]}\n    def partition(self, root, n):\n        if root is None:\n            return []\n        elif root.val <= n:\n            return [root]\n        else:\n            left_part = []\n            right_part = []\n            stack = [root]\n            while stack:\n                node = stack.pop()\n                if node.left is None:\n                    left_part.append(node)\n                    if len(left_part) == n:\n                        return left_part\n                else:\n                    stack.append(node.left)\n                    if len(right_part) < n:\n                        right_part.append(node)\n                    else:\n                        left_part.append(node)\n            return left_part + right_part\n\n# Test\ntest = Solution()\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.right = TreeNode(6)\nroot.right.right.left = TreeNode(7)\nroot.right.right.left.left = TreeNode(8)\nroot.right.right.left.left.left = TreeNode(9)\nroot.right.right.left.left.left.left = TreeNode(10)\nroot.right.right.left.left.left.left.left = TreeNode(11)\nroot.right.right.left.left.left.left.left.left = TreeNode(12)\nroot.right.right.left.left.left.left.left.left.left = TreeNode(13)\nroot.right.right.left.left.left.left.left.left.left.left = TreeNode(14)\nroot.right.right.left.left.left.left.left.left",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef split_list(list_to_split, length):\n    \"\"\"\n    >>> split_list([1,2,3,4,5], 2)\n    [[1,2], [3,4,5]]\n    >>> split_list([1,2,3,4,5], 3)\n    [[1,2,3], [4,5]]\n    >>> split_list([1,2,3,4,5], 4)\n    [[1,2,3,4], [5]]\n    >>> split_list([1,2,3,4,5], 5)\n    [[1,2,3,4,5]]\n    >>> split_list([1,2,3,4,5], 6)\n    [[1,2,3,4,5]]\n    >>> split_list([1,2,3,4,5], 7)\n    [[1,2,3,4,5]]\n    >>> split_list([1,2,3,4,5], 8)\n    [[1,2,3,4,5]]\n    >>> split_list([1,2,3,4,5], 9)\n    [[1,2,3,4,5]]\n    \"\"\"\n    if len(list_to_split) < length:\n        return []\n    else:\n        return [list_to_split[:length], list_to_split[length:]]\n\n\nif __name__ == \"__main__\":\n    print(split_list([1,2,3,4,5], 2))\n    print(split_list([1,2,3,4,5], 3))\n    print(split_list([1,2,3,4,5], 4))\n    print(split_list([1,2,3,4,5], 5))\n    print(split_list([1,2,3,4,5], 6))\n    print(split_list([1,2,3,4,5], 7))\n    print(split_list([1,2,3,4,5], 8))\n    print(split_list([1",
    "class Solution:\n    def splitList(self, head: ListNode, k: int) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        curr = head\n        pre = None\n        while curr is not None and k > 0:\n            curr = curr.next\n            k -= 1\n        \n        if curr is None:\n            return None\n        \n        pre = curr\n        curr = curr.next\n        while curr is not None:\n            curr = curr.next\n        \n        pre.next = None\n        return head",
    "from collections import namedtuple\n\n# Definition for singly-linked list.\nclass ListNode(namedtuple(\"ListNode\", \"val next\")):\n    def __str__(self):\n        return \"%s -> %s\" % (self.val, self.next)\n\nclass Solution(object):\n    def partition(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not k:\n            return head\n        if k == 1:\n            return head\n        \n        p = head\n        while p:\n            p = p.next\n            k -= 1\n        \n        p = head\n        q = p.next\n        while k > 0:\n            q = q.next\n            k -= 1\n        \n        p.next = None\n        return p",
    "# https://leetcode.com/problems/split-list-into-two-parts/description/\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        new_head = ListNode(0)\n        new_head.next = head\n        tail = new_head\n        while head:\n            tail.next = head.next\n            head = head.next\n            tail = tail.next\n        return new_head.next",
    "class Solution(object):\n    def splitIntoPieces(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.solve(nums, target, 0, len(nums) - 1)\n\n    def solve(self, nums, target, start, end):\n        if start == end:\n            if target == nums[start]:\n                return [nums[:start], nums[start:]]\n            else:\n                return []\n\n        if nums[start] > nums[end]:\n            return self.solve(nums, target, start, end + 1)\n\n        mid = (start + end) / 2\n        left = self.solve(nums, target, start, mid)\n        right = self.solve(nums, target, mid + 1, end)\n\n        if left and left[0][0] <= nums[mid]:\n            left = self.solve(nums, target, start, mid)\n\n        if right and right[-1][-1] >= nums[mid]:\n            right = self.solve(nums, target, mid + 1, end)\n\n        if left and right and left[-1][-1] == nums[mid] and right[0][0] == nums[mid]:\n            return [left, right]\n        else:\n            return []\n\n# Note:\n# 1. O(n) time, O(1) space\n# 2. Time Limit Exceeded",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def splitListToParts(self, head, k):\n        if not head or not head.next:\n            return head\n        \n        part1 = head\n        part2 = None\n        part3 = None\n        cur = head\n        while cur:\n            cur = cur.next\n            if cur and cur.next:\n                part3 = cur.next\n            else:\n                if part3:\n                    part3.next = None\n                    part2 = part3\n                break\n            part2 = cur\n        \n        part1.next = part2\n        part2.next = part3\n        \n        return part1",
    "def split_list(lst, n):\n    for i in range(len(lst)):\n        if i % n == 0:\n            yield lst[:i]\n            lst = lst[i:]\n    yield lst\n\ndef main():\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(split_list(lst, 3))\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} n\n    # @return {ListNode}\n    def partition(self, head, n):\n        if not head or not n:\n            return head\n        mid = head\n        left = None\n        right = None\n        while mid:\n            if mid.next:\n                if n == 0:\n                    return head\n                n -= 1\n            if n == 0:\n                right = mid\n                mid = mid.next\n            else:\n                left = mid\n                mid = mid.next\n        if left:\n            left.next = None\n            return left\n        return right",
    "class Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return None\n        left = head\n        right = head\n        while left.next!= None:\n            left = left.next\n            right = right.next\n        left.next = None\n        return right\n\n# test\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nprint Solution().splitList(head)",
    "# https://www.hackerrank.com/challenges/list-split\n\ndef list_split(lst, part_len):\n    \"\"\"\n    :type lst: List[int]\n    :type part_len: int\n    :rtype: List[List[int]]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n\n    return [lst[:part_len], lst[part_len:]]",
    "# Thought:\n\n# 10/16/2017\n\nclass Solution(object):\n    def partition(self, head, l):\n        \"\"\"\n        :type head: ListNode\n        :type l: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        pre = ListNode(0)\n        pre.next = head\n        cur = pre\n        while cur:\n            if cur.next and cur.next.val < l:\n                pre.next = cur.next\n                cur.next = cur.next.next\n            else:\n                pre = cur\n                cur = cur.next\n        pre.next = None\n        return pre.next\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def partition(self, head, l):\n        \"\"\"\n        :type head: ListNode\n        :type l: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        pre = head\n        cur = pre.next\n        while cur and cur.val < l:\n            pre = cur\n            cur = cur.next\n        pre.next = cur\n        return pre.next",
    "# https://leetcode.com/problems/split-a-list-into-two-parts-with-given-length/\n\n\nclass Solution(object):\n    def splitListToParts(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: List[ListNode]\n        \"\"\"\n        if head is None or head.next is None:\n            return []\n\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n        while head.next and k > 0:\n            k -= 1\n            head = head.next\n        dummy.next = head.next\n        head.next = None\n        return [head] + self.splitListToParts(head.next, k)",
    "class Solution(object):\n    def splitIntoTwo(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) < 2:\n            return nums\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) / 2\n            if nums[mid] <= nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        if left == right:\n            return [nums[:left], nums[left:]]\n        return [nums[:left], [nums[left], nums[left + 1:right]]]",
    "def split_list(list, size):\n    \"\"\"\n    :type list: List[int]\n    :type size: int\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    left = []\n    right = []\n    for i in range(0, len(list), size):\n        left.append(list[i:i+size])\n    for i in range(0, len(list), size):\n        right.append(list[i+size:i+size+1])\n    res.append(left)\n    res.append(right)\n    return res",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven a list, split it into two parts where the length of the first part is given.\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param l: A list of integers\n    @return: A list of lists\n    \"\"\"\n    def splitIntoParts(self, l, k):\n        \"\"\"\n        :type l: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not l:\n            return []\n\n        # Create a list of lists to store the result\n        res = []\n        # Calculate the length of the first part of the list\n        n = len(l)\n        # If the first part is more than the given k, just return the original list\n        if n > k:\n            return [l]\n        # Otherwise split the list into two parts\n        else:\n            res.append(l[:k])\n            res.append(l[k:])\n            return res\n\n\nif __name__ == '__main__':\n    print Solution().splitIntoParts([1, 2, 3, 4], 2)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        # head is not the end, so we can just move it to the end of the list.\n        new_head = head\n        while new_head.next:\n            new_head = new_head.next\n        # head is the end of the list, so we can't split it.\n        if new_head is head:\n            return None\n        new_head.next = None\n        # split the list in two parts.\n        new_head = head\n        new_tail = None\n        while new_head:\n            # new_head is the end of the first part.\n            new_tail = new_head\n            new_head = new_head.next\n        new_tail.next = None\n        # new_tail is the end of the second part.\n        return new_tail\n\n\ndef main():\n    # n1 = ListNode(1)\n    # n2 = ListNode(2)\n    # n3 = ListNode(3)\n    # n4 = ListNode(4)\n    # n5 = ListNode(5)\n    # n6 = ListNode(6)\n    # n7 = ListNode(7)\n    # n8 = ListNode(8)\n    # n9 = ListNode(9)\n    # n10 = ListNode(10)\n    # n11 = ListNode(11)\n    # n12 = ListNode(12)\n    # n13 = ListNode(13)\n    # n14 = ListNode(14)\n    # n15 = ListNode(15)\n    # n16 = ListNode(16)\n    # n17 = ListNode(17)\n    # n18 = ListNode(18)\n    # n19 = ListNode(19)\n    # n20 = ListNode(20)\n    # n21 = ListNode(21)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {integer} k\n    # @return {void} Do not return anything, modify root in-place instead.\n    def partition(self, root, k):\n        if root is None:\n            return\n        elif root.val < k:\n            self.partition(root.right, k)\n            root.val = k\n        elif root.val > k:\n            self.partition(root.left, k)\n            root.val = k\n        else:\n            self.partition(root.left, k)\n            self.partition(root.right, k)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: TreeNode\n        :type m: int\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        if head.left == None and head.right == None:\n            return head\n        if head.left == None:\n            head.left = head.right\n            head.right = None\n            return head\n        if head.right == None:\n            head.right = head.left\n            head.left = None\n            return head\n        split_node = TreeNode(0)\n        split_node.left = head\n        split_node.right = head.right\n        head.right = None\n        head.left = head.left\n        return split_node",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef split_list(lst, n):\n    \"\"\"\n    >>> split_list([1,2,3,4,5], 2)\n    [[1, 2], [3, 4], [5]]\n    >>> split_list([1,2,3,4,5], 3)\n    [[1, 2, 3], [4, 5]]\n    >>> split_list([1,2,3,4,5], 6)\n    [[1, 2, 3, 4, 5]]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [lst]\n    if n > len(lst):\n        return split_list(lst[:len(lst)//2], n) + split_list(lst[len(lst)//2:], n)\n    else:\n        return split_list(lst[:n], n) + split_list(lst[n:], n)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "class Solution(object):\n    def splitIntoTwo(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) <= 1:\n            return [[nums]]\n        \n        l = [nums[0]]\n        r = []\n        for i in range(1, len(nums)):\n            if l[-1] + nums[i] <= len(l):\n                l.append(nums[i])\n            else:\n                r.append(l)\n                l = [nums[i]]\n        r.append(l)\n        return r",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n    def partition(self, head, k):\n        if not head or not head.next:\n            return head\n        p = head\n        i = 1\n        while p.next and i < k:\n            i += 1\n            p = p.next\n        q = p.next\n        p.next = None\n        head = self.partition(q, k)\n        return self.merge(head, p)\n\n    def merge(self, h1, h2):\n        if not h1:\n            return h2\n        if not h2:\n            return h1\n        h1.next = self.merge(h1.next, h2)\n        return h1",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        p = head\n        left_num = 0\n        while p and p.next and p.next.val < m:\n            left_num += 1\n            p = p.next\n        if not p:\n            return head\n        left_head = p\n        p = p.next\n        while p and p.val < m:\n            left_num += 1\n            p = p.next\n        if not p:\n            return head\n        right_head = p\n        right_num = 0\n        while p:\n            right_num += 1\n            p = p.next\n        if right_num < m:\n            right_head.next = p\n        else:\n            right_head.next = None\n        return left_head\n\nif __name__ == '__main__':\n    print Solution().splitList(head, m)",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @param {integer} sum\n    # @return {TreeNode[]}\n    def splitBST(self, root, sum):\n        if root is None:\n            return []\n\n        if root.left is None and root.right is None:\n            if sum == root.val:\n                return [root]\n            else:\n                return []\n\n        if root.left is not None and root.right is not None:\n            if root.left.val + root.right.val == sum:\n                return self.splitBST(root.left, sum) + self.splitBST(root.right, sum)\n            else:\n                return []\n\n        if root.left is not None and root.right is None:\n            return self.splitBST(root.left, sum)\n        if root.left is None and root.right is not None:\n            return self.splitBST(root.right, sum)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.splitBST(root,sum)",
    "def split_list(lst):\n    if len(lst) == 1:\n        return [], [lst]\n    else:\n        return lst[:len(lst)/2], lst[len(lst)/2:]\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5]\n    print split_list(lst)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return head\n        if head.next is None:\n            return head\n        new_head = ListNode(0)\n        new_head.next = head\n        prev = new_head\n        while prev.next:\n            next = prev.next\n            if next.val < len(prev.next.next):\n                prev.next = next.next\n                next.next = prev.next\n                prev.next = next\n            else:\n                prev = prev.next\n        return new_head.next",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not m: return head\n        p = head\n        left = ListNode(0)\n        right = ListNode(0)\n        left.next = head\n        while p:\n            p = p.next\n            if p:\n                left.next = p\n            p = p.next\n        p = head\n        while p and m:\n            p = p.next\n            m -= 1\n        p = head\n        while p and m:\n            right.next = p\n            p = p.next\n            m -= 1\n        right.next = None\n        return left.next\n\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution2(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        if not m: return head\n        if m == 1:\n            return self.splitList(head, m-1)\n        p = head\n        left = ListNode(0)\n        right = ListNode(0)\n        left.next = head\n        while p:\n            p = p.next\n            if p:\n                left.next = p\n            p = p.next\n        p = head\n        while p and m:\n            right.next = p\n            p = p.next\n            m -= 1\n        right.next = None\n        return left.next\n\nif __name__ == '__main__':\n    solution = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param k, an integer\n\t# @return a ListNode\n\tdef partition(self, head, k):\n\t\tif not head or not head.next:\n\t\t\treturn head\n\n\t\tdummy = ListNode(0)\n\t\tdummy.next = head\n\t\tfast = dummy\n\t\tslow = dummy\n\t\t\n\t\twhile fast and fast.next:\n\t\t\tfast = fast.next.next\n\t\t\tslow = slow.next\n\t\t\n\t\tfast = dummy\n\t\tslow = dummy\n\t\t\n\t\twhile fast.next and fast.next.next:\n\t\t\tfast = fast.next\n\t\t\tslow = slow.next\n\t\t\n\t\tfast.next = None\n\t\tslow.next = None\n\t\t\n\t\tslow.next = self.partition(head.next, k)\n\t\t\n\t\treturn dummy.next",
    "from collections import defaultdict\n\ndef split_list(list_, length):\n    \"\"\"\n    :type list_: List[int]\n    :type length: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # print(list_)\n    # print(length)\n    dict_ = defaultdict(int)\n    for i in range(length):\n        dict_[i] = list_[i]\n\n    result = []\n    for i in range(length):\n        result.append(dict_[i])\n\n    return result\n\ndef main():\n    list_ = [1,2,3,4,5,6,7,8,9,10]\n    length = 4\n    result = split_list(list_, length)\n    print(result)\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def partition(self, list, k):\n        \"\"\"\n        :type list: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # 1. sort\n        # 2. k-partition\n        # 3. return\n        list.sort()\n        left, right = [], []\n        for i in range(len(list)):\n            if i < k:\n                left.append(list[i])\n            else:\n                right.append(list[i])\n        return left, right\n\n# Note:\n# 1. The length of first part is k.\n# 2. All elements in the first part must be sorted.\n# 3. All elements in the second part must be sorted.\n# 4. All elements in the second part must be greater than or equal to all elements in the first part.",
    "# TLE\nclass Solution:\n    def partition(self, A, n):\n        \"\"\"\n        :type A: List[int]\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        for i in range(n):\n            res.append([])\n        for i in range(len(A)):\n            res[i % n].append(A[i])\n        return res",
    "# https://leetcode.com/problems/split-list-into-two-parts/discuss/76489/Python-3-O(n)-Time-O(1)-Space-Solution-using-a-list\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:\n        if head is None or head.next is None:\n            return [head]\n\n        p = head\n        r = []\n        while p.next is not None:\n            r.append(p)\n            p = p.next\n            if len(r) == k:\n                p = r.pop()\n                r.append(p)\n        r.append(p)\n        return r\n\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    print(s.splitListToParts(head, 4))",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if head.next is None:\n            return head\n        p = head\n        while p.next and p.next.next:\n            p = p.next\n        if p.next:\n            p.next = None\n        l = head\n        r = None\n        while l.next:\n            l = l.next\n            if len(l.next) > m:\n                r = l.next\n                break\n        if r is None:\n            return head\n        r.next = None\n        return l\n\na = [1,2,3,4,5,6,7,8,9,10]\nprint(Solution().splitList(head=a, m=2))",
    "# https://leetcode.com/problems/split-a-list-into-two-parts-where-the-length-of-first-part-of-the-list-is-given/\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # TODO: Use a dynamic programming algorithm\n        # if head is None:\n        #     return head\n        # if head.next is None:\n        #     return head\n        # first = head\n        # second = None\n        # while first:\n        #     second = second if second else first.next\n        #     first = first.next\n        # return first if second is None else second\n        pass\n\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.",
    "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n    def partition(self, head, k):\n        if not head or not head.next:\n            return head\n        \n        # first part\n        node1 = head\n        node2 = head\n        while node1.next and node1.next.next:\n            node2 = node2.next\n            node1 = node1.next\n        \n        # second part\n        node3 = node2.next\n        node2.next = None\n        \n        # split\n        node2.next = head\n        return node1, node3",
    "class Solution(object):\n    def splitListToParts(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = sorted(nums)\n        \n        if len(nums) < k:\n            return [nums]\n        \n        ans = []\n        i = 0\n        while i < len(nums):\n            ans.append(nums[i:i+k])\n            i += k\n        \n        return ans",
    "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def partition(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        fast = dummy\n        slow = dummy\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        fast = dummy\n        slow = dummy\n        while fast.next and fast.next.next:\n            fast = fast.next\n            slow = slow.next\n        k -= 1\n        while k > 0:\n            slow = slow.next\n            k -= 1\n        fast.next = slow.next\n        slow.next = None\n        return dummy.next",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        n = len(head.next)\n        if n == m:\n            return head.next\n        if n > m:\n            p = head.next\n            for i in range(m):\n                p = p.next\n            p = p.next\n            return p\n        p = head\n        for i in range(m):\n            p = p.next\n        return p.next",
    "# https://www.hackerrank.com/challenges/list-partition\n\nimport sys\n\ndef partition(list, l):\n    \"\"\"\n    Partition list into two parts by length l.\n\n    :type list: List[int]\n    :type l: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # Create a list to store the result\n    result = []\n    # Start with the first element and put the rest in the result list\n    result.append(list[0:l])\n    # Create a list to store the rest\n    rest = list[l:]\n    # Loop through the rest list and append to the result list\n    for i in range(l):\n        # Append the rest to the result list\n        result.append(rest[i])\n    # Return the result list\n    return result\n\ndef main():\n    # Get the input\n    n, l = map(int, sys.stdin.readline().strip().split(' '))\n    list = list(map(int, sys.stdin.readline().strip().split(' ')))\n    # Partition the list into two parts\n    result = partition(list, l)\n    # Print the result\n    for i in range(l):\n        print''.join(map(str, result[i]))\n\nif __name__ == '__main__':\n    main()",
    "#!/usr/bin/env python\n\nimport sys\n\ndef splitList(list, length):\n    new_list = []\n    for item in list:\n        new_list.append(item)\n        if len(new_list) == length:\n            return new_list\n        else:\n            return new_list, []\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 3:\n        print \"Usage: python list-split.py input_file output_file\"\n        exit(0)\n    with open(sys.argv[1], 'r') as f:\n        list = f.readlines()\n        new_list, second_list = splitList(list, int(sys.argv[2]))\n        with open(sys.argv[3], 'w') as g:\n            g.writelines(new_list)\n            g.writelines(second_list)",
    "#!/usr/bin/env python\n\nimport random\n\n\ndef split_list(list_to_split):\n    # Create a list of random numbers\n    random_numbers = [random.randint(0, 100) for i in range(len(list_to_split))]\n\n    # Create a new list where the first part of the list is the random numbers\n    first_part = [x for x in list_to_split if x not in random_numbers]\n\n    # Create a new list where the second part of the list is the random numbers\n    second_part = [x for x in list_to_split if x in random_numbers]\n\n    return first_part, second_part\n\n\nif __name__ == '__main__':\n    # Test Case 1\n    test_list = [0, 1, 2, 3]\n    print \"Test Case 1:\", split_list(test_list)\n\n    # Test Case 2\n    test_list = [0, 1, 2, 3, 4]\n    print \"Test Case 2:\", split_list(test_list)\n\n    # Test Case 3\n    test_list = [0, 1, 2, 3, 4, 5]\n    print \"Test Case 3:\", split_list(test_list)\n\n    # Test Case 4\n    test_list = [0, 1, 2, 3, 4, 5, 6]\n    print \"Test Case 4:\", split_list(test_list)\n\n    # Test Case 5\n    test_list = [0, 1, 2, 3, 4, 5, 6, 7]\n    print \"Test Case 5:\", split_list(test_list)\n\n    # Test Case 6\n    test_list = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    print \"Test Case 6:\", split_list(test_list)\n\n    # Test Case 7\n    test_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print \"Test Case 7:\", split_list(test_list)\n\n    # Test Case 8\n    test_list = [0, 1, 2, 3, 4, 5, 6, 7, 8,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        left, right = head, None\n        while head and head.next:\n            right = head\n            left = head.next\n            head = head.next.next\n            right.next = None\n        return left, right\n\nclass Solution2(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        left, right = head, None\n        while head and head.next:\n            right = head\n            head = head.next\n            right.next = None\n        return left",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def splitList(self, head: TreeNode, k: int) -> TreeNode:\n        if head is None:\n            return None\n\n        dummy = TreeNode(0)\n        dummy.left = head\n        pre_node = dummy\n        pre_node.right = None\n        cur_node = dummy\n        while cur_node.right is not None and len(cur_node.right.left) > k:\n            cur_node = cur_node.right\n        while cur_node.left is not None:\n            cur_node = cur_node.left\n        pre_node.right = cur_node\n\n        cur_node = dummy\n        while cur_node.left is not None:\n            cur_node = cur_node.left\n        cur_node.left = pre_node.right\n        pre_node.right = cur_node.right\n        return dummy.right\n\n\n# TESTS\nfor k, l in [\n    (1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114",
    "# https://leetcode.com/problems/split-a-list-into-two-parts-ii/description/\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:\n        def splitList(head, k):\n            if head is None:\n                return\n            if head.next is None:\n                return [head]\n            mid = head.next\n            part = [head]\n            for i in range(k-1):\n                mid = mid.next\n            part.append(mid)\n            return splitList(mid.next, k)\n        return splitList(head, k)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def splitListToParts(self, head, k):\n        if not head or not head.next:\n            return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        i = 0\n        while head and i < k:\n            head = head.next\n            i += 1\n        head.next = None\n        return dummy.next\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.splitListToParts([1, 2, 3, 4, 5, 6], 2)",
    "class Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        pre_tail = head\n        pre_node = head\n        i = 1\n        while i < m:\n            pre_node = pre_node.next\n            i += 1\n        pre_node.next = None\n        pre_tail.next = head\n        return pre_node",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def splitList(self, head, m):\n        \"\"\"\n        :type head: TreeNode\n        :type m: int\n        :rtype: List[ListNode]\n        \"\"\"\n        if head is None:\n            return []\n        res = []\n        curr = head\n        while curr is not None:\n            res.append(curr)\n            curr = curr.left\n        res.append(None)\n        res.append(head)\n        curr = head\n        for _ in range(m):\n            curr = curr.right\n        res[m] = curr\n        return res\n\n\nif __name__ == '__main__':\n    head = TreeNode(1)\n    head.left = TreeNode(2)\n    head.left.left = TreeNode(3)\n    head.left.left.left = TreeNode(4)\n    head.left.left.right = TreeNode(5)\n    head.right = TreeNode(6)\n    head.right.left = TreeNode(7)\n    head.right.left.right = TreeNode(8)\n    head.right.right = TreeNode(9)\n    head.right.right.left = TreeNode(10)\n    head.right.right.right = TreeNode(11)\n    solution = Solution()\n    print solution.splitList(head, 3)",
    "class Solution(object):\n    def splitListToParts(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = sorted(nums)\n        ans = []\n        for i in range(len(nums)):\n            if i < k:\n                ans.append([])\n            if i < k and k <= i+1:\n                ans[-1].append(nums[i])\n            else:\n                ans[-1].append(nums[i-k])\n        return ans",
    "#!/bin/python\n\n\"\"\"\nGiven a list, split it into two parts where the length of the first part of the list is given.\n\nExample 1:\n\nInput: [1,2,3]\nOutput: [1,2], [3]\nExample 2:\n\nInput: [1,2,3,4,5,6,7]\nOutput: [1,2,3,4,5], [6,7]\n\"\"\"\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def splitList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        dummy = ListNode(0)\n        dummy.next = head\n\n        # Use two pointers to walk through the list\n        p1 = dummy\n        p2 = dummy\n\n        while p1.next:\n            p2 = p2.next\n            p1 = p1.next\n\n        # Reverse the list\n        p2 = dummy\n        p1.next = None\n        while p1:\n            temp = p1.val\n            p1.val = p2.val\n            p2.val = temp\n            p1 = p1.next\n            p2 = p2.next\n\n        return dummy.next\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    print s.splitList(head)\n    print s.splitList(ListNode(1))\n    print s.splitList(ListNode(1,2,3))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}