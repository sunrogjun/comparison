{
  "problem": {
    "task_id": "MBPP/285",
    "prompt": "Write a function that matches a string that has an a followed by two to three 'b'.",
    "canonical_solution": "import re\r\ndef text_match_two_three(text):\r\n        patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
    "test_list": [
      "assert text_match_two_three(\"ac\")==('Not matched!')",
      "assert text_match_two_three(\"dc\")==('Not matched!')",
      "assert text_match_two_three(\"abbbba\")==('Found a match!')"
    ],
    "challenge_test_list": [],
    "problem_id": 274
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from collections import Counter\n\ndef has_two_to_three_b(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(s) < 3:\n        return False\n    if s[0]!= 'a':\n        return False\n    if s[1]!= 'b':\n        return False\n    if s[2]!= 'b':\n        return False\n    if s[3]!= 'b':\n        return False\n    if s[4]!= 'b':\n        return False\n    return True\n\nprint(has_two_to_three_b('ababbb'))\nprint(has_two_to_three_b('aabbabb'))\nprint(has_two_to_three_b('abbababb'))\nprint(has_two_to_three_b('bbabbabbabbb'))\nprint(has_two_to_three_b('aabbabbbabbbabbbabb'))",
    "def match(s):\n    if not s:\n        return False\n    if len(s) < 3:\n        return False\n    if s[0]!= 'a' or s[1]!= 'b':\n        return False\n    if s[2]!= 'b':\n        return False\n    return True\n\n\n\nif __name__ == '__main__':\n    assert match('aabb')\n    assert match('bbbb')\n    assert not match('bb')\n    assert not match('b')\n    assert not match('a')\n    assert not match('aa')\n    assert not match('aaa')\n    assert not match('bbbbb')\n    assert not match('bb')",
    "def find_pattern(string):\n    if len(string) < 3:\n        return False\n    if string[0]!= 'a' or string[-1]!= 'b':\n        return False\n    for i in range(1, len(string) - 2):\n        if string[i]!= 'b':\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    string = \"abcb\"\n    print(find_pattern(string))",
    "",
    "import re\n\n\ndef is_palindrome(s):\n    \"\"\"\n    >>> is_palindrome('aabbcc')\n    True\n    >>> is_palindrome('aabbccdd')\n    False\n    >>> is_palindrome('ababbcc')\n    False\n    >>> is_palindrome('ababbccdd')\n    False\n    >>> is_palindrome('bbb')\n    True\n    >>> is_palindrome('bbbba')\n    True\n    >>> is_palindrome('bba')\n    False\n    >>> is_palindrome('bbbb')\n    False\n    \"\"\"\n    return re.match(r\"^[a-z]+$\", s) and s.upper() == s.lower()\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()",
    "# Write a function that matches a string that has an a followed by two to three 'b'.\n#\n# Example 1:\n# Input: \"bbb\"\n# Output: \"bbbb\"\n# Example 2:\n# Input: \"bab\"\n# Output: \"bab\"\n# Example 3:\n# Input: \"baa\"\n# Output: \"bbaa\"\n# Example 4:\n# Input: \"bbbbb\"\n# Output: \"bbbbbb\"\n# Example 5:\n# Input: \"bbbbbbb\"\n# Output: \"bbbbbbbb\"\n#\n# Note:\n# The length of the string is in the range [1, 500].\n#\n# Follow up:\n# Could you solve it with constant space complexity?\n\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        i, j = 0, 0\n        while i < len(s):\n            if s[i] not in p:\n                i += 1\n                continue\n            j = i + 1\n            while j < len(s) and s[j] in p:\n                j += 1\n            if j - i == 2:\n                ans.append(s[i:j])\n            i = j\n        return ans",
    "#!/bin/python\n\ndef match_a_to_bb(text):\n    if text.startswith('a'):\n        if text.endswith('b'):\n            return True\n        else:\n            return False\n    else:\n        return False\n\nif __name__ == '__main__':\n    text = 'aabbcc'\n    print(match_a_to_bb(text))",
    "from __future__ import print_function\n\ndef is_abba(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    return s.startswith('ab') and len(s) >= 3 and len(s) % 3 == 0\n\n\ndef main():\n    print(is_abba('ababb'))\n    print(is_abba('aba'))\n    print(is_abba('abbab'))\n    print(is_abba('abbb'))\n    print(is_abba('abb'))\n    print(is_abba('bbb'))\n\nif __name__ == '__main__':\n    main()",
    "def has_bb(string):\n    return string.count('b') == 2 and string.count('b') < 3\n\nprint has_bb('abbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb",
    "# https://www.hackerrank.com/challenges/find-a-pattern/problem\n\ndef find_pattern(string):\n    \"\"\"\n    :type string: str\n    :rtype: str\n    \"\"\"\n    pattern_dict = {'a': 'b', 'b': 'b', 'c': 'bb'}\n    return pattern_dict[string[0]] + string[1:]\n\nif __name__ == '__main__':\n    string = input().strip()\n    print(find_pattern(string))",
    "# I have found this solution using the following:\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two_to_three_b(s):\n#     return s.find('a') + 2\n#\n# def find_two",
    "import re\n\ndef has_two_b(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    m = re.search(r'^a[bc]b+', s)\n    return m is not None\n\nif __name__ == '__main__':\n    assert has_two_b(\"abbbbc\")\n    assert not has_two_b(\"abbbbcabbbbbb\")\n    assert has_two_b(\"abbbbcabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "",
    "def is_ab(s):\n    return s[0] == 'a' and s[1] == 'b' and len(s) > 2\n\nprint is_ab(\"aba\")\nprint is_ab(\"abb\")\nprint is_ab(\"abbbb\")\nprint is_ab(\"bbbbb\")\nprint is_ab(\"abbbbbb\")",
    "def is_match(s):\n    count = 0\n    for i in range(0, len(s) - 2):\n        if s[i] == s[i + 1] and s[i] == 'a':\n            if s[i + 2] == 'b':\n                count += 1\n    return count\n\nif __name__ == '__main__':\n    s = \"aaaabbbbbb\"\n    print(is_match(s))",
    "",
    "#!/bin/python\n\ndef is_abba(s):\n    return s[0] == s[1] and s[2] == 'b' and s[3] == 'a'\n\n# print(is_abba(\"abb\"))\n# print(is_abba(\"ab\"))\n# print(is_abba(\"ababb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_abba(\"abbbb\"))\n# print(is_",
    "import re\n\ndef match_two_to_three_b(string):\n    regex = r'(?P<first>[a-z])(?P<second>[b-z])(?P<third>[b-z])'\n    m = re.match(regex, string)\n    if m:\n        return m.group('first'), m.group('second'), m.group('third')\n    else:\n        return False",
    "def is_b_b_b(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\"\n\ndef is_b_b_bb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\"\n\ndef is_b_b_bbb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\" and s[5] == \"b\"\n\ndef is_b_b_bbbb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\" and s[5] == \"b\" and s[6] == \"b\"\n\ndef is_b_b_bbbbb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\" and s[5] == \"b\" and s[6] == \"b\" and s[7] == \"b\"\n\ndef is_b_b_bbbbbb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\" and s[5] == \"b\" and s[6] == \"b\" and s[7] == \"b\" and s[8] == \"b\"\n\ndef is_b_b_bbbbbbb(s):\n    return s[1] == \"b\" and s[2] == \"b\" and s[3] == \"b\" and s[4] == \"b\" and s[5] == \"b\" and s[6] == \"b\" and s[7] == \"b\" and s[8] == \"b\" and s[9] == \"b\"\n\ndef is_b_b_bbbbbbbb(s):\n    return s[",
    "def match(string):\n    if len(string) < 3:\n        return False\n    if string[1]!= 'b' or string[2]!= 'b':\n        return False\n    return True",
    "from string import ascii_lowercase\nfrom collections import Counter\n\ndef is_ab(string):\n    \"\"\"\n    Checks if a string is ab\n    \"\"\"\n    if len(string)!= 3:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    if string[1] not in ascii_lowercase:\n        return False\n    if string[2] not in ascii_lowercase:\n        return False\n    return True\n\ndef is_abc(string):\n    \"\"\"\n    Checks if a string is abc\n    \"\"\"\n    if len(string)!= 3:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    if string[1] not in ascii_lowercase:\n        return False\n    if string[2] not in ascii_lowercase:\n        return False\n    if string[1] not in ascii_lowercase:\n        return False\n    return True\n\ndef is_bab(string):\n    \"\"\"\n    Checks if a string is bab\n    \"\"\"\n    if len(string)!= 3:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    if string[1] not in ascii_lowercase:\n        return False\n    if string[2] not in ascii_lowercase:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    return True\n\ndef is_bab(string):\n    \"\"\"\n    Checks if a string is bab\n    \"\"\"\n    if len(string)!= 3:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    if string[1] not in ascii_lowercase:\n        return False\n    if string[2] not in ascii_lowercase:\n        return False\n    if string[0] not in ascii_lowercase:\n        return False\n    return True\n\ndef is_bac(string):\n    \"\"\"\n    Checks if a string is bac\n    \"\"\"",
    "# https://www.codeeval.com/open_challenges/173/\n\n# -*- coding: utf-8 -*-\n\ndef a_to_b(string):\n    \"\"\"\n    :type string: str\n    :rtype: int\n    \"\"\"\n    return int(string.replace(\"a\", \"\").replace(\"b\", \"\").replace(\"c\", \"\"))\n\nif __name__ == '__main__':\n    string = input()\n    print(a_to_b(string))",
    "def match(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b'\n\nif __name__ == \"__main__\":\n    s = 'aaabbbbb'\n    print(match(s))\n    print(s.replace('a', 'b'))",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def convertToBinary(self, s):\n        s = s.upper()\n        result = []\n        for i in range(len(s)):\n            if s[i] == 'a':\n                result.append(1)\n            elif s[i] == 'b':\n                if i+1 < len(s) and s[i+1] == 'a':\n                    result.append(2)\n                else:\n                    result.append(1)\n            elif s[i] == 'c':\n                if i+1 < len(s) and s[i+1] == 'a':\n                    result.append(3)\n                else:\n                    result.append(1)\n            elif s[i] == 'd':\n                if i+1 < len(s) and s[i+1] == 'a':\n                    result.append(4)\n                else:\n                    result.append(1)\n            elif s[i] == 'e':\n                if i+1 < len(s) and s[i+1] == 'a':\n                    result.append(5)\n                else:\n                    result.append(1)\n            elif s[i] == 'f':\n                if i+1 < len(s) and s[i+1] == 'a':\n                    result.append(6)\n                else:\n                    result.append(1)\n        return ''.join(str(x) for x in result)\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.convertToBinary('ab')\n    print solution.convertToBinary('ac')\n    print solution.convertToBinary('bc')\n    print solution.convertToBinary('bd')\n    print solution.convertToBinary('be')\n    print solution.convertToBinary('bf')\n    print solution.convertToBinary('bcdef')\n    print solution.convertToBinary('abcdef')",
    "",
    "import unittest\n\nclass Solution:\n    # @param s, a string\n    # @return a boolean\n    def hasAnagram(self, s):\n        if len(s) < 3:\n            return False\n        \n        dic = {}\n        for ch in s:\n            if ch in dic:\n                dic[ch] += 1\n            else:\n                dic[ch] = 1\n        \n        for i in range(1, len(s)):\n            for ch in dic:\n                if dic[ch]!= dic[s[i-1]]:\n                    return False\n                \n        return True\n        \n        \nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n        \nif __name__ == '__main__':\n    unittest.main()",
    "def is_ab(s):\n    return len(s) >= 2 and s[0] == 'a' and s[1] == 'b'\n\nif __name__ == '__main__':\n    assert is_ab('aabb') == True\n    assert is_ab('aabbbb') == False",
    "#!/usr/bin/env python\n\ndef is_b_followed_by_ab(text):\n    return text.startswith('b') and len(text) >= 3 and text[1] == 'a' and text[2] == 'b'\n\nif __name__ == '__main__':\n    text = 'bb'\n    print is_b_followed_by_ab(text)\n    text = 'ba'\n    print is_b_followed_by_ab(text)\n    text = 'bbbb'\n    print is_b_followed_by_ab(text)\n    text = 'aaaa'\n    print is_b_followed_by_ab(text)",
    "",
    "def is_match(s):\n    return s.startswith('ab')\n\nprint is_match(\"aba\")\nprint is_match(\"abb\")\nprint is_match(\"abbb\")\nprint is_match(\"bbbb\")\nprint is_match(\"aabb\")\nprint is_match(\"aaabb\")\nprint is_match(\"aabbb\")\nprint is_match(\"abbba\")\nprint is_match(\"abbbbb\")\nprint is_match(\"bbbbbb\")\nprint is_match(\"abbbbba\")\nprint is_match(\"bbbbbbb\")\nprint is_match(\"bbbbbbbb\")\nprint is_match(\"abbbbbbb\")\nprint is_match(\"abbbbbbbb\")\nprint is_match(\"bbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbbbbbbbbbb\")\nprint is_match(\"bbbbbbbbbbbbbbbbbbbbbbbbbb\")",
    "#!/usr/bin/env python\n\n#\n# The following code is a modified version of the solution to the\n# \"String Matching\" problem on LeetCode.\n#\n# https://leetcode.com/problems/string-matching/description/\n#\n\n#\n# The following is a modified version of the solution to the\n# \"String Matching\" problem on LeetCode.\n#\n# https://leetcode.com/problems/string-matching/solution/\n#\n\n#\n# This is the original function that was modified.\n#\n# def is_matching(s1, s2):\n#     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2]\n#\n#\n# This is the modified function that was written.\n#\n# def is_matching(s1, s2):\n#     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3]\n#\n#\n# This is the modified function that was written.\n#\n# def is_matching(s1, s2):\n#     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4]\n#\n\n#\n# The following is the modified function that was written.\n#\n# def is_matching(s1, s2):\n#     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5]\n#\n\n#\n# The following is the modified function that was written.\n#\n# def is_matching(s1, s2):\n#     return s1[0]",
    "import re\n\ndef match_pattern(string):\n    pattern = re.compile(\"^[ab][ab][ab]$\")\n    return pattern.match(string)\n\ndef test():\n    assert match_pattern(\"aabbbbb\") == None\n    assert match_pattern(\"abbbbb\") == None\n    assert match_pattern(\"ababbb\") == None\n    assert match_pattern(\"abbbbbb\") == None\n    assert match_pattern(\"abbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") == None\n    assert match_pattern(\"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "def is_abba(s):\n    \"\"\"\n    Write a function that checks if a string is an a followed by two to three 'b'.\n    :param s: The string to check.\n    :return: True if the string is an a followed by two to three 'b', false otherwise.\n    \"\"\"\n    return s.startswith('ab') and len(s) == 3 and s[1] == 'b'\n\n\ndef test_is_abba():\n    assert is_abba('ababb') == True\n    assert is_abba('aba') == False\n    assert is_abba('ab') == False\n    assert is_abba('b') == False\n\nif __name__ == '__main__':\n    test_is_abba()",
    "def check_match(string):\n    \"\"\"\n    Given a string, return True if the string matches the pattern 'a followed by two to three b'.\n    \"\"\"\n    if string[0] == 'a' and string[1] == 'b' and string[2:].isdigit():\n        return True\n    else:\n        return False\n\nprint(check_match('aaabb'))\nprint(check_match('abbb'))\nprint(check_match('abb'))\nprint(check_match('abbb'))\nprint(check_match('abbbb'))\nprint(check_match('abbbbb'))",
    "# https://www.hackerrank.com/challenges/matching-two-b\n# https://www.hackerrank.com/challenges/matching-three-b\n\n\ndef is_matching_two_b(s, i, j):\n    return s[i:j] == 'a' * 2 + 'b' * 3\n\n\ndef is_matching_three_b(s, i, j):\n    return s[i:j] == 'a' * 3 + 'b' * 2\n\n\ndef is_matching_two_b_recursive(s, i, j):\n    if i == 0:\n        return s[i:j] == 'a' * 2 + 'b' * 3\n    else:\n        return is_matching_two_b(s, i - 1, j) and is_matching_two_b_recursive(s, i - 1, j)\n\n\ndef is_matching_three_b_recursive(s, i, j):\n    if i == 0:\n        return s[i:j] == 'a' * 3 + 'b' * 2\n    else:\n        return is_matching_three_b(s, i - 1, j) and is_matching_three_b_recursive(s, i - 1, j)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n\n    match = []\n    for i in range(0, n):\n        match.append(is_matching_two_b_recursive(s, i, n))\n\n    if any(match):\n        print('YES')\n    else:\n        print('NO')",
    "import re\n\ndef has_bb(s):\n    return re.search(r'([ab]{2,3})', s)\n\n\nif __name__ == '__main__':\n    assert has_bb('abbabb')\n    assert has_bb('ababb')\n    assert has_bb('ababbb')\n    assert has_bb('abbb')\n    assert has_bb('abbb')\n    assert has_bb('abbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('abbbb')\n    assert has_bb('",
    "def has_abba(string):\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n    \"\"\"\n\n    if string[0:2] == \"aa\":\n        if string[2:4] == \"bb\":\n            if string[4:6] == \"bb\":\n                return True\n    return False\n\nprint(has_abba(\"aaabbbb\"))\nprint(has_abba(\"aaabbbba\"))\nprint(has_abba(\"aaabbbbba\"))\nprint(has_abba(\"aaabbbbbb\"))\nprint(has_abba(\"aaaabbb\"))\nprint(has_abba(\"aaaabbbba\"))\nprint(has_abba(\"aaaabbbbbb\"))\nprint(has_abba(\"aaaabbbbbba\"))\nprint(has_abba(\"aaaabbbbbbbb\"))",
    "from string import ascii_lowercase as lower\n\ndef check_for_abba(s):\n    if s.startswith('a') and s.endswith('b') and s.count('b') == 2:\n        return True\n    else:\n        return False\n\ndef main():\n    # Test Cases\n    test_cases = [\n        ('a', True),\n        ('aa', False),\n        ('aaa', False),\n        ('ab', False),\n        ('abb', True),\n        ('abbb', True),\n        ('abbbb', False),\n        ('abbbbb', False)\n    ]\n\n    for test_case in test_cases:\n        result = check_for_abba(test_case[0])\n        if result!= test_case[1]:\n            print('For case {} the result was {} but should have been {}'.format(test_case[0], result, test_case[1]))\n\n\nif __name__ == '__main__':\n    main()",
    "def match_two_to_three_b(string):\n    if len(string) < 3:\n        return False\n\n    a = string[0:2]\n    if a!= 'a' and a!= 'b':\n        return False\n\n    if len(string) == 3 and string[2]!= 'b':\n        return False\n\n    return True\n\n\nif __name__ == '__main__':\n    assert match_two_to_three_b('aabb') == True, \"Expected True\"\n    assert match_two_to_three_b('abb') == False, \"Expected False\"\n    assert match_two_to_three_b('abbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('abbbb') == True, \"Expected True\"\n    assert match_two_to_three_b('abbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbbbb') == True, \"Expected True\"\n    assert match_two_to_three_b('bbbbbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_b('bbbbbbbbbbbbb') == False, \"Expected False\"\n    assert match_two_to_three_",
    "def match_two_three_a(string):\n    return string.count(\"a\") >= 2 and string.count(\"b\") >= 3\n\nif __name__ == \"__main__\":\n    assert match_two_three_a(\"bbbb\") == True\n    assert match_two_three_a(\"babbb\") == False\n    assert match_two_three_a(\"abbba\") == False",
    "def is_bbb(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b'\n\ndef is_bb(s):\n    return s[0] == 'a' and s[1] == 'b'\n\ndef is_b(s):\n    return s[0] == 'a' and s[1] == 'b'\n\ndef is_b2(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b'\n\ndef is_b3(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b'\n\ndef is_b_a_b(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b'\n\ndef is_bbb_a_b(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b'\n\ndef is_bbb_a_b_b(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b' and s[4] == 'b'\n\ndef is_bb_a_b_bb(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b' and s[4] == 'b' and s[5] == 'b'\n\ndef is_bb_a_b_bb_b(s):\n    return s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'b' and s[4] == 'b' and s[5] == 'b' and s[6] == 'b'\n\ndef is_bb_a_b_bb_bb(s):",
    "def is_abba(str):\n    \"\"\"\n    :type str: str\n    :rtype: bool\n    \"\"\"\n    if str[0] == \"a\" and str[1] == \"b\" and str[2] == \"b\" and str[3] == \"a\":\n        return True\n    return False",
    "# https://www.hackerrank.com/challenges/matching-b-to-bbb\n\n# This is the solution for problem 1.\ndef is_match(string, pattern):\n    for i in range(len(string) - len(pattern) + 1):\n        if string[i:i+len(pattern)] == pattern:\n            return True\n    return False\n\n# This is the solution for problem 2.\ndef is_match2(string, pattern):\n    for i in range(len(string) - len(pattern) + 1):\n        if string[i:i+len(pattern)] == pattern:\n            return True\n        if string[i:i+len(pattern)] == pattern[::-1]:\n            return True\n    return False\n\n# This is the solution for problem 3.\ndef is_match3(string, pattern):\n    for i in range(len(string) - len(pattern) + 1):\n        if string[i:i+len(pattern)] == pattern:\n            return True\n        if string[i:i+len(pattern)] == pattern[::-1]:\n            return True\n        if string[i:i+len(pattern)] == pattern[1::-1]:\n            return True\n    return False\n\n# This is the solution for problem 4.\ndef is_match4(string, pattern):\n    for i in range(len(string) - len(pattern) + 1):\n        if string[i:i+len(pattern)] == pattern:\n            return True\n        if string[i:i+len(pattern)] == pattern[::-1]:\n            return True\n        if string[i:i+len(pattern)] == pattern[1::-1]:\n            return True\n        if string[i:i+len(pattern)] == pattern[2::-1]:\n            return True\n        if string[i:i+len(pattern)] == pattern[3::-1]:\n            return True\n    return False\n\n# This is the solution for problem 5.\ndef is_match5(string, pattern):\n    for i in range(len(string) - len(pattern) + 1):\n        if string[i:i+len(pattern)] == pattern:",
    "def find_b_b(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s)):\n        if s[i] == 'a' and s[i + 1] == 'b' and s[i + 2] == 'b':\n            return True\n    return False\n\nif __name__ == '__main__':\n    s = \"bb\"\n    print(find_b_b(s))\n    s = \"aaabb\"\n    print(find_b_b(s))\n    s = \"abb\"\n    print(find_b_b(s))\n    s = \"bbbb\"\n    print(find_b_b(s))\n    s = \"bbbbbbbb\"\n    print(find_b_b(s))\n    s = \"abbbbbbbbbb\"\n    print(find_b_b(s))",
    "# https://www.hackerrank.com/challenges/the-hobbyist\n\ndef main():\n    return\n\nif __name__ == \"__main__\":\n    main()",
    "def is_abba(s):\n    if len(s) < 3:\n        return False\n    if s[0]!= 'a':\n        return False\n    if s[1]!= 'b':\n        return False\n    if s[2]!= 'a':\n        return False\n    return True\n\nif __name__ == \"__main__\":\n    assert is_abba(\"abba\") == True\n    assert is_abba(\"abab\") == True\n    assert is_abba(\"abbb\") == True\n    assert is_abba(\"bbbb\") == False\n    assert is_abba(\"aabb\") == False\n    assert is_abba(\"abb\") == False",
    "",
    "",
    "# Write your code below\ndef has_a_followed_by_two_to_three_b(string):\n    if len(string) == 0:\n        return False\n\n    if len(string) > 3:\n        return False\n\n    if string[0]!= 'a':\n        return False\n\n    if string[1]!= 'b':\n        return False\n\n    if string[2]!= 'b':\n        return False\n\n    if string[3]!= 'b':\n        return False\n\n    return True",
    "# Your function will take in two strings, a and b.\n# Return true if the string a has a followed by two to three 'b' and false otherwise.\n\ndef is_abba(a, b):\n    if len(a)!= len(b):\n        return False\n    for i in range(len(a)):\n        if a[i]!= b[i]:\n            if i < 2 or i > len(a) - 2 or a[i - 1]!= b[i - 1] or a[i + 1]!= b[i + 1]:\n                return False\n    return True\n\n# Test Cases\n\n# Test Case 1\nassert is_abba('a', 'b') == True\n\n# Test Case 2\nassert is_abba('aa', 'bb') == False\n\n# Test Case 3\nassert is_abba('aaa', 'bbb') == True",
    "from collections import namedtuple\n\n__author__ = 'vladimir'\n\ndef check_match(string):\n    match = namedtuple('Match','string a b c')\n    match_string = 'abc'\n\n    for match_string in match_string:\n        if match_string in string:\n            return match(string=string, a=match_string[0], b=match_string[1], c=match_string[2])\n    else:\n        return None\n\nif __name__ == '__main__':\n    print check_match('abbb')\n    print check_match('abbc')\n    print check_match('abc')\n    print check_match('abb')\n    print check_match('abbbbb')\n    print check_match('abbbbc')",
    "def match_b(s):\n    match = 0\n    for i in range(0, len(s)):\n        if s[i] == 'a' and i < len(s)-2 and s[i+1] == 'b' and s[i+2] == 'b':\n            match += 1\n        i += 1\n    return match\n\n\n\nprint(match_b(\"abbb\"))\nprint(match_b(\"abbbb\"))\nprint(match_b(\"abbbbb\"))\nprint(match_b(\"abbbbbb\"))\nprint(match_b(\"abbbbbbb\"))\nprint(match_b(\"abbbbbbbb\"))\nprint(match_b(\"abbbbbbbbb\"))\nprint(match_b(\"abbbbbbbbbb\"))\nprint(match_b(\"abbbbbbbbbbb\"))\nprint(match_b(\"abbbbbbbbbbbb\"))",
    "def has_bbb(string):\n    if len(string) < 4:\n        return False\n    for i in range(len(string)):\n        if string[i]!= 'a' or (i+1) < len(string) and string[i+1]!= 'b':\n            return False\n        if (i+2) < len(string) and string[i+2]!= 'b':\n            return False\n    return True\n\ndef main():\n    test_cases = [\n        [\"bbb\", True],\n        [\"ababb\", True],\n        [\"bbbb\", True],\n        [\"abbabb\", True],\n        [\"ababbb\", False],\n        [\"abbabb\", False],\n        [\"abbabb\", False],\n        [\"abbabb\", False],\n        [\"bb\", False],\n        [\"b\", False],\n        [\"\", False],\n    ]\n    for test in test_cases:\n        print \"Test case #{}: {}\".format(test_cases.index(test)+1, has_bbb(test))\n\nif __name__ == \"__main__\":\n    main()",
    "",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        l, r = 0, len(s)-1\n        while l < r:\n            if s[l]!= s[r]:\n                if s[l] == 'b' and s[r] == 'a':\n                    l += 1\n                elif s[l] == 'a' and s[r] == 'b':\n                    r -= 1\n                else:\n                    return False\n            l += 1\n            r -= 1\n        return True\n\n\nif __name__ == \"__main__\":\n    s = \"aaabbba\"\n    print Solution().isPalindrome(s)",
    "# https://leetcode.com/problems/valid-palindrome/\n\n\nclass Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s[::-1] == s",
    "def a_b_to_bb():\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n    \"\"\"\n    pass\n\ndef a_b_to_bb_2():\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n    \"\"\"\n    pass\n\ndef a_b_to_bb_3():\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n    \"\"\"\n    pass\n\ndef a_b_to_bb_4():\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n    \"\"\"\n    pass",
    "def a_b_to_three_b(s):\n    return s.count('a') == s.count('b') and s.count('b') == s.count('bb')\n\nprint a_b_to_three_b('abbb')\nprint a_b_to_three_b('abbbbb')\nprint a_b_to_three_b('abbbbbbb')",
    "# Your code here\n\nfrom sys import argv\n\ndef match_b(str):\n    \"\"\"\n    Returns True if the string has an a followed by two to three 'b', else returns False.\n    \"\"\"\n    return str.startswith('a') and str.count('b') >= 2 and str.count('b') <= 3\n\nif __name__ == \"__main__\":\n    input_str = argv[1]\n    print(match_b(input_str))",
    "from string import ascii_lowercase\n\ndef is_ab_string(s):\n    \"\"\"\n    >>> is_ab_string('ab')\n    True\n    >>> is_ab_string('abcd')\n    False\n    \"\"\"\n    if len(s) < 3:\n        return False\n    if len(s) > 3:\n        return False\n    for i in range(len(s)):\n        if s[i] not in ascii_lowercase:\n            return False\n    return True\n\n\ndef main():\n    print(is_ab_string('ab'))\n    print(is_ab_string('abcd'))\n\nif __name__ == '__main__':\n    main()",
    "def check_for_bb(string):\n    \"\"\"\n    Given a string, return True if it matches the pattern aabb.\n    \"\"\"\n    if len(string) == 4:\n        if string[0] == 'a' and string[1] == 'b' and string[2] == 'b':\n            return True\n    return False\n\nprint check_for_bb('aabb')",
    "import re\n\n\ndef has_abba(string):\n    \"\"\"\n    Write a function that matches a string that has an a followed by two to three 'b'.\n\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    return re.search(r\"^a(b)?b(b)?b$\", string) is not None",
    "def is_ab_b(s):\n    # +++your code here+++\n    if len(s) < 3:\n        return False\n    if s[0]!= 'a' or s[1]!= 'b':\n        return False\n    if len(s) == 3 and s[2]!= 'b':\n        return False\n    return True\n\n# Test Cases:\n# Test Case 1:\n# Input: \"ab\"\n# Output: True\n# Test Case 2:\n# Input: \"abb\"\n# Output: False\n# Test Case 3:\n# Input: \"abbb\"\n# Output: True\n# Test Case 4:\n# Input: \"bbbb\"\n# Output: False\n# Test Case 5:\n# Input: \"bbbbb\"\n# Output: True\n# Test Case 6:\n# Input: \"bbbbbb\"\n# Output: False",
    "def match(s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    if len(s) < 3:\n        return False\n    if s[0] == 'a' and s[1] == 'b':\n        if len(s) == 2:\n            return True\n        elif len(s) == 3:\n            return s[2] == 'b'\n        else:\n            return False\n    else:\n        return False\n\n# https://www.codewars.com/kata/match-a-string-with-a-followed-by-two-to-three-b/train/python",
    "# Complete the function below.\ndef is_palindrome(s):\n    if len(s) < 2:\n        return True\n    elif s[0] == s[-1]:\n        return is_palindrome(s[1:-1])\n    elif s[0]!= s[-1]:\n        return False\n    else:\n        return is_palindrome(s[1:-1])\n\n# Your function will be called like this:\n# is_palindrome(\"aba\") --> False\n# is_palindrome(\"abca\") --> True\n# is_palindrome(\"abab\") --> True\n# is_palindrome(\"ababb\") --> False\n\nif __name__ == \"__main__\":\n    assert is_palindrome(\"aba\") == False\n    assert is_palindrome(\"abca\") == True\n    assert is_palindrome(\"abab\") == True\n    assert is_palindrome(\"ababb\") == False",
    "def is_b(s):\n    return s[1] == 'b' and len(s) >= 3 and s[2] == 'b'\n\nif __name__ == '__main__':\n    test_cases = [\n        ('ab', True),\n        ('abab', True),\n        ('ababb', False),\n        ('ababbb', False),\n        ('abb', False),\n        ('abbbb', False),\n        ('bb', False),\n    ]\n\n    for s, expected in test_cases:\n        actual = is_b(s)\n        print(s, '->', actual, '==>', expected)",
    "def a_b(string):\n    # write your code here\n    match = string.find(\"a\")\n    if match == -1:\n        return 0\n    return string[match+1:match+2]\n\n# Tests\n\nassert a_b(\"ab\") == \"b\"\nassert a_b(\"abab\") == \"b\"\nassert a_b(\"abb\") == \"b\"\nassert a_b(\"ab\") == \"\"\nassert a_b(\"\") == \"\"",
    "#!/usr/bin/env python\n\nimport re\n\ndef is_abba(string):\n    \"\"\"\n    >>> is_abba(\"ababbabbabb\")\n    True\n    >>> is_abba(\"ababbababb\")\n    True\n    >>> is_abba(\"abbabbabbabb\")\n    True\n    >>> is_abba(\"abbabbabbabbbb\")\n    False\n    \"\"\"\n    return re.match('^[a-z]{2,3}[ab]{1,2}$', string)\n\nif __name__ == '__main__':\n    import sys\n    if (len(sys.argv) <= 1):\n        import doctest\n        doctest.testmod()\n    else:\n        test_cases = open(sys.argv[1], 'r')\n        for test in test_cases:\n            test = test.rstrip('\\n')\n            if (test!= ''):\n                test = test.split(' ')\n                print(is_abba(test[0]))",
    "def test_match(string):\n    if len(string) < 3:\n        return False\n    if string[-2:] == 'bb':\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    assert test_match('abcb') == True, \"Test 1\"\n    assert test_match('abcbc') == False, \"Test 2\"",
    "__author__ = 'vivek'\n\ndef is_valid_b_string(string):\n    if string[-1]!= 'b' or len(string) < 3 or len(string) > 4:\n        return False\n    if string[-2] == 'a':\n        if string[-3] == 'b':\n            return True\n        else:\n            return False\n    else:\n        return False\n\nprint is_valid_b_string('ab')\nprint is_valid_b_string('aabb')\nprint is_valid_b_string('aabbbb')\nprint is_valid_b_string('bb')\nprint is_valid_b_string('bbbb')",
    "def is_ab(s):\n    \"\"\"\n    :param s: str\n    :return: bool\n    \"\"\"\n    return s.count('a') == 2 and s.count('b') == 3\n\nif __name__ == '__main__':\n    assert is_ab('aabbbb')\n    assert is_ab('bbbbba')\n    assert not is_ab('bbbbb')",
    "def is_ab(s):\n    return s[0] == 'a' and s[-1] in ['b', 'c']\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert is_ab(\"ba\") == True, \"A\"\n    assert is_ab(\"bb\") == True, \"B\"\n    assert is_ab(\"bc\") == False, \"C\"\n    assert is_ab(\"c\") == False, \"D\"\n    assert is_ab(\"bbb\") == False, \"E\"\n    assert is_ab(\"abb\") == False, \"F\"\n    assert is_ab(\"abc\") == False, \"G\"\n    assert is_ab(\"abbc\") == False, \"H\"",
    "# https://www.hackerrank.com/challenges/matching-a-string\n# Write a function that matches a string that has an a followed by two to three 'b'.\n\ndef matching_string(s):\n    return s[0] == 'a' and len(s) == 2 and s[1] == 'b'\n\nif __name__ == '__main__':\n    print matching_string(\"ab\")",
    "",
    "",
    "def is_b_followed_by_two_or_three(s):\n    return s[-3:] == 'b'\n\n\nif __name__ == \"__main__\":\n    assert is_b_followed_by_two_or_three(\"abb\") == True\n    assert is_b_followed_by_two_or_three(\"abbbb\") == False\n    assert is_b_followed_by_two_or_three(\"abbbbb\") == False\n    assert is_b_followed_by_two_or_three(\"abbbbbb\") == False\n    assert is_b_followed_by_two_or_three(\"abbbbbbb\") == False\n    assert is_b_followed_by_two_or_three(\"bbbb\") == False\n    assert is_b_followed_by_two_or_three(\"bbbbbb\") == False\n    assert is_b_followed_by_two_or_three(\"bbbbbbb\") == False",
    "#!/bin/python\n\ndef match_b(string):\n    result = []\n    if string[-1] == 'b':\n        if len(string) == 2:\n            result.append(string[:-1])\n        elif len(string) == 3:\n            result.append(string[:-2])\n            result.append(string[-2:])\n    return result\n\nif __name__ == '__main__':\n    string = 'aabbbb'\n    result = match_b(string)\n    print(result)",
    "import re\n\ndef is_abba(s):\n    return re.match(r\"^[ab]{2,3}$\", s)\n\nprint(is_abba(\"aba\"))\nprint(is_abba(\"ababb\"))\nprint(is_abba(\"ababb\"))\nprint(is_abba(\"bbabb\"))\nprint(is_abba(\"abbbb\"))\nprint(is_abba(\"abbbb\"))\nprint(is_abba(\"bbabb\"))\nprint(is_abba(\"bbabb\"))\nprint(is_abba(\"bbabb\"))\nprint(is_abba(\"abbbb\"))",
    "from collections import defaultdict\n\ndef is_valid_a_b_b(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b'\n\ndef is_valid_a_b_b_a(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'a'\n\ndef is_valid_a_b_b_ab(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'a' and s[4] == 'b'\n\ndef is_valid_a_b_b_ab_a(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'a' and s[4] == 'b' and s[5] == 'a'\n\ndef is_valid_a_b_b_ab_ab(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'a' and s[4] == 'b' and s[5] == 'a' and s[6] == 'b'\n\ndef is_valid_a_b_b_ab_ab_a(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] == 'b' and s[2] == 'b' and s[3] == 'a' and s[4] == 'b' and s[5] == 'a' and s[6] == 'b' and s[7] == 'a'\n\ndef is_valid_a_b_b_ab_ab_a_a(s):\n    return len(s) >= 3 and s[0] == 'a' and s[1] ==",
    "def has_abba(s):\n    return len(s) >= 2 and s[0:2] == 'ab' and s[-2:] == 'ab'\n\nprint(has_abba('ab'))\nprint(has_abba('abb'))\nprint(has_abba('bb'))\nprint(has_abba('abc'))\nprint(has_abba('acb'))\nprint(has_abba('ac'))\nprint(has_abba('abc'))\nprint(has_abba('ababb'))",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Author: victor\n# @Date:   2015-12-15 17:26:25\n# @Last Modified by:   victor\n# @Last Modified time: 2015-12-15 17:30:09\n\ndef match(string):\n    pattern = 'ab'\n    matches = []\n    for i in range(0, len(string)):\n        if string[i] == pattern[0]:\n            matches.append(string[i])\n            if len(matches) == 3:\n                return matches\n            else:\n                matches.append(string[i])\n    return matches\n\nif __name__ == '__main__':\n    s = 'ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb",
    "def match(string):\n    # write your code here\n    if string[0]!= 'a':\n        return False\n    if len(string)!= 3:\n        return False\n    if string[1]!= 'b':\n        return False\n    if string[2]!= 'b':\n        return False\n    return True\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ('ab', True),\n        ('bb', False),\n        ('bbbbbb', False),\n        ('ababb', False),\n        ('bbabbbb', False),\n        ('ababbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb', False),\n        ('abbbbbb',",
    "import re\n\n\ndef is_valid_b_followed_by_two_or_three_a(s):\n    regex = re.compile(r'([ab])\\1{2,3}')\n    return regex.match(s) is not None\n\n\nif __name__ == '__main__':\n    assert is_valid_b_followed_by_two_or_three_a('aabbba') == False\n    assert is_valid_b_followed_by_two_or_three_a('aabbba') == False\n    assert is_valid_b_followed_by_two_or_three_a('aaabbba') == True\n    assert is_valid_b_followed_by_two_or_three_a('ababbba') == True\n    assert is_valid_b_followed_by_two_or_three_a('abbabbba') == True\n    assert is_valid_b_followed_by_two_or_three_a('abbabbbaabb') == True",
    "def has_abba(string):\n    if len(string) == 0:\n        return False\n    if string[0]!= 'a':\n        return False\n    if len(string) < 4:\n        return False\n    if string[1]!= 'b':\n        return False\n    if string[2]!= 'b':\n        return False\n    if string[3]!= 'b':\n        return False\n    return True\n\nprint(has_abba('abab'))",
    "import re\n\ndef check(s):\n    \"\"\"\n    check(s) -> bool\n    \n    Returns True if the string s is a valid a followed by two to three 'b'.\n    \"\"\"\n    return re.search(r'^a{2,3}$', s) is not None\n\n\ndef main():\n    print(check('ab'))\n    print(check('abb'))\n    print(check('abbb'))\n    print(check('babbb'))\n    print(check('bbabbb'))\n    print(check('bbabbbabb'))\n    print(check('bbabbbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check('bbabbbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n    print(check",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def reverseStr(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0:\n            return s\n\n        if s[0] == 'b':\n            return self.reverseStr(s[1:]) + s[0] + self.reverseStr(s[1:])\n        else:\n            return self.reverseStr(s[1:])\n\n\nif __name__ == \"__main__\":\n    print Solution().reverseStr(\"bb\")\n    print Solution().reverseStr(\"ab\")\n    print Solution().reverseStr(\"abb\")\n    print Solution().reverseStr(\"bab\")",
    "def has_abba(s):\n    \"\"\"\n    >>> has_abba('aaaa')\n    True\n    >>> has_abba('aaaabb')\n    True\n    >>> has_abba('abab')\n    False\n    >>> has_abba('ab')\n    False\n    >>> has_abba('ab')\n    True\n    \"\"\"\n    return s.startswith('a') and s.endswith('b') and len(s) == 3\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "#%%\ndef test_match_ab(s):\n    assert s == 'aabbbb'\n\ndef match_ab(s):\n    return s[1:4]\n\n#%%\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    doctest.testfile('README.rst')",
    "from string import ascii_lowercase\n\n\ndef match_two_to_three_b(word):\n    \"\"\"\n    :type word: str\n    :rtype: bool\n    \"\"\"\n    return word[-2:] == ascii_lowercase[-2:] and word[-1] in ascii_lowercase and word[-3:] in ascii_lowercase\n\n\nif __name__ == '__main__':\n    assert match_two_to_three_b('abb') == True\n    assert match_two_to_three_b('abbc') == True\n    assert match_two_to_three_b('abbcc') == False\n    assert match_two_to_three_b('abbbb') == False",
    "def match_b(s):\n    return s[0] == 'a' and s[-2] == 'b' and s[-1] == 'b'\n\n\ndef test():\n    assert match_b('aaabbbb') == True\n    assert match_b('aaaabbbb') == False\n    assert match_b('abbbb') == True\n    assert match_b('abb') == False\n    assert match_b('abbbbbb') == False\n    assert match_b('abbbbbbb') == False\n    assert match_b('abbbbbbbb') == False\n    assert match_b('bbbb') == False\n    assert match_b('bb') == False\n    assert match_b('bbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbbbbbbbbbbbbbbbb') == False\n    assert match_b('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "#!/usr/bin/env python\n\n#-------------------------------------------------------------------------------\n# Solution:\n#\n#-------------------------------------------------------------------------------\n\ndef check_match(s):\n    \"\"\"\n    Check if s is a match for a string that has a followed by two to three 'b'.\n    \"\"\"\n\n    return s[-2:] == \"bb\"\n\n\n#-------------------------------------------------------------------------------\n# Tests\n#-------------------------------------------------------------------------------\n\ntests = [\n    (\"abb\", True),\n    (\"bbbb\", False),\n    (\"abb\", True),\n    (\"bb\", True),\n    (\"b\", False),\n]\n\nfor s, expected in tests:\n    print \"s = '{}'\".format(s)\n    print \"expected = '{}'\".format(expected)\n    print \"is_match = '{}'\".format(check_match(s))",
    "def match_two_to_three_b(string):\n    return len(string) >= 3 and string[0] == 'a' and string[1] == 'b' and string[2] == 'b'\n\nif __name__ == \"__main__\":\n    string = \"ababb\"\n    print(match_two_to_three_b(string))",
    "def has_ab_b(s):\n    if s.count('a') > 1 or s.count('b') > 2:\n        return False\n    return True\n\ndef test_case(s):\n    if has_ab_b(s):\n        return True\n    return False\n\nif __name__ == '__main__':\n    assert test_case('abbb') == True\n    assert test_case('abbbb') == True\n    assert test_case('abbbbc') == False\n    assert test_case('abbbbcx') == False\n    assert test_case('abbbbcxz') == False\n    assert test_case('abbbbcxyz') == False",
    "import re\n\ndef has_ab(string):\n    \"\"\"\n    Write a function that takes a string and returns True if the string has an a followed by two to three 'b'\n    and returns False if the string does not.\n    \"\"\"\n    return re.search('a+b+', string) is not None\n\n#print(has_ab('ababbabb'))\n#print(has_ab('abababbabb'))\n#print(has_ab('ababbabbabb'))\n#print(has_ab('ababbabbabbabb'))\n#print(has_ab('ababbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab('ababbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabbabb'))\n#print(has_ab",
    "# https://www.hackerrank.com/challenges/string-to-number-conversion\n\ndef convert(s):\n    '''\n    :param s: str\n    :return: int\n    '''\n    if s[0] == 'a':\n        if s[1] == 'b':\n            if s[2] == 'b':\n                return int(s[3:])\n            else:\n                return int(s[2:])\n        else:\n            return int(s[1:])\n    else:\n        return int(s)\n\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        s = input()\n        print(convert(s))",
    "from string import ascii_lowercase\n\ndef has_bb(s):\n    return len(s) >= 2 and s[-2] == 'b' and s[-1] in ascii_lowercase\n\n\nif __name__ == '__main__':\n    s = 'abb'\n    print has_bb(s)",
    "def is_abba(s):\n    return s[0:2] == \"ab\" and s[2:4] == \"b\"\n\n\nif __name__ == \"__main__\":\n    assert is_abba(\"abab\")\n    assert is_abba(\"ababb\")\n    assert is_abba(\"ababbb\")\n    assert is_abba(\"abbabb\")",
    "def match_b(s):\n    return s.replace('a', 'b')\n\nprint(match_b('abbbbb'))\nprint(match_b('abbbbb'))\nprint(match_b('abbbbb'))",
    "# import the necessary packages\nfrom string import ascii_lowercase\n\n# define the length of the string\nlen_string = len('ab')\n\n# the function that will be used to test\ndef test(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going to be used\ndef check(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going to be used\ndef check_reverse(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going to be used\ndef check_two(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b' and string[3] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going to be used\ndef check_three(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b' and string[3] == 'b' and string[4] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going to be used\ndef check_four(string):\n    if len(string) == len_string and string[0] == 'a' and string[1] == 'b' and string[2] == 'b' and string[3] == 'b' and string[4] == 'b' and string[5] == 'b':\n        return True\n    else:\n        return False\n\n# create the function that is going",
    "class Solution:\n    # @return a string\n    def check(self, s):\n        if len(s) < 2:\n            return False\n        for i in range(2, len(s)):\n            if s[i - 1]!= 'a' or s[i]!= 'b':\n                return False\n        return True\n    \n    def isMatch(self, s):\n        return self.check(s)"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}