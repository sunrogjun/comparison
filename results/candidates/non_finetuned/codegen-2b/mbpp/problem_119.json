{
  "problem": {
    "task_id": "MBPP/130",
    "prompt": "Write a function to find the item with maximum frequency in a given list.",
    "canonical_solution": "from collections import defaultdict\r\ndef max_occurrences(nums):\r\n    dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result",
    "test_list": [
      "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)",
      "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)",
      "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)"
    ],
    "challenge_test_list": [],
    "problem_id": 119
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import collections\n\n# @include\ndef max_frequency(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(max_frequency_helper(nums))\n\n\ndef max_frequency_helper(nums):\n    # Hash table to store frequency of each element.\n    freq_table = collections.defaultdict(int)\n    for num in nums:\n        freq_table[num] += 1\n\n    # Iterate through the keys in the table to find the max frequency.\n    max_freq = 0\n    for key in freq_table:\n        if freq_table[key] > max_freq:\n            max_freq = freq_table[key]\n    return max_freq\n# @exclude\n\n\ndef main():\n    nums = [1, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3]\n    print(max_frequency(nums))\n\n\nif __name__ == '__main__':\n    main()",
    "# https://www.hackerrank.com/challenges/find-the-most-frequent-item\n\ndef find_most_frequent(nums):\n    max_count = 0\n    max_index = 0\n    for i in range(len(nums)):\n        if nums[i] > max_count:\n            max_count = nums[i]\n            max_index = i\n    return max_index\n\nif __name__ == '__main__':\n    nums = [1, 1, 2, 2, 3, 3]\n    print(find_most_frequent(nums))",
    "# https://leetcode.com/problems/find-maximum-frequency-element-in-a-sorted-array/discuss/221829/Python-solution-using-recursion-and-hashmap\n\nclass Solution(object):\n    def findMaxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n\n        def maxFrequency(nums, i):\n            if i >= len(nums):\n                return 0\n            if i == len(nums) - 1:\n                return nums[i]\n            if nums[i] > nums[i + 1]:\n                return maxFrequency(nums, i + 1)\n            return max(maxFrequency(nums, i + 1), nums[i] + maxFrequency(nums[i + 1:], i + 1))\n\n        return maxFrequency(nums, 0)\n\n\nif __name__ == '__main__':\n    nums = [1, 1, 2]\n    print(Solution().findMaxFrequency(nums))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMaxNode(self, head):\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        max_node = slow\n        while slow.next:\n            if slow.next.val > max_node.val:\n                max_node = slow.next\n            slow = slow.next\n        return max_node",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return None\n        \n        max_freq = 0\n        curr = head\n        while curr:\n            if curr.next and curr.next.val > max_freq:\n                max_freq = curr.next.val\n                curr = curr.next\n            else:\n                curr = curr.next\n                \n        return head.val if max_freq == 0 else head",
    "# https://www.hackerrank.com/challenges/max-frequency/problem\n\ndef max_frequency(data):\n    # This is a simple implementation of max frequency.\n    # If the frequency of a word is greater than the frequency of\n    # any word in the list, we will consider the word the maximum.\n    # For example, if the input is [a, b, c, a, b, c], we will\n    # consider a to be the maximum.\n    max_freq = 0\n    for word in data:\n        if word in data:\n            if data[word] > max_freq:\n                max_freq = data[word]\n    return max_freq\n\nif __name__ == '__main__':\n    data = [1, 2, 3, 1, 2, 3]\n    print(max_frequency(data))",
    "# https://www.hackerrank.com/challenges/find-max-frequency\n\n# Sample Input\n# [2,3,1,2,3,4,2]\n# Sample Output\n# 2\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def findMax(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return max(self.findMax(root.left), self.findMax(root.right)) + 1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    root = TreeNode(2)\n    root.left = TreeNode(3)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(4)\n    print solution.findMax(root)",
    "from collections import Counter\n\ndef find_max_frequency(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: int\n    \"\"\"\n    c = Counter(l)\n    return max(c.keys())\n\n# Your find_max_frequency function will be called like this:\n# find_max_frequency(l)",
    "# https://oj.leetcode.com/problems/find-maximum-frequency-of-a-sublist/\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def findMaxNode(self, head):\n        max_freq = 0\n        max_node = None\n        while head is not None:\n            if head.val > max_freq:\n                max_freq = head.val\n                max_node = head\n            head = head.next\n        return max_node\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    print(s.findMaxNode(head))",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        freq = collections.defaultdict(int)\n        for i in range(n):\n            freq[nums[i]] += 1\n        max_freq = max(freq.values())\n        max_i = 0\n        for i in range(n):\n            if freq[nums[i]] == max_freq:\n                max_i = i\n        return max_i",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxFrequency(self, nums):\n        # write your code here\n        if nums == None or nums == []:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = 1\n        for i in range(n):\n            for j in range(i, n):\n                if nums[i] == nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n\nif __name__ == '__main__':\n    print Solution().maxFrequency([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])",
    "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_freq, max_index = 0, 0\n        for i, num in enumerate(nums):\n            if num not in nums[:max_index]:\n                max_freq = max(max_freq, num)\n            else:\n                max_freq = max(max_freq, nums[max_index] + num)\n            if max_index < i:\n                max_index = i\n        return max_freq",
    "# https://leetcode.com/problems/maximum-frequency-of-words-in-a-string/discuss/156537/Python-solution-with-explanation\n# https://leetcode.com/problems/maximum-frequency-of-words-in-a-string/discuss/156537/Python-solution-with-explanation\n# https://leetcode.com/problems/maximum-frequency-of-words-in-a-string/discuss/156537/Python-solution-with-explanation\n# https://leetcode.com/problems/maximum-frequency-of-words-in-a-string/discuss/156537/Python-solution-with-explanation\n\nimport unittest\n\nclass Solution(object):\n    def maxFrequency(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        max_freq = -1\n        for w in words:\n            max_freq = max(max_freq, w.count(w))\n        return max_freq\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-frequency-of-words-in-a-string/solution/\n\n# 2ms 100%\nclass Solution {\n    public int maxFrequency(String[] words) {\n        int maxFreq = 0;\n        for (int i = 0; i < words.length; i++) {\n            int freq = words[i].chars().filter(c -> c == words[i]).count();\n            maxFreq = Math.max(maxFreq, freq);\n        }\n        return maxFreq;\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public int maxFrequency(String[] words) {\n        int[] freq = new int[26];\n        for (String w : words) {",
    "#!/usr/bin/env python\n\ndef max_freq(items):\n\tmax_freq_dict = {}\n\tfor item in items:\n\t\tif max_freq_dict.get(item) == None:\n\t\t\tmax_freq_dict[item] = 1\n\t\telse:\n\t\t\tmax_freq_dict[item] += 1\n\treturn max_freq_dict.get(max(max_freq_dict.values()))\n\n# Input:\n# [['a', 'a', 'a', 'a'], ['a', 'a', 'b', 'a'], ['a', 'b', 'b', 'a'], ['b', 'a', 'b', 'b'], ['b', 'b', 'c', 'b']]\n# Output:\n# 2\n\nitems = [\n\t[\"a\", \"a\", \"a\", \"a\"],\n\t[\"a\", \"a\", \"b\", \"a\"],\n\t[\"a\", \"b\", \"b\", \"a\"],\n\t[\"b\", \"a\", \"b\", \"b\"],\n\t[\"b\", \"b\", \"c\", \"b\"]\n]\n\nprint max_freq(items)",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        max_node = head.next\n        while max_node.next:\n            if max_node.next.next:\n                max_node = max(max_node.next.next, head)\n            else:\n                max_node = max_node.next\n        return max_node",
    "# https://leetcode.com/problems/find-maximum-frequency-in-a-sorted-array/\n\nclass Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        max_freq = -1\n        max_index = -1\n        for i in xrange(len(nums)):\n            if nums[i] > max_freq:\n                max_freq = nums[i]\n                max_index = i\n        return max_index",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        # get max\n        maxNode = head\n        while maxNode.next:\n            maxNode = maxNode.next\n            if maxNode.next:\n                maxNode = maxNode.next\n                while maxNode.next:\n                    if maxNode.next.val < maxNode.val:\n                        maxNode = maxNode.next\n                    else:\n                        break\n\n        # get max node\n        node = head\n        while node:\n            if node.val < maxNode.val:\n                maxNode = node\n                node = node.next\n            else:\n                break\n        return maxNode\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n\n    solution = Solution()\n    print(solution.findMax(head))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        lst = [head]\n        while lst[-1].next:\n            lst.append(lst[-1].next)\n        freq = [0] * len(lst)\n        for i in range(len(lst)):\n            freq[i] = len(set([t.val for t in lst[i:]]))\n        max_freq = 0\n        for i in range(len(lst)):\n            if freq[i] > max_freq:\n                max_freq = freq[i]\n        return lst[max_freq-1]",
    "import collections\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findDuplicate(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Use a queue to store the nodes and the frequency.\n        # Then, when we visit a node, we check if its next node has the same frequency.\n        # If it does, we add this node to the queue.\n        # If not, we simply push the node to the end of the queue.\n        # Finally, when we pop the head node from the queue, we check if there are more nodes with the same frequency.\n        # If not, return the head node.\n        # If yes, we check the next node in the queue and return that.\n        # If not, we simply return the head node.\n        if not head:\n            return None\n        q = collections.deque()\n        p = head\n        while p:\n            if p.next:\n                if p.next.val == p.val:\n                    q.append(p.next)\n                else:\n                    q.append(p)\n                    p = p.next\n            else:\n                q.append(p)\n                p = None\n        if not q:\n            return head\n        q.append(head)\n        while not q.popleft():\n            pass\n        return q.popleft()\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(2)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # sort the list by frequency\n        nums.sort(key=lambda x: (x, len(nums)))\n        # find the index of the max frequency\n        return nums[-1][0]\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 1, 2, 2, 3, 3, 3, 4, 4, 4]\n    print(sol.maxFrequency(nums))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findPeakElement(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        slow = head\n        fast = head\n        while fast and fast.next:\n            if fast.next.next:\n                slow = slow.next\n                fast = fast.next.next\n            else:\n                slow = slow.next\n                fast = None\n        return slow\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.findPeakElement(head)",
    "# https://leetcode.com/problems/find-maximum-frequency-element-in-a-sorted-matrix/discuss/253761/Python-Solution\nclass Solution(object):\n    def maxFrequency(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        max = -1\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                if matrix[i][j] > max:\n                    max = matrix[i][j]\n        return max\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    matrix = [[1, 3, 1, 3], [1, 5, 1, 3], [1, 3, 1, 1], [1, 4, 1, 2]]\n    print solution.maxFrequency(matrix)",
    "class Solution:\n    # @param nums: a list of integers\n    # @return: an integer\n    def maxFrequency(self, nums):\n        max_freq = 0\n        max_index = 0\n        for i in range(len(nums)):\n            if nums[i] > max_freq:\n                max_freq = nums[i]\n                max_index = i\n        return max_index",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findMaxFrequency(self, head: ListNode) -> ListNode:\n        maxFreq = 0\n        maxNode = None\n        while head is not None:\n            curFreq = 1\n            curNode = head\n            while curNode.next is not None:\n                curFreq += 1\n                curNode = curNode.next\n            if curFreq > maxFreq:\n                maxFreq = curFreq\n                maxNode = head\n            head = head.next\n        return maxNode\n\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l4 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l5 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l6 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))).next\n    l7 = ListNode(1, ListNode(2",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num = 0\n        max_freq = 0\n        for num in nums:\n            if max_freq < num:\n                max_num = num\n                max_freq = num\n            elif max_freq == num:\n                max_num = max(max_num, num)\n        return max_num\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 1, 2, 2, 3]\n    sol = Solution()\n    print(sol.maxFrequency(nums))",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMaxNode(self, head):\n        if not head:\n            return None\n        curr = head\n        while curr.next:\n            if curr.next.next and curr.next.next.val > curr.next.val:\n                curr = curr.next.next\n            else:\n                curr = curr.next\n        return curr\n\n    def maxNode(self, head):\n        if not head:\n            return None\n        curr = head\n        while curr.next:\n            if curr.next.next and curr.next.val > curr.next.next.val:\n                curr = curr.next.next\n            else:\n                curr = curr.next\n        return curr\n\n    def maxNode2(self, head):\n        if not head:\n            return None\n        curr = head\n        while curr.next:\n            if curr.next.val > curr.next.next.val:\n                curr = curr.next\n            else:\n                curr = curr.next\n        return curr\n\n\n    def maxNode3(self, head):\n        if not head:\n            return None\n        curr = head\n        maxVal = curr.val\n        while curr.next:\n            if curr.next.val > maxVal:\n                maxVal = curr.next.val\n            curr = curr.next\n        return curr\n\nsol = Solution()\n\n# print sol.maxNode(None)\n# print sol.maxNode([])\n# print sol.maxNode([1,2,3])\n# print sol.maxNode([1,2,3,3])\n# print sol.maxNode([1,2,3,4])\n# print sol.maxNode([1,2,3,4,5,6,7,8,9])\n# print sol.",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        if head.next.next:\n            maxNode = self.findMaxNode(head.next.next)\n        else:\n            maxNode = head.next\n        \n        cur = head\n        while cur and cur.next:\n            if cur.next.next and cur.next.next.next:\n                maxNode = maxNode.next\n            cur = cur.next.next\n        return maxNode",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findMaxFreq(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        \n        curr = head\n        count = 0\n        while curr:\n            if curr.next:\n                curr = curr.next\n                count += 1\n            else:\n                curr = None\n                \n        return count",
    "def maxFrequency(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    f = collections.Counter(nums)\n    return f.most_common(1)[0][0]",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        max_val = -1\n        curr = head\n        while curr:\n            curr = self.max_consecutive(curr)\n            if curr and curr.val == 1:\n                max_val = max(max_val, curr.val)\n        \n        return head\n    \n    def max_consecutive(self, head):\n        \n        curr = head\n        ans = None\n        \n        while curr:\n            prev = curr.next\n            while prev and prev.val == curr.val:\n                prev = prev.next\n            \n            if prev and prev.val == 1:\n                if ans and ans.val < prev.val:\n                    ans = prev\n                else:\n                    ans = curr\n            \n            curr = curr.next\n        \n        return ans",
    "# https://leetcode.com/problems/find-maximum-frequency-in-a-sorted-array/\n\nclass Solution(object):\n    def findMaximumFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/find-maximum-frequency/discuss/27092/Python-solution-with-similar-ideas-and-comments\n        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        for i in xrange(n):\n            dp[i] = nums[i]\n        max_freq = nums[0]\n        max_pos = 0\n        for i in xrange(n):\n            max_freq = max(max_freq, dp[i])\n            if dp[i] == max_freq:\n                max_pos = i + 1\n        return max_pos",
    "def find_max_frequency(my_list):\n    \"\"\"\n    :type my_list: List[int]\n    :rtype: int\n    \"\"\"\n    return max(my_list, key=my_list.count)\n\nif __name__ == \"__main__\":\n    print(find_max_frequency([1,1,1,2,2,3,3,4,4,4,5,6,7,7,7,7,8,8,8,8]))",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_freq = 0\n        max_idx = 0\n        for idx, num in enumerate(nums):\n            if num > max_freq:\n                max_idx = idx\n                max_freq = num\n        return max_idx + 1\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 1, 3, 1, 5, 8]\n    print(Solution().maxFrequency(nums))",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        max_freq = 0\n        max_index = 0\n        for i in range(n):\n            if nums[i] > max_freq:\n                max_index = i\n                max_freq = nums[i]\n        return max_index",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def findMaxNode(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        max_node = head\n        current_node = head\n        while current_node:\n            if current_node.next and current_node.next.next:\n                current_node = current_node.next.next\n                max_node = current_node.next\n            else:\n                break\n        return max_node",
    "from collections import Counter\n\ndef findMaxFrequency(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    return max(Counter(numbers).most_common()[0][1])\n\nif __name__ == '__main__':\n    numbers = [1, 2, 2, 3, 2, 4, 2, 5, 2, 6]\n    print(findMaxFrequency(numbers))",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxFrequency(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        def find_max_node(node, max_node, max_val):\n            if not node:\n                return\n\n            if node.val == max_val:\n                max_node.left = node\n                return\n            elif node.val > max_val:\n                max_node.left = None\n                max_node.val = node.val\n                return\n            elif node.val < max_val:\n                max_node.val = node.val\n                return\n            else:\n                find_max_node(node.left, max_node, node.val)\n                find_max_node(node.right, max_node, node.val)\n\n        max_node = TreeNode(0)\n        find_max_node(root, max_node, 0)\n\n        return max_node.val",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if head is None or head.next is None:\n            return 0\n\n        max_num = 0\n        curr = head\n        while curr.next:\n            curr = curr.next\n            if curr.next is None:\n                break\n            if curr.next.val > max_num:\n                max_num = curr.next.val\n        return max_num\n\n    def findMax2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if head is None or head.next is None:\n            return 0\n        max_num = head.val\n        curr = head\n        while curr.next:\n            curr = curr.next\n            if curr.next is None:\n                break\n            if curr.next.val > max_num:\n                max_num = curr.next.val\n        return max_num\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        dic = {}\n        cur = head\n        while cur:\n            if cur.val in dic:\n                dic[cur.val] += 1\n            else:\n                dic[cur.val] = 1\n            cur = cur.next\n        max = -1\n        for k, v in dic.items():\n            if v > max:\n                max = v\n        return max",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        node = head\n        while node:\n            if node.next:\n                node = node.next\n            else:\n                node = None\n                break\n        maxNode = head\n        while node:\n            if node.val > maxNode.val:\n                maxNode = node\n            node = node.next\n        return maxNode\n\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        node = head\n        while node.next:\n            node = node.next\n            if node.next:\n                node = node.next\n            else:\n                node = None\n                break\n        maxNode = node\n        while node:\n            if node.val > maxNode.val:\n                maxNode = node\n            node = node.next\n        return maxNode",
    "# https://www.hackerearth.com/practice/algorithms/data-structures/lists/solution/\n\n\ndef find_max_freq(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: int\n    \"\"\"\n    max_freq = 0\n    for i in range(len(list_)):\n        if list_[i] > max_freq:\n            max_freq = list_[i]\n    return max_freq\n\n\ndef find_max_freq_recursive(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: int\n    \"\"\"\n    if len(list_) == 0:\n        return 0\n    max_freq = 0\n    for i in range(len(list_)):\n        if list_[i] > max_freq:\n            max_freq = list_[i]\n    return max_freq\n\n\ndef main():\n    \"\"\"\n    >>> find_max_freq([2, 1, 2, 3, 1, 4, 3, 3, 2])\n    4\n    >>> find_max_freq([1, 1, 1, 1, 1, 1])\n    1\n    >>> find_max_freq([1, 2, 3, 4, 1, 2])\n    4\n    >>> find_max_freq([2, 3, 4, 1, 2, 3])\n    4\n    >>> find_max_freq([1, 2, 3, 4, 1, 2, 3])\n    4\n    >>> find_max_freq([1, 2, 3, 4, 1, 2, 3, 4])\n    4\n    >>> find_max_freq([1, 2, 3, 4, 1, 2, 3, 4, 1])\n    4\n    >>> find_max_freq([1, 2, 3, 4, 1, 2, 3, 4, 1, 2])\n    4\n    \"\"\"\n    print(find_max_freq([2, 1, 2, 3, 1, 4, 3, 3, 2]))\n    print(find_max_freq([1, 1,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        max_freq = 0\n        p = head\n        while p:\n            if p.next:\n                max_freq = max(max_freq, p.next.val)\n            p = p.next\n        \n        max_freq = 0\n        p = head\n        while p:\n            if p.val == max_freq:\n                return p\n            if p.next:\n                if p.next.val > max_freq:\n                    max_freq = p.next.val\n            p = p.next\n        \n        return None\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next.next = ListNode(1)\n    head.next.next.next.next.next.next.next.next = ListNode(1)\n    head.next.next.next.next.next.next.next.next.next = ListNode(1)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(2)",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def findMaxNode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        if not root.left and not root.right:\n            return root\n        if not root.left:\n            return self.findMaxNode(root.right)\n        if not root.right:\n            return self.findMaxNode(root.left)\n        node = root.right\n        while node.left:\n            node = node.left\n        return node",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        h = head\n        max_freq = head.val\n        while h:\n            if h.next and h.next.val == max_freq:\n                max_freq = h.next.val\n                h = h.next\n            else:\n                h = h.next\n        return head if max_freq == head.val else head.next\n\n\nif __name__ == '__main__':\n    n1 = ListNode(1)\n    n2 = ListNode(2)\n    n3 = ListNode(3)\n    n4 = ListNode(4)\n    n5 = ListNode(5)\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    n4.next = n5\n    n5.next = None\n\n    head = n1\n    print Solution().maxFrequency(head)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMaxNode(self, head):\n        if head is None:\n            return None\n        maxNode = head\n        while maxNode.next is not None:\n            maxNode = maxNode.next\n            while maxNode.next is not None and maxNode.next.next is not None:\n                maxNode = maxNode.next.next\n        return maxNode\n\nif __name__ == '__main__':\n    print Solution().findMaxNode([1,2,3,1])",
    "# https://www.hackerrank.com/challenges/find-the-maximum-frequency/problem\n\ndef find_max_frequency(list):\n    max_freq = 0\n    for item in list:\n        if item in list:\n            if list.count(item) > max_freq:\n                max_freq = list.count(item)\n    return max_freq\n\nif __name__ == '__main__':\n    list = [1, 1, 2, 1, 3, 3, 4]\n    print(find_max_frequency(list))",
    "# https://www.geeksforgeeks.org/write-a-function-to-find-the-item-with-maximum-frequency-in-a-given-list/\n\n\ndef find_max_freq(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # Find max frequency\n    max_freq = 0\n    for i in range(len(arr)):\n        if arr[i] > max_freq:\n            max_freq = arr[i]\n    # Find item with max frequency\n    max_freq_item = 0\n    for i in range(len(arr)):\n        if arr[i] == max_freq:\n            max_freq_item = i\n    return max_freq_item\n\n\nif __name__ == '__main__':\n    test_cases = [\n        [2, 1, 3, 2, 3],\n        [1, 3, 2, 2, 1, 3],\n        [1, 3, 2, 3, 2, 3],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        max_freq = 0\n        max_node = None\n\n        while head:\n            freq = 1\n            curr = head\n            while curr.next:\n                if curr.next.val == curr.val:\n                    freq += 1\n                else:\n                    freq = 1\n                curr = curr.next\n            if freq > max_freq:\n                max_freq = freq\n                max_node = head\n            head = head.next\n        return max_node",
    "def find_max_frequency(list):\n  \"\"\"\n  Find the item with maximum frequency in a given list.\n\n  Input: A list of integers.\n\n  Output: The item with maximum frequency.\n  \"\"\"\n  max_frequency = 0\n  max_item = 0\n  for item in list:\n    if item in max_frequency_set:\n      if item > max_frequency:\n        max_frequency = item\n        max_item = item\n    else:\n      max_frequency_set.add(item)\n      if item > max_frequency:\n        max_frequency = item\n        max_item = item\n  return max_item\n\nmax_frequency_set = set()\n\ndef test_find_max_frequency():\n  assert find_max_frequency([1,2,3,4,5,6]) == 6\n  assert find_max_frequency([1,1,1,2,3]) == 3\n  assert find_max_frequency([1,2,3]) == 3\n  assert find_max_frequency([]) == 0\n  assert find_max_frequency(['a','b','c']) == 'c'\n\nif __name__ == \"__main__\":\n  test_find_max_frequency()",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findMaxAverage(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if not root:\n            return 0\n        ans = self.findMaxAverage(root.left, k)\n        ans += root.val\n        ans /= k\n        ans += self.findMaxAverage(root.right, k)\n        ans /= k\n        return ans\n\n    def findMaxAverage2(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: float\n        \"\"\"\n        if not root:\n            return 0\n        ans = self.findMaxAverage2(root.left, k)\n        ans += root.val\n        ans /= k\n        ans += self.findMaxAverage2(root.right, k)\n        ans /= k\n        return ans",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMaxForm(self, nums):\n        if not nums:\n            return None\n        \n        max_num = nums[0]\n        max_pos = 0\n        max_num_pos = 0\n        \n        for i in range(1, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n                max_pos = i\n                max_num_pos = 0\n            elif nums[i] == max_num:\n                max_num_pos += 1\n        \n        return max_pos",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def findMaximizedRep(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Complete this function\n        curr = head\n        while curr:\n            if curr.next and curr.next.next:\n                if curr.val > curr.next.next.val:\n                    curr = curr.next\n                else:\n                    curr = curr.next.next\n            else:\n                curr = curr.next\n        return curr",
    "# https://www.geeksforgeeks.org/write-a-function-to-find-the-item-with-maximum-frequency-in-a-given-list/\n\n# 1. Create a function to find the maximum frequency item in a given list.\ndef maxFrequency(items):\n    # 2. Create a dictionary to store the frequency of each item.\n    frequencyDict = {}\n\n    # 3. Iterate over the list and add the frequency of the item to the dictionary.\n    for item in items:\n        if item in frequencyDict:\n            frequencyDict[item] += 1\n        else:\n            frequencyDict[item] = 1\n\n    # 4. Iterate over the dictionary to find the maximum frequency item and return its value.\n    for key, value in frequencyDict.items():\n        if value > frequencyDict[key]:\n            frequencyDict[key] = value\n    return frequencyDict[max(frequencyDict, key=lambda x: frequencyDict[x])]\n\n# Test cases\nprint(maxFrequency(['a', 'b', 'a', 'b', 'a', 'b']))\nprint(maxFrequency(['a', 'b', 'a', 'a', 'a']))\nprint(maxFrequency(['a', 'a', 'a', 'a', 'a']))",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print sol.maxDepth(root)",
    "from collections import defaultdict\n\n# The input will be a list of integers.\n# The frequency of an integer is the number of times it appears in the list.\n#\n# Example:\n#\n# Input: [1,2,3,1,2,3,3,2,3,4,2,3]\n# Output: 3\n# Explanation:\n# 1 appears three times,\n# 2 appears three times,\n# 3 occurs three times.\n# So 3 is the item with maximum frequency.\n\n\nclass Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        dic = defaultdict(int)\n        for n in nums:\n            dic[n] += 1\n        return max(dic.iteritems(), key=lambda x: x[1])[0]",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        maxNode = head\n        while maxNode and maxNode.next:\n            if maxNode.next.next and maxNode.next.val < maxNode.next.next.val:\n                maxNode = maxNode.next.next\n            else:\n                maxNode = maxNode.next\n        return maxNode\n\n    def findMaxNode2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        maxNode = head\n        while maxNode.next:\n            if maxNode.next.val < maxNode.next.next.val:\n                maxNode = maxNode.next\n            else:\n                maxNode = maxNode.next\n        return maxNode\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    l1 = ListNode(1)\n    l1.next = ListNode(2)\n    l1.next.next = ListNode(3)\n    l1.next.next.next = ListNode(4)\n    l1.next.next.next.next = ListNode(5)\n    l1.next.next.next.next.next = ListNode(6)\n    l1.next.next.next.next.next.next = ListNode(7)\n    l1.next.next.next.next.next.next.next = ListNode(8)\n    l1.next.next.next.next.next.next.next.next = ListNode(9)\n    l2 = ListNode(1)\n    l2.next = ListNode(2)\n    l2.next.next = ListNode(3)\n    l2.next.next.next = ListNode(4)\n    l2.next.next.next.next =",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxFrequency(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        max_count = 0\n        max_node = None\n        if root:\n            max_count = 1\n            max_node = root\n            while max_node.left:\n                max_node = max_node.left\n                max_count += 1\n        return max_count",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode(self, head):\n        if head is None or head.next is None:\n            return head\n        l = head\n        r = head\n        while r.next is not None:\n            l = l.next\n            r = r.next\n            if l.next is not None:\n                r = r.next\n            if l.next is None:\n                r = r.next\n        return r\n        \n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode2(self, head):\n        if head is None or head.next is None:\n            return head\n        maxNode = head\n        while head.next is not None:\n            maxNode = head\n            head = head.next\n            if head.next is not None:\n                if head.next.val > maxNode.val:\n                    maxNode = head.next\n        return maxNode\n        \n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode3(self, head):\n        if head is None or head.next is None:\n            return head\n        maxNode = head\n        while head.next is not None:\n            if head.next.val > maxNode.val:\n                maxNode = head.next\n            head = head.next\n        return maxNode\n        \n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode4(self, head):\n        if head is None or head.next is None:\n            return head\n        maxNode = head\n        while head.next is not None:\n            if head.next.val > maxNode.val:\n                maxNode = head.next\n            head = head.next\n        return maxNode\n        \n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode5(self, head):\n        if head is None or head.next is None:\n            return head\n        maxNode =",
    "# https://www.hackerrank.com/challenges/find-the-most-frequent-item\n# Solution:\n# - We get the sorted list.\n# - We iterate through the list, checking if the current element is already in the dictionary.\n# - If it is not, we add it to the dictionary.\n# - We then return the key of the dictionary.\n# - If the dictionary is empty, we return -1.\ndef findMaxFrequency(arr):\n    dic = {}\n    for i in arr:\n        if i not in dic:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n    max_freq = -1\n    for key in dic:\n        if dic[key] > max_freq:\n            max_freq = dic[key]\n    return max_freq if max_freq!= -1 else -1\n\n# Test Cases:\n# arr = [1, 2, 3, 1, 2, 3]\n# arr = [1, 1, 2, 2, 3, 3]\n# arr = [1, 2, 3, 4, 5, 6]\n# arr = [1, 2, 3, 4, 5, 6]\n# arr = [1, 2, 3, 4, 5, 6, 7]\narr = [1, 2, 3, 4, 5, 6, 7]\nprint(findMaxFrequency(arr))",
    "#!/usr/bin/python\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nGiven a non-empty list of integers, return the k most frequent elements.\n\nExample:\n\nGiven [1,1,1,2,2,3] and k = 2, return [1,2].\n\nNote:\nYou may assume k is always valid, 1 \u2264 k \u2264 number of unique elements.\n\nFollow up:\nWhat if the list is already sorted? How would you optimize your algorithm?\nWhat if you cannot use additional data structures?\nWhat if the list size is very large?\n\n\"\"\"\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def kthToMax(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        max_node = head\n        max_val = head.val\n        curr = head.next\n        while k > 0:\n            curr = curr.next\n            k -= 1\n        while curr:\n            max_node = max_node.next if curr.val > max_val else max_node\n            max_val = curr.val\n            curr = curr.next\n        return max_node\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(2)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.",
    "import sys\n\n\nclass Solution(object):\n\n    def findMaxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        # nums_frequencies[i] = max(nums_frequencies[i-1], nums[i])\n        max_frequencies = [0] * n\n        for i in range(1, n):\n            max_frequencies[i] = max(max_frequencies[i-1], nums[i])\n        max_frequencies.append(0)\n        for i in range(n - 1, -1, -1):\n            max_frequencies[i] = max(max_frequencies[i + 1], nums[i])\n        return max(max_frequencies)\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 1, 2, 2, 3]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 1, 1, 2, 2, 3]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3, 1, 2, 3]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1]\n    print Solution().findMaxFrequency(nums)\n    nums = [1]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3, 4]\n    print Solution().findMaxFrequency(nums)\n    nums = [1, 2, 3, 4, 5]\n    print",
    "from collections import Counter\n\n\ndef max_freq_item(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: int\n    \"\"\"\n    counter = Counter(list_)\n    max_key = max(counter, key=counter.get)\n    return max_key\n\n\nif __name__ == '__main__':\n    assert max_freq_item([2, 1, 2, 3, 2, 4, 2, 5]) == 5\n    assert max_freq_item([3, 2, 1, 4, 2, 3, 1, 5]) == 3\n    assert max_freq_item([3, 2, 1, 4, 2, 3, 1, 5, 3, 2, 1, 4, 2, 3, 1, 5]) == 5",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMaxNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        n = 0\n        max = head\n        while max:\n            max = max.next\n            n += 1\n        max = head\n        while max:\n            if n > 1:\n                max = max.next\n                n -= 1\n            else:\n                break\n            if max:\n                max = max.next\n        return max\n\n    def findMaxNode_1(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        max = head\n        while max:\n            if max.next:\n                max = max.next\n                while max.next:\n                    max = max.next\n            else:\n                break\n        return max\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    l1 = ListNode(1)\n    l2 = ListNode(1)\n    l3 = ListNode(2)\n    l1.next = l2\n    l2.next = l3\n    l3.next = ListNode(3)\n    print sol.findMaxNode(l1)\n    print sol.findMaxNode_1(l1)",
    "# https://leetcode.com/problems/maximum-frequency-of-a-character-in-a-string/description/\n\nclass Solution:\n    # @param {string} str\n    # @return {integer}\n    def maxFrequency(self, str):\n        if not str:\n            return 0\n\n        dict = {}\n        for c in str:\n            if c in dict:\n                dict[c] += 1\n            else:\n                dict[c] = 1\n\n        return max(dict.items(), key=lambda x: x[1])[1]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxFrequency(\"abc\")",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMaxNode(self, head):\n        if not head: return None\n        max = head\n        while head.next:\n            if head.next.val > max.val:\n                max = head.next\n            head = head.next\n        return max",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findMaxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        max_freq = head.val\n        max_node = head\n        while max_node.next:\n            if max_freq < max_node.next.val:\n                max_freq = max_node.next.val\n                max_node = max_node.next\n            else:\n                max_node = max_node.next\n        return max_node",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        max_node = head\n        max_node_next = head\n        max_node_count = 1\n        while max_node_next:\n            if max_node_next.val > max_node.val:\n                max_node = max_node_next\n                max_node_count = 1\n            elif max_node_next.val == max_node.val:\n                max_node_count += 1\n            max_node_next = max_node_next.next\n        return max_node.val\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next.next.next.next = ListNode(3)\n    print Solution().findMax(head)",
    "# Your function should return the item with maximum frequency.\n# If the frequency list is not unique, return the first item from the list.\n# Note:\n#     You can assume the list that you are given is always sorted in ascending order.\n#     The frequency list that you are given may have duplicates.\n\nclass Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(nums)\n        return max(count.items(), key=lambda x: x[1])[0]\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxFrequency([1, 1, 1, 2, 2, 3, 3, 3]) == 3\n    assert Solution().maxFrequency([1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4]) == 4",
    "def find_max_frequency(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_freq = 0\n    for num in nums:\n        if num > max_freq:\n            max_freq = num\n    return max_freq\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 1, 2, 3, 4, 1, 2, 3]\n    print(find_max_frequency(nums))",
    "# https://www.geeksforgeeks.org/write-a-function-to-find-the-item-with-maximum-frequency-in-a-given-list/\n\n# TODO:\n# - Use binary search\n# - Use frequency list\n# - Use max_heap\n\n\ndef max_frequency(list_items):\n    \"\"\"\n    Find the maximum frequency in a list.\n\n    :param list_items: list of items\n    :return: The item with maximum frequency.\n    \"\"\"\n    max_freq = 0\n    max_item = 0\n    for item in list_items:\n        if item in list_items:\n            if list_items[item] > max_freq:\n                max_freq = list_items[item]\n                max_item = item\n    return max_item\n\n\ndef main():\n    \"\"\"\n    Test cases:\n    >>> max_frequency([1, 3, 1, 5, 7])\n    7\n    >>> max_frequency([1, 3, 1, 5, 7, 9, 1, 3, 1, 5])\n    9\n    >>> max_frequency([1, 3, 1, 5, 7, 9, 1, 3, 1, 5, 7, 9, 1, 3, 1, 5])\n    9\n    \"\"\"\n    print(max_frequency([1, 3, 1, 5, 7]))\n    print(max_frequency([1, 3, 1, 5, 7, 9, 1, 3, 1, 5]))\n    print(max_frequency([1, 3, 1, 5, 7, 9, 1, 3, 1, 5, 7, 9, 1, 3, 1, 5]))\n    print(max_frequency([1, 3, 1, 5, 7, 9, 1, 3, 1, 5, 7, 9, 1, 3, 1, 5, 7, 9, 1, 3, 1, 5]))\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findMaxFrequency(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Use a stack to store nodes in the list.\n        # The stack is used to store the current node and the next node.\n        # When the current node is popped from the stack, it's value is stored in the current node.\n        # When the next node is popped from the stack, it's value is stored in the next node.\n        # We can then use the stack to find the maximum frequency of all nodes.\n        max_freq = 0\n        stack = []\n        cur_node = head\n        while cur_node:\n            # Update the current node.\n            if cur_node.val > max_freq:\n                max_freq = cur_node.val\n            stack.append(cur_node)\n            cur_node = cur_node.next\n        # Pop the nodes from the stack in reverse order.\n        while stack:\n            cur_node = stack.pop()\n            cur_node.val = max_freq\n            if cur_node.next:\n                stack.append(cur_node.next)\n        return head\n\n\nif __name__ == '__main__':\n    # This is the sample input.\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))\n    head = ListNode(5, ListNode(6, ListNode(7, ListNode(8))))\n    head = ListNode(9, ListNode(10, ListNode(11, ListNode(12))))\n    head = ListNode(13, ListNode(14, ListNode(15, ListNode(16))))\n    head = ListNode(17, ListNode(18, ListNode(19, ListNode(20))))\n    head = ListNode(21, ListNode(22, ListNode(23, ListNode(24))))\n    head = ListNode(25, ListNode(26,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n\n        max_num = 0\n        max_head = head\n        while max_head:\n            if max_head.val < max_num:\n                max_num = max_head.val\n            max_head = max_head.next\n        return max_num\n\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        max_num = 0\n        max_head = head\n        while max_head:\n            if max_head.val < max_num:\n                max_num = max_head.val\n            max_head = max_head.next\n        return max_num\n\nif __name__ == \"__main__\":\n    # n1 = ListNode(1)\n    # n2 = ListNode(2)\n    # n3 = ListNode(3)\n    # n4 = ListNode(4)\n    # n5 = ListNode(5)\n    # n6 = ListNode(6)\n    # n7 = ListNode(7)\n    # n8 = ListNode(8)\n    # n9 = ListNode(9)\n    # n10 = ListNode(10)\n    # n11 = ListNode(11)\n    # n12 = ListNode(12)\n    # n13 = ListNode(13)\n    # n14 = ListNode(14)\n    # n15 = ListNode(15)\n    # n16 = ListNode(16)\n    # n17 = ListNode(17)\n    # n18 = ListNode(18)\n    # n19 = ListNode(19)\n    # n20 = ListNode(20)\n    # n21 = ListNode(21)\n    # n22 = ListNode(22)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution(object):\n    def findMaxFreq(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        dic = {}\n        curr = head\n        while curr:\n            if curr.val in dic:\n                dic[curr.val] += 1\n            else:\n                dic[curr.val] = 1\n            curr = curr.next\n        maxv = -1\n        maxcnt = 0\n        for key, value in dic.items():\n            if value > maxcnt:\n                maxv = key\n                maxcnt = value\n        return ListNode(maxv)\n\nif __name__ == '__main__':\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    print(sol.findMaxFreq(head))",
    "def find_max_frequency(input_list):\n    \"\"\"\n    :type input_list: List[int]\n    :rtype: int\n    \"\"\"\n    if not input_list:\n        return None\n\n    max_freq = 0\n    max_idx = 0\n\n    for i in range(len(input_list)):\n        if input_list[i] > max_freq:\n            max_freq = input_list[i]\n            max_idx = i\n\n    return max_idx\n\n\nif __name__ == '__main__':\n    print(find_max_frequency([1, 2, 3, 1, 2, 3, 4, 1, 2, 3]))\n    print(find_max_frequency([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    print(find_max_frequency([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    print(find_max_frequency([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    print(find_max_frequency([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))",
    "# https://www.hackerearth.com/practice/data-structures/arrays/lists/sort-and-search/practice-problems/algorithm/max-frequency-of-an-item-in-a-given-list/\n# https://www.hackerearth.com/practice/data-structures/arrays/lists/sort-and-search/practice-problems/algorithm/maximum-frequency-of-an-item-in-a-given-list/\n\n\ndef max_frequency(list):\n    max_freq = 0\n    max_idx = 0\n    for i in range(len(list)):\n        if list[i] > max_freq:\n            max_freq = list[i]\n            max_idx = i\n    return max_idx",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        max_val = 0\n        while cur:\n            if cur.val == 0:\n                cur = cur.next\n                continue\n            if cur.val > max_val:\n                max_val = cur.val\n                cur = cur.next\n            else:\n                cur = cur.next\n        return head\n\n    def findMaxConsecutiveOnes1(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        max_val = 0\n        while cur:\n            if cur.val == 0:\n                cur = cur.next\n                continue\n            if cur.val > max_val:\n                max_val = cur.val\n                cur = cur.next\n            else:\n                cur = cur.next\n        return head\n\nif __name__ == \"__main__\":\n    n1 = ListNode(1)\n    n2 = ListNode(1)\n    n3 = ListNode(1)\n    n4 = ListNode(0)\n    n5 = ListNode(0)\n    n6 = ListNode(0)\n    n7 = ListNode(0)\n    n8 = ListNode(0)\n    n9 = ListNode(0)\n    n10 = ListNode(0)\n    n11 = ListNode(1)\n    n12 = ListNode(1)\n    n13 = ListNode(1)\n    n14 = ListNode(1)\n    n15 = ListNode(1)\n    n16 = ListNode(1)\n    n17 = ListNode(1)\n    n18 = ListNode(1)\n    n19 = ListNode(1)\n    n20 = ListNode(1)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        max_freq = 0\n        curr = head\n        while curr:\n            curr_freq = 1\n            curr_next = curr.next\n            while curr_next:\n                curr_freq += 1\n                curr_next = curr_next.next\n            if curr_freq > max_freq:\n                max_freq = curr_freq\n            curr = curr.next\n\n        return head if max_freq == 0 else head.next\n\nif __name__ == \"__main__\":\n    head = ListNode(1, ListNode(2, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(1)))))))\n    head = Solution().maxFrequency(head)\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(3, ListNode(4, ListNode(5, ListNode(1)))))))\n    head = Solution().maxFrequency(head)\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(1)))))))\n    head = Solution().maxFrequency(head)\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()",
    "# https://www.hackerrank.com/challenges/find-the-most-frequent-item-in-a-list\n# https://www.hackerrank.com/challenges/find-the-most-frequent-item-in-a-list-v2/problem\n# https://www.hackerrank.com/challenges/find-the-most-frequent-item-in-a-list-v3/problem\n\n\n# TODO:\n# Find the most frequent item in a list.\n# Find the most frequent item in a list.\n# Find the most frequent item in a list.\n# Find the most frequent item in a list.\n\n\ndef max_freq(lst):\n    max_freq = 0\n    max_freq_i = 0\n    for i in range(len(lst)):\n        if lst[i] > max_freq:\n            max_freq = lst[i]\n            max_freq_i = i\n    return max_freq, max_freq_i\n\n\ndef max_freq_v2(lst):\n    max_freq = 0\n    max_freq_i = 0\n    for i in range(len(lst)):\n        if lst[i] > max_freq:\n            max_freq = lst[i]\n            max_freq_i = i\n            break\n    return max_freq, max_freq_i\n\n\ndef max_freq_v3(lst):\n    max_freq = 0\n    max_freq_i = 0\n    for i in range(len(lst)):\n        if lst[i] > max_freq:\n            max_freq = lst[i]\n            max_freq_i = i\n    return max_freq, max_freq_i\n\n\nif __name__ == '__main__':\n    n = int(input())\n    lst = []\n    for _ in range(n):\n        lst.append(int(input()))\n\n    print(max_freq(lst))\n    print(max_freq_v2(lst))",
    "# https://leetcode.com/problems/maximum-frequency-of-a-character-in-a-string/\n\nclass Solution(object):\n    def maxFrequency(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n\n        # map of character to frequency\n        freq = {}\n        for ch in s:\n            if ch not in freq:\n                freq[ch] = 1\n            else:\n                freq[ch] += 1\n\n        # find max frequency\n        max_freq = 0\n        for ch in freq:\n            if freq[ch] > max_freq:\n                max_freq = freq[ch]\n\n        # return max frequency\n        return max_freq",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nhttps://oj.leetcode.com/problems/maximum-frequency-of-one-in-a-binary-search-tree/\n\nGiven a binary tree, find the maximum frequency of 1 in the tree.\n\nThe frequency of 1 in a binary tree is the number of nodes with value 1\ndivided by the total nodes in the tree.\n\nExample:\n\n    1\n   / \\\n  2   3\n / \\\n4   5\n\n1's frequency in the tree is 2/5, and the answer is 1.\n\"\"\"\n\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxFrequency1(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n\n        left = self.maxFrequency1(root.left)\n        right = self.maxFrequency1(root.right)\n\n        if left == 0:\n            return right\n        elif right == 0:\n            return left\n        else:\n            return max(left, right) / max(left + right, 1)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(1)\n    root.right = TreeNode(0)\n    print(sol.maxFrequency1(root))\n\n    root = TreeNode(1)\n    root.left = TreeNode(1)\n    root.right = TreeNode(1)\n    print(sol.maxFrequency1(root))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        counts = {}\n        cur = head\n        while cur:\n            if cur.val in counts:\n                counts[cur.val] += 1\n            else:\n                counts[cur.val] = 1\n            cur = cur.next\n        max_cnt = 0\n        for k, v in counts.iteritems():\n            if v > max_cnt:\n                max_cnt = v\n        max_cnt = max_cnt + 1\n        cur = head\n        while cur:\n            if cur.val in counts and counts[cur.val] == max_cnt:\n                return cur\n            cur = cur.next\n        return None",
    "import collections\n\nclass Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_freq = collections.Counter()\n        for num in nums:\n            max_freq[num] += 1\n        max_freq = max_freq.most_common(1)\n        return max_freq[0][0]",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def helper(num, list):\n            return max([list.count(i) for i in list if i == num])\n\n        max_freq = 0\n        for num in nums:\n            max_freq = max(max_freq, helper(num, nums))\n        return max_freq\n\nif __name__ == \"__main__\":\n    nums = [2,1,2,3,1,5,3,5]\n    print Solution().maxFrequency(nums)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        # build the frequency dictionary\n        count = {}\n        cur = head\n        while cur:\n            if cur.val in count:\n                count[cur.val] += 1\n            else:\n                count[cur.val] = 1\n\n            cur = cur.next\n\n        # get the maximum value in the dictionary\n        max_count = max(count.values())\n        max_key = max(count, key=count.get)\n        max_node = head\n\n        # traverse the linked list and find the node with max count\n        while max_count > 1:\n            # find the node with max count\n            while max_count > 1 and max_node.next:\n                if count[max_node.next.val] < max_count:\n                    max_count = count[max_node.next.val]\n                    max_node = max_node.next\n\n            # move to the next node\n            max_node = max_node.next\n            max_count -= 1\n\n        return max_node\n\ns = Solution()\n\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(3)\nhead.next.next.next = ListNode(4)\nhead.next.next.next.next = ListNode(5)\n\nprint(s.maxFrequency(head))",
    "# https://www.hackerrank.com/challenges/find-max-frequency\ndef max_frequency(lst):\n    # Write your code here\n    # Initialize maximum frequency to 0\n    max_freq = 0\n\n    # Initialize list counter to 0\n    list_counter = 0\n\n    # Initialize max_freq to 0\n    max_freq = 0\n\n    # Iterate over the list\n    for item in lst:\n        # Increment list counter\n        list_counter = list_counter + 1\n\n        # If item is greater than max_freq\n        if item > max_freq:\n            # Set max_freq to item\n            max_freq = item\n\n    return max_freq\n\n# Driver code\nlst = [1, 1, 1, 2, 3, 1, 2, 3, 4]\n\nprint max_frequency(lst)",
    "import collections\n\n# https://leetcode.com/problems/find-the-most-frequent-item-in-an-array/discuss/162635/Python-solution\ndef findMaxFreq(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_freq = collections.defaultdict(int)\n    for num in nums:\n        max_freq[num] += 1\n    max_freq = collections.OrderedDict(sorted(max_freq.items(), key=lambda t: -t[1]))\n    return max_freq[nums[0]]",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        n = 0\n        dic = {}\n        while head:\n            if head.val in dic:\n                dic[head.val] += 1\n            else:\n                dic[head.val] = 1\n            n += 1\n            head = head.next\n        for i in dic:\n            dic[i] = dic[i] / n\n        maxv = 0\n        maxpos = 0\n        for i in dic:\n            if dic[i] > maxv:\n                maxv = dic[i]\n                maxpos = i\n        return maxpos\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1, ListNode(2, ListNode(3, ListNode(1, ListNode(1))))),\n    l2 = ListNode(1, ListNode(1, ListNode(1, ListNode(1))), ListNode(1, ListNode(2, ListNode(3))), ListNode(2, ListNode(3))),\n    l3 = ListNode(1, ListNode(1, ListNode(2))),\n    l4 = ListNode(1, ListNode(1, ListNode(1), ListNode(1, ListNode(1), ListNode(1))), ListNode(1, ListNode(1))),\n    l5 = ListNode(1, ListNode(1), ListNode(2, ListNode(3))),\n    l6 = ListNode(1, ListNode(1), ListNode(2, ListNode(3))),\n    l7 = ListNode(1, ListNode(1, ListNode(2))),\n    l8 = ListNode(1, ListNode(1, ListNode(1), ListNode(1), ListNode(1))),\n    l9 = ListNode(1, ListNode(1, ListNode(1",
    "from collections import Counter\n\ndef find_max_freq_item(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: int\n    \"\"\"\n    # get a counter object for each element\n    # count the frequency of each element\n    # return the element with max frequency\n    return max(Counter(l).items(), key=lambda x: x[1])[0]",
    "class Solution(object):\n    def findMaxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        count = collections.Counter(nums)\n        max_freq = max(count.items(), key=lambda x:x[1])[1]\n        return max_freq",
    "def find_max_freq(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # We need to find the maximum frequency in arr\n    # We will do the following\n    # 1. Count the frequency of all the items\n    # 2. Find the highest frequency item\n    # 3. Return the item number\n    max_freq = 0\n    max_freq_item = 0\n\n    for i in range(len(arr)):\n        # We need to find the item with the maximum frequency\n        # We will do this using the following formula\n        # (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (Frequency of item j)\n        # = (Frequency of item i) + (",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def findMaxFrequency(self, head: ListNode) -> ListNode:\n        maxFreq = 0\n        maxNode = None\n        currNode = head\n        while currNode:\n            if currNode.next and currNode.next.val == currNode.val:\n                currNode.next = currNode.next.next\n            else:\n                currFreq = 1\n                currNode = currNode.next\n            if currNode and currNode.val == currNode.next.val:\n                currFreq += 1\n                currNode = currNode.next\n            else:\n                currFreq += 1\n            if currFreq > maxFreq:\n                maxFreq = currFreq\n                maxNode = currNode\n        return maxNode",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def maxFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        count = 0\n        while slow:\n            if slow.next:\n                count += 1\n            slow = slow.next\n        max_count = 0\n        max_node = None\n        while head:\n            if head.val == max_node.val and count > max_count:\n                max_count = count\n                max_node = head\n            head = head.next\n            count -= 1\n        return max_node\n\n\ndef main():\n    # head = ListNode(1)\n    # head.next = ListNode(2)\n    # head.next.next = ListNode(3)\n    # head.next.next.next = ListNode(4)\n    # head.next.next.next.next = ListNode(5)\n    # head.next.next.next.next.next = ListNode(6)\n    # head.next.next.next.next.next.next = ListNode(7)\n    # head.next.next.next.next.next.next.next = ListNode(8)\n    # head.next.next.next.next.next.next.next.next = ListNode(9)\n    # head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    # head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    # head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    # head.next.next.next.next.next.next.next.next",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_freq = max(nums)\n        return max(nums)",
    "def find_max_freq(list):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n    :type list: List[int]\n    :rtype: int\n    \"\"\"\n    if not list:\n        return 0\n\n    max_freq = list[0]\n    max_index = 0\n\n    for i in range(1, len(list)):\n        if list[i] == list[i - 1]:\n            continue\n        elif list[i] > max_freq:\n            max_freq = list[i]\n            max_index = i\n\n    return max_index\n\n\ndef main():\n    \"\"\"\n    Main entry point.\n    \"\"\"\n    test_cases = [\n        [[1, 2, 2, 3, 1, 5], 5],\n        [[1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5], 5],\n        [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 1]\n    ]\n\n    for test_case, expected in test_cases:\n        actual = find_max_freq(test_case)\n        print(\"Max Freq: {}, Expected: {}\".format(actual, expected))\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def findMax(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        left = self.findMax(root.left)\n        right = self.findMax(root.right)\n\n        if left > right:\n            return left\n        else:\n            return right\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n\n    print s.findMax([1, 2, 3, 3, 4, 5, 5, 6, 7])\n\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n\n    print s.findMax(root)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findMaxFrequency(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        pre, cur = head, head.next\n        max_freq = 0\n        while cur:\n            if cur.val == pre.val:\n                pre = cur\n            else:\n                max_freq = max(max_freq, cur.val)\n            cur = cur.next\n        return head if max_freq > 0 else pre\n\nif __name__ == \"__main__\":\n    s = Solution()\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10))))))))))\n    print(s.findMaxFrequency(head))",
    "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_freq = 0\n        max_freq_num = 0\n        max_freq_count = 0\n        for num in nums:\n            count = 1\n            for i in range(len(nums)):\n                if nums[i] == num:\n                    count += 1\n            if count > max_freq_count:\n                max_freq_count = count\n                max_freq_num = num\n            elif count == max_freq_count:\n                if num > max_freq_num:\n                    max_freq_num = num\n                    max_freq_count = count\n            \n        return max_freq_num\n\nif __name__ == '__main__':\n    nums = [1,1,1,2,2,3]\n    print Solution().maxFrequency(nums)",
    "from collections import Counter\n\nclass Solution(object):\n    def findMaximizedRepetitions(self, items):\n        \"\"\"\n        :type items: List[int]\n        :rtype: int\n        \"\"\"\n        items = list(items)\n        items.sort()\n        result = 0\n        for i in range(1, len(items)):\n            if items[i]!= items[i - 1]:\n                result = max(result, i - 1)\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    items = [1,1,2,2,2,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7",
    "# https://www.hackerrank.com/challenges/max-frequency-of-item-in-a-sorted-array/problem\n# python 3\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range(len(arr)):\n        if arr[index] > maxFrequency:\n            maxFrequency = arr[index]\n            maxFrequencyIndex = index\n    return maxFrequencyIndex, maxFrequency\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range(len(arr)):\n        if arr[index] > maxFrequency:\n            maxFrequency = arr[index]\n            maxFrequencyIndex = index\n    return maxFrequencyIndex, maxFrequency\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range(len(arr)):\n        if arr[index] > maxFrequency:\n            maxFrequency = arr[index]\n            maxFrequencyIndex = index\n    return maxFrequencyIndex, maxFrequency\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range(len(arr)):\n        if arr[index] > maxFrequency:\n            maxFrequency = arr[index]\n            maxFrequencyIndex = index\n    return maxFrequencyIndex, maxFrequency\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range(len(arr)):\n        if arr[index] > maxFrequency:\n            maxFrequency = arr[index]\n            maxFrequencyIndex = index\n    return maxFrequencyIndex, maxFrequency\n\n# Returns the max frequency in a sorted array\ndef maxFrequency(arr):\n    maxFrequency = 0\n    maxFrequencyIndex = 0\n    for index in range",
    "import collections\n\ndef max_freq_item(items, freq_dict):\n    \"\"\"\n    :type items: List[int]\n    :type freq_dict: Dict[int, int]\n    :rtype: int\n    \"\"\"\n    # O(n) time, O(1) space\n    max_freq_item = None\n    max_freq = 0\n\n    for item in items:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n        if freq_dict[item] > max_freq:\n            max_freq = freq_dict[item]\n            max_freq_item = item\n\n    return max_freq_item\n\ndef max_freq_item_recur(items, freq_dict):\n    \"\"\"\n    :type items: List[int]\n    :type freq_dict: Dict[int, int]\n    :rtype: int\n    \"\"\"\n    if len(items) == 0:\n        return None\n\n    # max_freq_item, max_freq\n    max_freq_item, max_freq = max_freq_item_recur(items[1:], freq_dict)\n\n    # max_freq_item\n    for item in items:\n        if item in freq_dict:\n            if freq_dict[item] > max_freq:\n                max_freq_item = item\n                max_freq = freq_dict[item]\n\n    return max_freq_item\n\ndef max_freq_item_recur2(items, freq_dict):\n    \"\"\"\n    :type items: List[int]\n    :type freq_dict: Dict[int, int]\n    :rtype: int\n    \"\"\"\n    if len(items) == 0:\n        return None\n\n    # max_freq_item, max_freq\n    max_freq_item, max_freq = max_freq_item_recur2(items[1:], freq_dict)\n\n    # max_freq_item"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}