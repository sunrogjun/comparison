{
  "problem": {
    "task_id": "MBPP/280",
    "prompt": "Write a function to search an element in the given array by using sequential search.",
    "canonical_solution": "def sequential_search(dlist, item):\r\n    pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos",
    "test_list": [
      "assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)",
      "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)",
      "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"
    ],
    "challenge_test_list": [],
    "problem_id": 269
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        # write your code here\n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1",
    "def search(a, x):\n    \"\"\"\n    :type a: List[int]\n    :type x: int\n    :rtype: bool\n    \"\"\"\n    i = 0\n    while i < len(a) and a[i]!= x:\n        i += 1\n    if i == len(a):\n        return False\n    return True\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5, 6]\n    print(search(a, 6))\n    print(search(a, 5))\n    print(search(a, 7))\n    print(search(a, 0))\n    print(search(a, -1))",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def search(self, head: ListNode, target: int) -> ListNode:\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if target == slow.val:\n                return slow\n        return None\n\n    def sequentialSearch(self, head: ListNode, target: int) -> ListNode:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if target == slow.val:\n                return slow\n        return None\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, None))))))\n    head.next.next.next.next.next.next = head.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.next.next.next\n    head.next.next.next.next.next = head.next.next.",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a boolean\n    def search(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        if not slow:\n            return False\n        while fast:\n            if fast.val == val:\n                return True\n            if fast.val < val:\n                slow = slow.next\n            fast = fast.next\n        return False\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    print(sol.search(head, 1))",
    "class Solution:\n    # @param nums: a list of integers\n    # @param target: an integer to be searched\n    # @return: an integer\n    def search(self, nums, target):\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            elif nums[mid] > target:\n                hi = mid - 1\n        return -1\n\n    def search2(self, nums, target):\n        return bisect.bisect_left(nums, target) - 1",
    "from typing import List\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1",
    "def search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return -1\n\n    mid = 0\n    while mid < len(arr):\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            mid += 1\n        else:\n            mid -= 1\n\n    return -1",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def get_start(interval):\n            return min(interval.start, interval.end)\n\n        def get_end(interval):\n            return max(interval.start, interval.end)\n\n        def get_start_end(interval):\n            return (min(interval.start, interval.end), max(interval.start, interval.end))\n\n        def get_start_end_diff(interval):\n            return max(interval.start - interval.end, interval.start - get_start(interval))\n\n        def get_diff(interval):\n            return abs(get_end(interval) - get_start(interval))\n\n        def get_interval_diff(interval):\n            return get_diff(interval) + get_diff(interval)\n\n        def get_interval_diff_max(interval):\n            return max(get_interval_diff(interval), get_interval_diff_max(interval.left))\n\n        def get_max_diff(interval):\n            return max(get_interval_diff_max(interval), get_interval_diff_max(interval.right))\n\n        def get_max_diff_max(interval):\n            return max(get_max_diff(interval), get_max_diff_max(interval.left))\n\n        def get_max_diff_max_right(interval):\n            return max(get_max_diff(interval), get_max_diff_max(interval.right))\n\n        def get_max_diff_max_left(interval):\n            return max(get_max_diff(interval), get_max_diff_max(interval.left))\n\n        def get_max_diff_max_left_right(interval):\n            return",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) >> 1\n            if intervals[mid].end >= target:\n                lo = mid + 1\n            elif intervals[mid].start <= target:\n                hi = mid - 1\n            else:\n                return mid\n\n        return -1",
    "def search(arr, value):\n    if not arr:\n        return -1\n    \n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = lo + (hi - lo) / 2\n        if arr[mid] == value:\n            return mid\n        elif arr[mid] < value:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == '__main__':\n    print(search([1, 2, 3, 4], 5))\n    print(search([1, 2, 3, 4], 1))\n    print(search([1, 2, 3, 4], -1))\n    print(search([1, 2, 3, 4], 5))",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0] == target\n        \n        p = 0\n        r = n - 1\n        while p <= r:\n            mid = (p + r) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                p = mid + 1\n            else:\n                r = mid - 1\n        \n        return -1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def search(self, head, val):\n        if not head:\n            return None\n        p = head\n        while p:\n            if p.val == val:\n                return p\n            p = p.next\n        return None\n\n    def seq_search(self, head, val):\n        p = head\n        while p:\n            if p.val == val:\n                return p\n            p = p.next\n        return None\n\n    def search1(self, head, val):\n        while head:\n            if head.val == val:\n                return head\n            head = head.next\n        return None\n\n    def search2(self, head, val):\n        while head:\n            if head.val == val:\n                return head\n            head = head.next\n        return None\n\nif __name__ == '__main__':\n    s = Solution()\n    l1 = ListNode(1)\n    l2 = ListNode(2)\n    l3 = ListNode(3)\n    l4 = ListNode(4)\n    l5 = ListNode(5)\n    l6 = ListNode(6)\n    l1.next = l2\n    l2.next = l3\n    l3.next = l4\n    l4.next = l5\n    l5.next = l6\n    print(s.search(l1, 6))\n    print(s.search(l1, 2))\n    print(s.search(l1, 3))\n    print(s.search(l1, 7))\n    print(s.search(l1, 0))\n    print(s.search(l1, 1))\n    print(s.search(l1, 4))\n    print(s.search(l1, 5))\n    print(s.search(l1, 7))\n    print(s.search(l1, 8))\n    print",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def search(self, head: ListNode, val: int) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur:\n            if val == cur.val:\n                return cur\n            elif val > cur.val:\n                cur = cur.next\n            else:\n                cur = cur.next\n        return None",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        Greedy, O(n)\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        # 1. sort\n        # 2. binary search\n        # 3. linear search\n\n        if not nums:\n            return -1\n        # get the first element\n        if target < nums[0]:\n            return -1\n        elif target > nums[-1]:\n            return -1\n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def search2(self, nums, target):\n        \"\"\"\n        O(log(n))\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        # 1. sort\n        # 2. binary search\n        # 3. linear search\n\n        if not nums:\n            return -1\n        # get the first element\n        if target < nums[0]:\n            return -1\n        elif target > nums[-1]:\n            return -1\n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def search3(self, nums, target):\n        \"\"\"\n        O(n)\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        # 1.",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} target\n    # @return {integer}\n    def search(self, intervals, target):\n        if not intervals:\n            return -1\n        l, r = 0, len(intervals) - 1\n        while l <= r:\n            mid = (l + r) / 2\n            if intervals[mid].start <= target <= intervals[mid].end:\n                return mid\n            elif intervals[mid].start > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return -1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.search([Interval(0, 3), Interval(1, 4), Interval(2, 5), Interval(3, 6)], 3))\n    print(s.search([], 4))\n    print(s.search([Interval(0, 3), Interval(1, 4), Interval(2, 5), Interval(3, 6)], 0))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def search(self, head, val):\n        if not head:\n            return None\n\n        slow = head\n        fast = head\n        while fast and fast.next:\n            if fast.next.val == val:\n                return fast.next\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def __str__(self):\n        return str((self.start, self.end))\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        if intervals[0].start == target:\n            return True\n        else:\n            for i in range(len(intervals)):\n                if intervals[i].end < target:\n                    continue\n                if target < intervals[i].start:\n                    return False\n                elif target >= intervals[i].end:\n                    return True\n                else:\n                    return self.search(intervals[i+1:], target)",
    "def search(arr, target):\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        mid = (start + end) / 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return -1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param {ListNode[]} head\n    # @param {integer} val\n    # @return {ListNode}\n\n    def search(self, head, val):\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow.val == val:\n                return slow\n        return None\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n\n    def search(self, head, val):\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow.val == val:\n                return slow\n        return None",
    "import random\n\n\ndef random_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return True\n        elif arr[i] > target:\n            return False\n        else:\n            continue\n    return False\n\n\ndef sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    if len(arr) == 0:\n        return False\n    if arr[0] == target:\n        return True\n    elif arr[0] > target:\n        return False\n    else:\n        return sequential_search(arr[1:], target)\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    print(random_search(arr, 4))\n    print(sequential_search(arr, 4))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        return 0\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = 9\n# param_2 = [1, 2, 3]\n# param_1 = obj.search(param_1, param_2)",
    "# Your SequentialSearchArray solution(TM) \nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            elif nums[mid] < nums[right]:\n                if target > nums[mid]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                left = mid + 1\n                right = mid - 1\n        return -1\n\n# Your SequentialSearchArray solution(TM) \nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > nums[right]:\n                if target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            elif nums[mid] < nums[right]:\n                if target > nums[mid]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                left = mid + 1\n                right = mid - 1\n        return -1\n\n# Your SequentialSearchArray solution(TM) \nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        while head is not None:\n            if head.val == target:\n                return True\n            head = head.next\n        return False",
    "def sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n        if arr[i] < target:\n            continue\n        else:\n            return i + 1\n    return -1",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binary_search(nums, target, 0, len(nums)-1)\n\n    def binary_search(self, nums, target, left, right):\n        if left > right:\n            return -1\n        mid = left + (right-left)/2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.binary_search(nums, target, left, mid-1)\n        else:\n            return self.binary_search(nums, target, mid+1, right)",
    "import unittest\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return -1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-for-a-range/solution/\n#\nApproach #1: Sequential [Accepted]\nComplexity Analysis\nTime Complexity: O(log(n)), where n is the number of elements in the array.\nSpace Complexity: O(1).\n\n# 4ms 99.94%\nclass Solution {\n    public int search(int[] nums, int target) {\n        return search(nums, target, 0, nums.length - 1);\n    }\n\n    private int search(int[] nums, int target, int l, int r) {\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (nums[m] == target) return m;\n            if (nums[m] < target) {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        return -1;\n    }\n}\n\n# https://leetcode.com/problems/search-for-a-range/discuss/162865/Java-with-explanation-and-concise-explanation-with-O(log(n))-Time-and-Space-Complexity\n# Approach #2: Binary Search\n# Complexity Analysis",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def searchBST(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        return self.search(root, target)\n\n    def search(self, root, target):\n        if root is None:\n            return False\n\n        if root.val == target:\n            return True\n\n        if target < root.val:\n            return self.search(root.left, target)\n\n        if target > root.val:\n            return self.search(root.right, target)\n\n        return False",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        n = len(nums)\n        left = 0\n        right = n - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    #print(sol.search([1,3,5,6], 3))\n    print(sol.search([1,2,3,4,5,6], 3))\n    print(sol.search([1,2,3,4,5,6], 7))\n    print(sol.search([1,2,3,4,5,6], 0))\n    print(sol.search([1,2,3,4,5,6], 6))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        if target < nums[0]:\n            return self.search(nums[:nums[0]], target)\n        if target > nums[n - 1]:\n            return self.search(nums[n:], target)\n        return self.search(nums[n - 1:], target)\n\n\nif __name__ == \"__main__\":\n    assert Solution().search([2, 3, 5, 6], 5) == 0\n    assert Solution().search([2, 3, 5, 6], 7) == -1",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\n\nif __name__ == '__main__':\n    nums = [1, 3, 5, 6]\n    print(Solution().search(nums, 6))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().search([1,3,5,6], 7)",
    "def search(arr, target):\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        mid = (start + end) / 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] > target:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return -1\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(search(arr, 8))\n    print(search(arr, 1))\n    print(search(arr, 2))\n    print(search(arr, 3))\n    print(search(arr, 4))\n    print(search(arr, 5))\n    print(search(arr, 6))\n    print(search(arr, 7))\n    print(search(arr, 8))\n    print(search(arr, 9))\n    print(search(arr, 0))\n    print(search(arr, 10))\n    print(search(arr, 11))\n    print(search(arr, 12))\n    print(search(arr, 13))\n    print(search(arr, 14))\n    print(search(arr, 15))\n    print(search(arr, 16))\n    print(search(arr, 17))\n    print(search(arr, 18))\n    print(search(arr, 19))\n    print(search(arr, 20))\n    print(search(arr, 21))\n    print(search(arr, 22))\n    print(search(arr, 23))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i, j = 0, len(nums) - 1\n        while i < j:\n            mid = (i + j) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                j = mid - 1\n            else:\n                i = mid + 1\n        return -1\n\na = Solution()\na.search([1, 3, 5, 6], 4)",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def helper(i, j):\n            if i == j:\n                return i\n            if nums[i] > nums[j]:\n                return helper(i+1, j)\n            elif nums[i] < nums[j]:\n                return helper(i, j+1)\n            else:\n                return helper(i+1, j+1)\n\n        return helper(0, len(nums)-1)\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [1,2,3,4]\n    print(solution.search(nums, 1))",
    "def search(arr, val):\n    \"\"\"\n    :type arr: List[int]\n    :type val: int\n    :rtype: int\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == val:\n            return i\n    return -1\n\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5]\n    print(search(arr, 3))\n    print(search(arr, 6))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        if len(nums) == 0:\n            return -1\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def search(self, head: ListNode, target: int) -> ListNode:\n        if head is None:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if target == slow.val:\n                return slow\n        return None",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if intervals[mid].start <= target <= intervals[mid].end:\n                return True\n            elif target < intervals[mid].start:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # find the leftmost interval with target >= interval.start\n        # if there is no such one, return -1\n        leftmost = 0\n        while leftmost < len(intervals) and intervals[leftmost].start <= target:\n            leftmost += 1\n        if leftmost >= len(intervals):\n            return -1\n        # find the rightmost interval with target < interval.end\n        # if there is no such one, return -1\n        rightmost = len(intervals) - 1\n        while rightmost >= 0 and intervals[rightmost].end >= target:\n            rightmost -= 1\n        if rightmost < 0:\n            return -1\n        # find the leftmost and rightmost elements in the range of target\n        # if there is no such one, return -1\n        left = 0\n        right = len(intervals) - 1\n        while right > left and intervals[left].end < target and intervals[right].start > target:\n            left, right = left + 1, right - 1\n        if right < left:\n            return -1\n        # search\n        while left <= right:\n            # if the current interval contains target, return the start of the current interval\n            if intervals[left].end < target and intervals[right].start > target:\n                return intervals[left].start\n            elif intervals[left].end >= target:\n                return intervals[left].start\n            elif intervals[right].end >= target:\n                return intervals[right].start\n            elif intervals[right].start > target:\n                right -= 1\n            elif intervals[left].start > target:\n                left += 1\n        return -1",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        return self.search_iter(head, target)\n    \n    def search_iter(self, head, target):\n        while head:\n            if head.val == target:\n                return True\n            if head.val > target:\n                head = head.next\n            else:\n                break\n        return False\n\nclass Solution2(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if head is None:\n            return False\n        while head:\n            if head.val == target:\n                return True\n            if head.val > target:\n                head = head.next\n            else:\n                break\n        return False",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_by_index(nums, target, 0, len(nums) - 1)\n    \n    def search_by_index(self, nums, target, start, end):\n        if start > end:\n            return -1\n        \n        mid = start + (end - start) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.search_by_index(nums, target, start, mid - 1)\n        elif nums[mid] > target:\n            return self.search_by_index(nums, target, mid + 1, end)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    def search(self, head: ListNode, target: int) -> ListNode:\n        if head is None:\n            return None\n        if head.val == target:\n            return head\n        elif head.val < target:\n            return self.search(head.next, target)\n        else:\n            return self.search(head.next.next, target)\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n\n    Solution().search(head, 3)",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] > nums[lo]:\n                if target > nums[lo] and target < nums[mid]:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n            else:\n                if target > nums[hi] and target < nums[mid]:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print(Solution().search([2,3,5,6], 1))",
    "def sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    \n    # Base Case\n    if len(arr) == 0:\n        return -1\n    \n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = left + (right - left) / 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        elif arr[mid] > target:\n            right = mid - 1\n    \n    return -1\n\n\nif __name__ == \"__main__\":\n    print(sequential_search([1, 2, 3], 3))\n    print(sequential_search([1, 2, 3, 4, 5], 6))\n    print(sequential_search([1, 2, 3, 4, 5], 6))\n    print(sequential_search([1, 2, 3, 4, 5], 6))\n    print(sequential_search([1, 2, 3, 4, 5], 6))",
    "def sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # TODO\n    # # Count the number of times the target is found\n    # result = 0\n    # for i in range(len(arr)):\n    #     if arr[i] == target:\n    #         result += 1\n    # return result\n\n    # Count the number of times the target is found\n    result = 0\n    for i in range(len(arr)):\n        if arr[i] == target:\n            result += 1\n            break\n    return result\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sequential_search(arr, 3))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1",
    "import math\nimport random\nimport unittest\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # binary search\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-a-2d-matrix/solution/\n# Approach 1: Brute Force\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n# 1. Brute Force\n# 2. Brute Force\n# 3. Brute Force\n\n# Approach 2: Sequential Search\n# Complexity Analysis\n# Time Complexity: O(logn)\n# Space Complexity: O(1)\n# 4. Sequential Search\n\n# Approach 3: Binary Search\n# Complexity Analysis\n# Time Complexity: O(logn)\n# Space Complexity: O(1)\n# 5. Binary Search\n\n# Approach 4: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(logn)\n# Space Complexity: O(1)\n# 6. Two Pointers\n\n# Approach 5: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(logn)\n# Space Complexity: O(1)\n# 7. Two Pointers\n\n# Approach 6: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(logn)\n# Space Complexity: O(1)\n# 8. Two Pointers\n\n# Approach 7: Two Pointers",
    "def sequential_search(a, x):\n    \"\"\"\n    :type a: List[int]\n    :type x: int\n    :rtype: int\n    \"\"\"\n    lo = 0\n    hi = len(a) - 1\n    while lo <= hi:\n        mid = (lo + hi) / 2\n        if a[mid] == x:\n            return mid\n        elif a[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n\n        def search(intervals, target):\n            if target >= intervals[-1].end:\n                return -1\n            if target <= intervals[0].start:\n                return 0\n            l = 0\n            r = len(intervals) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if intervals[m].start <= target and target < intervals[m].end:\n                    return m\n                elif intervals[m].start > target:\n                    r = m - 1\n                else:\n                    l = m + 1\n            return -1\n\n        return search(intervals, target)\n\n\nif __name__ == '__main__':\n    intervals = [Interval(0, 3), Interval(1, 6), Interval(2, 10)]\n    print Solution().search(intervals, 0)\n    print Solution().search(intervals, 3)\n    print Solution().search(intervals, 1)\n    print Solution().search(intervals, 6)\n    print Solution().search(intervals, 2)\n    print Solution().search(intervals, 10)",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n        return -1",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.sequentialSearch(nums, target)\n\n    def sequentialSearch(self, nums, target):\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n            elif nums[i] > nums[i + 1]:\n                if target >= nums[i] and target < nums[i + 1]:\n                    return i\n                elif target > nums[i] and target <= nums[i + 1]:\n                    return self.sequentialSearch(nums[i + 1:], target)\n\n        return -1",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
    "# https://leetcode.com/problems/search-for-a-word-in-an-array-of-words/discuss/131150/Python-solution-using-sequential-search-and-array-indexing\n\nclass Solution:\n    # @param {integer[]} words\n    # @param {string} word\n    # @return {integer}\n    def search(self, words, word):\n        low = 0\n        high = len(words) - 1\n        while low <= high:\n            mid = low + (high - low) / 2\n            if words[mid] == word:\n                return mid\n            elif words[mid] > word:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n    def search2(self, words, word):\n        low = 0\n        high = len(words) - 1\n        while low <= high:\n            mid = low + (high - low) / 2\n            if words[mid] == word:\n                return mid\n            elif words[mid] > word:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n    def search3(self, words, word):\n        low = 0\n        high = len(words) - 1\n        while low <= high:\n            mid = low + (high - low) / 2\n            if words[mid] == word:\n                return mid\n            elif words[mid] > word:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n\n    print(solution.search([2, 3, 4, 4], 4))\n    print(solution.search([1, 2, 3, 4], 1))\n    print(solution.search([1, 2, 3, 4], 4))\n    print(solution.search([1, 2, 3, 4], 4))\n    print(solution.search([1, 2, 3, 4], 4))\n    print(solution.search([1, 2, 3, 4], 4))\n    print(solution.search([1, 2, 3, 4],",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        start = 0\n        end = len(intervals) - 1\n        while start <= end:\n            mid = start + (end - start) / 2\n            if intervals[mid].end < target:\n                start = mid + 1\n            elif intervals[mid].start > target:\n                end = mid - 1\n            else:\n                return True\n        return False",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0] == target\n        i = 0\n        j = n - 1\n        while i <= j:\n            mid = i + (j - i) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                j = mid - 1\n            else:\n                i = mid + 1\n        return -1",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].end < target:\n                left = mid + 1\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                return mid\n        return -1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def search(self, head: ListNode, target: int) -> ListNode:\n        prev = None\n        cur = head\n        while cur is not None:\n            if cur.val == target:\n                return cur\n            elif cur.val < target:\n                prev = cur\n                cur = cur.next\n            else:\n                prev = cur\n                cur = cur.next\n        return prev\n\nif __name__ == \"__main__\":\n    s = Solution()\n    a = [1, 2, 3, 4, 5]\n    print(s.search(a, 1))\n    print(s.search(a, -1))\n    print(s.search(a, -4))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_recursive(nums, target)\n\n    def search_recursive(self, nums, target):\n        if len(nums) == 0:\n            return -1\n        if nums[0] == target:\n            return 0\n        if nums[0] > nums[-1]:\n            return self.search_recursive(nums[-1:], target)\n        return self.search_recursive(nums[:len(nums) // 2], target) + \\\n               self.search_recursive(nums[len(nums) // 2 + 1:], target)\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_recursive(nums, target)\n\n    def search_recursive(self, nums, target):\n        if len(nums) == 0:\n            return -1\n        if nums[0] == target:\n            return 0\n        if nums[0] > nums[-1]:\n            return self.search_recursive(nums[-1:], target)\n        return self.search_recursive(nums[:len(nums) // 2], target) + \\\n               self.search_recursive(nums[len(nums) // 2 + 1:], target)",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def search(self, root: TreeNode, target: int) -> bool:\n        if not root:\n            return False\n        if target == root.val:\n            return True\n        if target > root.val:\n            return self.search(root.right, target)\n        return self.search(root.left, target)\n\n# TESTS\nfor arr, target, expected in [\n    ([1], 1, True),\n    ([1, 2, 3], 1, True),\n    ([1, 2, 3], 4, False),\n    ([1, 2, 3, 4], 4, False),\n    ([1, 2, 3, 4, 5], 4, False),\n    ([1, 2, 3, 4, 5], 6, False),\n]:\n    sol = Solution()\n    actual = sol.search(TreeNode(*arr), target)\n    print(\"Search\", target, \"in\", arr, \"->\", actual)\n    assert actual == expected",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        low = 0\n        high = n - 1\n\n        while low <= high:\n            mid = low + (high - low) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1",
    "# Your function should return:\n# - position where the element is found, if it is present in the array;\n# - -1, if the element is not present in the array.\n\ndef sequential_search(arr, x):\n    for i in range(0, len(arr)):\n        if arr[i] == x:\n            return i\n    return -1\n\nprint(sequential_search([1, 3, 5, 6], 2))\nprint(sequential_search([1, 3, 5, 6], 7))\nprint(sequential_search([1, 3, 5, 6], 1))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        while slow:\n            if slow.val == target:\n                return True\n            slow = slow.next\n            if fast and fast.val == target:\n                fast = fast.next\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.search(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))), 4)\n    print s.search(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10))))))))), 4)), 4)\n    print s.search(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10, ListNode(11))))))))), 4)), 4)\n    print s.search(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10, ListNode(11, ListNode(12))))))))), 4)), 4)), 4)\n    print s.search(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9, ListNode(10, ListNode",
    "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Do a binary search for the target.\n        \"\"\"\n        return self.search_bst(nums, target, 0, len(nums) - 1)\n    \n    def search_bst(self, nums: List[int], target: int, l: int, r: int) -> int:\n        \"\"\"\n        Do a binary search for the target.\n        \"\"\"\n        if l > r:\n            return -1\n        mid = l + (r - l) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.search_bst(nums, target, l, mid - 1)\n        else:\n            return self.search_bst(nums, target, mid + 1, r)",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1\n\n\nif __name__ == '__main__':\n    print Solution().search([1, 3, 5, 6], 4)",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        n = len(nums)\n        l, r = 0, n-1\n        while l <= r:\n            m = (l+r)/2\n            if nums[m] < target:\n                l = m + 1\n            elif nums[m] > target:\n                r = m - 1\n            else:\n                return m\n        return -1\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = 9\n# param_2 = 9.0\n# param_2 = 'abc'\n# param_2 = [1,2,3]\n# param_3 = obj.search(param_2, param_3)",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} target\n    # @return {integer}\n    def search(self, intervals, target):\n        # Write your code here\n        if not intervals or target < intervals[0].start or target > intervals[-1].end:\n            return -1\n\n        start = 0\n        end = len(intervals) - 1\n\n        while start <= end:\n            mid = (start + end) / 2\n            if target < intervals[mid].start:\n                end = mid - 1\n            elif target > intervals[mid].end:\n                start = mid + 1\n            else:\n                return mid\n\n        return -1",
    "def search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # O(n) time, O(1) space\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# Your Search function will be called like this:\n# def your_search(arr, target):\n#    return YourFunction(arr, target)",
    "def sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) / 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n\nprint(sequential_search([1, 2, 3], 3))\nprint(sequential_search([1, 2, 3, 4], 4))\nprint(sequential_search([1, 2, 3, 4], 3))\nprint(sequential_search([1, 2, 3, 4], 5))",
    "import random\n\n\ndef sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    if len(arr) == 0:\n        return False\n\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = low + (high - low) / 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] > target:\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return False\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = random.randint(1, 10)\n\n    print('Sequential search:'+ str(sequential_search(arr, target)))\n    print('Using binary search:'+ str(binary_search(arr, target)))\n\n\ndef binary_search(arr, target):\n    \"\"\"\n    Binary search.\n    :type arr: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    if len(arr) == 0:\n        return False\n\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = low + (high - low) / 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] > target:\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return False\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a boolean\n    def is_exist(self, head, val):\n        if not head:\n            return False\n        if head.val == val:\n            return True\n        if head.val > val:\n            return self.is_exist(head.next, val)\n        return False\n\n    def seq_search(self, head, val):\n        while head:\n            if head.val == val:\n                return head\n            elif head.val > val:\n                head = head.next\n            else:\n                break\n        return None\n\n    def seq_search_recur(self, head, val):\n        if not head:\n            return None\n        if head.val == val:\n            return head\n        if head.val > val:\n            return self.seq_search_recur(head.next, val)\n        else:\n            return self.seq_search_recur(head.next, val)\n\n    def is_exist_recur(self, head, val):\n        if not head:\n            return False\n        if head.val == val:\n            return True\n        if head.val > val:\n            return self.is_exist_recur(head.next, val)\n        else:\n            return False\n\n    def seq_search_recur2(self, head, val):\n        if not head:\n            return None\n        if head.val == val:\n            return head\n        if head.val > val:\n            return self.seq_search_recur(head.next, val)\n        else:\n            return self.seq_search_recur(head.next, val)\n\n    def is_exist_recur2(self, head, val):\n        if not head:\n            return False\n        if head.val == val:\n            return True\n        if head.val > val:\n            return self.is_exist_recur2(head.next, val",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        if head.val == target:\n            return True\n        if head.val > target:\n            return False\n        return self.search(head.next, target)",
    "class Solution:\n    # @param num, a list of integer\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, num, target):\n        left, right = 0, len(num) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if num[mid] == target:\n                return mid\n            elif num[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
    "# https://leetcode.com/problems/search-for-a-range/discuss/182218/Java-O(N)-Time-O(N)-Space-Approach-Based-on-Sequential-Search\n\n# Note:\n# You can assume that the given array's length is in the range [1, 10000].\n# The given target value may be in the range [0, 10000].\n# The input array is already sorted in ascending order.\n# You may assume no duplicates in the input array.\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                return mid\n        return -1\n\n# Note:\n# Use binary search to find the target.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.\n\n# Note:\n# Use a while loop to traverse the array.",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.sequential_search(nums, target)\n\n    def sequential_search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # base case\n        if len(nums) == 0:\n            return -1\n        # left side\n        for i in range(0, len(nums)):\n            if nums[i] == target:\n                return i\n        # right side\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] == target:\n                return i\n        return -1",
    "# https://leetcode.com/problems/search-for-a-range/description/\n# The first version of the problem is described here:\n# http://blog.csdn.net/zhengxu_zhang/article/details/40647537\n# The second version is described here:\n# http://blog.csdn.net/zhengxu_zhang/article/details/40647537\n\n\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        return self.search(nums, target, 0, len(nums) - 1)\n\n    def search(self, nums, target, lo, hi):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :type lo: int\n        :type hi: int\n        :rtype: List[int]\n        \"\"\"\n        if lo > hi:\n            return []\n        mid = lo + (hi - lo) // 2\n        if nums[mid] == target:\n            return [mid]\n        if nums[mid] < target:\n            return self.search(nums, target, mid + 1, hi)\n        else:\n            return self.search(nums, target, lo, mid - 1)",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        left = 0\n        right = len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].end >= target:\n                right = mid - 1\n            elif intervals[mid].start <= target:\n                left = mid + 1\n            else:\n                return mid\n        return -1",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # if target is out of range, return -1\n        if target < intervals[0].start or target > intervals[-1].end:\n            return -1\n\n        # binary search for target\n        low, high = 0, len(intervals) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if intervals[mid].end <= target:\n                low = mid + 1\n            elif intervals[mid].start >= target:\n                high = mid - 1\n            else:\n                return mid\n        return -1",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def __str__(self):\n        return \"[{}, {}]\".format(self.start, self.end)\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        if len(intervals) == 1:\n            return intervals[0].start <= target and intervals[0].end >= target\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].start <= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        if intervals[left].start <= target and intervals[left].end >= target:\n            return True\n        return False",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1",
    "def sequential_search(arr, val):\n    \"\"\"\n    :type arr: List[int]\n    :type val: int\n    :rtype: int\n    \"\"\"\n    return arr.index(val)\n\n\nclass Solution:\n    def search(self, arr, val):\n        \"\"\"\n        :type arr: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return -1\n        lo = 0\n        hi = len(arr) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if arr[mid] == val:\n                return mid\n            if arr[mid] < val:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 6, 7, 8]\n    sol = Solution()\n    print(sol.search(arr, 5))\n    print(sol.search(arr, 1))\n    print(sol.search(arr, -1))\n    print(sol.search(arr, 9))\n    print(sol.search(arr, 2))\n    print(sol.search(arr, 3))\n    print(sol.search(arr, 0))\n    print(sol.search(arr, 8))",
    "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return False\n        start, end = head, head\n        while start and start.val!= target:\n            start = start.next\n        if start and start.val == target:\n            return True\n        end = head\n        while end and end.val!= target:\n            end = end.next\n        if end and end.val == target:\n            return True\n        return False",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} target\n    # @return {integer}\n\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo = 0\n        hi = len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].end < target:\n                lo = mid + 1\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                return mid\n        return -1\n\nif __name__ == '__main__':\n    sol = Solution()\n    intervals = [Interval(0, 2), Interval(2, 5), Interval(5, 8), Interval(8, 10)]\n    print(sol.search(intervals, 1))",
    "from collections import defaultdict\n\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        d = defaultdict(int)\n        for i in range(len(nums)):\n            d[nums[i]] += 1\n        for i in range(len(nums)):\n            if d[nums[i]] == 1:\n                return i\n            d[nums[i]] -= 1\n        return -1\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.search([1, 3, 5, 6], 7))\n    print(sol.search([1, 3, 5, 6], 1))\n    print(sol.search([1, 3, 5, 6], 2))\n    print(sol.search([1, 3, 5, 6], 4))\n    print(sol.search([1, 3, 5, 6], 3))\n    print(sol.search([1, 3, 5, 6], 5))\n    print(sol.search([1, 3, 5, 6], 6))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head: return False\n        if head.val == target:\n            return True\n        if head.val < target:\n            return self.search(head.next, target)\n        else:\n            return self.search(head.next.next, target)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(3)\n    head.next.next = ListNode(5)\n    head.next.next.next = ListNode(7)\n    head.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next = ListNode(13)\n    head.next.next.next.next.next.next.next = ListNode(15)\n    head.next.next.next.next.next.next.next.next = ListNode(17)\n    head.next.next.next.next.next.next.next.next.next = ListNode(19)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(23)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(25)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(27)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(29)\n    print(sol.search(head, 1))",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        # \u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\uff0c\u7136\u540e\u518d\u5224\u65ad\u662f\u5426\u5728\u8303\u56f4\u5185\n        if not head:\n            return False\n        if head.val == target:\n            return True\n        if head.val > target:\n            return False\n        if head.val < target:\n            return False\n        # \u5c1d\u8bd5\u5bf9\u94fe\u8868\u8fdb\u884c\u524d\u5e8f\u904d\u5386\n        while head.next:\n            if head.next.val == target:\n                return True\n            if head.next.val > target:\n                return False\n            head = head.next\n        return False",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        if head.val == target:\n            return head\n        if head.val < target:\n            return self.search(head.next, target)\n        else:\n            return self.search(head.next.next, target)",
    "import random\n\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(nums, target)\n        if i == len(nums):\n            return -1\n        if nums[i] == target:\n            return i\n        if nums[i] > target:\n            return -1\n        if nums[i] < target:\n            return i + 1",
    "import random\n\n\ndef sequential_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n        elif arr[i] > target:\n            return -1\n    return -1\n\n\ndef main():\n    \"\"\"\n    Sample Input:\n        [1, 3, 5, 7, 8, 9, 10, 12]\n        8\n    Sample Output:\n        3\n        -1\n    \"\"\"\n    arr = [1, 3, 5, 7, 8, 9, 10, 12]\n    target = 8\n    print(sequential_search(arr, target))\n\n    arr = [1, 3, 5, 7, 8, 9, 10, 12]\n    target = 3\n    print(sequential_search(arr, target))\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        return self.helper(head, target)\n\n    def helper(self, head, target):\n        while head and head.val!= target:\n            head = head.next\n        if not head:\n            return False\n        else:\n            return True\n\nclass Solution2(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        return self.helper(head, target)\n\n    def helper(self, head, target):\n        while head and head.val!= target:\n            head = head.next\n        if not head:\n            return False\n        else:\n            return True\n\nclass Solution3(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        while head:\n            if head.val == target:\n                return True\n            head = head.next\n        return False\n\nclass Solution4(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        while head:\n            if head.val == target:\n                return True\n            head = head.next\n        return False",
    "# Approach 1: sequential search\n# Input: [1, 2, 3, 4, 5], 4\n# Output: [4]\n# Approach 2: Binary Search\n# Input: [1, 2, 3, 4, 5], 5\n# Output: [5]\n# Approach 3: Binary Search\n# Input: [1, 2, 3, 4, 5], 2\n# Output: [2]\n\ndef sequential_search(arr, value):\n    for i in range(len(arr)):\n        if arr[i] == value:\n            return [i]\n    return []\n\n# Approach 4: Binary Search\n# Input: [1, 2, 3, 4, 5], 4\n# Output: [4]\n\ndef binary_search(arr, value):\n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        if arr[mid] == value:\n            return [mid]\n        elif arr[mid] < value:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return []\n\n# Approach 5: Binary Search\n# Input: [1, 2, 3, 4, 5], 2\n# Output: [2]\n\ndef binary_search_2(arr, value):\n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        if arr[mid] < value:\n            lo = mid + 1\n        elif arr[mid] > value:\n            hi = mid - 1\n        else:\n            return [mid]\n    return []\n\n# Approach 6: Binary Search\n# Input: [1, 2, 3, 4, 5], 2\n# Output: [2]\n\ndef binary_search_3(arr, value):\n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        if arr[mid] < value:\n            lo = mid + 1\n        elif arr[mid] > value:\n            hi = mid - 1\n        else:\n            return [mid]",
    "from collections import defaultdict\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        if len(nums) == 1:\n            return 0 if nums[0] == target else -1\n        if nums[0] == target:\n            return 0\n        if nums[-1] == target:\n            return len(nums) - 1\n        mid = len(nums) / 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            return self.search(nums[:mid], target)\n        else:\n            return self.search(nums[mid:], target)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search([1, 3, 5, 6], 4))\n    print(sol.search([1, 3, 5, 6], 2))\n    print(sol.search([1, 3, 5, 6], 7))\n    print(sol.search([1, 3, 5, 6], 1))\n    print(sol.search([1, 3, 5, 6], 5))\n    print(sol.search([1, 3, 5, 6], 0))\n    print(sol.search([1, 3, 5, 6], 6))\n    print(sol.search([1, 3, 5, 6], 9))\n    print(sol.search([1, 3, 5, 6], -1))\n    print(sol.search([1, 3, 5, 6], -9))\n    print(sol.search([1, 3, 5, 6], 2))\n    print(sol.search([1, 3, 5, 6], 1))\n    print(sol.search([1, 3, 5, 6], 5))\n    print(sol.search([1, 3, 5, 6], 6))\n    print(sol.search([1, 3, 5, 6], 7))\n    print(sol.search([1, 3, 5, 6], 8))",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        if not nums:\n            return -1\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search([1, 3, 5, 6], 1))\n    print(sol.search([1, 3, 5, 6], 4))",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.sequential_search(nums, target, 0, len(nums) - 1)\n\n    def sequential_search(self, nums, target, start, end):\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a boolean\n    def search(self, head, val):\n        if head is None:\n            return False\n        if head.val == val:\n            return True\n        if head.val > val:\n            return self.search(head.next, val)\n        else:\n            return self.search(head.next, val)\n\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a boolean\n    def search1(self, head, val):\n        while head is not None:\n            if head.val == val:\n                return True\n            elif head.val > val:\n                head = head.next\n            else:\n                break\n        return False",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        if intervals[0].start < target and intervals[0].end < target:\n            return 0\n        if intervals[0].end < target:\n            return -1\n        if intervals[-1].start > target:\n            return -1\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].start < target and intervals[mid].end > target:\n                lo = mid + 1\n            elif intervals[mid].end > target:\n                hi = mid - 1\n            else:\n                return mid\n        return -1\n\n    def search2(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].start < target and intervals[mid].end > target:\n                lo = mid + 1\n            elif intervals[mid].end > target:\n                hi = mid - 1\n            else:\n                return mid\n        return -1",
    "def sequential_search(array, target):\n    \"\"\"\n    :type array: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    if not array or not array[0]:\n        return False\n    left = 0\n    right = len(array) - 1\n    while left <= right:\n        mid = left + (right - left) / 2\n        if array[mid] == target:\n            return True\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\n\nif __name__ == '__main__':\n    assert sequential_search([1, 2, 3], 1)\n    assert sequential_search([1, 2, 3], 3)\n    assert sequential_search([1, 2, 3], 4)\n    assert not sequential_search([1, 2, 3], 0)\n    assert not sequential_search([1, 2, 3], 5)",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @param e, an integer\n    # @return an integer\n    def search(self, intervals, e):\n        if not intervals:\n            return -1\n        \n        for i in range(len(intervals)):\n            if intervals[i].end < e:\n                continue\n            \n            if e <= intervals[i].start:\n                return i\n            elif e > intervals[i].end:\n                return -1\n            \n            return i"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}