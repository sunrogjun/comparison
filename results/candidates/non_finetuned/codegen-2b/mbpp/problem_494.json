{
  "problem": {
    "task_id": "MBPP/505",
    "prompt": "Write a function to move all zeroes to the end of the given array.",
    "canonical_solution": "def re_order(A):\r\n    k = 0\r\n    for i in A:\r\n        if i:\r\n            A[k] = i\r\n            k = k + 1\r\n    for i in range(k, len(A)):\r\n        A[i] = 0\r\n    return A",
    "test_list": [
      "assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]",
      "assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]",
      "assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]"
    ],
    "challenge_test_list": [],
    "problem_id": 494
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import numpy as np\n\n# TODO: Write the solution using the for loop.\n# TODO: Write the solution using the while loop.\n\ndef move_zeroes(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]\n    \"\"\"\n    i = 0\n    while i < len(a):\n        if a[i]!= 0:\n            a[i], a[-1] = a[-1], a[i]\n            i += 1\n        else:\n            i += 1\n    return a\n\ndef move_zeroes_recursive(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]\n    \"\"\"\n    if len(a) > 1:\n        return move_zeroes_recursive(a[0:len(a)-1]) + a[-1:]\n    else:\n        return a\n\ndef move_zeroes_recursive_2(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]\n    \"\"\"\n    if len(a) > 1:\n        return move_zeroes_recursive(a[0:len(a)-1]) + a[-1:]\n    else:\n        return a\n\ndef move_zeroes_recursive_3(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]\n    \"\"\"\n    if len(a) > 1:\n        return move_zeroes_recursive(a[0:len(a)-1]) + a[-1:]\n    else:\n        return a\n\ndef move_zeroes_recursive_4(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]\n    \"\"\"\n    if len(a) > 1:\n        return move_zeroes_recursive(a[0:len(a)-1]) + a[-1:]\n    else:\n        return a\n\ndef move_zeroes_recursive_5(a):\n    \"\"\"\n    :type a: list[int]\n    :rtype: list[int]",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[count] = nums[i]\n                count += 1\n        for i in range(count, len(nums)):\n            nums[i] = 0",
    "class Solution(object):\n    def zero_to_end(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:] + nums[i:]\n\n    def zero_to_end_2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        while i < len(nums):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:] + nums[i:]\n                i += 1\n            else:\n                i += 1",
    "# https://leetcode.com/problems/move-zeroes/\n\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        i = 0\n        j = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[j] = nums[i]\n                j += 1\n            i += 1\n        nums[j:] = nums[:j]\n        return nums\n\n\nif __name__ == \"__main__\":\n    assert Solution().moveZeroes([0, 0, 0, 1, 2, 0, 3, 0]) == [1, 2, 0, 3, 0, 0, 0, 0]\n    assert Solution().moveZeroes([0, 0, 0, 1, 2, 3, 4]) == [1, 2, 3, 4, 0, 0, 0, 0]",
    "def move_zeros(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Write your code here\n    return arr\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if nums == None or len(nums) == 0:\n            return\n        # remove all zeros\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[len(nums) - 1]\n                nums[len(nums) - 1] = 0\n                i += 1\n            else:\n                nums[i] = nums[len(nums) - 1]\n                nums[len(nums) - 1] = 0\n                i += 1\n        return",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        new_nums = []\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                new_nums.append(nums[i])\n        new_nums.extend([0] * (len(nums) - len(new_nums)))\n        return new_nums\n\nprint Solution().moveZeroes([0,0,0,1,0,2,0])",
    "import sys\nsys.path.append(\"..\")\nimport pprint\nimport random\nfrom collections import defaultdict\n\ndef move_zeroes(arr):\n    \"\"\"\n    Move all zeroes to the end of the given array.\n\n    :param arr: The given array.\n    :return: The modified array.\n    \"\"\"\n    res = defaultdict(list)\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            res[arr[i]].append(i)\n    for key, val in res.items():\n        arr[val[-1]] = key\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [0, 1, 0, 0, 0, 1, 1, 1, 1, 1]\n    print move_zeroes(arr)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        length = len(nums)\n        if length == 0:\n            return\n        for i in range(length-1):\n            if nums[i] == 0:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n                continue\n        return\n\n\nif __name__ == \"__main__\":\n    print Solution().moveZeroes([1, 0, 0, 0, 3, 0])",
    "# https://leetcode.com/problems/move-zeroes/\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        i = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i] = nums[len(nums)-1]\n                nums[len(nums)-1] = 0\n        return nums",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # https://leetcode.com/problems/move-zeroes/discuss/88498/C++-O(n)-Java-O(n)-C#2\n        if not nums:\n            return\n\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[count] = nums[i]\n                count += 1\n        nums[count:] = [0] * (len(nums) - count)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [0, 1, 0, 3, 12]\n    print(sol.moveZeroes(nums))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                ret.append(nums[i])\n        for i in range(len(ret)):\n            if ret[i] == 0:\n                ret.pop(i)\n        return ret\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [0, 1, 0, 3, 12]\n    print(sol.moveZeroes(nums))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n\n        for i, n in enumerate(nums):\n            if n == 0:\n                del nums[i]\n        nums.append(0)\n        for i, n in enumerate(nums[:-1]):\n            if n == 0:\n                nums[i] = nums[i+1]\n                del nums[i+1]\n\n\nif __name__ == '__main__':\n    print Solution().moveZeroes([0, 1, 0])",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ret = []\n        for i in intervals:\n            if i.start == i.end:\n                ret.append(i)\n        return ret",
    "class Solution:\n    # @param A, a list of integers\n    # @return nothing\n    def moveZeroes(self, A):\n        if not A:\n            return\n\n        newA = [0] * (len(A) + 1)\n        i = 1\n        for a in A:\n            if a == 0:\n                newA[i] = a\n                i += 1\n        newA[0:i] = A\n        return newA",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zeroes = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zeroes += 1\n            else:\n                nums[i - zeroes] = nums[i]\n                zeroes = 0\n        while zeroes > 0:\n            nums[len(nums) - zeroes] = 0\n            zeroes -= 1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def deleteZero(self, head):\n        prev = None\n        cur = head\n        while cur:\n            if cur.val == 0:\n                if prev:\n                    prev.next = cur.next\n                else:\n                    head = cur.next\n            else:\n                prev = cur\n            cur = cur.next\n        return head\n\nif __name__ == '__main__':\n    sol = Solution()\n    # print(sol.deleteZero([0,1,0,2,0]))\n    print(sol.deleteZero([0,0,0,0,0,0,0,0,0]))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        idx = 0\n        for i in range(1, len(nums)):\n            if nums[i]!= 0:\n                nums[idx:i] = nums[idx:i] + [0] * (len(nums) - i)\n                idx = i\n        nums[idx:len(nums)] = [0] * (len(nums) - idx)",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                count += 1\n                if count == len(nums):\n                    return nums\n                nums[i] = nums[len(nums)-count]\n                nums[len(nums)-count] = 0\n                count = 0\n        return nums\n\n\nif __name__ == '__main__':\n    print Solution().moveZeroes([0, 1, 0, 2, 3, 0])",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def moveZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        p = head\n        while p:\n            if p.next and p.next.val == 0:\n                p.next = p.next.next\n            p = p.next\n        return head\n\ndef print_list(head):\n    p = head\n    while p:\n        print(p.val)\n        p = p.next\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1, ListNode(0, ListNode(0, ListNode(0))))\n    l2 = ListNode(0, ListNode(1, ListNode(0, ListNode(0))))\n    l3 = ListNode(0, ListNode(0, ListNode(0, ListNode(0))))\n    l4 = ListNode(1, ListNode(0, ListNode(0, ListNode(0))))\n    l5 = ListNode(0, ListNode(1, ListNode(0, ListNode(0))))\n    l6 = ListNode(0, ListNode(0, ListNode(0, ListNode(0))))\n    print_list(l1)\n    print_list(Solution().moveZeroes(l1))\n    print_list(l2)\n    print_list(Solution().moveZeroes(l2))\n    print_list(l3)\n    print_list(Solution().moveZeroes(l3))\n    print_list(l4)\n    print_list(Solution().moveZeroes(l4))\n    print_list(l5)\n    print_list(Solution().moveZeroes(l5))\n    print_list(l6)\n    print_list(Solution().moveZeroes(l6))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in reversed(range(1, len(nums))):\n            if nums[i] == 0:\n                nums[i] = nums[i-1]\n                nums[i-1] = 0\n        return nums",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in reversed(range(1, len(nums))):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:] + nums[i:i+1]\n                break",
    "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:] + nums[i:i+1]\n\nif __name__ == '__main__':\n    print Solution().sortColors([1, 0, 0, 0, 2, 0, 3, 0])",
    "class Solution:\n    # @param nums, a list of integer\n    # @return nothing\n    def moveZeroes(self, nums):\n        length = len(nums)\n        for i in range(1, length):\n            if nums[i]!= 0:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [0, 1, 0, 3, 12]\n    nums = solution.moveZeroes(nums)\n    print(nums)",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[i]\n                i += 1\n            else:\n                nums[i] = nums[i-1]\n                i += 1\n        return nums",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        \n        pos = 0\n        while pos < len(nums) - 1 and nums[pos] == 0:\n            pos += 1\n        \n        if pos == len(nums) - 1:\n            return\n        \n        nums[pos + 1:] = nums[pos:]\n        nums[:pos] = []\n        \n        return",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                count += 1\n            else:\n                nums[count] = nums[i]\n                count += 1\n        return nums",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n        \n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[len(nums) - 1]\n                nums[len(nums) - 1] = 0\n                i += 1\n            else:\n                nums[i] = 0\n                i += 1\n        \n        return\n        \nif __name__ == '__main__':\n    s = Solution()\n    nums = [0, 1, 0, 3, 12]\n    s.moveZeroes(nums)\n    print(nums)\n    \n    nums = [0, 1, 0, 0, 12]\n    s.moveZeroes(nums)\n    print(nums)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def deleteZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        while curr:\n            if curr.next and curr.next.val == 0:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return dummy.next",
    "class Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if nums == []:\n            return\n\n        zero_pos = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[zero_pos] = nums[i]\n                zero_pos += 1\n\n        if zero_pos!= len(nums):\n            nums[zero_pos:] = nums[:zero_pos]\n\n\n\nif __name__ == \"__main__\":\n    print Solution().moveZeroes([1, 0, 0, 0, 3, 0, 4, 0, 5])",
    "# https://www.codewars.com/kata/54a0c6d8d6faf0d0a9/train/python\n\ndef moveZeroes(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # arr is a list of integers, so we can loop through and move the zeroes\n    # to the end of the list.\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr[i:] = arr[i+1:] + arr[i:]\n            break\n    return arr\n\nif __name__ == '__main__':\n    arr = [0, 0, 1, 0, 0, 2, 0, 3, 0]\n    arr = moveZeroes(arr)\n    print(arr)",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        idx = 0\n        while idx < len(nums) and nums[idx] == 0:\n            idx += 1\n        for i in range(idx, len(nums)):\n            nums[i - idx] = nums[i]\n        nums = nums[:idx] + [0] * (len(nums) - idx)",
    "class Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res.append(0)\n            else:\n                res.append(nums[i])\n\n        return res",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        while i < len(nums) and nums[i] == 0:\n            nums[i] = nums[len(nums) - 1]\n            i += 1\n            nums[len(nums) - 1] = 0\n        nums[i:] = nums[:i]",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def deleteZero(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        while head and head.val == 0:\n            head = head.next\n        if not head:\n            return None\n        # move all zeroes to the end\n        tail = head\n        while tail.next:\n            tail = tail.next\n            if tail.val == 0:\n                tail.next = tail.next.next\n        return head\n\ns = Solution()\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3,0,4,0])\n#print s.deleteZero([1,0,0,0,3",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        # sort intervals\n        intervals.sort(key=lambda x: (x.end, x.start))\n        # write zeroes to the end of intervals\n        ret = []\n        for interval in intervals:\n            if interval.start == interval.end:\n                ret.append(interval)\n        return ret",
    "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] == 0:\n                nums[i] = nums[j]\n                nums[j] = 0\n                i += 1\n                j -= 1\n            else:\n                i += 1\n        return",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Use two pointers to move all the zeroes to the end.\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        return nums",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        length = len(nums)\n        if length == 0:\n            return\n        \n        i = 0\n        while i < length and nums[i] == 0:\n            i += 1\n        \n        if i == length:\n            return\n        \n        j = length - 1\n        while i < j:\n            nums[i] = nums[j]\n            i += 1\n            j -= 1\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 0, 3, 12]\n    print Solution().moveZeroes(nums)",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[count] = nums[i]\n                count += 1\n        nums = nums[:count]\n        for i in range(count):\n            nums.insert(i, 0)\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[i] = nums[len(nums)-1-i]\n                nums[len(nums)-1-i] = 0",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n        else:\n            return \"Nil\"\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def moveZeroes(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        pre = head\n        cur = head\n        while cur.next:\n            cur = cur.next\n            if cur.val == 0:\n                pre.next = cur.next\n                cur.next = None\n            pre = cur\n        return head\n\nif __name__ == \"__main__\":\n    head = ListNode(0)\n    head.next = ListNode(0)\n    head.next.next = ListNode(0)\n    head.next.next.next = ListNode(1)\n    head.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next",
    "# https://leetcode.com/problems/move-zeroes/\n# time:O(n)\n# space:O(1)\n# score:100(0ms)\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        j = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[j] = nums[i]\n                j += 1\n            i += 1\n        while j < len(nums):\n            nums[j] = 0\n            j += 1\n\nif __name__ == '__main__':\n    print(Solution().moveZeroes([0, 1, 0, 3, 12]))",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in intervals:\n            if i.start == 0 and i.end == 0:\n                continue\n            res.append(i)\n        return res\n\n    def eraseZeroes2(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in intervals:\n            if i.start == i.end == 0:\n                continue\n            res.append(i)\n        return res",
    "class Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) <= 1:\n            return nums\n        ret = []\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                ret.append(nums[i])\n        ret.append(0)\n        return ret\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.moveZeroes([0, 0, 0, 1, 0, 2, 0]))",
    "class Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res.append(0)\n            else:\n                res.append(nums[i])\n        return res",
    "# https://leetcode.com/problems/move-zeroes/discuss/281368/Python-DP-Solution\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        elif n == 1:\n            return nums\n        elif n == 2:\n            return [0, nums[0], nums[1]]\n        else:\n            ret = [0] * n\n            ret[0] = nums[0]\n            ret[1] = nums[1]\n            ret[2] = nums[2]\n            ret[3] = nums[3]\n            ret[4] = nums[4]\n            ret[5] = nums[5]\n            for i in range(n - 1):\n                if nums[i]!= 0:\n                    ret[i + 1] = nums[i]\n                    break\n            return ret\n\nif __name__ == '__main__':\n    assert Solution().moveZeroes([1, 0, 0, 0, 2, 0, 3]) == [0, 1, 2, 3, 0, 0, 0]",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def moveZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(-1)\n        dummy.next = head\n        curr = dummy\n        while curr.next:\n            if curr.next.val == 0:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return dummy.next",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def moveZeroes(self, nums):\n        if not nums:\n            return nums\n\n        end = 0\n        while end < len(nums) and nums[end] == 0:\n            end += 1\n\n        end -= 1\n        if end < 0:\n            return nums\n\n        return nums[:end] + nums[end + 1:]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.moveZeroes([0, 1, 0]))\n    print(sol.moveZeroes([0]))",
    "class Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i] = 0\n                for j in range(i+1, len(nums)):\n                    nums[j] = nums[j-1]\n        return nums",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n\n        ans = 0\n        for i in xrange(len(intervals) - 1):\n            if intervals[i].end!= intervals[i+1].start:\n                ans += 1\n                intervals[i].end = intervals[i+1].end\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().eraseZeroes([Interval(0, 10), Interval(20, 30), Interval(40, 50)]) == 2\n\n    assert Solution().eraseZeroes([Interval(0, 1), Interval(1, 2), Interval(3, 4)]) == 2",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ret = []\n        for i in intervals:\n            if i.start!= i.end:\n                ret.append(i)\n        return ret",
    "class Solution(object):\n    def zero_based_search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        lo, hi = 0, len(nums)-1\n        while lo <= hi:\n            mid = lo + (hi-lo)//2\n            if nums[mid]!= target:\n                lo = mid+1\n            else:\n                hi = mid\n        return lo",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[i]\n                i += 1\n            else:\n                nums[i] = nums[i + 1]\n                i += 1",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def moveZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        prev = head\n        cur = head.next\n        while cur:\n            if cur.val == 0:\n                prev.next = cur\n                cur = cur.next\n            else:\n                prev = cur\n                cur = cur.next\n\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def deleteZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        prev = None\n        curr = head\n        while curr is not None:\n            if curr.val == 0:\n                if prev is None:\n                    head = curr.next\n                else:\n                    prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def deleteZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = head\n        while curr:\n            if curr.next and curr.val == 0:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n\n        return head",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: None\n        \"\"\"\n        if len(intervals) == 0:\n            return\n        \n        i = 0\n        while i < len(intervals) and intervals[i].end == 0:\n            i += 1\n        \n        if i == len(intervals):\n            return\n        \n        intervals[i].end = intervals[0].end\n        intervals[0].end = 0\n        \n        self.eraseZeroes(intervals[i + 1:])\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    \n    intervals = [Interval(0, 1), Interval(2, 2), Interval(3, 5), Interval(6, 6)]\n    \n    sol.eraseZeroes(intervals)\n    \n    for i in intervals:\n        print(i.start, i.end)",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def moveZeroes(self, nums):\n        if not nums:\n            return\n        zero_pos = 0\n        while zero_pos < len(nums) and nums[zero_pos] == 0:\n            zero_pos += 1\n        if zero_pos == len(nums):\n            return\n        start_pos = zero_pos\n        while start_pos < len(nums):\n            if nums[start_pos]!= 0:\n                nums[start_pos] = nums[zero_pos]\n                zero_pos += 1\n            start_pos += 1\n        nums[zero_pos:start_pos] = nums[start_pos:]",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        for interval in intervals:\n            if interval.start == interval.end:\n                result.append(interval)\n            else:\n                if interval.start == 0:\n                    result.append(Interval(interval.end, interval.end))\n                if interval.end == len(intervals) - 1:\n                    result.append(Interval(interval.start, interval.end))\n        return result\n\n\nif __name__ == \"__main__\":\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Interval(2, 3), Interval(2, 3)]) == [Interval(1, 3), Interval(2, 3)]\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Interval(2, 3), Interval(2, 3)]) == [Interval(1, 3), Interval(2, 3)]\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Interval(2, 3), Interval(2, 3)]) == [Interval(1, 3), Interval(2, 3)]\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Interval(2, 3), Interval(2, 3)]) == [Interval(1, 3), Interval(2, 3)]\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Interval(2, 3), Interval(2, 3)]) == [Interval(1, 3), Interval(2, 3)]\n    assert Solution().eraseZeroes([Interval(1, 3), Interval(2, 3), Inter",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return intervals\n        result = []\n        for i in intervals:\n            if i.start!= 0 and i.end!= 0:\n                result.append(i)\n        return result",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        if len(nums) == 1:\n            return\n        zero_pos = 0\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                nums[i] = nums[zero_pos]\n                zero_pos += 1\n        if zero_pos == 0:\n            return\n        nums[:zero_pos] = []\n\n\nif __name__ == '__main__':\n    nums = [1, 0, 0, 0, 2, 3]\n    print(Solution().moveZeroes(nums))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # use 2 pointers, one for moving\n        # another one for checking\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] == 0:\n                nums[i] = nums[0]\n                nums[0] = 0\n                # move pointer\n                i -= 1\n                # check if move is valid\n                while i >= 0 and nums[i] == 0:\n                    nums[i + 1] = nums[i]\n                    nums[i] = 0\n                    i -= 1\n        return nums\n\n\nif __name__ == \"__main__\":\n    print Solution().moveZeroes([0, 1, 0, 3, 12])",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def deleteZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        cur = head\n        while cur.next is not None:\n            if cur.next.val == 0:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(0)\n    head.next.next = ListNode(0)\n    head.next.next.next = ListNode(2)\n    head.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next",
    "def move_zeroes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    for i in range(len(nums) - 1, -1, -1):\n        if nums[i] == 0:\n            nums[i + 1:] = nums[i:]\n            break\n    return nums\n\n# Your MoveZeroes function should return the same output as the following.\ndef move_zeroes_2(nums):\n    new_nums = []\n    for i in range(len(nums)):\n        if nums[i]!= 0:\n            new_nums.append(nums[i])\n    return new_nums\n\nnums = [0, 0, 0, 0, 0]\nnums = move_zeroes(nums)\nnums = move_zeroes_2(nums)\nprint(nums)",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def moveZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        if not intervals:\n            return\n        i = 0\n        while i < len(intervals):\n            if intervals[i].start == intervals[i].end:\n                intervals.pop(i)\n            else:\n                i += 1",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n        new_nums = [nums[i] for i in range(len(nums)) if nums[i]!= 0]\n        return new_nums",
    "# https://leetcode.com/problems/move-zeroes/discuss/441259/Java-Python-C#2\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[i]\n                i += 1\n            else:\n                nums[i] = nums[i + 1]\n                i += 1\n                \n        while i < len(nums):\n            nums[i] = 0\n            i += 1",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n        result = []\n        for i in range(len(intervals)):\n            if intervals[i].start == intervals[i].end:\n                result.append(intervals[i])\n                continue\n            if result and result[-1].end == intervals[i].start:\n                result[-1].end = intervals[i].end\n                continue\n            result.append(intervals[i])\n        return result",
    "class Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ret = [0] * (len(nums) + 1)\n        for num in nums:\n            ret[len(ret) - 1] = num\n        return ret\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.zeroPadding([0]))\n    print(sol.zeroPadding([0,0]))\n    print(sol.zeroPadding([0,1,0]))\n    print(sol.zeroPadding([0,0,1]))\n    print(sol.zeroPadding([0,1,1,0]))\n    print(sol.zeroPadding([0,0,1,1]))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[count] = nums[i]\n                count += 1\n        for i in range(count, len(nums)):\n            nums[i] = 0\n        return nums",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return intervals\n        \n        result = []\n        \n        # Find the first interval that is not zero\n        for interval in intervals:\n            if interval.end:\n                break\n        \n        # Move all zeroes to the end\n        while interval:\n            # Move the zero to the end\n            if interval.start == interval.end:\n                interval.end += 1\n            \n            # Find the next interval\n            interval = intervals[intervals.index(interval) + 1]\n        \n        # Add the first interval\n        result.append(intervals[0])\n        \n        # Add the rest\n        for interval in intervals[1:]:\n            if interval.start == interval.end:\n                interval.end += 1\n            else:\n                result.append(interval)\n        \n        return result",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ans = []\n        i = 0\n        while i < len(intervals):\n            if intervals[i].start!= 0:\n                ans.append(intervals[i])\n            else:\n                i += 1\n        return ans",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[len(nums) - 1]\n                nums[len(nums) - 1] = 0\n                i += 1\n\n    def moveZeroes_1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[len(nums) - 1]\n                nums[len(nums) - 1] = 0\n                i += 1\n                # nums[i] = 0\n\n\nif __name__ == \"__main__\":\n    print(Solution().moveZeroes([1,0,0,0,2,3]))\n    print(Solution().moveZeroes_1([1,0,0,0,2,3]))",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if nums == []:\n            return\n        \n        i = 0\n        while i < len(nums) - 1:\n            if nums[i]!= 0:\n                nums[i] = nums[i]\n                i += 1\n            else:\n                nums[i] = nums[i + 1]\n                nums[i + 1] = 0\n                i += 1",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def moveZeroes(self, nums):\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[count] = nums[i]\n                count += 1\n        nums[count:] = nums[:count]\n        return nums\n\nif __name__ == '__main__':\n    print Solution().moveZeroes([0, 0, 0, 1, 1, 1, 1, 1])\n    print Solution().moveZeroes([0, 1, 0, 0])\n    print Solution().moveZeroes([1, 0, 1, 0])\n    print Solution().moveZeroes([1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
    "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:]\n        return\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [0, 0, 1, 1, 1, 1, 1, 0, 0]\n    sol.sortColors(nums)\n    print nums\n    print nums[-1]",
    "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: The length of the array after sorting\n    \"\"\"\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[res:res + 1] = nums[res:res + 1][1:]\n                res += 1\n        return res",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i]!= 0:\n                nums[i] = nums[i]\n                break\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] == 0:\n                nums[i] = nums[i - 1]\n                nums[i - 1] = 0",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                nums[i:] = nums[i+1:] + [0] * (len(nums) - i - 1)\n        return nums\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [nums[i] for i in range(len(nums)) if nums[i]!= 0]",
    "class Solution:\n    # @param A, a list of integer\n    # @return void\n    def sortZero(self, A):\n        if len(A) == 0:\n            return\n        \n        zero = 0\n        zero_count = 0\n        for i in range(len(A)):\n            if A[i] == 0:\n                zero_count += 1\n                zero += 1\n                \n        if zero_count == len(A):\n            return\n        \n        for i in range(len(A)):\n            if A[i] == 0:\n                A[i-zero] = A[i]\n                A[i] = 0\n                \n        for i in range(len(A)-1, -1, -1):\n            if A[i] == 0:\n                A[i-zero] = A[i]\n                A[i] = 0\n                \n        return",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def deleteZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        node = head\n        while node and node.next and node.next.val == 0:\n            node = node.next\n        if not node:\n            return head\n        prev = node\n        while prev and prev.next:\n            prev = prev.next\n            if prev.val == 0:\n                prev.next = prev.next.next\n        return head\n\n    def deleteZeroes_2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        node = dummy\n        while node and node.next and node.next.val == 0:\n            node = node.next\n        if not node:\n            return dummy.next\n        prev = node\n        while prev and prev.next:\n            prev = prev.next\n            if prev.next and prev.next.val == 0:\n                prev.next = prev.next.next\n        return dummy.next\n\nif __name__ == \"__main__\":\n    head = ListNode(0)\n    head.next = ListNode(0)\n    head.next.next = ListNode(0)\n    head.next.next.next = ListNode(0)\n    head.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.next.next.next.next = ListNode(0)\n    head.next.next.next.next.",
    "class Solution:\n    # @param nums, a list of integers\n    # @return nothing\n    def sortZero(self, nums):\n        if not nums:\n            return\n        # zero index is the first one,\n        # so we need to move the first zero to the end\n        while True:\n            if nums[0] == 0:\n                nums.remove(0)\n            else:\n                break\n        # move all zeroes to the end\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                nums[i:] = nums[i:] + nums[:i]\n                break\n        return nums\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.sortZero([0, 1, 0, 0, 3, 0]))",
    "# -*- coding: utf-8 -*-\n\n# https://leetcode.com/problems/move-zeroes/description/\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # sort\n        nums.sort()\n        \n        # move zeroes\n        i = 0\n        while i < len(nums):\n            if nums[i]!= 0:\n                nums[i] = nums[i] - 1\n                i += 1\n            else:\n                nums[i] = nums[i-1]\n                i += 1\n        \n        return nums",
    "class Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res.append(0)\n            else:\n                res.append(nums[i])\n        res.extend(nums[len(nums):])\n        return res\n\nclass Solution2(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res.append(0)\n            else:\n                res.append(nums[i])\n        res.extend(nums[len(nums):])\n        return res\n\nif __name__ == \"__main__\":\n    print Solution().zeroPadding([0, 1, 0, 2, 3, 4, 5, 0, 6, 7])\n    print Solution2().zeroPadding([0, 1, 0, 2, 3, 4, 5, 0, 6, 7])",
    "def zero_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    for i in range(len(arr)-1, -1, -1):\n        if arr[i] == 0:\n            arr[i] = arr[-1]\n            arr[-1] = 0\n            arr[i-1] = arr[i]\n            arr[i-2] = arr[i-1]\n            arr[i-3] = arr[i-2]\n    return arr\n\n\nif __name__ == '__main__':\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1]) == [0, 1, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]) == [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert zero_sort([0, 0, 0, 0, 0, 0, 1, 0, 0, 0,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def to_list(self):\n        return [self.val] + [self.next.to_list() if self.next else None]\n\n\nclass Solution(object):\n    def moveZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        p = head\n        while p.next:\n            if p.next.val:\n                p.next = p.next.next\n            else:\n                p = p.next\n        \n        p = head\n        while p:\n            if p.val:\n                p.next = p.next.next\n                p = p.next\n            else:\n                break\n        return head",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        def merge(i1, i2):\n            if i1.start == i2.start:\n                return Interval(min(i1.end, i2.end), max(i1.end, i2.end))\n            else:\n                return Interval(max(i1.start, i2.start), min(i1.end, i2.end))\n        return [merge(i1, i2) for i1, i2 in zip(intervals, intervals[1:]) if i1.start!= i2.start]",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sortZeroes(self, nums):\n        if not nums:\n            return\n\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            if nums[start] == 0:\n                start += 1\n            else:\n                nums[end] = nums[start]\n                end -= 1\n                start += 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [0, 1, 0, 2, 3]\n    s.sortZeroes(nums)\n    print(nums)",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        \n        idx = 0\n        while idx < len(nums) - 1:\n            if nums[idx]!= 0:\n                nums[idx] = nums[idx + 1]\n                idx += 1\n            else:\n                idx += 1\n        \n        nums[idx] = 0",
    "import unittest\n\nclass Solution(object):\n    def zeroPadding(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [0]*(len(nums)+1) + nums\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/zero-padding-array/solution/\n#\nApproach #1: Two Pointers [Accepted]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the array.\nSpace Complexity: O(1)\n\n# 12ms 85.52%\nclass Solution {\n    public int[] zeroPadding(int[] nums) {\n        int[] res = new int[nums.length];\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                res[i] = 0;\n                count++;\n            } else {\n                res[i] = nums[i];\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (res[i] == 0) {\n                res[i] = 1;\n                count--;\n            }\n        }\n        if (count == 0) {\n            return nums;\n        }\n        return res;\n    }\n}\n\n# 12ms 85.52%\nclass Solution {\n    public int[] zeroPadding(int[] nums) {\n        int[] res = new int[nums.length];\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                res[i] = 0;\n                count++;\n            } else {\n                res[i] = nums[i];\n            }",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        def merge(left, right):\n            if left.start > right.end:\n                return\n            if left.end <= right.start:\n                return left\n            if left.start <= right.start:\n                return right\n            left.end = max(left.end, right.end)\n            for i in range(left.end, right.end+1):\n                intervals.append(Interval(left.start, i))\n                left.start = i\n            return left\n\n        intervals = [Interval(i.start, i.end) for i in intervals]\n        return [i for i in intervals if i.start!= 0] + [i for i in intervals if i.start!= i.end]\n\n    def eraseZeroes1(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        intervals = sorted(intervals, key=lambda i: i.start)\n        for i in range(1, len(intervals)):\n            if intervals[i].start!= intervals[i-1].end:\n                intervals[i-1].end = max(intervals[i].end, intervals[i-1].end)\n                intervals[i].start = max(intervals[i-1].start, intervals[i].start)\n        return [i for i in intervals if i.start!= 0] + [i for i in intervals if i.start!= i.end]\n\n\nif __name__ == '__main__':\n    print Solution().eraseZeroes([Interval(0, 10), Interval(5, 15), Interval(20, 30), Interval(40, 50)])\n    print Solution().eraseZeroes([Interval(0, 10), Inter",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def moveZeroes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while pre.next:\n            if pre.next.val == 0:\n                pre.next = pre.next.next\n            else:\n                pre = pre.next\n        return dummy.next\n\n# Note:\n#  dummy.next.val = 0\n#  pre.next.val = 0",
    "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1, -1, -1):\n            if nums[i] == 0:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]",
    "# https://www.geeksforgeeks.org/move-zeroes-to-end-of-given-array/\n\n\ndef move_zeroes(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr[i:] = arr[i+1:] + arr[i:]\n\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [0, 0, 0, 1, 2, 3, 4, 0, 0, 5, 6, 7, 8, 9]\n    print(move_zeroes(arr))",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in xrange(len(intervals)):\n            if intervals[i].end == 0:\n                res.append(intervals[i])\n                continue\n            if i == 0:\n                res.append(Interval(intervals[i].start, intervals[i].end))\n            else:\n                res.append(Interval(intervals[i].start, intervals[i].end))\n                res[-1].end = intervals[i - 1].end\n        return res",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        start = 0\n        for i in xrange(len(intervals)):\n            if intervals[i].start == 0:\n                result.append(intervals[i])\n            else:\n                if start == i:\n                    start += 1\n                else:\n                    result.append(Interval(intervals[start].end, intervals[i].start - 1))\n                    start = i + 1\n        result.append(Interval(intervals[start].end, intervals[-1].end))\n        return result",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def moveZeroes(self, nums):\n        if len(nums) == 0:\n            return\n        left = 0\n        right = 0\n        while left < len(nums):\n            if nums[left]!= 0:\n                nums[right] = nums[left]\n                right += 1\n            left += 1\n        nums[right:len(nums)] = [0] * (len(nums) - right)\n        return",
    "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        idx = 0\n        while idx < len(nums) and nums[idx] == 0:\n            idx += 1\n        if idx > 0:\n            for i in xrange(idx):\n                nums[i] = nums[i + 1]\n        for i in xrange(idx + 1, len(nums)):\n            nums[i] = 0",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def moveZeroes(self, nums):\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                count += 1\n                nums[i - count] = nums[i]\n            else:\n                nums[i - count] = nums[i]\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.moveZeroes([0, 0, 0, 1, 0, 2, 0])",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def eraseZeroes(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        for i in intervals:\n            if i.start!= i.end:\n                result.append(i)\n        return result"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}