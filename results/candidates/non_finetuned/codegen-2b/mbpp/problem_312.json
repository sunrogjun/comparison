{
  "problem": {
    "task_id": "MBPP/323",
    "prompt": "Write a function to re-arrange the given array in alternating positive and negative items.",
    "canonical_solution": "def right_rotate(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr",
    "test_list": [
      "assert re_arrange([-5, -2, 5, 2, 4,\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]",
      "assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]",
      "assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]"
    ],
    "challenge_test_list": [],
    "problem_id": 312
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def alternating(array):\n    length = len(array)\n    for i in range(length):\n        if array[i] < 0:\n            array[i] *= -1\n        else:\n            array[i] *= -1\n        if i % 2 == 0:\n            array[i] *= -1\n        else:\n            array[i] *= -1\n    return array\n\nif __name__ == '__main__':\n    print alternating([1, 2, 3, 4, 5, 6, -1, -2, -3])",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n % 2 == 0:\n            for i in range(0, n, 2):\n                if nums[i] > 0:\n                    nums[i] = -nums[i]\n                else:\n                    nums[i] = nums[i] * -1\n        else:\n            nums.reverse()\n\n\na = Solution()\nnums = [1, 2, 3, -1, -2, -3]\na.alternatingNegativePositive(nums)\nprint(nums)",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def reorderList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        if n == 2:\n            if nums[0] > nums[1]:\n                nums[0], nums[1] = nums[1], nums[0]\n        for i in xrange(n-1):\n            if nums[i] > nums[i+1]:\n                j = i+1\n                while j < n and nums[j] < nums[i]:\n                    j += 1\n                if j > i+1:\n                    nums[i], nums[j-1] = nums[j-1], nums[i]\n        return",
    "# https://leetcode.com/problems/rearrange-the-array/description/\n\nclass Solution(object):\n    def alternateInOrder(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0: return\n        if n%2 == 0:\n            for i in range(n/2):\n                nums[i], nums[n-i-1] = nums[n-i-1], nums[i]\n        else:\n            for i in range(n-1):\n                nums[i], nums[n-1-i] = nums[n-1-i], nums[i]\n\nif __name__ == '__main__':\n    print Solution().alternateInOrder([1, 2, 3, 4, 5, 6, 7, 8, 9])",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Write your code here\n        if not nums:\n            return\n        nums.sort()\n        \n        for i in range(len(nums) - 1):\n            if nums[i] >= 0:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        \n        for i in range(len(nums) - 1):\n            if nums[i] <= 0:\n                nums[i], nums[i+1] = nums[i+1], nums[i]",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(0, n, 2):\n            nums[i], nums[i + 1] = -nums[i + 1], -nums[i]",
    "#!/usr/bin/env python\n\ndef alternating_array(arr):\n    # write your code here\n    arr_len = len(arr)\n    arr_pos = 0\n    arr_neg = 0\n    for i in range(0,arr_len):\n        if arr[i]>0:\n            arr_pos += 1\n        else:\n            arr_neg += 1\n        if arr_pos == arr_neg:\n            arr_pos = 0\n            arr_neg = 1\n        print(arr[i], end=' ')\n    print()\n\narr = [1,2,3,4,5,6,7,8,9,10]\nalternating_array(arr)",
    "# Definition for an Interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def alternatingNegPos(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        # write your code here\n        if not intervals:\n            return\n        i = 0\n        while i < len(intervals):\n            if intervals[i].start > intervals[i].end:\n                intervals[i].start, intervals[i].end = intervals[i].end, intervals[i].start\n            i += 1",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingNegative(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        i = 0\n        while i < len(intervals):\n            if intervals[i].start > 0:\n                res.append(intervals[i])\n                i += 1\n            else:\n                res.append(Interval(-intervals[i].end, -intervals[i].start))\n                i += 1\n        return res",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        nums.reverse()\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                nums[i] *= -1\n            else:\n                nums[i] *= -1\n            nums[i] += 2\n        nums.reverse()\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.alternatingNegative([1, 2, -3, 4, -5, 6])",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def alternatingNegative(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = dummy\n        prev = dummy\n        while curr:\n            next = curr.next\n            if next:\n                curr.next = next.next\n                prev.next = next.next\n                next.next = prev\n            else:\n                prev.next = None\n            prev = curr\n            curr = next\n        \n        return dummy.next",
    "import math\nfrom typing import List\n\nclass Solution:\n    def alternatingNegativePositive(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] > 0 and nums[i] < 0:\n                ans += 2 * nums[i]\n            elif nums[i] < 0 and nums[i] > 0:\n                ans += 2 * nums[i]\n        return ans\n\n    def alternatingNegativePositive2(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] > 0 and nums[i] < 0:\n                ans += 2 * nums[i]\n            elif nums[i] < 0 and nums[i] > 0:\n                ans += 2 * nums[i]\n        return ans\n\n    def alternatingNegativePositive3(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] > 0 and nums[i] < 0:\n                ans += 2 * nums[i]\n            elif nums[i] < 0 and nums[i] > 0:\n                ans += 2 * nums[i]\n        return ans\n\n    def alternatingNegativePositive4(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] > 0 and nums[i] < 0:\n                ans += 2 * nums[i]\n            elif nums[i] < 0 and nums[i] > 0:\n                ans += 2 * nums[i]\n        return ans\n\n    def alternatingNegativePositive5(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] > 0 and nums[i] < 0:\n                ans +=",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def alternatingPosNeg(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        # sort the intervals\n        intervals = sorted(intervals, key=lambda x: (x.start, x.end))\n\n        # alternatingly add the positive and negative intervals\n        ans = []\n        for i in range(len(intervals)):\n            if i % 2 == 0:\n                ans.append(intervals[i])\n            else:\n                ans.append(Interval(-1, -1))\n        return ans",
    "from collections import Counter\n\ndef alternating_positive_negative(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    c = Counter(arr)\n    for k in c:\n        if c[k] % 2 == 0:\n            arr.remove(k)\n        else:\n            arr.append(-k)\n    return arr\n\ndef alternating_negative_positive(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    arr.reverse()\n    arr.append(-arr.pop())\n    return arr\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9]\n    print(arr)\n    print(alternating_positive_negative(arr))\n    print(alternating_negative_positive(arr))",
    "import math\n\ndef alternating_pos_neg(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    arr_len = len(arr)\n    if arr_len % 2 == 0:\n        arr_len = arr_len / 2\n    else:\n        arr_len = arr_len / 2 + 1\n    arr_len = int(math.ceil(arr_len/2))\n    \n    pos_arr = [arr[i] for i in range(arr_len)]\n    neg_arr = [arr[i] for i in range(arr_len, arr_len*2)]\n    \n    return pos_arr + neg_arr\n\n# test cases\n\narr = [1, 2, 3, 4, 5]\nprint(alternating_pos_neg(arr))\n\narr = [1, 2, 3, 4, -5]\nprint(alternating_pos_neg(arr))",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def alternatingNegativeAndPositive(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in xrange(len(intervals)):\n            if i % 2 == 0:\n                res.append(intervals[i])\n            else:\n                res.append(Interval(intervals[i].start, intervals[i].end))\n        return res",
    "class Solution(object):\n    def alternatingNegativeAndPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i] *= -1\n        return nums",
    "def alternating_pos_neg(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for index in range(0, len(arr)):\n        if index % 2 == 0:\n            result.append(arr[index])\n        else:\n            result.append(-arr[index])\n    return result\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, -4, 5, -6]\n    print(alternating_pos_neg(arr))",
    "from collections import deque\n\ndef alternating_positive_negative_array(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not arr:\n        return arr\n\n    if not arr or arr[0] < 0:\n        return arr\n\n    n = len(arr)\n    d = deque([arr[0]])\n    for i in range(1, n):\n        if arr[i] > 0:\n            d.append(arr[i])\n        else:\n            d.append(-arr[i])\n    return [x for x in d]\n\nif __name__ == \"__main__\":\n    print(alternating_positive_negative_array([2, 1, 3, -4, -2, 1, -5, -1]))\n    print(alternating_positive_negative_array([-2, 1, -3, 4, -1, 1, 3, -4]))",
    "import unittest\nfrom random import randint\nfrom copy import deepcopy\n\n__author__ = 'Daniel'\n\n\nclass Test(unittest.TestCase):\n\n    def test_alternating_positive_and_negative_items(self):\n        arr = [randint(-10, 10) for _ in range(0, 10)]\n        res = alternating_positive_and_negative_items(arr)\n        self.assertEqual(res, [0, -1, -2, -3, -4, -5, -6, -7, -8, -9])\n        res = alternating_positive_and_negative_items([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, [0, -1, -2, -3, -4, -5, -6, -7, -8, -9])\n\n    def test_alternating_positive_and_negative_items_with_duplicates(self):\n        arr = [randint(-10, 10), randint(-10, 10)]\n        res = alternating_positive_and_negative_items(arr)\n        self.assertEqual(res, [0, -1, -2, -3, -4, -5, -6, -7, -8, -9])\n\n    def test_alternating_positive_and_negative_items_with_duplicates_2(self):\n        arr = [randint(-10, 10), randint(-10, 10), randint(-10, 10), randint(-10, 10)]\n        res = alternating_positive_and_negative_items(arr)\n        self.assertEqual(res, [0, -1, -2, -3, -4, -5, -6, -7, -8, -9])\n\n    def test_alternating_positive_and_negative_items_with_duplicates_3(self):\n        arr = [randint(-10, 10), randint(-10, 10), randint(-10, 10), randint(-10, 10), randint(-10, 10),\n               randint(-10, 10), randint(-10, 10), randint(-10, 10), randint",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def alternatingNegativePositive(self, nums):\n        # Write your code here\n        nums.sort()\n        res = []\n        for i in range(0, len(nums)):\n            if i % 2 == 0:\n                res.append(nums[i])\n            else:\n                res.append(-nums[i])\n        return res",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def alternateList(self, head):\n        if head is None or head.next is None:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n            fast = fast.next\n            slow.next = fast.next\n            fast.next = slow.next.next\n        return head\n\nif __name__ == '__main__':\n    # head = ListNode(1)\n    # head.next = ListNode(2)\n    # head.next.next = ListNode(3)\n    # head.next.next.next = ListNode(4)\n    # head.next.next.next.next = ListNode(5)\n    # print Solution().alternateList(head)\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def alternatingNegativePositive(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ret = []\n        for i in range(0, len(intervals), 2):\n            ret.append(intervals[i])\n            ret.append(intervals[i+1])\n        return ret",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def alternatingNegativePositive(self, nums):\n        if len(nums) == 0:\n            return nums\n\n        result = [0] * len(nums)\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result[i] = nums[i]\n            elif nums[i] < 0:\n                result[i] = -nums[i]\n            else:\n                result[i] = 0\n        return result\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [1, 2, 3, 4, -1, -2, -3, -4]\n    print solution.alternatingNegativePositive(nums)\n    nums = [1, -1, -2, -3, -4, 1, 2, 3, 4]\n    print solution.alternatingNegativePositive(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print solution.alternatingNegativePositive(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print solution.alternatingNegativePositive(nums)",
    "def alternating_array(arr):\n    arr = sorted(arr)\n    result = []\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            result.append(arr[i])\n        else:\n            result.append(-arr[i])\n    return result\n\ndef test_alternating_array():\n    assert alternating_array([1,2,3,4,5]) == [5, 4, 3, 2, 1]\n\nif __name__ == '__main__':\n    test_alternating_array()",
    "def alternating_array(arr):\n    if len(arr) <= 1:\n        return arr\n    pos = -1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            pos = i\n            break\n    if pos == -1:\n        return arr\n    neg = len(arr)\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            neg = i\n            break\n    return alternating_array(arr[pos:neg]) + arr[:pos] + alternating_array(arr[neg:])\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 3, 4, -5, -6, -7]\n    print(alternating_array(arr))",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def alternatingNegativePositive(self, intervals):\n        res = []\n        if len(intervals) == 0:\n            return res\n        if len(intervals) == 1:\n            return intervals\n        for i in xrange(len(intervals) - 1):\n            if intervals[i].start <= intervals[i + 1].start:\n                res.append(Interval(intervals[i].start, intervals[i + 1].start))\n            else:\n                res.append(Interval(intervals[i].end, intervals[i + 1].end))\n        return res",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingNegPos(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        prev_start = -1\n        prev_end = -1\n        for i in range(0, len(intervals)):\n            if prev_start > intervals[i].start:\n                res.append(Interval(prev_start, intervals[i].start))\n            res.append(intervals[i])\n            prev_start = intervals[i].start\n            prev_end = intervals[i].end\n\n        if prev_start > intervals[-1].start:\n            res.append(Interval(prev_start, intervals[-1].start))\n        return res",
    "from collections import Counter\n\ndef alternating_pos_neg(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    pos_cnt = Counter(arr)\n    neg_cnt = Counter(arr)\n    pos_cnt[0] += neg_cnt[0]\n    neg_cnt[0] += pos_cnt[0]\n    pos_cnt[1] += neg_cnt[1]\n    neg_cnt[1] += pos_cnt[1]\n    arr_out = []\n    pos_cnt_sum = pos_cnt[0] + pos_cnt[1]\n    neg_cnt_sum = neg_cnt[0] + neg_cnt[1]\n    while pos_cnt_sum > 0 and neg_cnt_sum > 0:\n        if pos_cnt[0] > neg_cnt[1]:\n            arr_out.append(pos_cnt[0] - 1)\n            pos_cnt[0] -= 1\n        else:\n            arr_out.append(neg_cnt[1] - 1)\n            neg_cnt[1] -= 1\n        pos_cnt_sum -= 1\n        neg_cnt_sum -= 1\n    arr_out += [pos_cnt[0] + neg_cnt[1]]\n    arr_out += [neg_cnt[0] + pos_cnt[1]]\n    return arr_out\n\n\n\nif __name__ == '__main__':\n    assert alternating_pos_neg([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    assert alternating_pos_neg([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16",
    "def alternating_arrangement(arr):\n    # write your code here\n    if len(arr) == 0:\n        return arr\n    if len(arr) == 1:\n        return arr\n    new_arr = [arr[0]]\n    for i in range(1, len(arr)):\n        new_arr.append(-arr[i])\n    return new_arr\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6]\n    print(alternating_arrangement(arr))\n    arr = [-1, -2, -3, -4, -5, -6]\n    print(alternating_arrangement(arr))\n    arr = [1, -1, -1, -1, -1, -1, -1, -1, -1]\n    print(alternating_arrangement(arr))\n    arr = [-1, -1, -1, -1, -1, -1, -1, -1, 1]\n    print(alternating_arrangement(arr))",
    "import math\n\ndef alternating_array(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Write your code here\n    n = len(arr)\n    if n == 0:\n        return arr\n    if n % 2 == 0:\n        n /= 2\n        if n % 2 == 0:\n            n /= 2\n        # n = math.ceil(math.sqrt(n))\n        return alternating_array(arr[:n]) + [arr[n]] + alternating_array(arr[n + 1:])\n    else:\n        return alternating_array(arr[:n]) + [arr[-1]] + alternating_array(arr[-2:])\n\nif __name__ == '__main__':\n    arr = [1, -1, 2, -2, 3, -3, 4, -4, 5, -5]\n    print(alternating_array(arr))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingNegPos(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        # sort intervals by start\n        intervals.sort(key=lambda x: x.start)\n        # find the start of the positive and end of the negative\n        start = 0\n        end = len(intervals)\n        while start < end:\n            if intervals[start].start < 0:\n                # negative\n                end -= 1\n                start += 1\n            else:\n                # positive\n                start += 1\n                end -= 1\n        # re-arrange\n        arr = []\n        for i in xrange(len(intervals)):\n            if i >= start and i < end:\n                arr.append(intervals[i])\n        return arr",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        if n % 2 == 0:\n            for i in range(n // 2):\n                nums[i], nums[n - 1 - i] = nums[n - 1 - i], nums[i]\n        else:\n            for i in range(n // 2):\n                nums[i], nums[n - 1 - i] = -nums[i], -nums[n - 1 - i]",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingPosNeg(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        n = len(intervals)\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n:\n                if intervals[i].end >= intervals[j].start:\n                    if intervals[i].end <= intervals[j].end:\n                        intervals[i].end = intervals[j].end\n                        intervals[j].end = intervals[i].end\n                j += 1\n            i += 1",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def alternatingNegative(self, head):\n        if not head:\n            return None\n\n        if not head.next:\n            return head\n\n        p = head\n        while p:\n            q = p.next\n            p.next = None\n            p = q\n            if p.val >= 0:\n                p.next = head\n                head = p\n\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param {ListNode[]} nums\n    # @return {ListNode[]}\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[ListNode]\n        :rtype: List[ListNode]\n        \"\"\"\n        result = []\n        if not nums:\n            return result\n        cur = nums[0]\n        for i in range(1, len(nums)):\n            cur = self.alternatingNegative_helper(cur, nums[i])\n        return result\n\n    def alternatingNegative_helper(self, cur, next):\n        if not next:\n            return cur\n        if not next.next:\n            return next\n        result = ListNode(0)\n        result.next = cur\n        cur.next = next.next\n        next.next = None\n        return result",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingNegative(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        intervals.sort(key=lambda x: x.start)\n        res = []\n        for i in xrange(0, len(intervals), 2):\n            res.append(Interval(intervals[i].start, intervals[i].end))\n            res.append(Interval(intervals[i+1].start, intervals[i+1].end))\n        return res",
    "# https://leetcode.com/problems/alternating-permutations/discuss/73892/C++-Python-Solution-with-2-lines\n\nclass Solution(object):\n    def alternatingPermutations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums_len = len(nums)\n        if nums_len == 0:\n            return []\n        if nums_len == 1:\n            return [[nums[0]]]\n        if nums_len == 2:\n            return [[nums[0]], [nums[1]]]\n        nums_list = [nums]\n        for i in range(nums_len - 2):\n            nums_list.append([nums[i], nums[i + 1], nums[i + 2]])\n        return self.alternatingPermutations_recursive(nums_list)\n\n    def alternatingPermutations_recursive(self, nums):\n        nums_len = len(nums)\n        if nums_len == 0:\n            return []\n        if nums_len == 1:\n            return [[nums[0]]]\n        if nums_len == 2:\n            return [[nums[0]], [nums[1]]]\n        result = []\n        for i in range(nums_len):\n            for j in range(i, nums_len - 1):\n                result.append([nums[j], nums[i], nums[j + 1], nums[j + 2]])\n        return result",
    "import random\n\ndef reorder(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    if not arr:\n        return\n\n    if len(arr) % 2 == 0:\n        # odd length array\n        arr.sort()\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n    else:\n        # even length array\n        random.shuffle(arr)\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n\nif __name__ == '__main__':\n    # arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print('Original array: {}'.format(arr))\n    reorder(arr)\n    print('Reordered array: {}'.format(arr))",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def alternatingNegativePositive(self, nums):\n        # write your code here\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        \n        res = []\n        for i in range(n-1):\n            if nums[i] < 0:\n                res.append(-nums[i])\n            else:\n                res.append(nums[i])\n            \n        res.append(-nums[n-1])\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.alternatingNegativePositive([1, 2, 3, 4, 5])\n    print s.alternatingNegativePositive([-1, -2, -3, -4, -5])",
    "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def alternatingNegativePositive(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        res = []\n        for i in range(len(intervals)):\n            if i % 2 == 0:\n                res.append(intervals[i])\n            else:\n                res.append(Interval(intervals[i].start, intervals[i].end))\n        return res",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # write your code here\n        i = 0\n        while i < len(nums):\n            if nums[i] > 0:\n                nums[i], nums[-i] = nums[-i], nums[i]\n            i += 2\n            if i >= len(nums):\n                break",
    "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def alternatingNegative(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals:\n            return []\n\n        ans = []\n        i = 0\n        while i < len(intervals):\n            if i % 2 == 0:\n                ans.append(intervals[i])\n            else:\n                ans.append(Interval(intervals[i].start, intervals[i].end))\n            i += 1\n        return ans",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def alternatingList(self, head):\n        if not head:\n            return head\n\n        if head.next:\n            head.next.next = head\n            head = head.next\n        \n        if head.next:\n            head.next.next = head\n            head = head.next\n        \n        p = head\n        while p:\n            n = p.next\n            p.next = None\n            p.next = n\n            p = n\n            \n        return head",
    "# https://www.hackerrank.com/challenges/alternating-permutations/problem\n\ndef alternating_permutations(arr):\n    res = []\n    for i in range(0, len(arr)):\n        if i % 2 == 0:\n            res.append(arr[i])\n        else:\n            res.append(arr[i] * -1)\n    return res\n\ndef main():\n    arr = [1, 2, 3, 4]\n    print(alternating_permutations(arr))\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\nclass Solution:\n    def alternatingNegativePositive(self, nums: List[int]) -> int:\n        sums = [0] * len(nums)\n        for i in range(len(nums)):\n            sums[i] += nums[i]\n        sums[0] -= nums[0]\n        sums[-1] -= nums[-1]\n        for i in range(1, len(nums)):\n            sums[i] += nums[i]\n        ans = 0\n        for i in range(len(nums)):\n            ans += nums[i] * (sums[i] + 2)\n        return ans\n\n\n# TESTS\nfor nums, expected in [\n    ([1, -2, 3], 6),\n    ([-2, 3, -1], 6),\n    ([-2, 3, -1, 0], 6),\n]:\n    sol = Solution()\n    actual = sol.alternatingNegativePositive(nums)\n    print(\"Alternating Negative Positive\", nums, \"->\", actual)\n    assert actual == expected",
    "import random\n\ndef alternating_pos_neg(a):\n    length = len(a)\n    for i in range(0, length):\n        if i % 2 == 0:\n            a[i] = a[i] * -1\n        else:\n            a[i] = a[i] * 1\n    return a\n\ndef main():\n    a = [1, 2, 3, 4, 5]\n    print(alternating_pos_neg(a))\n    a = [1, 2, 3, 4, -5]\n    print(alternating_pos_neg(a))\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14]\n    print(alternating_pos_neg(a))\n    a = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14]\n    print(alternating_pos_neg(a))\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution:\n    def reorderList(self, head: ListNode) -> ListNode:\n        # Base case\n        if not head or not head.next:\n            return head\n\n        # First reverse the list\n        p = head\n        head = head.next\n        while head:\n            # Keep track of the head of the list\n            tmp = head\n            head = head.next\n            # Reverse the list\n            tmp.next = None\n            tmp.next = p\n            p = tmp\n\n        # Now we can reverse the list\n        p = head\n        head = head.next\n        while head:\n            # Keep track of the head of the list\n            tmp = head\n            head = head.next\n            # Reverse the list\n            tmp.next = None\n            tmp.next = p\n            p = tmp\n\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def alternatingList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        while fast:\n            fast.next = slow.next\n            slow.next = fast\n            fast = slow.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n        else:\n            return \"null\"\n\nclass Solution(object):\n    def alternatingNegative(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # if head is null, return null\n        if not head:\n            return None\n        # create a new list node to store the head\n        new_head = ListNode(0)\n        # create a new list node to store the next node\n        new_next = ListNode(0)\n\n        # set the head node value to 0\n        new_head.val = 0\n        # set the next node value to the next node of the head\n        new_next.val = head.val\n        # set the next node value of the new_next node to the next node of the next node of the head\n        new_next.next = head.next\n        # set the next node value of the new_next node to the next node of the next node of the next node of the head\n        new_head.next = new_next\n        # set the next node value of the new_head node to the next node of the next node of the next node of the next node of the head\n        new_head.next.next = head.next.next\n        # set the next node value of the new_head node to the next node of the next node of the next node of the next node of the next node of the head\n        # set the next node value of the new_head node to the next node of the next node of the next node of the next node of the next node of the head\n        new_head.next.next.next = head.next.next.next\n        # set the next node value of the new_head node to the next node of the next node of the next node of the next node of the next node of the next node of the head\n        # set the next node value of the new_head node to",
    "def alternating_items(items):\n    for i in range(len(items)):\n        if i % 2 == 1:\n            items[i] *= -1\n        else:\n            items[i] *= 1\n    return items\n\nif __name__ == '__main__':\n    items = [1, 2, 3, 4, 5]\n    print alternating_items(items)",
    "def alternating_array(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(0, len(arr)):\n        if arr[i] > 0:\n            result.append(arr[i])\n        else:\n            result.append(-arr[i])\n    return result\n\nif __name__ == \"__main__\":\n    arr = [1, 2, -3, 4, -5, 6, -7]\n    print(alternating_array(arr))",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def reorderList(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        intervals.sort(key=lambda x: x.start)\n        for i in range(len(intervals) - 1):\n            if intervals[i].end <= intervals[i+1].start:\n                intervals[i+1] = Interval(intervals[i].end, intervals[i+1].start)\n        intervals.sort(key=lambda x: x.end)\n        for i in range(len(intervals) - 1):\n            if intervals[i].start >= intervals[i+1].end:\n                intervals[i+1] = Interval(intervals[i+1].start, intervals[i].end)",
    "class Solution(object):\n    def alternatingNegativeAndPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        \n        for i in xrange(0, n/2):\n            if nums[i] < 0:\n                nums[i], nums[n-1-i] = nums[n-1-i], nums[i]\n        \n        for i in xrange(n/2, n):\n            if nums[i] > 0:\n                nums[i], nums[n-1-i] = nums[n-1-i], nums[i]",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef alternate_negative_positive(self, head):\n\t\tprev = None\n\t\tcur = head\n\t\twhile cur:\n\t\t\tif prev:\n\t\t\t\tprev.next = cur\n\t\t\telse:\n\t\t\t\thead = cur\n\t\t\tprev = cur\n\t\t\tcur = cur.next\n\t\t\tif cur:\n\t\t\t\tcur.next = prev\n\t\t\telse:\n\t\t\t\tprev.next = None\n\t\t\tprev = cur\n\t\t\tcur = cur.next\n\t\treturn head\n\nif __name__ == '__main__':\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\thead.next.next.next.next.next.next = ListNode(7)\n\tprint Solution().alternate_negative_positive(head)",
    "# https://leetcode.com/problems/rearrange-the-matrix/discuss/70481/Java-Python-C#1\n\nclass Solution(object):\n    def alternatingPosNeg(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] > 0:\n                    matrix[i][j] *= -1\n                elif matrix[i][j] < 0:\n                    matrix[i][j] *= -1\n                else:\n                    matrix[i][j] *= -1\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] > 0:\n                    matrix[i][j] *= -1\n                elif matrix[i][j] < 0:\n                    matrix[i][j] *= -1\n                else:\n                    matrix[i][j] *= -1",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def alternatingNegative(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        if not intervals: return []\n        intervals.sort(key=lambda x: x.end)\n        result = []\n        for i in range(len(intervals)):\n            if i % 2 == 0:\n                result.append(intervals[i])\n            else:\n                result.append(Interval(intervals[i].start, intervals[i].end))\n        return result\n\n# Note:\n#  1. The input array is already sorted.\n#  2. The array only has even number of elements.\n#  3. The input array is guaranteed to be sorted.\n#  4. The input array is guaranteed to be non-empty.\n#  5. The input array is guaranteed to have even number of elements.",
    "import unittest\n\nclass Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n % 2 == 0:\n            # odd, find the next even number\n            for i in range(n // 2):\n                if nums[i] > 0:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                else:\n                    nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]\n        else:\n            # even, find the next odd number\n            for i in range(n // 2):\n                if nums[i] > 0:\n                    nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]\n                else:\n                    nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/alternating-negative-items/solution/\n# Approach #1: Sort and Re-arrange\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\n# 10ms 100%\nclass Solution {\n    public void alternatingNegative(List<Interval> intervals) {\n        Collections.sort(intervals, new Comparator<Interval>",
    "import unittest\n\n\nclass TestSolution(unittest.TestCase):\n    def test_alternating_positive_and_negative(self):\n        self.assertEqual(alternating_positive_and_negative([]), [])\n        self.assertEqual(alternating_positive_and_negative([1, 2, 3, 4, 5]), [5, 4, 3, 2, 1])\n        self.assertEqual(alternating_positive_and_negative([-1, -2, -3, -4, -5]), [-5, -4, -3, -2, -1])\n\n\ndef alternating_positive_and_negative(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(nums, reverse=True)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(0, len(nums)):\n            nums[i] = -nums[i]\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]",
    "# https://leetcode.com/problems/reorder-array/description/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def alternatingNegativePositive(self, nums):\n        if not nums:\n            return\n        size = len(nums)\n        for i in range(size - 1):\n            if nums[i] > 0 and nums[i + 1] < 0:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            if nums[i] < 0 and nums[i + 1] > 0:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]",
    "class Solution(object):\n    def alternatingNegativeAndPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n        for i in range(0, len(nums) - 1, 2):\n            nums[i], nums[i + 1] = -nums[i + 1], -nums[i]\n        return\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    solution.alternatingNegativeAndPositive([-1, 2, -3, 4])\n    print solution.alternatingNegativeAndPositive([-1, 2, -3, 4])",
    "# https://leetcode.com/problems/reorder-array-by-alternating-subsequences/discuss/105908/Java-O(N)-Time-Solution-with-Binary-Search-and-Stack\n# https://leetcode.com/problems/reorder-array-by-alternating-subsequences/discuss/105909/Java-O(N)-Time-Solution-with-Binary-Search-and-Stack\n\nclass Solution:\n    # @param nums, a list of integers\n    # @return void\n    def alternatingNegativePositive(self, nums):\n        # write your code here\n        if not nums:\n            return\n        stack = []\n        for i in range(len(nums)):\n            if not stack and nums[i] < 0:\n                stack.append(i)\n            elif stack and nums[i] >= 0:\n                top = stack.pop()\n                if nums[top] > nums[i]:\n                    stack.append(i)\n                    continue\n                else:\n                    stack.append(top)\n        if stack:\n            stack.append(len(nums))\n        for i in range(len(stack) - 1, -1, -1):\n            print(stack[i])\n\nif __name__ == '__main__':\n    print(Solution().alternatingNegativePositive([-3, -2, -1, 0, 1, 2, 3]))\n    print(Solution().alternatingNegativePositive([-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]))\n    print(Solution().alternatingNegativePositive([-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(Solution().alternatingNegativePositive([-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    print(Solution().alternatingNegativePositive([-3, -2, -1, 0, 1, 2, 3, 4, 5,",
    "import sys\n\nclass Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: The re-arranged array\n    \"\"\"\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                result.append(nums[i])\n            else:\n                result.append(-nums[i])\n        return result",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # http://blog.csdn.net/lmj623565791/article/details/49086095\n        n = len(nums)\n        for i in xrange(n // 2):\n            if nums[i] >= 0:\n                nums[i], nums[n - 1 - i] = nums[n - 1 - i], nums[i]\n            else:\n                nums[i], nums[n - 1 - i] = nums[n - 1 - i], nums[i]",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # https://leetcode.com/problems/re-arrange-the-array-in-alternating-positive-and-negative-items/discuss/343853/Java-Python-Recursion-O(n)-Time-O(1)-Space\n        if len(nums) == 0: return\n        if len(nums) == 1: return\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i], nums[-i-1] = nums[-i-1], nums[i]\n            elif nums[i] > 0:\n                nums[i], nums[-i-1] = nums[-i-1], nums[i]\n\n    def alternatingNegativePositive_recursive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # https://leetcode.com/problems/re-arrange-the-array-in-alternating-positive-and-negative-items/discuss/343853/Java-Python-Recursion-O(n)-Time-O(1)-Space\n        if len(nums) == 0: return\n        if len(nums) == 1: return\n        nums[0], nums[-1] = nums[-1], nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                nums[i], nums[-i-1] = nums[-i-1], nums[i]\n            elif nums[i] > 0:\n                nums[i], nums[-i-1] = nums[-i-1], nums[i]\n\n    def alternatingNegativePositive_iterative(self, nums",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # https://leetcode.com/problems/re-arrange-the-numbers-in-order/discuss/123437/Java-O(N)-Time-O(1)-Space\n        # O(N) time\n        # O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n        return\n\n    # https://leetcode.com/problems/re-arrange-the-numbers-in-order/discuss/123437/Java-O(N)-Time-O(1)-Space\n    # O(N) time\n    # O(1) space\n    def alternatingNegative_2(self, nums):\n        # @param nums: a list of integers\n        # @return: nothing\n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] < 0:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        return\n\n    # https://leetcode.com/problems/re-arrange-the-numbers-in-order/discuss/123437/Java-O(N)-Time-O(1)-Space\n    # O(N) time\n    # O(1) space\n    def alternatingNegative_3(self, nums):\n        # @param nums: a list of integers\n        # @return: nothing\n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] < 0:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        return\n\n    # https://leetcode.com/pro",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[i] *= -1\n            elif nums[i] < 0:\n                nums[i] *= -1\n                nums[i] = -nums[i]\n        return",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i] = -nums[i]\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] > 0:\n                nums[i] = -nums[i]\n            else:\n                nums[i] = -nums[i]",
    "import sys\n\nclass Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n % 2 == 0:\n            for i in range(n / 2):\n                nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    sol.alternatingNegativePositive([-2, 1, -3, 4, -1, 2, 1])\n    print(sol.alternatingNegativePositive([-2, 1, -3, 4, -1, 2, 1]))\n    print(sol.alternatingNegativePositive([-2, 1, -3, 4, -1, 2, 1]))",
    "class Solution(object):\n    def alternatingNegativeAndPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        odd_num = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                nums[i] = -nums[i]\n            elif nums[i] > 0:\n                nums[i] = -nums[i]\n            else:\n                odd_num = nums[i]\n        if odd_num < 0:\n            nums.reverse()",
    "class Solution:\n    # @param num, a list of integers\n    # @return a list of integers\n    def alternatingNegativePositive(self, num):\n        if not num: return num\n        res = []\n        for i in range(0, len(num), 2):\n            res.append(num[i])\n            res.append(-num[i+1])\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.alternatingNegativePositive([-2, -1, 1, 2])",
    "from collections import Counter\n\ndef alternating_pos_neg(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    arr.sort()\n    counter = Counter(arr)\n    result = []\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            result.append(arr[i])\n        else:\n            result.append(arr[i] * -1)\n    return result",
    "class Solution:\n    def alternatingNegativeAndPositive(self, A: List[int]) -> None:\n        l = len(A)\n        if l == 0:\n            return\n\n        if l % 2 == 1:\n            A.reverse()\n\n        if l % 2 == 0:\n            A.reverse()\n\n        for i in range(0, l, 2):\n            A[i], A[i + 1] = A[i + 1], A[i]\n\n        A.reverse()",
    "class Solution(object):\n    def alternatingPosNeg(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) < 2:\n            return\n\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                nums[i] = nums[i] * -1\n            else:\n                nums[i] = nums[i]",
    "class Solution:\n    # @param num, a list of integer\n    # @return nothing\n    def alternatingNegativePositive(self, num):\n        num.sort()\n        for i in range(0, len(num) - 1):\n            if num[i] < 0 and num[i + 1] > 0:\n                num[i], num[i + 1] = num[i + 1], num[i]\n        return\n\n    # @param num, a list of integer\n    # @return nothing\n    def alternatingNegativePositive2(self, num):\n        # write your code here\n        if not num:\n            return\n\n        for i in range(0, len(num) - 1):\n            if num[i] < 0 and num[i + 1] > 0:\n                num[i], num[i + 1] = num[i + 1], num[i]\n        return\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.alternatingNegativePositive([1, 2, 3, 4, 5])",
    "def alternating(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    n = len(arr)\n    ret = []\n    for i in range(n):\n        ret.append(arr[i])\n    for i in range(1, n):\n        ret.append(arr[n-i])\n    return ret\n\nif __name__ == '__main__':\n    arr = [1, -2, 3, 4, -5, 6]\n    print(arr)\n    print(alternating(arr))\n    print(alternating(arr))",
    "import numpy as np\n\ndef alternating_positive_negative_items(arr):\n    arr_positive = np.copy(arr)\n    arr_negative = np.copy(arr)\n    arr_positive[arr_positive < 0] = 0\n    arr_negative[arr_negative > 0] = 0\n\n    return arr_positive, arr_negative\n\ndef alternating_negative_positive_items(arr):\n    arr_positive = np.copy(arr)\n    arr_negative = np.copy(arr)\n    arr_positive[arr_positive > 0] = 0\n    arr_negative[arr_negative < 0] = 0\n\n    return arr_positive, arr_negative\n\ndef alternating_positive_items(arr):\n    arr_positive = np.copy(arr)\n    arr_positive[arr_positive < 0] = 0\n\n    return arr_positive\n\ndef alternating_negative_items(arr):\n    arr_negative = np.copy(arr)\n    arr_negative[arr_negative > 0] = 0\n\n    return arr_negative\n\nif __name__ == \"__main__\":\n    arr = np.array([-3, -2, -1, 0, 1, 2, 3])\n    print(arr)\n    arr_positive, arr_negative = alternating_positive_negative_items(arr)\n    print(arr_positive)\n    print(arr_negative)\n\n    arr_positive = alternating_positive_items(arr)\n    print(arr_positive)\n\n    arr_negative = alternating_negative_items(arr)\n    print(arr_negative)",
    "#!/usr/bin/python\n\nclass Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(0, n, 2):\n            nums[i], nums[i+1] = -nums[i+1], -nums[i]\n        for i in range(1, n, 2):\n            nums[i], nums[i+1] = -nums[i+1], -nums[i]\n        for i in range(2, n, 2):\n            nums[i], nums[i+1] = -nums[i+1], -nums[i]",
    "# https://oj.leetcode.com/problems/rearrange-the-matrix/\n\nclass Solution(object):\n    def alternatingPositiveNegative(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        mat = mat[:]\n        for i in range(len(mat)):\n            for j in range(len(mat[i])):\n                if mat[i][j] == 0:\n                    mat[i][j] = -1\n        for i in range(len(mat)):\n            for j in range(len(mat[i])):\n                if mat[i][j] == -1:\n                    mat[i][j] = 1\n        return mat\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    mat = [[1, -2, 3], [4, -5, 6], [7, -8, 9]]\n    print(sol.alternatingPositiveNegative(mat))",
    "def alternating_arr(nums):\n    return alternating_arr_helper(nums, 0, len(nums) - 1)\n\ndef alternating_arr_helper(nums, start, end):\n    if start == end:\n        return nums[start]\n    \n    if start % 2 == 0:\n        return alternating_arr_helper(nums, start + 1, end)\n    else:\n        return alternating_arr_helper(nums, start - 1, end)\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    print alternating_arr(nums)",
    "# https://leetcode.com/problems/re-arrange-the-list-of-integers-to-make-it-have-a-perfect-squares/discuss/254527/Python-solution-using-two-sides-of-an-array\n\nclass Solution(object):\n    def arrangeSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # write your code here\n        n = len(nums)\n        if n == 0:\n            return\n        mid = n // 2\n        if n % 2 == 1:\n            nums[0], nums[mid] = nums[mid], nums[0]\n            return\n        for i in range(mid - 1, -1, -1):\n            if nums[i] == nums[i + 1]:\n                nums[i] = nums[i] - nums[i + 1]\n            else:\n                nums[i] = nums[i] * nums[i + 1]\n            if nums[i] > 0:\n                nums[i] = nums[i] - nums[i + 1]\n            else:\n                nums[i] = nums[i + 1] - nums[i]\n        return\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.arrangeSquares([1, 2, 3, 4, 5]))\n    print(sol.arrangeSquares([1, -2, 3, -4, 5]))\n    print(sol.arrangeSquares([1, 2, 3, 4, 5, 6]))\n    print(sol.arrangeSquares([1, 2, 3, 4, 5, 6, 7]))\n    print(sol.arrangeSquares([1, 2, 3, 4, 5, 6, 7, 8]))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def alternatingList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        node = head\n        while node is not None:\n            if node.val > 0:\n                node = node.next\n            else:\n                temp = node.next\n                node.next = node.next.next\n                temp.next = node\n                node = temp\n        return head",
    "import sys\n\n# Complete the alternatingArray function below.\ndef alternatingArray(arr):\n    arr = sorted(arr)\n    length = len(arr)\n    if length % 2!= 0:\n        return arr\n    \n    for i in range(0, length, 2):\n        if arr[i] >= 0:\n            arr[i] *= -1\n        else:\n            arr[i] *= -1\n    return arr\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, -5]\n    print(alternatingArray(arr))\n    \n    arr = [1, -2, 3, -4, 5]\n    print(alternatingArray(arr))\n    \n    arr = [-1, -2, -3, -4, -5]\n    print(alternatingArray(arr))\n    \n    arr = [1, 2, 3, 4, -5, -6, -7, -8, -9, -10]\n    print(alternatingArray(arr))\n    \n    arr = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]\n    print(alternatingArray(arr))\n\n    arr = [1, 2, 3, 4, -5, -6, -7, -8, -9, -10, -11, -12]\n    print(alternatingArray(arr))\n    \n    arr = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12]\n    print(alternatingArray(arr))",
    "# https://oj.leetcode.com/problems/rearrange-the-matrix/\n\n# Note:\n# The input matrix is given as a list of lists.\n# Each element in the list is a row and each row is a list of integers.\n# The matrix has at most 10 elements.\n# The input matrix is not allowed to be empty or full.\n# Example 1:\n# Input:\n# [[1,2],\n#  [3,4]]\n# Output:\n# [[1,3,2,4],\n#  [1,4,3,2]]\n# Example 2:\n# Input:\n# [[-1,1,-1],\n#  [1,-1,2],\n#  [1,2,-1]]\n# Output:\n# [[-1,-1,1,1],\n#  [1,1,1,-1],\n#  [1,2,2,-1]]\n# Example 3:\n# Input:\n# [[-1,1,-1],\n#  [1,-1,2],\n#  [1,2,-1]]\n# Output:\n# [[-1,-1,-1,1,1,1,2,2,2],\n#  [1,1,1,-1,2,-1,2,-1,2]]\n# Note:\n# The input matrix is given.\n# The input matrix is in the range [-100,100] and has at most 10 elements.\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\n# DP solution\n# Time complexity: O(n^2)\n# Space complexity: O(n)\nclass Solution:\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def reorderList(self, matrix):\n        if len(matrix) == 0:\n            return []\n        if len(matrix) == 1:\n            return [[matrix[0][0]]]\n\n        ret = [[]]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if j == 0:\n                    ret[i].append(matrix[i][j])",
    "# https://leetcode.com/problems/alternating-negative-and-positive-items-in-an-array/discuss/113793/Python-solution-with-explanation\n\n# Algorithm:\n#   1. Count the negative items, positive items, and the total number of items.\n#   2. Make a new array with the same number of positive and negative items.\n#   3. Iterate over the original array, swap the elements at the same position if the elements are negative or positive.\n#   4. If the elements are negative, decrement the counter, otherwise increment it.\n#   5. If the counter is 0, swap the elements at the same position.\n#   6. Repeat step 5 until the counter is 0.\n\ndef alternating_negative_positive(arr):\n    if not arr:\n        return arr\n\n    count_negative = 0\n    count_positive = 0\n    total_count = 0\n    new_arr = [0] * len(arr)\n    for i, val in enumerate(arr):\n        if val < 0:\n            count_negative += 1\n        elif val > 0:\n            count_positive += 1\n        total_count += 1\n        new_arr[i] = val\n\n    for i in range(len(arr)):\n        if count_negative % 2 == 0:\n            if new_arr[i] < 0:\n                new_arr[i] = -new_arr[i]\n                count_negative -= 1\n        elif count_positive % 2 == 0:\n            if new_arr[i] > 0:\n                new_arr[i] = -new_arr[i]\n                count_positive -= 1\n\n    if count_negative == 0:\n        for i in range(len(arr)):\n            if new_arr[i] > 0:\n                new_arr[i] = -new_arr[i]\n\n    if count_positive == 0:\n        for i in range(len(arr)):\n            if new_arr[i] < 0:\n                new_arr[i] = -new_arr[i]\n\n    count_negative = 0\n    count_positive = 0\n    total_count = 0",
    "def alternating_pos_neg(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    count = 0\n    ret = []\n    for i in range(len(arr)):\n        if count == 0:\n            ret.append(arr[i])\n            count = 1\n        else:\n            if arr[i] < 0:\n                ret.append(-arr[i])\n                count = 0\n            else:\n                ret.append(arr[i])\n                count = 1\n    return ret\n\nif __name__ == '__main__':\n    arr = [-1, 2, -3, 4]\n    print(alternating_pos_neg(arr))\n    arr = [1, 2, 3, -4]\n    print(alternating_pos_neg(arr))\n    arr = [1, 2, 3, -4, 5]\n    print(alternating_pos_neg(arr))\n    arr = [1, 2, 3, -4, 5, 6]\n    print(alternating_pos_neg(arr))",
    "#!/usr/bin/env python\n\ndef alternating_posneg(arr):\n    arr_len = len(arr)\n    for i in range(0, arr_len, 2):\n        arr[i], arr[i+1] = arr[i+1], arr[i]\n    return arr\n\nif __name__ == '__main__':\n    test_cases = [\n        ([1, 2, 3], [1, -3, -2, -1]),\n        ([1, 2, 3], [1, 2, 3]),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, -9, -10, -8, -7, -6, -5, -4, -3, -2, -1]),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    ]\n    for test_case, expected in test_cases:\n        result = alternating_posneg(test_case)\n        print(result)\n        assert(result == expected)\n        print()",
    "class Solution(object):\n    def alternatingNegativePositive(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        for i in range(len(A)):\n            if A[i] < 0:\n                ans.append(A[i])\n                A[i] = -A[i]\n            else:\n                ans.append(A[i])\n        return ans",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        for i in range(0, len(nums) - 1):\n            if nums[i] >= 0:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        return",
    "# https://www.hackerrank.com/challenges/alternating-array/problem\n\ndef alternating_array(arr):\n    arr = sorted(arr)\n    \n    for i in range(len(arr)):\n        if arr[i] < 0:\n            arr[i] = -arr[i]\n        else:\n            arr[i] = arr[i] * -1\n    return arr\n\nif __name__ == \"__main__\":\n    arr = input().split()\n    arr = [int(a) for a in arr]\n    print(alternating_array(arr))",
    "from collections import Counter\n\n\ndef alternating_positive_negative(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    cnt = Counter(arr)\n    odds = [x for x in arr if x % 2 == 1]\n    evens = [x for x in arr if x % 2 == 0]\n    return odds + evens\n\n\nif __name__ == '__main__':\n    print(alternating_positive_negative([-3, 1, -5, 2, -1, -2]))",
    "class Solution(object):\n    def alternatingNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(0, n, 2):\n            nums[i], nums[i + 1] = -nums[i], -nums[i + 1]\n        return",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        step = 0\n        for i in range(1, n):\n            if nums[i] < 0:\n                nums[step] = nums[i]\n                step += 1\n            else:\n                nums[step] = -nums[i]\n                step += 2\n        return\n\nif __name__ == '__main__':\n    print Solution().alternatingNegativePositive([-1, -2, 3, 4, -5, -6])",
    "class Solution(object):\n    def alternatingNegativeAndPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                nums[i] = -nums[i]\n            else:\n                nums[i] = nums[i] * -1",
    "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def reorderList(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        if not intervals:\n            return\n        # Use a stack to keep track of the current interval,\n        # and the number of items in the current interval.\n        # Each time we pop from stack, we know the current interval is finished.\n        # So we can update the current interval to the next one,\n        # and remove it from stack.\n        stack = []\n        for i in range(len(intervals)):\n            if intervals[i].start < intervals[i].end:\n                stack.append(intervals[i])\n            else:\n                stack.pop()\n                stack[-1].end = intervals[i].start\n                stack.append(intervals[i])\n        # The number of items in the current interval is equal to the number of items in the current interval\n        # minus the number of items in the next interval.\n        # So we can update the current interval to the next one,\n        # and remove it from stack.\n        for i in range(len(intervals) - 1):\n            intervals[i].start = intervals[i].end\n            intervals[i].end = intervals[i + 1].start\n            stack.pop()\n            stack[-1].end = intervals[i + 1].start\n            stack.append(intervals[i + 1])",
    "class Solution(object):\n    def alternatingNegativePositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in xrange(0, n, 2):\n            nums[i], nums[i+1] = -nums[i+1], -nums[i]",
    "# https://leetcode.com/problems/re-arrange-the-list/discuss/126433/Java-O(n)-Sorting-Solution\n\nfrom random import randint\n\n# @include\ndef re_arrange(arr):\n    n = len(arr)\n    i, j = 0, n - 1\n    while i < j:\n        while i < j and arr[i] <= 0:\n            i += 1\n        while i < j and arr[j] >= 0:\n            j -= 1\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n        j -= 1\n    return arr\n# @exclude\n\nclass Test(unittest.TestCase):\n    def test(self):\n        for _ in range(1000):\n            n = randint(1, 100)\n            arr = [randint(-1, 1) for _ in range(n)]\n            expected = re_arrange(arr)\n            self.assertEqual(arr, expected)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def __str__(self):\n        return str((self.start, self.end))\n\nclass Solution:\n    def reorderList(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: void Do not return anything, modify intervals in-place instead.\n        \"\"\"\n        pairs = []\n        for i in xrange(len(intervals)):\n            if intervals[i].start < intervals[i].end:\n                pairs.append((intervals[i].start, intervals[i].end))\n        pairs.sort()\n        for start, end in pairs:\n            intervals[i].start = start\n            intervals[i].end = end\n            i += 1\n\nif __name__ == \"__main__\":\n    print Solution().reorderList([Interval(0, 1), Interval(1, 2), Interval(2, 3), Interval(3, 4), Interval(4, 5)])",
    "# https://leetcode.com/problems/reorder-array/\n\nclass Solution(object):\n    def reorderArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return\n\n        # build a stack of alternating positive and negative numbers\n        stack = []\n        for num in nums:\n            if num < 0:\n                stack.append(-num)\n            else:\n                stack.append(num)\n\n        # pop elements from stack and push to reversed array\n        while stack:\n            nums.append(stack.pop())"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}