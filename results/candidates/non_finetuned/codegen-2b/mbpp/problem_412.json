{
  "problem": {
    "task_id": "MBPP/423",
    "prompt": "Write a function to solve gold mine problem.",
    "canonical_solution": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ",
    "test_list": [
      "assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16",
      "assert get_maxgold([[10,20],[30,40]],2,2)==70",
      "assert get_maxgold([[4,9],[3,7]],2,2)==13"
    ],
    "challenge_test_list": [],
    "problem_id": 412
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "import numpy as np\n\nclass GoldMine(object):\n    \"\"\"\n    A class to solve the gold mine problem.\n\n    The problem is:\n    Given N mines, find the number of mines that are connected to the center.\n    \"\"\"\n    def __init__(self, N):\n        \"\"\"\n        Initialize the object with N mines.\n\n        :type N: int\n        :rtype: int\n        \"\"\"\n        self.N = N\n        self.mines = [0 for _ in range(N)]\n        self.connected_mines = 0\n\n    def solve(self):\n        \"\"\"\n        Solve the problem.\n\n        :rtype: int\n        \"\"\"\n        self.mines[0] = 1\n        self.connected_mines = 0\n\n        for i in range(1, self.N):\n            for j in range(i + 1, self.N):\n                if self.mines[j - 1] > 0:\n                    self.mines[j] = self.mines[j - 1] + 1\n                    self.connected_mines += 1\n\n        return self.connected_mines\n\n\n# Your GoldMine object will be instantiated and called as such:\n# obj = GoldMine(N)\n# param_1 = obj.solve()",
    "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A list of integers\n    \"\"\"\n    def solve(self, nums):\n        if not nums:\n            return []\n        n = len(nums)\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]]\n        if n == 9:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8]]\n        if n == 10:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9]]\n        if n == 11:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10]]",
    "import math\n\ndef solve(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += math.factorial(i) * math.factorial(n-i) / math.factorial(n)\n    return total\n\nif __name__ == '__main__':\n    print solve(3)\n    print solve(4)\n    print solve(5)",
    "import sys\nimport timeit\n\n__author__ = 'Daniel'\n\n\ndef solve(start, end):\n    \"\"\"\n    :param start: int, start\n    :param end: int, end\n    :return: int, the sum of the coins\n    \"\"\"\n    # write your code here\n    coins = [0 for i in range(end)]\n    coins[start] = 1\n\n    for i in range(start + 1, end + 1):\n        if i % 2 == 0:\n            coins[i] = coins[i - 1] + coins[i - 2]\n        else:\n            coins[i] = coins[i - 1] + coins[i - 3]\n\n    return sum(coins)\n\n\ndef test():\n    start = 0\n    end = 100\n\n    print(\"Starting...\")\n    print(solve(start, end))\n    print(\"Completed\")\n\n\nif __name__ == '__main__':\n    # test()\n    # timeit.main()\n    start = 0\n    end = 100\n    print(solve(start, end))",
    "import math\n\ndef solve(n, k, l):\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            if (i + j) % 2 == 0:\n                if (i + j) / 2 == k:\n                    return i + j + 1\n            elif (i + j) / 2 < k:\n                if (i + j) / 2 < k and ((i + j) / 2 + 1) > l:\n                    return i + j + 1\n    return -1\n\nif __name__ == '__main__':\n    n = int(input())\n    k = int(input())\n    l = int(input())\n    print(solve(n, k, l))",
    "from __future__ import print_function\nfrom collections import defaultdict\nimport os\n\n__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        m = cipher.split('\\n')\n        # m[0] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[1] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[2] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[3] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[4] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[5] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[6] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[7] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[8] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[9] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[10] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[11] = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n        # m[",
    "import sys\n\n\ndef solve(N, M):\n    \"\"\"\n    :param N: number of rows\n    :param M: number of columns\n    :return: number of mines\n    \"\"\"\n    mine_count = 0\n    for i in range(N):\n        for j in range(M):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                if j == 1:\n                    mine_count += 1\n            elif j == 0:\n                if i == 1:\n                    mine_count += 1\n            else:\n                if i == 1 and j == 1:\n                    mine_count += 1\n                elif i == 0 and j == M - 1:\n                    mine_count += 1\n                elif i == M - 1 and j == 1:\n                    mine_count += 1\n                elif i == M - 1 and j == M - 1:\n                    mine_count += 1\n                elif i == 1 and j == M - 1:\n                    mine_count += 1\n                elif i == M - 1 and j == M - 2:\n                    mine_count += 1\n    return mine_count\n\n\ndef main():\n    N, M = map(int, sys.stdin.readline().strip().split(' '))\n    print solve(N, M)\n\nif __name__ == '__main__':\n    main()",
    "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def gold_mine(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if root.left and not root.left.val:\n            return self.gold_mine(root.left)\n        if root.right and not root.right.val:\n            return self.gold_mine(root.right)\n        if root.val and root.val == 1:\n            return 1\n        return max(self.gold_mine(root.left), self.gold_mine(root.right))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        if not cipher:\n            return\n        s = cipher[0]\n        s_len = len(s)\n        i = 0\n        while True:\n            if s[i] == '0':\n                if s[i+1] == '0':\n                    return 0\n                else:\n                    return i\n            elif s[i] == '1':\n                if s[i+1] == '0':\n                    return i+1\n                else:\n                    return i\n            i += 1\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip().split(' ')\n\n        # solve\n        s = \"%s\" % (solution.solve(cipher))\n\n        # output\n        print \"Case #%d: %s\" % (t+1, s)\n    pass",
    "def solve(n, k):\n    if n == 0 or k == 0:\n        return 0\n    if n == 1 or k == 1:\n        return 1\n    if n == 2 or k == 1:\n        return 2\n    if n == 2 or k == 2:\n        return 3\n    if n == 3 or k == 1:\n        return 4\n    if n == 3 or k == 2:\n        return 5\n    if n == 3 or k == 3:\n        return 6\n    if n == 4 or k == 1:\n        return 7\n    if n == 4 or k == 2:\n        return 8\n    if n == 4 or k == 3:\n        return 9\n    if n == 4 or k == 4:\n        return 10\n    if n == 5 or k == 1:\n        return 11\n    if n == 5 or k == 2:\n        return 12\n    if n == 5 or k == 3:\n        return 13\n    if n == 5 or k == 4:\n        return 14\n    if n == 5 or k == 5:\n        return 15\n    if n == 6 or k == 1:\n        return 16\n    if n == 6 or k == 2:\n        return 17\n    if n == 6 or k == 3:\n        return 18\n    if n == 6 or k == 4:\n        return 19\n    if n == 6 or k == 5:\n        return 20\n    if n == 6 or k == 6:\n        return 21\n    if n == 7 or k == 1:\n        return 22\n    if n == 7 or k == 2:\n        return 23\n    if n == 7 or k == 3:\n        return 24\n    if n == 7 or k == 4:\n        return 25\n    if n == 7 or k == 5:\n        return 26\n    if n == 7 or k == 6:\n        return 27\n    if n == 7 or k == 7:\n        return 28\n    if n == 8 or k == 1:\n        return 29\n    if n == 8 or k == 2:\n        return 30\n    if n == 8 or k == 3:\n        return 31\n    if n == 8 or k == 4:\n        return 32\n    if n == 8 or k ==",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        def gold(cipher):\n            if len(cipher) < 2:\n                return 0\n            if cipher[0] == cipher[1]:\n                return 0\n            return 2 * gold(cipher[1:])\n        return gold(cipher)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.cache = {}\n\n    def solve(self, cipher):\n        \"\"\"\n        :param cipher: the cipher\n        :return: the solution\n        \"\"\"\n        self.cache = {}\n        return self.solve_recur(cipher, 0, 0)\n\n    def solve_recur(self, cipher, start, num):\n        \"\"\"\n        :param cipher: the cipher\n        :param start: the start index\n        :param num: the current number\n        :return: the solution\n        \"\"\"\n        if cipher[start] in self.cache:\n            return self.cache[cipher[start]]\n\n        if num == len(cipher):\n            self.cache[cipher[start]] = cipher[start]\n            return cipher[start]\n\n        if start + 1 == len(cipher):\n            # at least one number must be 0\n            self.cache[cipher[start]] = '0'\n            return '0'\n\n        if num > len(cipher):\n            # at least one number must be 0\n            self.cache[cipher[start]] = '0'\n            return '0'\n\n        if cipher[start] == '0':\n            self.cache[cipher[start]] = self.solve_recur(cipher, start + 1, num)\n            return self.cache[cipher[start]]\n\n        self.cache[cipher[start]] = self.solve_recur(cipher, start + 1, num + 1)\n        return self.cache[cipher[start]]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.solve('aaa')",
    "import unittest\n\nclass Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A list of integers\n    \"\"\"\n    def solve(self, nums):\n        nums = sorted(nums)\n        for i in xrange(len(nums) - 1):\n            if nums[i] + nums[i + 1] > nums[i + 2]:\n                return nums[:i + 1]\n        return nums\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/gold-mine-ii/solution/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *",
    "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A list of integers\n    \"\"\"\n    def solve(self, nums):\n        res = []\n        for i in range(len(nums)):\n            if i + 1 < len(nums):\n                if nums[i] + nums[i+1] > nums[i+2]:\n                    res.append(nums[i+1])\n        return res\n\n\nif __name__ == \"__main__\":\n    print Solution().solve([1, 2, 3, 3, 4, 5])",
    "# https://www.hackerrank.com/challenges/gold-mine\n\nimport math\n\ndef solve_gold_mine(n):\n    return sum(\n        [\n            (math.sqrt(n / (i + 1)))\n            for i in range(n + 1)\n        ]\n    )\n\nif __name__ == '__main__':\n    print(solve_gold_mine(100))",
    "import math\n\nclass Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def getSum(self, num):\n        ret = 0\n        for n in num:\n            ret += n\n        return ret\n    \n    # @param num, a list of integer\n    # @return a list of integer\n    def getSum2(self, num):\n        ret = 0\n        for n in num:\n            ret += math.floor(n)\n        return ret\n    \n    # @param num, a list of integer\n    # @return a list of integer\n    def getSum3(self, num):\n        ret = 0\n        for n in num:\n            ret += int(math.floor(math.sqrt(n)))\n        return ret\n\nif __name__ == '__main__':\n    print Solution().getSum([-1,2,3])\n    print Solution().getSum([-1,1,1,2])\n    print Solution().getSum([-1,1,1,2,3])\n    print Solution().getSum2([-1,1,1,2,3])\n    print Solution().getSum3([-1,1,1,2,3])",
    "import random\n\n\ndef solve(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n < 0:\n        return -1\n    if k < 0 or k > n:\n        return -1\n    if k == 0:\n        return 1\n    if k == 1:\n        return n\n    if n == 0:\n        return 1\n\n    p = random.randint(1, n)\n    q = random.randint(1, n)\n\n    # if p == 1 and q == 1:\n    #     return 1\n    # if p == 1 and q == n - 1:\n    #     return n\n    # if p == n - 1 and q == 1:\n    #     return n\n    # if p == n - 1 and q == n - 1:\n    #     return 1\n\n    p = p if p <= q else q\n\n    return solve(n - 1, k - 1) + solve(n - p, k - 1)\n\n\nif __name__ == \"__main__\":\n    print(solve(10, 1))",
    "def solve(gold, mines, mines_left):\n    \"\"\"\n    :type gold: int\n    :type mines: int\n    :type mines_left: int\n    :rtype: int\n    \"\"\"\n    if mines_left == 0:\n        return max(gold, 0)\n    mines_left -= 1\n    if mines_left == 0:\n        return max(mines, 0)\n    max_gold = 0\n    for i in range(mines_left):\n        max_gold += solve(gold - mines, mines, mines_left - 1)\n    return max(max_gold, max(mines, mines_left))\n\nif __name__ == '__main__':\n    gold = int(input())\n    mines = int(input())\n    mines_left = int(input())\n    print(solve(gold, mines, mines_left))",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        # write your code here\n        count = 0\n        for i in xrange(len(cipher)):\n            if cipher[i] == '+':\n                count += 1\n            else:\n                count -= 1\n        return count\n\n\nif __name__==\"__main__\":\n    import sys\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\"%(Solution().solve(cipher))\n        print s,",
    "__author__ = 'Daniel'\n\n\nclass Solution:\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        if cipher == \"a\":\n            return \"a\"\n        elif cipher == \"b\":\n            return \"b\"\n        elif cipher == \"c\":\n            return \"c\"\n        elif cipher == \"d\":\n            return \"d\"\n        elif cipher == \"e\":\n            return \"e\"\n        elif cipher == \"f\":\n            return \"f\"\n        elif cipher == \"g\":\n            return \"g\"\n        elif cipher == \"h\":\n            return \"h\"\n        elif cipher == \"i\":\n            return \"i\"\n        elif cipher == \"j\":\n            return \"j\"\n        elif cipher == \"k\":\n            return \"k\"\n        elif cipher == \"l\":\n            return \"l\"\n        elif cipher == \"m\":\n            return \"m\"\n        elif cipher == \"n\":\n            return \"n\"\n        elif cipher == \"o\":\n            return \"o\"\n        elif cipher == \"p\":\n            return \"p\"\n        elif cipher == \"q\":\n            return \"q\"\n        elif cipher == \"r\":\n            return \"r\"\n        elif cipher == \"s\":\n            return \"s\"\n        elif cipher == \"t\":\n            return \"t\"\n        elif cipher == \"u\":\n            return \"u\"\n        elif cipher == \"v\":\n            return \"v\"\n        elif cipher == \"w\":\n            return \"w\"\n        elif cipher == \"x\":\n            return \"x\"\n        elif cipher == \"y\":\n            return \"y\"\n        elif cipher == \"z\":\n            return \"z\"\n        else:\n            return cipher",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.upper()\n        if len(cipher) < 3:\n            return cipher\n        else:\n            return self.solve_with_backtrack(cipher, 0, len(cipher))\n\n    def solve_with_backtrack(self, cipher, start, end):\n        if start >= end:\n            return cipher[start:end]\n        if cipher[start] == '1':\n            return self.solve_with_backtrack(cipher, start + 1, end)\n        if cipher[start] == '0':\n            return self.solve_with_backtrack(cipher, start + 1, end)\n        return cipher[start:end]",
    "class Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.min_price = 0\n        self.max_price = 0\n        self.min_price_pos = 0\n        self.max_price_pos = 0\n        self.min_price_len = 0\n        self.max_price_len = 0\n        self.min_price_pos_len = 0\n        self.max_price_pos_len = 0\n        self.min_price_pos_len_sum = 0\n        self.max_price_pos_len_sum = 0\n        self.min_price_pos_len_sum_sum = 0\n        self.max_price_pos_len_sum_sum = 0\n        self.min_price_pos_len_sum_sum_sum = 0\n        self.max_price_pos_len_sum_sum_sum = 0\n        self.min_price_len_sum = 0\n        self.max_price_len_sum = 0\n        self.min_price_len_sum_sum = 0\n        self.max_price_len_sum_sum = 0\n        self.min_price_len_sum_sum_sum = 0\n        self.max_price_len_sum_sum_sum = 0\n\n    def solve(self, price):\n        \"\"\"\n        :type price: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.min_price = price[0]\n        self.max_price = price[-1]\n        self.min_price_len = len(price)\n        self.max_price_len = len(price)\n        self.min_price_pos = price.index(min(price))\n        self.max_price_pos = price.index(max(price))\n        self.min_price_pos_len = price[self.min_price_pos] - price[0]\n        self.max_price_pos_len = price[self.max_price_pos] - price[0]\n        self.min_price_pos_len_sum = sum(price[self.min_price_",
    "__author__ = 'Daniel'\n\n\nclass Solution:\n    def __init__(self):\n        self.d = {}\n        self.dp = {}\n\n    def solve(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        self.d[1] = 1\n        self.dp[1] = 1\n        for i in range(2, n + 1):\n            self.d[i] = max(self.d[i - 1] + 1, self.dp[i - 1])\n            self.dp[i] = max(self.d[i], self.dp[i - 1])\n        return self.d[n]\n\n\nif __name__ == '__main__':\n    assert Solution().solve(2) == 3\n    assert Solution().solve(4) == 7\n    assert Solution().solve(10) == 35\n    assert Solution().solve(20) == 953\n    assert Solution().solve(100) == 9530095\n    assert Solution().solve(200) == 9530095000\n    assert Solution().solve(1000) == 95300950002000",
    "import collections\nclass Solution:\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        if cipher == \"a\":\n            return \"c\"\n        elif cipher == \"b\":\n            return \"d\"\n        elif cipher == \"c\":\n            return \"a\"\n        elif cipher == \"d\":\n            return \"b\"\n        else:\n            return cipher\n\nif __name__ == '__main__':\n    Solution().solve(\"abcd\")",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.upper()\n        cipher = cipher[::-1]\n        count = 0\n        for i in range(len(cipher)):\n            if cipher[i] == 'A':\n                count += 1\n            elif cipher[i] == 'B':\n                count -= 1\n        return str(count)",
    "import random\nfrom collections import defaultdict\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        gold = 0\n        gold_dict = defaultdict(int)\n        for i in range(len(cipher)):\n            if cipher[i] == '#':\n                gold += 1\n                gold_dict[i] = gold\n        \n        for i in range(len(cipher)):\n            if cipher[i] == '#':\n                if gold_dict[i] < gold:\n                    return cipher[:i] + cipher[i+1:]\n                else:\n                    return cipher[:i] + cipher[i+1:] + cipher[i+2:]\n        return cipher",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        def solve(s, k):\n            if len(s) < k:\n                return 0\n            if s[k] == 'X':\n                return solve(s[:k], k) + 1\n            return solve(s[:k] + 'X', k) + solve(s[k:], k)\n\n        return solve(cipher, len(cipher))\n\n\nif __name__ == \"__main__\":\n    assert Solution().solve(\"a\", 1) == 2\n    assert Solution().solve(\"aa\", 1) == 3\n    assert Solution().solve(\"aaa\", 1) == 5\n    assert Solution().solve(\"aaaa\", 1) == 8\n    assert Solution().solve(\"aaaaa\", 1) == 13\n    assert Solution().solve(\"aaaaaa\", 1) == 22",
    "__author__ = 'Danyang'\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        :return: the solution\n        \"\"\"\n        def check_gold_mine(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 2 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_2(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 3 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_3(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 5 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_4(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 7 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_5(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 11 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_6(a):\n            \"\"\"\n            check if the current number is a gold mine\n            :param a: the number\n            :return: True if a is a gold mine, False otherwise\n            \"\"\"\n            if a % 13 == 0:\n                return True\n            else:\n                return False\n\n        def check_gold_mine_7(a):\n            \"\"\"",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        length = len(cipher)\n\n        # store the index of each letter\n        index = {c: i for i, c in enumerate(cipher)}\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate(cipher)}\n\n        # store the current index of each letter\n        cur = {c: i for i, c in enumerate(cipher)}\n\n        # store the last index of each letter\n        last = {c: i for i, c in enumerate",
    "def gold_mine(n):\n    \"\"\"\n    Given a positive integer n, return the number of possible configurations\n    of n coins in such a way that each of them can be made up of 1, 2, or 3\n    copies.\n    \"\"\"\n    return sum(gold_mine(n-i) for i in range(1, n+1))\n\n\nif __name__ == '__main__':\n    print(gold_mine(4))",
    "from __future__ import annotations\n\nimport argparse\nimport math\n\nclass Solution:\n    def __init__(self, nums: list[int]) -> None:\n        self.nums = nums\n\n    def solve(self) -> int:\n        n = len(self.nums)\n        if n == 1:\n            return self.nums[0]\n        if n == 2:\n            return self.find_max_sum(self.nums)\n        if n == 3:\n            return self.find_max_sum(self.nums)\n        if n == 4:\n            return self.find_max_sum(self.nums)\n        return self.find_max_sum(self.nums)\n\n    def find_max_sum(self, nums: list[int]) -> int:\n        max_sum = -math.inf\n        for num in nums:\n            max_sum = max(max_sum, num)\n        return max_sum\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\"nums\", nargs=\"+\", type=int, default=[], help=\"nums\")\n    args = parser.parse_args()\n    n = len(args.nums)\n    solution = Solution(args.nums)\n    print(f\"{solution.solve()}\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        if cipher == 'A':\n            return 1\n        elif cipher == 'B':\n            return 2\n        elif cipher == 'C':\n            return 3\n        elif cipher == 'D':\n            return 4\n        elif cipher == 'E':\n            return 5\n        elif cipher == 'F':\n            return 6\n        elif cipher == 'G':\n            return 7\n        elif cipher == 'H':\n            return 8\n        elif cipher == 'I':\n            return 9\n        elif cipher == 'J':\n            return 10\n        elif cipher == 'K':\n            return 11\n        elif cipher == 'L':\n            return 12\n        elif cipher == 'M':\n            return 13\n        elif cipher == 'N':\n            return 14\n        elif cipher == 'O':\n            return 15\n        elif cipher == 'P':\n            return 16\n        elif cipher == 'Q':\n            return 17\n        elif cipher == 'R':\n            return 18\n        elif cipher == 'S':\n            return 19\n        elif cipher == 'T':\n            return 20\n        elif cipher == 'U':\n            return 21\n        elif cipher == 'V':\n            return 22\n        elif cipher == 'W':\n            return 23\n        elif cipher == 'X':\n            return 24\n        elif cipher == 'Y':\n            return 25\n        elif cipher == 'Z':\n            return 26\n        elif cipher == '1':\n            return 27\n        elif cipher == '2':\n            return 28\n        elif cipher == '3':\n            return 29\n        elif cipher == '4':\n            return 30\n        elif cipher == '5':\n            return 31\n        elif cipher == '6':\n            return 32\n        elif cipher == '7':\n            return 33\n        elif cipher == '8':\n            return 34\n        elif cipher == '9':\n            return 35\n        elif cipher == '0':\n            return 36\n        else:\n            return -1",
    "def solve(N, P):\n    \"\"\"\n    Input:\n    N: number of mines\n    P: number of players\n    Output:\n    0 if the gold mine is not possible, 1 if the gold mine is possible.\n    \"\"\"\n    for i in xrange(1, N+1):\n        if i % P == 0:\n            return 0\n    return 1\n\nif __name__ == \"__main__\":\n    N = int(raw_input())\n    P = int(raw_input())\n    print solve(N, P)",
    "class Solution:\n    \"\"\"\n    @param num: A list of non-negative integers.\n    @return: An integer, denote the number of ways to make change.\n    \"\"\"\n    def countWays(self, num):\n        # write your code here\n        if len(num) == 0:\n            return 0\n        if len(num) == 1:\n            return 1\n        dp = [1] * len(num)\n        for i in range(1, len(num)):\n            dp[i] = dp[i - 1] + num[i]\n        return dp[-1]\n        \n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countWays([1, 2, 3]))",
    "class Solution(object):\n    def solve(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        if num < 0:\n            return -1\n        if num % 2 == 0:\n            return num / 2\n        return num / 2 + 1\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.solve(0))\n    print(s.solve(1))\n    print(s.solve(2))\n    print(s.solve(3))\n    print(s.solve(4))\n    print(s.solve(5))\n    print(s.solve(6))\n    print(s.solve(7))\n    print(s.solve(8))\n    print(s.solve(9))\n    print(s.solve(10))\n    print(s.solve(11))\n    print(s.solve(12))\n    print(s.solve(13))\n    print(s.solve(14))\n    print(s.solve(15))\n    print(s.solve(16))\n    print(s.solve(17))\n    print(s.solve(18))\n    print(s.solve(19))\n    print(s.solve(20))\n    print(s.solve(21))\n    print(s.solve(22))\n    print(s.solve(23))\n    print(s.solve(24))\n    print(s.solve(25))\n    print(s.solve(26))\n    print(s.solve(27))\n    print(s.solve(28))\n    print(s.solve(29))\n    print(s.solve(30))\n    print(s.solve(31))\n    print(s.solve(32))\n    print(s.solve(33))\n    print(s.solve(34))\n    print(s.solve(35))\n    print(s.solve(36))\n    print(s.",
    "import numpy as np\nfrom collections import defaultdict\n\nclass Solution:\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        def find_gold_mine(cipher):\n            \"\"\"\n            :type cipher: str\n            :rtype: int\n            \"\"\"\n            gold_mine = defaultdict(int)\n            for i in range(len(cipher)):\n                if cipher[i] == '+':\n                    gold_mine[i] = 1\n                elif cipher[i] == '-':\n                    gold_mine[i] = -1\n                elif cipher[i] == '.':\n                    gold_mine[i] = 0\n            for i in range(len(cipher)):\n                if cipher[i] == '+':\n                    gold_mine[i] += gold_mine[i - 1]\n                elif cipher[i] == '-':\n                    gold_mine[i] += gold_mine[i + 1]\n            return gold_mine[-1]\n\n        def find_min_sum_coins(cipher, gold_mine):\n            \"\"\"\n            :type cipher: str\n            :type gold_mine: dict\n            :rtype: int\n            \"\"\"\n            if len(cipher) == 0:\n                return 0\n            elif len(cipher) == 1:\n                return gold_mine[0]\n            else:\n                return min(find_min_sum_coins(cipher[0:-1], gold_mine),\n                           find_min_sum_coins(cipher[1:], gold_mine))\n\n        return find_min_sum_coins(cipher, find_gold_mine(cipher))\n\nif __name__ == '__main__':\n    assert Solution().solve(\"++.+.+.+.\") == 3\n    assert Solution().solve(\"++.+.+.+.+.\") == 3\n    assert Solution().solve(\"+++.+.+.+.\") == 3\n    assert Solution().solve(\"+-++.+.+.+.\") == 4\n    assert Solution().solve(\"+-++.+.+.+.\") == 4\n    assert Solution().solve(\"+-++.+.+.+.+",
    "class Solution:\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if mid == 0 or nums[mid - 1] < nums[mid]:\n                start = mid + 1\n            elif mid == end or nums[mid] > nums[mid + 1]:\n                end = mid - 1\n            else:\n                return mid\n        return mid\n\n\nif __name__ == '__main__':\n    assert Solution().findPeakElement([2, 1, 2, 4, 3]) == 3\n    assert Solution().findPeakElement([2, 1, 2, 3, 3]) == 3\n    assert Solution().findPeakElement([2, 3, 3, 4]) == 3\n    assert Solution().findPeakElement([2, 3, 2, 4]) == 2\n    assert Solution().findPeakElement([2, 3, 2, 3]) == 2",
    "import random\nimport numpy as np\n\ndef gold_mine(mine_data):\n    \"\"\"\n    Input: mine_data is a list of lists of ints\n    Output: A list of ints.\n    \"\"\"\n    # create a dictionary of the mines\n    mines = {}\n    for i in mine_data:\n        for j in i:\n            mines[j] = True\n\n    # create a list of all the mines\n    all_mines = set(mines.keys())\n\n    # return all the mines\n    return all_mines\n\n\ndef gold_mine_iterative(mine_data):\n    \"\"\"\n    Input: mine_data is a list of lists of ints\n    Output: A list of ints.\n    \"\"\"\n    # create a dictionary of the mines\n    mines = {}\n    for i in mine_data:\n        for j in i:\n            mines[j] = True\n\n    # create a list of all the mines\n    all_mines = set(mines.keys())\n\n    # return all the mines\n    return all_mines\n\n\ndef gold_mine_recursive(mine_data):\n    \"\"\"\n    Input: mine_data is a list of lists of ints\n    Output: A list of ints.\n    \"\"\"\n    # create a dictionary of the mines\n    mines = {}\n    for i in mine_data:\n        for j in i:\n            mines[j] = True\n\n    # create a list of all the mines\n    all_mines = set(mines.keys())\n\n    # return all the mines\n    return all_mines\n\n\ndef gold_mine_recursive_optimized(mine_data):\n    \"\"\"\n    Input: mine_data is a list of lists of ints\n    Output: A list of ints.\n    \"\"\"\n    # create a dictionary of the mines\n    mines = {}\n    for i in mine_data:\n        for j in i:\n            mines[j] = True\n\n    # create a list of all the mines\n    all_mines = set(mines.keys())\n\n    # return all the mines\n    return all_mines\n\n\ndef gold_mine_optimized(mine",
    "# Definition for a point.\nclass Point:\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\n    def __repr__(self):\n        return \"(%d, %d)\" % (self.x, self.y)\n\nclass Solution(object):\n    def solve(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: List[int]\n        \"\"\"\n        if not points:\n            return []\n        ans = []\n        min_x = min(x for x, y in points)\n        max_x = max(x for x, y in points)\n        min_y = min(y for x, y in points)\n        max_y = max(y for x, y in points)\n        for i in range(min_x, max_x + 1):\n            for j in range(min_y, max_y + 1):\n                if (i, j) in points:\n                    ans.append(points.count((i, j)))\n        return ans",
    "class Solution(object):\n    def __init__(self):\n        self.max = 0\n\n    def solve(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        self.max = 0\n        self.find(nums)\n        return self.max\n\n    def find(self, nums):\n        for i in xrange(len(nums)):\n            self.find_max(nums, i, i)\n\n    def find_max(self, nums, i, j):\n        if j == len(nums):\n            self.max = max(self.max, nums[i])\n            return\n        for k in xrange(i, j):\n            if nums[i] < nums[k]:\n                self.find_max(nums, i, k)\n            elif nums[i] > nums[k]:\n                self.find_max(nums, k, j)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print s.solve(nums)\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print s.solve(nums)",
    "from __future__ import annotations\n\nclass Solution:\n    def solve(self, input: str) -> str:\n        \"\"\"\n        :type input: str\n        :rtype: str\n        \"\"\"\n        if len(input) < 2:\n            return input\n        if input[-1] == '*':\n            return \"The\" + input[:-1]\n        if input[-1] == '.':\n            return \"The\" + input[:-1]\n        if input[-1] == '+':\n            return \"The\" + input[:-1]\n        return \"The\" + input\n\n\n\n# Note:\n# You can assume the input string has at least one character.\n# If the input string is a substring of a larger string, you can assume the substring is at the end of the larger string.\n# If the input string is a substring of a larger string, you can assume the substring is at the beginning of the larger string.\n# You can assume the input string is not a substring of itself.\n# If the input string is a substring of another string, you can assume the substring is at the end of the other string.\n# If the input string is a substring of another string, you can assume the substring is at the beginning of the other string.\n# If the input string is a substring of another string, you can assume the substring is at the beginning of the other string.\n# If the input string is a substring of another string, you can assume the substring is at the beginning of the other string.\n# If the input string is a substring of another string, you can assume the substring is at the beginning of the other string.\n# If the input string is a substring of another string, you can assume the substring is at the beginning of the other string.",
    "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def __init__(self):\n        self.max_price = 0\n\n    def solve(self, N, prices: List[int]) -> int:\n        self.max_price = max(prices)\n        self.max_price = max(self.max_price, N * self.max_price)\n        if N == 1:\n            return self.max_price\n        self.max_price = max(self.max_price, self.max_price + (N - 1) * self.max_price)\n        self.max_price = max(self.max_price, self.max_price + (N - 2) * self.max_price)\n        return self.max_price\n\n# TESTS\nfor N, prices in [\n    (3, [1, 2, 3]),\n    (4, [1, 2, 3, 4]),\n    (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n]:\n    sol = Solution()\n    actual = sol.solve(N, prices)\n    print(\"The max price of\", N, \"gold mines is\", actual)\n    assert actual == pytest.approx(sol.max_price)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        l, r = 0, len(cipher) - 1\n        while l <= r:\n            if cipher[l] == cipher[r]:\n                l += 1\n                r -= 1\n            else:\n                break\n\n        return l\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip().split(' ')\n\n        # solve\n        s = \"%s\\n\" % (solution.solve(cipher))\n        print s,",
    "class Solution:\n    def __init__(self):\n        self.__gold_mine = [0]\n        self.__gold_count = [0]\n\n    def solve(self, data):\n        \"\"\"\n        :type data: List[int]\n        :rtype: int\n        \"\"\"\n        for i in range(len(data)):\n            if data[i] == 1:\n                self.__gold_mine[i] += 1\n                self.__gold_count[i] += 1\n            else:\n                self.__gold_mine[i] -= 1\n                self.__gold_count[i] -= 1\n        sum = 0\n        for i in range(len(self.__gold_mine)):\n            if self.__gold_mine[i] > 0:\n                sum += self.__gold_count[i] * i\n        return sum",
    "class Solution:\n    \"\"\"\n    @param mineSweepCount: the number of times to sweep a mine\n    @param maxSweepCount: the maximum number of times to sweep a mine\n    @return: an integer\n    \"\"\"\n    def solve(self, mineSweepCount, maxSweepCount):\n        res = 0\n        while mineSweepCount < maxSweepCount:\n            res += mineSweepCount\n            mineSweepCount += 1\n        return res\n\nif __name__ == \"__main__\":\n    assert Solution().solve(2, 4) == 3\n    assert Solution().solve(2, 5) == 5\n    assert Solution().solve(3, 4) == 3\n    assert Solution().solve(3, 5) == 6\n    assert Solution().solve(4, 4) == 4\n    assert Solution().solve(4, 5) == 10\n    assert Solution().solve(5, 4) == 5\n    assert Solution().solve(5, 5) == 15",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n\n        :param cipher: the cipher\n        \"\"\"\n        # print cipher\n        # print cipher.count('A')\n\n        # generate all possible states\n        possible = [[0] * len(cipher) for _ in range(len(cipher))]\n        for i in range(len(cipher)):\n            for j in range(len(cipher)):\n                if cipher[i] == cipher[j]:\n                    possible[i][j] = 1\n        # print possible\n\n        # for each possible state, generate all possible next state\n        for i in range(len(possible)):\n            for j in range(len(possible)):\n                if possible[i][j] == 1:\n                    for k in range(len(possible)):\n                        possible[i][j] = 0\n                        possible[i][k] = 1\n                        if cipher[i] == cipher[k]:\n                            possible[i][k] = 1\n\n        # print possible\n\n        # find a path from A to B\n        result = 0\n        for i in range(len(possible)):\n            if possible[i][0] == 1:\n                result += 1\n                if possible[i][0] == 0:\n                    break\n\n        return result\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    # print solution.solve(f.readline().strip())\n    cipher = f.readline().strip()\n    # cipher = \"A\"\n    # cipher = \"B\"\n    # cipher = \"AA\"\n    # cipher = \"AB\"\n    # cipher = \"BA\"\n    # cipher = \"BB\"\n    # cipher = \"BBA\"\n    # cipher = \"BAA\"\n    # cipher = \"BAB\"\n    # cipher = \"BAAB\"\n    # cipher = \"AABA\"\n    # cipher = \"ABAB\"\n    # cipher = \"AABB\"",
    "def solve(n, k, m):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 0:\n        return 0\n    if m == 1:\n        return 1\n    if m == 2:\n        return n\n    if k == 1:\n        return n + 1\n    if k == 2:\n        return n + n\n    if k == 3:\n        return n + n + 1\n    if k > 3:\n        return solve(n, k - 1, m - 1) + solve(n, k - 2, m - 1)\n    return solve(n, k - 1, m) + solve(n, k - 2, m)\n\nif __name__ == '__main__':\n    print solve(7, 2, 3)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        :return: the solution\n        \"\"\"\n        if len(cipher) < 2:\n            return 0\n\n        # 1. find the max number of golds\n        max_golds = 0\n        for i in xrange(len(cipher)):\n            if cipher[i] == 'G':\n                max_golds += 1\n            else:\n                max_golds -= 1\n\n        # 2. find the max number of golds\n        max_golds = 0\n        for i in xrange(len(cipher)):\n            if cipher[i] == 'G':\n                max_golds += 1\n            else:\n                max_golds -= 1\n\n        # 3. find the max number of golds\n        max_golds = 0\n        for i in xrange(len(cipher)):\n            if cipher[i] == 'G':\n                max_golds += 1\n            else:\n                max_golds -= 1\n\n        return max_golds\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"0.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\" % (solution.solve(cipher))\n        print s,",
    "class Solution:\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.upper()\n        n = len(cipher)\n        ans = []\n        for i in range(n):\n            if cipher[i] == 'A':\n                ans.append(''.join(['A', 'B', 'C']))\n            elif cipher[i] == 'B':\n                ans.append(''.join(['C', 'A', 'B']))\n            elif cipher[i] == 'C':\n                ans.append(''.join(['B', 'A', 'C']))\n            else:\n                ans.append(''.join(['C', 'B', 'A']))\n        return ''.join(ans)",
    "import random\n\ndef gold_mine(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if k == 0:\n        return 0\n    if n <= k:\n        return 0\n    return gold_mine(n - 1, k) + gold_mine(n - 1, k - 1)\n\n\ndef main():\n    \"\"\"\n    Sample Input:\n    1\n    1\n    1\n    Sample Output:\n    0\n    0\n    0\n    \"\"\"\n    print(gold_mine(3, 4))\n\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        if len(cipher) == 1:\n            return cipher\n        \n        return self.decode(self.encode(cipher))\n    \n    def encode(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        return cipher\n    \n    def decode(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        return cipher\n    \nif __name__ == '__main__':\n    s = Solution()\n    print s.solve('abcde')\n    print s.solve('a')\n    print s.solve('ab')\n    print s.solve('abc')\n    print s.solve('aabbcc')\n    print s.solve('ababcc')\n    print s.solve('abababc')\n    print s.solve('abcabc')\n    print s.solve('abababcabc')\n    print s.solve('abcabcabcabc')\n    print s.solve('abababcabcabcabc')\n    print s.solve('abcabcabcabcabcabcabcabcabc')\n    print s.solve('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
    "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: bool\n        \"\"\"\n        gas.sort()\n        cost.sort()\n        if len(gas)!= len(cost):\n            return False\n        if len(gas) == 0:\n            return True\n        \n        start = 0\n        end = len(gas) - 1\n        \n        while start < end:\n            if gas[start] + cost[start] > gas[end]:\n                return False\n            elif gas[start] + cost[start] < gas[end]:\n                return True\n            start += 1\n            end -= 1\n        \n        return True",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        # write your code here\n        count = 0\n        res = []\n        for i in range(len(cipher)):\n            if cipher[i] == '1':\n                count += 1\n            else:\n                if count > 0:\n                    res.append(count)\n                    count = 0\n        if count > 0:\n            res.append(count)\n        return ''.join(map(str, res))",
    "class Solution:\n    # @param {integer[]} prices\n    # @return {integer[]}\n    def maxCoins(self, prices):\n        n = len(prices)\n        dp = [0] * n\n        dp[0] = 0\n        for i in xrange(1, n):\n            dp[i] = max(dp[i - 1] + prices[i], dp[i - 1])\n        return dp[-1]",
    "import numpy as np\n\ndef solve_gold_mine(n, k):\n    \"\"\"\n    Input n is the total number of items in the mine, and k is the number of\n    items to be extracted.\n\n    Output: An array of size k containing the number of items extracted.\n    \"\"\"\n    # Initialize the array to hold the number of items extracted.\n    num_extracted = [0] * k\n    # Generate a random number between 0 and n-1.\n    random_number = np.random.randint(0, n-1)\n    # Generate a random number between 0 and k-1.\n    random_number = np.random.randint(0, k-1)\n    # For each item, extract it.\n    for i in range(k):\n        # If the random number is smaller than the number of items in the\n        # mine, extract it.\n        if random_number < n:\n            # Add 1 to the array.\n            num_extracted[i] += 1\n        # If the random number is larger than the number of items in the mine,\n        # do not extract it.\n        if random_number > n:\n            # Subtract 1 from the array.\n            num_extracted[i] -= 1\n        # If the random number is equal to the number of items in the mine,\n        # extract it.\n        if random_number == n:\n            # Add 1 to the array.\n            num_extracted[i] += 1\n    return num_extracted\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the number of items in the mine: \"))\n    k = int(input(\"Enter the number of items to be extracted: \"))\n    num_extracted = solve_gold_mine(n, k)\n    print(\"The number of items extracted is:\")\n    for i in range(k):\n        print(num_extracted[i], end=\" \")\n    print()",
    "import unittest\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        if cipher == \"\":\n            return 0\n        pairs = {'a': 'b', 'b': 'a'}\n        res = 0\n        for i, c in enumerate(cipher):\n            if i % 2 == 0:\n                res += pairs[c]\n            else:\n                res -= pairs[c]\n        return res\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/gold-mine-ii/solution/\n#\nApproach 1: Brute Force\nComplexity Analysis\nTime Complexity: O(n^2), where n is the length of cipher.\nSpace Complexity: O(n^2).\n# 1ms 100%\nclass Solution {\n    public int solve(String cipher) {\n        int res = 0;\n        for (int i = 0; i < cipher.length(); i++) {\n            for (int j = 0; j < cipher.length(); j++) {\n                if (i % 2 == 0) {\n                    res += cipher.charAt(j) == cipher.charAt(i)? cipher.charAt(j) : cipher.charAt(j) - cipher.charAt(i) + cipher.charAt(i)\n                } else {\n                    res -= cipher.charAt(j) == cipher.charAt(i)? cipher.charAt(j) : cipher.charAt(j) - cipher.charAt(i) + cipher.charAt(i)\n                }\n            }\n        }\n        return res;\n    }\n}\n\nApproach 2: Hash Table\nComplexity Analysis\nTime Complexity: O(n), where n is the length of cipher.\nSpace Complexity: O(n).\n# 1ms 100%\nclass Solution {\n    public int solve(String cipher) {",
    "from collections import namedtuple\n\n\ndef solve_gold_mine(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # n * k is the number of unique mines, but there are k unique\n    # mines in total, so the total number of unique mines is n * k + 1.\n    # We need to count the number of unique mines in the first k positions,\n    # then the number of unique mines in the last n - k positions.\n    # So we can write a function to count the number of unique mines\n    # in the first k positions, and then the number of unique mines\n    # in the last n - k positions.\n    # We can use a namedtuple to represent the unique mine information,\n    # and then we can use the namedtuple as a key in a dictionary.\n    # Then we can use the dictionary as a set to count the number of\n    # unique mines.\n    # Then we can use the set as a key in a dictionary to count the\n    # number of unique mines in the first k positions, and the number\n    # of unique mines in the last n - k positions.\n    # Finally, we can use the dictionary to count the number of unique\n    # mines.\n\n    # We can use a namedtuple to represent the unique mine information,\n    # and then we can use the namedtuple as a key in a dictionary.\n    # Then we can use the dictionary as a set to count the number of\n    # unique mines.\n    # Then we can use the set as a key in a dictionary to count the\n    # number of unique mines in the first k positions, and the number\n    # of unique mines in the last n - k positions.\n    # Finally, we can use the dictionary to count the number of unique\n    # mines.\n\n    # We can use a namedtuple to represent the unique mine information,\n    # and then we can use the namedtuple as a key in a dictionary.\n    # Then we can use the dictionary as a set to count the number of\n    # unique mines.\n    # Then we can use the set as a key in a dictionary to count the\n    # number of unique mines in the first k positions,",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        if cipher == \"\":\n            return \"None\"\n        if cipher[0] == cipher[-1]:\n            return \"None\"\n        if cipher[0] == cipher[-2]:\n            return \"None\"\n        if cipher[0] == cipher[-3]:\n            return \"None\"\n        if cipher[0] == cipher[-4]:\n            return \"None\"\n        if cipher[0] == cipher[-5]:\n            return \"None\"\n        if cipher[0] == cipher[-6]:\n            return \"None\"\n        if cipher[0] == cipher[-7]:\n            return \"None\"\n        if cipher[0] == cipher[-8]:\n            return \"None\"\n        if cipher[0] == cipher[-9]:\n            return \"None\"\n        if cipher[0] == cipher[-10]:\n            return \"None\"\n        if cipher[0] == cipher[-11]:\n            return \"None\"\n        if cipher[0] == cipher[-12]:\n            return \"None\"\n        if cipher[0] == cipher[-13]:\n            return \"None\"\n        if cipher[0] == cipher[-14]:\n            return \"None\"\n        if cipher[0] == cipher[-15]:\n            return \"None\"\n        if cipher[0] == cipher[-16]:\n            return \"None\"\n        if cipher[0] == cipher[-17]:\n            return \"None\"\n        if cipher[0] == cipher[-18]:\n            return \"None\"\n        if cipher[0] == cipher[-19]:\n            return \"None\"\n        if cipher[0] == cipher[-20]:\n            return \"None\"\n        if cipher[0] == cipher[-21]:\n            return \"None\"\n        if cipher[0] == cipher[-22]:\n            return \"None\"\n        if cipher[0] == cipher[-23]:\n            return \"None\"\n        if cipher[0] == cipher[-24]:\n            return \"None\"\n        if cipher[0] == cipher",
    "# pylint: disable=missing-docstring\n\n# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def gold_mine(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.gold_mine(root.right)\n        if root.right is None:\n            return self.gold_mine(root.left)\n        if root.left.val == root.right.val:\n            return self.gold_mine(root.left) + self.gold_mine(root.right)\n        else:\n            return max(self.gold_mine(root.left), self.gold_mine(root.right))",
    "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Point(\" + str(self.x) + \",\" + str(self.y) + \")\"\n\nclass Solution:\n    def solve(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        def find_neighbor(point, direction):\n            if direction == \"up\":\n                for i in range(point.y - 1, -1, -1):\n                    if point.x == 0:\n                        return Point(point.x, i)\n                    else:\n                        point = Point(point.x - 1, i)\n            elif direction == \"down\":\n                for i in range(point.y + 1, len(points)):\n                    if point.x == 0:\n                        return Point(point.x, i)\n                    else:\n                        point = Point(point.x + 1, i)\n            elif direction == \"left\":\n                for i in range(point.x - 1, -1, -1):\n                    if point.y == 0:\n                        return Point(i, point.y)\n                    else:\n                        point = Point(i, point.y - 1)\n            elif direction == \"right\":\n                for i in range(point.x + 1, len(points)):\n                    if point.y == 0:\n                        return Point(i, point.y)\n                    else:\n                        point = Point(i, point.y + 1)\n            return None\n\n        def find_neighbor_up(point, direction):\n            if direction == \"up\":\n                for i in range(point.y - 1, -1, -1):\n                    if point.x == 0:\n                        return Point(point.x, i)\n                    else:\n                        point = Point(point.x - 1, i)\n            elif direction == \"down\":\n                for i in range(point.y + 1, len(points)):\n                    if point.x == 0:\n                        return Point(point.",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n\n        :param cipher: the cipher\n        \"\"\"\n        if cipher == \"\":\n            return \"none\"\n        n = len(cipher)\n        pairs = []\n        for i in range(n):\n            for j in range(i+1, n):\n                pairs.append((i,j))\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if cipher[i] == cipher[j]:\n                    pairs.append((i,j))\n        pairs = list(set(pairs))\n        pairs.sort()\n        pairs = [p[0]+1,p[1]+1]\n\n        cnt = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if cipher[i] == cipher[j]:\n                    cnt += 1\n        return str(cnt)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"0.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\"%(solution.solve(cipher))\n        print s,",
    "import sys\n\n\nclass Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.mine = [0 for i in range(101)]\n\n    def solve(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        self.mine[0] = 1\n        for i in range(1, 101):\n            self.mine[i] = self.mine[i - 1] + nums[i - 1]\n\n        return self.mine[100]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
    "class Solution:\n    def solve(self, input: str) -> str:\n        \"\"\"\n        Do not return anything, modify input instead.\n        \"\"\"\n        if input == \"Gold mine\":\n            return \"The gold mine is located in the middle of the city.\"\n        elif input == \"No Gold\":\n            return \"There is no gold in the mine.\"\n        else:\n            return \"There is no gold in the mine.\"\n\n# test\ntests = [\n    (\"Gold mine\", \"The gold mine is located in the middle of the city.\"),\n    (\"No Gold\", \"There is no gold in the mine.\"),\n    (\"Gold mine\", \"The gold mine is located in the middle of the city.\"),\n    (\"Gold mine\", \"The gold mine is located in the middle of the city.\"),\n]\nfor t in tests:\n    sol = Solution()\n    actual = sol.solve(t[0])\n    print(\"Input:\", t[0])\n    print(\"Expected:\", t[1])\n    print(\"Actual:\", actual)\n    print()",
    "from collections import Counter\nimport random\n\n\nclass GoldMine:\n\n    def __init__(self):\n        self.mine_count = 0\n        self.gold_count = 0\n\n    def mine_count(self):\n        return self.mine_count\n\n    def gold_count(self):\n        return self.gold_count\n\n    def add_mine(self, n):\n        self.mine_count += n\n\n    def add_gold(self, n):\n        self.gold_count += n\n\n\ndef solve_gold_mine(mine_count, gold_count, mine_value, gold_value):\n    \"\"\"\n    :param mine_count: int\n    :param gold_count: int\n    :param mine_value: int\n    :param gold_value: int\n    :return:\n    \"\"\"\n    # Mine\n    if mine_count >= mine_value:\n        # Gold\n        if gold_count >= gold_value:\n            return True\n        # Not enough\n        else:\n            return False\n    # Not mine\n    else:\n        # Not enough\n        if mine_count >= mine_value:\n            return False\n        # Enough\n        else:\n            return True\n\n\ndef gold_mine(mine_count, gold_count, mine_value, gold_value):\n    \"\"\"\n    :param mine_count: int\n    :param gold_count: int\n    :param mine_value: int\n    :param gold_value: int\n    :return:\n    \"\"\"\n    # Mine\n    if mine_count >= mine_value:\n        # Gold\n        if gold_count >= gold_value:\n            return True\n        # Not enough\n        else:\n            return False\n    # Not mine\n    else:\n        # Not enough\n        if mine_count >= mine_value:\n            return False\n        # Enough\n        else:\n            return True\n\n\ndef main():\n    \"\"\"\n    Test\n    \"\"\"\n    # Mine\n    mine_count = 1\n    gold_count = 1\n    mine_value = 10\n    gold_value = 100\n\n    # Mine\n    print(solve_gold_mine(mine_count, gold_count, mine_value, gold_value))",
    "import math\nfrom typing import List\n\nclass Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer\n    \"\"\"\n    def findPeakElement(self, nums: List[int]) -> int:\n        \"\"\"\n        @param nums: A list of integers\n        @return: An integer\n        \"\"\"\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        \n        if n == 1:\n            return nums[0]\n        \n        if n == 2:\n            return max(nums)\n        \n        if nums[0] > nums[1]:\n            return nums[0]\n        \n        if nums[-1] > nums[-2]:\n            return nums[-1]\n        \n        for i in range(2, n):\n            if nums[i] > nums[i-1]:\n                return nums[i]\n        \n        return nums[-1]\n\nif __name__ == \"__main__\":\n    assert Solution().findPeakElement([1, 2, 3]) == 2\n    assert Solution().findPeakElement([-1, -2, -3, -4]) == -4\n    assert Solution().findPeakElement([-1, -2, -3, -4, -5, -6, -7, -8, -9]) == -9\n    assert Solution().findPeakElement([0]) == 0\n    assert Solution().findPeakElement([-1, -2, -3, -4, -5, -6, -7, -8, -9]) == -9",
    "from collections import namedtuple\n\nGoldMine = namedtuple('GoldMine', 'x y h')\n\ndef gold_mine(x, y, h):\n    \"\"\"\n    Input:\n    x = the number of rows in the mine\n    y = the number of columns in the mine\n    h = the height of the mine\n    Output:\n    The total number of gold.\n    \"\"\"\n    if h <= 0:\n        return 0\n\n    if x == 0 or y == 0:\n        return 0\n\n    if x <= 1 or y <= 1:\n        return 1\n\n    if x == y:\n        return 2\n\n    total = 0\n    for i in range(1, x):\n        for j in range(1, y):\n            total += gold_mine(i, j, h - 1)\n\n    return total\n\n\ndef main():\n    \"\"\"\n    Main entry of this module.\n    \"\"\"\n    x, y, h = map(int, input().split())\n    print(gold_mine(x, y, h))\n\n\nif __name__ == '__main__':\n    main()",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        num = 0\n        for c in cipher:\n            if c == 'A':\n                num += 1\n            elif c == 'B':\n                num -= 1\n            elif c == 'C':\n                num *= 2\n            elif c == 'D':\n                num /= 2\n        return num\n\n\ndef main():\n    s = Solution()\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n    cipher = \"ADBACBCD\"\n    print s.solve(cipher)\n\nif __name__ == '__main__':\n    main()",
    "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def solve(self, num):\n        result = []\n        self.helper(num, result)\n        return result\n\n    def helper(self, num, result):\n        if not num:\n            return\n\n        for i in range(len(num)):\n            if num[i] == 1:\n                result.append([])\n                self.helper(num[:i] + num[i + 1:], result[-1])\n                break\n            else:\n                result[-1].append(num[i])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.solve([1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
    "def solve(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # write your code here\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43",
    "__author__ = 'Daniel'\n\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.n = len(nums)\n\n    def update(self, index, val):\n        \"\"\"\n        replace val at index to val.\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.nums[index] = val\n        if index < self.n - 1:\n            self.nums[index + 1] = self.nums[index]\n\n    def get(self, index):\n        \"\"\"\n        Returns the value at index.\n        :type index: int\n        :rtype: int\n        \"\"\"\n        return self.nums[index]\n\n    def reset(self):\n        \"\"\"\n        Reset the underlying array to its original configuration and return it.\n        :rtype: List[int]\n        \"\"\"\n        return self.nums[:]\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.update(index,val)\n# param_2 = obj.get(index)\n# param_3 = obj.reset()",
    "def solve(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: List[List[int]]\n    \"\"\"\n    # n is the number of rows and m is the number of columns.\n    # Each row and column contains the weight of the mine.\n    # The mine is placed in the center of the mine area.\n    # The mine area is defined by [0, n-1] and [0, m-1].\n    # The solution is a list of lists, where each list is the row\n    # and each item is the column of mine.\n    #\n    # Example 1:\n    # n = 3, m = 3\n    #\n    #       1\n    #   1 2\n    # 1 2 3\n    #\n    # The solution is [[0, 0], [0, 1], [0, 2]].\n    #\n    # Example 2:\n    # n = 4, m = 3\n    #\n    #       1\n    #   1 2\n    # 1 3 4\n    #   2 3\n    #\n    # The solution is [[0, 0], [0, 1], [0, 2], [1, 2]].\n    #\n    # Note:\n    # The number of rows and columns is in range [1, n].\n    # The number of mines is in range [0, m].\n    # The mine area is defined by [0, n-1] and [0, m-1].\n    # The solution is a list of lists, where each list is the row\n    # and each item is the column of mine.\n    #\n    # Time complexity: O(n * m * (m + n - 1))\n    # Space complexity: O(m * n)\n    \n    # Initialize the solution.\n    res = []\n    for i in range(m+1):\n        res.append([])\n        for j in range(n+1):\n            res[i].append(0)\n    \n    # Place the mine.\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            if j == 0 or i == m-1",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        n = len(cipher)\n        count = {}\n        for i in range(n):\n            if cipher[i] in count:\n                count[cipher[i]] += 1\n            else:\n                count[cipher[i]] = 1\n        ans = ''\n        for i in range(n):\n            if cipher[i] in count:\n                ans += str(count[cipher[i]])\n        return ans",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        count = 0\n        for i in range(len(cipher)):\n            for j in range(len(cipher)):\n                if cipher[i][j] == 'X':\n                    count += 1\n                else:\n                    count -= 1\n        return count\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = [['.' for i in range(len(cipher))] for j in range(len(cipher))]\n\n        for i in xrange(6):\n            for j in xrange(6):\n                cipher[i][j] = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\" % (solution.solve(cipher))\n        print s,",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        gold_mines = 0\n        for i in range(len(cipher)):\n            if cipher[i] == 'G':\n                gold_mines += 1\n        for i in range(len(cipher) - 1, -1, -1):\n            if cipher[i] == 'G':\n                gold_mines += 1\n        return gold_mines",
    "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution:\n    def gold_mine(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        def dfs(p, cnt):\n            if cnt == 0:\n                return cnt\n            if p.x == 0 and p.y == 0:\n                return 0\n            if p.x == 0:\n                return dfs(p.move(0, 1), cnt - 1)\n            if p.y == 0:\n                return dfs(p.move(1, 0), cnt - 1)\n            if p.x == p.y:\n                return dfs(p.move(0, 1), cnt - 1)\n            return dfs(p.move(1, 0), cnt - 1) + dfs(p.move(0, 1), cnt - 1)\n        ans = 0\n        for p in points:\n            ans += dfs(p, len(points) - 1)\n        return ans",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        cipher = cipher.upper()\n        return sum([int(c) for c in cipher if c == 'A' or c == 'B'])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.solve('ABAB')",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        self.goldMine(cipher)\n\n    def goldMine(self, cipher):\n        \"\"\"\n        Gold mine problem\n        :param cipher: the cipher\n        :return: nothing\n        \"\"\"\n        def goldMine(cipher):\n            \"\"\"\n            Gold mine\n            :param cipher: the cipher\n            :return: nothing\n            \"\"\"\n            solution = [0 for _ in xrange(len(cipher))]\n            # find the max\n            for i in xrange(len(cipher)):\n                for j in xrange(len(cipher)):\n                    if cipher[i] == cipher[j] and i!= j:\n                        solution[i] = max(solution[i], solution[j] + 1)\n            # print \"solution:\", solution\n            return solution\n\n        # find the max\n        max_solution = [0 for _ in xrange(len(cipher))]\n        for i in xrange(len(cipher)):\n            for j in xrange(len(cipher)):\n                if cipher[i] == cipher[j] and i!= j:\n                    max_solution[i] = max(max_solution[i], max_solution[j] + 1)\n        # print \"max_solution:\", max_solution\n        return max_solution",
    "import sys\n\n__author__ = 'Daniel'\n\n\ndef gold_mine(height, width):\n    \"\"\"\n    :type height: int\n    :type width: int\n    :rtype: int\n    \"\"\"\n    if height == 0 or width == 0:\n        return 0\n    if height == 1 or width == 1:\n        return 1\n    for row in range(height):\n        for col in range(width):\n            if row == 0 or col == 0:\n                continue\n            if row == height - 1 or col == width - 1:\n                continue\n            if (row - 1) * width + col > (height - 1) * width + (col - 1):\n                return 0\n    return 1\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    height = int(sys.stdin.readline())\n    width = int(sys.stdin.readline())\n    print(gold_mine(height, width))\n\n\nif __name__ == '__main__':\n    main()",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        :return: the result\n        \"\"\"\n        return self.solve_helper(cipher, 0, cipher[0])\n\n    def solve_helper(self, cipher, j, m):\n        if j == len(cipher):\n            return m\n        if j == 0:\n            return 0\n        if cipher[j]!= 'A':\n            return self.solve_helper(cipher, j-1, m)\n        else:\n            return self.solve_helper(cipher, j-1, m+1)",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        if cipher == 'a' or cipher == 'b':\n            return 0\n        if cipher == 'c':\n            return 1\n        return 2\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.solve(cipher)",
    "class Solution:\n    def solve(self, cipher: str) -> int:\n        \"\"\"\n        Encrypt a string to a number.\n        :param cipher: cipher\n        :return: result\n        \"\"\"\n        result = 0\n        for i in range(len(cipher)):\n            result = result ^ int(cipher[i])\n        return result",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        cipher = cipher.upper()\n\n        # 1. read the cipher\n        length = len(cipher)\n        self.nums = [0] * length\n        for i, c in enumerate(cipher):\n            self.nums[i] = cipher.index(c) + 1\n\n        # 2. count the number of 1's\n        self.num_1 = 0\n        for i in range(length):\n            if self.nums[i] == 1:\n                self.num_1 += 1\n\n        # 3. count the number of 0's\n        self.num_0 = length - self.num_1\n\n        # 4. generate the binary number\n        self.binary = []\n        for i in range(length):\n            self.binary.append(str(self.nums[i]))\n\n        # 5. compute the number of 1's in the binary\n        self.num_1_binary = self.num_1 * 2\n        for i in range(length):\n            self.num_1_binary += int(self.binary[i])\n\n        # 6. compute the number of 0's in the binary\n        self.num_0_binary = (length - self.num_1) * 2\n        for i in range(length):\n            self.num_0_binary += int(self.binary[i])\n\n        # 7. generate the number of 1's in the binary\n        self.num_1_binary_string = str(self.num_1_binary)\n        self.num_1_binary_string = self.num_1_binary_string[::-1]\n        self.num_1_binary_string = '0' * (self.num_1_binary % 2) + self.num_1_binary_string\n\n        # 8. generate the number of 0's in the binary\n        self.num_0_binary_string = str(self.num_0_binary)\n        self.num_0_binary_string = self.num_0_binary_string[::",
    "class Solution:\n    \"\"\"\n    @param n: The number of mines in a given field.\n    @return: A list of integers representing the number of grains\n    saved by the thief for each available room.\n    \"\"\"\n    def numMines(self, n):\n        return self.solve(n)\n\n    def solve(self, n):\n        ret = [0] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if i == j:\n                    ret[i] += 1\n                elif i < j:\n                    ret[i] += max(ret[j - 1], ret[i - 1])\n        return ret\n\n# test\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/gold-mine/solution/\n#\n# Approach #1: Iterate\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n#\n# 1. Build a hash table to store the value of each room.\n# 2. For each mine, add it to the hash table if it is not visited.\n# 3. Once we have visited all the rooms, return the max value of the hash table.\n# 4. There are two cases:\n#    a. If there is a max value in the hash table, then it is the number of mines we have to save.\n#    b. If the hash table is empty, then we are not able to save any mines.\n#\n\n# 1ms 100%\nclass Solution {\n    public int numMines(int n) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 1; i <= n; i++) {\n            map.put(i, 0);\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {",
    "from collections import Counter\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for i in range(len(cipher)):\n            if cipher[i] == 'A':\n                result.append('X')\n            elif cipher[i] == 'B':\n                result.append('B')\n            elif cipher[i] == 'C':\n                result.append('C')\n            else:\n                result.append(cipher[i])\n        return ''.join(result)\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    cipher = 'ABCABC'\n    print solution.solve(cipher)",
    "from collections import defaultdict\nfrom math import ceil\n\n\nclass Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.mine = defaultdict(lambda: 0)\n        self.total = 0\n\n    def solve(self, numRows, numCols, mine):\n        \"\"\"\n        Solve the problem.\n        :type numRows: int\n        :type numCols: int\n        :type mine: List[List[int]]\n        :rtype: void\n        \"\"\"\n        for i in range(numRows):\n            for j in range(numCols):\n                if mine[i][j] == 1:\n                    self.mine[(i, j)] += 1\n                    self.total += 1\n        for i in range(numRows):\n            for j in range(numCols):\n                if mine[i][j] == 0:\n                    self.total -= 1\n                    self.mine[(i, j)] -= 1\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# obj.solve(numRows, numCols, mine)\n\nif __name__ == '__main__':\n    print Solution().solve(3, 3, [[1, 1, 1], [1, 1, 0], [1, 0, 1]])\n    print Solution().solve(3, 3, [[1, 1, 1], [1, 0, 1], [0, 1, 1]])\n    print Solution().solve(3, 3, [[1, 1, 0], [1, 0, 1], [0, 1, 1]])\n    print Solution().solve(3, 3, [[1, 1, 0], [0, 0, 1], [1, 1, 1]])",
    "def gold_mine(w, h):\n    \"\"\"\n    :type w: int\n    :type h: int\n    :rtype: int\n    \"\"\"\n    if w == 1 and h == 1:\n        return 1\n    elif w == 1 and h > 1:\n        return 0\n    elif w > 1 and h == 1:\n        return 0\n    elif w > 1 and h > 1:\n        return max(gold_mine(w - 1, h), gold_mine(w, h - 1))\n    return 0\n\nif __name__ == '__main__':\n    print(gold_mine(3, 2))",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: int\n        \"\"\"\n        cipher = cipher.lower()\n        if not cipher:\n            return 0\n        size = len(cipher)\n        if size == 1:\n            return 1\n        if size == 2:\n            return cipher[0] - 'a' + cipher[1] - 'a'\n        if size == 3:\n            return cipher[0] - 'a' + cipher[1] - 'a' + cipher[2] - 'a'\n        if size == 4:\n            return cipher[0] - 'a' + cipher[1] - 'a' + cipher[2] - 'a' + cipher[3] - 'a'\n        if size == 5:\n            return cipher[0] - 'a' + cipher[1] - 'a' + cipher[2] - 'a' + cipher[3] - 'a' + cipher[4] - 'a'\n        if size == 6:\n            return cipher[0] - 'a' + cipher[1] - 'a' + cipher[2] - 'a' + cipher[3] - 'a' + cipher[4] - 'a' + cipher[5] - 'a'\n        return 0",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.upper()\n        res = ''\n        for i in xrange(len(cipher)):\n            if cipher[i] == 'A':\n                res += cipher[i - 1]\n                res += cipher[i + 1]\n            elif cipher[i] == 'B':\n                res += cipher[i - 1]\n            elif cipher[i] == 'C':\n                res += cipher[i - 1]\n                res += cipher[i + 1]\n            elif cipher[i] == 'D':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n            elif cipher[i] == 'E':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n                res += cipher[i + 3]\n            elif cipher[i] == 'F':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n                res += cipher[i + 4]\n            elif cipher[i] == 'G':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n                res += cipher[i + 4]\n                res += cipher[i + 5]\n            elif cipher[i] == 'H':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n                res += cipher[i + 4]\n                res += cipher[i + 5]\n                res += cipher[i + 6]\n            elif cipher[i] == 'I':\n                res += cipher[i - 1]\n                res += cipher[i + 2]\n                res += cipher[i + 4]\n                res += cipher[i + 5]\n                res += cipher[i + 6]\n                res += cipher[i + 7]\n            else:\n                res += cipher[i]\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.solve('ADOBECODEBANC')",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        N = len(cipher)\n        print cipher\n        # build table\n        table = [[0 for j in xrange(N)] for i in xrange(N)]\n        for i in xrange(N):\n            for j in xrange(N):\n                if cipher[i] == cipher[j]:\n                    table[i][j] = 1\n                else:\n                    table[i][j] = 0\n        # find the first one\n        for i in xrange(N):\n            for j in xrange(N):\n                if table[i][j] == 1:\n                    return i, j\n\n    def solve2(self, cipher):\n        \"\"\"\n        two-pass solution\n        :param cipher: the cipher\n        \"\"\"\n        N = len(cipher)\n        print cipher\n        # build table\n        table = [[0 for j in xrange(N)] for i in xrange(N)]\n        for i in xrange(N):\n            for j in xrange(N):\n                if cipher[i] == cipher[j]:\n                    table[i][j] = 1\n                else:\n                    table[i][j] = 0\n        # find the first one\n        for i in xrange(N):\n            for j in xrange(N):\n                if table[i][j] == 1:\n                    return i, j\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    N = int(f.readline().strip())\n    cipher = f.readline().strip().split(' ')\n    cipher = [int(c) for c in cipher]\n    # solve\n    print \"Case #1:\", solution.solve(cipher)\n    # solve2\n    print \"Case #2:\", solution.solve2(cipher)",
    "import time\nimport math\n\ndef solve_gold_mine(gold, mines):\n    \"\"\"\n    :param gold: the number of gold\n    :param mines: the number of mines\n    :return: the number of ways\n    \"\"\"\n    if gold == 0:\n        return 0\n\n    if mines == 0:\n        return 1\n\n    if gold < mines:\n        return solve_gold_mine(gold, mines - gold)\n\n    if gold % mines!= 0:\n        return solve_gold_mine(gold - 1, mines)\n\n    return solve_gold_mine(gold - 1, mines - 1) + solve_gold_mine(gold, mines)\n\nif __name__ == '__main__':\n    start_time = time.time()\n\n    print solve_gold_mine(100, 100)\n    print solve_gold_mine(10000, 10000)\n\n    print 'elapsed: {0:.3f}'.format(time.time() - start_time)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        if len(cipher) == 1:\n            return 1\n        N = len(cipher)\n        cipher = [1 if c == 'A' else 0 for c in cipher]\n        count = [0] * (N+1)\n        for i in xrange(N):\n            count[cipher[i]] += 1\n        return count[cipher[N]]\n\n\nif __name__ == \"__main__\":\n    import sys\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    N = int(f.readline().strip())\n    for i in xrange(N):\n        cipher = f.readline().strip()\n        cipher = [int(c) for c in cipher]\n        print \"Case #%d: %s\" % (i+1, \"%s\" % (solution.solve(cipher)))",
    "class Solution:\n    def __init__(self):\n        self.cache = {}\n        \n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        if cipher in self.cache:\n            return self.cache[cipher]\n        \n        # base case\n        if cipher == '':\n            return ''\n        \n        for i in range(1, len(cipher)):\n            if cipher[i-1] == cipher[i]:\n                continue\n            else:\n                result = self.solve(cipher[:i]+cipher[i+1:])\n                if result:\n                    return result\n                \n        return cipher\n\n# test\ns = Solution()\nprint s.solve('aabbcc')",
    "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        def gold_mine(s, n):\n            if n == 0:\n                return 0\n            if s[0] == '1':\n                return gold_mine(s[1:], n - 1)\n            if s[0] == '0':\n                return gold_mine(s[1:], n - 1)\n            return n - gold_mine(s[1:], n - 1)\n\n        return gold_mine(cipher, len(cipher))\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.solve(\"1000000\")",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n\n        :param cipher: the cipher\n        \"\"\"\n        # get the size\n        size = cipher[0]\n        cipher = cipher[1:]\n\n        # build the dict\n        ret = dict()\n        for i in range(size):\n            ret[i] = dict()\n            for j in range(size):\n                ret[i][j] = 0\n\n        # fill the dict\n        for i in range(size):\n            for j in range(size):\n                if cipher[i] == cipher[j]:\n                    ret[i][j] = 1\n\n        # print the result\n        print ret\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    solution.solve(f.read().split(\"\\n\"))\n    f.close()",
    "def solve(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    # base cases\n    if n == 0 or m == 0:\n        return 0\n    elif n == 1 or m == 1:\n        return 1\n    elif n == 2 or m == 2:\n        return 2\n    elif n == 3 or m == 3:\n        return 3\n    elif n == 4 or m == 4:\n        return 4\n    elif n == 5 or m == 5:\n        return 5\n    elif n == 6 or m == 6:\n        return 6\n    elif n == 7 or m == 7:\n        return 7\n    elif n == 8 or m == 8:\n        return 8\n    elif n == 9 or m == 9:\n        return 9\n    # recursion\n    if m % 2 == 0:\n        return solve(n - 1, m / 2) + solve(n, m / 2)\n    else:\n        return solve(n - 1, m / 2) + solve(n, m / 2) + solve(n - 1, m / 2 + 1)\n\nif __name__ == '__main__':\n    print(solve(6, 3))",
    "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '<Point x=\"{0}\", y=\"{1}\">'.format(self.x, self.y)\n\n\nclass Solution(object):\n    def solve(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        if not points:\n            return 0\n        n = len(points)\n        result = 0\n        for i in range(n):\n            left = points[i]\n            for j in range(i+1, n):\n                right = points[j]\n                if left.x == right.x:\n                    result += 1\n                if left.y == right.y:\n                    result += 1\n        return result",
    "def gold_mine(n, k):\n    \"\"\"\n    Input: n is the number of items, and k is the number of gold\n    Output: the max number of ways to put k items into n boxes.\n    \"\"\"\n    return int(1e9 + 9)\n\n\nif __name__ == '__main__':\n    assert(gold_mine(10, 5) == 26)",
    "def solve_gold_mine(n):\n    \"\"\"\n    Write a function solve_gold_mine(n) that, given an integer n, returns\n    the total number of ways to make n gold coins.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n % 2 == 0:\n        return solve_gold_mine(n/2) + solve_gold_mine(n/2)\n    else:\n        return solve_gold_mine(n-1) + solve_gold_mine(n-1)\n\ndef test_solve_gold_mine():\n    assert solve_gold_mine(1) == 1\n    assert solve_gold_mine(2) == 2\n    assert solve_gold_mine(3) == 3\n    assert solve_gold_mine(4) == 5\n    assert solve_gold_mine(5) == 9\n    assert solve_gold_mine(6) == 13\n    assert solve_gold_mine(7) == 17\n    assert solve_gold_mine(8) == 23\n    assert solve_gold_mine(9) == 29\n    assert solve_gold_mine(10) == 37\n\nif __name__ == '__main__':\n    test_solve_gold_mine()",
    "def solve(n):\n    if n == 0:\n        return 0\n    else:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return solve(n-1) + solve(n-2)\n\nn = int(input())\nprint(solve(n))",
    "import math\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.upper()\n        max_gold = 0\n        max_num = 0\n        gold_cnt = 0\n        for i in range(1, len(cipher)):\n            gold_cnt += int(cipher[i-1] == cipher[i])\n            if gold_cnt > max_gold:\n                max_gold = gold_cnt\n                max_num = i\n        return ''.join(cipher[i] for i in range(max_num, 0, -1))\n\n\ndef main():\n    s = Solution()\n    s.solve(\"AA\")\n\nif __name__ == '__main__':\n    main()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}