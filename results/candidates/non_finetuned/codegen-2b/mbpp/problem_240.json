{
  "problem": {
    "task_id": "MBPP/251",
    "prompt": "Write a function to insert an element before each element of a list.",
    "canonical_solution": "def insert_element(list,element):\r\n list = [v for elt in list for v in (element, elt)]\r\n return list",
    "test_list": [
      "assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] ",
      "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] ",
      "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] "
    ],
    "challenge_test_list": [],
    "problem_id": 240
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head: ListNode, insert_node: ListNode, insert_after: ListNode) -> ListNode:\n        if not head or not insert_node or not insert_after:\n            return head\n\n        insert_node_prev = None\n        insert_node_next = insert_node\n        insert_node_prev_next = insert_node.next\n        insert_node_next_prev = insert_node.prev\n        insert_node_next_prev_next = insert_node.next.next\n        while insert_node_next_prev:\n            insert_node_prev = insert_node_next_prev\n            insert_node_next = insert_node_next_prev\n            insert_node_next_prev = insert_node_next_prev_next\n            insert_node_next_prev_next = insert_node_next_prev_next.next\n\n        insert_node_prev.next = insert_node_next\n        insert_node_prev_next.next = insert_node_next_next\n        insert_node_next_prev.next = insert_node_next_next_next\n        insert_node_next_prev_next.next = insert_node_next\n\n        return head\n\ns = Solution()\n\nnode = ListNode(1)\nnode.next = ListNode(2)\nnode.next.next = ListNode(3)\nnode.next.next.next = ListNode(4)\nnode.next.next.next.next = ListNode(5)\nnode.next.next.next.next.next = ListNode(6)\nnode.next.next.next.next.next.next = ListNode(7)\nnode.next.next.next.next.next.next.next = ListNode(8)\nnode.next.next.next.next.next.next.next.next = ListNode(9)\n\nhead = node\n\ninsert_node = ListNode(10)\ninsert_after = node\n\ns.insertBefore(head, insert_node,",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next:\n            prev = prev.next\n        node = prev\n        while node.next:\n            node = node.next\n        node.next = ListNode(val)\n        return dummy.next",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        pre = None\n        cur = head\n        while cur.next:\n            pre = cur\n            cur = cur.next\n            while pre and cur.val < pre.val:\n                pre = pre.next\n            if pre:\n                pre.next = cur\n                cur = cur.next\n        \n        return pre",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if not head:\n            return ListNode(val)\n        if head.val < val:\n            pre = self.insertBefore(head.next, val)\n            head.next = pre\n        else:\n            curr = head\n            while curr.next and curr.next.val < val:\n                curr = curr.next\n            pre = curr.next\n            curr.next = ListNode(val)\n            curr.next.next = pre\n        return head\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(2)\n    head.next = ListNode(1)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    res = sol.insertBefore(head, 14)\n    while res:\n        res =",
    "class Solution:\n    # @param head, a list node\n    # @param val, an integer\n    # @return a list node\n    def insertBefore(self, head, val):\n        new_node = Node(val)\n        new_node.next = head\n        if head == None:\n            return new_node\n        head = new_node\n        while head.next!= None:\n            head = head.next\n        head.next = new_node\n        return head\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ns = Solution()\nhead = Node(1)\nhead = s.insertBefore(head, 2)\nhead = s.insertBefore(head, 3)\nhead = s.insertBefore(head, 4)\nhead = s.insertBefore(head, 5)\nhead = s.insertBefore(head, 6)\nhead = s.insertBefore(head, 7)\nhead = s.insertBefore(head, 8)\nhead = s.insertBefore(head, 9)\nhead = s.insertBefore(head, 10)\nhead = s.insertBefore(head, 11)\nhead = s.insertBefore(head, 12)\nhead = s.insertBefore(head, 13)\nhead = s.insertBefore(head, 14)\nhead = s.insertBefore(head, 15)\nhead = s.insertBefore(head, 16)\nhead = s.insertBefore(head, 17)\nhead = s.insertBefore(head, 18)\nhead = s.insertBefore(head, 19)\nhead = s.insertBefore(head, 20)\nhead = s.insertBefore(head, 21)\nhead = s.insertBefore(head, 22)\nhead = s.insertBefore(head, 23)\nhead = s.insertBefore(head, 24)\nhead = s.insertBefore(head, 25)\nhead = s.insertBefore(head, 26)\nhead = s.insertBefore(head, 27)\nhead = s.insertBefore(head, 28)\nhead = s.insertBefore(head, 29)\nhead = s.insertBefore(head, 30)\nhead = s.insertBefore(head,",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = self.insert(slow, fast.val)\n            fast = fast.next\n        \n        return slow\n        \n    def insert(self, head, val):\n        node = ListNode(val)\n        node.next = head\n        return node",
    "# https://leetcode.com/problems/insert-element-before-each-element-of-a-sorted-list/discuss/253520/Python-Cython-SortedList-Insert-Element-Before-Each-Element-Of-A-Sorted-List\n\n# https://leetcode.com/problems/insert-element-before-each-element-of-a-sorted-list/discuss/253520/Python-Cython-SortedList-Insert-Element-Before-Each-Element-Of-A-Sorted-List\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBeforeEach(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not newNode:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        newNode.next = fast\n        newNode.next = slow.next\n        slow.next = newNode\n        return head",
    "def insert_before(list, element):\n    for i in range(0, len(list)):\n        list.insert(i, element)\n    return list\n\n\nprint(insert_before([1, 2, 3, 4], 5))\nprint(insert_before([1, 2, 3, 4], 3))\nprint(insert_before([1, 2, 3, 4], 6))",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return ListNode(val)\n        p = head\n        while p.next:\n            p = p.next\n        p.next = ListNode(val)\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev:\n            prev = prev.next\n            if prev:\n                prev.next = ListNode(val)\n                break\n            else:\n                prev = dummy.next\n\n        return dummy.next",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        prev = head\n        cur = head.next\n        while cur:\n            prev.next = cur\n            prev = cur\n            cur = cur.next\n        return head",
    "# https://leetcode.com/problems/insert-element-before-each-element-of-a-sorted-list/\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBeforeEach(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return newNode\n        while head.next:\n            head = head.next\n        head.next = newNode\n        return head\n\n\nif __name__ == \"__main__\":\n    #head = ListNode(1)\n    #head.next = ListNode(2)\n    #head.next.next = ListNode(3)\n    #head.next.next.next = ListNode(4)\n    #head.next.next.next.next = ListNode(5)\n    #head.next.next.next.next.next = ListNode(6)\n    #print Solution().insertBeforeEach(head, ListNode(7))\n    #print Solution().insertBeforeEach(head, ListNode(8))\n    #print Solution().insertBeforeEach(head, ListNode(9))\n    #print Solution().insertBeforeEach(head, ListNode(10))\n    #print Solution().insertBeforeEach(head, ListNode(11))\n    #print Solution().insertBeforeEach(head, ListNode(12))\n    #print Solution().insertBeforeEach(head, ListNode(13))\n    #print Solution().insertBeforeEach(head, ListNode(14))\n    #print Solution().insertBeforeEach(head, ListNode(15))\n    #print Solution().insertBeforeEach(head, ListNode(16))\n    #print Solution().insertBeforeEach(head, ListNode(17))\n    #print Solution().insertBeforeEach(head, ListNode(18))\n    #print Solution().insertBeforeEach(head, ListNode(19))\n    #print Solution().insertBeforeEach(head, ListNode(20))\n    #print",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode.next = head\n        return newNode\n\nclass Solution2(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        while head and head.next:\n            head = head.next\n        newNode.next = head\n        return newNode\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n\n    s = Solution()\n    s.insertBefore(head, ListNode(10))\n    print s.insertBefore(head, ListNode(11))\n    print s.insertBefore(head, ListNode(12))\n    print s.insertBefore(head, ListNode(13))\n    print s.insertBefore(head, ListNode(14))\n    print s.insertBefore(head, ListNode(15))\n    print s.insertBefore(head, ListNode(16))\n    print s.insertBefore(head, ListNode(17))\n    print s.insertBefore(head, ListNode(18))\n    print s.insertBefore(head, ListNode(19))\n    print s.insertBefore",
    "class Solution:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a list node\n    def insertBefore(self, head, val):\n        if head is None:\n            return Node(val)\n        elif head.next is None:\n            return head.insert(val)\n        else:\n            new_head = head.insert(val)\n            new_head.next = self.insertBefore(head.next, val)\n            return new_head\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def insert(self, val):\n        new_node = Node(val)\n        new_node.next = self.next\n        self.next = new_node\n        return new_node\n\nhead = Node(1)\nhead.insert(2)\nhead.insert(3)\nhead.insert(4)\nhead.insert(5)\nhead.insert(6)\nhead.insert(7)\nhead.insert(8)\nhead.insert(9)\nhead.insert(10)\nhead.insert(11)\nhead.insert(12)\nhead.insert(13)\nhead.insert(14)\nhead.insert(15)\nhead.insert(16)\nhead.insert(17)\nhead.insert(18)\nhead.insert(19)\nhead.insert(20)\nhead.insert(21)\nhead.insert(22)\nhead.insert(23)\nhead.insert(24)\nhead.insert(25)\nhead.insert(26)\nhead.insert(27)\nhead.insert(28)\nhead.insert(29)\nhead.insert(30)\nhead.insert(31)\nhead.insert(32)\nhead.insert(33)\nhead.insert(34)\nhead.insert(35)\nhead.insert(36)\nhead.insert(37)\nhead.insert(38)\nhead.insert(39)\nhead.insert(40)\nhead.insert(41)\nhead.insert(42)\nhead.insert(43)\nhead.insert(44)\nhead.insert(45)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        node = newNode\n        while head.next is not None:\n            head = head.next\n        head.next = newNode\n        node.next = head\n        return newNode\n\nif __name__ == '__main__':\n    s = Solution()\n    n1 = ListNode(1)\n    n2 = ListNode(2)\n    n3 = ListNode(3)\n    n4 = ListNode(4)\n    n5 = ListNode(5)\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    n4.next = n5\n    print(s.insertBefore(n1, n3))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, insert_node, position):\n        \"\"\"\n        :type head: ListNode\n        :type insert_node: ListNode\n        :type position: int\n        :rtype: ListNode\n        \"\"\"\n        insert_node.next = head\n        if position == 0:\n            return insert_node\n        curr = head\n        while curr.next and position > 0:\n            curr = curr.next\n            position -= 1\n        curr.next = insert_node\n        return head\n\n    def insertBefore(self, head, insert_node):\n        \"\"\"\n        :type head: ListNode\n        :type insert_node: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return insert_node\n        else:\n            prev = head\n            curr = head.next\n            while curr:\n                prev = curr\n                curr = curr.next\n            prev.next = insert_node\n            return head",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return ListNode(val)\n        cur = head\n        while cur.next:\n            cur = cur.next\n        cur.next = ListNode(val)\n        return head",
    "class Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        current = head\n        while current.next is not None:\n            current = current.next\n            while current.next is not None and current.val < current.next.val:\n                current.next = current.next.next\n            current.next = ListNode(current.val)\n            current.next.next = current\n            current = current.next.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not newNode:\n            return head\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast:\n            newNode.next = head\n            head.next = newNode\n        else:\n            newNode.next = head\n            head = newNode\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return newNode\n        newNode.next = head\n        while head.next:\n            head = head.next\n        head.next = newNode\n        return head",
    "# Your Solution\n# @param  lst,  a list of integers\n# @param  val,  an integer\n# @return  a new list\ndef insertion_sort(lst, val):\n    for i in range(1, len(lst)):\n        j = i\n        while j > 0 and lst[j - 1] > lst[j]:\n            lst[j] = lst[j - 1]\n            j -= 1\n        lst[j] = val\n    return lst",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow.next = head\n        head.next = None\n        self.insertionSortList(head)\n        return head",
    "import sys\nsys.path.append('..')\nfrom algorithms.sorting.insert_sort import insert_sort\n\n\ndef insertion_sort(a):\n    \"\"\"\n    Sort the list a.\n    \"\"\"\n    for i in range(1, len(a)):\n        j = i - 1\n        while j >= 0 and a[j] > a[j + 1]:\n            a[j + 1] = a[j]\n            j = j - 1\n        a[j + 1] = a[i]\n\n\nif __name__ == '__main__':\n    a = [3, 1, 2, 5, 4]\n    insertion_sort(a)\n    print a",
    "def insert_before(list, element, position):\n    \"\"\"\n    >>> insert_before([1, 2, 3], 4, 1)\n    [1, 2, 3, 4]\n    >>> insert_before([1, 2, 3], 4, 3)\n    [1, 2, 3, 4]\n    >>> insert_before([1, 2, 3], 4, 4)\n    [1, 2, 3, 4]\n    >>> insert_before([1, 2, 3], 4, 5)\n    [1, 2, 3, 4, 4]\n    >>> insert_before([1, 2, 3], 4, 0)\n    [1, 2, 3, 4, 4]\n    \"\"\"\n    new_list = list[:]\n    new_list.insert(position, element)\n    return new_list\n\ndef main():\n    print(insert_before([1, 2, 3], 4, 1))\n    print(insert_before([1, 2, 3], 4, 3))\n    print(insert_before([1, 2, 3], 4, 4))\n    print(insert_before([1, 2, 3], 4, 5))\n    print(insert_before([1, 2, 3], 4, 0))\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return newNode\n        curr = head\n        while curr.next:\n            curr = curr.next\n        newNode.next = curr\n        curr.next = newNode\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        pre = head\n        while pre.next is not None:\n            pre = pre.next\n        pre.next = newNode\n        newNode.next = head\n        return head\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# obj.insertBefore(head, newNode)",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def insertionSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n\n        for i in xrange(1, len(nums)):\n            # find the element to insert\n            j = i\n            while j > 0 and nums[j - 1] > nums[j]:\n                # swap\n                nums[j], nums[j - 1] = nums[j - 1], nums[j]\n                j -= 1\n\n        return\n\n\nif __name__ == \"__main__\":\n    print Solution().insertionSort([0,1,2,3,4,5,6,7,8,9])\n    print Solution().insertionSort([9,8,7,6,5,4,3,2,1,0])",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, insert_node, insert_before):\n        \"\"\"\n        :type head: ListNode\n        :type insert_node: ListNode\n        :type insert_before: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return insert_node\n        cur = head\n        while cur:\n            if cur == insert_before:\n                insert_node.next = cur.next\n                cur.next = insert_node\n                break\n            cur = cur.next\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n    def insertBefore(self, head, newNode):\n        if not head:\n            return newNode\n        elif not head.next:\n            head.next = newNode\n        else:\n            current = head\n            previous = None\n            while current.next:\n                previous = current\n                current = current.next\n            previous.next = newNode\n            newNode.next = current\n        return head\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    print Solution().insertBefore(head, ListNode(8))\n    print head.next.next.next.next.next.next.next.val\n    print head.next.next.next.next.next.next.next.next.next.val\n    print head.next.next.next.next.next.next.next.next.next.next.next.val",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if not head:\n            return ListNode(val)\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return self.insertNodeAtTail(slow, val, head)\n\n    def insertNodeAtTail(self, node, val, head):\n        if not node:\n            return ListNode(val)\n        if node.val < val:\n            node.next = self.insertNodeAtTail(node.next, val, head)\n            return head\n        else:\n            node.next = self.insertNodeAtTail(node.next, val, head)\n            return node.next\n\n\nclass Solution2:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if not head:\n            return ListNode(val)\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return self.insertNodeAtTail(slow, val, head)\n\n    def insertNodeAtTail(self, node, val, head):\n        if not node:\n            return ListNode(val)\n        if node.val < val:\n            node.next = self.insertNodeAtTail(node.next, val, head)\n            return head\n        else:\n            node.next = self.insertNodeAtTail(node.next, val, head)\n            return node.next\n\n\nclass Solution3:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if not head:",
    "import sys\n\n\nclass Solution:\n    def insertion_sort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: void Do not return anything, modify A in-place instead.\n        \"\"\"\n        # base case\n        if A is None or len(A) == 0:\n            return\n\n        # insertion sort\n        for i in range(1, len(A)):\n            # if the current element is smaller than the previous one, insert it\n            if A[i-1] > A[i]:\n                A[i] = A[i-1]\n                # move the smaller element to the right place\n                for j in range(i, len(A)):\n                    if A[j] < A[j-1]:\n                        A[j] = A[j-1]\n                        A[j-1] = A[j]\n        return\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    A = [4, 5, 1, 3, 7, 2, 6]\n    sol.insertion_sort(A)\n    print(A)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        pre = head\n        while pre.next:\n            cur = pre\n            while cur.next and cur.next.val < pre.val:\n                cur = cur.next\n            pre.next = cur.next\n            cur.next = pre\n            pre = pre.next\n        return head",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, insert_node, k):\n        \"\"\"\n        :type head: ListNode\n        :type insert_node: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # write your code here\n        if head == None:\n            return insert_node\n        if k == 0:\n            return insert_node\n        if head.next == None:\n            head.next = insert_node\n            return head\n        if k == 1:\n            head.next = insert_node\n            return head\n        p = head\n        while p.next and k > 1:\n            p = p.next\n            k -= 1\n        if k == 1:\n            p.next = insert_node\n            return head\n        if p.next:\n            p.next.next = insert_node\n            return head\n        else:\n            return insert_node",
    "# https://leetcode.com/problems/insert-element-before-each-element-of-a-linked-list/discuss/106900/Python-solution-in-O(1)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        pre = head\n        while pre.next:\n            pre = pre.next\n        pre.next = newNode\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        curr = head\n        while curr.next:\n            # insert curr.next before curr\n            curr.next = self.insertBefore(curr.next, curr)\n            curr = curr.next\n        return head\n\n    def insertBefore(self, prev, curr):\n        curr.next = prev\n        return curr",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return newNode\n        if head.next == None:\n            head.next = newNode\n        else:\n            cur = head\n            while cur.next:\n                cur = cur.next\n            cur.next = newNode\n        return head",
    "def insert_before(lst, val, before=None):\n    \"\"\"\n    >>> insert_before([1,2,3,4,5,6,7], 3)\n    [1, 2, 3, 4, 5, 6, 7, 3]\n    >>> insert_before([1,2,3,4,5,6,7], 6, before=3)\n    [1, 2, 3, 4, 5, 6, 7, 6]\n    \"\"\"\n    \n    if before is None:\n        before = 0\n    \n    for i in range(before, len(lst)):\n        lst[i] = lst[i-1]\n    lst[before] = val\n    return lst\n\n\n# Test Code\n\ndef test():\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print insert_before(lst, 3)\n    print insert_before(lst, 9, before=3)\n    \n    \nif __name__ == \"__main__\":\n    test()",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        prev = None\n        curr = head\n        while curr:\n            if curr.next:\n                prev = curr\n                curr = curr.next\n            else:\n                prev.next = ListNode(x)\n                return head\n        \n        prev.next = ListNode(x)\n        return head\n\n\n# Note:\n# The Solution object is instantiated only once and is reused by each test case.\n# This means the data structures (e.g. prev) are not copied.\n# An instance of Solution is passed to each test function.\n#",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        if head is None:\n            return head\n        if head.next is None:\n            return head\n        pivot = head\n        while pivot.next is not None:\n            while pivot.next is not None and pivot.next.val < pivot.val:\n                pivot = pivot.next\n            #print(pivot.val)\n            pivot.next = self.insertBefore(pivot, pivot.next)\n        return head\n    \n    def insertBefore(self, p, q):\n        while p.next is not None:\n            if p.next.val < q.val:\n                p = p.next\n            else:\n                q.next = p.next\n                p.next = q\n                return q\n        return p.next",
    "# https://leetcode.com/problems/insert-element-before-each-element-of-a-sorted-list/\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertBefore(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        new_head = ListNode(val)\n        if head == None:\n            return new_head\n        \n        pre_head = ListNode(0)\n        pre_head.next = head\n        new_head.next = head.next\n        \n        while head.next!= None:\n            pre_head = head\n            head = head.next\n            \n        pre_head.next = new_head\n        \n        return pre_head.next",
    "def insertBefore(alist, item, index=0):\n    \"\"\"\n    >>> alist = [1,2,3]\n    >>> insertBefore(alist, 4)\n    >>> alist\n    [1, 2, 3, 4]\n    >>> insertBefore(alist, 5, 1)\n    >>> alist\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    insertBeforeList(alist, item, index)\n\ndef insertBeforeList(alist, item, index):\n    \"\"\"\n    >>> insertBeforeList([1, 2, 3], 4)\n    >>> insertBeforeList([1, 2, 3], 5, 1)\n    >>> insertBeforeList([1, 2, 3], 4, 2)\n    >>> insertBeforeList([1, 2, 3], 4, 3)\n    >>> insertBeforeList([1, 2, 3], 4, 4)\n    >>> insertBeforeList([1, 2, 3], 4, 5)\n    >>> insertBeforeList([1, 2, 3], 4, 6)\n    \"\"\"\n    if index < 0 or index > len(alist):\n        raise ValueError(\"Index must be between 0 and len(alist)\")\n    while index < len(alist):\n        alist[index] = item\n        index += 1",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        # write your code here\n        p = head\n        while p:\n            q = p\n            p = p.next\n            q.next = ListNode(val)\n            q.next.next = p\n            q.next = q\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    p = head\n    for i in range(3):\n        p.next = ListNode(i)\n        p = p.next\n    p = head\n    for i in range(3):\n        p.next = ListNode(i)\n        p = p.next\n    s = Solution()\n    head = s.insertBefore(head, 3)\n    while head:\n        print(head.val, end=\" \")\n        head = head.next",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        curr = head\n        while curr.next:\n            prev = curr\n            curr = curr.next\n            while curr and curr.val < prev.val:\n                prev = prev.next\n                curr = curr.next\n            prev.next = curr\n            curr = prev\n        return head\n\na = ListNode(4)\na.next = ListNode(1)\na.next.next = ListNode(2)\na.next.next.next = ListNode(3)\n\ns = Solution()\nhead = s.insertionSortList(a)\nwhile head:\n    print(head.val, end=\" \")\n    head = head.next",
    "class Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        if head.val < head.next.val:\n            head.next.val = self.insert(head, head.val)\n        else:\n            head.next.val = self.insert(head.next, head.val)\n        return self.insertionSortList(head.next)\n\n    def insert(self, head, val):\n        newHead = ListNode(val)\n        if head is None:\n            return newHead\n        newHead.next = head\n        return self.insert(newHead.next, val)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None",
    "#!/usr/bin/env python\n\nclass Solution:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a new list\n    def insertBefore(self, head, val):\n        head_new = Node(val)\n        head_new.next = head\n        while head.next:\n            head = head.next\n            head_new.next = head.next\n            head.next = head_new\n        return head_new.next\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef print_list(head):\n    while head:\n        print head.val\n        head = head.next\n\ndef main():\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    print head\n    print_list(head.next.next.next.next)\n    print Solution().insertBefore(head, 6)\n    print_list(head.next.next.next.next)\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        # traverse the list\n        pre, curr = head, head.next\n        while curr:\n            # insert element before current element\n            pre = self.insertBefore(pre, curr.val)\n            # insert current element to the end of the list\n            curr = curr.next\n        return head\n        \n    def insertBefore(self, pre, val):\n        curr = pre\n        while curr.next and curr.next.val < val:\n            pre = curr\n            curr = curr.next\n        if curr.val == val:\n            curr.next = self.insertBefore(curr, val)\n        return pre",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode.next = head\n        while head and head.next:\n            head = head.next\n        head.next = newNode\n        return newNode\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    print s.insertBefore(head, ListNode(6))\n    print head.next\n    print head.next.next\n    print head.next.next.next\n    print head.next.next.next.next",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        newNode.next = head\n        newNode.next = head.next\n        head.next = newNode\n        \n        return newNode",
    "#!/usr/bin/python\n\nclass Solution:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a list node\n    def insertBefore(self, head, val):\n        curr = head\n        while curr.next:\n            curr = curr.next\n        newNode = Node(val)\n        newNode.next = head\n        head = newNode\n        return head\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution2:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a list node\n    def insertBefore(self, head, val):\n        curr = head\n        while curr.next:\n            curr = curr.next\n        newNode = Node(val)\n        newNode.next = head\n        head = newNode\n        return head\n\nclass Solution3:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a list node\n    def insertBefore(self, head, val):\n        curr = head\n        while curr.next:\n            curr = curr.next\n        newNode = Node(val)\n        newNode.next = curr\n        return newNode\n\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head.next.next.next.next.next = Node(6)\n    head.next.next.next.next.next.next = Node(7)\n    head.next.next.next.next.next.next.next = Node(8)\n    head.next.next.next.next.next.next.next.next = Node(9)\n    head.next.next.next.next.next.next.next.next.next = Node(10)\n    print",
    "def insert_before(list, element, index=0):\n    \"\"\"\n    :type list: List[str]\n    :type element: str\n    :type index: int\n    :rtype: List[str]\n    \"\"\"\n    for i in range(index, len(list)):\n        list[i] = list[i-1] + list[i]\n    list[index-1] = element\n    return list\n\n# https://www.hackerrank.com/challenges/insert-an-element-before-a-given-index/problem",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if not head:\n            return head\n\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        new_node = ListNode(val)\n        new_node.next = fast\n        if slow:\n            slow.next = new_node\n        else:\n            head = new_node\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\n    head.next.next.next.next.",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        newNode.next = head\n        while head.next:\n            head = head.next\n        head.next = newNode\n        return head\n\nif __name__ == '__main__':\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    print(sol.insertBefore(head, ListNode(9)))\n    print(sol.insertBefore(head, ListNode(10)))\n    print(sol.insertBefore(head, ListNode(11)))",
    "class Solution(object):\n    def insertionSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            j = i\n            while j > 0 and nums[j-1] > nums[j]:\n                nums[j] = nums[j-1]\n                j -= 1\n            nums[j] = nums[j]",
    "# https://www.hackerrank.com/challenges/insert-before-each-element\n\ndef insert_before(lst, x, before):\n    \"\"\"\n    :type lst: List[int]\n    :type x: int\n    :type before: int\n    :rtype: List[int]\n    \"\"\"\n\n    # Insert before the first element\n    if before == 1:\n        lst.insert(0, x)\n        return lst\n\n    # Insert at the given index\n    for i, e in enumerate(lst):\n        if e == before:\n            lst.insert(i, x)\n            return lst\n\n    # Insert at the end\n    lst.insert(len(lst), x)\n    return lst\n\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 3, 4]\n    print(insert_before(lst, 5, 1))\n    print(insert_before(lst, 5, 2))\n    print(insert_before(lst, 5, 3))\n    print(insert_before(lst, 5, 4))\n    print(insert_before(lst, 5, 5))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        if self is None:\n            return \"None\"\n        else:\n            return str(self.val)\n\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        cur = head\n        while cur.next is not None:\n            pre = cur\n            cur = cur.next\n            while cur is not None and cur.val < cur.next.val:\n                cur = cur.next\n            if cur is None:\n                cur = pre\n                cur.next = head\n            else:\n                cur.next = cur.next\n                pre.next = cur\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(3)\n    head.next = ListNode(9)\n    head.next.next = ListNode(20)\n    head.next.next.next = ListNode(15)\n    head.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next.next.next = ListNode(1)\n    head.next.next.next.next.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\n    head.next.next.next.next.next.next.next.next.next.next.",
    "class Solution:\n    # @param {ListNode} head\n    # @param {ListNode} node\n    # @return {ListNode}\n    def insertBefore(self, head, node):\n        dummy = ListNode(0)\n        dummy.next = head\n        cur = dummy\n        while cur.next:\n            cur = cur.next\n        cur.next = node\n        return dummy.next\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    cur = head\n    for i in range(1, 5):\n        cur.next = ListNode(i)\n        cur = cur.next\n    Solution().insertBefore(head, ListNode(3))\n    while head:\n        print(head.val)\n        head = head.next",
    "def insert_before_each_element(list, element, index):\n    \"\"\"\n    Write a function to insert an element before each element of a list.\n\n    >>> insert_before_each_element(['A','B','C'], 'D', 0)\n    ['A', 'D', 'B', 'C']\n    >>> insert_before_each_element(['A','B','C'], 'D', 2)\n    ['A', 'D', 'B', 'C']\n    >>> insert_before_each_element(['A','B','C'], 'D', 3)\n    ['A', 'D', 'D', 'B', 'C']\n    >>> insert_before_each_element(['A','B','C'], 'D', -1)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -2)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -3)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -4)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -5)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -6)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -7)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -8)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_element(['A','B','C'], 'D', -9)\n    ['A', 'B', 'C', 'D']\n    >>> insert_before_each_",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport random\nimport unittest\n\n\ndef insertion_sort(nums):\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] > key:\n            nums[j + 1] = nums[j]\n            j -= 1\n        nums[j + 1] = key\n\n\nclass TestCases(unittest.TestCase):\n    def test_insertion_sort(self):\n        nums = [4, 2, 8, 1, 7, 5]\n        insertion_sort(nums)\n        self.assertEqual(nums, [1, 2, 4, 8, 7, 5])\n\n    def test_insertion_sort_empty_list(self):\n        nums = []\n        insertion_sort(nums)\n        self.assertEqual(nums, [])\n\n    def test_insertion_sort_list_with_one_element(self):\n        nums = [4]\n        insertion_sort(nums)\n        self.assertEqual(nums, [4])\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @param val, an integer\n    # @return a list node\n    def insertBefore(self, head, val):\n        if not head:\n            return ListNode(val)\n        elif head.next:\n            new_head = self.insertBefore(head.next, val)\n            new_head.next = head\n            return new_head\n        else:\n            return head\n\n    # def insertBefore(self, head, val):\n    #     if not head:\n    #         return ListNode(val)\n    #     elif not head.next:\n    #         return head.next = ListNode(val)\n    #     else:\n    #         new_head = ListNode(val)\n    #         new_head.next = head\n    #         return new_head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        if head.next is None:\n            head.next = newNode\n        else:\n            pre = head\n            while pre.next:\n                pre = pre.next\n            pre.next = newNode\n\n        return head\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n\n    l1 = ListNode(1)\n    l2 = ListNode(2)\n    l3 = ListNode(3)\n    l4 = ListNode(4)\n    l5 = ListNode(5)\n    l6 = ListNode(6)\n    l7 = ListNode(7)\n    l8 = ListNode(8)\n    l9 = ListNode(9)\n    l10 = ListNode(10)\n    l11 = ListNode(11)\n    l12 = ListNode(12)\n    l13 = ListNode(13)\n    l14 = ListNode(14)\n    l15 = ListNode(15)\n    l16 = ListNode(16)\n    l17 = ListNode(17)\n    l18 = ListNode(18)\n    l19 = ListNode(19)\n    l20 = ListNode(20)\n    l21 = ListNode(21)\n    l22 = ListNode(22)\n    l23 = ListNode(23)\n    l24 = ListNode(24)\n    l25 = ListNode(25)\n    l26 = ListNode(26)\n    l27 = ListNode(27)\n    l28 = ListNode(28)\n    l29 = ListNode(29)\n    l30 = ListNode(30)\n    l31 = ListNode(31)\n    l32 = ListNode(32)\n    l33 = ListNode(33)\n    l34 = List",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a list node\n\t# @return a list node\n\tdef insertBefore(self, head, node):\n\t\tif head == None or head.next == None:\n\t\t\thead.next = node\n\t\t\treturn head\n\t\tcur = head\n\t\twhile cur.next:\n\t\t\tcur = cur.next\n\t\tcur.next = node\n\t\treturn head\n\n\nif __name__ == \"__main__\":\n\ts = Solution()\n\tprint(s.insertBefore(ListNode(1), ListNode(2)))\n\tprint(s.insertBefore(ListNode(1), ListNode(3)))\n\tprint(s.insertBefore(ListNode(1), ListNode(4)))\n\tprint(s.insertBefore(ListNode(1), ListNode(5)))\n\tprint(s.insertBefore(ListNode(1), ListNode(6)))\n\tprint(s.insertBefore(ListNode(1), ListNode(7)))\n\tprint(s.insertBefore(ListNode(1), ListNode(8)))\n\tprint(s.insertBefore(ListNode(1), ListNode(9)))\n\tprint(s.insertBefore(ListNode(1), ListNode(10)))\n\tprint(s.insertBefore(ListNode(1), ListNode(11)))\n\tprint(s.insertBefore(ListNode(1), ListNode(12)))\n\tprint(s.insertBefore(ListNode(1), ListNode(13)))\n\tprint(s.insertBefore(ListNode(1), ListNode(14)))",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        slow.next = head\n        return slow.next",
    "# https://leetcode.com/problems/insert-element-before-each-element-of-a-sorted-list/discuss/446852/Java-Solution-with-O(N)-Time-and-O(1)-Space\nclass Solution(object):\n    def insertBeforeEach(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while pre.next:\n            pre = pre.next\n            while pre.next and pre.next.val <= newNode.val:\n                pre = pre.next\n            if pre.next:\n                pre.next = newNode\n                newNode.next = pre.next\n            else:\n                pre.next = newNode\n                newNode.next = None\n        return dummy.next",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            newNode.next = head\n            return newNode\n        pre = head\n        while pre.next:\n            pre = pre.next\n        newNode.next = pre.next\n        pre.next = newNode\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        cur = head\n        while cur.next:\n            pre = cur\n            cur = cur.next\n            while cur and cur.val < cur.next.val:\n                pre = cur\n                cur = cur.next\n            if pre == cur:\n                cur.next = head\n                head = head.next\n            else:\n                pre.next = cur.next\n                cur.next = head\n                head = cur\n        return head\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(0)\n    head.next = ListNode(2)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(4)\n    head.next.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next.next = ListNode(7)\n    print(sol.insertionSortList(head))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return newNode\n        newNode.next = head\n        while head.next:\n            head = head.next\n        head.next = newNode\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    Solution().insertBefore(head, ListNode(10))\n    while head:\n        print(head.val, end=\"\")\n        head = head.next\n    print()",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertBefore(self, head, insert_node):\n        \"\"\"\n        :type head: ListNode\n        :type insert_node: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return insert_node\n        if head.next == None:\n            head.next = insert_node\n            return head\n        pre = head\n        while pre.next.next:\n            pre = pre.next\n        pre.next = insert_node\n        return head",
    "# https://www.hackerrank.com/challenges/insert-before-each-element\n# https://www.hackerrank.com/challenges/insert-before-each-element-in-the-middle\n# https://www.hackerrank.com/challenges/insert-before-each-element-in-the-middle-2\n\n\ndef insert_before_each_element(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    for index, elem in enumerate(arr):\n        arr[index] = arr[index] + 1\n        arr.insert(index, elem)\n    return arr\n\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(insert_before_each_element(arr))\n\n\nif __name__ == '__main__':\n    main()",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if head is None:\n            return ListNode(val)\n        pre = None\n        cur = head\n        while cur is not None:\n            pre = cur\n            cur = cur.next\n        if pre is None:\n            return ListNode(val)\n        pre.next = ListNode(val)\n        pre.next.next = head\n        return pre.next\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    print(s.insertBefore(head, 1))",
    "class Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return newNode\n        while head.next:\n            head = head.next\n        newNode.next = head\n        newNode.prev = None\n        head.next = newNode\n        return head\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.insertBefore([1,2,3], [4,5,6])",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def insertionSortList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(1, len(nums)):\n            # insert the first element\n            nums[i] = nums[i]\n            for j in range(i):\n                if nums[i] < nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n                    break\n\n    def insertionSortList2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(1, len(nums)):\n            # insert the first element\n            nums[i] = nums[i]\n            for j in range(i):\n                if nums[i] < nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n                    break",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        cur = head\n        while cur.next:\n            pre = cur\n            cur = cur.next\n            while pre and cur.val < pre.val:\n                pre = pre.next\n            if pre:\n                pre.next = cur\n            else:\n                head = cur\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        O(n) time, O(1) space\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        \n        slow = head\n        fast = head.next\n        while fast is not None and fast.val < slow.val:\n            slow = slow.next\n            fast = fast.next\n        if fast is None:\n            return head\n        \n        # insert new node\n        new_node = ListNode(fast.val)\n        fast.next = new_node\n        \n        # continue insertion sort\n        slow = head\n        while slow.next is not None:\n            if slow.val > fast.val:\n                slow = slow.next\n            else:\n                fast = fast.next\n                slow = slow.next\n        \n        # reverse the list\n        slow = head\n        fast = new_node\n        while slow.next is not None and fast.val < slow.val:\n            slow = slow.next\n            fast = fast.next\n        \n        slow.next = None\n        return head",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @param val, an integer\n    # @return a list node\n    def insertBefore(self, head, val):\n        if not head:\n            return ListNode(val)\n        new_head = ListNode(val)\n        new_head.next = head\n        while head.next:\n            head = head.next\n        head.next = new_head\n        return new_head",
    "def insertBefore(list, value, before):\n    \"\"\"\n    :type list: List[int]\n    :type value: int\n    :type before: int\n    :rtype: List[int]\n    \"\"\"\n    return [value] + list[:before] + [value] + list[before:]",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return head\n        pre = None\n        while head:\n            cur = head\n            pre = head\n            head = head.next\n            while pre and cur.val < pre.val:\n                pre = pre.next\n            if pre:\n                pre.next = cur\n                cur = cur.next\n            else:\n                head = cur\n        return head\n\n# Note:\n#  1. \u6ce8\u610f\u662f\u5426\u8981\u6539\u6210\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u627e\u5230pre\uff0c\u7136\u540e\u627e\u5230cur\uff0c\u7136\u540epre.next = cur",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"None\"\n        return repr(self.val)\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        if head is None:\n            return ListNode(val)\n        if head.next is None:\n            return ListNode(val, head)\n        slow = head\n        fast = head.next\n        while fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        return ListNode(val, slow.next)\n\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertAfter(self, head, val):\n        if head is None:\n            return ListNode(val)\n        if head.next is None:\n            return ListNode(val, head)\n        slow = head\n        fast = head.next\n        while fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        return ListNode(val, slow)\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    Solution().insertBefore(head, 6)\n    print(head.val)\n    print(head.next.val)\n    print(head.next.next.val)\n    print(head.next.next.next.val)\n    print(head.next.next.next.next.val)",
    "class Solution:\n    # @param head, a list node\n    # @param val, a value to be inserted\n    # @return a new list\n    def insertBefore(self, head, val):\n        \n        if head is None:\n            return head\n        \n        newHead = Node(val)\n        newHead.next = head\n        \n        while head.next:\n            head = head.next\n            \n        head.next = newHead\n        \n        return newHead.next",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param val, an integer\n\t# @return a ListNode\n\tdef insertBefore(self, head, val):\n\t\tif not head:\n\t\t\treturn ListNode(val)\n\t\tnew_node = ListNode(val)\n\t\tnew_node.next = head\n\t\twhile head.next:\n\t\t\thead = head.next\n\t\thead.next = new_node\n\t\treturn head\n\nif __name__ == \"__main__\":\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\thead.next.next.next.next.next.next = ListNode(7)\n\thead.next.next.next.next.next.next.next = ListNode(8)\n\thead.next.next.next.next.next.next.next.next = ListNode(9)\n\thead.next.next.next.next.next.next.next.next.next = ListNode(10)\n\n\tsolution = Solution()\n\tprint solution.insertBefore(head, 10)",
    "class Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode.next = head\n        while head.next is not None:\n            head = head.next\n        head.next = newNode\n        return newNode\n\n\nif __name__ == \"__main__\":\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(3)\n    node4 = ListNode(4)\n    node5 = ListNode(5)\n    node6 = ListNode(6)\n    node7 = ListNode(7)\n    node8 = ListNode(8)\n    node9 = ListNode(9)\n    node10 = ListNode(10)\n    node11 = ListNode(11)\n    node12 = ListNode(12)\n    node13 = ListNode(13)\n    node14 = ListNode(14)\n    node15 = ListNode(15)\n    node16 = ListNode(16)\n    node17 = ListNode(17)\n    node18 = ListNode(18)\n    node19 = ListNode(19)\n    node20 = ListNode(20)\n    node21 = ListNode(21)\n    node22 = ListNode(22)\n    node23 = ListNode(23)\n    node24 = ListNode(24)\n    node25 = ListNode(25)\n    node26 = ListNode(26)\n    node27 = ListNode(27)\n    node28 = ListNode(28)\n    node29 = ListNode(29)\n    node30 = ListNode(30)\n    node31 = ListNode(31)\n    node32 = ListNode(32)\n    node33 = ListNode(33)\n    node34 = ListNode(34)\n    node35 = ListNode(35)\n    node36 = ListNode(36)\n    node37 = ListNode(37)\n    node38 = ListNode(38)\n    node39 = ListNode(39)\n    node40 = ListNode(40)\n    node41 = ListNode(41)",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return newNode\n        newNode.next = head\n        p = head\n        while p.next is not None:\n            p = p.next\n        p.next = newNode\n        return head",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        while p is not None:\n            q = p.next\n            p.next = newNode\n            newNode.next = q\n            p = q\n        return head\n\n# Note:\n# Use two pointers to simulate two loops.",
    "class Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur:\n            next = cur.next\n            while cur and cur.val < next.val:\n                cur = cur.next\n            cur.next = next\n            cur = next\n        return head\n\n\nif __name__ == \"__main__\":\n    p1 = ListNode(1)\n    p2 = ListNode(2)\n    p3 = ListNode(3)\n    p4 = ListNode(4)\n    p5 = ListNode(5)\n    p6 = ListNode(6)\n    p1.next = p2\n    p2.next = p3\n    p3.next = p4\n    p4.next = p5\n    p5.next = p6\n    s = Solution()\n    s.insertionSortList(p1)\n    while p1:\n        print p1.val\n        p1 = p1.next",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def insertBefore(self, head, val):\n        \"\"\"\n        head --> the new node\n        val --> the element to insert\n        \"\"\"\n        if head is None:\n            return val\n        new_head = Node(val)\n        new_head.next = head\n        new_head.prev = None\n        head.prev = new_head\n        return head\n\n\nclass Node(object):\n    def __init__(self, val):\n        \"\"\"\n        val --> the element to insert\n        \"\"\"\n        self.val = val\n        self.next = None\n        self.prev = None\n\n\ndef main():\n    s = Solution()\n\n    head = None\n    for i in xrange(5):\n        new_head = s.insertBefore(head, i)\n        head = new_head\n\n    for e in head:\n        print e.val\n\n\nif __name__ == \"__main__\":\n    main()",
    "def insert_before(lst, elem, index=0):\n    \"\"\"\n    >>> insert_before([1,2,3,4], 2)\n    [1, 2, 2, 3, 4]\n    >>> insert_before([1,2,3,4], 4)\n    [1, 2, 3, 4, 2]\n    >>> insert_before([1,2,3,4], 5)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    if index >= len(lst):\n        lst.append(elem)\n    else:\n        for i in range(index, len(lst)):\n            lst[i] = lst[i-1]\n        lst[index] = elem\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "class Solution(object):\n    def insertionSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: None Do not return anything, modify arr in-place instead.\n        \"\"\"\n        if len(arr) == 0:\n            return\n\n        for i in range(1, len(arr)):\n            j = i - 1\n            while j >= 0 and arr[j] > arr[j + 1]:\n                arr[j + 1] = arr[j]\n                j -= 1\n\n        arr[0] = arr[0]\n\n\nif __name__ == '__main__':\n    arr = [4, 5, 6, 7, 0, 1, 2]\n    print arr\n    Solution().insertionSort(arr)\n    print arr",
    "# https://www.youtube.com/watch?v=2_JbV-JUxRc\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        \n        slow, fast = head, head\n        \n        while fast and fast.next:\n            if fast.val < slow.val:\n                slow = slow.next\n            else:\n                fast = fast.next\n                slow = slow.next\n        \n        slow.next = head\n        \n        return slow",
    "class Solution:\n    # @param head, a list node\n    # @param val, an integer\n    # @return a list node\n    def insertBefore(self, head, val):\n        # write your code here\n        if not head:\n            return head\n        new_node = Node(val)\n        new_node.next = head\n        old_node = head\n        while old_node.next:\n            old_node = old_node.next\n        old_node.next = new_node\n        return head\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.insertBefore(head,val)",
    "class Solution(object):\n    def insertion_sort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: None\n        \"\"\"\n        if not A: return\n\n        for i in range(1, len(A)):\n            j = i\n            while j > 0 and A[j-1] > A[j]:\n                A[j], A[j-1] = A[j-1], A[j]\n                j -= 1\n                if j == 0: break\n\n        return",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def insertBefore(self, head, val):\n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        while curr is not None:\n            if curr.val == val:\n                break\n            curr = curr.next\n        if curr is None:\n            return dummy.next\n        pre = dummy\n        while curr is not None:\n            pre = pre.next\n            curr = curr.next\n        pre.next = curr\n        curr.next = head\n        return dummy.next",
    "def insert(list, element, index):\n    \"\"\"\n    :type list: List[int]\n    :type element: int\n    :type index: int\n    :rtype: List[int]\n    \"\"\"\n    for i in range(index):\n        list.insert(i, 0)\n    list.insert(index, element)\n    return list\n\n\n\n# Your Solution\n\n# In[ ]:\n\n# @param {List[int]} list\n# @param {int} element\n# @param {int} index\n# @return {List[int]}\ndef insert(list, element, index):\n    \"\"\"\n    :type list: List[int]\n    :type element: int\n    :type index: int\n    :rtype: List[int]\n    \"\"\"\n    for i in range(index):\n        list.insert(i, 0)\n    list.insert(index, element)\n    return list\n\n\n# In[ ]:\n\n# @param {List[int]} list\n# @param {int} element\n# @param {int} index\n# @return {List[int]}\ndef insert(list, element, index):\n    \"\"\"\n    :type list: List[int]\n    :type element: int\n    :type index: int\n    :rtype: List[int]\n    \"\"\"\n    for i in range(index):\n        list.insert(i, 0)\n    list.insert(index, element)\n    return list\n\n\n\n# In[ ]:\n\n# @param {List[int]} list\n# @param {int} element\n# @param {int} index\n# @return {List[int]}\ndef insert(list, element, index):\n    \"\"\"\n    :type list: List[int]\n    :type element: int\n    :type index: int\n    :rtype: List[int]\n    \"\"\"\n    for i in range(index):\n        list.insert(i, 0)\n    list.insert(index, element)\n    return list\n\n\n# In[ ]:\n\n# @param {List[int]} list\n# @param {int} element\n# @param {int} index\n# @return {List[int]}",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode.next = head\n        cur = head\n        while cur.next:\n            cur = cur.next\n        cur.next = newNode\n        return head\n\nclass Solution2:\n    def insertBefore(self, head, newNode):\n        \"\"\"\n        :type head: ListNode\n        :type newNode: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newNode.next = head\n        cur = head\n        while cur.next:\n            cur = cur.next\n        cur.next = newNode\n        return head",
    "class Solution(object):\n    def insertion_sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            j = i\n            while j > 0 and nums[j-1] > nums[j]:\n                nums[j-1], nums[j] = nums[j], nums[j-1]\n                j -= 1\n        return\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5]\n    Solution().insertion_sort(nums)\n    print(nums)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = self.insert(slow, fast.next)\n            fast = fast.next.next\n        return slow\n    \n    def insert(self, head, node):\n        slow = head\n        fast = head\n        while fast and fast.next:\n            if fast.next.val < node.val:\n                slow = self.insert(slow, fast.next)\n            fast = fast.next\n        slow.next = node\n        return slow",
    "# Your Solution\n# First, create a function insert(list, index, element):\n#  insert(list, index, element):\n#  Inserts element before the element at index.\n#  If index is equal to the length of list, append to the end of list.\n#  If index is negative, set index to index + list.length, then insert at the front of list.\n#  If index is greater than the length of list, raise a ValueError.\n\ndef insert(list, index, element):\n    if index == len(list):\n        list.append(element)\n    elif index < 0:\n        list.insert(0, element)\n    elif index >= len(list):\n        raise ValueError(\"Index is greater than list length\")\n    else:\n        list[index] = element",
    "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        curr = head\n        pre = head\n        while curr.next:\n            pre = curr\n            curr = curr.next\n        curr.next = head\n        pre.next = None\n        return head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertBefore(self, head, insert_node, insert_index):\n        if not head or not insert_index:\n            return head\n        if head.val < insert_node.val:\n            head, tail = self.insertBefore(head.next, insert_node, insert_index)\n        else:\n            head = self.insertBefore(head, insert_node, insert_index - 1)\n        return head\n\ndef test(head, insert_node, insert_index):\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    print(head)\n    print(insert_node.val)\n    print(insert_index)\n    Solution().insertBefore(head, insert_node, insert_index)\n    print(head)\n\nif __name__ == \"__main__\":\n    test(None, ListNode(2), 0)\n    test(None, ListNode(1), 1)\n    test(None, ListNode(2), 1)\n    test(None, ListNode(3), 1)\n    test(None, ListNode(4), 1)\n    test(None, ListNode(5), 1)\n    test(None, ListNode(6), 1)\n    test(None, ListNode(1), 2)\n    test(None, ListNode(2), 2)\n    test(None, ListNode(3), 2)\n    test(None, ListNode(4), 2)\n    test(None, ListNode(5), 2)\n    test(None, ListNode(6), 2)\n    test(None, ListNode(1), 3)\n    test(None, ListNode(2), 3)\n    test(None, ListNode(3), 3)\n    test",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return head\n        if head.next is None:\n            return head\n        prev = None\n        cur = head\n        while cur is not None:\n            next = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next\n        prev.next = head\n        return prev",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n        else:\n            return \"{}\"\n\n\nclass Solution:\n    def insertBefore(self, head: ListNode, x: int) -> ListNode:\n        if not head:\n            return ListNode(x)\n        if head.next is None:\n            return ListNode(x, head)\n        new_head = ListNode(x)\n        new_head.next = head\n        while head.next:\n            head = head.next\n        head.next = new_head\n        return new_head",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        curr = head\n        while curr.next:\n            prev = curr\n            curr = curr.next\n            while curr and curr.val < prev.val:\n                prev = prev.next\n                curr = curr.next\n            prev.next = curr\n            curr = prev\n        return head"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}