{
  "problem": {
    "task_id": "MBPP/291",
    "prompt": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
    "canonical_solution": "def count_no_of_ways(n, k): \r\n\tdp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]",
    "test_list": [
      "assert count_no_of_ways(2, 4) == 16",
      "assert count_no_of_ways(3, 2) == 6",
      "assert count_no_of_ways(4, 4) == 228"
    ],
    "challenge_test_list": [],
    "problem_id": 280
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # DFS solution.\n        # return self.numWaysDFS(n, k)\n        # BFS solution.\n        return self.numWaysBFS(n, k)\n\n    def numWaysDFS(self, n, k):\n        # Base cases.\n        if n == 1:\n            return 1\n        if n == k:\n            return 2\n\n        # Recursion base case.\n        if k == 1:\n            return n\n        if n % k == 0:\n            return self.numWaysDFS(n // k, k) + self.numWaysDFS(n // k + 1, k)\n\n        # Recursion base case.\n        return self.numWaysDFS(n - 1, k) + self.numWaysDFS(n - 1, k - 1)\n\n    def numWaysBFS(self, n, k):\n        # Base cases.\n        if n == 1:\n            return 1\n        if n == k:\n            return 2\n\n        # Recursion base case.\n        if k == 1:\n            return n\n        if n % k == 0:\n            return self.numWaysBFS(n // k, k) + self.numWaysBFS(n // k + 1, k)\n\n        # Recursion base case.\n        return self.numWaysBFS(n - 1, k) + self.numWaysBFS(n - 1, k - 1)",
    "# https://leetcode.com/problems/paint-fence/discuss/3726/Java-Solution-with-O(n!)-time-and-O(k!)-space\n\nclass Solution:\n    def numWays(self, n, k, color):\n        # base cases\n        if n == 0 or k == 0 or color == 0:\n            return 0\n        if n == 1:\n            return k\n        if color == 1:\n            return n * (n-1) / 2\n        if color == 2:\n            return n * (n-1) / 2 * (n-2)\n        if color == 3:\n            return n * (n-1) / 2 * (n-2) * (n-3)\n        if color == 4:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4)\n        if color == 5:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4) * (n-5)\n        if color == 6:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4) * (n-5) * (n-6)\n        if color == 7:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4) * (n-5) * (n-6) * (n-7)\n        if color == 8:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4) * (n-5) * (n-6) * (n-7) * (n-8)\n        if color == 9:\n            return n * (n-1) / 2 * (n-2) * (n-3) * (n-4) * (n-5) * (n-6) * (n-7) * (n-8) * (n-9)\n        return self.numWays(n-1, k-1, color-1) + self.",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) // 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) // 6\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, k + 1):\n            dp[i] = dp[i - 1]\n            for j in range(1, i):\n                dp[i] += dp[j - 1] * (n - i + j)\n        return dp[-1]\n\nprint(Solution().numWays(4, 2))",
    "class Solution(object):\n    def numWays(self, n, k, colors):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return 1 if n >= 2 else 0\n        if k == 2:\n            return self.numWays2(n, colors)\n        if k == 3:\n            return self.numWays3(n, colors)\n        return self.numWays4(n, k, colors)\n\n    def numWays2(self, n, colors):\n        \"\"\"\n        :type n: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1 if colors[0] == colors[1] else 0\n        if n == 2:\n            return self.numWays2(1, colors) + self.numWays2(2, colors)\n        return self.numWays2(n - 1, colors) + self.numWays2(n - 2, colors)\n\n    def numWays3(self, n, colors):\n        \"\"\"\n        :type n: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1 if colors[0] == colors[1] and colors[0] == colors[2] else 0\n        if n == 2:\n            return self.numWays3(1, colors) + self.numWays3(2, colors)\n        return self.numWays3(n - 1, colors) + self.numWays3(n - 2, colors)\n\n    def numWays4(self, n, k, colors):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1 if colors[0] == colors[1] and colors[0] == colors[2] and colors[0] == colors[3] else 0\n        if k == 1:\n            return self.numW",
    "class Solution(object):\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == 1:\n            return (n == 1 and fence[0] == fence[1]) or (n == 2 and fence[0] == fence[2]) or (n == 3 and fence[0] == fence[3]) or (n == 4 and fence[0] == fence[4]) or (n == 5 and fence[0] == fence[5]) or (n == 6 and fence[0] == fence[6]) or (n == 7 and fence[0] == fence[7]) or (n == 8 and fence[0] == fence[8]) or (n == 9 and fence[0] == fence[9]) or (n == 10 and fence[0] == fence[10]) or (n == 11 and fence[0] == fence[11]) or (n == 12 and fence[0] == fence[12]) or (n == 13 and fence[0] == fence[13]) or (n == 14 and fence[0] == fence[14]) or (n == 15 and fence[0] == fence[15]) or (n == 16 and fence[0] == fence[16]) or (n == 17 and fence[0] == fence[17]) or (n == 18 and fence[0] == fence[18]) or (n == 19 and fence[0] == fence[19]) or (n == 20 and fence[0] == fence[20]) or (n == 21 and fence[0] == fence[21]) or (n == 22 and fence[0] == fence[22]) or (n == 23 and fence[0] == fence[23]) or (n == 24 and fence[0] == fence[24]) or (n == 25 and fence[0] == fence[25]) or (n == 26 and fence[0] == fence[26]) or (n == 27 and fence[0] == fence[27]) or (n == 28 and fence[0] == fence[28]) or (n == 29 and fence[0] == fence[29",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # This is a brute force solution.\n        # We can easily do it in O(n^k) time by using a hash table to store the results of each color.\n        # However, it is not a good idea to do this because it would be too slow.\n        # The better solution is to use the brute force approach.\n        # We can solve this problem in O(nk) time.\n        # We can also do this in O(n^k) time, but we need to do a lot of unnecessary work to generate the result.\n        # We can also do this in O(n^k) time, but we need to do a lot of unnecessary work to generate the result.\n        # The solution is to use a hash table to store the results.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in O(n^k) time.\n        # We can do this in",
    "class Solution:\n    def totalPaintings(self, n: int, k: int) -> int:\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 12\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 20\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) / 30\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) / 40",
    "# https://www.hackerrank.com/challenges/fence-paint/problem\n\nimport math\n\ndef num_ways(n, k):\n    ways = 0\n    for i in range(1, n):\n        if (i % k) == 0:\n            ways += 1\n    return ways\n\nprint(num_ways(5, 2))",
    "# Example 1\n# n = 3, k = 2\n# Output: 6\n# Example 2\n# n = 4, k = 3\n# Output: 10\n# Example 3\n# n = 7, k = 3\n# Output: 24\n\n# Time complexity: O(nk)\n# Space complexity: O(k)\n\n# # Definition for a point.\n# class Point(object):\n#     def __init__(self, a=0, b=0):\n#         self.x = a\n#         self.y = b\n\n# class Solution(object):\n#     def numWays(self, n, k):\n#         \"\"\"\n#         :type n: int\n#         :type k: int\n#         :rtype: int\n#         \"\"\"\n#         if k == 0:\n#             return 1\n#         if n < k:\n#             return 0\n#         if k == 1:\n#             return 1\n#         if k == 2:\n#             return 4\n#         if k == 3:\n#             return 9\n#         if k == 4:\n#             return 24\n#         if k == 5:\n#             return 120\n#         if k == 6:\n#             return 720\n#         if k == 7:\n#             return 5040\n#         if k == 8:\n#             return 40320\n#         if k == 9:\n#             return 362880\n#         if k == 10:\n#             return 3628800\n#         if k == 11:\n#             return 39916800\n#         if k == 12:\n#             return 479001600\n#         if k == 13:\n#             return 6227020800\n#         if k == 14:\n#             return 87178291200\n#         if k == 15:\n#             return 1307674368000\n#         if k == 16:\n#             return 20922789888000\n#         if k == 17:\n#             return 355687428096000\n#         if k == 18:\n#             return 6402373705728000\n#         if k == 19:\n#             return 121645100408832000\n#         if k == 20:\n#             return 243290200817664",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        res = 0\n        if n == 0:\n            return 1\n        if k == 0:\n            return 0\n        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            for i in xrange(1, n):\n                res += i\n            return res\n        for i in xrange(1, n):\n            for j in xrange(1, k):\n                res += self.numWays(i, j) * self.numWays(i - 1, k - j)\n        return res\n\nif __name__ == '__main__':\n    sol = Solution()\n    n = 3\n    k = 2\n    print sol.numWays(n, k)",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if n < 2 or k < 2:\n            return 0\n        \n        # dp[i][j]: number of ways for i colors, j posts\n        dp = [[0 for i in range(k)] for j in range(n)]\n        \n        # dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j]\n        for i in range(1, n):\n            for j in range(1, k):\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        \n        return dp[n - 1][k - 1]",
    "from collections import defaultdict\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k < 2:\n            return 0\n        if n == 1:\n            return k\n\n        color = defaultdict(int)\n        for i in range(1, k + 1):\n            color[i] = 1\n        color[k] = 1\n\n        res = 0\n        for i in range(n - k + 1):\n            res += color[i] * self.numWays(n - k, k)\n        return res",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.numWays_rec(n, k, 0, [[0] * k for i in xrange(k)])\n\n    def numWays_rec(self, n, k, index, result):\n        if index == k:\n            return result[index]\n        elif index < k:\n            return self.numWays_rec(n, k, index + 1, result) + self.numWays_rec(n, k, index + 1, result)\n        elif index == 0:\n            return 1\n        else:\n            return result[index] + self.numWays_rec(n, k, index - 1, result)",
    "import sys\nsys.setrecursionlimit(10000)\n\n\n# https://www.codewars.com/kata/55f4b1f15f3e2f4f5d3a5d/train/python\n\ndef get_num_ways_to_paint_fence_with_color(n, k, fence):\n    # If the fence is empty, return 0.\n    if len(fence) == 0:\n        return 0\n\n    # If the fence has only 1 color, return 1.\n    if len(fence) == 1:\n        return 1\n\n    # If the fence has only 2 colors, return 2.\n    if len(fence) == 2:\n        return 2\n\n    # If the fence has only 3 colors, return 3.\n    if len(fence) == 3:\n        return 3\n\n    # If the fence has only 4 colors, return 4.\n    if len(fence) == 4:\n        return 4\n\n    # If the fence has only 5 colors, return 5.\n    if len(fence) == 5:\n        return 5\n\n    # If the fence has only 6 colors, return 6.\n    if len(fence) == 6:\n        return 6\n\n    # If the fence has only 7 colors, return 7.\n    if len(fence) == 7:\n        return 7\n\n    # If the fence has only 8 colors, return 8.\n    if len(fence) == 8:\n        return 8\n\n    # If the fence has more than 8 colors, return 9.\n    return 9\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n\n    fence = list(map(int, input().split()))\n\n    print(get_num_ways_to_paint_fence_with_color(n, k, fence))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ret = 0\n        if n < 3:\n            return 1\n        for i in range(1, n+1):\n            for j in range(1, i+1):\n                ret += self.numWays2(n, k, i, j)\n        return ret\n\n    def numWays2(self, n, k, i, j):\n        if i == j:\n            if i == n:\n                return 1\n            else:\n                return 0\n        elif i == 1:\n            return self.numWays2(n, k, n, j)\n        else:\n            return self.numWays2(n, k, i-1, j) + self.numWays2(n, k, i, j-1)\n\nif __name__ == \"__main__\":\n    assert Solution().numWays(4, 2) == 15",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        if n <= 1:\n            return 0\n        if n == 2:\n            return 2\n        for i in xrange(n-1, -1, -1):\n            res += self.numWays(n-i, k)\n        return res\n\nif __name__ == '__main__':\n    assert Solution().numWays(2, 2) == 2\n    assert Solution().numWays(3, 3) == 2\n    assert Solution().numWays(5, 5) == 8\n    assert Solution().numWays(5, 5) == 4\n    assert Solution().numWays(10, 5) == 16",
    "import math\n\n\ndef count_ways(n, k):\n    ways = [0] * (k + 1)\n    ways[0] = 1\n    for i in range(1, k + 1):\n        ways[i] = ways[i - 1] + ways[i - 1]\n    for i in range(2, n + 1):\n        ways[0] += ways[i - 1]\n    ways[n + 1] = 1\n    for i in range(1, k + 1):\n        ways[n + 1] += ways[n - i]\n    return ways[n + 1]\n\nif __name__ == '__main__':\n    print(count_ways(3, 2))",
    "__author__ = 'Daniel'\nimport sys\n\nclass Solution(object):\n    def paintFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.count(n, k)\n\n    def count(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return n\n        elif k == 2:\n            return (n * n - 1) / 2\n        else:\n            return self.count(n - 1, k - 1) + self.count(n - 1, k)\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    n = int(sys.argv[1])\n    k = int(sys.argv[2])\n    print solution.paintFence(n, k)",
    "# https://discuss.leetcode.com/topic/36981/java-o-n-easy-to-explain-o-n-dp-solution\n# https://leetcode.com/problems/painted-fence/\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k > n:\n            return 0\n\n        if k == 0:\n            return 1\n\n        if k == 1:\n            return n\n\n        if k == 2:\n            return n * (n - 1)\n\n        if k % 2 == 0:\n            return (self.numWays(n, k / 2) * (n - 1) + self.numWays(n - 1, k / 2))\n\n        return (self.numWays(n, k / 2) * (n - 1) + self.numWays(n - 1, k / 2) + self.numWays(n, k / 2 - 1))\n\n\nprint Solution().numWays(3, 2)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        if n < 2:\n            return 0\n        if k == 1:\n            return n\n        if n == k:\n            return 1\n        for i in xrange(1, n):\n            if k == 2:\n                res += (n - i) * (n - i - 1) / 2\n                continue\n            res += (n - i) * (n - i - 1)\n            res += (n - i) * (n - i - 1) / 2\n        return res\n\nif __name__ == '__main__':\n    print Solution().numWays(3, 2)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return (n - 1) * (n - 2) / 2\n        if k == 4:\n            return (n - 1) * (n - 2) * (n - 3) / 6\n        if k == 5:\n            return (n - 1) * (n - 2) * (n - 3) * (n - 4) / 24\n        if k == 6:\n            return (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) / 120\n        if k == 7:\n            return (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) / 720\n        return 0",
    "class Solution(object):\n    def totalNights(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < 2 or k < 2:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, n + 1):\n                dp[j][i] = dp[j - 1][i - 1] + dp[j - 1][i]\n        return dp[n][k]",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return k == 1 and 2 or k == 2 and 3\n        ans = 0\n        for i in xrange(1, n):\n            for j in xrange(i, n):\n                if i == j:\n                    continue\n                if (i, j) in [(1, 1), (1, 2), (2, 1), (2, 2)]:\n                    ans += 1\n        return ans",
    "import sys\nimport timeit\n\n\"\"\"\n    >>> sys.path.append('..')\n    >>> from problems.problem01 import *\n    >>> from problems.problem01 import *\n\"\"\"\n\n\ndef solution(n, k):\n    \"\"\"\n    :param n: int\n    :param k: int\n    :return: int\n    \"\"\"\n    return solve(n, k, lambda *_: 0)\n\n\ndef solve(n, k, f):\n    \"\"\"\n    :param n: int\n    :param k: int\n    :param f: function\n    :return: int\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return k\n    else:\n        return f(n - 2, k) + f(n - 1, k)\n\n\nif __name__ == '__main__':\n    t = timeit.Timer(\"solution(100, 5)\", \"from __main__ import solution\")\n    print(t.timeit(1))",
    "# Definition for a point.\n# class Point(object):\n#     def __init__(self, a=0, b=0):\n#         self.x = a\n#         self.y = b\n\nclass Solution(object):\n    def numWays(self, n, k, colors):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        # DFS\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n\n        if k > n:\n            return 0\n\n        # DP\n        dp = [0] * k\n        dp[0] = 1\n        for i in range(1, k):\n            dp[i] = dp[i - 1] + dp[i - 1] * (n - 1)\n\n        return dp[k - 1]",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if n == 1:\n            return k\n        if n == 2:\n            return k * (k - 1) / 2\n\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]\n        # [0, 0, 1, 0, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2]",
    "class Solution:\n    \"\"\"\n    @param n, k:\n    @return:\n    \"\"\"\n    def paintFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums = [0] * n\n        for i in range(n):\n            nums[i] = 1\n        nums[0] = k\n        for i in range(1, n):\n            nums[i] = nums[i-1] + 1\n        ans = 1\n        for i in range(n):\n            if nums[i]!= k:\n                ans *= (n-i)\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.paintFence(5, 3))",
    "def num_of_ways(n, k, colors):\n    # print(n, k, colors)\n    ways = 0\n    for i in range(k):\n        for j in range(k):\n            if i!= j:\n                if colors[i] == colors[j]:\n                    ways += 1\n    return ways\n\n# print(num_of_ways(5, 3, [1, 2, 3]))\nprint(num_of_ways(5, 3, [1, 2, 3]))",
    "def count_ways(n, k, colors):\n    if n == 1:\n        return 1\n    elif n == 2:\n        if colors == [0,0,0]:\n            return 2\n        else:\n            return 3\n    else:\n        if colors == [0,0,0]:\n            return count_ways(n - 1, k, [0,0,0]) + count_ways(n - 1, k, [0,0,0])\n        else:\n            return count_ways(n - 1, k, colors) + count_ways(n - 1, k, colors)\n\nprint count_ways(3, 3, [0,0,0])",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < 2:\n            return 0\n        if n == 2:\n            return k\n        if n == 3:\n            return k * (k - 1) // 2\n        if n == 4:\n            return k * (k - 1) // 2 + k * (k - 1) % 2\n        if n == 5:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3\n        if n == 6:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3 + k * (k - 1) % 4\n        if n == 7:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3 + k * (k - 1) % 4 + k * (k - 1) % 5\n        if n == 8:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3 + k * (k - 1) % 4 + k * (k - 1) % 5 + k * (k - 1) % 6\n        if n == 9:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3 + k * (k - 1) % 4 + k * (k - 1) % 5 + k * (k - 1) % 6 + k * (k - 1) % 7\n        if n == 10:\n            return k * (k - 1) // 2 + k * (k - 1) % 2 + k * (k - 1) % 3 + k * (k - 1) % 4 + k * (k - 1) % 5 + k * (k - 1) % 6 + k * (k - 1) % 7 + k * (k - 1) % 8\n        if n == 11:\n            return k *",
    "class Solution:\n    # @return an integer\n    def numWays(self, n, k):\n        return self.numWays_aux(n, k, 0, [0] * n)\n\n    def numWays_aux(self, n, k, color, res):\n        if n == 1:\n            return 1 if color == k else 0\n\n        if n == 2:\n            return 2 if color == k else 0\n\n        if color == k:\n            return 2\n\n        for i in xrange(2, n):\n            if color == k:\n                res[i] = self.numWays_aux(n - i, k, color, res) + self.numWays_aux(n - i, k - 1, color, res)\n            else:\n                res[i] = self.numWays_aux(n - i, k, color, res)\n\n        return res[n - 1]",
    "#!/bin/python3\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.num_ways(n, k, 0)\n\n    def num_ways(self, n, k, ways):\n        if n == 0:\n            return ways\n        if n == 1:\n            return (k == 0 and ways == 0) or (k > 0 and ways == 1) or (k < 0 and ways == 1)\n        if k == 0:\n            return ways + self.num_ways(n - 1, 0, ways)\n        if k == 1:\n            return ways + self.num_ways(n - 1, 1, ways)\n        if k > 1:\n            return ways + self.num_ways(n - 1, k - 1, ways)\n        if k < 1:\n            return ways + self.num_ways(n - 1, k + 1, ways)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.numWays(3, 2))\n    print(s.numWays(3, 3))\n    print(s.numWays(3, 4))\n    print(s.numWays(3, 5))\n    print(s.numWays(3, 6))",
    "class Solution(object):\n    def __init__(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        \"\"\"\n        self.n = n\n        self.k = k\n\n    def ways(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.ways_rec(self.k, self.n, [0]*self.k)\n\n    def ways_rec(self, k, n, res):\n        if k == 0:\n            return 1 if res[0] == 0 else 0\n        if k == 1:\n            return res[0]\n        if n == 1:\n            return sum(res)\n        if n == 2:\n            return sum(res) + sum(res[:k]) + sum(res[k:])\n        return self.ways_rec(k-1, n-1, res) + self.ways_rec(k, n-1, res + [res[k-1]]) + self.ways_rec(k, n-2, res + [res[k-1], res[k]])\n\n\nif __name__ == '__main__':\n    assert Solution().ways(3, 2) == 6\n    assert Solution().ways(3, 3) == 12\n    assert Solution().ways(3, 4) == 24\n    assert Solution().ways(3, 5) == 120",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        res = 0\n        if n == 1:\n            return 1\n        for i in range(2, n):\n            res += self.numWays(i, k)\n        if n % 2 == 1:\n            res += self.numWays(n - 1, k)\n        return res\n\ns = Solution()\nprint s.numWays(6, 3)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return n*(n-1)/2\n        if k == 3:\n            return n*(n-1)*(n-2)/6\n        if k == 4:\n            return n*(n-1)*(n-2)*(n-3)/24\n        if k == 5:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)/120\n        if k == 6:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)/720\n        if k == 7:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)/5040\n        if k == 8:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)/40320\n        if k == 9:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)/362880\n        if k == 10:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)/3628800\n        if k == 11:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)*(n-8)*(n-9)*(n-10)/39916800\n        if k == 12:\n            return n*(n-1)*(n-2)*(n-3)*(n-4",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.dfs(n, k, [0] * k, 0)\n\n    def dfs(self, n, k, colors, color):\n        if n == 0:\n            return 1\n        if n == 1:\n            return (colors[color] == k and k > 0) or (colors[color] == k and k < 0)\n        if colors[color] == k:\n            return 0\n        if k > 0:\n            return self.dfs(n - 1, k - 1, colors, color)\n        else:\n            return self.dfs(n - 1, k, colors, color)\n\n\nif __name__ == '__main__':\n    assert Solution().numWays(2, 2) == 2\n    assert Solution().numWays(2, 3) == 4\n    assert Solution().numWays(2, 4) == 8\n    assert Solution().numWays(3, 3) == 9\n    assert Solution().numWays(4, 4) == 16\n    assert Solution().numWays(4, 5) == 25",
    "class Solution(object):\n    def paintFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return n\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[-1][-1]\n\nif __name__ == \"__main__\":\n    assert Solution().paintFence(4, 2) == 6\n    assert Solution().paintFence(5, 1) == 4\n    assert Solution().paintFence(6, 3) == 15",
    "class Solution(object):\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1 or k == 1:\n            return 1\n        if k == 2 and fence[0] == fence[n-1]:\n            return 2\n        ans = 0\n        for i in xrange(2, n):\n            if fence[i-1] == fence[i]:\n                ans += self.numWays(n-1, k-1, fence)\n            else:\n                ans += self.numWays(n-1, k, fence)\n        return ans\n\n\nif __name__ == '__main__':\n    assert Solution().numWays(2, 2, [0, 1]) == 2\n    assert Solution().numWays(2, 3, [0, 1]) == 3\n    assert Solution().numWays(3, 2, [0, 1]) == 3\n    assert Solution().numWays(3, 3, [0, 1]) == 6\n    assert Solution().numWays(5, 2, [0, 1, 0, 1, 1]) == 6\n    assert Solution().numWays(5, 3, [0, 1, 0, 1, 1]) == 6",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n + 1):\n            dp[i] = 0\n            for j in xrange(i):\n                if dp[j] == 0:\n                    dp[i] += dp[j - 1]\n                elif j < i - 1:\n                    dp[i] += dp[j] + dp[i - 1]\n        return dp[n]",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return (n + 1) // 2\n\n        if k == 2:\n            return (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 3:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 4:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 5:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 6:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 7:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 8:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2\n        \n        if k == 9:\n            return ((n + 1) // 2) * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2 * (n + 1) // 2",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        :param n: integer\n        :param k: integer\n        :return: integer\n        \"\"\"\n        dp = [[0 for j in xrange(k)] for i in xrange(n+1)]\n        dp[0][0] = 1\n        for i in xrange(1, n+1):\n            for j in xrange(1, k+1):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[n][k]\n\n\nif __name__ == \"__main__\":\n    print Solution().numWays(4, 3)",
    "class Solution(object):\n    def numWays(self, n, k, color):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type color: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        elif n == 2:\n            return k * (k - 1)\n        elif n > 2:\n            return self.numWays(n - 1, k, color) + self.numWays(n - 2, k, color)\n        else:\n            return 0\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.numWays(2, 2, [1, 2])\n    print s.numWays(2, 2, [1, 1])\n    print s.numWays(2, 2, [1, 2, 3])\n    print s.numWays(3, 3, [1, 2, 3])\n    print s.numWays(3, 4, [1, 2, 3])\n    print s.numWays(3, 4, [1, 2, 3, 4])",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\nclass Solution(object):\n    def numWays(self, n, k, color):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type color: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(n):\n            for j in xrange(k):\n                if color[i] == color[j]:\n                    result += self.numWays(n-1, k-1, color)\n                    break\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numWays(10, 3, [1,2,3])\n    print s.numWays(5, 2, [1,2,3,4,5])\n    print s.numWays(10, 6, [1,2,3,4,5,6])\n    print s.numWays(10, 10, [1,2,3,4,5,6,7,8,9,10])",
    "# https://oj.leetcode.com/problems/paint-fence/\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(k):\n            res += self.maxFenceHelper(n, i)\n        return res\n\n    def maxFenceHelper(self, n, i):\n        if i == 0:\n            return 1\n        if i == 1:\n            return 2\n        if n % 2 == 0:\n            return max(self.maxFenceHelper(n / 2, i - 1) + self.maxFenceHelper(n / 2, i),\n                       self.maxFenceHelper(n / 2, i - 1) + self.maxFenceHelper(n / 2, i))\n        else:\n            return max(self.maxFenceHelper(n / 2, i - 1) + self.maxFenceHelper(n / 2, i),\n                       self.maxFenceHelper(n / 2, i - 1) + self.maxFenceHelper(n / 2, i))\n\nif __name__ == \"__main__\":\n    print Solution().maxFence(4, 2)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k < 2 or n < k:\n            return 0\n        return self.__numWays_helper(n, k, [0] * n, [0] * n)\n\n    def __numWays_helper(self, n, k, nums, colors):\n        if k == 1:\n            return nums[0]\n        elif k == 2:\n            return nums[0] * nums[1]\n        else:\n            if k - 2 in colors:\n                return nums[0] * nums[1] * nums[2] + self.__numWays_helper(n, k - 2, nums, colors)\n            else:\n                return nums[0] * nums[1] * nums[2] + nums[0] * self.__numWays_helper(n, k - 2, nums, colors) + self.__numWays_helper(n, k - 1, nums, colors)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.numWays(4, 2))",
    "# https://leetcode.com/problems/the-fence-with-n-posts-and-k-colors/discuss/81757/Python-DP-Solution-Faster-O(n+k)\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n, k = max(n, k), min(n, k)\n        dp = [[0 for _ in range(k)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i == j:\n                    dp[i][j] = 1\n                elif i > j:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][k]\n\nif __name__ == '__main__':\n    print(Solution().numWays(3, 4))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # base case\n        if n == 1:\n            return k\n        # calculate the number of ways to paint the fence\n        # the number of ways to paint the fence is the number of ways to paint the fence with n-1 posts and k-1 colors\n        # the number of ways to paint the fence with n-1 posts and k-1 colors is the number of ways to paint the fence with n-2 posts and k-2 colors\n        # the number of ways to paint the fence with n-2 posts and k-2 colors is the number of ways to paint the fence with n-3 posts and k-3 colors\n        # the number of ways to paint the fence with n-3 posts and k-3 colors is the number of ways to paint the fence with n-4 posts and k-4 colors\n        # the number of ways to paint the fence with n-4 posts and k-4 colors is the number of ways to paint the fence with n-5 posts and k-5 colors\n        # the number of ways to paint the fence with n-5 posts and k-5 colors is the number of ways to paint the fence with n-6 posts and k-6 colors\n        # the number of ways to paint the fence with n-6 posts and k-6 colors is the number of ways to paint the fence with n-7 posts and k-7 colors\n        # the number of ways to paint the fence with n-7 posts and k-7 colors is the number of ways to paint the fence with n-8 posts and k-8 colors\n        # the number of ways to paint the fence with n-8 posts and k-8 colors is the number of ways to paint the fence with n-9 posts and k-9 colors\n        # the number of ways to paint the fence with n-9 posts and k-9 colors is the number of ways to paint the fence with n-10 posts and k-10 colors\n        # the number of ways to paint the fence with n-10 posts and k-10 colors is the number of ways to paint the fence with n-11 posts and k-11 colors\n        # the number of ways to",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\n    def __repr__(self):\n        return \"(%d, %d)\" % (self.x, self.y)\n\nclass Solution(object):\n    def __init__(self):\n        self.result = 0\n\n    def maxPairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        elif k == 1:\n            return 1\n        elif k == 2:\n            return n * (n - 1) // 2\n        elif k == 3:\n            return n * (n - 1) * (n - 2) // 6\n        elif k > 3:\n            return 0\n        elif k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) // 24\n        elif k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n        elif k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n        elif k == 7:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n        else:\n            return 0\n\ns = Solution()\ns.maxPairs(4, 6)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if k == 1:\n            return 2\n        res = [0] * (n + 1)\n        res[0] = 1\n        for i in range(1, n + 1):\n            if i % k == 0:\n                res[i] = res[i - k] + res[i - k - 1]\n            else:\n                res[i] = res[i - 1]\n        return res[-1]",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return k\n        if n == 2:\n            return k*(k - 1)//2\n        ret = 0\n        for i in range(1, k):\n            ret += self.numWays(n - 1, i)\n        return ret\n\n\nif __name__ == '__main__':\n    print(Solution().numWays(2, 1))\n    print(Solution().numWays(3, 2))\n    print(Solution().numWays(3, 3))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        dp = [[0] * n for _ in xrange(k)]\n        dp[0][0] = 1\n        for i in xrange(1, k):\n            dp[i][0] = 1\n            for j in xrange(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n\n\nif __name__ == '__main__':\n    print Solution().numWays(2, 2)\n    print Solution().numWays(2, 3)",
    "def count_ways(n, k, fence):\n    if k == 1:\n        return (fence[0] == fence[1])\n    elif k == 2:\n        return (fence[0] == fence[2])\n    else:\n        count = 0\n        for i in range(1, n):\n            if (fence[i] == fence[i-1] and fence[i] == fence[i+1]):\n                count += 1\n        return count\n\nn = int(input())\nk = int(input())\nfence = [int(x) for x in input().split()]\nprint(count_ways(n, k, fence))",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\n    def __repr__(self):\n        return \"Point [x=%d, y=%d]\" % (self.x, self.y)\n\nclass Solution(object):\n    def __init__(self):\n        self.result = 0\n\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[Point]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            if k == 1:\n                return self.numWays1(n, fence)\n            elif k == 2:\n                return self.numWays2(n, fence)\n            else:\n                return self.numWays3(n, k, fence)\n\n    def numWays1(self, n, fence):\n        \"\"\"\n        :type n: int\n        :type fence: List[Point]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(n):\n            res += self.numWays2(n - i, fence)\n        return res\n\n    def numWays2(self, n, fence):\n        \"\"\"\n        :type n: int\n        :type fence: List[Point]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(n):\n            for j in xrange(i, n):\n                if fence[i].x == fence[j].x and fence[i].y == fence[j].y:\n                    res += self.numWays3(n - i - 1, fence) + self.numWays3(n - j - 1, fence)\n        return res\n\n    def numWays3(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[Point]\n        :rtype: int",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.ways = []\n\n    def paintFence(self, n, k):\n        \"\"\"\n        :param n: an integer\n        :param k: an integer\n        :return: an integer\n        \"\"\"\n        self.ways.append(0)\n        self.paint(n, k, 0)\n        return sum(self.ways)\n\n    def paint(self, n, k, color):\n        if n == 0:\n            self.ways[color] += 1\n            return\n\n        for i in range(k):\n            if color == i:\n                self.paint(n - 1, k, i)\n            else:\n                self.paint(n, k, i)\n                self.paint(n, k, i + 1)\n\n\nif __name__ == \"__main__\":\n    print Solution().paintFence(2, 2)",
    "#!/bin/python\n\ndef f(n, k):\n    if k == 1:\n        return 1\n    else:\n        return n * f(n - 1, k - 1) + f(n - 1, k)\n\nprint f(4, 2)",
    "# Definition for a fence.\nclass Fence:\n    def __init__(self, l):\n        self.left = l\n        self.right = l\n\nclass Solution:\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def numWays(self, n, k):\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        else:\n            return self.numWays(n, k-1) + self.numWays(n-1, k-1)\n\n    # @param {integer[]} colors\n    # @return {integer}\n    def numWays(self, colors):\n        n = len(colors)\n        k = len(colors) - 1\n        return self.numWays(n, k)",
    "# https://leetcode.com/problems/paint-fence/\n\nclass Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if k == 0:\n            return 0\n        if k == 1:\n            return n - 1\n        if n < k:\n            return 0\n        if n == k:\n            return 1\n        if n - k > 2:\n            return 0\n        ret = 0\n        for i in range(1, k + 1):\n            ret += self.numWays(n - i, k - i)\n        return ret\n\n\nif __name__ == \"__main__\":\n    print(Solution().numWays(5, 2))",
    "class Solution:\n    # @return an integer\n    def numWays(self, n, k):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1)\n        if k == 3:\n            return n * (n - 1) * (n - 2)\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3)\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4)\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5)\n        return self.rec(n, k)\n\n    def rec(self, n, k):\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1)\n        if k == 3:\n            return n * (n - 1) * (n - 2)\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3)\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4)\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5)\n        return self.rec(n - 1, k - 1) + self.rec(n - 2, k - 1)",
    "class Solution(object):\n    def numWays(self, n, k, color):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type color: str\n        :rtype: int\n        \"\"\"\n        res = 0\n        if n == 1:\n            return 1\n        if k == 1:\n            if color == 'R':\n                return n\n            else:\n                return n + 1\n        if k == 2:\n            if color == 'R':\n                return n * (n - 1) / 2\n            else:\n                return n * (n - 1) / 2 + n - 1\n        if k == 3:\n            res += self.numWays(n - 1, 3, 'R')\n            res += self.numWays(n - 1, 3, 'B')\n            res += self.numWays(n - 1, 3, 'G')\n            return res\n        if k == 4:\n            res += self.numWays(n - 1, 4, 'R')\n            res += self.numWays(n - 1, 4, 'B')\n            res += self.numWays(n - 1, 4, 'G')\n            res += self.numWays(n - 1, 4, 'Y')\n            return res\n        if k == 5:\n            res += self.numWays(n - 1, 5, 'R')\n            res += self.numWays(n - 1, 5, 'B')\n            res += self.numWays(n - 1, 5, 'G')\n            res += self.numWays(n - 1, 5, 'Y')\n            res += self.numWays(n - 1, 5, 'M')\n            return res\n        if k == 6:\n            res += self.numWays(n - 1, 6, 'R')\n            res += self.numWays(n - 1, 6, 'B')\n            res += self.numWays(n - 1, 6, 'G')\n            res += self.numWays(n - 1, 6, 'Y')\n            res += self.numWays(n - 1, 6, 'M')",
    "# -*- coding:utf-8 -*-\nclass Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        # write your code here\n        if n == 1 or k == 1:\n            return 1\n        if n == 2 and k == 1:\n            return 2\n        if n == 2 and k == 2:\n            return 4\n        if n == 2 and k == 3:\n            return 6\n        if n == 2 and k == 4:\n            return 8\n        if n == 2 and k == 5:\n            return 10\n        if n == 2 and k == 6:\n            return 12\n        if n == 2 and k == 7:\n            return 14\n        if n == 2 and k == 8:\n            return 16\n        if n == 2 and k == 9:\n            return 18\n        if n == 2 and k == 10:\n            return 20\n        if n == 2 and k == 11:\n            return 22\n        if n == 2 and k == 12:\n            return 24\n        if n == 2 and k == 13:\n            return 26\n        if n == 2 and k == 14:\n            return 28\n        if n == 2 and k == 15:\n            return 30\n        if n == 2 and k == 16:\n            return 32\n        if n == 2 and k == 17:\n            return 34\n        if n == 2 and k == 18:\n            return 36\n        if n == 2 and k == 19:\n            return 38\n        if n == 2 and k == 20:\n            return 40\n        if n == 2 and k == 21:\n            return 42\n        if n == 2 and k == 22:\n            return 44\n        if n == 2 and k == 23:\n            return 46\n        if n == 2 and k == 24:\n            return 48\n        if n == 2 and k == 25:\n            return 50\n        if n == 2 and k == 26:\n            return 52\n        if n == 2 and k == 27:\n            return 54\n        if n == 2 and k == 28:\n            return 56\n        if n == 2 and k == 29:\n            return 58",
    "# https://leetcode.com/problems/paint-fence/description/\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # 1:1\n        # 2:2\n        # 3:2\n        # 4:1\n        # 5:3\n        # 6:3\n        # 7:3\n        # 8:4\n        # 9:4\n        # 10:4\n        # 11:4\n        # 12:4\n        # 13:4\n        # 14:5\n        # 15:5\n        # 16:5\n        # 17:5\n        # 18:5\n        # 19:5\n        # 20:6\n        # 21:6\n        # 22:6\n        # 23:6\n        # 24:6\n        # 25:6\n        # 26:6\n        # 27:6\n        # 28:6\n        # 29:6\n        # 30:6\n        # 31:6\n        # 32:6\n        # 33:6\n        # 34:6\n        # 35:6\n        # 36:6\n        # 37:6\n        # 38:6\n        # 39:6\n        # 40:6\n        # 41:6\n        # 42:6\n        # 43:6\n        # 44:6\n        # 45:6\n        # 46:6\n        # 47:6\n        # 48:6\n        # 49:6\n        # 50:6\n        # 51:6\n        # 52:6\n        # 53:6\n        # 54:6\n        # 55:6\n        # 56:6\n        # 57:6\n        # 58:6\n        # 59:6\n        # 60:6\n        # 61:6\n        # 62:6\n        # 63:6\n        # 64:6\n        # 65:6\n        # 66:6\n        # 67:6\n        # 68:6\n        # 69:6\n        # 70:6\n        # 71:6\n        # 72:6\n        # 73:6\n        # 74:6",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return n\n        if n == 1:\n            return 1\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 24\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 120\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) / 720\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) / 5040",
    "class Solution:\n    # @param {integer[]} colors\n    # @param {integer} n\n    # @param {integer} k\n    # @return {integer}\n    def numWays(self, colors, n, k):\n        if n < k:\n            return 0\n        if k == 1:\n            return (n == 1) * 2\n        if k == 2:\n            return (n == 1) * 4 + (n == 2) * 3\n        if k == 3:\n            return (n == 1) * 6 + (n == 2) * 5 + (n == 3) * 4\n        if k == 4:\n            return (n == 1) * 10 + (n == 2) * 9 + (n == 3) * 8 + (n == 4) * 7\n        if k == 5:\n            return (n == 1) * 15 + (n == 2) * 14 + (n == 3) * 13 + (n == 4) * 12 + (n == 5) * 11\n        if k == 6:\n            return (n == 1) * 21 + (n == 2) * 20 + (n == 3) * 19 + (n == 4) * 18 + (n == 5) * 17 + (n == 6) * 16\n        if k == 7:\n            return (n == 1) * 30 + (n == 2) * 29 + (n == 3) * 28 + (n == 4) * 27 + (n == 5) * 26 + (n == 6) * 25 + (n == 7) * 24\n        if k == 8:\n            return (n == 1) * 40 + (n == 2) * 39 + (n == 3) * 38 + (n == 4) * 37 + (n == 5) * 36 + (n == 6) * 35 + (n == 7) * 34 + (n == 8) * 33\n        if k == 9:\n            return (n == 1) * 50 + (n == 2) * 49 + (n == 3) * 48 + (n == 4) * 47 + (n == 5) * 46 + (n == 6) * 45 + (n == 7) * 44 + (n == 8) * 43 + (n == 9) * 42\n        return (n",
    "# Definition for a point.\n# class Point(object):\n#     def __init__(self, a=0, b=0):\n#         self.x = a\n#         self.y = b\n\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return n * n\n        if k == 3:\n            return n * n * n\n        if k > 3:\n            return 0\n        if k > 2:\n            return 0\n        if k > 1:\n            return 0\n        if k > 0:\n            return 0\n        if k == 0:\n            return 1\n\n        numWays = 0\n        for i in range(1, k + 1):\n            numWays += self.numWays(n - 1, k - i)\n        return numWays\n\n\nif __name__ == '__main__':\n    assert Solution().numWays(5, 2) == 4\n    assert Solution().numWays(4, 3) == 12\n    assert Solution().numWays(3, 3) == 6",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if n < k:\n            return 0\n        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k > 3:\n            return 0\n\n        count = [0] * (k - 1)\n        for i in range(n - 1):\n            count[k - 1] += self.numWays(n - i - 1, k - 1)\n            count[k - 2] += self.numWays(n - i - 1, k - 2)\n        return count[0] + count[1]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numWays(5, 3)\n    print s.numWays(6, 3)\n    print s.numWays(6, 4)",
    "class Solution(object):\n    def paintFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # DP: O(n^2 * k)\n        # http://www.cnblogs.com/grandyang/p/3817862.html\n        # http://www.cnblogs.com/grandyang/p/3817863.html\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if dp[i-1][j-1] == 0:\n                    dp[i][j] = 0\n                elif dp[i-1][j-1] == 1:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                elif dp[i-1][j-1] == 2:\n                    dp[i][j] = dp[i-1][j-1] + dp[i][j]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[n][k]\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.paintFence(2, 2))\n    print(s.paintFence(2, 3))\n    print(s.paintFence(3, 3))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < 3:\n            return 0\n        if k == 2:\n            return self.numWays2(n, k)\n        elif k == 3:\n            return self.numWays3(n, k)\n        else:\n            return self.numWays(n, k-1) + self.numWays(n-1, k-1) + self.numWays(n-2, k-1)\n    \n    def numWays2(self, n, k):\n        ways = [0] * (n+1)\n        ways[0] = 1\n        for i in range(1, n+1):\n            ways[i] = ways[i-1]\n            if i < k:\n                ways[i] += ways[i-k]\n        return ways[n]\n    \n    def numWays3(self, n, k):\n        ways = [0] * (n+1)\n        ways[0] = 1\n        for i in range(1, n+1):\n            ways[i] = ways[i-1]\n            if i < k:\n                ways[i] += ways[i-k]\n            if i < k:\n                ways[i] += ways[i-k-1]\n        return ways[n]",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\nclass Solution(object):\n    def numWays(self, points, n, k):\n        \"\"\"\n        :type points: List[Point]\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or k == 0:\n            return 0\n        if n == 1:\n            if k == 1:\n                return 1\n            else:\n                return k\n        ret = 0\n        for i in range(1, n):\n            ret += self.numWays(points, n-1, k)\n            if k == 1:\n                ret += self.numWays(points, n-1, 1)\n            else:\n                ret += self.numWays(points, n-1, k-1)\n        return ret\n\n    def numWays2(self, points, n, k):\n        \"\"\"\n        :type points: List[Point]\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or k == 0:\n            return 0\n        if n == 1:\n            if k == 1:\n                return 1\n            else:\n                return k\n        ret = 0\n        for i in range(1, n):\n            ret += self.numWays2(points, n-1, k)\n            if k == 1:\n                ret += self.numWays2(points, n-1, 1)\n            else:\n                ret += self.numWays2(points, n-1, k-1)\n        return ret",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [1] * (k + 1)\n        for i in range(2, k + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % k\n        for i in range(k + 1, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % k\n        return dp[n]",
    "class Solution(object):\n    def paintFence(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i - j >= 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][k]\n\nif __name__ == \"__main__\":\n    print Solution().paintFence(3, 2)",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttps://www.codewars.com/kata/55a30f6f1c0b8a7c00008cd/train/python\n\n\"\"\"\n\nimport unittest\nfrom collections import Counter\n\n#  Ported from Codewars\n#  Problem Statement:\n#  You are given the number of posts and colors, and the fence.\n#  You have to find out the number of ways to paint the fence.\n#  You can paint only two adjacent posts with the same color.\n#  For example, for the fence:\n#  1 2 3 4\n#  5 6 7 8\n#  You can paint:\n#  1 3 4\n#  1 5 6\n#  1 7 8\n#  2 3 4\n#  2 5 6\n#  2 7 8\n#  3 4 5\n#  3 6 7\n#  3 8 8\n#  4 5 6\n#  4 7 8\n#  5 6 7\n#  6 7 8\n#  The total number of ways to paint the fence is:\n#  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 14\n#  The total number of ways to paint the fence without the same color is:\n#  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 17\n#  The total number of ways to paint the fence without the same color is:\n#  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 = 30\n#  The total number of ways to paint the fence without the same color is:\n#  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 = 45\n#  The total number of ways to paint the fence without the same color is:\n#  1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 +",
    "# https://leetcode.com/problems/fence-painting/discuss/71672/Python-DP-solution-with-explanation\n\nclass Solution:\n    # @return an integer\n    def numWays(self, n, k, colors):\n        dp = [0] * (n + 1)\n        for i in range(k):\n            dp[0] += 1\n        for i in range(1, n + 1):\n            dp[i] = sum(dp[i - 1:])\n        return dp[-1]",
    "# https://leetcode.com/problems/paint-fence/description/\n# https://leetcode.com/problems/paint-fence/discuss/276564/C++-DP-solution-with-explicit-loop\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return k * (k - 1) // 2\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, k + 1):\n            dp[i] = dp[i - 1] + dp[i - 1] * (k - i + 1)\n        return dp[k]",
    "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if j>=1 and k[i-1]==k[j-1] else dp[i-1][j]\n        dp = [[0 for _ in xrange(n)] for _ in xrange(k)]\n        for i in xrange(1, n):\n            for j in xrange(1, k):\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if j>=1 and k[i-1]==k[j-1] else dp[i-1][j]\n\n        return dp[n-1][k-1]\n\n\nif __name__ == \"__main__\":\n    print Solution().numWays(4, 3)",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if k == 0:\n            return n\n        else:\n            return self.helper(n, k)\n\n    def helper(self, n, k):\n        if k == 0:\n            return 1\n        else:\n            return self.helper(n - 1, k - 1) + self.helper(n - 1, k)",
    "class Solution(object):\n    def numWays(self, n, k, colors):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        if k == 1:\n            return (n - k + 1) if n % 2 else (n + k - 1)\n        else:\n            return self.numWays(n - 1, k, colors) + self.numWays(n - 1, k - 1, colors)",
    "class Solution:\n    # @return an integer\n    def numWays(self, n, k):\n        dp = [1] * k\n        dp[0] = 1\n        for i in xrange(1, k):\n            dp[i] = dp[i - 1] + dp[i - 1]\n        for i in xrange(2, k):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        for i in xrange(k - 1, -1, -1):\n            dp[i] = dp[i + 1] + dp[i]\n        return dp[k - 1]\n\nif __name__ == \"__main__\":\n    assert Solution().numWays(4, 2) == 6\n    assert Solution().numWays(4, 3) == 12\n    assert Solution().numWays(4, 4) == 24\n    assert Solution().numWays(4, 5) == 120",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k % 2 == 0:\n            return self.numWays(n, k / 2) + self.numWays(n - 1, k / 2)\n        return self.numWays(n, k / 2) + self.numWays(n - 1, k / 2) + self.numWays(n - 2, k / 2)\n\n\nif __name__ == '__main__':\n    print Solution().numWays(3, 2)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return k\n        if n == 2:\n            return k * (k + 1) // 2\n        if n == 3:\n            return k * (k + 1) // 2 + k * k\n        if n == 4:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2\n        if n == 5:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k\n        if n == 6:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k * (k + 3) // 2\n        if n == 7:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k * (k + 3) // 2 + k * k * k * k * k\n        if n == 8:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k * (k + 3) // 2 + k * k * k * k * k * k\n        if n == 9:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k * (k + 3) // 2 + k * k * k * k * k * k + k * k * k * k * k * k * k\n        if n == 10:\n            return k * (k + 1) // 2 + k * k * (k + 2) // 2 + k * k * k * (k + 3) // 2 + k * k * k * k * k * k * k + k * k * k * k * k * k * k * k\n        return n * (n + 1) // 2\n\nif __name__ == \"__main__\":\n    assert Solution().numW",
    "def paint_fence(n, k, colors):\n    if n == 1:\n        return 1\n    if k == 1:\n        return 1\n    if k == 2:\n        return n\n    if k == 3:\n        return (n * (n - 1)) // 2\n    if k == 4:\n        return (n * (n - 1)) // 2 * (n - 2)\n    if k == 5:\n        return (n * (n - 1)) // 2 * (n - 3) * (n - 2)\n    if k == 6:\n        return (n * (n - 1)) // 2 * (n - 4) * (n - 3) * (n - 2)\n    if k == 7:\n        return (n * (n - 1)) // 2 * (n - 5) * (n - 4) * (n - 3) * (n - 2)\n    if k == 8:\n        return (n * (n - 1)) // 2 * (n - 6) * (n - 5) * (n - 4) * (n - 3) * (n - 2) * (n - 1)\n\n\ndef test():\n    assert(paint_fence(1, 1, 1) == 1)\n    assert(paint_fence(2, 1, 1) == 2)\n    assert(paint_fence(3, 1, 1) == 4)\n    assert(paint_fence(4, 1, 1) == 8)\n    assert(paint_fence(5, 1, 1) == 15)\n    assert(paint_fence(6, 1, 1) == 30)\n    assert(paint_fence(7, 1, 1) == 63)\n    assert(paint_fence(8, 1, 1) == 126)\n    assert(paint_fence(9, 1, 1) == 252)\n\nif __name__ == '__main__':\n    test()",
    "# import time\n# start = time.time()\n\nclass Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if k > n:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        # else:\n        #     return self.numWays(n, k - 1) + self.numWays(n - 1, k - 2)\n        # return self.numWays(n, k - 1) + self.numWays(n - 1, k - 2)\n\n        # dp[i] is the number of ways to paint the first i posts with the same color\n        dp = [0] * (n + 1)\n        # dp[0] = 1\n        # dp[1] = k\n        # dp[2] = k * (k - 1) / 2\n        # dp[3] = k * (k - 1) / 2 * (k - 2) / 2\n        # dp[4] = k * (k - 1) / 2 * (k - 2) / 2 * (k - 3) / 2\n        # dp[5] = k * (k - 1) / 2 * (k - 2) / 2 * (k - 3) / 2 * (k - 4) / 2\n        # dp[6] = k * (k - 1) / 2 * (k - 2) / 2 * (k - 3) / 2 * (k - 4) / 2 * (k - 5) / 2\n        # dp[7] = k * (k - 1) / 2 * (k - 2) / 2 * (k - 3) / 2 * (k - 4) / 2 * (k - 5) / 2 * (k - 6) / 2\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + k\n        return dp[n]\n\nif __name__ == '__main__':\n    s =",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n+1)\n        dp[0] = 1\n        for i in xrange(1, n+1):\n            dp[i] = (dp[i-1] + dp[i-k]) % 1000000007\n        return dp[n]",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if n < 2 or k < 2:\n            return 0\n        if n == 2:\n            return k == 1 or k == 2\n        if n == 3:\n            return k == 1 or k == 2 or k == 3\n        if n == 4:\n            return k == 1 or k == 2 or k == 3 or k == 4\n        if n == 5:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5\n        if n == 6:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6\n        if n == 7:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7\n        if n == 8:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8\n        if n == 9:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9\n        if n == 10:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10\n        if n == 11:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10 or k == 11\n        if n == 12:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10 or k == 11 or k == 12\n        if n == 13:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k ==",
    "class Solution:\n    # @param n, an integer\n    # @param k, an integer\n    # @return an integer\n    def numWays(self, n, k):\n        if n == 1:\n            return 1\n        if n == 2:\n            return k == 1 or k == 2\n        if n == 3:\n            return k == 1 or k == 2 or k == 3\n        if n == 4:\n            return k == 1 or k == 2 or k == 3 or k == 4\n        if n == 5:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5\n        if n == 6:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6\n        if n == 7:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7\n        if n == 8:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8\n        if n == 9:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9\n        if n == 10:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10\n        if n == 11:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10 or k == 11\n        if n == 12:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10 or k == 11 or k == 12\n        if n == 13:\n            return k == 1 or k == 2 or k == 3 or k == 4 or k == 5 or k == 6 or k == 7 or k == 8 or k == 9 or k == 10 or k ==",
    "# Note:\n# We use a hash map to store the color of adjacent posts.\n# The hash map is:\n# post -> {color: number}\n# The number is the number of times the given post has the given color.\n# If the color is not in the hash map, then the number is 0.\n# The hash map is O(n) in size.\n# The hash map is O(k) in time.\n# The hash map is O(nk) in space.\n# Example:\n# n = 5, k = 2\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}\n# post -> {'black': 1,'red': 2}\n# post -> {'black': 1,'red': 1}",
    "# Definition for a point.\nclass Point:\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\nclass Solution:\n    def maxClique(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # Initialize graph\n        # Graph[i][j] means post i can be painted with color j\n        # Graph[i][j] = Graph[j][i] = 0 if there is no such color\n        # Graph[i][j] = Graph[j][i] = 1 if there is such color\n        graph = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(k):\n                graph[i][j] = 1\n        for i in range(n):\n            for j in range(k):\n                for j in range(i, n):\n                    graph[i][j] = max(graph[i][j], graph[i][j-1] + graph[j][i])\n        return graph[n-1][k-1]",
    "def num_paint(n, k, post_colors):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 0\n    if post_colors[n-2] == post_colors[n-1]:\n        return num_paint(n-1, k-1, post_colors) + num_paint(n-2, k-1, post_colors)\n    else:\n        return num_paint(n-1, k-1, post_colors)\n\nprint num_paint(5, 3, [1, 2, 2])",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/fence-with-two-colors/#/solutions\n        if n == 1 or k == 1:\n            return 1\n        if n == 1:\n            return k\n        if k == 1:\n            return n\n        if n == k:\n            return k * k\n        return self.numWays(n - 1, k) + self.numWays(n - 1, k - 1)\n\n\nif __name__ == '__main__':\n    print Solution().numWays(4, 3)",
    "def num_paintings(n, k, fence):\n    if fence == 0:\n        return 0\n    if fence < 2:\n        return 1\n    if fence < 5:\n        return num_paintings(n, k, fence - 1) + num_paintings(n, k, fence - 2)\n    if fence < 10:\n        return num_paintings(n, k, fence - 1) + num_paintings(n, k, fence - 5) + num_paintings(n, k, fence - 9)\n    if fence < 15:\n        return num_paintings(n, k, fence - 1) + num_paintings(n, k, fence - 5) + num_paintings(n, k, fence - 10) + num_paintings(n, k, fence - 15)\n    if fence < 20:\n        return num_paintings(n, k, fence - 1) + num_paintings(n, k, fence - 5) + num_paintings(n, k, fence - 10) + num_paintings(n, k, fence - 15) + num_paintings(n, k, fence - 20)\n    return num_paintings(n, k, fence - 1) + num_paintings(n, k, fence - 5) + num_paintings(n, k, fence - 10) + num_paintings(n, k, fence - 15) + num_paintings(n, k, fence - 20) + num_paintings(n, k, fence - 25)\n\nn = 5\nk = 3\nprint(num_paintings(n, k, n))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # naive solution\n        #return self.naive(n, k)\n\n        # dp solution\n        # return self.dp(n, k)\n\n    def naive(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(1, k+1):\n            res += self.naive(n-1, k-i)\n        return res\n\n    def dp(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(1, k+1):\n            res += self.dp(n-1, k-i)\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.naive(2, 2)\n    print s.naive(3, 3)\n    print s.naive(3, 4)\n    print s.dp(3, 4)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if k == 1:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if k == 2:\n            return 2\n        if k == 3:\n            return 4\n        if n == 3:\n            return 4\n        if k == 4:\n            return 8\n        if k == 5:\n            return 16\n        if n == 4:\n            return 16\n        if k == 6:\n            return 32\n        if n == 5:\n            return 32\n        if k == 7:\n            return 64\n        if k == 8:\n            return 128\n        if n == 6:\n            return 128\n        if k == 9:\n            return 256\n        if n == 7:\n            return 256\n        if k == 10:\n            return 512\n        if n == 8:\n            return 512\n        if k == 11:\n            return 1024\n        if n == 9:\n            return 1024\n        if k == 12:\n            return 2048\n        if n == 10:\n            return 2048\n        if k == 13:\n            return 4096\n        if n == 11:\n            return 4096\n        if k == 14:\n            return 8192\n        if n == 12:\n            return 8192\n        if k == 15:\n            return 16384\n        if n == 13:\n            return 16384\n        if k == 16:\n            return 32768\n        if n == 14:\n            return 32768\n        if k == 17:\n            return 65536\n        if n == 15:\n            return 65536\n        if k == 18:\n            return 131072\n        if n == 16:\n            return 131072\n        if k == 19:\n            return 262144\n        if n == 17:\n            return 262144\n        if k == 20:\n            return 524288\n        if n == 18:\n            return 524288\n        if k == 21:\n            return 1048576\n        if n == 19",
    "# https://leetcode.com/problems/paint-fence/description/\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k >= 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 24\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 720\n\n    def numWays_dp(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k >= 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 24\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 720\n        dp = [0] * n\n        for i in xrange(n):\n            dp[i] = 1\n        for i in xrange(2, k + 1):\n            for j in xrange(i, n):\n                dp[j] = dp[j] + dp[j - i]\n        return dp[n - 1]\n\nif __name__ == \"__main__\":\n    assert Solution().numWays_dp(3, 3) == 4",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\n    def __repr__(self):\n        return '<Point %s, %s>' % (self.x, self.y)\n\nclass Solution(object):\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[Point]\n        :rtype: int\n        \"\"\"\n        if not fence:\n            return 0\n        if n <= 1:\n            return 1\n        \n        num_ways = 0\n        for i in range(k):\n            fence_copy = fence[:]\n            fence_copy.remove(fence[0])\n            num_ways += self.numWays(n-1, k-1, fence_copy)\n        return num_ways\n\n\nif __name__ == '__main__':\n    n = 4\n    k = 3\n    fence = [Point(0, 0), Point(0, 1), Point(0, 2), Point(0, 3)]\n    solution = Solution()\n    print solution.numWays(n, k, fence)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < 2:\n            return 0\n        if k == 1:\n            return (n - 1) * (n - 2) // 2\n        if k == 2:\n            return n * (n - 1) // 2\n        if k == 3:\n            return n * (n - 1) // 2 + n - 1\n        if k == 4:\n            return n * (n - 1) // 2 + n - 1 + n - 2\n        if k == 5:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3\n        if k == 6:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4\n        if k == 7:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5\n        if k == 8:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5 + n - 6\n        if k == 9:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5 + n - 6 + n - 7\n        if k == 10:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5 + n - 6 + n - 7 + n - 8\n        if k == 11:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5 + n - 6 + n - 7 + n - 8 + n - 9\n        if k == 12:\n            return n * (n - 1) // 2 + n - 1 + n - 2 + n - 3 + n - 4 + n - 5 + n - 6 + n - 7 + n - 8 + n - 9 + n - 10\n        if",
    "# This is the naive implementation of the problem. It is not the best one since it does not take into account the fact that the same color can be assigned to the same post in different ways.\n# time:O(n^3)\n# space:O(n^2)\n# score:5.07(3ms)\n# score:3.73(2ms)\n# score:2.43(1ms)\n# score:1.98(1ms)\n# score:1.96(1ms)\n# score:1.90(1ms)\n# score:1.73(1ms)\n# score:1.67(1ms)\n# score:1.50(1ms)\ndef paintFence(n, k):\n    if n < 2 or k == 0:\n        return 0\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = 0\n        for j in range(0, i):\n            dp[i] += dp[j] * (k - 1)\n    return dp[n]\n\n# This is the optimal solution. It takes into account the fact that the same color can be assigned to the same post in different ways.\n# time:O(n^2)\n# space:O(n^2)\n# score:3.73(2ms)\n# score:2.43(1ms)\n# score:1.98(1ms)\n# score:1.96(1ms)\n# score:1.90(1ms)\n# score:1.73(1ms)\n# score:1.67(1ms)\n# score:1.50(1ms)\ndef paintFence2(n, k):\n    if n < 2 or k == 0:\n        return 0\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = 0\n        for j in range(0, i):\n            dp[i] += dp[j] * (k - 1)\n    return dp[n]\n\n# This is",
    "#!/usr/bin/env python\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if n <= 2:\n            return 0\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 24\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 720\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numWays(3, 3)",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.numWays_dp(n, k)\n\n    def numWays_dp(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) // 2\n        if k == 3:\n            return n * (n - 1) // 2 * n\n        return self.numWays_dp(n - 1, k) + self.numWays_dp(n - 1, k - 1)\n\n\nif __name__ == '__main__':\n    assert Solution().numWays(5, 2) == 10",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return fence[0] == fence[1] and fence[0] or fence[1]\n        count = 0\n        for i in range(1, n+1):\n            if i == 1:\n                continue\n            if fence[i-1] == fence[i]:\n                count += self.numWays(i-1, k, fence)\n        return count\n\nclass Solution2:\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return fence[0] == fence[1] and fence[0] or fence[1]\n        count = 0\n        for i in range(1, n+1):\n            if i == 1:\n                continue\n            if fence[i-1] == fence[i]:\n                count += self.numWays(i-1, k, fence)\n        return count\n\nclass Solution3:\n    def numWays(self, n, k, fence):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type fence: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return fence[0] == fence[1] and fence[0] or fence[1]\n        count = 0\n        for i in range(1, n+1):\n            if i == 1:\n                continue\n            if fence[i-1] == fence[i]:\n                count",
    "# https://www.hackerrank.com/challenges/fence-painting/problem\n\ndef fence_painting(n, k):\n    ways = 0\n    for i in range(n):\n        for j in range(n-i):\n            if i == j:\n                continue\n            if i+j == n-1:\n                ways += 1\n            else:\n                ways += (i+1) * (j+1)\n    return ways\n\n# print(fence_painting(4, 2))\n\nprint(fence_painting(3, 2))",
    "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if n == k:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n*(n-1)\n        if k == 3:\n            return n*(n-1)*(n-2)\n        if k == 4:\n            return n*(n-1)*(n-2)*(n-3)\n        if k == 5:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)\n        if k == 6:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)\n        if k == 7:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)\n        if k == 8:\n            return n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5)*(n-6)*(n-7)\n        return self.numWays(n-1, k-1) + self.numWays(n-1, k-2)\n\nif __name__ == '__main__':\n    print Solution().numWays(4, 3)"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}