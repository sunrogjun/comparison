{
  "problem": {
    "task_id": "MBPP/272",
    "prompt": "Write a function to perfom the rear element extraction from list of tuples records.",
    "canonical_solution": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ",
    "test_list": [
      "assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]",
      "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]",
      "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"
    ],
    "challenge_test_list": [],
    "problem_id": 261
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "class Solution:\n    # @param {List[List[int]]} matrix\n    # @return {void} Do not return anything, modify matrix in-place instead.\n    def reverseList(self, matrix):\n        if not matrix or not matrix[0]:\n            return\n        n = len(matrix)\n        for i in xrange(n/2):\n            j = n - 1 - i\n            tmp = matrix[i][0]\n            matrix[i][0] = matrix[j][0]\n            matrix[j][0] = tmp\n            tmp = matrix[i][1]\n            matrix[i][1] = matrix[j][1]\n            matrix[j][1] = tmp\n            tmp = matrix[i][2]\n            matrix[i][2] = matrix[j][2]\n            matrix[j][2] = tmp\n\n    def reverseList_2(self, matrix):\n        if not matrix or not matrix[0]:\n            return\n        n = len(matrix)\n        for i in xrange(n/2):\n            j = n - 1 - i\n            tmp = matrix[i][0]\n            matrix[i][0] = matrix[j][0]\n            matrix[j][0] = tmp\n            tmp = matrix[i][1]\n            matrix[i][1] = matrix[j][1]\n            matrix[j][1] = tmp\n            tmp = matrix[i][2]\n            matrix[i][2] = matrix[j][2]\n            matrix[j][2] = tmp\n            tmp = matrix[i][3]\n            matrix[i][3] = matrix[j][3]\n            matrix[j][3] = tmp\n\n    def reverseList_3(self, matrix):\n        if not matrix or not matrix[0]:\n            return\n        n = len(matrix)\n        for i in xrange(n/2):\n            j = n - 1 - i\n            tmp = matrix[i][0]\n            matrix[i][0] = matrix[j][0]\n            matrix[j][0] = tmp\n            tmp = matrix[i][1]",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\nclass Solution(object):\n    def findRearOccurence(self, nums, k):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        n = len(nums)\n        if k > n:\n            return -1\n        if k == 1:\n            return nums[0].x\n        if k == n:\n            return nums[-1].x\n        left = 0\n        right = n - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid].x < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return nums[right].x",
    "from collections import defaultdict\nfrom itertools import islice\n\ndef extract_rear(records):\n    \"\"\"\n    Extract the rear element from a list of tuples records.\n\n    :param records: A list of tuples records.\n    :return: A list of records without the rear element.\n    \"\"\"\n    return [t for t in records if t[0]!= records[-1][0]]\n\ndef extract_rear_records(records):\n    \"\"\"\n    Extract the rear element records from a list of tuples records.\n\n    :param records: A list of tuples records.\n    :return: A list of records without the rear element.\n    \"\"\"\n    return [t for t in records if t[0]!= records[-1][0]]\n\ndef extract_rear_records_with_count(records):\n    \"\"\"\n    Extract the rear element records from a list of tuples records.\n\n    :param records: A list of tuples records.\n    :return: A list of records without the rear element.\n    \"\"\"\n    return [t for t in records if t[0]!= records[-1][0]]\n\ndef extract_rear_records_with_count_from_list(records):\n    \"\"\"\n    Extract the rear element records from a list of tuples records.\n\n    :param records: A list of tuples records.\n    :return: A list of records without the rear element.\n    \"\"\"\n    return [t for t in records if t[0]!= records[-1][0]]\n\ndef extract_rear_records_with_count_from_list_with_count(records):\n    \"\"\"\n    Extract the rear element records from a list of tuples records.\n\n    :param records: A list of tuples records.\n    :return: A list of records without the rear element.\n    \"\"\"\n    return [t for t in records if t[0]!= records[-1][0]]\n\ndef extract_rear_records_from_list(records):\n    \"\"\"\n    Extract the rear element records from a list of tuples records.\n\n    :param records: A list of tuples records.",
    "def get_rear(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\ndef get_rear_records(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\ndef get_rear_tuples(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\ndef get_rear_records_tuples(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\ndef get_rear_tuples_records(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\ndef get_rear_tuples_tuples(tup_list):\n    \"\"\"\n    tup_list: list of tuples\n    return: list of lists with the rear element\n    \"\"\"\n    return tup_list[-1]\n\nif __name__ == \"__main__\":\n    tup_list = [(1,2),(3,4),(5,6)]\n    print get_rear(tup_list)\n    print get_rear_records(tup_list)\n    print get_rear_tuples(tup_list)\n    print get_rear_records_tuples(tup_list)\n    print get_rear_tuples_tuples(tup_list)\n    print get_rear_tuples_records(tup_list)",
    "class Solution:\n    # @param {List[Tuple[int, int]]} head\n    # @param {int} target\n    # @return {List[int]}\n    def getRearElements(self, head, target):\n        res = []\n        dummy = [None]\n        dummy[0] = head\n        while dummy[0]:\n            cur = dummy[0]\n            if cur[0] == target:\n                res.append(cur[1])\n                dummy[0] = cur[2]\n            else:\n                dummy[0] = cur[2]\n        return res",
    "#!/usr/bin/python\n\n# #################################################################################\n# #################################################################################\n#\n#  Copyright (c) 2017-2019 Francesco Napolitano, Francesco D'Aquino\n#  Nuovamente Dato e Travbato\n#  Distributed under the MIT license\n#  See the LICENSE file at the root of this distribution\n#  or http://opensource.org/licenses/mit-license.php\n#\n# #################################################################################\n# #################################################################################\n\n\nimport sys\nimport csv\n\n\ndef main():\n    \"\"\"\n    Write a function to perfom the rear element extraction from list of tuples records.\n    \"\"\"\n\n    # ###########################################################################\n    # ###########################################################################\n\n    # read input from file\n    with open('input.txt', 'r') as f:\n        records = csv.reader(f)\n\n        for record in records:\n            print(rear_element(record))\n\n\ndef rear_element(record):\n    \"\"\"\n    Extract the rear element from a list of tuples records.\n    \"\"\"\n\n    # check if the list has elements\n    if len(record) > 1:\n\n        # extract the rear element\n        rear_element = record[-1]\n\n        # return the rear element\n        return rear_element\n\n    # otherwise return None\n    else:\n        return None\n\n\n# ###########################################################################\n# ###########################################################################\n#\n#  Main\n#\n# ###########################################################################\n# ###########################################################################\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution(object):\n    def reverse(self, l):\n        \"\"\"\n        :type l: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        ret = []\n        for i in range(len(l)):\n            ret.append(l[i][0], l[i][1])\n        return ret\n\n    def rearrange(self, l):\n        \"\"\"\n        :type l: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        res = []\n        for i in range(len(l)):\n            for j in range(i):\n                if l[i][0] > l[j][0]:\n                    res.append((l[j][0], l[i][1]))\n        return res\n\n\nif __name__ == '__main__':\n    print Solution().rearrange([(1,2),(3,4),(5,6),(7,8)])",
    "def rear_element_extraction(list_of_tuples):\n    \"\"\"\n    Input: list of tuples.\n    Output: rear element.\n    \"\"\"\n    if len(list_of_tuples) > 0:\n        return list_of_tuples[0][1]\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    list_of_tuples = [('John', 'Doe'), ('Jane', 'Smith'), ('Peter', 'Jones'), ('Tom', 'Jones'), ('Mary', 'Jones'), ('John', 'Doe')]\n    print rear_element_extraction(list_of_tuples)",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def getRear(self, nums):\n        # write your code here\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        # if n == 2:\n        #     return min(nums)\n        # if n == 3:\n        #     return min(nums)\n        # if n == 4:\n        #     return min(nums)\n        # if n == 5:\n        #     return min(nums)\n        # if n == 6:\n        #     return min(nums)\n        # if n == 7:\n        #     return min(nums)\n        if n == 8:\n            return min(nums)\n        # if n == 9:\n        #     return min(nums)\n        # if n == 10:\n        #     return min(nums)\n        # if n == 11:\n        #     return min(nums)\n        # if n == 12:\n        #     return min(nums)\n        # if n == 13:\n        #     return min(nums)\n        # if n == 14:\n        #     return min(nums)\n        # if n == 15:\n        #     return min(nums)\n        # if n == 16:\n        #     return min(nums)\n        # if n == 17:\n        #     return min(nums)\n        # if n == 18:\n        #     return min(nums)\n        # if n == 19:\n        #     return min(nums)\n        # if n == 20:\n        #     return min(nums)\n        # if n == 21:\n        #     return min(nums)\n        # if n == 22:\n        #     return min(nums)\n        # if n == 23:\n        #     return min(nums)\n        # if n == 24:\n        #     return min(nums)\n        # if n == 25:\n        #     return min(nums)\n        # if n ==",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\nclass Solution(object):\n    def rearEl(self, A):\n        \"\"\"\n        :type A: List[Tuple]\n        :rtype: Tuple\n        \"\"\"\n        res = Tuple(None)\n        for i in xrange(len(A)):\n            if i == 0:\n                res.x = A[0]\n                res.y = A[1]\n            else:\n                res.x = A[i-1]\n                res.y = A[i]\n            if res.x == None:\n                return res\n        return res",
    "class Solution:\n    \"\"\"\n    @param: head is the head of list\n    @param: rear is the rear of list\n    @return: a tuple of two list\n    \"\"\"\n    def getRear(self, head, rear):\n        \"\"\"\n        :type head: ListNode\n        :type rear: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        pre_dummy = dummy\n        while pre_dummy.next and pre_dummy.next.next:\n            pre_dummy = pre_dummy.next\n        pre_dummy.next = rear\n        return dummy.next",
    "class Solution(object):\n    def getRecords(self, records):\n        \"\"\"\n        :type records: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        result = []\n        for i in range(len(records)):\n            if i == 0:\n                result.append(records[i])\n            else:\n                result.append(records[i-1])\n        return result\n\n    def getRecords2(self, records):\n        \"\"\"\n        :type records: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        result = []\n        for i in range(len(records)):\n            if i == 0:\n                result.append(records[i])\n            else:\n                result.append(records[i-1])\n            if i!= 0 and i!= len(records) - 1:\n                result.append(records[i])\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    records = [(-1, -1), (-1, -2), (1, -1), (1, -2), (2, -1), (2, -2)]\n    print(s.getRecords(records))\n    records = [(-1, -1), (-1, -2), (1, -1), (1, -2), (2, -1), (2, -2)]\n    print(s.getRecords2(records))",
    "import unittest\nfrom collections import namedtuple\n\nclass TestCase(unittest.TestCase):\n\n    def test_rear_element_extraction(self):\n        #Given\n        tuple_ = namedtuple('tuple', ['a', 'b', 'c'])\n        tuple_list = [\n            (1, 2, 3),\n            (2, 3, 4),\n            (3, 4, 5)\n        ]\n        #When\n        result = list(rear_element_extraction(tuple_list))\n        #Then\n        self.assertEqual(result, [(3, 4, 5)])\n\n    def test_rear_element_extraction_empty_list(self):\n        #Given\n        tuple_list = []\n        #When\n        result = list(rear_element_extraction(tuple_list))\n        #Then\n        self.assertEqual(result, [])\n\n    def test_rear_element_extraction_not_a_tuple(self):\n        #Given\n        tuple_ = namedtuple('tuple', ['a', 'b', 'c'])\n        tuple_list = [\n            (1, 2, 3),\n            (2, 3, 4),\n            (3, 4, 5)\n        ]\n        #When\n        result = list(rear_element_extraction(tuple_list))\n        #Then\n        self.assertEqual(result, [(3, 4, 5)])\n\nif __name__ == '__main__':\n    unittest.main()",
    "from collections import namedtuple\n\nRecord = namedtuple('Record', 'name, score, age')\n\ndef get_rear_element(records):\n    \"\"\"\n    Get the rear element of the list of tuples records.\n    :param records: A list of tuples records.\n    :return: The rear element of the list.\n    \"\"\"\n    return next(reversed(records), None)\n\ndef test():\n    records = [\n        Record(name='Amit', score=90, age=25),\n        Record(name='Arvind', score=70, age=50),\n        Record(name='Babu', score=80, age=70),\n        Record(name='Bhushan', score=90, age=40),\n        Record(name='Girish', score=80, age=20),\n        Record(name='Harsha', score=85, age=45),\n        Record(name='Jain', score=60, age=20),\n        Record(name='Krishna', score=80, age=50),\n        Record(name='Manoj', score=70, age=40),\n        Record(name='Narendra', score=80, age=40),\n        Record(name='Puneeth', score=85, age=35),\n        Record(name='Sarvada', score=80, age=30),\n        Record(name='Siddhartha', score=85, age=35),\n        Record(name='Srinivas', score=80, age=30),\n        Record(name='Tushar', score=80, age=30),\n        Record(name='Vijayakumar', score=80, age=30),\n        Record(name='Vivek', score=80, age=30),\n        Record(name='Yashdeep', score=80, age=30),\n        Record(name='Yashwant', score=80, age=30),\n        Record(name='Yashwant', score=80, age=30),\n        Record(name='Yashwant', score=80, age=30),\n        Record(name='Yashwant', score=80, age=30),\n        Record(name='Yash",
    "from collections import namedtuple\n\nclass Record(namedtuple('Record', 'date,time,total,rear')):\n    __slots__ = ()\n\n    def __new__(cls, date, time, total, rear):\n        return super(Record, cls).__new__(cls, date, time, total, rear)\n\n    def __repr__(self):\n        return '{} {} {}'.format(self.date, self.time, self.total)\n\ndef rear_extraction(records):\n    \"\"\"\n    Input: list of records\n    Output: list of rear records\n    \"\"\"\n\n    # Sort the records\n    records.sort(key=lambda x: x.date)\n\n    # Get the last element\n    last_record = records[-1]\n\n    # Extract the rear element from the last record\n    rear_element = Record(last_record.date, last_record.time, last_record.total, last_record.rear)\n\n    # Return the rear element\n    return rear_element\n\nif __name__ == '__main__':\n    # Test case\n    records = [\n        Record(2016, 3, 200, 0),\n        Record(2016, 2, 200, 0),\n        Record(2016, 1, 200, 0),\n        Record(2016, 0, 200, 0),\n        Record(2015, 2, 200, 0),\n        Record(2015, 1, 200, 0),\n        Record(2014, 2, 200, 0),\n        Record(2014, 1, 200, 0),\n        Record(2013, 2, 200, 0),\n        Record(2013, 1, 200, 0),\n        Record(2012, 2, 200, 0),\n        Record(2012, 1, 200, 0),\n        Record(2011, 2, 200, 0),\n        Record(2011, 1, 200, 0),\n        Record(2010, 2, 200, 0),\n        Record(2010, 1, 200, 0),\n        Record(2009, 2, 200, 0),\n        Record(2009, 1, 200, 0),\n        Record(2008, 2, 200, 0),\n        Record(2008, 1, 200, 0),\n        Record(2007,",
    "import sys\n\ndef extract_rear(tuple_list):\n    \"\"\"\n    tuple_list is a list of tuples.\n    \"\"\"\n    return tuple_list[-1]\n\nif __name__ == '__main__':\n    tuple_list = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n    print(extract_rear(tuple_list))\n    print(extract_rear(tuple_list[::-1]))",
    "def extractRear(list):\n    if len(list) == 0:\n        return []\n    for i in range(0, len(list) - 1):\n        if list[i][1] == list[i + 1][0]:\n            return list[i]\n    return []\n\nif __name__ == \"__main__\":\n    list = [(\"A\", 1), (\"B\", 2), (\"C\", 3)]\n    print extractRear(list)",
    "def rear_element(tuples):\n    for i in reversed(range(len(tuples))):\n        yield tuples[i]\n\ndef test_rear_element():\n    tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    for t in rear_element(tuples):\n        assert t == (7, 8, 9)\n\ndef test_rear_element_empty():\n    tuples = []\n    for t in rear_element(tuples):\n        assert t == None\n\ndef test_rear_element_not_list():\n    tuples = 'not a list'\n    for t in rear_element(tuples):\n        assert t == None\n\ndef test_rear_element_not_tuple():\n    tuples = (1, 2, 3)\n    for t in rear_element(tuples):\n        assert t == None",
    "from collections import namedtuple\n\n\ndef find_rear_element(tuple_list):\n    \"\"\"\n    tuple_list = [(1,2),(4,5),(6,7)]\n    find_rear_element(tuple_list) == (7,6)\n    \"\"\"\n    if not tuple_list:\n        return None\n    elif len(tuple_list) == 1:\n        return tuple_list[0]\n    elif len(tuple_list) == 2:\n        return tuple_list[1]\n    else:\n        return tuple_list[len(tuple_list) - 1]\n\n\ndef test_find_rear_element():\n    assert find_rear_element([]) == None\n    assert find_rear_element([(1,2)]) == (2,1)\n    assert find_rear_element([(1,2),(3,4)]) == (4,3)\n    assert find_rear_element([(1,2),(3,4),(5,6)]) == (6,5)\n    assert find_rear_element([(1,2),(3,4),(5,6),(7,8)]) == (8,7)\n    assert find_rear_element([(1,2),(3,4),(5,6),(7,8),(9,10)]) == (10,9)\n    assert find_rear_element([(1,2),(3,4),(5,6),(7,8),(9,10),(11,12)]) == (12,11)\n\n\nif __name__ == '__main__':\n    tuple_list = [\n        (1,2),\n        (4,5),\n        (6,7),\n        (8,9),\n        (10,11),\n        (12,13),\n        (14,15),\n        (16,17),\n        (18,19),\n        (20,21),\n        (22,23),\n        (24,25),\n        (26,27),\n        (28,29),\n        (30,31),\n        (32,33",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution:\n    def extract(self, t, n):\n        \"\"\"\n        :type t: List[Tuple]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if n == 0:\n            return []\n        res = []\n        for i in range(n):\n            res.append(t[n-i-1].x)\n        return res",
    "def rear_element(arr):\n    \"\"\"\n    :param arr: list of tuples of (number, number)\n    :return: the element at the end of the list\n    \"\"\"\n    return arr[-1]\n\n\nif __name__ == \"__main__\":\n    test_list = [\n        (1, 1),\n        (2, 1),\n        (3, 2),\n        (4, 2),\n        (5, 3),\n        (6, 3),\n        (7, 4),\n        (8, 4),\n        (9, 5),\n        (10, 5),\n        (11, 6),\n        (12, 6),\n        (13, 7),\n        (14, 7),\n        (15, 8),\n        (16, 8),\n        (17, 9),\n        (18, 9),\n        (19, 10),\n        (20, 10),\n        (21, 11),\n        (22, 11),\n        (23, 12),\n        (24, 12),\n        (25, 13),\n        (26, 13),\n        (27, 14),\n        (28, 14),\n        (29, 15),\n        (30, 15),\n        (31, 16),\n        (32, 16),\n        (33, 17),\n        (34, 17),\n        (35, 18),\n        (36, 18),\n        (37, 19),\n        (38, 19),\n        (39, 20),\n        (40, 20),\n        (41, 21),\n        (42, 21),\n        (43, 22),\n        (44, 22),\n        (45, 23),\n        (46, 23),\n        (47, 24),\n        (48, 24),\n        (49, 25),\n        (50, 25),\n        (51, 26),\n        (52, 26),\n        (53, 27),\n        (54, 27),\n        (55, 28),\n        (56, 28),\n        (57, 29),\n        (58, 29),\n        (59, 30),\n        (60, 30),\n        (61, 31),\n        (62, 31),\n        (63, 32),",
    "# https://www.hackerrank.com/challenges/rear-element-extraction\n# The input is a list of tuples where the first element of each tuple is the number of times\n# that element appears in the list and the second element is the element itself.\n\ndef rear_element_extraction(input):\n    for i in range(len(input)-1, -1, -1):\n        print(input[i][1])\n\n# sample input\n# [(2, 'a'), (1, 'b'), (3, 'c'), (2, 'd'), (1, 'e'), (3, 'f'), (1, 'g'), (2, 'h'), (1, 'i'), (3, 'j'), (2, 'k'), (1, 'l'), (3,'m'), (2, 'n'), (1, 'o'), (3, 'p'), (2, 'q'), (1, 'r'), (3,'s'), (2, 't'), (1, 'u'), (3, 'v'), (2, 'w'), (1, 'x'), (3, 'y'), (2, 'z'), (1, 'A'), (3, 'B'), (2, 'C'), (1, 'D'), (3, 'E'), (2, 'F'), (1, 'G'), (3, 'H'), (2, 'I'), (1, 'J'), (3, 'K'), (2, 'L'), (1, 'M'), (3, 'N'), (2, 'O'), (1, 'P'), (3, 'Q'), (2, 'R'), (1, 'S'), (3, 'T'), (2, 'U'), (1, 'V'), (3, 'W'), (2, 'X'), (1, 'Y'), (3, 'Z')]\n\n# sample output\n# [2, 'a', 1, 'b', 3, 'c', 2, 'd', 1, 'e', 3, 'f', 1, 'g', 2, 'h', 1, 'i', 3, 'j', 2, 'k', 1, 'l', 3,'m', 2, 'n', 1, 'o', 3, 'p', 2,",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def reverseTuples(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        return self.reverse_nums(nums)\n\n    def reverse_nums(self, nums):\n        nums.reverse()\n        return nums",
    "class Solution:\n    \"\"\"\n    @param: ListNode: A list node\n    @return: ListNode\n    \"\"\"\n    def reverse(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        cur = head\n        next = head.next\n        while next.next:\n            cur.next = next.next\n            cur = cur.next\n            next = next.next\n        cur.next = None\n        return head",
    "def extract_rear(records):\n    \"\"\"\n    Extract the rear element from a list of tuples records.\n    \"\"\"\n    return records[0]\n\n# Test cases\n\nrecords = [(1,2,3),(4,5,6),(7,8,9),(10,11,12)]\n\nprint extract_rear(records)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def extractRear(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return nums[-1][0]",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def getRear(self, L):\n        \"\"\"\n        :type L: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return max(i for i,t in enumerate(L) if t[1]==L[-1][1])\n\ns = Solution()\nt = Tuple(1,1)\nt2 = Tuple(2,1)\nt3 = Tuple(1,2)\nt4 = Tuple(1,1)\nt5 = Tuple(1,1)\nt6 = Tuple(2,2)\nt7 = Tuple(3,1)\nt8 = Tuple(1,2)\nt9 = Tuple(1,2)\nt10 = Tuple(1,1)\nt11 = Tuple(1,1)\nt12 = Tuple(2,2)\nt13 = Tuple(1,2)\nt14 = Tuple(1,1)\nt15 = Tuple(1,1)\nt16 = Tuple(2,2)\nt17 = Tuple(1,2)\nt18 = Tuple(1,2)\nt19 = Tuple(1,1)\nt20 = Tuple(1,1)\nt21 = Tuple(1,1)\nt22 = Tuple(1,1)\nt23 = Tuple(1,1)\nt24 = Tuple(1,1)\nt25 = Tuple(1,1)\nt26 = Tuple(1,1)\nt27 = Tuple(1,1)\nt28 = Tuple(1,1)\nt29 = Tuple(1,1)\nt30 = Tuple(1,1)\nt31 = Tuple(1,1)\nt32 = Tuple(1,1)\nt33 = Tuple(1,1)\nt34 = Tuple(1,1)\nt35 = Tuple(1,1)\nt36 = Tuple(1,1",
    "# Definition for a tuple\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def findRearOccurence(self, records):\n        \"\"\"\n        :type records: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if not records:\n            return None\n        n = len(records)\n        j = 0\n        for i in xrange(n-1, -1, -1):\n            if records[i].x == records[j].x:\n                j += 1\n            if records[i].x!= records[j].x:\n                return i\n        return None",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def extractRear(self, nums, k):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        if not nums or nums[0] == None or nums[-1] == None:\n            return res\n        i = 0\n        j = 0\n        while i < len(nums) - k:\n            while j < k:\n                if nums[i] == nums[j]:\n                    i += 1\n                    j += 1\n                else:\n                    j += 1\n            res.append(nums[i].x)\n            i += 1\n        return res",
    "class Solution:\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return nums[-1]",
    "def rear_extraction(list_tuples):\n    \"\"\"\n    Return the rear element of list of tuples.\n    \"\"\"\n    # TODO: write code\n    return\n\n\nif __name__ == '__main__':\n    list_tuples = [(1, 2), (3, 4), (5, 6)]\n    print rear_extraction(list_tuples)",
    "def rear_element(records):\n    for i, record in enumerate(records):\n        if i == 0:\n            return record[0]\n        else:\n            return record[1]\n\n\nrecords = [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')]\nprint rear_element(records)",
    "def get_rear_tuple(tuple_list):\n    \"\"\"\n    Get the rear element from a list of tuples.\n    \"\"\"\n    return tuple_list[-1]\n\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get_rear_tuple([(1, 2), (3, 4), (5, 6)]) == (6, 5), \"Example\"\n    assert get",
    "#\n# Definition for a tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.y = y\n#\n#     def __repr__(self):\n#         return \"Tuple(%s)\" % (self.x)\n#\n\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if not x:\n            return []\n        return [y for x in reversed(x) for y in x]",
    "def rear_element(records):\n    return records[-1]\n\ndef rear_element_with_index(records):\n    return records[-1][1]\n\ndef test_rear_element():\n    assert rear_element([(1,2,3,4),(5,6,7,8)]) == (5,6,7,8)\n    assert rear_element_with_index([(1,2,3,4),(5,6,7,8)]) == (5,6,7,8)\n\ndef test_rear_element_with_index():\n    assert rear_element_with_index([(1,2,3,4),(5,6,7,8)]) == (5,6,7,8)\n    assert rear_element_with_index([(1,2,3,4),(5,6,7,8)]) == (5,6,7,8)\n\nif __name__ == \"__main__\":\n    test_rear_element()\n    test_rear_element_with_index()",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        nums = sorted(nums, reverse=True)\n        return nums[0]",
    "def extract_rear(records):\n    for record in records:\n        if record[-1] == record[0]:\n            return record[-1]\n\ndef main():\n    records = [\n        ('a', 'b', 'c'),\n        ('a', 'b', 'd'),\n        ('a', 'c', 'd'),\n        ('a', 'c', 'e'),\n        ('a', 'd', 'e'),\n        ('b', 'c', 'd'),\n        ('b', 'c', 'e'),\n        ('b', 'd', 'e'),\n        ('c', 'd', 'e'),\n        ('a', 'b', 'c'),\n        ('a', 'b', 'd'),\n        ('a', 'b', 'e'),\n        ('a', 'c', 'd'),\n        ('a', 'c', 'e'),\n        ('a', 'd', 'e'),\n        ('b', 'c', 'd'),\n        ('b', 'c', 'e'),\n        ('b', 'd', 'e'),\n        ('c', 'd', 'e')\n    ]\n    print extract_rear(records)\n\nif __name__ == \"__main__\":\n    main()",
    "def rear_element(list_of_tuples):\n    \"\"\"\n    list_of_tuples is a list of tuples with the format (name, age)\n    Returns the last element of the list.\n    \"\"\"\n    return list_of_tuples[-1]\n\n\nif __name__ == \"__main__\":\n    print rear_element([('Alice', 23), ('Bob', 34), ('Charlie', 45)])",
    "import unittest\nimport os\n\nfrom random import randint\n\n\ndef get_records(file_path):\n    with open(file_path, 'r') as f:\n        records = [line.strip().split(',') for line in f.readlines()]\n    return records\n\n\ndef get_records_with_doubles(file_path):\n    with open(file_path, 'r') as f:\n        records = [line.strip().split(',') for line in f.readlines()]\n    records = [(float(value), float(value)) for value in records]\n    return records\n\n\ndef extract_records_with_doubles(records):\n    return [(value, value) for value in records]\n\n\nclass TestRecordsExtraction(unittest.TestCase):\n\n    def test_extract_records_with_doubles(self):\n        records = get_records_with_doubles('test/input.txt')\n        extracted = extract_records_with_doubles(records)\n        self.assertEqual(extracted, [\n            (1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0),\n            (5.0, 5.0), (6.0, 6.0), (7.0, 7.0), (8.0, 8.0),\n            (9.0, 9.0), (10.0, 10.0), (11.0, 11.0), (12.0, 12.0),\n            (13.0, 13.0), (14.0, 14.0), (15.0, 15.0), (16.0, 16.0),\n            (17.0, 17.0), (18.0, 18.0), (19.0, 19.0), (20.0, 20.0),\n            (21.0, 21.0), (22.0, 22.0), (23.0, 23.0), (24.0, 24.0),\n            (25.0, 25.0), (26.0, 26.",
    "from collections import namedtuple\n\n\nclass Tuple(namedtuple('Tuple', 'name age')):\n    __slots__ = ()\n\n    def __new__(cls, *args):\n        return super(Tuple, cls).__new__(cls, *args)\n\n\nclass TestCase(unittest.TestCase):\n    def test(self):\n        tuples = (('Alice', 100), ('Bob', 50), ('Charlie', 120))\n        result = extract_rear(tuples)\n        self.assertEqual(result, ('Charlie', 120))\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "class ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution(object):\n    def extractRear(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p = head\n        while p.next:\n            p = p.next\n            \n        q = head\n        while q.next:\n            q = q.next.next\n            \n        p.next = q.next\n        q.next = None\n        return head",
    "class Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while pre.next:\n            next = pre.next.next\n            pre.next = next\n            next.next = pre\n            pre = next\n\n        return dummy.next\n\n    def reverse(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        pre, cur = head, head.next\n        while cur:\n            tmp = cur.next\n            cur.next = pre\n            pre = cur\n            cur = tmp\n        return pre\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef main():\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    print s.reverseList(head)\n    print s.reverse(head)\n\nif __name__ == '__main__':\n    main()",
    "def reverse_list(lst):\n    new_list = []\n    for i in range(len(lst)):\n        new_list.append(lst[i][0])\n    return new_list\n\ndef extract_rear(lst):\n    new_list = []\n    for i in range(len(lst)):\n        new_list.append(lst[-i-1][0])\n    return new_list\n\ndef main():\n    lst = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]\n    print(reverse_list(lst))\n    print(extract_rear(lst))\n\nif __name__ == '__main__':\n    main()",
    "from collections import namedtuple\n\ndef extract_rear(records):\n    \"\"\"\n    Extract the rear element from list of tuples records.\n\n    :type records: List[Tuple[int, int, int]]\n    :rtype: int\n    \"\"\"\n    return records[-1][1]\n\nif __name__ == '__main__':\n    records = [\n        (1, 2, 3),\n        (2, 4, 6),\n        (3, 6, 9),\n        (4, 8, 12),\n        (5, 10, 15),\n        (6, 12, 18),\n        (7, 14, 20),\n        (8, 16, 22),\n        (9, 18, 25),\n        (10, 20, 28),\n        (11, 22, 30)\n    ]\n\n    print extract_rear(records)",
    "def rear_element(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int, int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return None\n    return tuples[-1][2]",
    "def extract_rear_element(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: tuple\n    \"\"\"\n    return tuple_list[-1]\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    print(extract_rear_element(tuple_list))",
    "def rear_element_extraction(t):\n    \"\"\"\n    :type t: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return t[-1]\n\n# Your RearElementExtraction function should return the same output as\n# the following.\n\n# def rear_element_extraction(t):\n#     return t[-1]",
    "import collections\n\ndef extract_rear_element(list_of_tuples):\n    \"\"\"\n    list_of_tuples: list of tuples (e.g. (1, 2), (3, 4), (5, 6))\n    return: the rear element of the list\n    \"\"\"\n    rear_element = None\n    for i in range(0, len(list_of_tuples)):\n        if list_of_tuples[i][0] > list_of_tuples[i][1]:\n            rear_element = list_of_tuples[i][1]\n            break\n\n    return rear_element\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2),\n        (3, 4),\n        (5, 6),\n    ]\n\n    print extract_rear_element(tuples)\n    print extract_rear_element([(1, 2), (3, 4), (5, 6)])\n    print extract_rear_element([(1, 2), (3, 4), (5, 6), (7, 8)])\n    print extract_rear_element([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)])\n    print extract_rear_element([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12)])",
    "# https://www.hackerrank.com/challenges/extract-rear-element-from-list-of-tuples/problem\n\n#!/bin/python\nimport sys\n\nT = int(raw_input().strip())\n\nfor t in range(T):\n    n, m = map(int, raw_input().strip().split(' '))\n    arr = map(int, raw_input().strip().split(' '))\n    l = [x for x in arr if x!= -1]\n    r = [x for x in arr if x == -1]\n    print l[m]",
    "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport random\nimport sys\n\n# ----------------------------------------------------------------------\n#\n# ----------------------------------------------------------------------\n\ndef main():\n    \"\"\"\n    \"\"\"\n    data = [\n        (1, 2, 3, 4, 5),\n        (6, 7, 8, 9, 10),\n        (11, 12, 13, 14, 15),\n        (16, 17, 18, 19, 20),\n        (21, 22, 23, 24, 25),\n        (26, 27, 28, 29, 30),\n        (31, 32, 33, 34, 35),\n        (36, 37, 38, 39, 40),\n        (41, 42, 43, 44, 45),\n        (46, 47, 48, 49, 50),\n        (51, 52, 53, 54, 55),\n        (56, 57, 58, 59, 60),\n        (61, 62, 63, 64, 65),\n        (66, 67, 68, 69, 70),\n        (71, 72, 73, 74, 75),\n        (76, 77, 78, 79, 80),\n        (81, 82, 83, 84, 85),\n        (86, 87, 88, 89, 90),\n        (91, 92, 93, 94, 95),\n        (96, 97, 98, 99, 100),\n        (101, 102, 103, 104, 105),\n        (106, 107, 108, 109, 110),\n        (111, 112, 113, 114, 115),\n        (116, 117, 118, 119, 120),\n        (121, 122, 123, 124, 125),\n        (126, 127, 128, 129, 130),\n        (131, 132, 133, 134, 135),\n        (136, 137, 138, 139, 140),\n        (141, 142, 143, 144, 145),\n        (146, 147, 148, 149, 150),\n        (151, 152, 153, 154, 155),\n        (156, 157, 158, 159, 160),\n        (161, 162, 163, 164, 165),\n        (166, 167, 168, 169, 170),\n        (171, 172, 173, 174, 175),",
    "def rear(record_list):\n    \"\"\"\n    Args:\n        record_list (list): list of tuples records\n\n    Returns:\n        list: the rear element of the list\n    \"\"\"\n    return record_list[-1]\n\nif __name__ == '__main__':\n    \"\"\"\n    Sample Input:\n    [(1, 2), (3, 4), (5, 6)]\n    Sample Output:\n    6\n    \"\"\"\n    sample_input = [(1, 2), (3, 4), (5, 6)]\n    sample_output = 6\n    assert rear(sample_input) == sample_output, \"Sample Input: {}, Sample Output: {}\".format(sample_input, sample_output)",
    "#!/usr/bin/python\n\nimport sys\n\ndef extract(lst):\n    return lst[-1]\n\ndef main(args):\n    with open(args[0]) as f:\n        for line in f:\n            lst = line.strip().split(',')\n            print extract(lst)\n\nif __name__ == '__main__':\n    main(sys.argv[1:])",
    "# https://www.hackerrank.com/challenges/rearranging-the-list/problem\n\n# Complete the rearrange function below.\ndef rearrange(records):\n    return [tuple(records[i:i+2]) for i in range(0, len(records), 2)]\n\n\nif __name__ == '__main__':\n    with open(\"input.txt\", \"r\") as f:\n        n = int(f.readline())\n        records = [map(int, s.split(' ')) for s in f.readline().split(' ')]\n    result = rearrange(records)\n    print(result)",
    "# Example\n# [('John', 'Smith', 'john.smith@example.com'), ('Jane', 'Doe', 'jane.doe@example.com'), ('John', 'Smith', 'john.smith@example.com')]\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n\n# Output\n# [['john.smith@example.com', 'jane.doe@example.com']]\n\n# Input\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n\n# Output\n# [['john.smith@example.com', 'jane.doe@example.com']]\n\n# Input\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n\n# Output\n# [['john.smith@example.com', 'jane.doe@example.com']]\n\n# Input\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'], ['John', 'Smith', 'john.smith@example.com']]\n# [['John', 'Smith', 'john.smith@example.com'], ['Jane', 'Doe', 'jane.doe@example.com'",
    "from collections import namedtuple\n\n# Your code here\n\ndef extract_rear(t):\n    return t[-1]\n\ndef test_extract_rear():\n    t = [('a', 1), ('b', 2), ('c', 3)]\n    assert extract_rear(t) == 'c'\n\ndef extract_rear_tuple(t):\n    return t[-1]\n\ndef test_extract_rear_tuple():\n    t = namedtuple('t', 'a b c')\n    assert extract_rear_tuple(t(1, 2, 3)) == 'c'\n\ndef extract_rear_list(t):\n    return t[-1]\n\ndef test_extract_rear_list():\n    t = [('a', 1), ('b', 2), ('c', 3)]\n    assert extract_rear_list(t) == 'c'\n\ndef extract_rear_tuple_list(t):\n    return t[-1]\n\ndef test_extract_rear_tuple_list():\n    t = namedtuple('t', 'a b c')\n    assert extract_rear_tuple_list(t(1, 2, 3)) == 'c'\n\ndef extract_rear_list_list(t):\n    return t[-1]\n\ndef test_extract_rear_list_list():\n    t = [('a', 1), ('b', 2), ('c', 3)]\n    assert extract_rear_list_list(t) == 'c'\n\ndef extract_rear_tuple_list_list(t):\n    return t[-1]\n\ndef test_extract_rear_tuple_list_list():\n    t = namedtuple('t', 'a b c')\n    assert extract_rear_tuple_list_list(t(1, 2, 3)) == 'c'",
    "def rear_element(lst):\n\tif not lst:\n\t\treturn None\n\treturn lst[-1]\n\nif __name__ == '__main__':\n\tlst = [(1,2),(3,4),(5,6)]\n\tprint rear_element(lst)\n\tlst = [1,2,3]\n\tprint rear_element(lst)",
    "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return str((self.x, self.y))\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(tuple_list)\n# param_1 = obj.extract(tuple_list)\n\ndef extract(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return [tuple_list[-1]]",
    "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def rpop(self, nums):\n        if not nums or len(nums) == 0:\n            return -1\n\n        idx = 0\n        while True:\n            idx += 1\n            if idx >= len(nums):\n                break\n            if nums[idx-1] == nums[idx]:\n                return nums[idx-1]\n        return -1\n\n    def rpop(self, nums):\n        if not nums or len(nums) == 0:\n            return -1\n\n        idx = 0\n        while True:\n            idx += 1\n            if idx >= len(nums):\n                break\n            if nums[idx-1] == nums[idx]:\n                return nums[idx-1]\n        return -1",
    "def rear_extraction(input_list):\n    return input_list[-1]\n\n\"\"\"\nWrite a function to perform the insertion of the front element into the rear of a list of tuples records.\n\"\"\"\ndef rear_insertion(input_list, new_tuple):\n    return input_list[:-1] + [new_tuple]\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_insertion(input_list, new_tuple):\n    return [new_tuple] + input_list\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_extraction(input_list):\n    return input_list[1:]\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_insertion(input_list, new_tuple):\n    return [new_tuple] + input_list\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_extraction(input_list):\n    return input_list[:-1]\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_insertion(input_list, new_tuple):\n    return [new_tuple] + input_list\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_extraction(input_list):\n    return input_list[1:]\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef front_insertion(input_list, new_tuple):\n    return [new_tuple] + input_list\n\n\"\"\"\nWrite a function to perform the insertion of the rear element into the front of a list of tuples records.\n\"\"\"\ndef rear_insertion(input_list, new_tuple):\n    return [new_tuple] + input_list",
    "def extract_rear(tuple_list):\n    \"\"\"\n    >>> extract_rear([(1, 2), (3, 4), (5, 6)])\n    (6, 5)\n    >>> extract_rear([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    >>> extract_rear([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    >>> extract_rear([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    >>> extract_rear([(1, 2), (3, 4), (5, 6)])\n    (5, 6)\n    \"\"\"\n    return tuple_list[-1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# TODO: write a function to extract the rear element from a list of tuples.\n\n# Example\n# Given a list of tuples like this: [(1,2),(3,4),(5,6)]\n# extract the second element from the list of tuples.\n# You should return a list of two elements [2,6].\n#\n# Example:\n# Given a list of tuples like this: [(1,2),(3,4),(5,6)]\n# extract the second element from the list of tuples.\n# You should return a list of two elements [2,6].\n#\n# Example:\n# Given a list of tuples like this: [(1,2),(3,4),(5,6)]\n# extract the second element from the list of tuples.\n# You should return a list of two elements [2,6].\n\nclass Solution(object):\n    def extractSecondFromList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [nums[1]] + nums[2:]",
    "import collections\n\ndef extract_rear(l):\n    \"\"\"\n    Given a list of tuples, extract the rear element.\n    \"\"\"\n    return l[-1]\n\ndef extract_rear_recursive(l):\n    \"\"\"\n    Given a list of tuples, extract the rear element.\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return extract_rear_recursive(l[:-1]) + (l[-1],)\n\ndef test():\n    assert extract_rear((1,2,3,4,5)) == (5,4,3,2,1)\n    assert extract_rear_recursive((1,2,3,4,5)) == (5,4,3,2,1)\n\nif __name__ == '__main__':\n    test()",
    "def rear(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear element of a list.\n    \"\"\"\n    return lst[-1]\n\ndef front(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the front element of a list.\n    \"\"\"\n    return lst[0]\n\ndef middle(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the middle element of a list.\n    \"\"\"\n    return lst[len(lst)//2]\n\ndef rear_and_front(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and front element of a list.\n    \"\"\"\n    return rear(lst), front(lst)\n\ndef rear_and_middle(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and middle element of a list.\n    \"\"\"\n    return rear(lst), middle(lst)\n\ndef rear_and_middle_and_front(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and middle element of a list.\n    \"\"\"\n    return rear(lst), middle(lst), front(lst)\n\ndef rear_and_middle_and_front_and_rear(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and middle element of a list.\n    \"\"\"\n    return rear(lst), middle(lst), front(lst), rear(lst)\n\ndef rear_and_middle_and_front_and_rear_and_front(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and middle element of a list.\n    \"\"\"\n    return rear(lst), middle(lst), front(lst), rear(lst), front(lst)\n\ndef rear_and_middle_and_front_and_rear_and_front_and_rear(lst):\n    \"\"\"\n    lst is a list of tuples.\n    Return the rear and middle",
    "#!/usr/bin/python\n\ndef extractRearElement(listOfTuples):\n    return listOfTuples[-1]\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7,8)]\n# Sample Output\n# (7,8)\n\n# Sample Input\n# [(1,2),(3,4),(5,6),(7",
    "from collections import namedtuple\n\nclass TupleRecord(namedtuple('TupleRecord', 'f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12')):\n    pass\n\ndef extract_rear_element(lst):\n    \"\"\"\n    lst is a list of tuple records\n    returns a tuple record\n    \"\"\"\n    return lst[-1]\n\ndef main():\n    lst = [\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n        (1, 2, 3, 4, 5, 6,",
    "# https://www.hackerrank.com/challenges/list-of-tuples-extraction-rear\n# https://www.youtube.com/watch?v=9T_jwSXd5Yw\ndef list_of_tuples_extraction_rear(list_of_tuples):\n    \"\"\"\n    Input: A list of tuples.\n    Output: A list of the rear element.\n    \"\"\"\n    # Initialize a list for the rear element.\n    rear_element = []\n    # Iterate over the list of tuples.\n    for i in list_of_tuples:\n        # If the current index is greater than the rear element,\n        # append the current element to the rear element.\n        if i[0] > rear_element[-1]:\n            rear_element.append(i[1])\n        # If the current index is less than the rear element,\n        # append the current element to the rear element.\n        elif i[0] < rear_element[-1]:\n            rear_element.append(i[1])\n    # Return the rear element.\n    return rear_element",
    "# https://www.hackerrank.com/challenges/rear-element-extraction\n\ndef rear_element_extraction(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    for i in reversed(list_of_tuples):\n        if i[0]!= 0:\n            return i[0]\n    return 0\n\n\nif __name__ == '__main__':\n    with open(\"input.txt\") as f:\n        n = int(f.readline())\n        for _ in range(n):\n            nums = list(map(int, f.readline().split()))\n            list_of_tuples = list(zip(nums, nums[1:]))\n            print(rear_element_extraction(list_of_tuples))",
    "def extract_rear(record_list):\n    \"\"\"\n    :param record_list: List of tuples of (x, y, z)\n    :return: List of tuples of (x, y, z, rear)\n    \"\"\"\n    return record_list[-1:]\n\n\ndef test_extract_rear():\n    assert extract_rear([(1, 2, 3), (2, 3, 4), (3, 4, 5)]) == [(2, 3, 4, 5), (3, 4, 5, 1), (4, 5, 1, 2)]\n\nif __name__ == '__main__':\n    test_extract_rear()",
    "def rear_element(tuple_list):\n    \"\"\"\n    :param tuple_list: List of tuples records\n    :return: Return the rear element of the tuple list\n    \"\"\"\n    return tuple_list[-1]\n\n\ndef main():\n    \"\"\"\n    Write a function to perfom the rear element extraction from list of tuples records.\n    \"\"\"\n    tuple_list = [(1, 2), (3, 4), (5, 6)]\n\n    print rear_element(tuple_list)\n\nif __name__ == \"__main__\":\n    main()",
    "class Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums or len(nums) == 0:\n            return 0\n        \n        nums = sorted(nums)\n        return nums[-1]",
    "def extract_rear(records):\n    \"\"\"\n    :param records: A list of records in format (1,2,3,4,5)\n    :return: A list of elements from the rear, e.g. [(5,4,3,2,1)]\n    \"\"\"\n    return [records[-1]] + records[:-1]\n\nif __name__ == \"__main__\":\n    assert extract_rear([1,2,3,4,5]) == [(5,4,3,2,1)]\n    assert extract_rear([1,2,3,4,5,6]) == [(5,4,3,2,1), (6,5,4,3,2)]\n    assert extract_rear([1,2,3,4,5,6,7]) == [(5,4,3,2,1), (6,5,4,3,2), (7,6,5,4,3)]\n    assert extract_rear([1,2,3,4,5,6,7,8]) == [(5,4,3,2,1), (6,5,4,3,2), (7,6,5,4,3), (8,7,6,5,4)]\n    assert extract_rear([1,2,3,4,5,6,7,8,9]) == [(5,4,3,2,1), (6,5,4,3,2), (7,6,5,4,3), (8,7,6,5,4), (9,8,7,6,5)]\n    assert extract_rear([1,2,3,4,5,6,7,8,9,10]) == [(5,4,3,2,1), (6,5,4,3,2), (7,6,5,4,3), (8,7,6,5,4), (9,8,7,6,5), (10,9,8,7,6)]\n    assert extract_rear([1,2,3,4,5,6,7,8,9,10,11]) == [(5,4,3,2,1),",
    "def rear_element(list_tuple):\n    \"\"\"\n    For a given list of tuples, return the rear element of the tuple.\n    :param list_tuple: list of tuples\n    :return: the rear element of the tuple\n    \"\"\"\n    return list_tuple[-1]\n\ndef main():\n    \"\"\"\n    Write a function to extract the rear element from a list of tuples.\n    \"\"\"\n    print rear_element([(1,2),(3,4),(5,6)])\n\nif __name__ == \"__main__\":\n    main()",
    "# https://www.hackerrank.com/challenges/rearrange-the-list\n# Problem : Rearrange the elements of a list from right to left\n# Input : A list of tuples (x,y)\n# Output : Rearranged list\ndef rearrange(lst):\n    for i in range(len(lst) - 1):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n\n# Sample Input\n# (1,2)\n# (3,4)\n# (5,6)\n# (7,8)\n# (9,10)\n# (11,12)\n# (13,14)\n# (15,16)\n# (17,18)\n# (19,20)\n# (21,22)\n# (23,24)\n# (25,26)\n# (27,28)\n# (29,30)\n# (31,32)\n# (33,34)\n# (35,36)\n# (37,38)\n# (39,40)\n# (41,42)\n# (43,44)\n# (45,46)\n# (47,48)\n# (49,50)\n# (51,52)\n# (53,54)\n# (55,56)\n# (57,58)\n# (59,60)\n# (61,62)\n# (63,64)\n# (65,66)\n# (67,68)\n# (69,70)\n# (71,72)\n# (73,74)\n# (75,76)\n# (77,78)\n# (79,80)\n# (81,82)\n# (83,84)\n# (85,86)\n# (87,88)\n# (89,90)\n# (91,92)\n# (93,94)\n# (95,96)\n# (97,98)\n# (99,100)\n# (101,102)\n# (103,104)\n# (105,106)\n# (107,108)\n# (109,110)\n# (111,112)\n# (113,114)",
    "import random\n\nclass ListNode:\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def __init__(self):\n        self.n = 0\n        self.nodes = []\n\n    def generate(self, n):\n        self.n = n\n        self.nodes = [ListNode(0)]\n        self.generate_records()\n\n    def generate_records(self):\n        for i in range(1, self.n+1):\n            self.nodes.append(ListNode(i))\n            self.generate_records()\n        self.nodes.append(ListNode(0))\n\n    def reverse_records(self):\n        head = None\n        curr = self.nodes[0]\n        for i in range(self.n):\n            if curr:\n                if head is None:\n                    head = curr\n                else:\n                    head.next = curr\n                curr = curr.next\n            else:\n                break\n\n        return head\n\n    def generate_records2(self):\n        for i in range(1, self.n+1):\n            self.nodes.append(ListNode(i))\n            self.generate_records2()\n        self.nodes.append(ListNode(0))\n\n    def reverse_records2(self):\n        head = None\n        curr = self.nodes[0]\n        for i in range(self.n):\n            if curr:\n                if head is None:\n                    head = curr\n                else:\n                    head.next = curr\n                curr = curr.next\n            else:\n                break\n        return head\n\n    def reverse_records3(self):\n        head = None\n        curr = self.nodes[0]\n        for i in range(self.n):\n            if curr:\n                if head is None:\n                    head = curr\n                else:\n                    head.next = curr\n                curr = curr.next\n            else:\n                break\n        return head\n\n    def reverse_records4(",
    "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def findRear(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return self.rear(nums, 0, len(nums))\n\n    def rear(self, nums, start, end):\n        if start >= end:\n            return -1\n        mid = (start + end) / 2\n        if nums[mid].x < nums[start].x:\n            return self.rear(nums, start, mid)\n        elif nums[mid].x > nums[start].x:\n            return self.rear(nums, mid + 1, end)\n        else:\n            return mid",
    "# Example 1:\n# Input: [('a',1),('b',2),('c',3)]\n# Output: ('c',3)\n# Explanation: Rear element of tuple is 'c'\n\n# Example 2:\n# Input: [('a',1),('b',2),('c',3),('d',4)]\n# Output: ('d',4)\n# Explanation: Rear element of tuple is 'd'\n\n# Example 3:\n# Input: [('a',1),('b',2),('c',3)]\n# Output: None\n# Explanation: The list is empty.\n\n# Example 4:\n# Input: [('a',1),('b',2),('c',3),('d',4),('e',5)]\n# Output: None\n# Explanation: The list is empty.\n\n# Note:\n# The length of the given list is in range [0, 10000].\n# The given list is a list of tuples.\n# The length of the tuple is in range [1, 20].\n# The given tuple is a pair of numbers.\n# The first number is always a string.\n# The second number is always a number.\n# The given tuple is unique.\n# The rear element extraction is performed on the right side of the tuple.\n# The given tuple does not contain duplicate tuple.\n\nclass Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[Tuple[str, int]]\n        :rtype: str\n        \"\"\"\n        if not nums:\n            return None\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i][0] == nums[i + 1][0]:\n                return nums[i][0]\n        return None",
    "def rear_element(records):\n    \"\"\"\n    Input: A list of records\n    Output: A list of elements from the rear of the list\n    \"\"\"\n    # Your code here\n    return []\n\nif __name__ == '__main__':\n    records = [('a', 1), ('b', 2), ('c', 3)]\n    print rear_element(records)\n    records = [(1, 2), (3, 4), (5, 6)]\n    print rear_element(records)\n    records = [(1, 2), (3, 4), (5, 6)]\n    print rear_element(records)\n    records = [(1, 2), (3, 4), (5, 6)]\n    print rear_element(records)",
    "class Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums[::-1])",
    "def rear(list_of_tuples):\n    return list_of_tuples[-1]\n\ndef front(list_of_tuples):\n    return list_of_tuples[0]\n\ndef main():\n    test_case_1 = (('a', 'b', 'c'), ('d', 'e', 'f'))\n    test_case_2 = ((1, 2, 3), (4, 5, 6))\n    test_case_3 = (('a', 'b', 'c'), ('d', 'e', 'f'))\n    test_case_4 = ((1, 2, 3), (4, 5, 6))\n\n    assert rear(test_case_1) == ('b', 'c', 'd')\n    assert front(test_case_2) == ('d', 'e', 'f')\n    assert rear(test_case_3) == ('d', 'e', 'f')\n    assert front(test_case_4) == ('d', 'e', 'f')\n\nif __name__ == '__main__':\n    main()",
    "def extract_rear(tuples_list):\n    \"\"\"\n    :type tuples_list: List[tuple]\n    :rtype: tuple\n    \"\"\"\n    return tuples_list[-1]",
    "from collections import namedtuple\n\nclass Tuple(namedtuple(\"Tuple\", \"first second\")):\n    def __str__(self):\n        return self.first + \",\" + self.second\n\ndef extract(lst):\n    \"\"\"\n    lst: list of tuples\n    return: list of tuples, with the rear element extracted.\n    \"\"\"\n    return [Tuple(first, second) for first, second in lst if second]\n\nif __name__ == \"__main__\":\n    tuple1 = Tuple(\"1\", \"2\")\n    tuple2 = Tuple(\"2\", \"3\")\n    tuple3 = Tuple(\"3\", \"4\")\n    tuple4 = Tuple(\"4\", \"5\")\n    tuple5 = Tuple(\"5\", \"6\")\n    tuple6 = Tuple(\"6\", \"7\")\n    tuple7 = Tuple(\"7\", \"8\")\n    tuple8 = Tuple(\"8\", \"9\")\n    tuple9 = Tuple(\"9\", \"10\")\n    tuple10 = Tuple(\"10\", \"11\")\n    tuple11 = Tuple(\"11\", \"12\")\n    tuple12 = Tuple(\"12\", \"13\")\n    tuple13 = Tuple(\"13\", \"14\")\n    tuple14 = Tuple(\"14\", \"15\")\n    tuple15 = Tuple(\"15\", \"16\")\n    tuple16 = Tuple(\"16\", \"17\")\n    tuple17 = Tuple(\"17\", \"18\")\n    tuple18 = Tuple(\"18\", \"19\")\n    tuple19 = Tuple(\"19\", \"20\")\n    tuple20 = Tuple(\"20\", \"21\")\n    tuple21 = Tuple(\"21\", \"22\")\n    tuple22 = Tuple(\"22\", \"23\")\n    tuple23 = Tuple(\"23\", \"24\")\n    tuple24 = Tuple(\"24\", \"25\")\n    tuple25 = Tuple(\"25\", \"26\")\n    tuple26 = Tuple(\"26\", \"27\")\n    tuple27 = Tuple(\"27\", \"28\")\n    tuple28 = Tuple(\"28\", \"29\")",
    "def get_rear(arr):\n    \"\"\"\n    arr: list of tuples\n    returns: tuple of the last element in the list\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    else:\n        return arr[-1]\n\ndef get_rear_rec(arr):\n    \"\"\"\n    arr: list of records\n    returns: tuple of the last element in the list\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    else:\n        return arr[-1][-1]\n\ndef get_rear_rec_w_key(arr, key):\n    \"\"\"\n    arr: list of records\n    key: str\n    returns: tuple of the last element in the list\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    else:\n        return arr[-1][key]\n\ndef get_rear_rec_w_key_w_default(arr, key, default):\n    \"\"\"\n    arr: list of records\n    key: str\n    default: default value\n    returns: tuple of the last element in the list\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    else:\n        return arr[-1][key] if arr[-1][key]!= default else default\n\nif __name__ == \"__main__\":\n    arr = [(1, 2), (3, 4), (5, 6), (7, 8)]\n    print get_rear(arr)\n    print get_rear_rec(arr)\n    print get_rear_rec_w_key(arr, \"x\")\n    print get_rear_rec_w_key_w_default(arr, \"x\", \"default\")",
    "def reverse_records(records):\n    \"\"\"\n    :param records: a list of tuples\n    :return: a list of reversed records\n    \"\"\"\n    return [r[::-1] for r in records]\n\n\ndef test_reverse_records():\n    assert reverse_records([]) == []\n    assert reverse_records([(1, 2), (3, 4), (5, 6)]) == [(5, 6), (3, 4), (1, 2)]\n\n\ndef extract_rear_records(records):\n    \"\"\"\n    :param records: a list of tuples\n    :return: a list of reversed records\n    \"\"\"\n    return [r[-1] for r in records]\n\n\ndef test_extract_rear_records():\n    assert extract_rear_records([]) == []\n    assert extract_rear_records([(1, 2), (3, 4), (5, 6)]) == [6, 5, 4, 3, 2, 1]",
    "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def reverseKGroup(self, nums, k):\n        n = len(nums)\n        nums.sort()\n        res = []\n        i = 0\n        while i < n:\n            while i < n and nums[i] == nums[i - 1]:\n                i += 1\n            if i == n or i + k > n:\n                res.append(nums[i - k:i])\n                break\n            j = i\n            while j < n and nums[j]!= nums[i - k]:\n                j += 1\n            res.append(nums[i - k:j])\n            i = j\n        return res",
    "# write your code here\n\ndef extract_rear_element(record):\n\t\"\"\"\n\tReturn the value of the rear element of the tuple.\n\t:param record: a tuple record\n\t:return: the value of the rear element of the tuple\n\t\"\"\"\n\treturn record[-1]\n\ndef test():\n\t\"\"\"\n\tTest cases.\n\t\"\"\"\n\t# create a list of tuples\n\tl = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]\n\t# extract the rear element of the tuple\n\tprint(extract_rear_element(l[-1]))\n\t# extract the rear element of the tuple\n\tprint(extract_rear_element(l[-2]))\n\t# extract the rear element of the tuple\n\tprint(extract_rear_element(l[-3]))\n\nif __name__ == '__main__':\n\ttest()",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nimport math\nimport timeit\n\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# ==============================================================================\n# =================================================================",
    "def extract_rear_element(records):\n    \"\"\"\n    :param records: List of tuples of form (name, age)\n    :return: name of the rear element\n    \"\"\"\n    return records[-1][0]\n\n\nif __name__ == \"__main__\":\n    records = [(1, 22), (2, 33), (3, 44), (4, 55), (5, 66)]\n    print(extract_rear_element(records))",
    "class Solution:\n    \"\"\"\n    @param: A list of tuples\n    @return: A list of integers\n    \"\"\"\n    def reverse(self, l):\n        \"\"\"\n        :type l: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        l.reverse()\n        res = []\n        for item in l:\n            res.append(item[0])\n        return res",
    "def rear_extraction(records):\n    for i in range(len(records)):\n        yield records[i][-1]\n\nrecords = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]\n\nprint(rear_extraction(records))",
    "# https://leetcode.com/problems/reverse-linked-list/\n\nclass Solution(object):\n    def reverseBetween(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if m == n:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # while m < n\n        while m < n:\n            # while head.next and m < head.next.val\n            while head and m < head.next.val:\n                # if head.next.next is not None\n                if head.next.next is not None:\n                    head.next = head.next.next\n                    head = head.next\n                else:\n                    # head.next.next is None\n                    break\n                \n                # m += 1\n                m += 1\n            \n            # if head.next is not None\n            if head.next is not None:\n                head.next = head.next.next\n                head = head.next\n            \n            # n -= 1\n            n -= 1\n        \n        return dummy.next",
    "# https://www.tutorialspoint.com/python/python_list.htm\n# https://www.tutorialspoint.com/python/python_list_operations.htm\n# https://www.tutorialspoint.com/python/python_list_iterator.htm\n\n# TODO:\n# - implement the rear element extraction\n\ndef extract_rear_element(list_of_tuples):\n    \"\"\"\n    Extract the rear element from the list of tuples.\n    :param list_of_tuples: list of tuples, for example: [(1,2), (3,4), (5,6), (7,8)]\n    :return: rear element from the list of tuples, for example: (7,8)\n    \"\"\"\n    # TODO: implement this function\n    pass\n\nif __name__ == '__main__':\n    print extract_rear_element([(1,2), (3,4), (5,6), (7,8)])",
    "import unittest\n\nfrom list_tuple_tuples import ListTuples\n\n\nclass TestListTuples(unittest.TestCase):\n\n    def test_tuple_rear(self):\n        l = [(1, 2), (3, 4), (5, 6)]\n        expected = [2, 4, 6]\n        result = ListTuples.tuple_rear(l)\n        self.assertEqual(expected, result)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def rear_extraction(data):\n    \"\"\"\n    Input:\n        data: a list of tuples\n    Output:\n        rear: the rear element of the list\n    \"\"\"\n    rear = data[0][1]\n    for i in range(len(data) - 1):\n        rear = data[i+1][1]\n    return rear\n\n# test\nif __name__ == '__main__':\n    data = [('a', 1), ('b', 2), ('c', 3)]\n    print rear_extraction(data)\n\n    data = [(1, 2), (3, 4), (5, 6)]\n    print rear_extraction(data)\n\n    data = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    print rear_extraction(data)",
    "import unittest\n\n\nclass TestRearElementExtraction(unittest.TestCase):\n\n    def setUp(self):\n        self.list = [('a', 1), ('b', 2), ('c', 3)]\n\n    def test_rear_element_extraction_from_list_of_tuples(self):\n        \"\"\"\n        Test the rear element extraction from list of tuples\n        \"\"\"\n        self.assertEqual(rear_element_extraction(self.list), 'c')\n\n    def test_rear_element_extraction_from_list_of_strings(self):\n        \"\"\"\n        Test the rear element extraction from list of strings\n        \"\"\"\n        self.assertEqual(rear_element_extraction(self.list, str), 'c')\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def find_rear(record_list):\n    \"\"\"\n    Input:\n    record_list = [(1,2),(3,4),(5,6)]\n    Output:\n    [(6,5)]\n    \"\"\"\n    rear_index = 0\n    for index in range(len(record_list)):\n        if record_list[index][0] > record_list[rear_index][0]:\n            rear_index = index\n    return record_list[rear_index]\n\nif __name__ == \"__main__\":\n    input_data = [\n        (1,2),\n        (3,4),\n        (5,6),\n        (7,8),\n        (9,10),\n        (11,12),\n        (13,14),\n        (15,16),\n        (17,18),\n        (19,20),\n        (21,22),\n        (23,24),\n        (25,26),\n        (27,28),\n        (29,30),\n        (31,32),\n        (33,34),\n        (35,36),\n        (37,38),\n        (39,40),\n        (41,42),\n        (43,44),\n        (45,46),\n        (47,48),\n        (49,50),\n        (51,52),\n        (53,54),\n        (55,56),\n        (57,58),\n        (59,60),\n        (61,62),\n        (63,64),\n        (65,66),\n        (67,68),\n        (69,70),\n        (71,72),\n        (73,74),\n        (75,76),\n        (77,78),\n        (79,80),\n        (81,82),\n        (83,84),\n        (85,86),\n        (87,88),\n        (89,90),\n        (91,92),\n        (93,94),\n        (95,96),\n        (97,98),\n        (99,100),\n        (101,102),\n        (103,104),\n        (105,106),\n        (",
    "# https://www.hackerrank.com/challenges/rear-element-extraction\n\ndef rear_element_extraction(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # Find the last element in the list of tuples\n    last_element = list_of_tuples[-1]\n\n    # Calculate the distance between the last element and the first element\n    distance = last_element[0] - list_of_tuples[0][0]\n\n    # Calculate the distance between the last element and the second element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the third element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the fourth element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the fifth element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the sixth element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the seventh element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the eight element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the ninth element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the tenth element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the eleventh element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the twelve element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the thirteen element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the fourteen element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the fifteen element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the sixteen element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the seventeen element\n    distance = distance * distance\n\n    # Calculate the distance between the last element and the eighteen element\n    distance = distance * distance",
    "def rear_extraction(tuple_list):\n    \"\"\"\n    tuple_list = [(1, 2), (3, 4), (5, 6)]\n    \"\"\"\n    return tuple_list[-1]\n\nif __name__ == '__main__':\n    print rear_extraction([(1, 2), (3, 4), (5, 6)])",
    "def rear_element(records):\n    \"\"\"\n    :param records: A list of tuples\n    :return: The element at the rear of the list\n    \"\"\"\n    return records[-1][0]",
    "import collections\n\ndef rear_extraction(records):\n    \"\"\"\n    :type records: List[Tuple[str, int]]\n    :rtype: List[int]\n    \"\"\"\n    return [r[1] for r in records]\n\nif __name__ == \"__main__\":\n    r = [('a', 1), ('b', 2), ('c', 3)]\n    print(rear_extraction(r))",
    "def extract_rear(lst):\n    \"\"\"\n    lst is a list of tuples records.\n    Return a list of elements from the last element to the first element of the list.\n\n    Example\n    -------\n    extract_rear([(1, 2), (3, 4), (5, 6)]) -> [6, 5, 4, 3]\n    extract_rear([(1, 2), (3, 4), (5, 6)]) -> [2, 1, 4, 3]\n    extract_rear([(1, 2), (3, 4), (5, 6)]) -> [6, 5, 4, 3]\n    extract_rear([(1, 2), (3, 4), (5, 6)]) -> [2, 1, 4, 3]\n    \"\"\"\n    return [x[1] for x in reversed(lst)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}