{
  "problem": {
    "task_id": "MBPP/142",
    "prompt": "Write a function to count the same pair in three given lists.",
    "canonical_solution": "def count_samepair(list1,list2,list3):\r\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result",
    "test_list": [
      "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3",
      "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4",
      "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"
    ],
    "challenge_test_list": [],
    "problem_id": 131
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def same_pair(list1, list2, list3):\n\tcount = 0\n\tfor i in range(len(list1)):\n\t\tif list1[i] == list2[i] and list2[i] == list3[i]:\n\t\t\tcount += 1\n\treturn count\n\n#Test case\nlist1 = [1,2,3]\nlist2 = [1,2,3]\nlist3 = [1,2,4]\n\nprint same_pair(list1, list2, list3)",
    "def three_pairs(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return len(list1) * len(list2) * len(list3)\n\n\nif __name__ == '__main__':\n    list1 = [1, 2, 3, 3, 4, 5, 6]\n    list2 = [1, 2, 3]\n    list3 = [3, 4, 5, 6]\n    print(three_pairs(list1, list2, list3))",
    "#!/usr/bin/env python\n\ndef count_pairs(a, b, c):\n    \"\"\"\n    count_pairs(a, b, c) -> int\n    \n    Returns the number of same pairs in three given lists.\n    \"\"\"\n    count = 0\n    for i in range(len(a)):\n        for j in range(len(b)):\n            for k in range(len(c)):\n                if a[i] == b[j] and a[i] == c[k]:\n                    count += 1\n    return count\n\ndef test_count_pairs():\n    assert count_pairs([1, 2, 3], [1, 2, 3], [1, 2, 3]) == 3\n    assert count_pairs([1, 2, 3], [1, 2, 3], [2, 3, 4]) == 0\n    assert count_pairs([1, 2, 3], [1, 2, 3], [1, 2, 4]) == 0\n    assert count_pairs([1, 2, 3], [1, 2, 3], [2, 3, 4]) == 1\n    assert count_pairs([1, 2, 3], [1, 2, 3], [2, 3, 4, 5]) == 1\n\nif __name__ == '__main__':\n    test_count_pairs()",
    "def count_pairs(l1, l2, l3):\n    count = 0\n    for i in l1:\n        for j in l2:\n            for k in l3:\n                if i == j and i == k:\n                    count += 1\n    return count\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3]\n    l2 = [3, 1, 2]\n    l3 = [2, 3, 1]\n    print(count_pairs(l1, l2, l3))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def countSamePairs(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        dic1 = {}\n        dic2 = {}\n        dic3 = {}\n        cur = head1\n        while cur:\n            dic1[cur.val] = 1\n            cur = cur.next\n        cur = head2\n        while cur:\n            dic2[cur.val] = 1\n            cur = cur.next\n        cur = head3\n        while cur:\n            dic3[cur.val] = 1\n            cur = cur.next\n        count = 0\n        for val in dic1.keys():\n            if dic1[val] == 2:\n                count += dic2[val] + dic3[val]\n        return count",
    "# Hint:\n# use the function same_pair\n#\n#\n\n# Your code here\n\ndef count_same_pair(l1, l2, l3):\n    # write your code here\n    result = 0\n    for x in l1:\n        for y in l2:\n            if same_pair(x, y):\n                result += 1\n    for x in l3:\n        for y in l2:\n            if same_pair(x, y):\n                result += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 2, 3]\n    l2 = [1, 2, 3]\n    l3 = [1, 3, 4]\n    print count_same_pair(l1, l2, l3)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def threeSum(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums1 or not nums2 or not nums3:\n            return []\n        result = []\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        i = 0\n        j = 0\n        k = 0\n        while i < len(nums1) and j < len(nums2) and k < len(nums3):\n            if nums1[i] + nums2[j] + nums3[k] == 0:\n                result.append(nums1[i] + nums2[j] + nums3[k])\n                i += 1\n                j += 1\n                k += 1\n            elif nums1[i] + nums2[j] + nums3[k] > 0:\n                j += 1\n            elif nums1[i] + nums2[j] + nums3[k] < 0:\n                i += 1\n            else:\n                k += 1\n        return result",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def samePair(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        if not head1 or not head2 or not head3:\n            return 0\n        head1 = head1.next\n        head2 = head2.next\n        head3 = head3.next\n        p1 = head1\n        p2 = head2\n        p3 = head3\n        count = 0\n        while p1 and p2 and p3:\n            if p1.val == p2.val and p2.val == p3.val:\n                count += 1\n                p1 = p1.next\n                p2 = p2.next\n                p3 = p3.next\n        return count",
    "# https://www.hackerrank.com/challenges/three-lists\n# Problem: https://www.hackerrank.com/challenges/three-lists\n# Written by Vaideeswara\n# Time complexity: O(n^2)\n\ndef count_same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    n1 = len(list1)\n    n2 = len(list2)\n    n3 = len(list3)\n    \n    count = 0\n    for i in range(0, n1):\n        for j in range(0, n2):\n            for k in range(0, n3):\n                if (list1[i] == list2[j] == list3[k]):\n                    count += 1\n    return count\n\nif __name__ == \"__main__\":\n    n1 = int(input())\n    n2 = int(input())\n    n3 = int(input())\n    list1 = [int(i) for i in input().split()]\n    list2 = [int(i) for i in input().split()]\n    list3 = [int(i) for i in input().split()]\n    print(count_same_pair(list1, list2, list3))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def samePair(self, headA, headB, headC):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: int\n        \"\"\"\n        p1 = headA\n        p2 = headB\n        p3 = headC\n\n        count = 0\n        while p1:\n            if p2 and p2.val == p1.val:\n                count += 1\n            p1 = p1.next\n            p2 = p2.next\n\n        while p3:\n            if p2 and p2.val == p3.val:\n                count += 1\n            p3 = p3.next\n            p2 = p2.next\n\n        return count",
    "def same_pair_in_three(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    # return the number of same pair\n    # the same pair is defined as the same pair of two lists\n    # the pair of two lists is defined as the two elements of the same list\n    # list1 and list2 are sorted by ascending\n    # list3 is sorted by ascending\n\n    # if list1 and list2 are same, then return 1\n    # if list1 and list3 are same, then return 2\n    # if list2 and list3 are same, then return 3\n\n    return 0\n\n# Test Cases\n# [[1, 2], [1, 3], [1, 1]]\n# [[2, 2], [2, 3], [2, 1]]\n# [[3, 2], [3, 3], [3, 1]]\n\n# Output\n# 3\n# 2\n# 1",
    "class Solution(object):\n    def samePair(self, n, l1, l2, l3):\n        \"\"\"\n        :type n: int\n        :type l1: List[int]\n        :type l2: List[int]\n        :type l3: List[int]\n        :rtype: int\n        \"\"\"\n        nums1 = set(l1)\n        nums2 = set(l2)\n        nums3 = set(l3)\n        return sum(nums1 & nums2 & nums3)",
    "def samePair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(i == j for i, j in zip(list1, list2) if i < j) + sum(i == j for i, j in zip(list1, list3) if i < j)\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4]\n    l2 = [5, 6, 7, 8]\n    l3 = [1, 2, 5, 6]\n    print(samePair(l1, l2, l3))",
    "class Pair:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef three_pairs(L1, L2, L3):\n    pairs = []\n    for i in range(len(L1)):\n        for j in range(len(L2)):\n            for k in range(len(L3)):\n                if L1[i] == L2[j] and L2[j] == L3[k] and L3[k] == L1[i]:\n                    pairs.append(Pair(L1[i], L2[j]))\n    return len(pairs)\n\ndef main():\n    L1 = [1, 2, 2, 3, 4, 5]\n    L2 = [1, 2, 3, 4, 5, 6]\n    L3 = [1, 1, 2, 3, 4, 5]\n    print three_pairs(L1, L2, L3)\n    L1 = [1, 2, 2, 3, 4, 5]\n    L2 = [1, 2, 3, 4, 5, 6]\n    L3 = [1, 1, 2, 3, 4, 5]\n    print three_pairs(L1, L2, L3)\n\nif __name__ == \"__main__\":\n    main()",
    "def same_pair(list_a, list_b, list_c):\n    \"\"\"\n    Input: list_a = [1, 2, 3, 4, 5, 6]\n           list_b = [1, 2, 3, 4, 5, 6]\n           list_c = [1, 2, 3, 4, 5, 6]\n\n    Output: 3\n    \"\"\"\n    count = 0\n    for i in range(len(list_a)):\n        if list_a[i] == list_b[i] and list_b[i] == list_c[i]:\n            count += 1\n    return count\n\n\nif __name__ == '__main__':\n    print same_pair([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6])",
    "def same_pair(first_list, second_list, third_list):\n    \"\"\"\n    :type first_list: List[int]\n    :type second_list: List[int]\n    :type third_list: List[int]\n    :rtype: int\n    \"\"\"\n    return len([x for x in first_list if x in second_list and x in third_list])\n\n\ndef same_pair_2(first_list, second_list, third_list):\n    \"\"\"\n    :type first_list: List[int]\n    :type second_list: List[int]\n    :type third_list: List[int]\n    :rtype: int\n    \"\"\"\n    return len([x for x in first_list if x in second_list and x in third_list])\n\n\nif __name__ == '__main__':\n    assert same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 3\n    assert same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]) == 0\n    assert same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]) == 2\n    assert same_pair_2([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]) == 3\n    assert same_pair_2([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]) == 0\n    assert same_pair_2([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8, 9]) == 2",
    "class Solution:\n    # @param {ListNode} head1\n    # @param {ListNode} head2\n    # @param {ListNode} head3\n    # @return {integer}\n    def samePair(self, head1, head2, head3):\n        n1 = len(head1)\n        n2 = len(head2)\n        n3 = len(head3)\n        if n1!= n2 or n2!= n3:\n            return 0\n\n        i = 0\n        j = 0\n        k = 0\n        while i < n1:\n            if head1[i] == head2[j]:\n                k += 1\n                j += 1\n            else:\n                i += 1\n        return k\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head1 = ListNode(1, ListNode(2, ListNode(3)))\n    head2 = ListNode(1, ListNode(2, ListNode(3)))\n    head3 = ListNode(1, ListNode(2, ListNode(3)))\n    print(sol.samePair(head1, head2, head3))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def countSamePairs(self, headA, headB, headC):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        currA = headA\n        currB = headB\n        currC = headC\n        while currA and currB and currC:\n            if currA.val == currB.val:\n                cnt += 1\n                currA = currA.next\n                currB = currB.next\n                currC = currC.next\n            else:\n                currA = currA.next\n                currB = currB.next\n                currC = currC.next\n        return cnt\n\nif __name__ == \"__main__\":\n    headA = ListNode(1)\n    headB = ListNode(1)\n    headC = ListNode(1)\n    headA.next = headB\n    headB.next = headC\n    headC.next = headA\n    print Solution().countSamePairs(headA, headB, headC)\n    headA = ListNode(1)\n    headB = ListNode(2)\n    headC = ListNode(1)\n    headA.next = headB\n    headB.next = headC\n    headC.next = headA\n    print Solution().countSamePairs(headA, headB, headC)\n    headA = ListNode(1)\n    headB = ListNode(1)\n    headC = ListNode(2)\n    headA.next = headB\n    headB.next = headC\n    headC.next = headA\n    print Solution().countSamePairs(headA, headB, headC)\n    headA = ListNode(1)\n    headB = ListNode(1)\n    headC = ListNode(1)\n    headA.next = head",
    "#!/usr/bin/env python\n\nclass ListNode(object):\n    def __init__(self, val, next_node=None):\n        self.val = val\n        self.next = next_node\n\n\nclass Solution(object):\n    def samePair(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        n1 = n2 = n3 = 0\n        p1 = p2 = p3 = head1\n        while p1!= None:\n            n1 += 1\n            p1 = p1.next\n        p1 = head2\n        while p1!= None:\n            n2 += 1\n            p1 = p1.next\n        p1 = head3\n        while p1!= None:\n            n3 += 1\n            p1 = p1.next\n        return n1*n2*n3",
    "from collections import Counter\n\ndef count_same_pairs(l1, l2, l3):\n    \"\"\"\n    :type l1: list\n    :type l2: list\n    :type l3: list\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(0, len(l1)):\n        for j in range(0, len(l2)):\n            for k in range(0, len(l3)):\n                if l1[i] == l2[j] and l1[i] == l3[k]:\n                    count += 1\n    return count\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3]\n    l2 = [1, 2, 3]\n    l3 = [1, 2, 3, 2, 3]\n    print(count_same_pairs(l1, l2, l3))",
    "import collections\n\ndef count_same_pairs(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return collections.Counter(list1 + list2 + list3).most_common(1)[0][0]\n\n\ndef main():\n    \"\"\"\n    Example:\n        >>> count_same_pairs([1, 2, 3], [1, 2, 3], [1, 2, 3, 3])\n        3\n    \"\"\"\n    print(count_same_pairs([1, 2, 3], [1, 2, 3], [1, 2, 3, 3]))\n\nif __name__ == '__main__':\n    main()",
    "def count_same_pairs(a, b, c):\n    count = 0\n    for i in a:\n        for j in b:\n            for k in c:\n                if i == j and i == k:\n                    count += 1\n    return count\n\n# Your code here!\na = [1, 2, 3, 4, 5]\nb = [3, 4, 5, 6, 7]\nc = [5, 6, 7, 8, 9]\nprint(count_same_pairs(a, b, c))",
    "from collections import Counter\n\ndef three_pairs(l1, l2, l3):\n    return Counter(l1) == Counter(l2) == Counter(l3)\n\ndef test():\n    l1 = [1,2,3]\n    l2 = [1,3,2]\n    l3 = [1,3,3]\n\n    assert(three_pairs(l1, l2, l3) == True)\n    assert(three_pairs(l1, l2, l1) == False)\n    assert(three_pairs(l2, l1, l3) == False)\n    assert(three_pairs(l3, l1, l2) == False)\n\ntest()",
    "# http://www.geeksforgeeks.org/count-pairs-given-three-lists/\n\n# time complexity: O(n*m*k)\n# space complexity: O(n*m)\n\n# 1. Get the index of the element in the first list\n# 2. Get the index of the element in the second list\n# 3. Get the index of the element in the third list\n# 4. Compare the elements and add the result to the sum\ndef three_lists_pairs(first_list, second_list, third_list):\n    sum = 0\n    for i in range(len(first_list)):\n        for j in range(len(second_list)):\n            for k in range(len(third_list)):\n                if first_list[i] == second_list[j] and second_list[j] == third_list[k]:\n                    sum += 1\n    return sum\n\n# 5. Recursion\ndef three_lists_pairs_recursion(first_list, second_list, third_list):\n    sum = 0\n    if len(first_list) == 0:\n        return sum\n    if len(second_list) == 0:\n        return sum\n    if len(third_list) == 0:\n        return sum\n    for i in range(len(first_list)):\n        for j in range(len(second_list)):\n            for k in range(len(third_list)):\n                sum += three_lists_pairs_recursion(first_list[i+1:], second_list[j+1:], third_list[k+1:])\n    return sum\n\n# 6. DP\n# def three_lists_pairs_dp(first_list, second_list, third_list):\n#     sum = 0\n#     dp = [[0 for i in range(len(third_list)+1)] for j in range(len(first_list)+1)]\n#     for i in range(len(first_list)):\n#         dp[i][0] = 1\n#     for i in range(len(second_list)):\n#         dp[0][i+1] = 1\n#     for i",
    "from collections import Counter\n\ndef count_same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(map(lambda x, y, z: x == y and x == z, list1, list2, list3))\n\n\nif __name__ == '__main__':\n    assert count_same_pair([1, 2, 3], [1, 2, 3], [1, 2, 3]) == 3\n    assert count_same_pair([1, 2, 3], [1, 2, 3], [1, 2, 4]) == 2\n    assert count_same_pair([1, 2, 3], [1, 2, 3], [1, 2, 3, 4]) == 0",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def countSamePairs(self, root1, root2, root3):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :type root3: TreeNode\n        :rtype: int\n        \"\"\"\n        if root1 is None:\n            return 0\n        if root2 is None:\n            return 0\n        if root3 is None:\n            return 0\n\n        if root1.val!= root2.val and root1.val!= root3.val and root2.val!= root3.val:\n            return 0\n\n        res = 0\n        if root1.val == root2.val:\n            res += 1\n        if root1.val == root3.val:\n            res += 1\n        if root2.val == root3.val:\n            res += 1\n\n        res += self.countSamePairs(root1.left, root2.left, root3.left)\n        res += self.countSamePairs(root1.right, root2.right, root3.right)\n        return res\n\n\nif __name__ == '__main__':\n    root1 = TreeNode(1)\n    root2 = TreeNode(2)\n    root3 = TreeNode(3)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    root3.left = TreeNode(3)\n    root3.right = TreeNode(2)\n    print Solution().countSamePairs(root1, root2, root3)",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def threeSum(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[ListNode]\n        \"\"\"\n        res = []\n        n1, n2, n3 = len(nums1), len(nums2), len(nums3)\n        if n1 + n2 + n3!= 3:\n            return res\n\n        # sort the three lists\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n\n        i, j, k = 0, 0, 0\n        while i < n1 and j < n2 and k < n3:\n            if nums1[i] + nums2[j] + nums3[k] == 0:\n                res.append(ListNode(nums1[i] + nums2[j] + nums3[k]))\n                i += 1\n                j += 1\n                k += 1\n            elif nums1[i] + nums2[j] + nums3[k] < 0:\n                i += 1\n            elif nums1[i] + nums2[j] + nums3[k] > 0:\n                j += 1\n            else:\n                k += 1\n        return res",
    "def same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            count += 1\n    return count\n\ndef same_pair_2(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            count += 1\n    return count\n\ndef same_pair_3(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(1 for i in range(len(list1)) if list1[i] == list2[i] and list1[i] == list3[i])\n\n\nif __name__ == '__main__':\n    print same_pair(list1=[1,2,3], list2=[1,2,3], list3=[1,2,3,4])\n    print same_pair_2(list1=[1,2,3], list2=[1,2,3], list3=[1,2,3,4])\n    print same_pair_3(list1=[1,2,3], list2=[1,2,3], list3=[1,2,3,4])",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# \n# class Solution(object):\n#     def samePair(self, head1, head2, head3):\n#         \"\"\"\n#         :type head1: ListNode\n#         :type head2: ListNode\n#         :type head3: ListNode\n#         :rtype: int\n#         \"\"\"\n#         same_count = 0\n#         while head1 and head2 and head3:\n#             if head1.val == head2.val and head2.val == head3.val:\n#                 same_count += 1\n#                 head1 = head1.next\n#                 head2 = head2.next\n#                 head3 = head3.next\n#             else:\n#                 break\n#         return same_count\n\nclass Solution(object):\n    def samePair(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        same_count = 0\n        while head1 and head2 and head3:\n            if head1.val == head2.val and head2.val == head3.val:\n                same_count += 1\n                head1 = head1.next\n                head2 = head2.next\n                head3 = head3.next\n            else:\n                break\n        return same_count",
    "def same_pair(list1, list2, list3):\n    for i in list1:\n        for j in list2:\n            if i == j:\n                for k in list3:\n                    if i == k:\n                        return 3\n\nif __name__ == '__main__':\n    list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    list2 = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    list3 = [3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print same_pair(list1, list2, list3)",
    "# pylint: disable=missing-docstring\n\n# TODO: write tests for this function.\n\ndef count_same_pairs(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    result = 0\n    for i in list1:\n        if i in list2 and i in list3:\n            result += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    assert count_same_pairs([1, 2, 3], [1, 2, 3], [1, 2, 3, 4]) == 2",
    "def count_pair(first, second, third):\n\t# write your code here\n\tcount = 0\n\tfor i in first:\n\t\tif i in second:\n\t\t\tcount += 1\n\treturn count\n\ndef main():\n\tfirst = [1, 2, 2, 3, 3, 3, 4]\n\tsecond = [2, 3, 3, 4, 4, 4, 5]\n\tthird = [3, 3, 4, 4, 5, 5, 5]\n\tprint count_pair(first, second, third)\n\nif __name__ == '__main__':\n\tmain()",
    "def count_same_pair(l1, l2, l3):\n    return len(list(filter(lambda x: x in l1 and x in l2 and x in l3, l1)))\n\n# Test Cases\ntest_cases = [\n    ([[1, 2], [3, 4], [5, 6]], [1, 2, 5], [3, 4], [5, 6], 0),\n    ([[1, 2], [3, 4], [5, 6]], [1, 2, 5], [3, 4], [5, 6], 1),\n    ([[1, 2], [3, 4], [5, 6]], [1, 2, 5], [3, 4], [5, 6], 2),\n]\n\nfor case in test_cases:\n    res = count_same_pair(*case)\n    assert res == case[3]",
    "def same_pair(l1, l2, l3):\n    # Write your code here\n    #return count_same_pair(l1, l2, l3)\n\n    # Solution 1:\n    # 1. Count the number of same pairs in l1 and l2\n    # 2. Count the number of same pairs in l3\n    # 3. Count the number of same pairs in l1 and l3\n    # 4. Count the number of same pairs in l2 and l3\n    # 5. Sum up the number of same pairs in l1 and l2\n    # 6. Sum up the number of same pairs in l2 and l3\n    # 7. Sum up the number of same pairs in l1 and l3\n    # 8. Sum up the number of same pairs in l3 and l2\n    # 9. Sum up the number of same pairs in l3 and l1\n    # 10. Sum up the number of same pairs in l1 and l2\n    # 11. Sum up the number of same pairs in l1 and l3\n    # 12. Sum up the number of same pairs in l2 and l3\n    # 13. Sum up the number of same pairs in l1 and l3\n    # 14. Sum up the number of same pairs in l3 and l2\n    # 15. Sum up the number of same pairs in l3 and l1\n    # 16. Sum up the number of same pairs in l1 and l2\n    # 17. Sum up the number of same pairs in l2 and l1\n\n    # Solution 2:\n    # 1. Count the number of same pairs in l1 and l2\n    # 2. Count the number of same pairs in l3\n    # 3. Count the number of same pairs in l1 and l3\n    # 4. Count the number of same pairs in l2 and l3\n    # 5. Sum up the number of same pairs in l1 and l2\n    # 6. Sum up the number of same pairs in l2 and l3\n    # 7. Sum up the number of same pairs in l1 and l3\n    # 8. Sum up the number of same pairs in l3 and l2\n    # 9. Sum up the number of same pairs in l3 and l1\n    # 10.",
    "import sys\nsys.path.append(\"..\")\nimport itertools\n\ndef same_pair_in_lists(list1, list2, list3):\n    \"\"\"\n    :param list1: First list of elements.\n    :param list2: Second list of elements.\n    :param list3: Third list of elements.\n    :return: Number of same pair in the three given lists.\n    \"\"\"\n    return len(list(itertools.combinations(list1, 3)) &\n               list(itertools.combinations(list2, 3)) &\n               list(itertools.combinations(list3, 3)))\n\ndef main():\n    list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    list2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    list3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(same_pair_in_lists(list1, list2, list3))\n\nif __name__ == \"__main__\":\n    main()",
    "# Definition for a triplet.\nclass Triplet(object):\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return '<Triplet %d, %d, %d>' % (self.a, self.b, self.c)\n\nclass Solution(object):\n    def countTriplets(self, A, B, C):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([(A.count(a), B.count(b), C.count(c)) for a, b, c in Triplet(a, b, c)])",
    "def count_same_pairs(first, second, third):\n    return sum(map(lambda x: x * x, first + second + third))\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3]\n    l2 = [1, 2, 4]\n    l3 = [1, 2, 5]\n    print(count_same_pairs(l1, l2, l3))",
    "# Definition for a triplet.\nclass Triplet:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n    def __repr__(self):\n        return str(self.x) + str(self.y) + str(self.z)\n\nclass Solution:\n    def countPairs(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # dp[i][j][k] is the number of same triplet in lists[i][j] and lists[k][j]\n        dp = [[[[0]*len(lists[0])]*len(lists[1])]*len(lists[2])] * len(lists)\n        for i in range(len(lists)):\n            for j in range(len(lists[0])):\n                for k in range(len(lists[1])):\n                    for l in range(len(lists[2])):\n                        for m in range(len(lists)):\n                            for n in range(len(lists[0])):\n                                dp[i][j][k][l][m][n] = dp[i][j][k][l][m][n] + lists[m][n] == lists[i][j] * lists[k][l]\n        return sum(sum(dp[i][j][k][l][m][n]) for n in range(len(lists)) for m in range(len(lists[0])) for l in range(len(lists[1])) for k in range(len(lists[2])) for j in range(len(lists[0])) for i in range(len(lists[1])))",
    "def same_pair_three(list1, list2, list3):\n    return len(list1) == len(list2) == len(list3) and len(list1 & list2) == len(list1 & list3) and len(list2 & list3) == len(list1 & list3)\n\nprint same_pair_three([1,2,3], [1,2,3], [2,3,4])",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def samePair(self, headA, headB, headC):\n        \"\"\"\n        :type headA: ListNode\n        :type headB: ListNode\n        :type headC: ListNode\n        :rtype: int\n        \"\"\"\n        # if len(headA)!= len(headB) or len(headA)!= len(headC):\n        #     return 0\n\n        # pair_count = 0\n        #\n        # while headA:\n        #     headA = headA.next\n        #     headB = headB.next\n        #     headC = headC.next\n        #     if headA and headB and headC:\n        #         if headA.val == headB.val and headA.val == headC.val:\n        #             pair_count += 1\n        #\n        # return pair_count\n        return 0\n\nif __name__ == '__main__':\n    headA = ListNode(1)\n    headB = ListNode(1)\n    headC = ListNode(1)\n    headA.next = headB\n    headB.next = headC\n    headC.next = None\n    print Solution().samePair(headA, headB, headC)",
    "def three_pairs(first, second, third):\n    count = 0\n    for i in range(len(first)):\n        for j in range(len(second)):\n            for k in range(len(third)):\n                if first[i] == second[j] and second[j] == third[k] and third[k] == first[i]:\n                    count += 1\n    return count\n\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 6])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 5])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 5])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7])\nprint three_pairs([1, 2, 3, 4, 5], [1, 2, 3, 4,",
    "# https://www.hackerrank.com/challenges/three-lists-are-same\n#\n# In this problem, we have three lists, which are already sorted in ascending order.\n# Each element in the lists are unique.\n#\n# The function should return the number of same pairs in three lists.\n#\n# Example 1:\n#\n# Input:\n# [\"A\", \"B\", \"C\", \"D\", \"E\"]\n# [\"B\", \"C\", \"D\", \"F\", \"G\"]\n# [\"C\", \"D\", \"E\", \"F\", \"G\"]\n# Output: 2\n#\n# Explanation:\n# Two pairs are \"B\", \"C\" and \"D\", \"F\" and \"G\".\n#\n# Example 2:\n#\n# Input:\n# [\"A\", \"B\", \"C\", \"D\", \"E\"]\n# [\"B\", \"C\", \"D\", \"E\", \"F\"]\n# [\"C\", \"D\", \"E\", \"F\", \"G\"]\n# Output: 3\n#\n# Explanation:\n# Three pairs are \"B\", \"C\", \"D\" and \"E\", \"F\", and \"G\".\n#\n# Example 3:\n#\n# Input:\n# [\"A\", \"B\", \"C\", \"D\", \"E\"]\n# [\"B\", \"C\", \"D\", \"E\", \"F\"]\n# [\"B\", \"C\", \"D\", \"F\", \"G\"]\n# Output: 2\n#\n# Explanation:\n# Two pairs are \"B\", \"C\" and \"D\", \"F\" and \"G\".\n#\n# Example 4:\n#\n# Input:\n# [\"A\", \"B\", \"C\", \"D\", \"E\"]\n# [\"B\", \"C\", \"D\", \"E\", \"F\"]\n# [\"B\", \"C\", \"E\", \"F\", \"G\"]\n# Output: 3\n#\n# Explanation:\n# Three pairs are \"B\", \"C\", \"E\" and \"F\", \"G\", and \"D\".\n#\n# Note:\n#\n# The size of the input lists will be in the range [1, 100].\n# Each input list's size will be in the range [1, 50].",
    "class Solution(object):\n    def samePair(self, l1, l2, l3):\n        \"\"\"\n        :type l1: List[int]\n        :type l2: List[int]\n        :type l3: List[int]\n        :rtype: int\n        \"\"\"\n        if len(l1) == 0:\n            return 0\n        if len(l2) == 0:\n            return 0\n        if len(l3) == 0:\n            return 0\n        dp = [[0 for j in range(len(l1) + 1)] for i in range(len(l2) + 1)]\n        for i in range(len(l1)):\n            for j in range(len(l2)):\n                for k in range(len(l3)):\n                    dp[j + 1][i + 1] = max(dp[j + 1][i + 1], dp[j][i] + dp[j + 1][k + 1] + dp[k + 1][i + 1])\n        return dp[len(l2)][len(l1)]\n\nif __name__ == \"__main__\":\n    print Solution().samePair([1, 2, 3], [1, 2, 3, 4], [1, 2, 3])\n    print Solution().samePair([1, 2], [1, 2, 3], [1, 2, 3])\n    print Solution().samePair([1, 2], [1, 2], [1, 2, 3])\n    print Solution().samePair([1, 2], [1, 2, 3], [1, 2, 3])\n    print Solution().samePair([1, 2, 3], [1, 2, 3], [1, 2, 3])",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def threeSum(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: int\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        length = len(nums1)\n        res = 0\n        for i in xrange(length-2):\n            if i>0 and nums1[i] == nums1[i-1]:\n                continue\n            j = i+1\n            k = length-1\n            while j < k:\n                if j >= length-1 or k < 0:\n                    break\n                if nums2[j] == nums1[i] and nums3[k] == nums1[i] and nums2[j] == nums3[k]:\n                    res += 1\n                    j += 1\n                    k -= 1\n                elif nums2[j] > nums1[i]:\n                    j += 1\n                else:\n                    k -= 1\n        return res",
    "def same_pair(a, b, c):\n    same = 0\n    for i in range(len(a)):\n        if a[i] == b[i] and a[i] == c[i]:\n            same = same + 1\n    return same\n\nprint same_pair([1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5])",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        self.next = None\n\nclass Solution:\n    def samePairs(self, head1: TreeNode, head2: TreeNode, head3: TreeNode) -> int:\n        # write your code here\n        n1 = len(head1)\n        n2 = len(head2)\n        n3 = len(head3)\n        dp = [[0] * n3 for _ in range(n2)]\n        \n        for i in range(n1):\n            cur = head1.left\n            for j in range(n2):\n                dp[j][i] = dp[j][i-1] + (cur and cur.val == head2[j].val)\n                cur = cur.next\n            \n        for i in range(n3):\n            cur = head3.left\n            for j in range(n2):\n                dp[j][i] = dp[j][i-1] + (cur and cur.val == head2[j].val)\n                cur = cur.next\n            \n        return sum(dp)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head1 = TreeNode(1)\n    head1.left = TreeNode(2)\n    head1.right = TreeNode(3)\n    head1.left.left = TreeNode(4)\n    head1.left.right = TreeNode(5)\n    head1.right.right = TreeNode(6)\n    head2 = TreeNode(1)\n    head2.left = TreeNode(2)\n    head2.right = TreeNode(3)\n    head3 = TreeNode(1)\n    head3.left = TreeNode(2)\n    head3.right = TreeNode(3)\n    head3.left.left = TreeNode(4)\n    head3.left.right = TreeNode(5)\n    head3.right.right = TreeNode(6)\n    print(sol.samePairs(head1, head2,",
    "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param n1, an integer\n\t# @param n2, an integer\n\t# @param n3, an integer\n\t# @return a ListNode\n\tdef samePairs(self, head, n1, n2, n3):\n\t\tif head is None:\n\t\t\treturn None\n\t\t# list1\n\t\tp1 = ListNode(n1)\n\t\tp1.next = head\n\t\t# list2\n\t\tp2 = ListNode(n2)\n\t\tp2.next = head\n\t\t# list3\n\t\tp3 = ListNode(n3)\n\t\tp3.next = head\n\t\t# list1, list2\n\t\tp1p2 = ListNode(0)\n\t\tp1p2.next = p1\n\t\tp1p2.next = p2\n\t\t# list1, list3\n\t\tp1p3 = ListNode(0)\n\t\tp1p3.next = p1\n\t\tp1p3.next = p3\n\t\t# list2, list3\n\t\tp2p3 = ListNode(0)\n\t\tp2p3.next = p2\n\t\tp2p3.next = p3\n\t\t# list1, list2, list3\n\t\tp1p2p3 = ListNode(0)\n\t\tp1p2p3.next = p1p2\n\t\tp1p2p3.next = p2p3\n\t\t# list1, list2, list3\n\t\tp1p3p2 = ListNode(0)\n\t\tp1p3p2.next = p1p3\n\t\tp1p3p2.next = p2p3\n\t\t# list2, list3, list1\n\t\tp2p3p1 = ListNode(0)\n\t\tp2p3p1.next = p2p3\n\t\tp2p3p1.next = p1p2\n\t\t# list2, list3, list1\n\t\tp2p1p3 = ListNode(0)",
    "def same_pair_in_three(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(1 for i in range(len(list1)) if list1[i] == list2[i] and list2[i] == list3[i] and list3[i] == list1[i])\n\n\n# Your Solution\n# @author Wang Lei",
    "# https://leetcode.com/problems/same-pair-in-three-lists/\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def samePair(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        cur1 = head1\n        cur2 = head2\n        cur3 = head3\n        count = 0\n        while cur1 and cur2 and cur3:\n            if cur1.val == cur2.val and cur1.val == cur3.val:\n                count += 1\n            cur1 = cur1.next\n            cur2 = cur2.next\n            cur3 = cur3.next\n        return count",
    "# https://leetcode.com/problems/same-pair-in-three-lists/discuss/63835/Java-O(n)-time-and-O(1)-space-solution-with-explanation\n\nclass Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return a list of integer\n    def samePair(self, num, k):\n        if len(num) < 3 or len(num) < 3:\n            return []\n        nums = list(map(int, num))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i] == nums[j] and nums[i] == nums[k]:\n                        return [nums[i]]\n        return []\n\n\nif __name__ == \"__main__\":\n    assert Solution().samePair([1, 2, 2], 1) == [2]\n    assert Solution().samePair([1, 2, 2], 2) == [1, 2]\n    assert Solution().samePair([1, 2, 2], 3) == []",
    "# https://leetcode.com/problems/same-pair-in-three-lists/\n\n# DFS\nclass Solution(object):\n    def samePair(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(lists) < 3:\n            return 0\n        count = 0\n        for i in range(len(lists)):\n            for j in range(i + 1, len(lists)):\n                for k in range(j + 1, len(lists)):\n                    if lists[i][j] == lists[k][j]:\n                        count += 1\n        return count",
    "class Solution(object):\n    def samePair(self, list1, list2, list3):\n        \"\"\"\n        :type list1: List[int]\n        :type list2: List[int]\n        :type list3: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([list1.count(x) for x in list2]+[list3.count(x) for x in list1])\n\na = [1,1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6",
    "import unittest\n\n\nclass TestSamePair(unittest.TestCase):\n\n    def test_same_pair(self):\n        self.assertEqual(same_pair([1, 2, 3], [1, 2, 4]), 3)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "def count_same_pair(list_1, list_2, list_3):\n    count = 0\n    for i in range(len(list_1)):\n        if list_1[i] == list_2[i] and list_1[i] == list_3[i]:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    list_1 = [1, 2, 3]\n    list_2 = [1, 2, 3]\n    list_3 = [1, 3, 4]\n    print(count_same_pair(list_1, list_2, list_3))\n    list_1 = [1, 2, 3]\n    list_2 = [1, 2, 3]\n    list_3 = [1, 3, 4]\n    print(count_same_pair(list_1, list_2, list_3))\n    list_1 = [1, 2, 3]\n    list_2 = [1, 2, 3]\n    list_3 = [1, 3, 4]\n    print(count_same_pair(list_1, list_2, list_3))\n    list_1 = [1, 2, 3]\n    list_2 = [1, 2, 3]\n    list_3 = [1, 3, 4]\n    print(count_same_pair(list_1, list_2, list_3))",
    "def same_pair(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # same_pair(l1, l2, l3)\n\n    # l1.sort()\n    # l2.sort()\n    # l3.sort()\n\n    # l1 = list(l1)\n    # l2 = list(l2)\n    # l3 = list(l3)\n\n    # l1.sort()\n    # l2.sort()\n    # l3.sort()\n\n    # l1 = list(l1)\n    # l2 = list(l2)\n    # l3 = list(l3)\n\n    # l1.sort()\n    # l2.sort()\n    # l3.sort()\n\n    # same_pair_1 = same_pair_2 = same_pair_3 = 0\n    # same_pair_1 = same_pair_2 = same_pair_3 = 0\n\n    # for i in range(len(l1)):\n    #     for j in range(len(l2)):\n    #         if l1[i] == l2[j]:\n    #             same_pair_1 += 1\n    #     for k in range(len(l3)):\n    #         if l1[i] == l3[k]:\n    #             same_pair_2 += 1\n    #     for l in range(len(l3)):\n    #         if l1[i] == l3[l]:\n    #             same_pair_3 += 1\n\n    # return same_pair_1 + same_pair_2 + same_pair_3\n\nif __name__ == '__main__':\n    l1 = [1, 2, 2]\n    l2 = [1, 1, 1]\n    l3 = [1, 1, 1]\n\n    same_pair(l1, l2, l3)",
    "def same_pair(x, y, z):\n    return sum(x) == sum(y) == sum(z)\n\ndef same_pair_2(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z)\n\ndef same_pair_3(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z) and sum(y) == sum(z)\n\ndef same_pair_4(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z) and sum(y) == sum(z) and sum(x) == sum(y) + sum(x)\n\ndef same_pair_5(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z) and sum(y) == sum(z) and sum(x) == sum(y) + sum(x) + sum(z) + sum(y)\n\ndef same_pair_6(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z) and sum(y) == sum(z) and sum(x) == sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(y) + sum(z)\n\ndef same_pair_7(x, y, z):\n    return sum(x) == sum(y) and sum(x) == sum(z) and sum(y) == sum(z) and sum(x) == sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(y) + sum(z) + sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(z) + sum(y) + sum(x) + sum(y) + sum(z)\n\ndef same_pair_8(x,",
    "def same_pair(a, b, c):\n    \"\"\"\n    :type a: List[int]\n    :type b: List[int]\n    :type c: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(map(lambda x, y: x == y, a, b, c))\n\nif __name__ == '__main__':\n    a = [1, 2, 3]\n    b = [1, 2, 3]\n    c = [1, 2]\n    print same_pair(a, b, c)",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def countSamePairs(self, headA, headB, headC):\n        \"\"\"\n        :type headA: ListNode\n        :type headB: ListNode\n        :type headC: ListNode\n        :rtype: int\n        \"\"\"\n        ret = 0\n        if headA is None or headB is None or headC is None:\n            return 0\n        \n        curr = headA\n        while curr is not None:\n            if curr is headB:\n                ret += 1\n                curr = headC\n            else:\n                curr = curr.next\n        return ret",
    "def same_pair(l1, l2, l3):\n    count = 0\n    for i in l1:\n        if i in l2:\n            count += 1\n        if i in l3:\n            count += 1\n    return count\n\n# Test Cases\n\ntest_cases = [\n    ([1, 2, 3], [1, 2, 3], [1, 2, 3], 1),\n    ([1, 2, 3], [1, 2, 3], [1, 2, 4], 2),\n    ([1, 2, 3], [1, 2, 3], [1, 3, 4], 3),\n    ([1, 2, 3], [1, 2, 3], [2, 3, 4], 3),\n    ([1, 2, 3], [1, 2, 3], [3, 4, 5], 3),\n    ([1, 2, 3], [1, 2, 3], [4, 5, 6], 2),\n    ([1, 2, 3], [1, 2, 3], [5, 6, 7], 3),\n    ([1, 2, 3], [1, 2, 3], [6, 7, 8], 2),\n    ([1, 2, 3], [1, 2, 3], [7, 8, 9], 3)\n]\n\nfor t in test_cases:\n    print(same_pair(*t))",
    "# https://leetcode.com/problems/three-lists-same-pair/\n# Given three lists: A, B, C, return the number of pairs of elements in A, B, C which have the same values.\n# Example:\n# A = [1, 2, 3], B = [2, 3, 4], C = [1, 2, 3, 4]\n# Return 3.\n#\n# Note:\n# 1. All lists have same length.\n# 2. Elements in each list are in non-descending order.\n# 3. Elements in three lists are distinct.\n# 4. A pair of elements from two lists are considered different.\n# 5. Elements in the same list appear in the same order.\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# Follow up:\n# Could you solve it in O(n) time and O(1) space?\n\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        ret = 0\n        for i in range(n - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            if i < n - 3 and nums[i] == nums[i + 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                if k < n - 2 and nums[k] == nums[k + 1]:\n                    continue\n                if nums[i] + nums[j] + nums[k] == 0:\n                    ret += 3\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    while j < k and nums[j] == nums[j - 1]:\n                        j -= 1\n        return ret",
    "def same_pair_three(list1, list2, list3):\n\tcount = 0\n\tfor i in list1:\n\t\tfor j in list2:\n\t\t\tfor k in list3:\n\t\t\t\tif i == j and i == k:\n\t\t\t\t\tcount += 1\n\treturn count\n\nprint same_pair_three([1,2,3,4], [1,2,3], [1,2,3,4])",
    "# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return 'Point({}, {})'.format(self.x, self.y)\n    def __repr__(self):\n        return self.__str__()\n\nclass Solution(object):\n    def threeSum(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        \n        ans = []\n        for i in range(len(nums1)):\n            j = i + 1\n            k = len(nums1) - 1\n            while j < k:\n                if nums1[i] + nums2[j] + nums3[k] == 0:\n                    ans.append(nums1[i] + nums2[j] + nums3[k])\n                    while j < k and nums1[j] == nums1[j + 1] and nums2[j] == nums2[j + 1] and nums3[j] == nums3[j + 1]:\n                        j += 1\n                    j += 1\n                    while j < k and nums1[k] == nums1[k - 1] and nums2[k] == nums2[k - 1] and nums3[k] == nums3[k - 1]:\n                        k -= 1\n                    k -= 1\n                elif nums1[i] + nums2[j] + nums3[k] < 0:\n                    j += 1\n                else:\n                    k -= 1\n        return ans",
    "from collections import Counter\n\n\ndef three_same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[str]\n    :type list2: List[str]\n    :type list3: List[str]\n    :rtype: int\n    \"\"\"\n    return Counter(list1).most_common(3) + Counter(list2).most_common(3) + Counter(list3).most_common(3)\n\n\nif __name__ == '__main__':\n    print(three_same_pair(['a', 'b', 'b'], ['b', 'b', 'a'], ['a', 'b', 'a']))\n    print(three_same_pair(['a', 'b', 'b'], ['b', 'b', 'a'], ['a', 'b', 'a']))\n    print(three_same_pair(['a', 'b', 'b'], ['b', 'b', 'a'], ['a', 'b', 'a']))",
    "def three_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(list1)\n    m = len(list2)\n    o = len(list3)\n    p = n * m * o\n    if p < 3:\n        return 0\n    else:\n        p = p // 3\n        return p",
    "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def samePair(self, headA, headB, headC):\n        \"\"\"\n        :type headA: ListNode\n        :type headB: ListNode\n        :type headC: ListNode\n        :rtype: int\n        \"\"\"\n        if not headA or not headB or not headC:\n            return 0\n        \n        # \u521d\u59cb\u5316\u94fe\u8868\n        tailA = ListNode(0)\n        tailB = ListNode(0)\n        tailC = ListNode(0)\n        \n        currA = headA\n        currB = headB\n        currC = headC\n        \n        # \u8ba1\u7b97\u94fe\u8868\u7684\u957f\u5ea6\n        lengthA = 0\n        lengthB = 0\n        lengthC = 0\n        \n        while currA!= None:\n            tailA.next = currA\n            tailA = tailA.next\n            currA = currA.next\n            lengthA += 1\n        \n        while currB!= None:\n            tailB.next = currB\n            tailB = tailB.next\n            currB = currB.next\n            lengthB += 1\n        \n        while currC!= None:\n            tailC.next = currC\n            tailC = tailC.next\n            currC = currC.next\n            lengthC += 1\n        \n        lengthA = lengthA + lengthB + lengthC\n        \n        # \u521d\u59cb\u5316\u8ba1\u7b97\u51fd\u6570\n        lengthB = lengthB + lengthC\n        lengthC = 0\n        \n        # \u8ba1\u7b97\u521d\u59cb\u5316\u7ed3\u679c\n        currA = headA\n        currB = headB\n        currC = headC\n        \n        while currA!= None:\n            if currA.val == currB.val:\n                cur",
    "def samePair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    # https://leetcode.com/problems/same-pair/solution/\n    return samePair_1(list1, list2, list3)\n\ndef samePair_1(list1, list2, list3):\n    return sum(i==j for i,j in zip(list1, list2) if i!=j) + sum(i==j for i,j in zip(list2, list3) if i!=j) + sum(i==j for i,j in zip(list3, list1) if i!=j)",
    "def samePair(list1, list2, list3):\n    samePair = 0\n    for index in range(0, len(list1)):\n        if list1[index] == list2[index] and list1[index] == list3[index]:\n            samePair += 1\n    return samePair\n\nprint(samePair([1, 2, 3], [1, 2, 3], [1, 2, 3]))\nprint(samePair([1, 2, 3], [1, 2, 3], [2, 3, 1]))\nprint(samePair([1, 2, 3], [1, 2, 3], [3, 2, 1]))\nprint(samePair([1, 2, 3], [1, 2, 3], [1, 2, 3]))\nprint(samePair([1, 2, 3], [1, 2, 3], [1, 2, 3]))",
    "# https://oj.leetcode.com/problems/3sum/\n# Given three integer arrays nums1, nums2, nums3 sorted in ascending order,\n# return the number of unique triplets created by taking these arrays.\n#\n# Each triplet is defined as [a, b, c] where a, b, and c are\n# consecutive elements from the corresponding nums1, nums2, and nums3.\n#\n# Example 1:\n#\n# Input: nums1 = [1, 0, 1], nums2 = [1, 1, 0], nums3 = [0, 1, 1]\n# Output: 2\n#\n# Example 2:\n#\n# Input: nums1 = [1, 2, 2], nums2 = [2, 2, 1], nums3 = [2, 1, 0]\n# Output: 4\n#\n# Company Tags: LinkedIn\n# Tags: Array, Two pointers, Two Sorting\n# Similar Problems: (E) 3Sum Closest\n#\n# Author: Kuang Qin\n#\n\n# Definition for a triplet\nclass Triplet(object):\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return str(self.a) + \" \" + str(self.b) + \" \" + str(self.c)\n\nclass Solution(object):\n    def threeSumClosest(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: int\n        \"\"\"\n        # sort nums1, nums2, nums3\n        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        nums3 = sorted(nums3)\n        # count the same pair\n        result = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range",
    "def three_pairs(first, second, third):\n    \"\"\"\n    :type first: list\n    :type second: list\n    :type third: list\n    :rtype: int\n    \"\"\"\n    # write your code here\n    count = 0\n    for i in range(len(first)):\n        for j in range(len(second)):\n            for k in range(len(third)):\n                if first[i] == second[j] == third[k]:\n                    count += 1\n    return count",
    "def same_pair(a, b, c):\n    return (a[0] == b[0] and a[1] == b[1]) or (a[0] == c[0] and a[1] == c[1]) or (a[0] == c[1] and a[1] == c[0])\n\n\ndef same_pair_2(a, b, c):\n    return a[0] == b[0] and a[1] == b[1] and a[2] == b[2] or a[0] == c[0] and a[1] == c[1] and a[2] == c[2] or a[0] == c[2] and a[1] == c[1] and a[2] == c[0]\n\n\ndef same_pair_3(a, b, c):\n    return a[0] == b[0] and a[1] == b[1] and a[2] == b[2] and a[3] == b[3] or a[0] == c[0] and a[1] == c[1] and a[2] == c[2] and a[3] == c[3] or a[0] == c[3] and a[1] == c[2] and a[2] == c[1] and a[3] == c[0]\n\n\ndef same_pair_4(a, b, c):\n    return a[0] == b[0] and a[1] == b[1] and a[2] == b[2] and a[3] == b[3] and a[4] == b[4] or a[0] == c[0] and a[1] == c[1] and a[2] == c[2] and a[3] == c[3] and a[4] == c[4] or a[0] == c[4] and a[1] == c[3] and a[2] == c[2] and a[3] == c[1] and a[4] == c[0]\n\n\ndef same_pair_5(a, b, c):\n    return a[0] == b",
    "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer[]} nums3\n    # @return {integer}\n    def threeSum(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        pairs = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    if i + j + k <= len(nums1) * len(nums2) * len(nums3):\n                        if nums1[i] + nums2[j] + nums3[k] == nums1[i + j + k]:\n                            pairs.append([nums1[i], nums2[j], nums3[k]])\n        return len(pairs)\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3]\n    nums2 = [1, 3, 4]\n    nums3 = [1, 2, 4]\n    print Solution().threeSum([1, 2, 3], [1, 3, 4], [1, 2, 4])",
    "def count_same_pair(first, second, third):\n    count = 0\n    for i in range(len(first)):\n        if first[i] == second[i] and first[i] == third[i]:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    first = [1, 2, 3, 3, 3, 4, 4, 4, 4, 5]\n    second = [1, 2, 3, 4, 5]\n    third = [1, 2, 3, 4, 5]\n    print count_same_pair(first, second, third)",
    "def samePair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    list1 = [1, 1, 2]\n    list2 = [1, 2, 1]\n    list3 = [2, 1, 1]\n    print(samePair(list1, list2, list3))",
    "def same_pair(l1, l2, l3):\n    pairs = 0\n    for i in range(len(l1)):\n        for j in range(len(l2)):\n            for k in range(len(l3)):\n                if l1[i] == l2[j] and l1[i] == l3[k]:\n                    pairs += 1\n    return pairs\n\nprint same_pair([1, 2, 3], [1, 2, 4], [1, 2, 3])\nprint same_pair([1, 2, 3], [1, 2, 4], [1, 2, 3, 4])\nprint same_pair([1, 2, 3], [1, 2, 4], [1, 2, 3, 4, 5])\nprint same_pair([1, 2, 3], [1, 2, 4], [1, 2, 3, 4, 5, 6])",
    "def same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    # Write your code here\n    a = [1] * 3\n    b = [1] * 3\n    c = [1] * 3\n    \n    for i in range(len(list1)):\n        a[i] += list1[i]\n    for i in range(len(list2)):\n        b[i] += list2[i]\n    for i in range(len(list3)):\n        c[i] += list3[i]\n\n    i = 0\n    j = 0\n    k = 0\n    while i < len(a) and j < len(b) and k < len(c):\n        if a[i] == b[j] and a[i] == c[k]:\n            print(a[i], b[j], c[k])\n            i += 1\n            j += 1\n            k += 1\n        elif a[i] == b[j] and c[k] == a[i]:\n            print(a[i], b[j], c[k])\n            i += 1\n            j += 1\n            k += 1\n        elif a[i] == c[k] and b[j] == a[i]:\n            print(a[i], b[j], c[k])\n            i += 1\n            j += 1\n            k += 1\n        elif b[j] == c[k] and a[i] == b[j]:\n            print(a[i], b[j], c[k])\n            i += 1\n            j += 1\n            k += 1\n        elif b[j] == c[k] and a[i] == c[k]:\n            print(a[i], b[j], c[k])\n            i += 1\n            j += 1\n            k += 1\n        elif a[i] == c[k] and c[k] == b[j]:\n            print(a[i], b[",
    "def same_pair(l1, l2, l3):\n    \"\"\"\n    l1 and l2 are two lists of same size.\n    l3 is a third list.\n    return the number of same pair.\n    \"\"\"\n    return len(set(l1).intersection(set(l2)))\n\nif __name__ == \"__main__\":\n    l1 = [1,2,3,4,5,6,7]\n    l2 = [1,2,3,4,5,6,7]\n    l3 = [1,2,3,4,5,6,7,8,9]\n    print same_pair(l1, l2, l3)",
    "# Definition for a triple.\nclass Triple(object):\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n# @param {integer[]} nums1\n# @param {integer[]} nums2\n# @param {integer[]} nums3\n# @return {integer}\ndef samePairs(nums1, nums2, nums3):\n    nums1.sort()\n    nums2.sort()\n    nums3.sort()\n    # @return {integer}\n    # @time <O(nums1.length)\n    # @space <O(1)\n    # @examples\n    # >>> samePairs([1, 2, 3, 1, 2, 3], [1, 2, 3, 1, 2, 3], [1, 2, 3, 4, 5, 6])\n    # 4\n    # >>> samePairs([1, 2, 3, 1, 2, 3], [1, 2, 3, 1, 2, 3], [1, 2, 3, 4, 5, 6, 7])\n    # 2\n    # >>> samePairs([1, 2, 3, 1, 2, 3], [1, 2, 3, 1, 2, 3], [1, 2, 3, 4, 5, 6, 7, 8])\n    # 1\n    # >>> samePairs([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7])\n    # 0\n    # >>> samePairs([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7, 8])\n    # 0\n    # >>> samePairs([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7, 8, 9])\n    # 0\n    # >>> samePairs([1, 2, 3, 4, 5, 6], [1, 2",
    "#!/usr/bin/env python\n\n# @include\ndef same_pair(xs, ys, zs):\n    \"\"\"Returns the number of times two elements appear in three given lists.\n    xs, ys, and zs are lists of integer elements.\n    \"\"\"\n    return len(set(xs) & set(ys) & set(zs))\n# @exclude\n\n\ndef same_pair_test():\n    assert same_pair([1, 2], [1, 2], []) == 0\n    assert same_pair([1, 2, 3], [1, 2, 3], []) == 0\n    assert same_pair([1, 2, 3], [1, 2], [3]) == 1\n    assert same_pair([1, 2, 3], [1, 2], [1, 2]) == 2\n    assert same_pair([1, 2, 3], [1, 2], [1, 2, 3]) == 3\n    assert same_pair([1, 2, 3], [1, 2], [1, 2, 3, 4]) == 4\n    assert same_pair([1, 2, 3], [1, 2], [1, 2, 3, 4, 5]) == 5\n    assert same_pair([1, 2, 3], [1, 2], [1, 2, 3, 4, 5, 6]) == 6\n\n\nif __name__ == \"__main__\":\n    same_pair_test()",
    "def count_three(lists):\n    \"\"\"\n    :type lists: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not lists:\n        return 0\n    return sum(count_three_rec(lists[0], lists[1], lists[2]) for _ in range(3))\n\ndef count_three_rec(list1, list2, list3):\n    if not list1 or not list2 or not list3:\n        return 0\n    if list1 == list2 or list1 == list3 or list2 == list3:\n        return 1\n    return sum(count_three_rec(list1[:i], list2[:i], list3[:i]) for i in range(1, len(list1) + 1)) + \\\n           sum(count_three_rec(list1[i:], list2[i:], list3[i:]) for i in range(1, len(list1) + 1)) + \\\n           sum(count_three_rec(list1[:i], list2[:i], list3[:i]) for i in range(1, len(list2) + 1)) + \\\n           sum(count_three_rec(list1[i:], list2[i:], list3[i:]) for i in range(1, len(list2) + 1)) + \\\n           sum(count_three_rec(list1[:i], list2[:i], list3[:i]) for i in range(1, len(list3) + 1)) + \\\n           sum(count_three_rec(list1[i:], list2[i:], list3[i:]) for i in range(1, len(list3) + 1))\n\n# print(count_three([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# print(count_three([[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3]]))\n# print(count_three([[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3], [4, 5",
    "def samePair(list1, list2, list3):\n    return sum(1 for x in list1 if x in list2 and x in list3)\n\n\n#Test cases\nassert samePair([1, 2], [3, 4], [5, 6]) == 3\nassert samePair([1, 2], [3, 4], [5, 6, 7]) == 3\nassert samePair([1, 2, 3, 4], [5, 6], [7]) == 2\nassert samePair([1, 2, 3, 4], [5, 6], [7, 8]) == 2\nassert samePair([1, 2, 3, 4], [5, 6], [7, 8, 9]) == 2\nassert samePair([1, 2, 3, 4], [5, 6], [7, 8, 9, 10]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12, 13]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12, 13, 14]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12, 13, 14, 15]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12, 13, 14, 15, 16]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7], [8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == 2\nassert samePair([1, 2, 3, 4], [5, 6, 7",
    "def samePair(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return sum(x == y for x, y in zip(l1, l2))\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    l2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    l3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print samePair(l1, l2, l3)",
    "import collections\n\n\ndef count_same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    # TODO\n    return 0\n\n\ndef main():\n    print(count_same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]))\n    print(count_same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]))\n    print(count_same_pair([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]))\n\n\nif __name__ == '__main__':\n    main()",
    "def same_pair(list_1, list_2, list_3):\n    \"\"\"\n    Input:\n        list_1, list_2, list_3: lists of integers.\n    Output:\n        count: the number of same pair in three lists.\n    \"\"\"\n    if len(list_1)!= len(list_2) or len(list_1)!= len(list_3):\n        return 0\n\n    # for each pair, check if it's in list_1, list_2, list_3.\n    for pair in list(zip(list_1, list_2, list_3)):\n        if pair in list_1:\n            continue\n        elif pair in list_2:\n            continue\n        elif pair in list_3:\n            continue\n        else:\n            return 0\n    return 1\n\n\nif __name__ == \"__main__\":\n    print(same_pair([1, 2, 3], [2, 3, 4], [1, 4, 5]))\n    print(same_pair([1, 2, 3], [3, 4, 5], [1, 4, 6]))",
    "# Your solution will be evaluated on the following test cases.\n#\n#    Sample Inputs\n#    [[1, 2], [1, 2, 3], [4, 5, 6, 7]]\n#    [[1, 2], [1, 3], [2, 3]]\n#    [[1, 2], [1, 2, 3, 4], [1, 2, 3, 5]]\n#    [[1, 2], [1, 2, 3], [1, 2, 3, 4, 5, 6]]\n#    [[1, 2], [1, 2, 3], [1, 2, 3, 4, 5, 6, 7, 8]]\n#    [[1, 2], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157",
    "import sys\n\ndef same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    # count the number of same pair in three lists\n    i = 0\n    j = 0\n    k = 0\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                if list1[i] == list2[j] and list1[i] == list3[k]:\n                    return i + 1\n    return 0\n\nif __name__ == '__main__':\n    t = int(input())\n    for ti in range(t):\n        n = int(input())\n        l1 = []\n        for ni in range(n):\n            l1.append(int(input()))\n        l2 = []\n        for ni in range(n):\n            l2.append(int(input()))\n        l3 = []\n        for ni in range(n):\n            l3.append(int(input()))\n        print(same_pair(l1, l2, l3))",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    # @param A a list of ListNode\n    # @param head a ListNode\n    # @return an integer\n    def getIntersectionNode(self, A, head):\n        \n        if A is None or head is None:\n            return None\n\n        if A.__len__() == 0:\n            return None\n\n        # print A\n        # print head\n        # print A[0]\n        # print A[1]\n        # print A[2]\n        # print A[3]\n        # print A[4]\n\n        head = head.next\n        A.next = None\n        head = head.next\n        A.next = None\n        \n        # print A\n        # print head\n        # print A[0]\n        # print A[1]\n        # print A[2]\n        # print A[3]\n        # print A[4]\n\n        # print A[0]\n        # print A[1]\n        # print A[2]\n        # print A[3]\n        # print A[4]\n        \n        count = 0\n        # print A[0]\n        # print A[1]\n        # print A[2]\n        # print A[3]\n        # print A[4]\n        \n        while A.next is not None:\n            # print A.next\n            # print A.next.next\n            # print A.next.next.next\n            # print A.next.next.next.next\n            # print A.next.next.next.next.next\n            \n            A = A.next\n            head = head.next\n            \n            # print A\n            # print head\n            # print A[0]\n            # print A[1]\n            # print A[2]\n            # print A[3]\n            # print A[4]\n            \n            # print A[0]\n            # print A[1]\n            # print A[2]\n            # print A[3]\n            # print A",
    "from collections import defaultdict\n\ndef same_pair(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    if len(list1)!= len(list2) or len(list1)!= len(list3):\n        return 0\n\n    # make a dictionary of pairs\n    pairs = defaultdict(int)\n    for i in range(len(list1)):\n        pairs[(list1[i], list2[i])] += 1\n        pairs[(list1[i], list3[i])] += 1\n        pairs[(list2[i], list1[i])] += 1\n        pairs[(list2[i], list3[i])] += 1\n        pairs[(list3[i], list1[i])] += 1\n        pairs[(list3[i], list2[i])] += 1\n\n    # get the number of pairs\n    return sum(pairs.values())\n\n\nif __name__ == \"__main__\":\n    assert same_pair([1, 2, 3], [2, 3, 4], [3, 4, 5]) == 1\n    assert same_pair([1, 2, 3], [1, 3, 4], [1, 4, 5]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [1, 3, 5]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [1, 3, 4]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [2, 3, 4]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [1, 3, 4]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [1, 4, 5]) == 0\n    assert same_pair([1, 2, 3], [1, 2, 4], [1, 3, 5]) == 0\n    assert same_pair([",
    "def same_pair(list1, list2, list3):\n    return (list1[0] == list2[0] and list1[1] == list2[1] and list1[0] == list3[0] and list1[1] == list3[1])\n\n#Test cases\nlist1 = [1,2]\nlist2 = [1,3]\nlist3 = [1,2,3]\nprint same_pair(list1, list2, list3)",
    "def count_same_pair(l1, l2, l3):\n    \"\"\"\n    :type l1: ListNode\n    :type l2: ListNode\n    :type l3: ListNode\n    :rtype: ListNode\n    \"\"\"\n    result = ListNode(0)\n    curr = result\n    for i in range(len(l1)):\n        if l1[i].val == l2[i].val and l1[i].val == l3[i].val:\n            curr.next = ListNode(1)\n            curr = curr.next\n        else:\n            curr.next = ListNode(0)\n            curr = curr.next\n    return result.next\n\nclass Solution:\n    # @param l1, a list of integer\n    # @param l2, a list of integer\n    # @param l3, a list of integer\n    # @return a list of integer\n    def threeSum(self, l1, l2, l3):\n        if len(l1) < 3 or len(l2) < 3 or len(l3) < 3:\n            return []\n        result = []\n        curr = result\n        for i in range(len(l1)):\n            for j in range(len(l2)):\n                for k in range(len(l3)):\n                    if l1[i].val + l2[j].val + l3[k].val == 0:\n                        curr.next = ListNode(i, j, k)\n                        curr = curr.next\n        return result.next",
    "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def samePair(self, headA, headB, headC):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        if headA is None:\n            return 0\n        count = 0\n        while headA is not None:\n            if headB is not None and headA.val == headB.val:\n                count += 1\n            if headC is not None and headA.val == headC.val:\n                count += 1\n            headA = headA.next\n        return count\n\nif __name__ == \"__main__\":\n    headA = ListNode(1)\n    headB = ListNode(2)\n    headC = ListNode(2)\n    headA.next = headB\n    headB.next = headC\n    print Solution().samePair(headA, headB, headC)",
    "def same_pair_3(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            count += 1\n    return count\n\ndef same_pair_2(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            for j in range(len(list3)):\n                if list3[j] == list1[i]:\n                    count += 1\n    return count\n\ndef same_pair_1(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            for j in range(len(list3)):\n                if list3[j] == list1[i]:\n                    count += 1\n    return count\n\nif __name__ == '__main__':\n    list1 = [1, 2, 3, 4, 5, 6, 7]\n    list2 = [1, 2, 3, 4, 5, 6]\n    list3 = [1, 2, 3, 4, 5]\n    print(same_pair_1(list1, list2, list3))\n    print(same_pair_2(list1, list2, list3))\n    print(same_pair_3(list1, list2, list3))",
    "class Solution:\n    # @param {ListNode} l1\n    # @param {ListNode} l2\n    # @param {ListNode} l3\n    # @return {integer}\n    def threeSum(self, l1, l2, l3):\n        l1.sort()\n        l2.sort()\n        l3.sort()\n        result = 0\n        for i in range(len(l1)):\n            for j in range(len(l2)):\n                for k in range(len(l3)):\n                    if i + j + k < len(l1) + len(l2) + len(l3):\n                        if l1[i] + l2[j] + l3[k] == l1[i + j + k]:\n                            result += 1\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    l1 = [1, 2, 1, 3, 4]\n    l2 = [1, 3, 5, 7, 2]\n    l3 = [1, 5, 10, 8, 6]\n    print(s.threeSum(l1, l2, l3))",
    "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def countSamePairs(self, head1, head2, head3):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :type head3: ListNode\n        :rtype: int\n        \"\"\"\n        if not head1 or not head2 or not head3:\n            return 0\n        count = 0\n        pre = None\n        curr1 = head1\n        curr2 = head2\n        curr3 = head3\n        while curr1 and curr2 and curr3:\n            if pre == curr1:\n                count += 1\n            pre = curr1\n            curr1 = curr1.next\n            curr2 = curr2.next\n            curr3 = curr3.next\n        return count\n\n\nif __name__ == \"__main__\":\n    head1 = ListNode(1)\n    head1.next = ListNode(2)\n    head2 = ListNode(1)\n    head2.next = ListNode(3)\n    head3 = ListNode(1)\n    head3.next = ListNode(2)\n    head3.next.next = ListNode(3)\n    solution = Solution()\n    print solution.countSamePairs(head1, head2, head3)",
    "def same_pairs(list1, list2, list3):\n    \"\"\"\n    :type list1: List[int]\n    :type list2: List[int]\n    :type list3: List[int]\n    :rtype: int\n    \"\"\"\n    return sum(list1 == list2 or list1 == list3 or list2 == list3)\n\n\nif __name__ == '__main__':\n    print(same_pairs([1, 2, 3, 4], [2, 3, 4], [3, 4, 5]))",
    "def samePair(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # l1.sort()\n    # l2.sort()\n    # l3.sort()\n    # i = 0\n    # j = 0\n    # k = 0\n    # count = 0\n    # while i < len(l1) and j < len(l2) and k < len(l3):\n    #     if l1[i] == l2[j] and l1[i] == l3[k]:\n    #         count += 1\n    #         i += 1\n    #         j += 1\n    #         k += 1\n    #     elif l1[i] == l2[j]:\n    #         i += 1\n    #     elif l1[i] == l3[k]:\n    #         j += 1\n    #     elif l2[j] == l3[k]:\n    #         k += 1\n    #     else:\n    #         i += 1\n    #         j += 1\n    #         k += 1\n    # return count\n\n    return 0\n\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4, 5]\n    l2 = [1, 2, 3, 4, 5]\n    l3 = [1, 2, 3, 5, 6]\n    print samePair(l1, l2, l3)",
    "import unittest\n\nclass Solution(object):\n    def samePair(self, l1, l2, l3):\n        \"\"\"\n        :type l1: List[int]\n        :type l2: List[int]\n        :type l3: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for i in l1 if l2.count(i) == l3.count(i) and l3.count(i) == l1.count(i))\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/same-pair-in-three-lists/solution/\n# 1ms 99.80%\nclass Solution {\n    public int samePair(List<Integer> l1, List<Integer> l2, List<Integer> l3) {\n        int[] same = new int[l1.size()];\n        for (int i = 0; i < l1.size(); i++) {\n            int count = l2.indexOf(l1.get(i)) >= 0? l3.indexOf(l1.get(i)) >= 0? l3.indexOf(l1.get(i)) >= 0? 1 : 0 : 0 : 0;\n            same[i] = count;\n        }\n        return sum(same);\n    }\n}\n\n# 1ms 99.80%\nclass Solution {\n    public int samePair(List<Integer> l1, List<Integer> l2, List<Integer> l3) {\n        int[] same = new int[l1.size()];\n        for (int i = 0; i < l1.size(); i++) {\n            int count = l2.contains(l1.get(i))? l3.contains(l1.get(i))? l3.contains(l1.get(i))? 1 : 0 : 0 : 0;\n            same[i] = count;\n        }",
    "def same_pairs(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return sum(l1 == l2 and l2 == l3)\n\n\ndef same_pairs2(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return sum(l1 == l2 and l2 == l3)\n\n\ndef same_pairs3(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return sum(l1 == l2 and l2 == l3)\n\n\ndef same_pairs4(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return sum(l1 == l2 and l2 == l3)\n\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4, 5]\n    l2 = [1, 2, 3, 4]\n    l3 = [1, 2, 3]\n\n    print(same_pairs(l1, l2, l3))\n    print(same_pairs2(l1, l2, l3))\n    print(same_pairs3(l1, l2, l3))\n    print(same_pairs4(l1, l2, l3))",
    "def same_pair_three(l1, l2, l3):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :type l3: List[int]\n    :rtype: int\n    \"\"\"\n    n1 = len(l1)\n    n2 = len(l2)\n    n3 = len(l3)\n    if n1!= n2 or n1!= n3:\n        return 0\n    s1 = {}\n    s2 = {}\n    s3 = {}\n    for i in range(n1):\n        s1[l1[i]] = l1[i]\n        s2[l2[i]] = l2[i]\n        s3[l3[i]] = l3[i]\n    i = 0\n    j = 0\n    k = 0\n    while i < n1:\n        if s1[l1[i]] == s2[l2[i]] and s1[l1[i]] == s3[l3[i]]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    while i < n1:\n        if s1[l1[i]] == s2[l2[j]] and s1[l1[i]] == s3[l3[k]]:\n            j += 1\n            k += 1\n        else:\n            i += 1\n    return j * k\n\nif __name__ == '__main__':\n    assert same_pair_three([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]) == 1\n    assert same_pair_three([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16]) == 2\n    assert same_pair_three([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17]) == 3\n    assert same_pair_three([1, 2, 3, 4, 5], [6, 7,",
    "# write your code here\ndef same_pair(list1, list2, list3):\n    same_pair_list = []\n    for x in list1:\n        for y in list2:\n            if x == y:\n                same_pair_list.append(x)\n                same_pair_list.append(y)\n    for x in list3:\n        for y in same_pair_list:\n            if x == y:\n                same_pair_list.append(x)\n    return same_pair_list",
    "# https://oj.leetcode.com/problems/same-pair-in-three-lists/\n\n# DP\nclass Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @param nums3, a list of integers\n    # @return an integer\n    def threeSum(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        \n        dic = {}\n        for num in nums1:\n            if num in dic:\n                dic[num] += 1\n            else:\n                dic[num] = 1\n        for num in nums2:\n            if num in dic:\n                dic[num] += 1\n            else:\n                dic[num] = 1\n        for num in nums3:\n            if num in dic:\n                dic[num] += 1\n            else:\n                dic[num] = 1\n        \n        result = 0\n        for k,v in dic.items():\n            if k == 0:\n                continue\n            if k == 1:\n                result += v\n                continue\n            if k == 2:\n                result += v\n                continue\n            if k == 3:\n                result += v\n                continue\n            if k == 4:\n                result += v\n                continue\n            if k == 5:\n                result += v\n                continue\n            if k == 6:\n                result += v\n                continue\n            if k == 7:\n                result += v\n                continue\n            if k == 8:\n                result += v\n                continue\n            if k == 9:\n                result += v\n                continue\n        return result\n\n# Time:  O(n^3)\n# Space: O(n^2)\n# Binary Search\nclass Solution2:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @param nums3, a list of integers\n    # @return an integer\n    def threeSum(self, nums1, nums2, nums3"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}