{
  "problem": {
    "task_id": "MBPP/247",
    "prompt": "Write a function to find the longest palindromic subsequence in the given string.",
    "canonical_solution": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]",
    "test_list": [
      "assert lps(\"TENS FOR TENS\") == 5 ",
      "assert lps(\"CARDIO FOR CARDS\") == 7",
      "assert lps(\"PART OF THE JOURNEY IS PART\") == 9 "
    ],
    "challenge_test_list": [],
    "problem_id": 236
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "# Definition for a  subsequence.\nclass  Subsequence(object):\n    def __init__(self, s, i, j):\n        self.s = s\n        self.i = i\n        self.j = j\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        maxLen = 0\n        maxSubseq = []\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                subseq = Subsequence(s, i, j)\n                if self.isPalindrome(subseq):\n                    if len(subseq.s) > maxLen:\n                        maxLen = len(subseq.s)\n                        maxSubseq = [subseq]\n                    elif len(subseq.s) == maxLen:\n                        maxSubseq.append(subseq)\n        return \"\".join(map(str, maxSubseq))\n\n    def isPalindrome(self, subseq):\n        if subseq.i > subseq.j:\n            return False\n        i = subseq.i\n        j = subseq.j\n        while i < j:\n            if s[i]!= s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\ns = Solution()\ns.longestPalindrome(\"abc\")",
    "def longest_palindrome(str):\n    if len(str) <= 1:\n        return 0\n    \n    length = len(str)\n    \n    # store the max length and the first index of the longest palindrome\n    max_length = 0\n    max_index = 0\n    \n    # loop over the string and keep track of the longest palindrome\n    for index in range(len(str)):\n        # if the current index is a palindrome\n        if str[index] == str[index+1]:\n            # add the length of the palindrome to the max length\n            max_length += 1\n        else:\n            # if the current index is not a palindrome,\n            # reset the max length and the first index of the longest palindrome\n            max_length = 0\n            max_index = 0\n    \n    # return the max length\n    return max_length",
    "# https://leetcode.com/problems/longest-palindromic-subsequence/\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        maxLen = 0\n        length = len(s)\n        if length <= 1:\n            return 0\n        # dp[i][j] means the longest palindromic subsequence ending at index i\n        # and ending at index j.\n        dp = [[0 for i in range(length)] for j in range(length)]\n        for i in range(length):\n            for j in range(i):\n                # dp[i][j] = dp[i - 1][j] + 1 if s[i] == s[j]\n                # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1)\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n                if s[i] == s[j]:\n                    dp[i][j] += 1\n        for i in range(length):\n            maxLen = max(maxLen, dp[i][i])\n        return maxLen",
    "import re\n\ndef longest_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    # This is a \"best-case\" solution.\n    # We can easily find the longest palindrome in the string.\n    # We can also find the longest palindromic subsequence in the string.\n    # The longest palindromic subsequence is a subsequence that is the longest\n    # palindrome made from the subsequence.\n    # We can find the longest palindromic subsequence in the string by using\n    # the following algorithm:\n    #  1. Search from the end of the string and find the longest palindrome.\n    #  2. Search from the beginning of the string and find the longest palindrome.\n    #  3. If we find two palindromes of same length, then the longest palindrome\n    #     is the longest palindrome made from the longest palindrome in the\n    #     first two steps.\n    #  4. If we don't find the longest palindrome, then the longest palindrome\n    #     is the longest palindrome made from the longest palindrome in the\n    #     first step.\n    #\n    # The following code is a \"good\" solution.\n    # We will find the longest palindromic subsequence by finding the longest\n    # palindrome in the string, and then checking all the subsequences that\n    # are made from the longest palindrome.\n    # We will check all the palindromes in the string starting from the end,\n    # and then the palindromes in the string starting from the beginning.\n    # If we find two palindromes of same length, then the longest palindrome\n    # is the longest palindrome made from the longest palindrome in the\n    # first two steps.\n    # If we don't find the longest palindrome, then the longest palindrome\n    # is the longest palindrome made from the longest palindrome in the\n    # first step.\n    #\n    # We will find the longest palindrome in the string by finding the longest\n    # palindrome in the string.\n    # We will then check all",
    "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def longestPalindrome(self, s):\n        if not s: return 0\n        s = s.lower()\n        max_len = 0\n        max_len_pos = -1\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    max_len = max(max_len, j-i+1)\n                    max_len_pos = max(max_len_pos, i)\n        return max_len",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) <= 1:\n            return s\n        left, right = 0, len(s) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if s[mid:mid + 1] == s[mid - 1:mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return s[left:right + 1]",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/\n\n# https://leetcode.com/problems/longest-palindromic-subsequence/solution/\n# https://leetcode.com/problems/longest-palindromic-subsequence/solution/\n# https://leetcode.com/problems/longest-palindromic-subsequence/discuss/267024/Python-solution-with-explanation\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        length = len(s)\n        if length == 0:\n            return 0\n        if length == 1:\n            return 1\n        if length == 2:\n            return 2\n        i = 0\n        j = 0\n        max_length = 1\n        while i < length:\n            if s[i] == s[j]:\n                max_length = 2*max_length\n                i += 1\n                j += 1\n            elif j > 0 and s[i] == s[j-1]:\n                max_length = max(max_length, 2*j-i)\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return max_length\n\n\nif __name__ == '__main__':\n    print(Solution().longestPalindrome('aabbcc'))\n    print(Solution().longestPalindrome('aabbccdd'))",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s: return ''\n        \n        length = len(s)\n        if length <= 1:\n            return s\n        \n        # store the longest palindrome\n        longest_palindrome = ''\n        \n        # store the start and end position of the longest palindrome\n        start = 0\n        end = 0\n        \n        # store the last character of the longest palindrome\n        last_char = s[0]\n        \n        # store the length of the longest palindrome\n        palindrome_length = 0\n        \n        # keep looping through the string\n        for i in range(length):\n            # check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as the last character\n            # if it is, check if the current character is the same as",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        length = len(s)\n        if length < 2:\n            return s\n        \n        # dp[i][j] is the longest palindrome with length from i to j\n        dp = [ [0] * (length+1) for i in range(length+1) ]\n        for i in range(length):\n            for j in range(i, length):\n                if s[i:j] == s[j:i]:\n                    dp[i][j] = dp[i][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n        \n        # find the longest palindrome with length from 1 to length\n        max_length = 1\n        for i in range(length):\n            if dp[1][i] > max_length:\n                max_length = dp[1][i]\n        return s[:max_length]",
    "import re\n\n\ndef longest_palindrome_subseq(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    # handle case 1\n    if len(s) < 2:\n        return s\n\n    # handle case 2\n    if len(s) == 2:\n        if s == s[::-1]:\n            return s\n\n        return ''\n\n    # handle case 3\n    if s[0] == s[-1]:\n        return s\n\n    # handle case 4\n    if s[0] == s[-2] and s[0] == s[-1]:\n        return s\n\n    # handle case 5\n    if s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 6\n    if s[0] == s[-2]:\n        return s[0:len(s)-2]\n\n    # handle case 7\n    if s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 8\n    if s[0] == s[-2] and s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 9\n    if s[0] == s[-2]:\n        return s[0:len(s)-2]\n\n    # handle case 10\n    if s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 11\n    if s[0] == s[-2] and s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 12\n    if s[0] == s[-2]:\n        return s[0:len(s)-2]\n\n    # handle case 13\n    if s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 14\n    if s[0] == s[-2] and s[0] == s[-1]:\n        return s[0:len(s)-1]\n\n    # handle case 15\n    if s[",
    "# The longest palindromic subsequence of a string is a subsequence of that string \n# where each of the characters are the same.\n\n# For example, the longest palindromic subsequence of \"aabcbb\" is \"bbbb\".\n\n# Given a string, find the length of the longest palindromic subsequence in it.\n# \n# If there is no palindromic subsequence in the string, return 0.\n\n# Example\n# Input:\n# \"a\"\n# \n# Output:\n# 1\n# \n# Explanation:\n# There is no palindromic subsequence in \"a\".\n# \n# Example 2\n# Input:\n# \"abbcbbcc\"\n# \n# Output:\n# 4\n# \n# Explanation:\n# \"abbcbbcc\" is a palindromic subsequence in the string.\n# \n# Example 3\n# Input:\n# \"abc\"\n# \n# Output:\n# 0\n# \n# Explanation:\n# There is no palindromic subsequence in \"abc\".\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\nclass Solution:\n    # @param {string} s\n    # @return {integer}\n    def longestPalindromeSubseq(self, s):\n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        \n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i] == s[j]:\n                    max_len = max(max_len, j - i + 1)\n                    \n        return max_len",
    "# @include\ndef longest_palindromic_subsequence(s):\n    # A palindrome is a string that is the same in reverse and the same in\n    # normal form.\n    # A palindromic subsequence is a subsequence of a string that is the same\n    # in both forms.\n    # Assume the longest palindromic subsequence is a string of length 1.\n    # Otherwise, return -1.\n    def longest_palindromic_subsequence_helper(start, end):\n        if start == end:\n            return 1\n        # If the substring in the middle is not a palindrome,\n        # return the length of the palindromic subsequence.\n        if s[start:end]!= s[start:end][::-1]:\n            return end - start\n        # Otherwise, recursively call longest_palindromic_subsequence_helper\n        # on the substrings in the middle of the palindromic subsequence.\n        return max(\n            longest_palindromic_subsequence_helper(start, end - 1),\n            longest_palindromic_subsequence_helper(start + 1, end - 1)\n        )\n\n    return longest_palindromic_subsequence_helper(0, len(s) - 1)\n# @exclude\n\n\ndef simple_test():\n    assert(longest_palindromic_subsequence(\"aa\") == 1)\n    assert(longest_palindromic_subsequence(\"ab\") == 1)\n    assert(longest_palindromic_subsequence(\"bb\") == 1)\n    assert(longest_palindromic_subsequence(\"ac\") == 2)\n    assert(longest_palindromic_subsequence(\"ad\") == 2)\n    assert(longest_palindromic_subsequence(\"bc\") == 2)\n    assert(longest_palindromic_subsequence(\"acb\") == 2)\n    assert(longest_palindromic_subsequence(\"bbc\") == 2)\n    assert(longest_palindromic_subsequence(\"abbcccdddddddddddddddddddddd",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n\n        max_len = 1\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                max_len += 1\n            else:\n                break\n        max_len += 1\n\n        for i in range(len(s) - max_len + 1):\n            if s[i: i + max_len] == s[i: i + max_len].lower():\n                return max_len\n\n        return max_len",
    "import re\n\ndef longestPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    max_len = 0\n    for i in range(len(s)):\n        j = i + 1\n        while j < len(s):\n            if s[i] == s[j]:\n                j += 1\n            else:\n                break\n        if j > max_len:\n            max_len = j - i\n    return max_len\n\n\nif __name__ == \"__main__\":\n    s = \"babad\"\n    print longestPalindrome(s)\n    s = \"a\"\n    print longestPalindrome(s)",
    "import sys\nimport string\n\ndef is_palindrome(s):\n    \"\"\"\n    >>> is_palindrome('abc')\n    True\n    >>> is_palindrome('aab')\n    False\n    >>> is_palindrome('abb')\n    True\n    >>> is_palindrome('abcde')\n    False\n    \"\"\"\n    if len(s) < 2:\n        return True\n    s_rev = s[::-1]\n    i, j = 0, 0\n    while i < len(s):\n        if j >= len(s_rev):\n            return False\n        if s[i] == s_rev[j]:\n            i += 1\n            j += 1\n        else:\n            return False\n    return True\n\ndef longest_palindromic_subsequence(s):\n    \"\"\"\n    >>> longest_palindromic_subsequence('abc')\n    ['abc']\n    >>> longest_palindromic_subsequence('aab')\n    ['aab']\n    >>> longest_palindromic_subsequence('abb')\n    ['abb']\n    >>> longest_palindromic_subsequence('abcde')\n    ['abcde']\n    \"\"\"\n    if len(s) < 2:\n        return [s]\n    longest_subseq = []\n    for i in range(1, len(s)):\n        if is_palindrome(s[:i] + s[i:]):\n            longest_subseq.append(s[:i] + s[i:])\n    return longest_subseq\n\nif __name__ == '__main__':\n    print(longest_palindromic_subsequence('abc'))\n    print(longest_palindromic_subsequence('aab'))\n    print(longest_palindromic_subsequence('abb'))\n    print(longest_palindromic_subsequence('abcde'))",
    "# https://leetcode.com/problems/longest-palindromic-subsequence/discuss/52784/Python-C%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2B%2B-%2",
    "import unittest\n\ndef longest_palindrome(s):\n    \"\"\"\n    Returns the longest palindromic subsequence in the string.\n    \"\"\"\n\n    if len(s) < 2:\n        return s\n    mid = len(s) // 2\n    #print(s)\n    #print(s[:mid])\n    #print(s[mid:])\n    l = [s[:mid]]\n    r = [s[mid:]]\n    for i in range(len(s) - 2):\n        #print(s[i:i+2])\n        if s[i:i+2] == s[i+1:i+3]:\n            l.append(s[i:i+2])\n        else:\n            r.append(s[i:i+2])\n    if len(l) > len(r):\n        return s[:mid] + ''.join(l)\n    else:\n        return s[:mid] + ''.join(r)\n\nclass TestLongestPalindrome(unittest.TestCase):\n\n    def test_longest_palindrome(self):\n        self.assertEqual(longest_palindrome('a'), 'a')\n        self.assertEqual(longest_palindrome('aa'), 'a')\n        self.assertEqual(longest_palindrome('ab'), 'a')\n        self.assertEqual(longest_palindrome('ba'), 'b')\n        self.assertEqual(longest_palindrome('abc'), 'abc')\n        self.assertEqual(longest_palindrome('abcdef'), 'abc')\n        self.assertEqual(longest_palindrome('abcdefg'), 'abc')\n        self.assertEqual(longest_palindrome('abcdefgh'), 'abc')\n\nif __name__ == '__main__':\n    unittest.main()",
    "import re\n\ndef longest_palindromic_subsequence(string):\n    \"\"\"\n    :type string: str\n    :rtype: int\n    \"\"\"\n    # Create a regular expression to match the longest palindromic subsequence\n    # The longest palindromic subsequence is a subsequence that is equal to the same string\n    # This is because the longest palindromic subsequence is the longest string that is a subsequence of itself\n    # This is because the longest palindromic subsequence is the longest string that is a subsequence of itself\n    # So we can just use the regular expression to match the longest palindromic subsequence\n    pattern = re.compile(r\"^.+$\")\n\n    # Create a list to hold the longest palindromic subsequence\n    max_length = 0\n    max_index = 0\n\n    # Create a list to hold the subsequences\n    subsequences = []\n\n    # Create a list to hold the subsequence lengths\n    subsequence_lengths = []\n\n    # Create a list to hold the subsequence start indices\n    subsequence_start_indices = []\n\n    # Create a list to hold the subsequence end indices\n    subsequence_end_indices = []\n\n    # Create a list to hold the subsequence characters\n    subsequence_characters = []\n\n    # Create a list to hold the subsequence strings\n    subsequence_strings = []\n\n    # Create a list to hold the longest subsequence string\n    longest_subsequence_string = \"\"\n\n    # Create a list to hold the longest subsequence indices\n    longest_subsequence_indices = []\n\n    # Create a list to hold the longest subsequence start indices\n    longest_subsequence_start_indices = []\n\n    # Create a list to hold the longest subsequence end indices\n    longest_subsequence_end_indices = []\n\n    # Create a list to hold the longest subsequence characters\n    longest_subsequence_characters = []\n\n    # Create a list to hold the longest subsequence strings\n    longest_subsequence_strings = []\n\n    # Create a list to hold the subsequence start indices\n    subsequence_start_indices.append(0)\n\n    # Create a list to hold the subsequ",
    "class Solution:\n    # @param {string} s\n    # @return {string}\n    def longestPalindrome(self, s):\n        # write your code here\n        if not s:\n            return ''\n        if not s[0] and not s[-1]:\n            return s\n        \n        if len(s) == 1:\n            return s\n        \n        m = []\n        n = []\n        for i in range(1,len(s)):\n            if s[i-1] == s[i]:\n                m.append(s[i-1])\n            else:\n                m.append('')\n                n.append(s[i-1])\n                n.append(s[i])\n        \n        m.append('')\n        n.append('')\n        \n        m = ''.join(m)\n        n = ''.join(n)\n        \n        return max(m,n)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestPalindrome('abcd')\n    print s.longestPalindrome('aaa')\n    print s.longestPalindrome('aaab')\n    print s.longestPalindrome('abcd')",
    "import string\n\n\ndef longest_palindromic_subsequence(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # If s is empty, return 0.\n    if not s:\n        return 0\n\n    # If s only contains one character, return 1.\n    if len(s) == 1:\n        return 1\n\n    # If s is a palindrome, return 1.\n    if s == s[::-1]:\n        return 1\n\n    # If s has only one non-palindrome, return 1.\n    if s[0] not in s[1:]:\n        return 1\n\n    # If s has only two non-palindrome, return 1.\n    if s[-1] not in s[:-2]:\n        return 1\n\n    # Otherwise, return the max of the two longest palindromic subsequences.\n    return max(\n        longest_palindromic_subsequence(s[:-1]),\n        longest_palindromic_subsequence(s[1:])\n    )\n\n\nif __name__ == '__main__':\n    s = \"aabbcc\"\n    print(longest_palindromic_subsequence(s))",
    "class Solution:\n    # @return a list of lists of length 3, [[a, b, c]]\n    def longestPalindrome(self, s):\n        if not s:\n            return [[]]\n        max_len = 0\n        max_len_sub = 0\n        result = []\n        for i in xrange(len(s)):\n            for j in xrange(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    max_len_sub = max(max_len_sub, j-i)\n                    result.append([s[i], s[j], s[j-max_len_sub:j+1]])\n                    max_len = max(max_len, max_len_sub+1)\n        return result\n\n\nif __name__ == '__main__':\n    assert Solution().longestPalindrome('') == [[]]\n    assert Solution().longestPalindrome('abc') == [['a', 'b', 'c']]\n    assert Solution().longestPalindrome('bba') == [['b', 'b', 'a']]\n    assert Solution().longestPalindrome('ccbba') == [['c', 'b', 'b']]\n    assert Solution().longestPalindrome('abcdbc') == [['a', 'b', 'c']]",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/\n# Definition for a  subsequence of a string.\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.getPalindromes(s, 0, len(s)-1)\n    \n    def getPalindromes(self, s, i, j):\n        if i == j:\n            return 1\n        elif i == j-1:\n            return 2\n        elif s[i] == s[j]:\n            return self.getPalindromes(s, i+1, j-1) + self.getPalindromes(s, i+1, j)\n        else:\n            return self.getPalindromes(s, i+1, j-1) + self.getPalindromes(s, i, j-1) + self.getPalindromes(s, i+1, j)",
    "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def longestPalindrome(self, s):\n        # write your code here\n        \n        if len(s) <= 1:\n            return [s]\n\n        # find the longest palindrome in the middle\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            mid = s[i:j]\n            # find the longest palindrome\n            left = self.longestPalindrome(s[:i+1])\n            right = self.longestPalindrome(s[j+1:])\n            # get the longest palindrome in the middle\n            if len(left) > len(right):\n                i = i + 1\n            else:\n                j = j - 1\n        \n        return [s[:i] + s[i:j+1] + s[j+1:]]\n\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"aabbcc\")",
    "import sys\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(\"\".join(max(s, key=len)))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        if len(s) == 1:\n            return 1\n        l = []\n        for i in range(len(s)):\n            l.append(s[i])\n            for j in range(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    l[i] = max(l[i], l[j]+1)\n        return max(l)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestPalindrome(\"a\"))\n    print(sol.longestPalindrome(\"aa\"))\n    print(sol.longestPalindrome(\"aa\"))\n    print(sol.longestPalindrome(\"abc\"))\n    print(sol.longestPalindrome(\"abcd\"))\n    print(sol.longestPalindrome(\"aaaa\"))\n    print(sol.longestPalindrome(\"abcd\"))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return ''\n        \n        s = s.lower()\n        max_len = 1\n        max_len_str = ''\n        for i in xrange(len(s)):\n            for j in xrange(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    max_len_str = s[i:j+1]\n                    max_len = max(max_len, len(max_len_str))\n        return max_len_str",
    "# https://www.hackerrank.com/challenges/longest-palindromic-subsequence\n\ndef LongestPalindromicSubsequence(string):\n    # base case\n    if len(string) == 1:\n        return [string]\n    # recursive case\n    longest = [string[0]]\n    for i in range(1, len(string)):\n        # if the first character of the string is same as the second,\n        # then the string is palindromic\n        if string[i] == string[i-1]:\n            # append the first character to the list of longest palindromic subsequence\n            longest.append(string[i])\n        # if the first character of the string is not same as the second,\n        # then the string is not palindromic\n        elif string[i]!= string[i-1]:\n            # append the first character to the list of longest palindromic subsequence\n            longest.append(string[i])\n            # reset the list of longest palindromic subsequence\n            longest = [string[i]]\n    return longest\n\nif __name__ == \"__main__\":\n    string = \"abcd\"\n    print(LongestPalindromicSubsequence(string))",
    "class Solution:\n    # @param s, a string\n    # @return a list of integers\n    def longestPalindromeSubsequence(self, s):\n        # Write your code here\n        if not s:\n            return []\n        # s = s[::-1]\n        start = 0\n        end = 0\n        res = []\n        while end < len(s):\n            while end < len(s) and s[end] == s[end-1]:\n                end += 1\n            if end - start > len(res):\n                res = [start, end]\n            start = end + 1\n            while start < len(s) and s[start] == s[start-1]:\n                start += 1\n            end = start\n        return res",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s: return ''\n\n        def get_length(s):\n            length = 0\n            for i in range(len(s)):\n                if s[i] == s[-i-1]:\n                    length += 2\n                else:\n                    length += 1\n            return length\n\n        def get_max_length(s, i, j):\n            length = 0\n            while i < len(s) and j >= 0:\n                if s[i] == s[j]:\n                    length += 2\n                    i += 1\n                    j -= 1\n                else:\n                    length += 1\n                    i += 1\n                    j -= 2\n            return length\n\n        max_length = 0\n        for i in range(len(s)):\n            length = get_length(s)\n            if length > max_length:\n                max_length = length\n            for j in range(i, len(s)):\n                length = get_max_length(s, i, j)\n                if length > max_length:\n                    max_length = length\n\n        return s[0:max_length]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.longestPalindrome(\"abcabcbb\"))\n    print(s.longestPalindrome(\"bbbbb\"))\n    print(s.longestPalindrome(\"\"))",
    "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return ''\n        s = s[::-1]\n        m = len(s)//2\n        i = 0\n        while i < m:\n            j = m - i - 1\n            while j >= 0 and s[i] == s[j]:\n                j -= 1\n            if j < 0:\n                break\n            i += 2\n        return s[i:m*2]",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n\n        length = len(s)\n        if length < 2:\n            return length\n\n        max_sub_len = 0\n        max_len = 0\n        max_index = 0\n        max_sub_index = 0\n        for i in range(length - 1):\n            sub_len = self.longestPalindromeSub(s, i, i + 1)\n            if sub_len > max_sub_len:\n                max_sub_len = sub_len\n                max_index = i\n                max_sub_index = i\n            if sub_len > max_len:\n                max_len = sub_len\n                max_index = i\n                max_sub_index = i\n\n        return max_len\n\n    def longestPalindromeSub(self, s, start, end):\n        if start == end:\n            return 1\n        if start >= end:\n            return 0\n\n        sub_len = 0\n        for i in range(start, end):\n            if s[i] == s[end - i]:\n                sub_len += 2\n            else:\n                break\n\n        return sub_len",
    "# https://www.hackerrank.com/challenges/longest-palindrome/problem\n\ndef longest_palindromic(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    # The longest palindrome subsequence is a longest palindrome that\n    # is formed by concatenating the two halves of the string in reverse order.\n    # If the string is a palindrome, the second half is a palindrome.\n    # If the string is not a palindrome, return the empty string.\n\n    # First, split the string into a list of characters.\n    s_list = s.split(' ')\n\n    # Sort the list.\n    s_list = sorted(s_list)\n\n    # If the string is a palindrome, the second half is a palindrome.\n    if s_list[0] == s_list[-1]:\n        return s_list[0]\n\n    # The maximum length of the palindrome subsequence is the length of the string.\n    # We can then calculate the length of the longest palindrome subsequence.\n    max_length = len(s_list)\n\n    # We can then use the recursive function to calculate the longest palindrome subsequence\n    # starting at the first index.\n    return longest_palindromic(s_list[0:max_length])\n\nif __name__ == \"__main__\":\n    # The input will be a string.\n    s = input()\n\n    # Print the longest palindrome subsequence.\n    print(longest_palindromic(s))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s: return ''\n        maxLen = 0\n        longest = ''\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                if s[i:j] == s[j-i:]:\n                    if len(s[i:j]) > maxLen:\n                        maxLen = len(s[i:j])\n                        longest = s[i:j]\n        return longest\n\nif __name__ == '__main__':\n    print Solution().longestPalindrome('a')",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s:\n            return ''\n        \n        if len(s) == 1:\n            return s\n        \n        max_len = 0\n        cur_len = 1\n        \n        t = TreeNode(s[0])\n        stack = [t]\n        \n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                cur_len += 1\n                if cur_len > max_len:\n                    max_len = cur_len\n                \n            elif s[i-1] == s[i]:\n                if cur_len > max_len:\n                    max_len = cur_len\n                cur_len = 1\n                stack.append(t)\n                t = TreeNode(s[i])\n            else:\n                if t.left is None:\n                    stack.append(t)\n                    t = TreeNode(s[i])\n                else:\n                    while t.left is not None:\n                        t = t.left\n                    t.left = TreeNode(s[i-1])\n        \n        if t.left is None:\n            stack.append(t)\n        \n        while stack[-1] is not None:\n            t = stack.pop()\n            if t.right is None:\n                stack.append(t)\n                t = stack.pop()\n            else:\n                while t.right is not None:\n                    t = t.right\n                t.right = TreeNode(s[len(s)-1])\n                stack.append(t)\n                t = stack.pop()\n        \n        return s[0:max_len+1]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestPalindrome(\"abc\")",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        return self.longestPalindromeHelper(s, 0, len(s) - 1)\n\n    def longestPalindromeHelper(self, s, start, end):\n        if start == end:\n            return 1\n        mid = (start + end) / 2\n        if s[start] == s[mid]:\n            return self.longestPalindromeHelper(s, start + 1, mid - 1) + self.longestPalindromeHelper(s, mid + 1, end)\n        elif s[start] < s[mid]:\n            return self.longestPalindromeHelper(s, start, mid - 1)\n        else:\n            return self.longestPalindromeHelper(s, mid + 1, end)",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.calc(s, 0, len(s), 0)\n\n    def calc(self, s, left, right, current):\n        if current == right:\n            return right - left + 1\n        if current == left:\n            return 1\n        mid = left + (right - left) / 2\n        if s[mid - 1] == s[mid] and s[mid] == s[mid + 1]:\n            return self.calc(s, left, mid, current + 1) + self.calc(s, mid + 1, right, current + 1)\n        return max(self.calc(s, left, mid, current + 1), self.calc(s, mid + 1, right, current + 1))",
    "# https://www.hackerrank.com/challenges/longest-palindrome/problem\n\ndef longestPalindrome(string):\n    # Complete this function\n    max_len = 0\n    length_map = {}\n    for i in range(len(string)):\n        if string[i] in length_map:\n            length_map[string[i]] += 1\n        else:\n            length_map[string[i]] = 1\n        if length_map[string[i]] > max_len:\n            max_len = length_map[string[i]]\n\n    for i in range(len(string)):\n        if string[i] in length_map:\n            length_map[string[i]] -= 1\n            if length_map[string[i]] < 0:\n                length_map.pop(string[i])\n    return max_len\n\n#test\nassert longestPalindrome(\"abcabcbb\") == 3\nassert longestPalindrome(\"abcbbc\") == 2\nassert longestPalindrome(\"\") == 0\nassert longestPalindrome(\"a\") == 1\nassert longestPalindrome(\"aa\") == 2\nassert longestPalindrome(\"aaa\") == 3\nassert longestPalindrome(\"abcd\") == 2\nassert longestPalindrome(\"bb\") == 1\nassert longestPalindrome(\"cba\") == 2\nassert longestPalindrome(\"cccc\") == 3",
    "class Solution:\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s:\n            return ''\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and s[l]!= s[r]:\n                l += 1\n                r -= 1\n            while l < r and s[l] == s[r]:\n                l += 1\n                r -= 1\n            if l - 1 > l:\n                l = l - 1\n            if r + 1 < r:\n                r = r + 1\n            if l == r:\n                l += 1\n                r -= 1\n        return s[l:r+1]\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"babad\")",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/discuss/126761/Python-Solution-with-O(n)-Time-and-O(1)-Space-Time\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return \"\"\n        return self.longestPalindromeSub(s, 0, len(s) - 1)\n\n    def longestPalindromeSub(self, s, start, end):\n        if start == end:\n            return s[start]\n        mid = (start + end) / 2\n        if s[mid] == s[start]:\n            return self.longestPalindromeSub(s, start, mid - 1)\n        elif s[mid] == s[end]:\n            return self.longestPalindromeSub(s, mid + 1, end)\n        else:\n            return max(self.longestPalindromeSub(s, start, mid - 1), self.longestPalindromeSub(s, mid + 1, end))\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestPalindrome(\"abcd\")\n    print s.longestPalindrome(\"a\")\n    print s.longestPalindrome(\"abcda\")\n    print s.longestPalindrome(\"abcd\")",
    "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def isPalindrome(s):\n            l = len(s)\n            if l == 0:\n                return False\n            elif l == 1:\n                return True\n            mid = l // 2\n            return isPalindrome(s[:mid]) and isPalindrome(s[mid:])\n        \n        def findMaxSub(s):\n            n = len(s)\n            maxSub = 0\n            for i in range(1, n):\n                for j in range(i+1, n):\n                    if isPalindrome(s[i:j+1]):\n                        maxSub = max(maxSub, j-i+1)\n            return maxSub\n        \n        return findMaxSub(s)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestPalindrome(\"aabb\")\n    print s.longestPalindrome(\"aaa\")\n    print s.longestPalindrome(\"aba\")\n    print s.longestPalindrome(\"ab\")\n    print s.longestPalindrome(\"\")\n    print s.longestPalindrome(\"abcd\")\n    print s.longestPalindrome(\"aabc\")\n    print s.longestPalindrome(\"aabbc\")\n    print s.longestPalindrome(\"aabbccd\")\n    print s.longestPalindrome(\"aabbccdd\")\n    print s.longestPalindrome(\"aaabbbccccddd\")",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return ''\n        max_length = 0\n        for i in range(len(s)):\n            for j in range(len(s)):\n                if i - j == j - i:\n                    if s[i - j:i + j] == s[j - i:j + i]:\n                        max_length = max(max_length, j - i + 1)\n        return s[:max_length]",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def longestPalindromeSubseq(self, s):\n        # write your code here\n        if not s:\n            return [[]]\n        else:\n            # build the stack\n            stack = []\n            for i in range(len(s)):\n                if s[i] == s[i+1]:\n                    stack.append(s[i:i+2])\n                else:\n                    if len(stack) > 0:\n                        # get the longest palindrome\n                        longest_palindrome = stack.pop()\n                        # get the longest palindrome from left\n                        stack.append(longest_palindrome[:i] + longest_palindrome[i+1:])\n                    # push the current character to stack\n                    stack.append(s[i:i+2])\n            # return the longest palindrome\n            return stack[-1]",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return \"\"\n        left = 0\n        right = len(s) - 1\n        max_len = 0\n        while left < right:\n            if self.isPalindrome(s, left, right):\n                max_len = max(max_len, right - left + 1)\n            left += 1\n            right -= 1\n        return s[left:right + 1]\n        \n    def isPalindrome(self, s, left, right):\n        while left <= right:\n            if s[left]!= s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True",
    "# https://oj.leetcode.com/problems/longest-palindromic-subsequence/\n\nclass Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        max_length = 0\n        start = 0\n        end = 0\n        while start < len(s):\n            end = start + 1\n            while end < len(s):\n                if s[start] == s[end]:\n                    if end - start > max_length:\n                        max_length = end - start\n                    while start < end and s[start] == s[end]:\n                        end += 1\n                    start = end\n                else:\n                    end += 1\n        return s[start:start + max_length]\n\nif __name__ == \"__main__\":\n    s = \"a\"\n    print Solution().longestPalindrome(s)\n    s = \"abcd\"\n    print Solution().longestPalindrome(s)\n    s = \"a\"\n    print Solution().longestPalindrome(s)",
    "import unittest\n\n\ndef longest_palindromic(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # A palindromic string is one that is the same forwards and backwards.\n    # A palindrome is a string that is the same in both directions.\n\n    # The longest palindromic subsequence in a string is the longest palindromic subsequence of the string itself.\n    # The longest palindromic subsequence is the longest subsequence that is palindromic, and is not a subsequence of another\n    # palindromic subsequence.\n\n    # If the string is not palindromic, return 0.\n\n    # If the string is empty, return 0.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is not a palindrome, return 0.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome, return 1.\n\n    # If the string is a palindrome",
    "class Solution:\n    # @return a list of integers\n    def longestPalindrome(self, s):\n        res = []\n        def dfs(i, j):\n            if i > j:\n                return\n            if s[i] == s[j]:\n                dfs(i+1, j-1)\n                res.append(i)\n                res.append(j)\n            else:\n                dfs(i+1, j)\n                dfs(i, j-1)\n        dfs(0, len(s)-1)\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().longestPalindrome(\"abc\") == [0, 3]\n    assert Solution().longestPalindrome(\"a\") == [0]\n    assert Solution().longestPalindrome(\"aa\") == [0, 2]\n    assert Solution().longestPalindrome(\"aaa\") == [0, 3]\n    assert Solution().longestPalindrome(\"a\") == [0]\n    assert Solution().longestPalindrome(\"a\") == [0]\n    assert Solution().longestPalindrome(\"aa\") == [0, 2]\n    assert Solution().longestPalindrome(\"aaa\") == [0, 3]\n    assert Solution().longestPalindrome(\"abccd\") == [0, 4]\n    assert Solution().longestPalindrome(\"abbcc\") == [0, 3]\n    assert Solution().longestPalindrome(\"abccd\") == [0, 4]\n    assert Solution().longestPalindrome(\"abcc\") == [0, 3]",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/discuss/363697/C-Python-Solution-Easy-Easy-Easy\n\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def longestPalindrome(self, s):\n        if len(s) <= 1:\n            return len(s)\n        \n        # find the longest palindromic subsequence\n        def longestPalindromicSubsequence(s, l, r):\n            if l == r:\n                return 1\n            \n            if s[l] == s[r]:\n                return 2 + longestPalindromicSubsequence(s, l+1, r-1)\n            else:\n                return longestPalindromicSubsequence(s, l, r-1)\n        \n        return longestPalindromicSubsequence(s, 0, len(s)-1)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.longestPalindrome(s)",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) < 2:\n            return s\n        max_len = 1\n        start = 0\n        end = 0\n        for i in range(len(s)):\n            if s[i] == s[i+1]:\n                end = i + 1\n                while start < end and s[start] == s[end]:\n                    start += 1\n                    end -= 1\n                max_len = max(max_len, end - start + 1)\n            else:\n                start = i + 1\n        return s[:start] + s[start + max_len :]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestPalindrome(\"abcd\")\n    print s.longestPalindrome(\"abcbb\")\n    print s.longestPalindrome(\"abcd\")\n    print s.longestPalindrome(\"abcbb\")\n    print s.longestPalindrome(\"abbbb\")",
    "import collections\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return ''\n\n        s = s.upper()\n        max_len = 1\n        longest_len = 1\n        palindrome_map = collections.defaultdict(int)\n        for i, c in enumerate(s):\n            if c == s[i - 1]:\n                palindrome_map[c] += 1\n                max_len = max(max_len, palindrome_map[c])\n            else:\n                palindrome_map[s[i - 1]] -= 1\n        for i, c in enumerate(s):\n            if c == s[i + 1]:\n                palindrome_map[c] += 1\n                max_len = max(max_len, palindrome_map[c])\n            else:\n                palindrome_map[s[i + 1]] -= 1\n        for i in range(1, max_len):\n            if palindrome_map[s[i]] == 0:\n                return s[i * 2 - 1:i * 2 + 2]\n            else:\n                if i * 2 - 1 > 0:\n                    palindrome_map[s[i * 2 - 1]] -= 1\n                if i * 2 + 1 < len(s):\n                    palindrome_map[s[i * 2 + 1]] -= 1\n\n\nif __name__ == '__main__':\n    assert Solution().longestPalindrome(\"a\") == \"a\"\n    assert Solution().longestPalindrome(\"aa\") == \"a\"\n    assert Solution().longestPalindrome(\"aaaa\") == \"a\"\n    assert Solution().longestPalindrome(\"abcd\") == \"d\"\n    assert Solution().longestPalindrome(\"abbabb\") == \"abb\"\n    assert Solution().longestPalindrome(\"bbb\") == \"bb\"\n    assert Solution().longestPalindrome(\"bbbb\") == \"bb\"\n    assert Solution().longestPalindrome(\"abc\") == \"\"\n    assert Solution().longestPalindrome(\"ac\") == \"a\"\n    assert Solution().longestPalindrome(\"a",
    "import re\n\ndef longestPalindrome(str):\n    if len(str) < 2:\n        return str\n    if len(str) == 2:\n        return str\n\n    start = 0\n    end = 0\n    max_length = 0\n    while start < len(str):\n        end = start + 1\n        while end < len(str):\n            if str[end] == str[start]:\n                if end - start > max_length:\n                    max_length = end - start\n                    start = end\n            end += 1\n        start += 1\n\n    return str[start - max_length : start]\n\nif __name__ == '__main__':\n    assert longestPalindrome('abcabcbb') == 'bbbb'\n    assert longestPalindrome('cbbd') == 'cbbd'\n    assert longestPalindrome('abcd') == 'd'\n    assert longestPalindrome('abcbc') == 'b'\n    assert longestPalindrome('aabbcc') == 'b'\n    assert longestPalindrome('abc') == 'abc'\n    assert longestPalindrome('abcdef') == 'abcdef'\n    assert longestPalindrome('abcdabc') == 'abc'\n    assert longestPalindrome('abbbbb') == 'bbbb'\n    assert longestPalindrome('abbcbbcbb') == 'bbbb'\n    assert longestPalindrome('abbbbcbb') == 'bbbb'\n    assert longestPalindrome('abbbbc') == 'bbbb'",
    "import collections\n\ndef longest_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    s_length = len(s)\n    if s_length < 2:\n        return 0\n    # construct a dictionary of all palindromic substrings\n    # and their lengths\n    palindrome_dict = collections.defaultdict(list)\n    for i in range(s_length):\n        for j in range(i, s_length):\n            palindrome_dict[s[i:j+1]].append((i, j))\n    # find the longest palindrome substrings\n    max_len = 0\n    for key in palindrome_dict.keys():\n        max_len = max(max_len, len(key))\n    return max_len",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return len(s)\n        \n        start = 0\n        end = 0\n        maxLen = 0\n        \n        while end < len(s):\n            if s[start] == s[end]:\n                maxLen = max(maxLen, end - start + 2)\n                start = end + 1\n                end = start + 1\n            else:\n                end = end + 1\n        \n        return maxLen",
    "import unittest\n\nclass Solution:\n    # @param s, a string\n    # @return a list of integers\n    def longestPalindrome(self, s):\n        if not s:\n            return []\n        if len(s) == 1:\n            return [1]\n        res = [[]]\n        for i in range(len(s)):\n            res.append([])\n            for j in range(len(s)):\n                if i > j:\n                    res[-1].append(res[-1][j-1])\n                elif s[i] == s[j]:\n                    res[-1].append(res[-1][j-1]+1)\n                else:\n                    res[-1].append(max(res[-1][j-1], res[-1][j-2]))\n        return res[-1]\n\n    def test(self):\n        s = \"abc\"\n        self.assertEqual(self.longestPalindrome(s), [3, 2, 1])\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/longest-palindromic-substring/solution/\n#\nApproach #1: Brute Force [Accepted]\nComplexity Analysis\nTime Complexity: O(n^2), where n is the length of the string.\nSpace Complexity: O(1).\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> longestPalindrome(String s) {\n        List<Integer> res = new ArrayList<>();\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            for (int j = i; j < len; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    res.add(Math.max(res.get(j - i) + 1, res.get(j - i - 1",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s) == 0:\n            return ''\n        if len(s) == 1:\n            return s\n        maxlen = 1\n        maxlens = 1\n        start = 0\n        end = 0\n        while start < len(s):\n            end = start + 1\n            while end < len(s):\n                if s[start:end] == s[end-1:end]:\n                    end += 1\n                else:\n                    break\n            maxlens = max(maxlens, end-start)\n            maxlen = max(maxlen, end-start)\n            start = end\n        return s[start:end]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.longestPalindrome('aabb'))\n    print(s.longestPalindrome('cbbd'))\n    print(s.longestPalindrome('a'*(100*100)))",
    "def longest_palindrome(string):\n    \"\"\"\n    :type string: str\n    :rtype: int\n    \"\"\"\n    # This is a simple implementation of the longest palindrome\n    # problem. It doesn't use recursion.\n    #\n    # We will build a list of all the possible palindromes from the\n    # given string. Then, we will find the longest one.\n    #\n    # The problem is that the longest palindrome may not be the\n    # longest palindrome in the string.\n    #\n    # Example:\n    #\n    # Input: \"abc\"\n    # Output: \"abc\"\n    #\n    # Input: \"bbb\"\n    # Output: \"bbb\"\n    #\n    # Input: \"pwwkew\"\n    # Output: \"pwwkew\"\n    #\n    # Input: \"word\"\n    # Output: \"word\"\n    #\n    # Input: \"aaaaaaaaaa\"\n    # Output: \"aaaaaaaaaa\"\n    #\n    # Input: \"a\"\n    # Output: \"a\"\n    #\n    # Input: \"aa\"\n    # Output: \"aa\"\n    #\n    # Input: \"aaa\"\n    # Output: \"aaa\"\n    #\n    # Input: \"aaaa\"\n    # Output: \"aaaa\"\n    #\n    # Input: \"aaaaa\"\n    # Output: \"aaaaa\"\n    #\n    # Input: \"aab\"\n    # Output: \"aab\"\n    #\n    # Input: \"aaab\"\n    # Output: \"aaab\"\n    #\n    # Input: \"aaba\"\n    # Output: \"aaba\"\n    #\n    # Input: \"aaaba\"\n    # Output: \"aaaba\"\n    #\n    # Input: \"aabb\"\n    # Output: \"aabb\"\n    #\n    # Input: \"aabbb\"\n    # Output: \"aabbb\"\n    #\n    # Input: \"aabbbb\"\n    # Output: \"aabbbb\"\n    #\n    # Input: \"aabbbbb\"\n    # Output: \"aabbbbb\"",
    "import sys\nimport re\n\ndef longestPalindromicSubsequence(string):\n    \"\"\"\n    :type string: str\n    :rtype: str\n    \"\"\"\n    if not string:\n        return \"\"\n    string = string.lower()\n    regex = re.compile(\"[a-z]*\")\n    for i in range(len(string)):\n        for j in range(len(string)):\n            if regex.match(string[i:j+1]) and string[i:j+1] == string[j:i+1]:\n                if j - i + 1 > len(string):\n                    return string[i:j+1]\n    return \"\"\n\nif __name__ == \"__main__\":\n    string = sys.stdin.readline().strip()\n    print(longestPalindromicSubsequence(string))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return len(s)\n        start = 0\n        end = 0\n        max_len = 0\n        while end < len(s):\n            while end < len(s) and s[end] == s[end - 1]:\n                end += 1\n            while start < len(s) and s[start] == s[start - 1]:\n                start += 1\n            max_len = max(max_len, end - start + 1)\n            end += 1\n            start -= 1\n        return max_len\n\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"abbcc\")",
    "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        \"\"\"\n        Brute force O(n^2)\n        \"\"\"\n        if not s:\n            return \"\"\n        \n        # longestPalindrome = \"\";\n        # longestPalindrome_end = 0;\n        # longestPalindrome_start = 0;\n        # longestPalindrome_end = 0;\n        # longestPalindrome_start = 0;\n        # for i in range(0, len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i] == s[j] and (i - j + 1 > longestPalindrome_end - longestPalindrome_start):\n        #             longestPalindrome_end = i\n        #             longestPalindrome_start = j\n        # print longestPalindrome_end, longestPalindrome_start, s[longestPalindrome_end]\n        \n        # longestPalindrome = s[longestPalindrome_start:longestPalindrome_end+1]\n        # return longestPalindrome\n        \n        longestPalindrome = \"\"\n        \n        stack = []\n        for i in range(0, len(s)):\n            if s[i] == s[i-1]:\n                stack.append(i)\n            else:\n                if len(stack) > 0:\n                    longestPalindrome = s[stack[-1]:i+1]\n                    stack = []\n        return longestPalindrome",
    "# @include\ndef longest_palindromic_subsequence(s):\n    def is_palindromic(i, j):\n        return (s[i] == s[j] and is_palindromic(i - 1, j - 1)\n                or is_palindromic(i - 1, j) or is_palindromic(i, j - 1))\n\n    def longest_palindromic_subsequence_helper(i, j):\n        if i == 0 or j == len(s) - 1:\n            return s[i:j + 1]\n        if is_palindromic(i, j):\n            return s[i:j + 1]\n        if is_palindromic(i - 1, j):\n            return longest_palindromic_subsequence_helper(i - 1, j)\n        return longest_palindromic_subsequence_helper(i, j - 1)\n\n    return longest_palindromic_subsequence_helper(0, len(s) - 1)\n# @exclude\n\ndef longest_palindromic_subsequence(s):\n    return longest_palindromic_subsequence_helper(0, len(s) - 1)\n\ndef longest_palindromic_subsequence_helper(i, j):\n    if i == 0 or j == len(s) - 1:\n        return s[i:j + 1]\n    if s[i] == s[j]:\n        return s[i:j + 1]\n    if s[i] == s[j - 1]:\n        return longest_palindromic_subsequence_helper(i, j - 1)\n    return longest_palindromic_subsequence_helper(i, j - 1)\n\nif __name__ == '__main__':\n    assert longest_palindromic_subsequence('abc') == 'abc'\n    assert longest_palindromic_subsequence('bca') == 'bca'\n    assert longest_palindromic_subsequence('abc') == 'abc'\n    assert longest_palindromic_subsequence('abcd') == 'abcd",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        length = len(s)\n        max_length = 0\n        max_index = -1\n        for i in range(length):\n            for j in range(i+1, length):\n                if s[i:j+1] == s[j:i+1]:\n                    max_length = max(max_length, j-i+1)\n                    if max_length > len(s):\n                        max_index = i\n        return max_length\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.longestPalindrome('aabbcc'))\n    print(s.longestPalindrome('bbb'))\n    print(s.longestPalindrome('abcd'))\n    print(s.longestPalindrome('deee'))\n    print(s.longestPalindrome('a'))\n    print(s.longestPalindrome('aa'))\n    print(s.longestPalindrome('aa'))\n    print(s.longestPalindrome('aa'))\n    print(s.longestPalindrome('abcd'))\n    print(s.longestPalindrome('abcd'))\n    print(s.longestPalindrome('abcd'))\n    print(s.longestPalindrome('abcd'))\n    print(s.longestPalindrome('abbb'))\n    print(s.longestPalindrome('abbb'))",
    "import sys\n\n\nclass Solution:\n\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s:\n            return ''\n        end = len(s)\n        if end == 1:\n            return s\n\n        maxLen = 1\n        maxEnd = 1\n        maxPos = 1\n        curEnd = 1\n        curPos = 1\n        curLen = 1\n        curStr = s[curPos]\n\n        while curEnd < end:\n            if s[curEnd] == curStr:\n                if curLen > maxLen:\n                    maxLen = curLen\n                    maxPos = curPos\n                curLen += 1\n                curEnd += 1\n                curPos += 1\n                curStr = s[curPos]\n            else:\n                if curPos > maxPos:\n                    maxPos = curPos\n                    maxLen = 1\n                    maxEnd = curEnd\n                curPos += 1\n                curEnd += 1\n                curStr = s[curPos]\n                curLen = 1\n            if curEnd == end:\n                break\n        return s[maxPos:maxEnd+1]\n\n    def longestPalindrome1(self, s):\n        if not s:\n            return ''\n        if len(s) == 1:\n            return s\n        end = len(s)\n        if end == 1:\n            return s\n\n        maxLen = 1\n        maxEnd = 1\n        maxPos = 1\n        curEnd = 1\n        curPos = 1\n        curLen = 1\n        curStr = s[curPos]\n\n        while curEnd < end:\n            if s[curEnd] == curStr:\n                if curLen > maxLen:\n                    maxLen = curLen\n                    maxPos = curPos\n                curLen += 1\n                curEnd += 1\n                curPos += 1\n                curStr = s[curPos]\n            else:\n                if curPos > maxPos:\n                    maxPos = curPos\n                    maxLen = 1\n                    maxEnd = curEnd\n                curPos += 1\n                curEnd += 1\n                curStr = s[curPos]\n                curLen = 1\n            if curEnd == end:\n                break",
    "import unittest\nfrom collections import Counter\nfrom string import ascii_lowercase\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        max_len = 0\n        max_idx = 0\n        max_len_len = 0\n        max_len_idx = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and i-j+1 > max_len_len:\n                    max_len = i-j+1\n                    max_len_len = i-j+1\n                    max_len_idx = i\n                    max_idx = j\n        return s[max_idx-max_len_idx+1:max_idx+1]\n\n    def longestPalindrome2(self, s: str) -> str:\n        max_len = 0\n        max_idx = 0\n        max_len_len = 0\n        max_len_idx = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and i-j+1 > max_len_len:\n                    max_len = i-j+1\n                    max_len_len = i-j+1\n                    max_len_idx = i\n                    max_idx = j\n        return s[max_idx-max_len_idx+1:max_idx+1]\n\n    def longestPalindrome3(self, s: str) -> str:\n        max_len = 0\n        max_idx = 0\n        max_len_len = 0\n        max_len_idx = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and i-j+1 > max_len_len:\n                    max_len = i-j+1\n                    max_len_len = i-j+1\n                    max_len_idx = i\n                    max_",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s) == 0:\n            return \"\"\n        \n        maxLen = 1\n        p = []\n        for i in range(len(s)):\n            if s[i] == s[i+1]:\n                p.append(s[i])\n                maxLen = max(maxLen, len(s[i+1:]))\n        \n        return \"\".join(p)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestPalindrome(\"a\")\n    print s.longestPalindrome(\"bbb\")\n    print s.longestPalindrome(\"abba\")",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [[0] * (n + 1) for i in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i, n):\n                if s[i] == s[j] and dp[i][j - 1] > dp[i][j]:\n                    dp[i][j] = dp[i][j - 1]\n                if s[i] == s[j] and dp[j][i + 1] > dp[j][i]:\n                    dp[i][j] = dp[j][i + 1]\n        return dp[0][n - 1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.longestPalindrome('a'))\n    print(s.longestPalindrome('aa'))\n    print(s.longestPalindrome('ab'))\n    print(s.longestPalindrome('abc'))\n    print(s.longestPalindrome('acb'))\n    print(s.longestPalindrome('bbb'))\n    print(s.longestPalindrome('abcdefgh'))\n    print(s.longestPalindrome('abcdefghijklmnopqrstuvwxyz'))",
    "class Solution:\n    # @return a list of lists of string\n    def longestPalindrome(self, s):\n        if not s:\n            return []\n        n = len(s)\n        m = self.getMax(s)\n        palindrome = []\n        for i in range(m):\n            palindrome.append([])\n            for j in range(n):\n                if i-j >= 0 and j+i < n and s[i-j:j+i] == s[j+i:i+j]:\n                    palindrome[i].append(s[j+i:i+j])\n        return palindrome\n\n    def getMax(self, s):\n        m = 0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    m = max(m, j-i+1)\n                    break\n        return m\n\nif __name__ == '__main__':\n    s = \"babad\"\n    s = \"a\"\n    s = \"cbbd\"\n    s = \"bbbcb\"\n    s = \"a\"\n    s = \"aa\"\n    s = \"abcd\"\n    s = \"a\"\n    s = \"aa\"\n    s = \"abbc\"\n    s = \"abcd\"\n    s = \"abbb\"\n    s = \"abbb\"\n    s = \"aa\"\n    s = \"aa\"\n    s = \"aa\"\n    s = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "def longestPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    if len(s) == 2:\n        return 2\n    s_length = len(s)\n    p_length = 2\n    p_candidates = []\n    p_candidates.append(s[0:1])\n    p_candidates.append(s[0:2])\n    for i in range(1, s_length):\n        p_candidates.append(s[i-1:i+1:2])\n        p_candidates.append(s[i-1:i+1:1])\n    p_candidates.append(s[s_length-1:s_length-1:2])\n    p_candidates.append(s[s_length-1:s_length-1:1])\n    max_length = 0\n    for i in range(p_length):\n        for j in range(p_length):\n            if p_candidates[i][j] == s[i:j+1:2]:\n                if i == 0 or j == 0:\n                    max_length = max(max_length, j)\n                else:\n                    max_length = max(max_length, j-i)\n    return max_length\n\nprint(longestPalindrome('a'))",
    "def longestPalindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    if len(s) < 2:\n        return s\n    start = 0\n    end = len(s) - 1\n    while start < end:\n        if s[start] == s[end]:\n            # Check if the substrings are palindromes\n            if s[start:end] == s[end - start:end]:\n                # The longest palindromic subsequence is from start to end\n                return s[start:end+1]\n            else:\n                # The longest palindromic subsequence is from start to end - 1\n                return s[start:end]\n        elif s[start] < s[end]:\n            # The longest palindromic subsequence is from start to end - 1\n            return s[start:end]\n        else:\n            # The longest palindromic subsequence is from start to end + 1\n            return s[start:end+1]\n\n# Test\ns = \"a\"\nprint longestPalindrome(s)\nprint longestPalindrome(\"aa\")\nprint longestPalindrome(\"aba\")\nprint longestPalindrome(\"abbba\")\nprint longestPalindrome(\"abbbbb\")\nprint longestPalindrome(\"abbbbbb\")\nprint longestPalindrome(\"abbbbbbb\")\nprint longestPalindrome(\"abbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbbbbbbbbbbb\")\nprint longestPalindrome(\"abbbbbbbbbb",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s) == 0:\n            return \"\"\n        if len(s) == 1:\n            return s\n        maxlen = 0\n        for i in range(len(s)):\n            j = i\n            while j < len(s) and s[j] == s[j - i]:\n                j += 1\n            maxlen = max(maxlen, j - i)\n        return s[0:maxlen]",
    "import collections\nimport sys\n\ndef longest_palindromic_subsequence(s):\n    # write your code here\n    if not s:\n        return ''\n    # check for palindromic substrings\n    l = len(s)\n    for i in xrange(l):\n        for j in xrange(i, l):\n            if s[i:j+1] == s[j:i+1]:\n                return s[i:j+1]\n    # no palindromic substrings\n    return ''\n\ndef main():\n    s = sys.argv[1]\n    print longest_palindromic_subsequence(s)\n\nif __name__ == '__main__':\n    main()",
    "import collections\n\ndef longest_palindromic_subsequence(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    return max(len(s), 1)\n\ndef longest_palindromic_subsequence2(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not s:\n        return 0\n\n    def longest_palindromic(s, start, end):\n        if start == end:\n            return 1\n        if start >= end:\n            return 0\n        if s[start] == s[end]:\n            return max(longest_palindromic(s, start + 1, end - 1), longest_palindromic(s, start + 1, end)) + 1\n        else:\n            return max(longest_palindromic(s, start + 1, end), longest_palindromic(s, start, end - 1))\n\n    return longest_palindromic(s, 0, len(s) - 1)\n\nif __name__ == '__main__':\n    print(longest_palindromic_subsequence(\"aabbcc\"))\n    print(longest_palindromic_subsequence2(\"aabbcc\"))\n    print(longest_palindromic_subsequence2(\"aabbcc\"))",
    "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        \"\"\"\n        Brute Force\n        :param s: str\n        :return: int\n        \"\"\"\n        ret = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and i-j+1 > ret:\n                    ret = i-j+1\n        return ret\n\n    def longestPalindrome1(self, s: str) -> int:\n        \"\"\"\n        Greedy\n        :param s: str\n        :return: int\n        \"\"\"\n        ret = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j] and i-j+1 > ret:\n                    ret = i-j+1\n        return ret\n\n    def longestPalindrome2(self, s: str) -> int:\n        \"\"\"\n        DP\n        :param s: str\n        :return: int\n        \"\"\"\n        ret = 0\n        dp = [0] * len(s)\n        for i in range(len(s)):\n            dp[i] = 1\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i] = max(dp[i], dp[j] + 2)\n        for i in range(len(s)):\n            if dp[i] > ret:\n                ret = dp[i]\n        return ret",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        lst = []\n        for i in range(len(s)):\n            # print(i)\n            cur_len = 0\n            for j in range(i, len(s)):\n                # print(j)\n                if s[j] == s[i]:\n                    cur_len += 1\n                else:\n                    break\n            if cur_len > max_len:\n                max_len = cur_len\n                lst = [i]\n            elif cur_len == max_len:\n                lst.append(i)\n        return max(lst)\n\n    def longestPalindrome2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        lst = []\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i:j+1] == s[j:i+1]:\n                    max_len = max(max_len, j - i + 1)\n                    lst.append(i)\n                    lst.append(j)\n        return max(lst)\n\n    def longestPalindrome3(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        lst = []\n        for i in range(len(s)):\n            # print(i)\n            cur_len = 0\n            for j in range(i, len(s)):\n                # print(j)\n                if s[j] == s[i]:\n                    cur_len += 1\n                else:\n                    break\n            if cur_len > max_len:\n                max_len = cur_len\n                lst = [i]\n            el",
    "# https://leetcode.com/problems/longest-palindromic-subsequence/discuss/446924/Python-solution-using-a-stack\ndef longestPalindrome(s):\n    if not s: return 0\n    s = s.upper()\n    max_len = 0\n    stack = []\n    for i in range(len(s)):\n        if i < len(s) - 1 and s[i] == s[i + 1]:\n            stack.append(s[i])\n            max_len = max(max_len, len(stack))\n        else:\n            while len(stack) > 0 and s[stack[-1]]!= s[i]:\n                stack.pop()\n            stack.append(s[i])\n    return max_len\n\nprint(longestPalindrome(\"abcd\"))\nprint(longestPalindrome(\"abcdde\"))\nprint(longestPalindrome(\"abcddcde\"))\nprint(longestPalindrome(\"abcddcde\"))\nprint(longestPalindrome(\"abcddcde\"))\nprint(longestPalindrome(\"abcddcde\"))",
    "def longest_palindromic_subsequence(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # check whether the length is odd or even\n    if len(s) % 2!= 0:\n        return 0\n    # check whether the string is empty\n    if len(s) == 0:\n        return 0\n    # check whether the string is palindromic\n    if s == s[::-1]:\n        return len(s)\n    # if the string is not palindromic, return the length of the string\n    return 0",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s) < 2:\n            return s\n        \n        if len(s) == 1:\n            return s\n        \n        max_length = 1\n        max_length_palindrome = 0\n        \n        for i in range(2, len(s)):\n            start = i - 1\n            end = i\n            while start >= 0 and end < len(s):\n                if s[start:end] == s[start:end][::-1]:\n                    max_length_palindrome = max(max_length_palindrome, end - start + 1)\n                    end -= 1\n                start -= 1\n            \n            if max_length_palindrome > max_length:\n                max_length = max_length_palindrome\n                \n        return s[:max_length]",
    "def longest_palindrome(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # Write your code here\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], len(s) if s[:len(s)/2] == s[len(s)/2:]\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], len(s) if s[:len(s)/2] == s[len(s)/2:]\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], 0\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], 0\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], len(s) if s[:len(s)/2] == s[len(s)/2:]\n    # return len(s) if s[:len(s)/2] == s[len(s)/2:], len(s) if s[:len(s)/2] == s[len(s)/2:]\n    return max([len(s) if s[:len(s)/2] == s[len(s)/2:], len(s) if s[:len(s)/2] == s[len(s)/2:]\n               , 0])\n\nif __name__ == '__main__':\n    print(longest_palindrome(\"aab\"))\n    print(longest_palindrome(\"aaab\"))\n    print(longest_palindrome(\"aabb\"))\n    print(longest_palindrome(\"abb\"))\n    print(longest_palindrome(\"abbb\"))\n    print(longest_palindrome(\"ababb\"))\n    print(longest_palindrome(\"aaabb\"))\n    print(longest_palindrome(\"aaabbb\"))\n    print(longest_palindrome(\"ababbb\"))\n    print(longest_palindrome(\"abbbbb\"))",
    "class Solution:\n    # @param s, a string\n    # @return a list of integers\n    def longestPalindrome(self, s):\n        if not s:\n            return []\n        \n        length = len(s)\n        if length == 1:\n            return [length]\n        \n        pairs = []\n        for i in range(length):\n            for j in range(i+1, length):\n                pairs.append((i, j))\n        \n        res = []\n        for pair in pairs:\n            start = pair[0]\n            end = pair[1]\n            subseq = self.subseq(s, start, end)\n            if len(subseq) > len(res):\n                res = subseq\n        return res\n        \n    def subseq(self, s, start, end):\n        if end-start < 2:\n            return []\n        \n        res = []\n        for i in range(start, end):\n            res.append(s[i])\n        res.append(s[start])\n        res.append(s[end])\n        return res",
    "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param {string} s\n    # @return {integer}\n    def longestPalindromeSubseq(self, s):\n        if not s or len(s) < 2:\n            return 0\n        result = 0\n        length = len(s)\n        max_length = 0\n        for i in range(length):\n            length = self.longestPalindromeSubseq(s, i, i, length)\n            if length > max_length:\n                max_length = length\n                result = i\n        return result\n\n    def longestPalindromeSubseq(self, s, i, j, length):\n        if i < 0 or j > length or j < 0:\n            return 0\n        if i == j:\n            return 1\n        if s[i] == s[j]:\n            return 2 + self.longestPalindromeSubseq(s, i+1, j-1, length)\n        else:\n            return max(self.longestPalindromeSubseq(s, i+1, j, length), self.longestPalindromeSubseq(s, i, j-1, length))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i - 1, -1, -1):\n                if s[j] == s[i - 1]:\n                    dp[i] = max(dp[i], dp[j] + 2)\n        return dp[n]\n\n\nif __name__ == '__main__':\n    print Solution().longestPalindrome('a')\n    print Solution().longestPalindrome('aa')\n    print Solution().longestPalindrome('ab')\n    print Solution().longestPalindrome('abc')\n    print Solution().longestPalindrome('aabb')",
    "# @include\ndef longest_palindromic_subsequence(s):\n    \"\"\"\n    :param s: a string\n    :return: a string representing the longest palindromic subsequence\n    \"\"\"\n    if not s:\n        return ''\n\n    # To avoid calculating the length of the longest subsequence, we\n    # need to store the length of the longest subsequence as a list.\n    # For example, if s = 'abc', then the list [1, 2, 2, 3, 3, 3] is\n    # returned.\n    max_length = []\n    for i in range(len(s)):\n        # The length of the longest subsequence is the length of the\n        # longest palindromic subsequence.\n        length = len(longest_palindromic_subsequence(s[:i] + s[i:]))\n        if length > len(max_length):\n            max_length = length\n    return s[:max_length] + s\n# @exclude\n\ndef main():\n    s = 'abcd'\n    assert longest_palindromic_subsequence(s) == 'dcdcba'\n    s = 'abc'\n    assert longest_palindromic_subsequence(s) == 'abc'\n    s = 'abcba'\n    assert longest_palindromic_subsequence(s) == 'cba'\n    s = 'abc'\n    assert longest_palindromic_subsequence(s) == 'abc'\n    s = 'abc'\n    assert longest_palindromic_subsequence(s) == 'abc'\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert longest_palindromic_subsequence(s) == 'abcdefghijklmnopqrstuvwxyz'\n    s = 'abc'\n    assert longest_palindromic_subsequence(s) == 'abc'\n    s = 'abc'\n    assert longest_palindromic_subsequence(s) == 'abc'\n\nif __name__ == '__main__':\n    main()",
    "import sys\n\n# @include\ndef longest_palindrome(s):\n    \"\"\"\n    Returns the longest palindromic subsequence in the given string.\n\n    The length of the returned subsequence will be less than or equal to the given string's length.\n    \"\"\"\n    return longest_palindromic_subsequence(s, 0, len(s) - 1)\n# @exclude\n\n\ndef longest_palindromic_subsequence(s, i, j):\n    if i > j:\n        return 0\n    mid = (i + j) / 2\n    if s[i] == s[mid] and s[mid] == s[j]:\n        return max(longest_palindromic_subsequence(s, i, mid - 1), longest_palindromic_subsequence(s, mid + 1, j)) + 1\n    if s[i] == s[mid] and s[mid]!= s[j]:\n        return longest_palindromic_subsequence(s, i, mid)\n    if s[i]!= s[mid] and s[i] == s[j]:\n        return longest_palindromic_subsequence(s, mid + 1, j)\n    return max(longest_palindromic_subsequence(s, i, mid - 1), longest_palindromic_subsequence(s, mid + 1, j)) + 1\n\n\ndef test_longest_palindromic_subsequence():\n    assert longest_palindromic_subsequence('abc') == 3\n    assert longest_palindromic_subsequence('a') == 1\n    assert longest_palindromic_subsequence('ab') == 2\n    assert longest_palindromic_subsequence('abb') == 3\n    assert longest_palindromic_subsequence('abbb') == 5\n    assert longest_palindromic_subsequence('abbbaabbbaabbbbbabbbaabbabbbbaabbbaabbbaabbbbaabbbaabbbaabbbaabbbaabbbbaabbbaabbbaabbbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabbbaabb",
    "def longestPalindrome(s):\n    if len(s) <= 1:\n        return s\n    max_len = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            l = i\n            while i > 0 and s[i] == s[i - 1]:\n                i = i - 1\n            l = max(l, i)\n            if l > max_len:\n                max_len = l\n    return s[:max_len + 1]\n\n\n\ns = \"aabcc\"\nprint(longestPalindrome(s))",
    "import re\nfrom collections import Counter\nfrom itertools import takewhile\n\ndef longest_palindromic(string):\n    \"\"\"\n    :type string: str\n    :rtype: str\n    \"\"\"\n    if len(string) == 0:\n        return ''\n    if len(string) == 1:\n        return string\n    if string[0] == string[-1]:\n        return string[0:len(string) - 1]\n    longest = ''\n    for i in range(1, len(string)):\n        # check the first half\n        if string[0:i] == string[i:i + len(string)]:\n            longest = string[0:i]\n        # check the second half\n        if string[i:len(string) - 1] == string[i:i + len(string) - 1]:\n            longest = string[0:len(string) - 1] + longest\n    return longest\n\ndef main():\n    s = 'abcabcbb'\n    print(longest_palindromic(s))\n\nif __name__ == '__main__':\n    main()",
    "import sys\nsys.path.append('..')\nimport string\nimport time\nimport random\nfrom collections import Counter\n\n\nclass Solution(object):\n    def is_palindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) <= 1:\n            return True\n        s = s[::-1]\n        return self.is_palindrome(s)\n\n    def longest_palindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not self.is_palindrome(s):\n            return 0\n        cnt = Counter(s)\n        start = 0\n        max_len = 0\n        while start < len(s):\n            max_len = max(max_len, cnt[s[start:]])\n            start += 1\n        return max_len\n\n\nif __name__ == '__main__':\n    start = time.time()\n    sol = Solution()\n    print('time cost:', time.time() - start)\n    s = 'abcabcbb'\n    print(sol.longest_palindrome(s))",
    "# https://leetcode.com/problems/longest-palindromic-subsequence/discuss/111515/Python-Solution-Easy-and-Fast\n\n\"\"\"\nThis is a tricky problem, I think it is a very difficult problem.\n\nWe can use the same idea with the problem \"Longest Common Prefix\"\n\"\"\"\n\n# This is a simple approach.\n# We first build a dictionary for each character,\n# and then we can find the longest palindrome subsequence\n# by using the longest common prefix as the prefix.\n# Note that this approach is very naive.\n\n# The problem is to solve the problem \"Longest Palindromic Subsequence\"\n# which is a problem in the other project.\n# I will solve this problem first, then I will take the solution\n# from the other project.\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0:\n            return ''\n        result = ''\n        # build a dictionary for each character\n        d = {}\n        for i in range(len(s)):\n            d[s[i]] = i\n        # build a dictionary for each character\n        # and build a list of the longest palindromic subsequences\n        lps = []\n        for i in range(len(s)):\n            # find the longest palindrome subsequence\n            lps.append('')\n            # find the longest palindrome subsequence\n            # using the longest common prefix as the prefix\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j] and d[s[i]] < d[s[j]]:\n                    d[s[i]] = d[s[j]]\n                    lps[len(lps) - 1] = s[i] + s[j]\n        # find the longest palindromic subsequence\n        # using the longest common prefix as the prefix\n        for i in range(len(lps)):\n            result = max(result, lps[i])\n        return result\n\n# This is a much more efficient approach.",
    "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {string} s\n    # @return {integer}\n    def longestPalindrome(self, s):\n        if s == '':\n            return 0\n        if len(s) < 3:\n            return len(s)\n        # get the length of longest palindrome\n        maxlen = 1\n        # store the start and end index of each longest palindrome\n        start = 0\n        end = 0\n        # store the left most index of each longest palindrome\n        # (end - start + 1) is the length of longest palindrome\n        # (end - start) is the end index of longest palindrome\n        # start is the start index of longest palindrome\n        # s[start] is the first char of longest palindrome\n        # s[end] is the last char of longest palindrome\n        for i in range(len(s)):\n            # if current char is different from last char\n            if s[i]!= s[end]:\n                # update start index of longest palindrome\n                start = end + 1\n                end = i\n                # update maxlen\n                maxlen = end - start + 1\n        # find the longest palindrome starting from the right most index\n        # i.e. s[end]\n        for j in range(end, len(s)):\n            # if current char is different from the last char\n            if s[j]!= s[end]:\n                # update end index of longest palindrome\n                end = j\n                # update maxlen\n                maxlen = end - start + 1\n        # return maxlen\n        return maxlen",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return \"\"\n        max_length = 0\n        max_length_index = 0\n        max_length_sub = 0\n        for i in range(len(s)):\n            if s[i] == s[-i-1]:\n                max_length_sub += 1\n            else:\n                if max_length_sub > max_length:\n                    max_length = max_length_sub\n                    max_length_index = i\n        return s[max_length_index - max_length:max_length_index + max_length]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestPalindrome('bbbab')\n    print s.longestPalindrome('cbbd')\n    print s.longestPalindrome('bbcbb')",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n+1):\n            dp[i] = 0\n            for j in xrange(i):\n                if s[j] == s[i-j-1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]\n\n    def longestPalindrome2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n+1):\n            dp[i] = 0\n            for j in xrange(i):\n                if s[j] == s[i-j-1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestPalindrome(\"a\")\n    print s.longestPalindrome(\"ab\")\n    print s.longestPalindrome(\"aa\")\n    print s.longestPalindrome(\"aba\")\n    print s.longestPalindrome(\"bab\")\n    print s.longestPalindrome(\"abb\")\n    print s.longestPalindrome(\"abab\")\n    print s.longestPalindrome(\"ababb\")\n    print s.longestPalindrome(\"ababbb\")\n    print s.longestPalindrome(\"abababb\")\n    print s.longestPalindrome(\"abababbb\")",
    "# The longest palindromic subsequence in a string is a subsequence of the string such that each character is repeated exactly once and the entire sequence is a palindrome.\n# For example, the longest palindromic subsequence in \"babad\" is \"bab\" which is 3 characters long.\n# Given a string, find the length of the longest palindromic subsequence in it.\n# Note:\n# The length of the given string will not exceed 1000.\n# The given string will only contain lowercase letters and spaces.\n# Example 1:\n# Input:\n# \"abc\"\n# Output:\n# 3\n# Example 2:\n# Input:\n# \"cbbd\"\n# Output:\n# 5\n\n# T:O(N^2), S:O(N), 4 ms 100%\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n\n        N = len(s)\n        max_len = 0\n        curr_len = 0\n        for i in xrange(N):\n            for j in xrange(i+1, N):\n                if s[i] == s[j] and s[i] == s[N-j-1]:\n                    curr_len = max(curr_len, j-i+1)\n                    max_len = max(max_len, curr_len)\n        return max_len",
    "# https://leetcode.com/problems/longest-palindrome-subsequence/discuss/351096/5-lines\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s: return ''\n        l, r = 0, len(s) - 1\n        while l < r:\n            if s[l] == s[r]:\n                l += 1\n                r -= 1\n            else:\n                if l > r:\n                    break\n                if s[l] == s[r]:\n                    l += 1\n                    r -= 1\n                else:\n                    if l > r:\n                        break\n                    if s[l] == s[r]:\n                        l += 1\n                        r -= 1\n        return s[l:r + 1]\n\n\nif __name__ == '__main__':\n    print Solution().longestPalindrome('abcd')\n    print Solution().longestPalindrome('abba')",
    "class Solution:\n    # @param s, a string\n    # @return a string\n    def longestPalindrome(self, s):\n        if not s: return \"\"\n        s = s[::-1]\n        length = len(s)\n        start = 0\n        end = 0\n        max_len = 0\n        max_start = 0\n        max_end = 0\n        while start < length:\n            end = start + 1\n            while end < length:\n                if s[start:end] == s[end-1:end]:\n                    max_len = max(max_len, end-start+1)\n                    max_start = start\n                    max_end = end\n                end += 1\n            start += 1\n        return s[max_start:max_end+1]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestPalindrome('bbbab')",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n\n        max_length = 0\n        max_index = -1\n        for i in range(len(s)):\n            for j in range(i, len(s) - 1):\n                if s[i] == s[j] and s[i:j + 1] == s[j:i + 1]:\n                    max_length = max(max_length, j - i + 1)\n                    max_index = max(max_index, j)\n        return max_length\n\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"abc\")",
    "def longest_palindrome_subsequence(str):\n    \"\"\"\n    :type str: str\n    :rtype: int\n    \"\"\"\n    max_len = 0\n    max_len_pos = 0\n    for i in range(len(str)):\n        for j in range(i, len(str)):\n            if str[i:j] == str[j:i]:\n                if j - i > max_len:\n                    max_len = j - i\n                    max_len_pos = i\n    return max_len, max_len_pos\n\nif __name__ == '__main__':\n    print(longest_palindrome_subsequence('abcabc'))\n    print(longest_palindrome_subsequence('bbb'))",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 1\n        max_len_str = \"\"\n        for i in range(len(s)):\n            left_str, right_str = s[i:i+2], s[i-1:i+1]\n            if left_str == right_str:\n                max_len_str += left_str\n            else:\n                max_len_str += s[i-1:i+1]\n            if len(max_len_str) > len(s):\n                max_len = len(max_len_str)\n        return max_len\n\n    def longestPalindrome2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 1\n        max_len_str = \"\"\n        for i in range(len(s)):\n            if s[i] == s[i-1]:\n                max_len_str += s[i]\n            else:\n                if len(max_len_str) > len(s):\n                    max_len = len(max_len_str)\n                max_len_str = s[i-1:i+1]\n        return max_len\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestPalindrome('') == 0\n    assert Solution().longestPalindrome('a') == 1\n    assert Solution().longestPalindrome('aa') == 2\n    assert Solution().longestPalindrome('aaa') == 3\n    assert Solution().longestPalindrome('abcd') == 4\n    assert Solution().longestPalindrome('abbba') == 3",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0:\n            return ''\n        max_len = 0\n        max_len_start = -1\n        max_len_end = -1\n        for i in range(len(s)):\n            if len(s[i:]) >= max_len:\n                max_len = len(s[i:])\n                max_len_start = i\n                max_len_end = i + max_len - 1\n        for i in range(max_len_start + 1, max_len_end):\n            if s[i] == s[i - 1] and s[i] == s[max_len_end - i]:\n                max_len = max(max_len, len(s[i - 1:max_len_end + 1]))\n        return s[max_len_start:max_len_end + 1]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.longestPalindrome('abcdefg')\n    print sol.longestPalindrome('cba')\n    print sol.longestPalindrome('abcd')\n    print sol.longestPalindrome('ab')\n    print sol.longestPalindrome('ac')\n    print sol.longestPalindrome('a')\n    print sol.longestPalindrome('b')",
    "# This is the same as a palindromic subsequence in a string\ndef longestPalindromicSubsequence(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    res = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j] and s[i:j + 1] == s[j:i + 1]:\n                res = max(res, j - i + 1)\n    return res",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     return 2\n        \n        # left, right = 0, 0\n        # mid = 0\n        # while left < len(s):\n        #     while right < len(s):\n        #         if s[left] == s[right]:\n        #             mid = max(mid, right - left + 1)\n        #         elif s[left] == s[right + 1]:\n        #             right += 1\n        #         else:\n        #             break\n        #         left += 1\n        #         right += 1\n        # return mid\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = 1\n        # dp[1] = 2\n        # for i in range(2, len(s) + 1):\n        #     dp[i] = max(dp[i - 2], dp[i - 1]) + 1\n        # return dp[-1]\n        # return dp[-1]\n        # return dp[-1]\n        \n        # for i in range(0, len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i] == s[j]:\n        #             if i > 0 and j > 0 and s[i-1] == s[j-1]:\n        #                 return max(dp[i], dp[j]) + 1\n        #             else:\n        #                 return max(dp[i], dp[j])\n        #         elif s[i] == s[j + 1]:\n        #             if i > 0 and j > 0 and s[i-1] == s[j]:\n        #                 return max(dp[i], dp[j]) + 1\n        #             else:\n        #                 return max(dp[i], d",
    "#!/usr/bin/env python\n\ndef find_longest_palindrome(string):\n    # write code here\n    length = len(string)\n    if length <= 1:\n        return ''\n    p = [0] * (length + 1)\n    for i in range(length):\n        for j in range(i, length):\n            if string[i:j+1] == string[j:i+1]:\n                p[j] = max(p[j], p[j-1] + 1)\n    for i in range(length):\n        if p[i] > 0:\n            return string[:i+p[i]-1]\n    return ''\n\nif __name__ == '__main__':\n    assert find_longest_palindrome('abc') == 'abc'\n    assert find_longest_palindrome('aabb') == 'aabb'\n    assert find_longest_palindrome('abcd') == 'abcd'\n    assert find_longest_palindrome('aabbccd') == 'aabbccd'\n    assert find_longest_palindrome('abcd') == 'abcd'\n    assert find_longest_palindrome('abcdabcde') == 'abcd'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'\n    assert find_longest_palindrome('abcabcdefabcdefabcdef') == 'abc'",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        start = 0\n        end = 0\n        max_len = 0\n        while end < len(s):\n            if s[end] == s[start]:\n                start += 1\n                end += 1\n            else:\n                max_len = max(max_len, end - start + 1)\n                start = end\n            end += 1\n        max_len = max(max_len, end - start + 1)\n        return max_len\n\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"a\")\n    print Solution().longestPalindrome(\"aa\")\n    print Solution().longestPalindrome(\"aaa\")\n    print Solution().longestPalindrome(\"aaaa\")\n    print Solution().longestPalindrome(\"aaaaa\")",
    "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0:\n            return \"\"\n\n        l = []\n        r = []\n\n        for i in range(len(s)):\n            if s[i] == s[-1-i]:\n                l.append(s[i])\n            else:\n                r.append(s[i])\n\n        longest = \"\"\n        for i in range(len(r)):\n            if len(longest) < len(r[i]):\n                longest = r[i]\n        return longest\n\n\nif __name__ == \"__main__\":\n    print Solution().longestPalindrome(\"babad\")"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}