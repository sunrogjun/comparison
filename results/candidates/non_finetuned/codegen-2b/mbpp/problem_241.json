{
  "problem": {
    "task_id": "MBPP/252",
    "prompt": "Write a python function to convert complex numbers to polar coordinates.",
    "canonical_solution": "import cmath  \r\ndef convert(numbers):    \r\n  num = cmath.polar(numbers)  \r\n  return (num) ",
    "test_list": [
      "assert convert(1) == (1.0, 0.0)",
      "assert convert(4) == (4.0,0.0)",
      "assert convert(5) == (5.0,0.0)"
    ],
    "challenge_test_list": [],
    "problem_id": 241
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def complex_to_polar(complex_number):\n    \"\"\"\n    Input:\n    complex_number = 2 + 2j\n    Output:\n    r = abs(complex_number)\n    theta = arg(complex_number)\n    \"\"\"\n    r = abs(complex_number)\n    theta = arg(complex_number)\n    return r, theta\n\n# TEST CASES\nprint(complex_to_polar(2 + 2j))\nprint(complex_to_polar(1 + 1j))\nprint(complex_to_polar(1 - 1j))\nprint(complex_to_polar(1 - 2j))\nprint(complex_to_polar(1 - 3j))\nprint(complex_to_polar(1 + 3j))\nprint(complex_to_polar(1 + 4j))\nprint(complex_to_polar(1 + 5j))\nprint(complex_to_polar(1 + 6j))\nprint(complex_to_polar(1 + 7j))\nprint(complex_to_polar(1 + 8j))\nprint(complex_to_polar(1 + 9j))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Input:\n    z = complex number\n\n    Output:\n    r = real part of z\n    theta = argument of z\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    return r, theta\n\n\ndef main():\n    \"\"\"\n    Call the above function to convert complex numbers.\n    \"\"\"\n    z = complex(2, 3)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\n    z = complex(3, 0)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\n    z = complex(0, 3)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\n    z = complex(0, 0)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert a complex number z to polar coordinates.\n    z = r + i*theta\n    r is the real part, theta is the imaginary part.\n    \"\"\"\n    r, theta = z.real, z.imag\n    return (r, theta)\n\ndef test_complex_to_polar():\n    assert complex_to_polar(1+1j) == (1.0, 0.0)\n    assert complex_to_polar(2+2j) == (2.0, 0.0)\n    assert complex_to_polar(3+3j) == (3.0, 0.0)\n    assert complex_to_polar(4+4j) == (4.0, 0.0)\n    assert complex_to_polar(5+5j) == (5.0, 0.0)\n    assert complex_to_polar(6+6j) == (6.0, 0.0)\n    assert complex_to_polar(7+7j) == (7.0, 0.0)\n    assert complex_to_polar(8+8j) == (8.0, 0.0)\n    assert complex_to_polar(9+9j) == (9.0, 0.0)\n    assert complex_to_polar(10+10j) == (10.0, 0.0)\n    assert complex_to_polar(11+11j) == (11.0, 0.0)\n    assert complex_to_polar(12+12j) == (12.0, 0.0)\n    assert complex_to_polar(13+13j) == (13.0, 0.0)\n    assert complex_to_polar(14+14j) == (14.0, 0.0)\n    assert complex_to_polar(15+15j) == (15.0, 0.0)\n    assert complex_to_polar(16+16j) == (16.0, 0.0)\n    assert complex_to_polar(17+17j) == (17.0, 0.",
    "def complex_to_polar(complex_number):\n    \"\"\"\n    Convert complex number to polar coordinates.\n    complex_number: A complex number\n    returns: A tuple of the form (r, theta)\n    \"\"\"\n    real = complex_number.real\n    imag = complex_number.imag\n    return (real, complex(math.atan2(imag, real)))\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex number.\n    r: The real part of the complex number\n    theta: The imaginary part of the complex number\n    returns: A complex number\n    \"\"\"\n    return complex(r, theta)\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    complex_number = complex(1, 2)\n    polar_number = complex_to_polar(complex_number)\n    print(polar_number)\n    polar_number = polar_to_complex(*polar_number)\n    print(polar_number)\n    print(type(polar_number))\n\nif __name__ == '__main__':\n    main()",
    "def to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    z: complex number\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test your function.\n    \"\"\"\n    assert to_polar(1+1j) == (1.0, 0.0)\n    assert to_polar(2+2j) == (2.0, math.pi/4)\n    assert to_polar(-2+2j) == (2.0, -math.pi/4)\n    assert to_polar(-1+1j) == (1.0, -math.pi/4)\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Converts complex numbers to polar coordinates.\n\n    z: complex number\n    returns: tuple of real and imaginary parts\n    \"\"\"\n\n    r = z.real\n    theta = z.imag\n    return (r, theta)\n\nprint(complex_to_polar(2*3*4*5))\nprint(complex_to_polar(3*4))",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    Main function to run the program.\n    \"\"\"\n    z = complex(0.1, 0.2)\n    print(z)\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Input: complex number\n    Output: list of 2 numbers, theta and phi\n    \"\"\"\n    rad = z.real\n    if rad == 0:\n        return [z.imag, 0]\n    else:\n        return [rad*math.pi/180, math.atan(z.imag/rad)]\n\ndef complex_to_cartesian(z):\n    \"\"\"\n    Input: complex number\n    Output: list of 2 numbers, x and y\n    \"\"\"\n    x = z.real\n    y = z.imag\n    return [x, y]\n\nif __name__ == '__main__':\n    test = complex(1.0, 2.0)\n    test2 = complex(-1.0, -2.0)\n    test3 = complex(0.0, 0.0)\n    test4 = complex(0.0, -1.0)\n    test5 = complex(0.0, 1.0)\n    test6 = complex(1.0, 0.0)\n    test7 = complex(0.0, 0.0)\n    test8 = complex(0.0, 0.0)\n    test9 = complex(0.0, 0.0)\n    test10 = complex(0.0, 0.0)\n    test11 = complex(0.0, 0.0)\n    test12 = complex(0.0, 0.0)\n    test13 = complex(0.0, 0.0)\n    test14 = complex(0.0, 0.0)\n    test15 = complex(0.0, 0.0)\n    test16 = complex(0.0, 0.0)\n    test17 = complex(0.0, 0.0)\n    test18 = complex(0.0, 0.0)\n    test19 = complex(0.0, 0.0)\n    test20 = complex(0.0, 0.0)\n    test21 = complex(0.0, 0.0)\n    test22 = complex(0.0, 0.0)\n    test23 = complex(0.0, 0.0)\n    test24 = complex(0.",
    "import math\n\ndef complex2polar(z):\n    \"\"\"\n    Convert a complex number z to polar coordinates.\n    \"\"\"\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar2complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex number.\n    \"\"\"\n    return r * math.cos(theta), r * math.sin(theta)\n\ndef main():\n    \"\"\"\n    Write a program that converts a complex number z to polar coordinates.\n    \"\"\"\n    z = complex(3, 4)\n    r, theta = complex2polar(z)\n    print(\"{0} {1}\".format(r, theta))\n    print(\"{0} {1}\".format(polar2complex(r, theta)))\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Write a python function to convert complex numbers to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan(z.imag/z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Write a main function to test the above function.\n    \"\"\"\n    test_cases = [\n        (complex(1,0), 1, 0),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.pi/2),\n        (complex(1,0), 1, math.",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    This function converts a complex number to polar coordinates.\n\n    z: The complex number to be converted.\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n    z = complex(1, 2)\n    print(z)\n    print(\"The polar coordinates of z are:\", complex_to_polar(z))\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    :param z: complex number\n    :return: (r, theta)\n    \"\"\"\n    r = abs(z)\n    theta = z.imag / r\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test this function.\n    \"\"\"\n    z1 = complex(3, 4)\n    z2 = complex(2, -5)\n    r1, t1 = complex_to_polar(z1)\n    r2, t2 = complex_to_polar(z2)\n    print('r1 =', r1, 'theta1 =', t1)\n    print('r2 =', r2, 'theta2 =', t2)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex numbers.\n    \"\"\"\n    z = complex(r, theta)\n    return z\n\nif __name__ == '__main__':\n    # Test case\n    r = 3.14\n    theta = 1.0\n    z = complex_to_polar(r, theta)\n    polar_to_complex(z[0], z[1])",
    "from math import pi\n\ndef to_polar(z):\n    r = abs(z)\n    theta = pi * arg(z) / 2.0\n    return r, theta\n\ndef main():\n    z = complex(1, 2)\n    print(to_polar(z))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    Returns: polar coordinates of z\n    \"\"\"\n    r = abs(z)\n    phase = math.atan2(z.imag, z.real)\n    return (r, phase)\n\ndef main():\n    print(complex_to_polar(1+2j))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    r, theta = [], []\n    for i in range(0, len(z)):\n        r.append(abs(z[i]))\n        theta.append(angle(z[i]))\n    return r, theta\n\ndef angle(z):\n    \"\"\"\n    Convert complex number z into theta.\n    \"\"\"\n    theta = 2*pi*z.imag/3\n    return theta\n\ndef main():\n    z = [1.0+2.0j, -1.0+2.0j, 1.0-2.0j, -1.0-2.0j]\n    r, theta = complex_to_polar(z)\n    print r\n    print theta\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef convert(z):\n    \"\"\"\n    Convert a complex number z to polar coordinates.\n\n    z: a complex number\n\n    Returns a tuple (r, theta) where r is the real part and theta is the\n    imaginary part of z.\n\n    >>> convert(3 + 4j)\n    (3.0, 4.0)\n    >>> convert(3)\n    (3.0, 0.0)\n    >>> convert(0)\n    (0.0, 0.0)\n    \"\"\"\n    z = complex(z)\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "import math\n\ndef complex_to_polar(z):\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    z = complex(r * math.cos(theta), r * math.sin(theta))\n    return z\n\ndef main():\n    test_cases = [(-1, 0), (0, -math.pi), (1, 0), (math.pi, 0), (1, math.pi), (math.pi, -math.pi), (math.pi, math.pi)]\n\n    for r, theta in test_cases:\n        print(r, theta)\n        print(complex_to_polar(polar_to_complex(r, theta)))\n\n    return 0\n\nif __name__ == \"__main__\":\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\n\ndef main():\n    \"\"\"\n    Call the conversion function.\n    \"\"\"\n    z = complex(2, 4)\n    r, theta = complex_to_polar(z)\n    print(r)\n    print(theta)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Input:\n        z: Complex number\n\n    Output:\n        r: Radian\n        theta: Angle in radians\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\nif __name__ == \"__main__\":\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    print(r, theta)",
    "def complex_to_polar(z):\n    \"\"\"\n    Converts complex number z to polar coordinates.\n\n    >>> complex_to_polar(1.0 + 1.0j)\n    (0.0, 1.0)\n    >>> complex_to_polar(3.0 + 0.0j)\n    (3.0, 0.0)\n    >>> complex_to_polar(1.0 - 1.0j)\n    (3.0, 0.0)\n    \"\"\"\n    return z.real, z.imag",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Complex numbers are represented as a pair of complex numbers.\n    The real part is the real component of the complex number.\n    The imaginary part is the imaginary component of the complex number.\n    The absolute value is the absolute value of the complex number.\n    \"\"\"\n    return math.atan(z.real) + 1j * math.atan(z.imag)\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex numbers.\n\n    The polar coordinates are represented as a pair of real numbers.\n    The real part is the real component of the complex number.\n    The imaginary part is the imaginary component of the complex number.\n    The absolute value is the absolute value of the complex number.\n    \"\"\"\n    return math.cos(theta) * r + 1j * math.sin(theta)\n\nif __name__ == \"__main__\":\n    z = complex(1, 2)\n    print(complex_to_polar(z))\n    print(polar_to_complex(3, 0))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates (r, theta)\n    \"\"\"\n\n    r = abs(z)\n    theta = arg(z)\n\n    if r == 0:\n        return 0, 0\n    else:\n        return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates (r, theta) to complex number\n    \"\"\"\n\n    return r * exp(1j * theta)\n\ndef test_polar_to_complex():\n    \"\"\"\n    Test polar_to_complex()\n    \"\"\"\n    assert polar_to_complex(1, 0) == 1\n    assert polar_to_complex(1, 1) == 1j\n    assert polar_to_complex(1, 2) == 1j\n    assert polar_to_complex(1, 3) == 1j\n    assert polar_to_complex(1, 4) == 1j\n    assert polar_to_complex(1, 5) == 1j\n    assert polar_to_complex(1, 6) == 1j\n    assert polar_to_complex(1, 7) == 1j\n    assert polar_to_complex(1, 8) == 1j\n    assert polar_to_complex(1, 9) == 1j\n    assert polar_to_complex(1, 10) == 1j\n    assert polar_to_complex(1, 11) == 1j\n    assert polar_to_complex(1, 12) == 1j\n    assert polar_to_complex(1, 13) == 1j\n    assert polar_to_complex(1, 14) == 1j\n    assert polar_to_complex(1, 15) == 1j\n    assert polar_to_complex(1, 16) == 1j\n    assert polar_to_complex(1, 17) == 1j\n    assert polar_to_complex(1, 18) == 1j\n    assert polar_to_complex(1, 19) == 1j\n    assert polar_to_complex(1, 20) == 1j\n    assert polar_to_complex(1, 21) == 1j\n    assert polar_to_complex(1, 22",
    "import math\n\ndef polar(complex_num):\n    \"\"\"\n    Write a python function to convert complex numbers to polar coordinates.\n    \n    Example:\n    >>> complex_num = complex(5, -4)\n    >>> polar(complex_num)\n    (5.0, -4.0)\n    \"\"\"\n    real = complex_num.real\n    imag = complex_num.imag\n    \n    # Convert complex number to polar coordinates.\n    r = math.sqrt(real**2 + imag**2)\n    theta = math.atan2(imag, real)\n    \n    # Convert polar coordinates to cartesian coordinates.\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    return (x, y)\n\n# Test function\nif __name__ == '__main__':\n    print \"polar(complex(5, -4)) = \", polar(complex(5, -4))",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    \"\"\"\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\nif __name__ == '__main__':\n    assert complex_to_polar(1+1j) == (1, math.pi/2)\n    assert complex_to_polar(1+1j+1j) == (1, math.pi/2)\n    assert complex_to_polar(1+1j-1j) == (1, math.pi/2)\n    assert complex_to_polar(1-1j) == (1, -math.pi/2)\n    assert complex_to_polar(1-1j+1j) == (1, -math.pi/2)\n    assert complex_to_polar(1-1j-1j) == (1, -math.pi/2)",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Returns the polar coordinates of the complex number z.\n\n    z is a complex number.\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Returns the complex number that corresponds to the polar coordinates r\n    and theta.\n\n    r and theta are polar coordinates.\n    \"\"\"\n    z = complex(r, 0)\n    z = z * math.cos(theta) - complex(r, 0) * math.sin(theta)\n    z = z + complex(r, 0) * math.sin(theta) + complex(r, 0) * math.cos(theta)\n    return z\n\ndef main():\n    \"\"\"\n    Test your function by printing the polar coordinates of the complex\n    number 1 + 2j.\n    \"\"\"\n    z = complex(1, 2)\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n    print(polar_to_complex(r, theta))\n\nif __name__ == '__main__':\n    main()",
    "import numpy as np\nimport math\n\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates\n    z = (r,theta)\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex number\n    r = radius\n    theta = angle\n    \"\"\"\n    return complex(r*math.cos(theta), r*math.sin(theta))\n\n\ndef test_complex_to_polar():\n    z = complex(1, 2)\n    r, theta = complex_to_polar(z)\n    assert r == 1.414\n    assert theta == 3.1415\n\n\ndef test_polar_to_complex():\n    r, theta = 1.414, 3.1415\n    z = polar_to_complex(r, theta)\n    assert z.real == r\n    assert z.imag == theta\n\n\ndef test_complex_to_polar_fail():\n    z = complex(1, -2)\n    r, theta = complex_to_polar(z)\n    assert r == 0.0\n    assert theta == 0.0\n\n\ndef test_polar_to_complex_fail():\n    r, theta = 1.414, 3.1415\n    z = polar_to_complex(r, theta)\n    assert z.real == r\n    assert z.imag == theta\n\n\ndef test_polar_to_complex_fail2():\n    r, theta = 1.414, -3.1415\n    z = polar_to_complex(r, theta)\n    assert z.real == 0.0\n    assert z.imag == 0.0\n\n\ndef test_polar_to_complex_fail3():\n    r, theta = 0.0, 0.0\n    z = polar_to_complex(r, theta)\n    assert z.real == 0.0\n    assert z",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    z is a complex number.\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    z = complex(1, 2)\n    print(complex_to_polar(z))\n\nif __name__ == '__main__':\n    main()",
    "def complex2polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n    z: complex number\n    Returns:\n    r: radius\n    theta: angle\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return r, theta\n\ndef polar2complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex number.\n    r: radius\n    theta: angle\n    Returns:\n    z: complex number\n    \"\"\"\n    z = r * exp(1j * theta)\n    return z\n\ndef test_polar2complex():\n    r, theta = complex2polar(complex(1, 0))\n    assert r == 1\n    assert theta == 0\n    r, theta = complex2polar(complex(1, 1))\n    assert r == 1\n    assert theta == 1j\n    r, theta = complex2polar(complex(1, -1))\n    assert r == 1\n    assert theta == -1j\n    r, theta = complex2polar(complex(1, 2))\n    assert r == 1\n    assert theta == 2j\n    r, theta = complex2polar(complex(1, 3))\n    assert r == 1\n    assert theta == 3j\n    r, theta = complex2polar(complex(1, -2))\n    assert r == 1\n    assert theta == -2j\n    r, theta = complex2polar(complex(1, -3))\n    assert r == 1\n    assert theta == -3j\n    r, theta = complex2polar(complex(1, -4))\n    assert r == 1\n    assert theta == -4j\n    r, theta = complex2polar(complex(1, 5))\n    assert r == 1\n    assert theta == 5j\n    r, theta = complex2polar(complex(1, -5))\n    assert r == 1\n    assert theta == -5j\n    r, theta = complex2polar(complex(1, 6))\n    assert r == 1\n    assert theta == 6j\n    r,",
    "def complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    returns: polar coordinates\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    return r, theta\n\ndef main():\n    \"\"\"\n    Write a test program that uses the function complex_to_polar to convert the\n    complex number (z) to polar coordinates.\n    \"\"\"\n    z = complex(1, 2)\n    r, theta = complex_to_polar(z)\n    print 'r =', r, 'theta =', theta\n\nif __name__ == '__main__':\n    main()",
    "import numpy as np\nimport math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number z into polar coordinates.\n    z is a complex number.\n    Return a tuple (r, theta), where r is the modulus and theta is the phase.\n    \"\"\"\n    return math.sqrt(z.real**2 + z.imag**2), math.atan2(z.imag, z.real)\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert a polar coordinates r and theta into a complex number.\n    r is the modulus, theta is the phase.\n    Return a complex number z.\n    \"\"\"\n    return complex(r * math.cos(theta), r * math.sin(theta))\n\ndef main():\n    \"\"\"\n    Test the conversion using some sample values.\n    \"\"\"\n    r, theta = complex_to_polar(complex(3.0, 4.0))\n    print(r, theta)\n    z = polar_to_complex(r, theta)\n    print(z)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n\n    z = complex number to be converted\n    returns a tuple of the form (r, theta).\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    Test the function.\n    \"\"\"\n    assert complex_to_polar((1,0)) == (1, 0)\n    assert complex_to_polar((0,1)) == (1, math.pi/2)\n    assert complex_to_polar((0,0)) == (1, 0)\n    assert complex_to_polar((1,1)) == (1, math.pi/4)\n    assert complex_to_polar((1,1j)) == (1, math.pi/4)\n    assert complex_to_polar((-1,1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1+1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1-1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1+1j+1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1-1j+1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1+1j-1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1-1j-1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1+1j-1j+1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1-1j-1j+1j)) == (1, math.pi/4)\n    assert complex_to_polar((1,1+1j+1j-1j)) == (",
    "def complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    returns: a tuple (r, theta)\n    \"\"\"\n    r = abs(z)\n    theta = math.atan(z.imag/z.real)\n    if z.real < 0:\n        theta += 2*math.pi\n    if r == 0:\n        return (0, 0)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    main function\n    \"\"\"\n    for i in range(0, 50):\n        z = complex(i, 0)\n        r, theta = complex_to_polar(z)\n        print(i, r, theta)\n\nif __name__ == \"__main__\":\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    z is a complex number\n    \"\"\"\n    return math.atan2(z.imag, z.real), math.sqrt(z.real * z.real + z.imag * z.imag)\n\ndef main():\n    \"\"\"\n    Run some tests\n    \"\"\"\n    z = complex(2, 3)\n    assert complex_to_polar(z) == (math.pi / 2, 2)\n    z = complex(2, -3)\n    assert complex_to_polar(z) == (math.pi / 2, 2)\n    z = complex(2, 3) * complex(3, -1)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, 1)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, 2)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, -2)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, 0)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, -3)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, 4)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, -4)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) * complex(3, 5)\n    assert complex_to_polar(z) == (math.pi / 2, 4)\n    z = complex(2, 3) *",
    "def convert(z):\n    r = abs(z)\n    theta = arg(z)\n    return r, theta\n\ndef test():\n    assert convert(1) == (1, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1.1) == (1.1, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1.1+1j) == (1.1+1j, 0)\n    assert convert(1.1-1j) == (1.1-1j, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1.1+1j) == (1.1+1j, 0)\n    assert convert(1.1-1j) == (1.1-1j, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1+1j) == (1+1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1-1j, 0)\n    assert convert(1-1j) == (1",
    "import math\n\ndef polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates\n    \"\"\"\n    mag = math.sqrt(z.real**2 + z.imag**2)\n    angle = math.atan2(z.imag, z.real)\n    return mag, angle\n\ndef test():\n    z = complex(1, 2)\n    print(polar(z))\n    z = complex(1, 2)\n    print(z.real, z.imag)\n    z = complex(1, 2)\n    print(z.imag)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n    z = complex(1, 2)\n    print(z.imag)\n    z = complex(1, 2)\n    print(z.imag)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n    z = complex(1, 2)\n    print(z.imag, z.real)\n\nif __name__ == '__main__':\n    test()",
    "def complex_to_polar(z):\n    \"\"\"\n    Write a function to convert complex numbers to polar coordinates.\n    z = complex number\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    Write a function to convert complex numbers to polar coordinates.\n    z = complex number\n    \"\"\"\n    z = complex(2, 2)\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n\nif __name__ == '__main__':\n    main()",
    "def polar(z):\n    \"\"\"\n    Return a tuple of polar coordinates for complex number z.\n    \"\"\"\n    r = abs(z)\n    theta = arctan(z.imag / r)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test the polar function.\n    \"\"\"\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    convert a complex number to polar coordinates\n\n    :param z: the complex number to convert\n    :return: a tuple containing the real and imaginary part of z and the angle\n    \"\"\"\n    return z.real, z.imag, 2 * np.arctan(z.imag / z.real)\n\n\ndef polar_to_complex(z):\n    \"\"\"\n    convert a complex number to polar coordinates\n\n    :param z: the complex number to convert\n    :return: a tuple containing the real and imaginary part of z and the angle\n    \"\"\"\n    return z.real, z.imag, 2 * np.arctan(z.imag / z.real)\n\n\nif __name__ == \"__main__\":\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex_to_polar((3, 4)) == (3, 4, 5)\n    assert complex",
    "# The input to the function should be a complex number\n# Complex numbers are represented as a tuple (real, imaginary)\n# Input is the complex number\n\ndef complex_to_polar(z):\n    # convert complex number to polar coordinates\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\n# print the complex number\nprint(\"The polar coordinates of the complex number are:\")\nprint(complex_to_polar(1+2j))\nprint(complex_to_polar(1-2j))\nprint(complex_to_polar(1+3j))\nprint(complex_to_polar(1-3j))\nprint(complex_to_polar(1+4j))\nprint(complex_to_polar(1-4j))\nprint(complex_to_polar(1+5j))\nprint(complex_to_polar(1-5j))\nprint(complex_to_polar(1+6j))\nprint(complex_to_polar(1-6j))\nprint(complex_to_polar(1+7j))\nprint(complex_to_polar(1-7j))\nprint(complex_to_polar(1+8j))\nprint(complex_to_polar(1-8j))\nprint(complex_to_polar(1+9j))\nprint(complex_to_polar(1-9j))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = arctan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Unit test for complex_to_polar.\n    \"\"\"\n    z = complex(1.5, 1.5)\n    r, theta = complex_to_polar(z)\n    assert r == 1.5 and theta == 1.5\n    z = complex(1.5, -1.5)\n    r, theta = complex_to_polar(z)\n    assert r == 1.5 and theta == 3.1415\n    z = complex(-1.5, -1.5)\n    r, theta = complex_to_polar(z)\n    assert r == 1.5 and theta == 3.1415\n    z = complex(-1.5, 1.5)\n    r, theta = complex_to_polar(z)\n    assert r == 1.5 and theta == -1.5\n    z = complex(1.5, -1.5)\n    r, theta = complex_to_polar(z)\n    assert r == 1.5 and theta == -3.1415\n\nif __name__ == \"__main__\":\n    main()",
    "def polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    >>> polar(complex(1, 2))\n    (1.0, 2.0)\n    >>> polar(complex(1, -2))\n    (1.0, -2.0)\n    >>> polar(complex(1, 0))\n    (1.0, 0.0)\n    >>> polar(complex(1, 1))\n    (1.0, 1.0)\n    >>> polar(complex(1, -1))\n    (1.0, -1.0)\n    >>> polar(complex(1, -2))\n    (1.0, -2.0)\n    >>> polar(complex(1, -3))\n    (1.0, -3.0)\n    >>> polar(complex(1, -4))\n    (1.0, -4.0)\n    \"\"\"\n    r = abs(z)\n    theta = z.imag\n    return (r, theta)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    returns: (r, theta)\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return (r, theta)\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    r: real\n    theta: complex\n    returns: (z)\n    \"\"\"\n    return r * exp(1j * theta)",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert a complex number z to polar coordinates.\n    \"\"\"\n    return z.real, z.imag\n\ndef main():\n    \"\"\"\n    Unit tests for complex_to_polar().\n    \"\"\"\n    assert complex_to_polar(1) == (1, 0)\n    assert complex_to_polar(1j) == (0, 1)\n    assert complex_to_polar(1.0) == (1.0, 0.0)\n    assert complex_to_polar(1.0j) == (0.0, 1.0)\n    assert complex_to_polar(1j + 1) == (1.0, 1.0)\n    assert complex_to_polar(1.0 + 1j) == (1.0, 1.0)\n    assert complex_to_polar(1.0j + 1) == (1.0, 1.0)\n    assert complex_to_polar(1.0 + 1j + 1.0j) == (1.0, 1.0)\n    assert complex_to_polar(1.0 + 1j + 1.0j) == (1.0, 1.0)\n    assert complex_to_polar(1.0 + 1j + 1.0j) == (1.0, 1.0)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    z is a complex number.\n    Returns (r, theta) where r is the real part and theta is the\n    imaginary part.\n    \"\"\"\n    return complex(z.real, z.imag)\n\ndef test_complex_to_polar():\n    z = complex(1.0, 1.0)\n    r, theta = complex_to_polar(z)\n    assert r == 1.0\n    assert theta == 1.0\n\nif __name__ == \"__main__\":\n    test_complex_to_polar()",
    "def complex_to_polar(z):\n    r = z.real\n    theta = z.imag\n    return r, theta\n\ndef main():\n    z = complex(1, 3)\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(c):\n    r = c.real\n    theta = c.imag\n    return r * np.cos(theta), r * np.sin(theta)\n\ndef test_polar_to_complex():\n    assert complex_to_polar(complex(1,2)) == (1.0, 2.0)\n    assert complex_to_polar(complex(1,0)) == (1.0, 0.0)\n    assert complex_to_polar(complex(0,2)) == (0.0, 2.0)\n    assert complex_to_polar(complex(0,0)) == (0.0, 0.0)\n\ndef test_polar_to_complex_with_nan():\n    assert complex_to_polar(complex(np.nan,1)) == (np.nan, 1.0)\n    assert complex_to_polar(complex(np.nan,np.nan)) == (np.nan, np.nan)\n    assert complex_to_polar(complex(np.nan,np.nan,np.nan)) == (np.nan, np.nan)\n\ndef test_polar_to_complex_with_inf():\n    assert complex_to_polar(complex(np.inf,1)) == (np.inf, 1.0)\n    assert complex_to_polar(complex(np.inf,np.inf)) == (np.inf, np.inf)\n    assert complex_to_polar(complex(np.inf,np.inf,np.inf)) == (np.inf, np.inf)\n\ndef test_polar_to_complex_with_zero():\n    assert complex_to_polar(complex(0,1)) == (0.0, 1.0)\n    assert complex_to_polar(complex(0,np.inf)) == (0.0, np.inf)\n    assert complex_to_polar(complex(0,np.nan)) == (0.0, np.nan)\n\ndef test_polar_to_complex_with_complex():\n    assert complex_to_polar(complex(1,1)) == (1",
    "import math\n\ndef complex_to_polar(complex_number):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n\n    Input:\n        complex_number: A complex number.\n\n    Output:\n        A tuple containing the real and imaginary parts of the complex number\n        in the following order: (real, imaginary).\n    \"\"\"\n    real = complex_number.real\n    imag = complex_number.imag\n\n    # Calculate the magnitude.\n    mag = math.sqrt(real**2 + imag**2)\n\n    # Calculate the phase.\n    phase = math.atan2(imag, real)\n\n    # Return the magnitude and phase as a tuple.\n    return (mag, phase)\n\nif __name__ == \"__main__\":\n    # Test your function by converting the complex number (1+2j) to polar\n    # coordinates and comparing the result with the expected result.\n    print complex_to_polar((1+2j))\n    print complex_to_polar((2+3j))\n    print complex_to_polar((4+5j))\n    print complex_to_polar((6+7j))\n    print complex_to_polar((8+9j))",
    "from __future__ import division\n\nimport math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n\n    >>> complex_to_polar(1+1j)\n    (0.785398163397448309615236214015625, 2.35619449019234492884)\n\n    >>> complex_to_polar(1+1j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j)\n    (0.785398163397448309615236214015625, 1.57079632679489661923)\n\n    >>> complex_to_polar(1+1j*1.0j*1j)\n    (0.785398163397448309615236214015625, 2.35619449019234492884)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j*1.0j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j*1.0j*1.0j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j*1.0j*1.0j*1.0j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(1+1j*1.0j*1.0j*1.0j*1.0j*1.0j*1.0j*1j)\n    (1.0, 1.0)\n\n    >>> complex_to_polar(",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    >>> complex_to_polar(1+2j)\n    (1.0, 3.14159265358979)\n    >>> complex_to_polar(3+4j)\n    (3.0, 6.28318530717959)\n    >>> complex_to_polar(-1+2j)\n    (1.0, -3.14159265358979)\n    >>> complex_to_polar(-3+4j)\n    (3.0, -6.28318530717959)\n    >>> complex_to_polar(0+0j)\n    (0.0, 0.0)\n    >>> complex_to_polar(1+0j)\n    (1.0, 0.0)\n    >>> complex_to_polar(1+2j)\n    (1.0, 3.14159265358979)\n    >>> complex_to_polar(3+4j)\n    (3.0, 6.28318530717959)\n    >>> complex_to_polar(-1+2j)\n    (1.0, -3.14159265358979)\n    >>> complex_to_polar(-3+4j)\n    (3.0, -6.28318530717959)\n    \"\"\"\n\n    real = z.real\n    imag = z.imag\n    r = real\n    theta = imag * pi / 180.0\n\n    if r == 0:\n        return (0.0, 0.0)\n\n    return (r * cos(theta), r * sin(theta))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def complex_to_polar(z):\n    \"\"\"\n    Returns the complex number z in the form (r, theta).\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return r, theta\n\ndef test_complex_to_polar():\n    assert complex_to_polar((1+1j)) == (1, 0)\n    assert complex_to_polar((1-1j)) == (1, pi/2)\n    assert complex_to_polar((-1+1j)) == (1, pi)\n    assert complex_to_polar((-1-1j)) == (1, 3*pi/2)\n    assert complex_to_polar((0+1j)) == (1, 0)\n    assert complex_to_polar((0-1j)) == (1, pi)\n    assert complex_to_polar((1-0j)) == (1, pi)\n    assert complex_to_polar((1+0j)) == (1, pi/2)\n    assert complex_to_polar((-1-0j)) == (1, 3*pi/2)\n    assert complex_to_polar((-1+0j)) == (1, 3*pi/2)\n    assert complex_to_polar((0+0j)) == (1, 0)\n    assert complex_to_polar((0-0j)) == (1, pi)\n    assert complex_to_polar((0-1j)) == (1, pi)\n    assert complex_to_polar((1-0j)) == (1, pi/2)\n    assert complex_to_polar((1+0j)) == (1, pi/2)\n    assert complex_to_polar((-1+0j)) == (1, 3*pi/2)\n    assert complex_to_polar((-1-0j)) == (1, 3*pi/2)\n    assert complex_to_polar((-1-1j)) == (1, 0)\n    assert complex_to_polar((-1+1j)) == (1, 3*pi/2)\n    assert complex",
    "from math import atan, cos, sin, pi\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Input:\n    z -- complex number to convert.\n\n    Output:\n    r -- real part of z\n    theta -- imaginary part of z\n\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    theta = atan(r/theta)\n    if theta < 0:\n        theta = theta + 2*pi\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex numbers.\n\n    Input:\n    r -- real part of z\n    theta -- imaginary part of z\n\n    Output:\n    z -- complex number\n\n    \"\"\"\n    z = complex(r, theta)\n    return z\n\nif __name__ == \"__main__\":\n    # Test complex to polar\n    assert complex_to_polar(1) == (1, 0)\n    assert complex_to_polar(-1) == (1, pi)\n    assert complex_to_polar(0) == (0, 0)\n    assert complex_to_polar(1j) == (1, pi/2)\n    assert complex_to_polar(-1j) == (1, -pi/2)\n    assert complex_to_polar(2) == (2, 0)\n    assert complex_to_polar(3) == (3, pi/4)\n    assert complex_to_polar(-2) == (2, -pi/4)\n    assert complex_to_polar(-3) == (3, -pi/4)\n\n    # Test polar to complex\n    assert polar_to_complex(1, 0) == 1\n    assert polar_to_complex(1, pi/2) == 1j\n    assert polar_to_complex(1, pi) == 1\n    assert polar_to_complex(1, 3*pi/4) == 1j\n    assert polar_to_complex(1, -pi/4) == 1\n    assert polar_to_complex(1, -pi/2) == 1",
    "def complex_to_polar(complex_number):\n    \"\"\"\n    :param complex_number: The complex number\n    :return: The polar coordinates\n    \"\"\"\n    return complex_number.real, complex_number.imag\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    print(complex_to_polar(complex_number=2.3+3j))\n    print(complex_to_polar(complex_number=2.3+3j))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    r, theta = 0, 0\n    if z.real == 0:\n        return r, theta\n    if z.real < 0:\n        theta = 2 * math.pi\n    else:\n        theta = 0\n    return r * math.cos(theta), r * math.sin(theta)\n\ndef main():\n    z = complex(1, 0)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex2polar(z):\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar2complex(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return x + 1j * y\n\ndef main():\n    for z in (1 + 1j, 1.1 + 1j, 1.0001 + 1j):\n        r, theta = complex2polar(z)\n        print r, theta\n        print polar2complex(r, theta)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    z = complex number\n    returns a tuple (r, theta) where r is the real part and theta is the\n    imaginary part\n    \"\"\"\n\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    r = real part\n    theta = imaginary part\n    returns a complex number\n    \"\"\"\n\n    return r * math.cos(theta), r * math.sin(theta)",
    "def complex_to_polar(c):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Args:\n        c: a complex number\n    Returns:\n        a tuple of the form (r, theta) where r is the real part and theta is the\n        imaginary part\n    \"\"\"\n    r = abs(c)\n    theta = atan2(c.imag, c.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Write a function to convert complex numbers to polar coordinates.\n    \"\"\"\n    c = complex(1, 2)\n    print(complex_to_polar(c))\n    c = complex(1, 2)\n    print(complex_to_polar(c))\n    c = complex(1, 2)\n    print(complex_to_polar(c))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    z is a complex number\n    returns a tuple (r, theta) where r is the real part and theta is the\n    imaginary part\n    \"\"\"\n\n    r = z.real\n    theta = z.imag\n    return (r, theta)\n\nprint complex_to_polar(3.5+2j)",
    "def complex_to_polar(z):\n    \"\"\"\n    Given a complex number z, return the polar coordinates x and y.\n\n    Complex numbers are represented as a pair of real and imaginary parts,\n    e.g. (3,4) is represented by (3+4j).\n\n    The argument is always the second component of the pair.\n    \"\"\"\n    # x = abs(z.real) + j * abs(z.imag)\n    # y = arg(z.real) + j * arg(z.imag)\n    # z = x * exp(1j * y)\n    x, y = z.real, z.imag\n    return x * np.exp(1j * y)\n\n\ndef polar_to_complex(z):\n    \"\"\"\n    Given a complex number z, return the real and imaginary parts.\n\n    Complex numbers are represented as a pair of real and imaginary parts,\n    e.g. (3,4) is represented by (3+4j).\n\n    The argument is always the second component of the pair.\n    \"\"\"\n    real, imag = z.real, z.imag\n    return real, imag * np.exp(1j * real)\n\n\nif __name__ == '__main__':\n    # Test the complex_to_polar function\n    print(complex_to_polar((3, 4)))\n\n    # Test the polar_to_complex function\n    print(polar_to_complex((3, 4)))",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n    \"\"\"\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    a = complex(1, -2)\n    r, theta = complex_to_polar(a)\n    print(\"(r, theta) = ({}, {})\".format(r, theta))\n\nif __name__ == \"__main__\":\n    main()",
    "import math\n\ndef polar_to_cartesian(r, theta):\n    return r*math.cos(theta), r*math.sin(theta)\n\ndef main():\n    r = input('Enter the radius: ')\n    theta = input('Enter the angle: ')\n    print(polar_to_cartesian(r, theta))\n\nmain()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    z is a complex number in the form (r,i) where r is the real part\n    and i is the imaginary part.\n    \"\"\"\n    return math.atan2(z.imag, z.real), math.degrees(math.atan2(z.imag, z.real))\n\ndef main():\n    \"\"\"\n    Use complex_to_polar() to convert complex numbers to polar coordinates.\n    \"\"\"\n    for z in [1, 2, 3, 4, 5, 6]:\n        print('r =', complex_to_polar(z)[0], '\\ti =', complex_to_polar(z)[1])\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n    \"\"\"\n    rad = math.atan(z.imag / z.real)\n    if z.real < 0:\n        rad = 2 * math.pi + rad\n    return rad, z.real, z.imag\n\ndef polar_to_complex(r, theta, phi):\n    \"\"\"\n    Convert polar coordinates r, theta, phi to complex number.\n    \"\"\"\n    return complex(r * math.cos(theta), r * math.sin(theta) * math.cos(phi))\n\nif __name__ == \"__main__\":\n    a = complex_to_polar(1 + 2j)\n    print(a)\n\n    b = polar_to_complex(*a)\n    print(b)",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert a complex number z to polar coordinates (r, theta).\n    z is a complex number.\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    return r, theta\n\nif __name__ == '__main__':\n    print(complex_to_polar(3.0 + 5.0j))\n    print(complex_to_polar(3.0 + 5.0j))\n    print(complex_to_polar(3.0 + 5.0j))",
    "def convert(complex_num):\n    \"\"\"\n    Write a function to convert complex numbers to polar coordinates.\n    :param complex_num: A complex number\n    :return: A tuple containing the real and imaginary parts of the complex number in polar coordinates\n    \"\"\"\n    real = complex_num.real\n    imag = complex_num.imag\n    # convert to radians\n    r = math.atan2(imag, real)\n    # convert to degrees\n    degrees = math.degrees(r)\n    # return tuple of the real and imaginary parts\n    return (real, imag)",
    "import math\n\ndef complex_to_polar(c):\n    \"\"\"\n    Convert complex number to polar coordinates.\n\n    Complex number is represented as (r, i).\n\n    >>> complex_to_polar((1, 0))\n    (1.0, 0.0)\n    >>> complex_to_polar((1, 1))\n    (1.0, 1.0)\n    >>> complex_to_polar((1, 2))\n    (1.0, 2.0)\n    >>> complex_to_polar((0, 0))\n    (0.0, 0.0)\n    >>> complex_to_polar((0, 1))\n    (0.0, 1.0)\n    >>> complex_to_polar((0, 2))\n    (0.0, 2.0)\n    \"\"\"\n    return math.sqrt(c.real**2 + c.imag**2), c.real\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# The first time you run this, the first time it runs, it will print out\n# the number of arguments.\n\ndef complex_to_polar(x):\n    \"\"\"\n    This function takes in a complex number and returns the polar\n    coordinates of it.\n    \"\"\"\n    r = abs(x)\n    theta = (x.imag / 2) * np.pi\n    return r, theta\n\ndef main():\n    \"\"\"\n    The main function to run.\n    \"\"\"\n    print(complex_to_polar(complex(1, 2)))\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(c):\n    \"\"\"\n    Converts complex numbers to polar coordinates.\n    \"\"\"\n    real = c.real\n    imag = c.imag\n    r = abs(real)\n    theta = atan2(imag, real)\n    if r == 0:\n        return 0, 0\n    return r, theta\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Test the function by converting to polar coordinates and back\n    \"\"\"\n    print(complex_to_polar(1 + 2j))\n    print(complex_to_polar(3 + 4j))\n    print(complex_to_polar(5 + 6j))\n    print(complex_to_polar(7 + 8j))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    >>> complex_to_polar(1 + 2j)\n    (0.995312563635, 1.01011254309)\n    >>> complex_to_polar(1 + 2j)\n    (0.995312563635, 1.01011254309)\n    >>> complex_to_polar(3 + 4j)\n    (0.995312563635, 1.01011254309)\n    \"\"\"\n    return complex_to_cartesian(z), 0\n\ndef complex_to_cartesian(z):\n    \"\"\"\n    Convert complex numbers to cartesian coordinates.\n\n    >>> complex_to_cartesian(1 + 2j)\n    (1.995312563635, 1.01011254309)\n    >>> complex_to_cartesian(1 + 2j)\n    (1.995312563635, 1.01011254309)\n    >>> complex_to_cartesian(3 + 4j)\n    (3.995312563635, 1.01011254309)\n    \"\"\"\n    return z.real, z.imag\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def complex_to_polar(z):\n    \"\"\"\n    Args:\n        z: complex number\n    Returns:\n        r: real part\n        theta: phase\n    \"\"\"\n\n    r = abs(z.real)\n    theta = atan2(z.imag, z.real)\n\n    return r, theta\n\n\ndef main():\n    \"\"\"\n    Runs the conversion from complex to polar coordinates.\n    \"\"\"\n\n    print(complex_to_polar(3.3 + 2.2j))\n    print(complex_to_polar(3.3 - 2.2j))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Input:\n        z: A complex number\n\n    Output:\n        r: The real part\n        theta: The argument\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    return r, theta\n\ndef main():\n    \"\"\"\n    Execute the main program.\n    \"\"\"\n    z = complex(0, 1)\n    r, theta = complex_to_polar(z)\n    print('r =', r)\n    print('theta =', theta)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef convert_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    z: complex number\n    returns: float\n    \"\"\"\n    r = math.sqrt(z.real ** 2 + z.imag ** 2)\n    theta = math.atan2(z.imag, z.real)\n    return r * math.cos(theta), r * math.sin(theta)\n\ndef convert_to_cartesian(r, theta):\n    \"\"\"\n    Convert polar coordinates to cartesian coordinates.\n\n    r: float\n    theta: float\n    returns: complex\n    \"\"\"\n    return r * math.cos(theta) + math.sin(theta) * math.sqrt(1 - r ** 2)\n\ndef main():\n    \"\"\"\n    main\n    \"\"\"\n    x = convert_to_polar(complex(1, 1))\n    y = convert_to_polar(complex(2, 2))\n    z = convert_to_polar(complex(3, 3))\n\n    print(x)\n    print(y)\n    print(z)\n\nif __name__ == '__main__':\n    main()",
    "def polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n\n    >>> polar(1 + 2j)\n    (0.7853981633974483, 3.141592653589793)\n    >>> polar(2 + 3j)\n    (1.5707963267948966, 0.0)\n    >>> polar(4 + 5j)\n    (2.3561944901923448, 0.7853981633974483)\n    >>> polar(6 + 7j)\n    (2.3561944901923448, 1.5707963267948966)\n    \"\"\"\n    return complex(0.0, 0.0), z\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n\n    z: complex number\n    Returns:\n    r: real part\n    theta: phase angle\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    return r, theta\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Convert polar coordinates to complex number.\n\n    r: real part\n    theta: phase angle\n    Returns:\n    z: complex number\n    \"\"\"\n    z = r * np.exp(1j * theta)\n    return z\n\ndef main():\n    \"\"\"\n    Simple test of the complex_to_polar and polar_to_complex functions.\n    \"\"\"\n    # complex number\n    z = complex(1, 2)\n    r, theta = complex_to_polar(z)\n    z = polar_to_complex(r, theta)\n    assert z == complex(1, 2)\n    # complex number in a list\n    z = complex([1, 2])\n    r, theta = complex_to_polar(z)\n    z = polar_to_complex(r, theta)\n    assert z == complex(1, 2)\n    # complex number in a tuple\n    z = complex([1, 2])\n    r, theta = complex_to_polar(z)\n    z = polar_to_complex(r, theta)\n    assert z == complex(1, 2)\n    # complex number in a tuple\n    z = complex([1, 2])\n    r, theta = complex_to_polar(z)\n    z = polar_to_complex(r, theta)\n    assert z == complex(1, 2)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test the function\n    \"\"\"\n    print(complex_to_polar(1+2j))\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    return np.angle(z), np.abs(z)\n\nif __name__ == \"__main__\":\n    print complex_to_polar(complex(1, 2))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    z -- complex number to convert\n\n    Returns a tuple (r, theta) where r is the real part and theta is the\n    imaginary part of z.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    Run the main program.\n    \"\"\"\n    # Test the complex_to_polar function\n    z = complex(1, 2)\n    assert complex_to_polar(z) == (1.0, 2.0)\n\n    # Test the polar coordinates\n    assert complex_to_polar(complex(1, 0)) == (1.0, 0.0)\n    assert complex_to_polar(complex(1, -1)) == (1.0, -1.0)\n    assert complex_to_polar(complex(1, -2)) == (1.0, -2.0)\n    assert complex_to_polar(complex(1, -3)) == (1.0, -3.0)\n    assert complex_to_polar(complex(1, -4)) == (1.0, -4.0)\n    assert complex_to_polar(complex(1, -5)) == (1.0, -5.0)\n    assert complex_to_polar(complex(1, -6)) == (1.0, -6.0)\n    assert complex_to_polar(complex(1, -7)) == (1.0, -7.0)\n    assert complex_to_polar(complex(1, -8)) == (1.0, -8.0)\n    assert complex_to_polar(complex(1, -9)) == (1.0, -9.0)\n    assert complex_to_polar(complex(1, -10)) == (1.0, -10.0)\n    assert complex_to_polar(complex(1, -11)) == (1.0, -11.0)\n    assert complex_to_polar",
    "def polar_to_cartesian(z):\n    \"\"\"\n    Convert complex number z to cartesian coordinates.\n    \"\"\"\n    x = z.real\n    y = z.imag\n    return (x, y)\n\ndef cartesian_to_polar(xy):\n    \"\"\"\n    Convert cartesian coordinates to polar coordinates.\n    \"\"\"\n    x = xy[0]\n    y = xy[1]\n    r = sqrt(x**2 + y**2)\n    theta = atan2(y, x)\n    return (r, theta)\n\ndef main():\n    \"\"\"\n    Test the function.\n    \"\"\"\n    z = complex(3, 4)\n    xy = polar_to_cartesian(z)\n    xy2 = cartesian_to_polar(xy)\n    print(z, xy, xy2)\n\nif __name__ == \"__main__\":\n    main()",
    "# Import the math library\nimport math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert complex number to polar coordinates.\n\n    Arguments:\n    z -- complex number\n    \"\"\"\n    # Convert to polar coordinates\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test the above function.\n    \"\"\"\n    # Test 1\n    print(complex_to_polar(complex(1, 2)))\n    # Test 2\n    print(complex_to_polar(complex(3, 4)))\n    # Test 3\n    print(complex_to_polar(complex(5, 6)))\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef convert(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    z1 = complex(1, 2)\n    z2 = complex(2, 3)\n    z3 = complex(3, 4)\n    r1, theta1 = convert(z1)\n    r2, theta2 = convert(z2)\n    r3, theta3 = convert(z3)\n    print(r1, theta1)\n    print(r2, theta2)\n    print(r3, theta3)\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(complex_number):\n    \"\"\"\n    :type complex_number: float\n    :rtype: tuple\n    \"\"\"\n    radian = complex_number.imag / complex_number.real\n    degrees = 180 * radian / math.pi\n    return (degrees, radian)\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    complex_number = complex(1, 3)\n    print(complex_to_polar(complex_number))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def complex2polar(z):\n    \"\"\"\n    z: complex number\n    returns: polar coordinates\n    \"\"\"\n    return z.real, z.imag\n\ndef polar2complex(x, y):\n    \"\"\"\n    x, y: polar coordinates\n    returns: complex number\n    \"\"\"\n    return complex(x, y)\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    z = complex(2, 3)\n    print(z)\n    print(complex2polar(z))\n    print(polar2complex(2, 3))\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Converts a complex number to polar coordinates\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Main function for the module\n    \"\"\"\n    z = complex(1.0, 2.0)\n    r, theta = complex_to_polar(z)\n    print(\"The complex number z is: \", z)\n    print(\"The real part is: \", r)\n    print(\"The imaginary part is: \", theta)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef convert_to_polar(z):\n    \"\"\"\n    Convert complex number z to polar coordinates.\n\n    z must be a complex number.\n    \"\"\"\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Write a function named main that takes one complex number as an argument.\n\n    The function should convert the argument to polar coordinates.\n    \"\"\"\n    x = complex(1,2)\n    y = convert_to_polar(x)\n    print(y)\n\nif __name__ == '__main__':\n    main()",
    "import math\nimport time\n\n\ndef complex_to_polar(z):\n    \"\"\"\n    Input: a complex number.\n    Output: a tuple (r, theta) where r is the modulus and theta is the phase.\n    \"\"\"\n\n    r = math.sqrt(z.real**2 + z.imag**2)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)\n\n\ndef main():\n    \"\"\"\n    Write a function to convert a complex number to polar coordinates.\n    \"\"\"\n\n    complex_number_1 = complex(1, 2)\n    complex_number_2 = complex(3, 4)\n    complex_number_3 = complex(5, 6)\n\n    print(complex_to_polar(complex_number_1))\n    print(complex_to_polar(complex_number_2))\n    print(complex_to_polar(complex_number_3))\n\nif __name__ == '__main__':\n    start_time = time.time()\n    main()\n    end_time = time.time()\n    print(\"Runtime: {}\".format(end_time - start_time))",
    "def complex2polar(z):\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return r, theta\n\ndef polar2complex(r, theta):\n    return complex(r * math.cos(theta), r * math.sin(theta))\n\ndef main():\n    for z in [1+1j, -1+1j, 1-1j, -1-1j]:\n        print(complex2polar(z))\n        print(polar2complex(*complex2polar(z)))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    r, theta = abs(z), math.atan2(z.imag, z.real)\n    return r, theta\n\ndef main():\n    complex_list = [1, 1+2j, -1+3j, -1, -1-2j, 1+1j]\n    for complex_number in complex_list:\n        print(complex_to_polar(complex_number))\n\nif __name__ == \"__main__\":\n    main()",
    "from math import *\n\ndef complex_to_polar(z):\n    \"\"\"\n    Given a complex number z, return a tuple containing the real and\n    imaginary parts of z in polar coordinates.\n    \"\"\"\n    r = abs(z)\n    theta = arg(z)\n    return (r, theta)\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    Given a tuple containing the real and imaginary parts of a complex\n    number, return a new complex number.\n    \"\"\"\n    return r * (cos(theta), -r * sin(theta))\n\ndef main():\n    \"\"\"\n    Test complex_to_polar and polar_to_complex.\n    \"\"\"\n    test_cases = (\n        (1, 0, 1, 1),\n        (1, 2, 1, 3),\n        (1, -2, 1, -3),\n        (1, 0, -1, 1),\n        (1, 2, -1, 3),\n        (1, -2, -1, -3),\n        (-1, 0, 1, 1),\n        (-1, 2, 1, 3),\n        (-1, -2, 1, -3),\n        (-1, 0, -1, 1),\n        (-1, 2, -1, 3),\n        (-1, -2, -1, -3),\n        (1, 1, 1, 1),\n        (1, 1, -1, -1),\n        (1, -1, 1, -1),\n        (1, 1, -1, -1),\n        (-1, 1, 1, 1),\n        (-1, 1, -1, -1),\n        (-1, -1, 1, -1),\n        (-1, 1, -1, -1),\n    )\n    for (r, theta, x, y) in test_cases:\n        assert complex_to_polar(polar_to_complex(r, theta)) == (x, y)\n\nif __name__ == '__main__':\n    main()",
    "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    returns: a tuple with (r, theta) where r is the real part\n    of z and theta is the argument of z.\n    \"\"\"\n    r = z.real\n    theta = z.imag\n    if theta == 0:\n        return r, 0\n    else:\n        return r, math.atan(theta/r)\n\ndef polar_to_complex(r, theta):\n    \"\"\"\n    r: real part\n    theta: argument of z\n    returns: a complex number\n    \"\"\"\n    if theta == 0:\n        return r, 0\n    else:\n        return r * math.cos(theta), r * math.sin(theta)\n\ndef main():\n    \"\"\"\n    Write a main function to test the conversion.\n    \"\"\"\n    test_list = [\n        (1 + 2j),\n        (0 + 0j),\n        (0 + 1j),\n        (1 + 0j),\n        (0 + -1j),\n        (1 - 0j),\n        (0 + 1j),\n        (1 + 1j),\n        (0 + 0j),\n        (1 + 1j),\n        (0 + 0j),\n        (1 + 0j),\n        (0 + -1j),\n        (1 - 0j),\n        (0 + -1j),\n        (1 - 1j),\n        (0 + -1j),\n        (1 - 0j),\n        (0 + 0j),\n        (1 - 0j),\n        (0 + 1j),\n        (1 - 0j),\n        (0 + 0j),\n        (1 - 0j),\n        (0 + 1j),\n        (1 - 1j),\n        (0 + 0j),\n        (1 - 1j),\n        (0 + 0j),\n        (1 - 0j),\n        (0 + 1j),\n        (1 - 1j),\n        (0 + 1j),\n        (1 - 0j),\n        (0 + 0j),\n        (1 - 0j),\n        (",
    "# This is a simple example of how to use the function\n# using the complex number class\nimport complex\n\n\ndef to_polar(z):\n    r = abs(z)\n    theta = arg(z)\n    return r, theta\n\n\nprint(to_polar(complex(2, -1)))\nprint(to_polar(complex(1, 1)))\nprint(to_polar(complex(1, 0)))\nprint(to_polar(complex(0, 1)))\nprint(to_polar(complex(0, 0)))",
    "def complex_to_polar(z):\n    \"\"\"\n    z: complex number\n    \"\"\"\n    rad = z.real * math.pi / 180.0\n    r = z.imag * math.cos(rad)\n    theta = z.imag * math.sin(rad)\n    return r, theta\n\ndef main():\n    \"\"\"\n    Test function. Call this file directly\n    \"\"\"\n    z = complex(3.0, 4.0)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\nif __name__ == '__main__':\n    main()",
    "# Write the function\ndef polar_to_cartesian(z):\n    \"\"\"\n    Input: z = complex number\n    Output: x = real part, y = imaginary part\n    \"\"\"\n    return complex(z.real, z.imag)\n\n# Test the function\npolar_to_cartesian(2.0 + 1.0j)",
    "def polar(z):\n    r = z.real\n    theta = z.imag\n    if theta < 0:\n        theta += 2 * math.pi\n    if r > 0:\n        return r, theta\n    else:\n        return r * math.cos(theta), r * math.sin(theta)\n\ndef main():\n    for i in range(10):\n        print(polar((i, i)))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    Input:\n        z: complex number\n\n    Output:\n        x: real part of z\n        y: imaginary part of z\n    \"\"\"\n    x = z.real\n    y = z.imag\n    return x, y\n\nif __name__ == \"__main__\":\n    test_cases = [[2+1j, 0+0j], [2+1j, 1+1j], [2+1j, 0+1j], [2+1j, -1+1j], [2+1j, 1+2j]]\n\n    for t in test_cases:\n        print(\"x:\", t[0], \"y:\", t[1])\n        print(complex_to_polar(t[0]))",
    "def complex_to_polar(z):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    z - Complex number to convert.\n    \"\"\"\n    return (z.real, z.imag)\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    z = complex(1, 1)\n    print(complex_to_polar(z))\n\nif __name__ == '__main__':\n    main()",
    "def complex_to_polar(z):\n    \"\"\"\n    z is a complex number\n    Returns (r, theta) where r is the real part and theta is the\n    imaginary part of z.\n    \"\"\"\n    r = abs(z)\n    theta = angle(z)\n    return (r, theta)\n\ndef angle(z):\n    \"\"\"\n    Returns the angle in radians of z.\n    \"\"\"\n    return z.imag/abs(z)\n\ndef main():\n    \"\"\"\n    Write a program that takes a complex number z as input and outputs\n    the real and imaginary parts of z in polar coordinates.\n    \"\"\"\n    z = complex(1.0, 2.0)\n    r, theta = complex_to_polar(z)\n    print r, theta\n\nif __name__ == \"__main__\":\n    main()",
    "def complex_to_polar(z):\n    r = z.real\n    theta = z.imag\n    return r, theta\n\ndef test_complex_to_polar():\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    assert r == 3\n    assert theta == 4\n\ndef test_complex_to_polar_2():\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    assert r == 3\n    assert theta == 4\n\ndef test_complex_to_polar_3():\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    assert r == 3\n    assert theta == 4\n\ndef test_complex_to_polar_4():\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    assert r == 3\n    assert theta == 4\n\ndef test_complex_to_polar_5():\n    z = complex(3, 4)\n    r, theta = complex_to_polar(z)\n    assert r == 3\n    assert theta == 4",
    "def complex_to_polar(z):\n    \"\"\"\n    Returns the real and imaginary parts of a complex number in polar\n    coordinates.\n    \"\"\"\n\n    # Convert to polar coordinates\n    r, theta = z\n    \n    # Return polar coordinates\n    return r, theta * np.pi / 180.0\n\ndef main():\n    \"\"\"\n    Write a main function that takes in a complex number and returns a tuple\n    with the real and imaginary parts in polar coordinates.\n    \"\"\"\n\n    z = 3.5 + 2.1j\n    r, theta = complex_to_polar(z)\n    print(r, theta)\n\nif __name__ == '__main__':\n    main()",
    "def to_polar(z):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n    z = complex number\n    \"\"\"\n\n    # Calculate the modulus, r\n    r = abs(z)\n    \n    # Calculate the angle, theta\n    theta = math.atan2(z.imag, z.real)\n\n    # Return the polar coordinates as a tuple\n    return (r, theta)\n\n# Call the above function with a complex number\nprint(to_polar(1+2j))\nprint(to_polar(3+4j))",
    "def complex_to_polar(z):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n\n    z = complex number\n    \"\"\"\n\n    # Convert complex number to polar coordinates\n    r = z.real\n    theta = z.imag\n\n    # Normalize complex number\n    r = r / abs(z)\n\n    # Return polar coordinates\n    return r, theta\n\n\n# Test function\ndef test():\n    \"\"\"\n    Test function\n    \"\"\"\n\n    # Test 1\n    assert complex_to_polar(1) == (1.0, 0.0)\n\n    # Test 2\n    assert complex_to_polar(1j) == (1.0, 0.0)\n\n    # Test 3\n    assert complex_to_polar(2j) == (2.0, 0.0)\n\n    # Test 4\n    assert complex_to_polar(3j) == (3.0, 0.0)\n\n    # Test 5\n    assert complex_to_polar(4j) == (4.0, 0.0)\n\n    # Test 6\n    assert complex_to_polar(5j) == (5.0, 0.0)\n\n    # Test 7\n    assert complex_to_polar(6j) == (6.0, 0.0)\n\n    # Test 8\n    assert complex_to_polar(7j) == (7.0, 0.0)\n\n    # Test 9\n    assert complex_to_polar(8j) == (8.0, 0.0)\n\n    # Test 10\n    assert complex_to_polar(9j) == (9.0, 0.0)\n\n    # Test 11\n    assert complex_to_polar(10j) == (10.0, 0.0)\n\n    # Test 12\n    assert complex_to_polar(11j) == (11.0, 0.0)\n\n    # Test 13\n    assert complex_to_polar(12j) == (12.0, 0.0)\n\n    # Test 14\n    assert complex_to_polar(13j) == (13.0, 0.0)\n\n    # Test 15\n    assert complex_to_polar"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}