{
  "problem": {
    "task_id": "HumanEval/115",
    "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n",
    "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
    "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
    "entry_point": "max_fill",
    "docstring": "",
    "problem_id": 115
  },
  "model_name": "codegen-2b",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "n = len(grid)\n    m = len(grid[0])\n    ret = 0\n    for i in xrange(m):\n        for j in xrange(n):\n            if grid[i][j] == 1:\n                ret += min(1, capacity - grid[i][j])\n    return ret\n\ndef max_fill_2(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    ret = 0\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                ret += min(1, capacity - grid[i][j])\n    return ret\n\nif __name__ == \"__main__\":\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print max_fill(grid, bucket_capacity)\n    grid = [[0,0",
    "m, n = len(grid), len(grid[0])\n    bucket_capacity = capacity\n    max_lower = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                lower = 0\n                for k in range(i+1, m):\n                    if grid[k][j] == 1:\n                        lower += 1\n                for k in range(j+1, n):\n                    if grid[i][k] == 1:\n                        lower += 1\n                max_lower = max(max_lower, lower)\n    return max_lower\n\nif __name__ == '__main__':\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n    bucket_capacity = 2\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0,0,0], [0,0,0]]\n    bucket_capacity = 5\n    print(max_fill(grid, bucket_capacity))",
    "def max_fill_helper(grid, capacity, row, col):\n        row_index = row\n        col_index = col\n        if grid[row_index][col_index] == 0:\n            return 0\n        if row_index < 0 or row_index >= grid.length or \\\n           col_index < 0 or col_index >= grid[row_index].length:\n            return 0\n        if grid[row_index][col_index] == 1:\n            return 0\n        max_row_index = row_index\n        max_col_index = col_index\n        if grid[row_index][col_index] == 0:\n            max_row_index = row_index + 1\n            max_col_index = col_index\n        elif grid[row_index][col_index] == 1:\n            max_row_index = row_index\n            max_col_index = col_index + 1\n        max_row_index += row_index\n        max_col_index += col_index\n        #print(row_index, col_index)\n        #print(max_row_index, max_col_index)\n        #print(grid[max_row_index][max_col_index])\n        return max_fill_helper(grid, capacity, max_row_index, max_col_index) + \\\n               max_fill_helper(grid, capacity, row_index, col_index)\n    return max_fill_helper(grid, capacity, 0, 0)\n\nif __name__ == \"__main__\":\n    grid = [[0,0,0,1,1,1,0,0], [0,0,1,0,0,1,0,0], [0,1,0,0,0,1,0,0], [1,0,0,0,0,0,0,0],\n            [1,0,0,1,0,0,1,0], [1,0,1,0,0,1,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]]\n    capacity =",
    "assert 1 <= len(grid) <= 10**2\n    assert 1 <= len(grid[0]) <= 10**2\n    assert all(grid[i][j] == 0 or grid[i][j] == 1 for i in range(len(grid)))\n    assert 1 <= capacity <= 10\n\n    def max_fill_helper(grid, bucket_capacity):\n        n = len(grid)\n        m = len(grid[0])\n        bucket_capacity = int(bucket_capacity)\n        ans = 0\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    ans += 1\n                    grid[i][j] = 0\n                    grid[i][j+1] = bucket_capacity\n                    grid[i+1][j] = bucket_capacity\n                    grid[i+1][j+1] = bucket_capacity\n        return ans\n\n    return max_fill_helper(grid, capacity)\n\nif __name__ == '__main__':\n    grid = [[0,0,0,1], [0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n    print(max_fill(grid, bucket_capacity))\n    print(max_fill(grid, bucket_capacity))\n    print(max_fill(grid, bucket_capacity))\n    print(max_fill(grid, bucket_capacity))",
    "n = len(grid)\n    m = len(grid[0])\n    \n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                grid[i][j] = 0\n\n    def fill_bucket(grid, capacity, bucket_idx):\n        def can_extract(x, y):\n            return x > 0 and y > 0 and grid[x-1][y-1] == 0 and grid[x][y] == 1\n        \n        def can_extract_row(x, y):\n            return x > 0 and grid[x-1][y] == 0 and grid[x][y] == 1\n        \n        def can_extract_column(x, y):\n            return y > 0 and grid[x][y-1] == 0 and grid[x][y] == 1\n        \n        def can_extract_diag(x, y):\n            return x > 0 and y > 0 and grid[x-1][y-1] == 0 and grid[x][y] == 1\n        \n        for x in xrange(n):\n            for y in xrange(m):\n                if can_extract(x, y):\n                    grid[x][y] = 0\n                    if bucket_idx == 0:\n                        return fill_bucket(grid, capacity - 1, 1)\n                    elif bucket_idx == 1:\n                        return fill_bucket(grid, capacity - 2, 0)\n                    elif bucket_idx == 2:\n                        return fill_bucket(grid, capacity - 3, 3)\n                    elif bucket_idx == 3:\n                        return fill_bucket(grid, capacity - 4, 4)\n                    else:\n                        return fill_bucket(grid, capacity - 5, 5)\n                elif can_extract_row(x, y):\n                    grid[x][y] = 0\n                    if bucket_idx == 0:\n                        return fill_bucket(grid, capacity - 1, 1)\n                    elif bucket_idx == 1:\n                        return fill_bucket(grid, capacity - 2, 0)\n                    elif bucket_idx",
    "if len(grid) == 0:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n        grid[i][0] = 0\n        grid[i][n-1] = 0\n\n    for j in range(1, n-1):\n        grid[0][j] = 0\n        grid[m-1][j] = 0\n\n    bucket_capacity = int(math.ceil(capacity/len(grid[0])))\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res += max_fill(grid[i][j:j+2], bucket_capacity)\n                grid[i][j] = 0\n    return res\n\nif __name__ == '__main__':\n    import sys\n    filename = sys.argv[1]\n    with open(filename, 'r') as f:\n        grid = [[int(x) for x in line.strip().split()] for line in f]\n    print(max_fill(grid, 3))",
    "def max_fill(grid, capacity):\n        if not grid:\n            return 0\n        row, col = grid[0][0], 0\n        res = 0\n        for i in range(1, len(grid)):\n            if grid[i][0] == 0:\n                row += 1\n                col = 0\n                continue\n            while grid[row][col] == 0 and col < len(grid[i]):\n                grid[row][col] = 1\n                col += 1\n            if grid[row][col] == 0:\n                res += 1\n            row += 1\n        return res\n\n    return max_fill(grid, capacity)\n\ndef max_fill_2(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    def max_fill(grid, capacity):\n        if not grid:\n            return 0\n        row, col = 0, 0\n        res = 0\n        for i in range(1, len(grid)):\n            if grid[i][0] == 0:\n                row += 1\n                col = 0",
    "if not grid or not bucket_capacity:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n\n    # find the maximum amount of water that can be extracted from a well\n    max_extract = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                if grid[i][j] == 1:\n                    max_extract = max(max_extract, capacity - grid[i][j])\n\n    # find the maximum amount of water that can be extracted from a bucket\n    max_extract = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                if grid[i][j] == 1:\n                    max_extract = max(max_extract, bucket_capacity - grid[i][j])\n\n    # find the maximum amount of water that can be extracted from a bucket\n    max_extract = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                if grid[i][j] == 1:\n                    max_extract = max(max_extract, bucket_capacity - grid[i][j])\n\n    return int(math.ceil(max_extract / max_extract))",
    "n = len(grid)\n    m = len(grid[0])\n    capacity = int(capacity)\n\n    # for each row, find the maximum value\n    max_value = 0\n    for row in range(n):\n        max_value = max(max_value, max(grid[row]))\n\n    # find the max value in each column\n    max_column = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            max_column[i][j] = max(max_column[i][j], max(grid[i][j], grid[i][j+1]))\n\n    # find the max value in each column\n    max_column = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            max_column[i][j] = max(max_column[i][j], max_column[i][j+1])\n\n    # find the max value in each row\n    max_row = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            max_row[i][j] = max(max_row[i][j], max_column[i][j])\n\n    # find the max value in each row\n    max_row = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            max_row[i][j] = max(max_row[i][j], max_column[i][j])\n\n    # find the max value in each column\n    max_column = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            max_column[i][j] = max(max_column[i][j], max_row[i][j])\n\n    # find the max value in each row\n    max_column = [[0 for _ in range(m)] for _ in range(n)]\n    for",
    "if grid == None or len(grid) == 0:\n        return 0\n    grid_len = len(grid)\n    grid_len = grid_len if grid_len <= 10 else 10\n    grid_len = grid_len if grid_len >= 1 else 1\n    grid_len = grid_len if grid_len <= 10 else 10\n    if grid[0][0] == 0:\n        return 0\n    for i in range(grid_len):\n        for j in range(grid_len):\n            if grid[i][j] == 1:\n                return 0\n    grid = [[0 for _ in range(grid_len)] for _ in range(grid_len)]\n    for i in range(grid_len):\n        grid[i][i] = 1\n    capacity = 1\n    for i in range(grid_len):\n        for j in range(grid_len):\n            if grid[i][j] == 0:\n                grid[i][j] = capacity\n                if capacity == 1:\n                    return 0\n                capacity = capacity + 1\n    return int(math.ceil(math.log(capacity, 2)))\n\nif __name__ == '__main__':\n    print(max_fill([[0,0,0,0,0,0],\n                    [0,0,1,0,0,0],\n                    [0,0,0,0,0,0],\n                    [0,0,1,1,0,0],\n                    [0,0,0,1,1,0],\n                    [0,0,0,0,0,0]], 5))",
    "N = len(grid)\n    M = len(grid[0])\n    for i in range(N):\n        grid[i][1:] = [x + 1 for x in grid[i][1:]]\n    def solve(grid, bucket_capacity):\n        if not grid: return 0\n        N = len(grid)\n        M = len(grid[0])\n        bucket_capacity = int(bucket_capacity)\n        if bucket_capacity <= 0: return 0\n        if bucket_capacity >= M: return 1\n        # print grid\n        # print bucket_capacity\n        bucket_map = [[0] * (M - bucket_capacity) for _ in range(N)]\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 1:\n                    for k in range(1, bucket_capacity):\n                        bucket_map[i][j + k - 1] = 1\n        # print bucket_map\n        # print bucket_map.count(1)\n        # print bucket_map.count(0)\n        for i in range(N):\n            for j in range(M):\n                if bucket_map[i][j] == 1:\n                    if grid[i][j] == 1:\n                        return 0\n        return 1 + solve(grid[:], bucket_capacity - 1)\n    return solve(grid, capacity)\n\n# Test cases\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\nbucket_capacity = 1\nprint(max_fill(grid, bucket_capacity))\ngrid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\nbucket_capacity = 2\nprint(max_fill(grid, bucket_capacity))\ngrid = [[0,0,0], [0,0,0]]\nbucket_capacity = 5\nprint(max_fill(grid, bucket_capacity))",
    "m, n = len(grid), len(grid[0])\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)\n    # O(m*n)",
    "def max_water(grid, capacity):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def max_water(grid, capacity, i, j):\n            if capacity == 0:\n                return 0\n            if grid[i][j] == 0:\n                return 0\n            if grid[i][j] == 1:\n                return 1\n            return max(max_water(grid, capacity - 1, i, j - 1),\n                       max_water(grid, capacity - 1, i - 1, j),\n                       max_water(grid, capacity - 1, i, j + 1),\n                       max_water(grid, capacity - 1, i + 1, j))\n        return max_water(grid, capacity, 0, 0)\n    return max_water(grid, capacity)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    for testcase in sys.stdin:\n        grid, capacity = [int(x) for x in testcase.split(\"\\n\")]\n        print(max_fill(grid, capacity))",
    "if capacity == 0:\n        return 0\n    grid = np.array(grid)\n    n = len(grid)\n    m = len(grid[0])\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                res += fill_well(grid, i, j, capacity)\n    return res\n\n\ndef fill_well(grid, i, j, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    if capacity == 0:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    i_start = i - 1\n    i_end = i + 2\n    j_start = j - 1\n    j_end = j + 2\n    res = 0\n    for i in range(i_start, i_end):\n        for j in range(j_start, j_end):\n            if grid[i][j] == 0:\n                res += min(capacity, 1)",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                break\n        else:\n            return 0\n\n        if capacity == 1:\n            continue\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    continue\n\n                if i+1 < n and grid[i+1][j] == 1 and grid[i+1][j] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if j+1 < m and grid[i][j+1] == 1 and grid[i][j+1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if i-1 >= 0 and grid[i-1][j] == 1 and grid[i-1][j] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if j-1 >= 0 and grid[i][j-1] == 1 and grid[i][j-1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if i+1 < n and j+1 < m and grid[i+1][j+1] == 1 and grid[i+1][j+1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if i-1 >= 0 and j+1 < m and grid[i-1][j+1] == 1 and grid[i-1][j+1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if i+1 < n and j-1 >= 0 and grid[i+1][j-1] == 1 and grid[i+1][j-1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n                if i-1 >= 0 and j-1 >= 0 and grid[i-1][j-1] == 1 and grid[i-1][j-1] == 1:\n                    grid[i][j] = 1\n                    continue\n\n    return math.ceil(len(grid)/capacity)",
    "def max_fill_helper(grid, capacity, cur_row, cur_col, row_size, col_size):\n        if cur_col == col_size and cur_row == row_size:\n            return 0\n        elif cur_col == col_size:\n            return max_fill_helper(grid, capacity, cur_row + 1, 0, row_size, col_size)\n        elif cur_row == row_size:\n            return max_fill_helper(grid, capacity, cur_row, 0, col_size, row_size)\n        else:\n            return max_fill_helper(grid, capacity, cur_row, cur_col + 1, row_size, col_size) + 1\n\n    return max_fill_helper(grid, capacity, 0, 0, grid.length, grid[0].length)\n\nif __name__ == '__main__':\n    grid = [[0, 0, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))",
    "rows = grid.length\n    cols = grid[0].length\n    bucket_capacity = capacity\n    \n    grid = [[0 for j in xrange(cols)] for i in xrange(rows)]\n    \n    for i in xrange(rows):\n        for j in xrange(cols):\n            grid[i][j] = grid[i][j] or 1\n    \n    def max_fill_recur(row, col):\n        \"\"\"\n        recursive function\n        \"\"\"\n        if row == rows or col == cols:\n            return 0\n        \n        if grid[row][col] == 0:\n            grid[row][col] = max_fill_recur(row + 1, col) + 1\n            grid[row][col] = max_fill_recur(row, col + 1) + grid[row][col]\n        else:\n            grid[row][col] = max_fill_recur(row + 1, col)\n        return grid[row][col]\n    \n    return max_fill_recur(0, 0)",
    "grid = [[int(i) for i in row] for row in grid]\n\n    if len(grid) == 1:\n        return 0\n    elif len(grid) == 2:\n        return 1 if grid[0][0] == grid[1][1] else 0\n\n    max_count = 0\n    for row in grid:\n        if len(row)!= 2:\n            return 0\n        for i in range(2):\n            if row[i] == 1:\n                max_count += 1\n            else:\n                max_count += math.ceil(max(grid[i]) / capacity)\n    return max_count\n\nif __name__ == '__main__':\n    print(max_fill([[0, 1, 1], [1, 1, 1], [1, 0, 0]], 2))\n    print(max_fill([[0, 0, 0], [1, 1, 1], [0, 0, 0]], 5))\n    print(max_fill([[0, 1, 1], [1, 1, 1], [1, 0, 0]], 1))",
    "if not grid or not capacity:\n        return 0\n    grid = [[int(x) for x in row] for row in grid]\n    max_fill_count = 0\n    for row in grid:\n        capacity_left = capacity\n        for i in range(len(row)):\n            if row[i] == 1:\n                capacity_left -= 1\n                if capacity_left <= 0:\n                    return max_fill_count + 1\n                max_fill_count += 1\n    return max_fill_count",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                if capacity == 1:\n                    return 1\n                else:\n                    return max_fill(grid, capacity - 1) + 1\n    return 0",
    "def solve(grid, capacity):\n        def max_water(row):\n            res = 0\n            for col in range(row[0]+1, row[1]+1):\n                if grid[row][col]:\n                    res += 1\n            return res\n\n        def max_water_bucket(row):\n            res = 0\n            for col in range(row[0]+1, row[1]+1):\n                if grid[row][col]:\n                    res += 1\n                if grid[row][col] and max_water(row) == max_water(row-1):\n                    res += 1\n            return res\n\n        def max_water_bucket_bucket(row):\n            res = 0\n            for col in range(row[0]+1, row[1]+1):\n                if grid[row][col]:\n                    res += 1\n                if grid[row][col] and max_water(row) == max_water(row-1) and max_water_bucket(row-1) == max_water_bucket(row-2):\n                    res += 1\n            return res\n\n        return max(max_water_bucket_bucket(len(grid)-1) for row in grid)\n\n    return solve(grid, capacity)\n\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    capacity = 1\n    print(\"%s -> %s\" % (max_fill(grid, capacity), max_fill_recursive(grid, capacity)))\n    capacity = 2\n    print(\"%s -> %s\" % (max_fill(grid, capacity), max_fill_recursive(grid, capacity)))\n    capacity = 5\n    print(\"%s -> %s\" % (max_fill(grid, capacity), max_fill_recursive(grid, capacity)))\n    capacity = 10\n    print(\"%s -> %s\" % (max_fill(grid, capacity), max_fill_recursive(grid, capacity)))",
    "# print('grid:', grid)\n    # print('capacity:', capacity)\n    # print('grid.length:', grid.length)\n    # print('grid[:,1].length:', grid[:,1].length)\n    \n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,1,0], [0,0,0,0]]\n    # grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1], [0,1,1,1]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    # grid = [[",
    "return math.ceil(sum(grid) / capacity)\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\n#\n# DFS + BFS\nclass Solution2:\n    def maxFill(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        grid = sorted(grid, key=lambda x: x[0])\n        n = len(grid)\n        m = len(grid[0])\n        # dp[i][j] -> max number of buckets to empty from the well at (i, j)\n        dp = [[0 for j in range(m)] for i in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dp[i][j] = 1\n                elif grid[i][j] == 1:\n                    dp[i][j] = 0\n                elif grid[i][j] == 2:\n                    dp[i][j] = max(dp[i][j - 1], dp[i][j - 1] + 1)\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j] + 1)\n        return max(dp)\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\n#\n# DFS + BFS\nclass Solution3:\n    def maxFill(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        # dp[i][j] -> max number of buckets to empty from the well at (i, j)\n        dp = [[0 for j in range(m)] for i in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dp[i][j] = 1",
    "return sum(1 for _ in range(capacity))",
    "# find the max number of buckets we can empty\n    max_buckets = int(math.ceil(math.sqrt(grid.shape[0] * grid.shape[1])))\n    # check if we can empty all the buckets\n    if grid.sum() == 0:\n        return 0\n    # check if we can empty all the buckets\n    if grid.sum() == capacity:\n        return max_buckets\n    # find the max number of buckets we can empty\n    max_buckets = int(math.ceil(math.sqrt(grid.shape[0] * grid.shape[1])))\n    # check if we can empty all the buckets\n    if grid.sum() == 0:\n        return 0\n    # check if we can empty all the buckets\n    if grid.sum() == capacity:\n        return max_buckets\n    return max_buckets\n\n\nif __name__ == '__main__':\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    bucket_capacity = 2\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    bucket_capacity = 2\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    bucket_capacity = 5\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    bucket_capacity = 5\n    print(max_fill(grid, bucket_capacity))",
    "n = len(grid)\n    m = len(grid[0])\n\n    # build a binary matrix\n    grid = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                grid[i][j] = 1\n    # find the number of times that we can lower the bucket\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                # print(\"grid[%d][%d] = %d\" % (i, j, grid[i][j]))\n                for k in range(j + 1, m):\n                    if grid[i][k] and grid[i][j] == grid[i][k]:\n                        # print(\"grid[%d][%d] = %d\" % (i, k, grid[i][k]))\n                        count += int(math.floor(grid[i][k] / grid[i][j]))\n    return count\n\nif __name__ == \"__main__\":\n    print(max_fill([[0, 0, 0, 1], [0, 0, 0, 0], [1, 1, 1, 1], [1, 1, 1, 1]], 1))",
    "n = len(grid)\n    m = len(grid[0])\n    nums = [0]*n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                nums[i] = max(nums[i], 1 + nums[i-1])\n    return max(nums)",
    "n = len(grid)\n    if n == 0:\n        return 0\n    m = len(grid[0])\n    if m == 0:\n        return 0\n    \n    # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dp[0][0] = 0\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n    \n    # max_fill(grid, capacity) = dp[n-1][m-1]\n    return dp[n-1][m-1]",
    "if capacity <= 0:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    row_bucket_capacity = [[0] * cols for _ in range(rows)]\n    col_bucket_capacity = [[0] * cols for _ in range(cols)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                row_bucket_capacity[i][j] = capacity\n            else:\n                col_bucket_capacity[j][i] = capacity\n\n    # iterate over rows\n    for i in range(rows):\n        # iterate over cols\n        for j in range(cols):\n            # iterate over buckets\n            for k in range(row_bucket_capacity[i][j]):\n                if i + 1 < rows:\n                    if row_bucket_capacity[i + 1][j] > row_bucket_capacity[i][j] and col_bucket_capacity[j][i + 1] > col_bucket_capacity[j][i]:\n                        row_bucket_capacity[i][j] = row_bucket_capacity[i + 1][j]\n                        col_bucket_capacity[j][i] = col_bucket_capacity[j][i + 1]\n                    elif row_bucket_capacity[i][j] > row_bucket_capacity[i + 1][j] and col_bucket_capacity[j][i] > col_bucket_capacity[j][i + 1]:\n                        row_bucket_capacity[i][j] = row_bucket_capacity[i][j]\n                        col_bucket_capacity[j][i] = col_bucket_capacity[j][i]\n                    elif row_bucket_capacity[i + 1][j] > row_bucket_capacity[i][j] and col_bucket_capacity[j][i] > col_bucket_capacity[j][i + 1]:\n                        row_bucket_capacity[i][j] = row_bucket_capacity[i + 1][j]\n                        col_bucket_capacity[j][",
    "n = len(grid)\n    m = len(grid[0])\n    \n    def is_full(i, j):\n        return grid[i][j] == 1\n    \n    def is_empty(i, j):\n        return grid[i][j] == 0\n    \n    def is_empty_row(i):\n        return grid[i][1:] == [0] * (m - 1)\n    \n    def is_full_row(i):\n        return grid[i][1:] == [1] * (m - 1)\n    \n    def is_full_col(j):\n        return grid[1][j] == 1\n    \n    def is_empty_col(j):\n        return grid[1][j] == 0\n    \n    def is_full_diag(i, j):\n        return grid[i][j] == 1\n    \n    def is_empty_diag(i, j):\n        return grid[i][j] == 0\n    \n    def is_full_down(i):\n        return grid[i][m] == 1\n    \n    def is_empty_down(i):\n        return grid[i][m] == 0\n    \n    def is_full_right(j):\n        return grid[m][j] == 1\n    \n    def is_empty_right(j):\n        return grid[m][j] == 0\n    \n    def is_full_left(j):\n        return grid[1][j] == 1\n    \n    def is_empty_left(j):\n        return grid[1][j] == 0\n    \n    def is_full_up(i):\n        return grid[i][1] == 1\n    \n    def is_empty_up(i):\n        return grid[i][1] == 0\n    \n    def is_full_diag_up(i, j):\n        return grid[i][j] == 1\n    \n    def is_empty_diag_up(i, j):\n        return grid[i][j] == 0\n    \n    def is_full_diag_left(i, j):\n        return grid[i][j] == 1",
    "n = len(grid)\n    m = len(grid[0])\n    if n == 0 or m == 0:\n        return 0\n    \n    bucket_capacity = min(capacity, n*m)\n    \n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                bucket_capacity -= min(grid[i][j], bucket_capacity)\n    \n    return bucket_capacity\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# DP\n#\n# DP solution:\n#\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution(object):\n    def maxFill(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        m = len(grid[0])\n        if n == 0 or m == 0:\n            return 0\n        \n        bucket_capacity = min(grid[0][0], n*m)\n        \n        for i in xrange(n):\n            for j in xrange(m):\n                if grid[i][j] == 1:\n                    bucket_capacity -= min(grid[i][j], bucket_capacity)\n        \n        return bucket_capacity",
    "if not grid:\n        return 0\n\n    # get the max number of buckets\n    max_bucket_num = max([len(row) for row in grid])\n\n    # get the max number of wells\n    max_well_num = max([len(row) for row in grid[0]])\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(max_well_num, max_bucket_num)\n\n    # max number of buckets\n    max_bucket_num = min(max_bucket_num, capacity)\n\n    # max number of wells\n    max_well_num = min(",
    "#print(grid, bucket_capacity)\n    #grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    #bucket_capacity = 1\n    #grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    #bucket_capacity = 2\n    #grid = [[0,0,0], [0,0,0]]\n    #bucket_capacity = 5\n    #grid = [[0,0,0], [0,0,0]]\n    grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    bucket_capacity = 5\n    #print(grid, bucket_capacity)\n    #print(max_fill(grid, bucket_capacity))\n    result = 0\n    #print(max_fill(grid, bucket_capacity))\n    #print(max_fill_2(grid, bucket_capacity))\n    #print(max_fill_3(grid, bucket_capacity))\n    return result\n\ndef max_fill_2(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:",
    "# grid[0][0] is the first well\n    # grid[i][j] is the bucket of well i\n    # capacity is the capacity of bucket j\n    # max_fill is the max_fill of all buckets\n    max_fill = 0\n    for i in range(1, len(grid)):\n        for j in range(1, len(grid[i])):\n            if grid[i][j] == 1:\n                max_fill = max(max_fill, math.ceil(capacity / (grid[i][j] + 1)))\n    return max_fill",
    "n = len(grid)\n    m = len(grid[0])\n    \n    if n == 1:\n        return 0\n\n    if m == 1:\n        return 1\n\n    for i in range(1,n):\n        for j in range(1,m):\n            if grid[i][j] == 1:\n                if max_fill(grid[:i+1,:], capacity - 1) <= 0:\n                    return max_fill(grid[i+1:n,:], capacity)\n    return 0\n\n\nif __name__ == '__main__':\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n\n    grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n    bucket_capacity = 2\n    print(max_fill(grid, bucket_capacity))\n\n    grid = [[0,0,0], [0,0,0]]\n    bucket_capacity = 5\n    print(max_fill(grid, bucket_capacity))",
    "# first row is the empty bucket, so the maximum number of buckets to empty\n    # is the number of rows - 1\n    return (grid.length - 1) * (grid[0].length - 1)\n\n\nif __name__ == '__main__':\n    print(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]))\n    print(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]))\n    print(max_fill([[0, 0, 0], [0, 0, 0]]))",
    "return math.ceil(max(map(lambda x: sum(map(lambda y: max(0, x[y]) if x[y] else 0, grid[i]) for i in range(len(grid)))), [len(grid[0])]) / capacity)",
    "n = len(grid)\n    m = len(grid[0])\n    max_water = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                max_water += capacity\n    return math.ceil(max_water / capacity)",
    "return max_fill_helper(grid, capacity)\n\n\ndef max_fill_helper(grid, capacity):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type capacity: int\n    :rtype: int\n    \"\"\"\n    # print('grid:', grid)\n    # print('capacity:', capacity)\n    # print('grid[0]', grid[0])\n    # print('grid[0][0]', grid[0][0])\n    if grid is None or grid[0] is None or grid[0][0] is None:\n        return 0\n    grid_length = len(grid)\n    if grid_length == 0:\n        return 0\n\n    grid_length = len(grid[0])\n\n    if capacity > grid_length:\n        return 0\n\n    if capacity == 0:\n        return 1\n\n    # print('grid_length:', grid_length)\n    # print('grid[0][0]:', grid[0][0])\n    # print('capacity:', capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    # print('grid_length - capacity:', grid_length - capacity)\n    #",
    "if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    # init\n    bucket_capacity = capacity\n    # init\n    bucket = [0] * bucket_capacity\n    # init\n    visited = [[0] * n for i in range(m)]\n    visited[0][0] = 1\n\n    def dfs(i, j):\n        \"\"\"\n        dfs: dfs recursion\n        :param i:\n        :param j:\n        :return:\n        \"\"\"\n        if i < 0 or j < 0 or i >= m or j >= n:\n            return 0\n\n        if visited[i][j] == 1:\n            return 0\n\n        visited[i][j] = 1\n        bucket[0] = 1\n        # print(i, j)\n        if grid[i][j] == 1:\n            return 1\n        elif grid[i][j] == 0:\n            return 0\n\n        # find the next bucket\n        for k in range(1, bucket_capacity):\n            if bucket[k - 1] == 1:\n                break\n\n        # update the next bucket\n        for k in range(1, bucket_capacity):\n            if grid[i][j] == 0:\n                bucket[k] = 1\n            else:\n                bucket[k] = 0\n\n        # recur to next level\n        return dfs(i - 1, j) + dfs(i, j - 1)\n\n    return dfs(m - 1, n - 1)\n\nif __name__ == '__main__':\n    \"\"\"\n    Sample Input:\n        [[0,0,0,0], [0,1,0,0], [1,1,1,1], [0,1,1,1]]\n        1\n        1\n    Sample Output:\n        6\n\n    Explanation:\n        We can extract water from the well (0,0) by removing 1 unit from the bucket (0).\n        Then, we can extract water from the well (0,0) by removing 1 unit from the bucket (1).\n        We can extract water from the well (",
    "N = len(grid)\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if grid[i][j] == 0 and grid[j][i] == 0:\n                continue\n            if grid[i][j] == 1 and grid[j][i] == 1:\n                capacity -= 1\n            else:\n                return 0\n    return math.ceil(math.sqrt(capacity))\n\n# Time:  O(N^2 * max_fill_time)\n# Space: O(N^2)\n# Divide and Conquer\n#\n# Time:  O(N^2)\n# Space: O(N^2)\n# Divide and Conquer\nclass Solution:\n    def maxFill(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        N = len(grid)\n        if N == 0:\n            return 0\n        if N == 1:\n            return 1\n        max_fill_time = 0\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == 0:\n                    max_fill_time = max(max_fill_time, max_fill(grid, j + 1))\n                else:\n                    return max_fill_time\n        return max_fill_time",
    "if grid is None or len(grid) == 0:\n        return 0\n    if grid[0].count(1) == 0:\n        return 0\n\n    def max_fill_helper(grid, capacity, row_num, col_num):\n        if row_num >= len(grid) or col_num >= len(grid[row_num]):\n            return 0\n        if grid[row_num][col_num] == 1:\n            if capacity == 0:\n                return 1\n            else:\n                return max_fill_helper(grid, capacity - 1, row_num, col_num + 1) + 1\n        else:\n            return max_fill_helper(grid, capacity, row_num, col_num + 1)\n\n    return max_fill_helper(grid, capacity, 0, 0)\n\n\nif __name__ == '__main__':\n    import time\n\n    start_time = time.time()\n\n    print(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    print(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    print(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 3))\n    print(max_fill([[0, 0, 0], [0, 0, 0]], 5))\n    print(max_fill([[0, 0, 0], [0, 0, 0]], 5))\n\n    print(\"--- %s seconds ---\" % (time.time() - start_time))",
    "if not grid:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n    if n == 1:\n        return 0\n\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                return max(max_fill(grid[i:n, j:m], capacity - 1), max_fill(grid[i:n, j:m][::-1], capacity - 1))\n    return 0\n\n\nif __name__ == '__main__':\n    print(max_fill([[1, 1, 1, 1], [1, 0, 0, 0], [1, 1, 0, 0], [1, 1, 1, 1]]))\n    print(max_fill([[1, 0, 0], [1, 1, 0], [1, 0, 1], [1, 1, 1]]))\n    print(max_fill([[0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 1]]))\n    print(max_fill([[0, 0, 0], [0, 0, 0], [0, 0, 0]]))",
    "n = len(grid)\n    if n == 0:\n        return 0\n\n    m = len(grid[0])\n    if m == 0:\n        return 0\n\n    max_level = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                max_level = max(max_level, 1 + max_fill(grid[i][:j], capacity))\n    return max_level\n\nif __name__ == '__main__':\n    n = int(input())\n    m = int(input())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, input().split())))\n    capacity = int(input())\n    print(max_fill(grid, capacity))",
    "n = len(grid)\n    m = len(grid[0])\n    \n    # max_water_in_bucket = []\n    max_water_in_bucket = 0\n    water_in_bucket = 0\n    water_in_well = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                water_in_well += 1\n                water_in_bucket = capacity\n            else:\n                water_in_bucket -= 1\n                \n            if water_in_bucket == 0:\n                max_water_in_bucket += 1\n            elif water_in_bucket < 0:\n                max_water_in_bucket += 1\n                \n    return max_water_in_bucket\n\nif __name__ == '__main__':\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    capacity = 1\n    print(max_fill(grid, capacity))\n    # grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n    # capacity = 2\n    # print(max_fill(grid, capacity))\n    # grid = [[0,0,0], [0,0,0]]\n    # capacity = 5\n    # print(max_fill(grid, capacity))\n    # grid = [[0,0,1], [0,0,1]]\n    # capacity = 5\n    # print(max_fill(grid, capacity))\n    # grid = [[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0]]\n    # capacity = 5\n    # print(max_fill(grid, capacity))\n    # grid = [[0,0,0,0,0], [0,0,0,0,0], [0,0,0,0,0], [0,0,0,",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                if (i > 0 and grid[i-1][j] == 0) or (j > 0 and grid[i][j-1] == 0) or (i < n-1 and grid[i+1][j] == 0) or (j < m-1 and grid[i][j+1] == 0):\n                    return math.ceil(math.log(capacity, 2))\n    return 0",
    "#print(grid)\n    #print(max_fill_helper(grid, capacity))\n    return max_fill_helper(grid, capacity)\n\ndef max_fill_helper(grid, capacity):\n    \"\"\"\n    Input: grid and bucket_capacity\n    Output: the number of times you can lower the bucket\n    \"\"\"\n    row_num = len(grid)\n    col_num = len(grid[0])\n    #print(row_num, col_num)\n    grid_new = [[0 for i in range(col_num)] for j in range(row_num)]\n    for i in range(row_num):\n        for j in range(col_num):\n            if grid[i][j] == 1:\n                grid_new[i][j] = capacity\n            else:\n                grid_new[i][j] = 0\n    #print(grid_new)\n    #print(max_fill_helper(grid_new, capacity))\n    return max_fill_helper(grid_new, capacity)\n\ndef max_fill_2(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2",
    "def _max_fill(grid, capacity):\n        # write your code here\n        return 0\n\n    return _max_fill(grid, capacity)",
    "n = len(grid)\n    m = len(grid[0])\n    \n    # first row is special\n    for i in range(n):\n        grid[i][0] = 0\n    \n    # max_fill_helper\n    def max_fill_helper(i, j):\n        if grid[i][j] == 0:\n            return 0\n        \n        if i == n - 1:\n            return 1\n        \n        if j == m - 1:\n            return 1\n        \n        if grid[i+1][j] == 0 and grid[i+1][j+1] == 0:\n            return max_fill_helper(i+1, j)\n        else:\n            return max_fill_helper(i, j+1)\n    \n    # max_fill\n    return max(max_fill_helper(0, 0), max_fill_helper(0, m-1), max_fill_helper(n-1, 0), max_fill_helper(n-1, m-1))",
    "# https://leetcode.com/problems/max-fill-up-water-tank/discuss/245901/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251317/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251316/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251315/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251314/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251313/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251312/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill-up-water-tank/discuss/251311/C%2B%2B-O(NlogN)-O(1)-O(N)\n    # O(NlogN)\n    # https://leetcode.com/problems/max-fill",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                grid[i][j] = 0\n                grid[i][j+1] = 1\n                break\n    return len(grid) * m * (grid[0][0] == 1)",
    "# n is the number of wells, m is the number of rows\n    n = len(grid)\n    m = len(grid[0])\n    if n == 0:\n        return 0\n    if m == 0:\n        return 0\n\n    # build the max_fill table\n    table = [[-1] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                table[i][j] = 0\n            elif grid[i][j] == 1:\n                table[i][j] = 1\n            else:\n                table[i][j] = -1\n\n    # use max_fill table to find the maximum number of buckets to empty\n    max_fill_table = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == -1:\n                continue\n            # find the maximum number of buckets that can be empty\n            max_fill_table[i][j] = max(table[i][j + 1:]) + 1\n\n    # the maximum number of buckets to empty is the maximum of the following two\n    # scenarios:\n    # 1. all buckets can be empty\n    # 2. all buckets can't be empty\n    # find the maximum of the two scenarios\n    max_fill_table_max = max(max_fill_table)\n    if max_fill_table_max == m:\n        return 0\n    else:\n        return max_fill_table_max\n\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    capacity = 1\n    print(max_fill(grid, capacity))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    capacity = 2\n    print(max_fill(grid, capacity))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    capacity = 5",
    "return math.ceil(sum(1 for _ in grid) / capacity)\n\nif __name__ == '__main__':\n    grid = [[0,0,0,0], [0,0,0,0], [0,1,0,0], [1,1,1,1]]\n    print(max_fill(grid, 2))",
    "return sum(1 for _ in range(len(grid)) for _ in range(len(grid[0])))\n\n\nif __name__ == \"__main__\":\n    print(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2))\n    print(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 5))\n    print(max_fill([[0,0,0], [0,0,0]]))",
    "# https://leetcode.com/problems/max-fill-water-tank/discuss/258968/C%2B%2B-Python-DP-solution-using-bucket-and-queue\n    n = len(grid)\n    m = len(grid[0])\n    capacity = int(capacity)\n    if capacity == 0: return 0\n    if n == 0 or m == 0: return 0\n    dp = [[0] * m for _ in range(n)]\n    queue = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                queue.append((i, j))\n    while queue:\n        i, j = queue.pop(0)\n        if dp[i][j] > capacity:\n            return dp[i][j]\n        elif dp[i][j] == 0:\n            dp[i][j] = 1\n            for x in range(1, m):\n                if grid[i][j] == 0 and dp[i][x] == 1:\n                    queue.append((i, x))\n        else:\n            dp[i][j] += 1\n    return dp[0][0]\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))",
    "def max_fill_helper(grid, capacity, bucket_capacity):\n        max_fill_set = set()\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    max_fill_set.add((i, j))\n                    if (i, j) in max_fill_set:\n                        max_fill_set.remove((i, j))\n        return max(max_fill_set)\n\n    return max_fill_helper(grid, capacity, bucket_capacity)\n\ndef main():\n    import timeit\n\n    start = timeit.default_timer()\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n    print(timeit.default_timer() - start)\n\n\nif __name__ == '__main__':\n    main()",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                return 0\n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = min(grid[i][j], capacity)\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == capacity:\n                ans += 1\n    return ans",
    "return sum(math.ceil(len(grid)/2) for grid in grid_to_bucket_capacity(grid))\n\n\ndef grid_to_bucket_capacity(grid):\n    \"\"\"\n    Input: \n        grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    Output:\n        [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n    \"\"\"\n    return [grid_to_bucket_capacity_row(row) for row in grid]\n\n\ndef grid_to_bucket_capacity_row(row):\n    \"\"\"\n    Input: \n        row : [1, 1, 1, 1]\n    Output:\n        [1, 1, 1, 1]\n    \"\"\"\n    return [1 if x == 0 else 0 for x in row]\n\n\nif __name__ == '__main__':\n    import timeit\n\n    start = timeit.default_timer()\n    print(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    print(timeit.default_timer() - start)",
    "if not grid or not capacity: return 0\n\n    n = len(grid)\n    m = len(grid[0])\n    \n    if n == 0 or m == 0: return 0\n\n    def get_max_fill(i, j):\n        if grid[i][j] == 0:\n            return 0\n\n        elif grid[i][j] == 1:\n            return 1\n\n        elif grid[i][j] == 2:\n            return 2\n\n        elif grid[i][j] == 3:\n            return 3\n\n        else:\n            return 4\n\n    res = 0\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 0:\n                res = max(res, get_max_fill(i, j))\n    return res\n\nif __name__ == \"__main__\":\n    import sys\n    if len(sys.argv) >= 2:\n        n = int(sys.argv[1])\n        m = int(sys.argv[2]) if len(sys.argv) == 3 else 1\n        grid = [[0] * m for i in xrange(n)]\n        bucket_capacity = 1\n        grid[0][0] = 1\n        grid[0][1] = 1\n        grid[0][2] = 1\n        grid[0][3] = 1\n        grid[0][4] = 1\n        grid[0][5] = 1\n        print max_fill(grid, bucket_capacity)",
    "n = len(grid)\n    m = len(grid[0])\n    # check if all wells have same length\n    if grid[0][1]!= grid[0][0]:\n        return 0\n    # check if all wells have same length\n    if grid[0][1]!= grid[1][1]:\n        return 0\n    # check if all wells have same length\n    if grid[n-1][1]!= grid[n-1][0]:\n        return 0\n    # check if all wells have same length\n    if grid[n-1][1]!= grid[n-2][1]:\n        return 0\n    # check if all wells have same length\n    if grid[0][1]!= grid[1][1]:\n        return 0\n    # check if all wells have same length\n    if grid[0][1]!= grid[n-1][1]:\n        return 0\n\n    def max_fill_helper(row, col, bucket_capacity, bucket_count):\n        if row == n and col == m:\n            return bucket_count\n        if row == n or col == m:\n            return 0\n        if grid[row][col] == 1:\n            return bucket_count + max_fill_helper(row + 1, col, bucket_capacity, bucket_count)\n        else:\n            return max(max_fill_helper(row + 1, col, bucket_capacity, bucket_count), max_fill_helper(row, col + 1, bucket_capacity, bucket_count))\n    return max_fill_helper(0, 0, bucket_capacity, 0)",
    "# TODO: Implement this function.\n    \n    # https://www.youtube.com/watch?v=wVhV6gOeX4I\n    def get_max_fill(grid, capacity, bucket_capacity):\n        if not grid:\n            return 0\n        rows = len(grid)\n        cols = len(grid[0])\n        # if bucket_capacity == 1, then we only need to check the first row and first col\n        if bucket_capacity == 1:\n            max_fill = 0\n            for row in range(rows):\n                for col in range(cols):\n                    if grid[row][col] == 1:\n                        max_fill += 1\n                        break\n                break\n            return max_fill\n        # else we need to check every row and col\n        else:\n            max_fill = 0\n            for row in range(rows):\n                for col in range(cols):\n                    if grid[row][col] == 1:\n                        max_fill += 1\n                        for i in range(row - 1, -1, -1):\n                            if grid[i][col] == 1:\n                                break\n                            max_fill += 1\n                        for j in range(col - 1, -1, -1):\n                            if grid[row][j] == 1:\n                                break\n                            max_fill += 1\n                        break\n                break\n            return max_fill\n    \n    return get_max_fill(grid, capacity, bucket_capacity)\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    print(max_fill(grid, 2))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    print(max_fill(grid, 5))",
    "m, n = len(grid), len(grid[0])\n    # check whether grid is valid\n    if not (m == n and 1 <= m <= 10**2 and 1 <= n <= 10**2):\n        return 0\n\n    # check whether bucket_capacity is valid\n    if not 1 <= bucket_capacity <= 10**3:\n        return 0\n\n    # check whether grid is empty\n    if m == 0 or n == 0:\n        return 0\n\n    # check whether grid is full\n    if m == n and grid[0][0] == 0:\n        return 0\n\n    # sort the grid\n    grid = sorted(grid)\n\n    # for each row\n    for i in xrange(1, m):\n        # for each column\n        for j in xrange(1, n):\n            # if the current grid is full, lower the capacity\n            if grid[i][j] == 1:\n                if grid[i-1][j-1] == 0 and grid[i-1][j] == 1:\n                    bucket_capacity = min(bucket_capacity, grid[i-1][j-1] + 1)\n                elif grid[i-1][j-1] == 1 and grid[i-1][j] == 0:\n                    bucket_capacity = min(bucket_capacity, grid[i-1][j] + 1)\n                elif grid[i-1][j-1] == 0 and grid[i-1][j] == 1:\n                    bucket_capacity = min(bucket_capacity, grid[i-1][j-1] + 1)\n                elif grid[i-1][j-1] == 1 and grid[i-1][j] == 0:\n                    bucket_capacity = min(bucket_capacity, grid[i-1][j] + 1)\n            # if the current grid is empty, lower the capacity\n            elif grid[i][j] == 0 and grid[i-1][j-1] == 1 and grid[i-1][j] == 1:\n                bucket_capacity = min(bucket_capacity, grid[i][j-1] + 1)\n            elif grid[i][j] == 0 and grid[i",
    "# Solution 1:\n    #  - we can't do the max fill as well, since we can't tell which bucket will be full\n    #  - we can't just do the max fill as well, since we can't get the max value of all \n    #    buckets\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we can't know which bucket to empty\n    #  - we can't do the max fill as well, since we",
    "# https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-Short-Java-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-Java-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max-fill-a-grid/discuss/81825/C%2B%2B-DP-solution\n    # https://leetcode.com/problems/max",
    "n = len(grid)\n    m = len(grid[0])\n    bucket_capacity = capacity\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                res += max_fill_helper(grid, i, j, bucket_capacity)\n    return res\n\ndef max_fill_helper(grid, i, j, bucket_capacity):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type i: int\n    :type j: int\n    :type bucket_capacity: int\n    :rtype: int\n    \"\"\"\n    if i == 0 or j == 0:\n        return 0\n    if grid[i-1][j] == 1:\n        return max_fill_helper(grid, i-1, j, bucket_capacity)\n    if grid[i][j-1] == 1:\n        return max_fill_helper(grid, i, j-1, bucket_capacity)\n    if grid[i-1][j-1] == 1:\n        return max_fill_helper(grid, i-1, j-1, bucket_capacity)\n    if grid[i-1][j] + grid[i][j-1] < bucket_capacity:\n        return grid[i-1][j] + grid[i][j-1]\n    else:\n        return max_fill_helper(grid, i-1, j, bucket_capacity) + max_fill_helper(grid, i, j-1, bucket_capacity)\n\nif __name__ == '__main__':\n    for i in range(1, 11):\n        grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity = i\n        print(max_fill(grid, bucket_capacity))",
    "# https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://leetcode.com/problems/max-fill/discuss/373514/C%2B%2B-Python-DP-solution\n    # https://le",
    "if not grid or not capacity:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n\n    # grid[i][j] -> 0 | 1\n    grid[0][0] = 0\n    grid[0][1] = 1\n    grid[m - 1][0] = 1\n    grid[m - 1][1] = 0\n\n    for i in range(1, m - 1):\n        grid[i][0] = grid[i - 1][0]\n        grid[i][1] = grid[i - 1][1]\n    for j in range(1, n - 1):\n        grid[0][j] = grid[0][j - 1]\n        grid[1][j] = grid[1][j - 1]\n    for j in range(2, n - 1):\n        grid[0][j] = grid[1][j - 1]\n        grid[1][j] = grid[0][j - 1]\n\n    def fill_bucket(bucket_idx, bucket_capacity):\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and bucket_capacity > 0:\n                    grid[i][j] = 1\n                    bucket_capacity -= 1\n                    fill_bucket(i, bucket_capacity)\n                    grid[i][j] = 0\n\n    fill_bucket(0, capacity)\n    return m - n\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"0.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    # solve(f)\n    tests = sys.stdin\n    for t in tests:\n        # g = sys.stdin\n        g = t\n        # solve(g)\n        res = solution.solve(g)\n        print(\"{0} {1}\".format(t, res))\n    # eof",
    "# Step 1: find the max value of the first row\n    max_value = grid[0][0]\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][0])\n\n    # Step 2: find the max value of the second row\n    max_value = max(max_value, grid[0][1])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][1])\n\n    # Step 3: find the max value of the third row\n    max_value = max(max_value, grid[0][2])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][2])\n\n    # Step 4: find the max value of the fourth row\n    max_value = max(max_value, grid[0][3])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][3])\n\n    # Step 5: find the max value of the fifth row\n    max_value = max(max_value, grid[0][4])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][4])\n\n    # Step 6: find the max value of the sixth row\n    max_value = max(max_value, grid[0][5])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][5])\n\n    # Step 7: find the max value of the seventh row\n    max_value = max(max_value, grid[0][6])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][6])\n\n    # Step 8: find the max value of the eighth row\n    max_value = max(max_value, grid[0][7])\n    for i in range(1, len(grid)):\n        max_value = max(max_value, grid[i][7])\n\n    # Step 9: find",
    "n = len(grid)\n    m = len(grid[0])\n    # max_fill_cnt = [0 for _ in range(n)]\n    # for i in range(n):\n    #     max_fill_cnt[i] = max(max_fill_cnt[j] for j in range(n) if grid[i][j] == 1)\n    # print(max_fill_cnt)\n    # print(max(max_fill_cnt))\n    # return max(max_fill_cnt)\n    # return sum(max_fill_cnt)\n    return sum(sum(grid[i][j] == 1 for j in range(m)) for i in range(n))\n    # return sum(max_fill_cnt)\n\n\ndef max_fill_2(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    # max_fill_cnt = [0 for _ in range(",
    "n = len(grid)\n    m = len(grid[0])\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                grid[i][j] = -1\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == -1:\n                return 0\n    ans = 0\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == -1:\n                ans += 1\n    return ans",
    "def max_fill_helper(grid, capacity, n, m):\n        if n == 0:\n            return 0\n        elif n == 1:\n            if grid[n-1][m-1] == 0:\n                return 0\n            else:\n                return 1\n        else:\n            if grid[n-1][m-1] == 0:\n                return max_fill_helper(grid, capacity, n-1, m-1)\n            elif grid[n-1][m-1] == 1:\n                return max_fill_helper(grid, capacity, n-1, m)\n            else:\n                return max_fill_helper(grid, capacity, n, m-1)\n    return max_fill_helper(grid, capacity, len(grid), len(grid[0]))\n\ndef max_fill_recursive(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    def max_fill_helper(grid, capacity, n, m):\n        if n == 0:\n            return",
    "n = len(grid)\n    m = len(grid[0])\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                continue\n            elif grid[i][j] == 1:\n                if capacity == 0:\n                    continue\n                elif capacity == 1:\n                    res += 1\n                else:\n                    res += math.ceil(1/float(capacity))\n            elif grid[i][j] == 2:\n                if capacity == 0:\n                    continue\n                elif capacity == 1:\n                    res += 1\n                else:\n                    res += math.ceil(1/float(capacity))\n    return res",
    "if len(grid) == 0:\n        return 0\n    if len(grid[0]) == 0:\n        return 0\n    if capacity == 0:\n        return 0\n    if capacity > grid[0][0]:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    if n == 0:\n        return 0\n    if m == 0:\n        return 0\n    if n == 1:\n        return 0\n    if m == 1:\n        return 0\n    if n == 2 and m == 2:\n        return 0\n    if n == 2:\n        return 0\n    if m == 2:\n        return 0\n    if n == 3 and m == 3:\n        return 0\n    if n == 3:\n        return 0\n    if m == 3:\n        return 0\n    if n == 4 and m == 4:\n        return 0\n    if n == 4:\n        return 0\n    if m == 4:\n        return 0\n    if n == 5 and m == 5:\n        return 0\n    if n == 5:\n        return 0\n    if m == 5:\n        return 0\n    if n == 6 and m == 6:\n        return 0\n    if n == 6:\n        return 0\n    if m == 6:\n        return 0\n    if n == 7 and m == 7:\n        return 0\n    if n == 7:\n        return 0\n    if m == 7:\n        return 0\n    if n == 8 and m == 8:\n        return 0\n    if n == 8:\n        return 0\n    if m == 8:\n        return 0\n    if n == 9 and m == 9:\n        return 0\n    if n == 9:\n        return 0\n    if m == 9:\n        return 0\n    if n == 10 and m == 10:\n        return 0\n    if n == 10:\n        return 0\n    if m == 10:\n        return 0\n    if n == 11 and m == 11:\n        return 0\n    if n == 11:\n        return 0\n    if m == 11:\n        return 0\n    if n == 12 and m == 12:\n        return 0\n    if n == 12:\n        return",
    "n = len(grid)\n    m = len(grid[0])\n\n    if n == 0 or m == 0:\n        return 0\n\n    # the number of ways to fill the grid with water\n    ways = [0] * (m * n)\n    ways[0] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i-1][j-1] == 1:\n                ways[(i-1)*n + j-1] += ways[(i-1)*n + j-1 - 1]\n            if grid[i-1][j] == 1:\n                ways[(i-1)*n + j] += ways[(i-1)*n + j - 1]\n            if grid[i][j-1] == 1:\n                ways[i*n + j-1] += ways[i*n + j-1 - 1]\n            if grid[i][j] == 1:\n                ways[i*n + j] += ways[i*n + j - 1]\n            if grid[i][j+1] == 1:\n                ways[i*n + j+1] += ways[i*n + j - 1]\n            if grid[i][j+2] == 1:\n                ways[i*n + j+2] += ways[i*n + j - 1]\n\n    # the max number of ways to fill the grid with water\n    max_ways = 0\n    for i in range(n):\n        for j in range(m):\n            if ways[(i*m + j)] > max_ways:\n                max_ways = ways[(i*m + j)]\n    return max_ways\n\n\nif __name__ == \"__main__\":\n    n = [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1]\n    ]\n    capacity = 1\n    print(max_fill(n, capacity))",
    "if not grid or not capacity:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n    if n == 0 or m == 0:\n        return 0\n\n    bucket_capacity = capacity\n\n    # for each row, find the maximum water in the row\n    for i in range(n):\n        max_water_in_row = max_water_in_row_in_row(grid, i)\n        bucket_capacity = min(bucket_capacity, max_water_in_row)\n\n    # for each column, find the maximum water in the column\n    for j in range(m):\n        max_water_in_column = max_water_in_column_in_column(grid, j)\n        bucket_capacity = min(bucket_capacity, max_water_in_column)\n\n    return bucket_capacity\n\n\ndef max_water_in_row_in_row(grid, i):\n    \"\"\"\n    Return the maximum water in the row.\n    \"\"\"\n    max_water_in_row = 0\n    for j in range(len(grid[i])):\n        if grid[i][j] == 1:\n            max_water_in_row = max(max_water_in_row, 1)\n    return max_water_in_row\n\n\ndef max_water_in_column_in_column(grid, j):\n    \"\"\"\n    Return the maximum water in the column.\n    \"\"\"\n    max_water_in_column = 0\n    for i in range(len(grid)):\n        if grid[i][j] == 1:\n            max_water_in_column = max(max_water_in_column, 1)\n    return max_water_in_column\n\n\nif __name__ == '__main__':\n    import sys\n\n    f = open(\"0.in\", \"r\")\n    # f = sys.stdin\n    solution = \"\"\n    testcases = int(f.readline().strip())\n\n    for t in range(testcases):\n        # construct cipher\n        n = int(f.readline().strip())\n        grid = []\n        for _ in range(n):\n            grid.append",
    "# print(\"grid\", grid)\n    # print(\"capacity\", capacity)\n    # print(\"len(grid)\", len(grid))\n    # print(\"len(grid[0]), len(grid[0][0])\", len(grid[0]), len(grid[0][0]))\n    # print(\"len(grid[0][0]), len(grid[0][0][0])\", len(grid[0][0]), len(grid[0][0][0]))\n    # print(\"len(grid[0][0][0]), len(grid[0][0][0][0])\", len(grid[0][0][0]), len(grid[0][0][0][0]))\n    # print(\"len(grid[0][0][0][0]), len(grid[0][0][0][0][0])\", len(grid[0][0][0][0]), len(grid[0][0][0][0][0]))\n    # print(\"len(grid[0][0][0][0][0]), len(grid[0][0][0][0][0][0])\", len(grid[0][0][0][0][0]), len(grid[0][0][0][0][0][0]))\n    # print(\"len(grid[0][0][0][0][0][0]), len(grid[0][0][0][0][0][0][0])\", len(grid[0][0][0][0][0]), len(grid[0][0][0][0][0][0][0]))\n    # print(\"len(grid[0][0][0][0][0][0][0]), len(grid[0][0][0][0][0][0][0][0])\", len(grid[0][0][0][0][0][0]), len(grid[0][0][0][0][0][0][0][0]))\n    # print(\"len(grid[0][0][0][0][0][0][0][0]), len(grid[0][0][0][0][0][0][0][0][0])\", len(grid[0][0][0][0][0][0]), len(grid[0][0][0",
    "def solution(grid, capacity):\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        dp = [[0] * grid[0].length for _ in range(grid.length)]\n        for i in range(grid.length):\n            for j in range(grid[i].length):\n                if grid[i][j] == 1:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n                elif grid[i][j] == 0:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                else:\n                    raise Exception('Invalid grid')\n        return dp[grid.length - 1][grid[0].length - 1]\n    return solution(grid, capacity)\n\n\nif __name__ == '__main__':\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    print(max_fill(grid, 2))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    print(max_fill(grid, 5))",
    "m = len(grid)\n    n = len(grid[0])\n    # get the max capacity of the buckets\n    max_capacity = max(map(lambda x: sum(x), grid))\n    # find the max bucket that can be used\n    max_fill = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                # get the bucket that can be used\n                max_fill += max(map(lambda x: x - grid[i][j], grid[i][j+1:]))\n    return max_fill\n\n\nif __name__ == '__main__':\n    import sys\n\n    f = open(\"0.in\", \"r\")\n    # f = sys.stdin\n    grid = []\n    for line in f:\n        # sys.stdout.write(line)\n        grid.append(list(map(int, line.strip().split(' '))))\n    m, n = len(grid), len(grid[0])\n    # m, n = map(int, f.readline().strip().split(' '))\n    # m, n = map(int, sys.stdin.readline().strip().split(' '))\n    grid = [list(row) for row in grid]\n    # grid = map(list, f.readline().strip().split(' '))\n    # grid = map(list, sys.stdin.readline().strip().split(' '))\n    grid = [list(row) for row in grid]\n\n    # solve\n    print(max_fill(grid, m))",
    "return math.ceil(sum(map(lambda x: max_fill_helper(grid, x, capacity), range(1, len(grid) + 1))))\n\ndef max_fill_helper(grid, row, capacity):\n    import math\n    if row == 0:\n        return 0\n    elif row == 1:\n        return 1\n    else:\n        return max(max_fill_helper(grid, row - 1, capacity), max_fill_helper(grid, row - 1, capacity - grid[row - 1][1])) + 1\n\nif __name__ == '__main__':\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    bucket_capacity = 2\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    bucket_capacity = 5\n    print(max_fill(grid, bucket_capacity))",
    "n = len(grid)\n    m = len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                for k in range(i, m):\n                    if grid[k][j] == 0:\n                        grid[k][j] = 1\n                        break\n                for k in range(i, n):\n                    if grid[i][k] == 0:\n                        grid[i][k] = 1\n                        break\n    \n    n = n\n    m = m\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                break\n        else:\n            return 0\n    \n    n = n\n    m = m\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                break\n        else:\n            return 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                break\n        else:\n            return 0\n    \n    return 0",
    "def count_lower_bucket(grid, capacity, i, j):\n        return sum(grid[i][j] == 0) + count_lower_bucket(grid, capacity, i-1, j) \\\n            + count_lower_bucket(grid, capacity, i, j-1)\n\n    def count_upper_bucket(grid, capacity, i, j):\n        return sum(grid[i][j] == 1) + count_upper_bucket(grid, capacity, i-1, j) \\\n            + count_upper_bucket(grid, capacity, i, j-1)\n\n    return count_lower_bucket(grid, capacity, len(grid)-1, len(grid[0])-1) \\\n        + count_upper_bucket(grid, capacity, len(grid)-1, len(grid[0])-1)",
    "def check_input(grid, bucket_capacity):\n        assert len(grid) == 2, \"Wrong grid length\"\n        assert len(grid[0]) == 2, \"Wrong grid row length\"\n        assert len(grid[1]) == 2, \"Wrong grid column length\"\n        assert 0 <= bucket_capacity <= 10, \"Wrong bucket capacity\"\n        assert 1 <= len(grid) <= 10**2, \"Wrong grid length\"\n        assert 1 <= len(grid[0]) <= 10**2, \"Wrong grid row length\"\n        assert 1 <= len(grid[1]) <= 10**2, \"Wrong grid column length\"\n    \n    def max_fill_helper(grid, capacity, bucket_capacity, i, j, max_fill_count):\n        if grid[i][j] == 0:\n            return max_fill_count\n        elif grid[i][j] == 1:\n            return max_fill_helper(grid, capacity, bucket_capacity, i-1, j, max_fill_count)\n        else:\n            max_fill_count = max(max_fill_count, max_fill_helper(grid, capacity, bucket_capacity, i-1, j, max_fill_count))\n            max_fill_count = max(max_fill_count, max_fill_helper(grid, capacity, bucket_capacity, i, j-1, max_fill_count))\n            return max_fill_count\n    \n    check_input(grid, bucket_capacity)\n    max_fill_count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            max_fill_count = max(max_fill_count, max_fill_helper(grid, bucket_capacity, bucket_capacity, i, j, 0))\n    return max_fill_count\n\nif __name__ == \"__main__\":\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))\n    grid = [[0,0,1,",
    "n = len(grid)\n    if n == 0:\n        return 0\n\n    m = len(grid[0])\n\n    def max_fill_helper(row, bucket_capacity):\n        if row == []:\n            return 0\n        else:\n            left = max_fill_helper(row[:], bucket_capacity)\n            right = max_fill_helper(row[1:], bucket_capacity)\n            return max(left, right)\n\n    return max_fill_helper(grid, capacity)",
    "# https://www.acmicpc.net/problem/1544\n    # https://www.acmicpc.net/problem/1667\n    # https://www.acmicpc.net/problem/1918\n    # https://www.acmicpc.net/problem/2117\n    # https://www.acmicpc.net/problem/2032\n    # https://www.acmicpc.net/problem/2438\n    # https://www.acmicpc.net/problem/2617\n    # https://www.acmicpc.net/problem/2765\n    # https://www.acmicpc.net/problem/2925\n    # https://www.acmicpc.net/problem/2938\n    # https://www.acmicpc.net/problem/3135\n    # https://www.acmicpc.net/problem/3201\n    # https://www.acmicpc.net/problem/3400\n    # https://www.acmicpc.net/problem/3600\n    # https://www.acmicpc.net/problem/3601\n    # https://www.acmicpc.net/problem/3640\n    # https://www.acmicpc.net/problem/3800\n    # https://www.acmicpc.net/problem/3900\n    # https://www.acmicpc.net/problem/3901\n    # https://www.acmicpc.net/problem/3902\n    # https://www.acmicpc.net/problem/3903\n    # https://www.acmicpc.net/problem/3904\n    # https://www.acmicpc.net/problem/3905\n    # https://www.acmicpc.net/problem/3906\n    # https://www.acmicpc.net/problem/3907\n    # https://www.acmicpc.net/problem/3908\n    # https://www.acmicpc.net/problem/3909\n    # https://www.acmicpc.net/problem/3910\n    # https://www.acmicpc.net/problem/3911\n    # https://www.acmicpc.net/problem/3912\n    #",
    "row_count = len(grid)\n    col_count = len(grid[0])\n    max_water = capacity\n    result = 0\n    for i in range(row_count):\n        for j in range(col_count):\n            if grid[i][j] == 0:\n                result += 1\n                max_water -= 1\n            elif grid[i][j] == 1:\n                if max_water == 0:\n                    break\n                else:\n                    result += 1\n                    max_water -= 1\n    return result\n\ndef test():\n    assert max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6\n    assert max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5\n    assert max_fill([[0,0,0], [0,0,0]]) == 0\n\nif __name__ == '__main__':\n    test()",
    "# grid = [[0, 0, 0], [0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 0, 0]]\n    # bucket_capacity = 2\n    # Output: 6\n    \n    # grid = [[0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 1, 1]]\n    # bucket_capacity = 2\n    # Output: 3\n    \n    # grid = [[0, 0, 0], [0, 0, 0], [1, 1, 1], [0, 1, 1]]\n    # bucket_capacity = 5\n    # Output: 0\n    \n    if capacity < 1:\n        return 0\n    \n    n = len(grid)\n    m = len(grid[0])\n    \n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                res += max(0, n-i-1) * max(0, m-j-1)\n    \n    return res\n\nif __name__ == \"__main__\":\n    for _ in range(input()):\n        n = input()\n        m = input()\n        grid = [list(map(int, line.strip().split())) for line in open(input())]\n        print(max_fill(grid, m))",
    "n = len(grid)\n    m = len(grid[0])\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                result += min(1, capacity - grid[i][j])\n    return result\n\n\nif __name__ == '__main__':\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    print(max_fill(grid, 2))\n    print(max_fill(grid, 5))\n    print(max_fill(grid, 6))\n    print(max_fill(grid, 7))",
    "n = len(grid)\n    m = len(grid[0])\n    bucket_capacity = capacity\n    queue = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                queue.append((i, j, 0))\n    count = 0\n    while queue:\n        x, y, d = queue.pop(0)\n        if d > bucket_capacity:\n            continue\n        grid[x][y] = 1\n        count += 1\n        if x == n - 1:\n            continue\n        if grid[x + 1][y] == 1:\n            queue.append((x + 1, y, d + 1))\n        if y == m - 1:\n            continue\n        if grid[x][y + 1] == 1:\n            queue.append((x, y + 1, d + 1))\n    return count\n\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    print(max_fill(grid, 2))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    print(max_fill(grid, 5))",
    "n = len(grid)\n    m = len(grid[0])\n    max_water = capacity\n    water = [0] * n\n    max_water_index = [0] * n\n    for i in xrange(n):\n        for j in xrange(m):\n            if grid[i][j] == 1:\n                water[i] += 1\n                max_water_index[i] = max(max_water_index[i], j)\n\n    water_to_lower = 0\n    for i in xrange(n):\n        if water[i] > max_water:\n            water_to_lower += water[i] - max_water\n            water[i] = max_water\n    return water_to_lower\n\nif __name__ == '__main__':\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    bucket_capacity = 1\n    print max_fill(grid, bucket_capacity)\n    grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n    bucket_capacity = 2\n    print max_fill(grid, bucket_capacity)\n    grid = [[0,0,0], [0,0,0]]\n    bucket_capacity = 5\n    print max_fill(grid, bucket_capacity)",
    "# https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/discuss/93825/C%2B%2B-Short-Java-SOLUTION-O(n)\n    # https://leetcode.com/problems/max-fill/",
    "def max_fill_helper(grid, capacity):\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        ret = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    ret += max_fill_helper(grid[i][:j] + grid[i][j+1:], capacity - grid[i][j])\n        return ret\n    return max_fill_helper(grid, capacity)\n\n\ndef test():\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n    grid = [[0,0,0,0], [0,0,0,0], [0,0,0,0]]\n    grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1], [0,1,1,1]]\n    grid = [[0,0,0,0], [0,0,0,0]]\n    grid = [[0,0,0], [0,0,0]]\n    grid = [[0,0,0], [0,0,0], [0,0,0], [0,0,0]]\n    grid = [[0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]]\n    grid = [[0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0",
    "def max_fill_helper(grid, capacity):\n        if not grid:\n            return 0\n        max_water = 0\n        max_water_index = None\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[i])):\n                if grid[i][j] == 0:\n                    water = min(capacity, max_water)\n                    max_water = max(max_water, water)\n                    max_water_index = (i, j)\n        return max_water_index\n\n    return max_fill_helper(grid, capacity)",
    "n = len(grid)\n    m = len(grid[0])\n    if capacity == 0:\n        return 0\n    if capacity > m:\n        capacity = m\n    n_water = 0\n    for i in range(m):\n        water = 0\n        for j in range(n):\n            if grid[i][j] == 1:\n                water += 1\n        if water > capacity:\n            n_water += 1\n    return n_water\n\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) <= 1:\n        import doctest\n        doctest.testmod()\n        sys.exit(0)\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    print(max_fill(grid, 2))\n    print(max_fill(grid, 5))\n    print(max_fill(grid, 10))",
    "m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                grid[i][j] = -1\n    ret = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == -1:\n                ret += max(0, min(n - j, n - i) - 1)\n    return ret\n\nclass Solution(object):\n    def maxFill(self, grid, capacity):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type capacity: int\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    grid[i][j] = -1\n        ret = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    ret += max(0, min(n - j, n - i) - 1)\n        return ret",
    "def find_max_fill(grid, capacity, result):\n        \"\"\"\n        Find the maximum number of buckets that can be filled.\n        :type grid: List[List[int]]\n        :type capacity: int\n        :type result: List[int]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n\n        row_size = len(grid[0])\n        col_size = len(grid)\n\n        # find the maximum number of buckets that can be filled.\n        max_fill = 0\n        for i in range(row_size):\n            for j in range(col_size):\n                if grid[i][j] == 1:\n                    # the bucket is full, we need to find the minimum number of buckets that\n                    # can be used to extract water.\n                    min_fill = math.floor(capacity / 2)\n                    for k in range(1, min_fill):\n                        # find the maximum number of buckets that can be filled with the given\n                        # minimum number of buckets.\n                        max_fill = max(max_fill, find_max_fill(grid, capacity - k, result + [k]))\n                    result.append(min_fill)\n        return max_fill\n    return find_max_fill(grid, capacity, [])",
    "return int(math.ceil(math.log(capacity, 2)))\n\n\nif __name__ == '__main__':\n    grid = [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n    bucket_capacity = 1\n    print(max_fill(grid, bucket_capacity))",
    "# sort the grid by row\n    grid = sorted(grid, key=lambda x: x[0])\n\n    # the maximum number of times that we can lower the buckets\n    max_lower = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 1:\n                if grid[i][j+1] == 1:\n                    max_lower += 1\n                elif grid[i][j+1] == 0:\n                    max_lower += min(max_fill(grid, capacity-1), capacity-1-grid[i][j+1])\n\n    return max_lower",
    "grid = [[0 for _ in range(2)] for _ in range(grid.length)]\n    for i in range(grid.length):\n        for j in range(grid[i].length):\n            if grid[i][j] == 1:\n                grid[i][j] = 1\n                break\n    \n    for i in range(grid.length):\n        for j in range(grid[i].length):\n            if grid[i][j] == 1:\n                break\n            elif grid[i][j] == 0:\n                grid[i][j] = 1\n                break\n        \n    max_capacity = 0\n    for i in range(grid.length):\n        for j in range(grid[i].length):\n            if grid[i][j] == 1:\n                max_capacity = max(max_capacity, grid[i][j])\n    \n    return int(math.ceil(capacity / max_capacity))\n\nclass Solution:\n    def maxFill(self, grid: List[List[int]], capacity: int) -> int:\n        grid = [[0 for _ in range(2)] for _ in range(grid.length)]\n        for i in range(grid.length):\n            for j in range(grid[i].length):\n                if grid[i][j] == 1:\n                    grid[i][j] = 1\n                    break\n        \n        for i in range(grid.length):\n            for j in range(grid[i].length):\n                if grid[i][j] == 1:\n                    break\n                elif grid[i][j] == 0:\n                    grid[i][j] = 1\n                    break\n        \n        max_capacity = 0\n        for i in range(grid.length):\n            for j in range(grid[i].length):\n                if grid[i][j] == 1:\n                    max_capacity = max(max_capacity, grid[i][j])\n        \n        return int(math.ceil(capacity / max_capacity))",
    "row_len, col_len = len(grid), len(grid[0])\n    if row_len == 0 or col_len == 0:\n        return 0\n\n    capacity = min(capacity, row_len*col_len)\n    bucket_cap = [capacity] * col_len\n    bucket_cap[0] = 0\n\n    count = 0\n    for row in grid:\n        for col in row:\n            if col == 0:\n                count += 1\n                bucket_cap[col] -= 1\n\n    return count",
    "return sum([sum(grid[i][j] == 1 for j in range(len(grid[0]))) for i in range(len(grid))]) % capacity\n\nif __name__ == \"__main__\":\n    grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\n    print(max_fill(grid, 1))\n    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]\n    print(max_fill(grid, 2))\n    grid = [[0, 0, 0], [0, 0, 0]]\n    print(max_fill(grid, 5))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}