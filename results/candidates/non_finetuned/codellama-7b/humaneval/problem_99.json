{
  "problem": {
    "task_id": "HumanEval/99",
    "prompt": "\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
    "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
    "entry_point": "closest_integer",
    "docstring": "",
    "problem_id": 99
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "# convert string to float\n    value = float(value)\n    # convert float to int\n    value = int(value)\n    # if value is equidistant from two integers, round it away from zero\n    if value % 1 == 0.5:\n        value = value + 1\n    return value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# check for valid input\n    try:\n        float(value)\n    except:\n        raise ValueError('Invalid input')\n\n    # convert to float\n    value = float(value)\n\n    # round to nearest integer\n    value = round(value)\n\n    # return integer\n    return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    pass",
    "return round(float(value))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if isinstance(value, str):\n        value = float(value)\n\n    if value % 1 == 0.5:\n        if value >= 0:\n            return value + 1\n        return value - 1\n    elif value % 1 >= 0.5:\n        return value + 1\n    return value - 1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "float_value = float(value)\n    if float_value == int(float_value):\n        return int(float_value)\n    elif float_value - int(float_value) == 0.5:\n        return int(float_value) + 1\n    elif float_value - int(float_value) > 0.5:\n        return int(float_value) + 1\n    else:\n        return int(float_value)\n\n\ndef test_closest_integer():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"-14.4\") == -14\n    assert closest_integer(\"-15.5\") == -15\n    assert closest_integer(\"-15.6\") == -16\n    assert closest_integer(\"-15.4\") == -15\n    assert closest_integer(\"15.4\") == 15\n    assert closest_integer(\"15.6\") == 16\n\n\nif __name__ == '__main__':\n    test_closest_integer()",
    "value = float(value)\n    # TODO: Write your function here\n    return round(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "value = float(value)\n    integer = int(value)\n\n    if integer == value:\n        return integer\n    elif integer > value:\n        return integer - 1\n    else:\n        return integer + 1\n\n\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))",
    "if type(value) is not str:\n        raise TypeError(\"Input must be a string\")\n\n    # convert to float\n    number = float(value)\n\n    # convert to int\n    number_int = int(number)\n\n    # round the number\n    number_rounded = round(number)\n\n    # get the difference between the rounded number and the input number\n    diff = number_rounded - number\n\n    # get the absolute value of the difference\n    diff_abs = abs(diff)\n\n    # if the difference is equal to the number\n    if diff == number:\n        # return the number rounded\n        return number_rounded\n\n    # if the difference is greater than or equal to the number\n    if diff >= number:\n        # return the number rounded\n        return number_rounded\n\n    # if the difference is less than the number\n    if diff < number:\n        # if the difference is greater than or equal to zero\n        if diff_abs >= 0:\n            # return the number rounded\n            return number_rounded\n\n        # if the difference is less than zero\n        if diff_abs < 0:\n            # return the number rounded\n            return number_rounded",
    "# return int(round(float(value)))\n    num = float(value)\n    if num > 0:\n        return int(num + 0.5)\n    elif num < 0:\n        return int(num - 0.5)\n    else:\n        return int(num)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\ndef test_closest_integer():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"-14.555\") == -15\n    assert closest_integer(\"-14.444\") == -14\n    assert closest_integer(\"0.5\") == 0\n    assert closest_integer(\"0.499999999\") == 0\n    assert closest_integer(\"0.50000001\") == 1\n    assert closest_integer(\"-0.5\") == 0\n    assert closest_integer(\"-0.499999999\") == 0\n    assert closest_integer(\"-0.50000001\") == -1\n    assert closest_integer(\"-1000.5\") == -1000\n    assert closest_integer(\"1000.5\") == 1000\n    assert closest_integer(\"5.0\") == 5\n    assert closest_integer(\"5.5\") == 6\n    assert closest_integer(\"5.499999999\") == 5\n    assert closest_integer(\"5.50000001\") == 6\n    assert closest_integer(\"5.444444444\") == 5\n    assert closest_integer(\"5.555555555\") == 6\n    assert closest_integer(\"2.4\") == 2\n    assert closest_integer(\"2.5\") == 3\n    assert closest_integer(\"2.499999999\") == 2\n    assert closest_integer(\"2.50000001\") == 3\n    assert closest_integer(\"2.444444444\") == 2\n    assert closest_integer(\"2.555555555\") == 3",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\n\n\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    return int(float(value) + 0.5)\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "value = float(value)\n    return int(round(value))\n\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\n\n# 15\n# 15\n# -15\n\n\ndef closest_integer_2(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    value = float(value)\n    return int(value + 0.5)\n\nprint(closest_integer_2(\"15.3\"))\nprint(closest_integer_2(\"14.5\"))\nprint(closest_integer_2(\"-14.5\"))\n\n# 15\n# 15\n# -15",
    "# First, convert the input to a float.\n    number = float(value)\n\n    # If the number is equidistant between two integers, round it away from zero.\n    if number > 0:\n        if (number % 1) == 0.5:\n            number += 1\n        return int(number)\n\n    # If the number is negative, round it away from zero.\n    elif number < 0:\n        if (abs(number) % 1) == 0.5:\n            number -= 1\n        return int(number)\n\n\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "# If it's an integer, just return it.\n    if int(value) == float(value):\n        return int(value)\n\n    # If it's a float, return the closest integer.\n    return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\ndef test_closest_integer():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"14.4\") == 14\n    assert closest_integer(\"-14.4\") == -14\n    assert closest_integer(\"-14.6\") == -15\n    assert closest_integer(\"14.6\") == 15\n    assert closest_integer(\"-14.55\") == -15\n    assert closest_integer(\"14.55\") == 15\n    assert closest_integer(\"0.5\") == 1\n    assert closest_integer(\"0.51\") == 1\n    assert closest_integer(\"0.49\") == 0\n    assert closest_integer(\"1.5\") == 2\n    assert closest_integer(\"2.5\") == 3\n    assert closest_integer(\"3.5\") == 4\n    assert closest_integer(\"-3.5\") == -4\n    assert closest_integer(\"-2.5\") == -3\n    assert closest_integer(\"-1.5\") == -2\n    assert closest_integer(\"1.5\") == 2\n    assert closest_integer(\"2.5\") == 3\n    assert closest_integer(\"3.5\") == 4\n    assert closest_integer(\"1000.3\") == 1000\n    assert closest_integer(\"1000.5\") == 1001\n    assert closest_integer(\"1000.6\") == 1001\n    assert closest_integer(\"-1000.5\") == -1001\n    assert closest_integer(\"-1000.6\") == -1001\n    assert closest_integer(\"1000.55\") == 1001\n    assert closest_integer(\"1000.45\") == 1000\n    assert closest_integer(\"100",
    "return int(round(float(value)))",
    "if float(value) - int(value) == 0:\n        return int(value)\n    elif float(value) - int(value) >= 0.5:\n        return int(value) + 1\n    else:\n        return int(value) - 1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "# your code here\n    return int(round(float(value)))\n\n\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"10\"))",
    "# Your code here\n    return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# TODO: write your code here\n    return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# your code here\n    pass\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "if value == '0':\n        return 0\n\n    value = float(value)\n\n    if value > 0:\n        return int(value + (0.5 if value % 1 == 0.5 else 1))\n    else:\n        return int(value - (0.5 if value % 1 == 0.5 else 1))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "float_value = float(value)\n    int_value = int(float_value)\n    if abs(float_value - int_value) == 0.5:\n        return int(float_value + 0.5)\n    elif float_value - int_value >= 0.5:\n        return int_value + 1\n    else:\n        return int_value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    float_value = float(value)\n    if float_value - int(float_value) < 0.5:\n        return int(float_value)\n    else:\n        if float_value >= 0:\n            return int(float_value) + 1\n        else:\n            return int(float_value) - 1\n\n\nprint(closest_integer(\"10\"))  # Should print 10\nprint(closest_integer(\"15.3\"))  # Should print 15\nprint(closest_integer(\"-14.5\"))  # Should print -15",
    "return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "number = float(value)\n    number = number if number % 1 else number + 1\n    return int(number)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# your code here\n    return round(float(value))\n\n\nif __name__ == '__main__':\n    print(\"Example:\")\n    print(closest_integer('10'))\n\n    # These \"asserts\" are used for self-checking and not for an auto-testing\n    assert closest_integer('10') == 10\n    assert closest_integer('0') == 0\n    assert closest_integer('1000000000000000000000000000') == 1000000000000000000000000000\n    assert closest_integer('-10') == -10\n    assert closest_integer('15.3') == 15\n    assert closest_integer('14.5') == 15\n    assert closest_integer('-14.5') == -15\n    assert closest_integer('1234.5678') == 1235\n    assert closest_integer('1234.4678') == 1234\n    assert closest_integer('1234.4679') == 1235\n    assert closest_integer('-1234.5678') == -1234\n    assert closest_integer('-1234.4678') == -1234\n    assert closest_integer('-1234.4679') == -1234\n    print(\"Coding complete? Click 'Check' to earn cool rewards!\")",
    "return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Convert string to float\n    value = float(value)\n\n    # Get absolute value\n    value = abs(value)\n\n    # If the number is equidistant from two integers, round it away from zero.\n    # If the number is equidistant from two integers, round it away from zero.\n    if value % 1 == 0.5:\n        return int(value) + 1\n    else:\n        return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    return int(value) if float(value) % 1 == 0 else int(value) + 1 if float(value) % 1 > 0.5 else int(value) - 1\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "import math\n    num = float(value)\n    return round(num + math.copysign(0.5, num), 0)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "return int(round(float(value)))\n\n\ndef test_closest_integer():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.49999999999\") == -15\n    assert closest_integer(\"4.49999999999\") == 4\n    assert closest_integer(\"-4.49999999999\") == -4\n\n\nif __name__ == '__main__':\n    test_closest_integer()",
    "return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# the following is the solution I came up with, but I'm sure\n    # there is a much simpler way to do it!\n    value = float(value)\n    if value < 0:\n        value *= -1\n    if value % 1 >= 0.5:\n        value += 1\n    return int(value)\n\ndef test_function(test_case):\n    test_case = test_case.split(',')\n    test_input = test_case[0]\n    solution = test_case[1]\n    output = closest_integer(test_input)\n    if output == int(solution):\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\ntest_function(\"10,10\")\ntest_function(\"15.3,15\")\ntest_function(\"14.5,15\")\ntest_function(\"-14.5,-15\")\ntest_function(\"12.4999999,12\")\ntest_function(\"12.5000001,13\")\ntest_function(\"0.5,1\")\ntest_function(\"-0.5,-1\")\ntest_function(\"12345678901234567890.5,12345678901234567891\")\ntest_function(\"-12345678901234567890.5,-12345678901234567891\")\ntest_function(\"12345678901234567890.4,12345678901234567890\")\ntest_function(\"-12345678901234567890.4,-12345678901234567890\")\ntest_function(\"12345678901234567890.6,123456789",
    "# Taking the number as a string\n    number = value\n    # Converting the number into a float\n    number = float(number)\n    # Finding the absolute value\n    number = abs(number)\n    # Rounding off the number to the nearest integer\n    number = round(number)\n    # Converting the rounded off number back into a string\n    number = str(number)\n    # Converting the string into a integer\n    number = int(number)\n    return number",
    "return int(round(float(value)))",
    "# Convert string to float\n    num = float(value)\n\n    # Check if number is equidistant from two integers\n    if num % 1 == 0.5:\n        # If true, round number away from zero\n        return int(round(num + 0.5))\n    else:\n        # If false, return the nearest integer\n        return int(round(num))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\n\n\ndef closest_integer_2(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer_2(\"10\")\n    10\n    >>> closest_integer_2(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer_2(\"14.5\") should\n    return 15 and closest_integer_2(\"-14.5\") should return -15.\n    '''\n    return int(float(value) + 0.5)\n\n\nprint(closest_integer_2(\"10\"))\nprint(closest_integer_2(\"15.3\"))",
    "#print(value)\n    #print(type(value))\n    #print(int(value))\n    #print(int(float(value)))\n    #print(int(float(value))+0.5)\n    #print(int(float(value))-0.5)\n    #print(abs(int(float(value))-0.5))\n    #print(abs(int(float(value))-0.5) == min(abs(int(float(value))-0.5)))\n    #print(abs(int(float(value))-0.5) == min(abs(int(float(value))-0.5), abs(int(float(value))-0.5)))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))+0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))-0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))+0.5, int(float(value))-0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))-0.5, int(float(value))+0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))-0.5, int(float(value))-0.5, int(float(value))+0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5, int(float(value))-0.5, int(float(value))-0.5, int(float(value))+0.5, int(float(value))+0.5))\n    #print(int(float(value))-0.5 == min(int(float(value))-0.5,",
    "# Cast value to float\n    value = float(value)\n\n    # Calculate floor and ceil of value\n    floor = int(value // 1)\n    ceil = floor + 1\n\n    # If value is equidistant from floor and ceil, return the ceil\n    if floor == ceil:\n        return ceil\n    # If value is closer to floor than ceil, return the floor\n    elif abs(value - floor) < abs(value - ceil):\n        return floor\n    # If value is closer to ceil than floor, return the ceil\n    else:\n        return ceil\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "float_value = float(value)\n    if float_value - int(float_value) == 0.5:\n        return int(float_value + 1)\n    else:\n        return int(float_value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\n\n\ndef closest_integer2(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    return int(round(float(value)))\n\nprint(closest_integer2(\"10\"))\nprint(closest_integer2(\"15.3\"))\n\n\ndef closest_integer3(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    return int(round(float(value)))\n\nprint(closest_integer3(\"10\"))\nprint(closest_integer3(\"15.3\"))\n\n\ndef closest_integer4(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equid",
    "# Your code here\n    num = float(value)\n    if num > 0:\n        return int(num+0.5)\n    else:\n        return int(num-0.5)\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "# Your code here\n    if value == \"0\":\n        return 0\n    if float(value) - int(value) == 0:\n        return int(value)\n    if float(value) - int(value) > 0:\n        return int(value) + 1\n    return int(value) - 1\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"0\"))\nprint(closest_integer(\"-0.5\"))\nprint(closest_integer(\"-0.4\"))\nprint(closest_integer(\"-0.6\"))\nprint(closest_integer(\"0.5\"))\nprint(closest_integer(\"0.4\"))\nprint(closest_integer(\"0.6\"))",
    "# TODO: Write your function here\n    return round(float(value))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "pass\n\nprint(closest_integer(\"15.3\"))",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\n\n# ------------------------------------------------------------------------------------\n\ndef is_leap_year(year):\n    '''\n    Create a function that takes a year (string) and returns True if the\n    year is a leap year. Otherwise return False.\n\n    Examples\n    >>> is_leap_year(\"2012\")\n    True\n    >>> is_leap_year(\"1999\")\n    False\n    '''\n    year = int(year)\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n        return True\n    return False\n\nprint(is_leap_year(\"2012\"))\nprint(is_leap_year(\"1999\"))\n\n# ------------------------------------------------------------------------------------\n\ndef days_in_month(month, year):\n    '''\n    Create a function that takes a month (string) and year (string)\n    and returns the number of days in that month.\n\n    Examples\n    >>> days_in_month(\"February\", \"2012\")\n    29\n    >>> days_in_month(\"August\", \"1978\")\n    31\n    '''\n    month = str(month)\n    year = int(year)\n    if month == \"February\":\n        if is_leap_year(year):\n            return 29\n        return 28\n    if month == \"April\" or month == \"June\" or month == \"September\" or month == \"November\":\n        return 30\n    return 31\n\nprint(days_in_month(\"February\", \"2012\"))\nprint(days_in_month(\"August\", \"1978\"))\n\n# ------------------------------------------------------------------------------------\n\ndef next_day(year, month, day):\n    '''\n    Create a function that takes a",
    "if isinstance(value, str):\n        value = float(value)\n    if value % 1 == 0.5:\n        if value > 0:\n            return int(value - 0.5)\n        elif value < 0:\n            return int(value + 0.5)\n    elif value % 1 == 0.0:\n        return int(value)\n    else:\n        return round(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\n\n\ndef distance_from_zero(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the absolute value of the number.\n\n    Examples\n    >>> distance_from_zero(\"10\")\n    10\n    >>> distance_from_zero(\"-10\")\n    10\n    >>> distance_from_zero(\"-15.3\")\n    15.3\n    '''\n\n    return abs(float(value))\n\n\nprint(distance_from_zero(\"10\"))\nprint(distance_from_zero(\"-10\"))\nprint(distance_from_zero(\"-15.3\"))\n\n\ndef is_prime(value):\n    '''\n    Create a function that takes a value (string) representing an integer\n    and returns True if it is a prime number, False otherwise.\n\n    Examples\n    >>> is_prime(\"10\")\n    False\n    >>> is_prime(\"11\")\n    True\n    >>> is_prime(\"25\")\n    False\n    >>> is_prime(\"27\")\n    True\n    '''\n\n    if int(value) < 2:\n        return False\n    for i in range(2, int(value)):\n        if int(value) % i == 0:\n            return False\n    return True\n\n\nprint(is_prime(\"10\"))\nprint(is_prime(\"11\"))\nprint(is_prime(\"25\"))\nprint(is_prime(\"27\"))",
    "return round(float(value))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "return round(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "#convert string to float\n    num = float(value)\n    #if number is equidistant from two integers, round it away from zero\n    if int(num) == num:\n        return int(num)\n    #if number is greater than 0, return the closest integer below it\n    elif num > 0:\n        return int(num + 1)\n    #if number is less than 0, return the closest integer above it\n    else:\n        return int(num - 1)\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"-14.4\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"14.4\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"-14.4\"))",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\n\ndef closest_integer_2(value):\n    return int(float(value) + (0.5 - round(float(value)) % 2))\n\nprint(closest_integer_2(\"10\"))\nprint(closest_integer_2(\"15.3\"))\nprint(closest_integer_2(\"14.5\"))\nprint(closest_integer_2(\"-14.5\"))",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Convert to float\n    number = float(value)\n\n    # Check if it is a positive number\n    if number >= 0:\n        # Round up\n        return int(number + 0.5)\n    # Check if it is a negative number\n    elif number < 0:\n        # Round down\n        return int(number - 0.5)\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "def _is_even(number):\n        return number % 2 == 0\n\n    def _closest_integer(value):\n        value = float(value)\n\n        if _is_even(value):\n            return int(value)\n\n        return int(value + 0.5)\n\n    return _closest_integer(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# convert string to float\n    x = float(value)\n    # convert x to integer\n    y = int(x)\n    # check if x is integer\n    if x == y:\n        return x\n    # check if x is float\n    else:\n        # check if x is negative\n        if x < 0:\n            # check if x is equidistant from two integers\n            if int(x - y) == 0.5:\n                return y - 1\n            # check if x is not equidistant from two integers\n            else:\n                return y\n        # check if x is positive\n        else:\n            # check if x is equidistant from two integers\n            if int(x - y) == 0.5:\n                return y + 1\n            # check if x is not equidistant from two integers\n            else:\n                return y",
    "# your code here\n    # print(type(value))\n    value = float(value)\n    if value % 1 == 0.5:\n        return int(value + 1)\n    else:\n        return int(value)\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\n\n\ndef string_to_int(string):\n    '''\n    Create a function that takes a string as an input and returns\n    an integer if the string is a number. Otherwise, return None.\n\n    Examples\n    >>> string_to_int(\"10\")\n    10\n    >>> string_to_int(\"banana\")\n    None\n\n    Note:\n    You may want to use the float() or int() functions to turn a\n    string into a number.\n    '''\n    # your code here\n    try:\n        return int(string)\n    except ValueError:\n        return None\n\nprint(string_to_int(\"10\"))\nprint(string_to_int(\"banana\"))\n\n\ndef string_to_float(string):\n    '''\n    Create a function that takes a string as an input and returns\n    a float if the string is a number. Otherwise, return None.\n\n    Examples\n    >>> string_to_float(\"10\")\n    10.0\n    >>> string_to_float(\"10.5\")\n    10.5\n    >>> string_to_float(\"banana\")\n    None\n    '''\n    # your code here\n    try:\n        return float(string)\n    except ValueError:\n        return None\n\nprint(string_to_float(\"10\"))\nprint(string_to_float(\"10.5\"))\nprint(string_to_float(\"banana\"))\n\n\ndef count_letters(string):\n    '''\n    Create a function that takes a string as an input and returns\n    a dictionary where each key is a letter and each value is the\n    number of times that letter occurs in the string.\n\n    Examples\n    >>> count_letters",
    "return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\n\n\ndef is_palindrome(input):\n    \"\"\"\n    Create a function that takes a string and returns True if the string is\n    a palindrome (reads the same forwards and backwards), and False\n    otherwise.\n\n    Examples:\n    >>> is_palindrome(\"tacocat\")\n    True\n    >>> is_palindrome(\"banana\")\n    False\n    \"\"\"\n    return input == input[::-1]\n\nprint(is_palindrome(\"tacocat\"))\nprint(is_palindrome(\"banana\"))\n\n\ndef is_prime(input):\n    \"\"\"\n    Create a function that takes a number and returns True if the number\n    is a prime, and False otherwise.\n\n    Examples:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"\n    for i in range(2, input):\n        if input % i == 0:\n            return False\n    return True\n\nprint(is_prime(2))\nprint(is_prime(15))\n\n\ndef is_fibonacci(input):\n    \"\"\"\n    Create a function that takes a number and returns True if the number\n    is a Fibonacci number, and False otherwise.\n\n    Examples:\n    >>> is_fibonacci(8)\n    True\n    >>> is_fibonacci(22)\n    False\n    \"\"\"\n    return is_prime(input) and is_prime(input-1) and is_prime(input+1)\n\nprint(is_fibonacci(8))\nprint(is_fibonacci(22))\n\n\ndef is_divisible(input, divisor):\n    \"\"\"\n    Create a function that takes two numbers as arguments and returns\n    True if the first number is evenly divisible by the second number,\n    False otherwise.\n\n    Examples:\n    >>> is_divisible(4, 2)\n    True\n    >>> is_divisible(5,",
    "num = float(value)\n    int_num = int(num)\n    if num - int_num == 0.5:\n        return int_num + 1\n    elif num - int_num > 0.5:\n        return int_num + 1\n    else:\n        return int_num\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\n\ndef test_closest_integer():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"1234.5678\") == 1235\n    assert closest_integer(\"-1234.5678\") == -1235\n    assert closest_integer(\"1234.4\") == 1234\n    assert closest_integer(\"-1234.4\") == -1234\n    assert closest_integer(\"1234.5\") == 1235\n    assert closest_integer(\"-1234.5\") == -1235\n    assert closest_integer(\"1234.6\") == 1235\n    assert closest_integer(\"-1234.6\") == -1235\n    assert closest_integer(\"1234.51\") == 1235\n    assert closest_integer(\"-1234.51\") == -1235\n    assert closest_integer(\"1234.501\") == 1235\n    assert closest_integer(\"-1234.501\") == -1235\n    assert closest_integer(\"1234.499\") == 1234\n    assert closest_integer(\"-1234.499\") == -1234\n    assert closest_integer(\"1234.45\") == 1234\n    assert closest_integer(\"-1234.45\") == -1234\n    assert closest_integer(\"1234.451\") == 1234\n    assert closest_integer(\"-1234",
    "# Hint: Use the built-in abs() function\n\n    # The following solution is a bit more involved than the others.\n    # It uses the built-in math.floor() and math.ceil() functions,\n    # which return the largest integer less than or equal to x, and\n    # the smallest integer greater than or equal to x, respectively.\n    #\n    # To get the closest integer to x, you first need to find the\n    # integer part of x (the integer that x is closest to). To do\n    # this, you can subtract the integer part of x from x. If this\n    # is positive, then you can subtract the integer part of x from\n    # x again to get the fractional part of x. If this is negative,\n    # then you can add the integer part of x to x to get the\n    # fractional part of x.\n    #\n    # The integer part of x is equal to math.floor(x) for positive\n    # numbers and math.ceil(x) for negative numbers.\n    import math\n    x = float(value)\n    integer_part = math.floor(x) if x > 0 else math.ceil(x)\n    fractional_part = x - integer_part if x > 0 else integer_part - x\n    return integer_part if abs(fractional_part) > 0.5 else integer_part - 1\n\ndef closest_integer2(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    # The following solution uses the built-in round() function,",
    "# your code here\n    return int(round(float(value)))",
    "return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# convert value to float\n    value = float(value)\n    # if value is equidistant from two integers, round it away from zero\n    if value > 0:\n        if value - int(value) == 0.5:\n            return int(value) + 1\n        else:\n            return int(value)\n    elif value < 0:\n        if int(value) - value == 0.5:\n            return int(value) - 1\n        else:\n            return int(value)\n    else:\n        return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "if value == '0':\n        return 0\n    return round(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "float_value = float(value)\n    if float_value - int(float_value) > 0:\n        return int(float_value) + 1\n    else:\n        return int(float_value)\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "float_value = float(value)\n\n    if float_value - int(float_value) < 0.5:\n        return int(float_value)\n    elif float_value - int(float_value) > 0.5:\n        return int(float_value) + 1\n    else:\n        return 0\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "# your code here\n    #print(type(value))\n    if type(value) == str:\n        value = float(value)\n    if (value - int(value)) == 0.5:\n        if int(value) > 0:\n            return int(value) - 1\n        elif int(value) < 0:\n            return int(value) + 1\n    return int(value)",
    "if float(value) > 0:\n        return int(value) if float(value) - int(value) < 0.5 else int(value) + 1\n    elif float(value) < 0:\n        return int(value) if int(value) - float(value) < 0.5 else int(value) - 1\n    else:\n        return 0\n\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
    "# Convert to float\n    value = float(value)\n\n    # Round to integer\n    value = round(value)\n\n    # Check if the number is equidistant from two integers\n    if value % 1 == 0.5:\n        # Round away from zero\n        value += 1\n\n    # Return the rounded value\n    return value",
    "# convert the string to a float\n    value = float(value)\n\n    # if the number is equidistant from two integers, round it away from zero\n    if abs(int(value) - value) == 0.5:\n        return int(value + 1)\n    else:\n        return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "float_value = float(value)\n    if float_value - int(float_value) == 0.5:\n        return int(float_value + 1)\n    else:\n        return int(float_value)\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"-14.4\"))",
    "return int(round(float(value)))",
    "if value == \"0\":\n        return 0\n    else:\n        if float(value) < 0:\n            return int(value) - 0.5\n        else:\n            return int(value) + 0.5\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "import math\n\n    # Create a float from the string\n    number = float(value)\n\n    # Round number to the nearest integer\n    rounded = round(number)\n\n    # If number is equidistant from two integers, round away from zero\n    if abs(rounded - number) == 0.5:\n        rounded = math.floor(number + 0.5)\n\n    # Return the rounded integer as a string\n    return str(rounded)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return round(float(value))\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))",
    "# Your code here\n    return int(round(float(value)))\n\nprint(closest_integer(\"10\"))  # 10\nprint(closest_integer(\"15.3\"))  # 15\nprint(closest_integer(\"14.5\"))  # 15\nprint(closest_integer(\"-14.5\"))  # -15\nprint(closest_integer(\"14.4\"))  # 14\nprint(closest_integer(\"-14.6\"))  # -15\nprint(closest_integer(\"-14.51\"))  # -15\nprint(closest_integer(\"4.51\"))  # 5\nprint(closest_integer(\"-14.49\"))  # -14\nprint(closest_integer(\"0.51\"))  # 1\nprint(closest_integer(\"-0.49\"))  # 0\nprint(closest_integer(\"0.49\"))  # 0\nprint(closest_integer(\"-0.51\"))  # 0\nprint(closest_integer(\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "# convert to float\n    value = float(value)\n    # round\n    rounded_value = round(value)\n    # check if rounded value is closer than value\n    if abs(rounded_value - value) < abs(rounded_value - 0):\n        return int(rounded_value)\n    else:\n        # otherwise return int(value)\n        return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}