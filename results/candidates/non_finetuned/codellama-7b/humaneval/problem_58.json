{
  "problem": {
    "task_id": "HumanEval/58",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
    "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
    "entry_point": "common",
    "docstring": "",
    "problem_id": 58
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "l3 = [i for i in l1 if i in l2]\n    l3.sort()\n    return l3",
    "# Set Union\n    # return sorted(set(l1).intersection(set(l2)))\n\n    # List Union\n    # return sorted(list(set(l1) | set(l2)))\n\n    # List Comprehension\n    return sorted([val for val in l1 if val in l2])",
    "set_1 = set(l1)\n    set_2 = set(l2)\n    return sorted(set_1 & set_2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))",
    "# O(n)\n    return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_sorted(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n*log(n))\n    return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_fast(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_fast([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_fast([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n)\n    s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1.intersection(s2))\n\n\ndef common_fastest(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_fastest([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_fastest([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n)\n    s1 = set",
    "return sorted(set(l1) & set(l2))",
    "l1.sort()\n    l2.sort()\n    result = []\n    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))",
    "if len(l1) > len(l2):\n        return common(l2, l1)\n\n    # build a set of elements in list 1\n    s = set(l1)\n\n    # check for intersection with list 2\n    result = []\n    for x in l2:\n        if x in s:\n            result.append(x)\n\n    return sorted(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(set(l2))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\ndef unique_common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> unique_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> unique_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(l2)))\n\n\ndef common_sorted(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common_sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1).intersection(l2)))",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(l1) < len(l2):\n        return sorted(set(l1) & set(l2))\n    else:\n        return sorted(set(l2) & set(l1))",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "set1 = set(l1)\n    set2 = set(l2)\n    common = set1 & set2\n    return sorted(common)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# We don't need to sort the lists because they are sorted\n    # anyway.\n    # We need to make a copy of the lists because otherwise we\n    # will modify the original lists.\n    l1 = l1[:]\n    l2 = l2[:]\n    # We need to make a copy of the lists because otherwise we\n    # will modify the original lists.\n    l1 = l1[:]\n    l2 = l2[:]\n    # Remove duplicates from the lists.\n    l1 = list(set(l1))\n    l2 = list(set(l2))\n    # Find the common elements.\n    common = []\n    for el in l1:\n        if el in l2:\n            common.append(el)\n    # Sort the common elements.\n    common.sort()\n    return common\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "l3 = sorted(set(l1) & set(l2))\n    return l3\n\n\ndef difference(l1: list, l2: list):\n    \"\"\"Return sorted unique elements in first list not present in second.\n    >>> difference([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [2, 3, 4]\n    >>> difference([5, 3, 2, 8], [3, 2])\n    [5, 8]\n\n    \"\"\"\n    l3 = sorted(set(l1) - set(l2))\n    return l3\n\n\ndef union(l1: list, l2: list):\n    \"\"\"Return sorted unique elements in first or second list.\n    >>> union([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 3, 4, 5, 653, 7, 9, 121]\n    >>> union([5, 3, 2, 8], [3, 2])\n    [2, 3, 5, 8]\n\n    \"\"\"\n    l3 = sorted(set(l1) | set(l2))\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Create a dictionary that counts the number of times a value\n    # occurs in l1.\n    d1 = {}\n    for i in l1:\n        if i in d1:\n            d1[i] += 1\n        else:\n            d1[i] = 1\n\n    # Create a dictionary that counts the number of times a value\n    # occurs in l2.\n    d2 = {}\n    for i in l2:\n        if i in d2:\n            d2[i] += 1\n        else:\n            d2[i] = 1\n\n    # Create a dictionary that counts the number of times a value\n    # occurs in the intersection of the two lists.\n    d3 = {}\n    for i in l1:\n        if i in d2:\n            if i in d3:\n                d3[i] += 1\n            else:\n                d3[i] = 1\n\n    # Create a list of common values.\n    common = []\n    for i in d3:\n        if d1[i] == d2[i]:\n            common.append(i)\n\n    # Return the sorted unique common values.\n    return sorted(common)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))  # [1, 5, 653]\n    l1 = [5, 3, 2, 8]\n    l2 = [3, 2]\n    print(common(l1, l2))  # [2, 3]\n\n\nif __name__ == \"__main__\":\n    main()",
    "return sorted(list(set(l1).intersection(l2)))",
    "l1.sort()\n    l2.sort()\n    i = 0\n    j = 0\n    common_elements = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            common_elements.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return common_elements\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "l3 = set(l1) & set(l2)\n    l3 = sorted(l3)\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Set operations are O(n), so we can use them to get the unique values of\n    # each list in O(n) time.\n    l1_set = set(l1)\n    l2_set = set(l2)\n\n    # Find the intersection of the sets in O(n) time using set.intersection().\n    # This will return a set of common elements, but we want a list.\n    common_elements = l1_set.intersection(l2_set)\n\n    # Sort the common elements in O(n log n) time.\n    return sorted(common_elements)",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))",
    "return sorted(set(l1) & set(l2))",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# TODO: complete this local function\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))",
    "l1.sort()\n    l2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))",
    "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "l1 = set(l1)\n    l2 = set(l2)\n\n    return sorted(l1 & l2)\n\n\ndef common_sort(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1.sort()\n    l2.sort()\n\n    l1 = set(l1)\n    l2 = set(l2)\n\n    return sorted(l1 & l2)",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "l1.sort()\n    l2.sort()\n    l1_p = l1[0]\n    l2_p = l2[0]\n    result = []\n    while True:\n        if l1_p == l2_p:\n            result.append(l1_p)\n        if l1_p < l2_p:\n            l1_p = l1[l1.index(l1_p) + 1]\n        else:\n            l2_p = l2[l2.index(l2_p) + 1]\n        if l1_p == len(l1):\n            break\n        if l2_p == len(l2):\n            break\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# convert to dict\n    d1 = {}\n    d2 = {}\n    for i in l1:\n        d1[i] = 1\n    for i in l2:\n        d2[i] = 1\n    # find intersection\n    ret = []\n    for i in d1:\n        if i in d2:\n            ret.append(i)\n    return sorted(ret)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))",
    "l1.sort()\n    l2.sort()\n\n    common_list = []\n\n    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            common_list.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n\n    return common_list",
    "if len(l1) < len(l2):\n        return common(l2, l1)\n    l1 = set(l1)\n    l2 = set(l2)\n    return sorted(l1 & l2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    print(common([5, 3, 2, 8], [3, 2]))",
    "if not l1 or not l2:\n        return []\n    return sorted(set(l1) & set(l2))",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Set-based approach\n    return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    main()",
    "return sorted(set(l1).intersection(l2))",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_recursive(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_recursive([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_recursive([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if l1 and l2:\n        if l1[0] == l2[0]:\n            return [l1[0]] + common_recursive(l1[1:], l2[1:])\n        else:\n            return common_recursive(l1[1:], l2) or common_recursive(l1, l2[1:])\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1.intersection(s2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))",
    "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))",
    "return sorted(list(set(l1).intersection(set(l2))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(set(l2)))\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    main()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(l1) > len(l2):\n        return common(l2, l1)\n\n    l1 = sorted(l1)\n    l2 = sorted(l2)\n\n    i, j = 0, 0\n    result = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    seen = set(l1)\n    return sorted(set(l2) & seen)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(list(set(l1).intersection(set(l2))))",
    "return sorted(set(l1) & set(l2))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}