{
  "problem": {
    "task_id": "HumanEval/49",
    "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
    "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
    "entry_point": "modp",
    "docstring": "",
    "problem_id": 49
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "assert n >= 0\n    assert p >= 2\n    if p == 2:\n        return n & 1\n    m = 1\n    while m < n:\n        m <<= 1\n    while m:\n        if n >= p:\n            n -= p\n        if m & n:\n            n = (n << 1) % p\n        m >>= 1\n    return n\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of n in (Z/pZ)^*.\n    >>> modp_inv(3, 5)\n    2\n    >>> modp_inv(1101, 101)\n    7\n    >>> modp_inv(0, 101)\n    1\n    \"\"\"\n    assert n >= 0\n    assert p >= 2\n    if p == 2:\n        return n & 1\n    if n == 0:\n        return 0\n    if p == 1:\n        return 1\n    if n == 1:\n        return 1\n    if p == 2:\n        return n & 1\n    if n == 1:\n        return 1\n    if p == 2:\n        return n & 1\n    if n == 1:\n        return 1\n    u = p\n    v = n\n    t = 0\n    while v:\n        q = u // v\n        r = u % v\n        u = v\n        v = r\n        t = q - t\n    if u == 1:\n        return t % p\n    raise ValueError(\"{} has no inverse mod {}\".format(n, p))\n\n\ndef modp_sqrt(n: int, p: int):\n    \"\"\"Return a square root of n in (Z/pZ)^*, or raise ValueError.\n    >>> modp_sqrt(2, 5)\n    2\n    >>> modp_sqrt(1101, 101)\n    11\n    >>> modp_sqrt(0, 101)\n    0\n    >>> modp_sqrt(2, 11)\n    3",
    "if p == 2:\n        return 1\n\n    if n == 0:\n        return 1\n\n    if n % 2 == 0:\n        return modp(n / 2, p) * modp(2, p)\n\n    return modp((n - 1) / 2, p) * modp(2, p) * p\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return the multiplicative inverse of a modulo p.\n    >>> modp_inv(7, 11)\n    4\n    >>> modp_inv(7, 13)\n    5\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef modp_log(x: int, p: int):\n    \"\"\"Return log_2(x) modulo p.\n    >>> modp_log(2, 3)\n    1\n    >>> modp_log(2, 11)\n    1\n    >>> modp_log(12, 11)\n    10\n    >>> modp_log(1, 13)\n    12\n    \"\"\"\n    if x == 0:\n        return 0\n\n    if x == 1:\n        return 1\n\n    return modp_log(x, p) + modp_log(modp(2, p), p)\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(18, 42)\n    6\n    >>> gcd(2, 3)\n    1\n    >>> gcd(11, 35)\n    1\n    \"\"\"\n    if a == 0:\n        return b\n\n    return gcd(b % a, a)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"Return the lowest common multiple of a and b.\n    >>> lcm(3, 5)\n    15\n    >>> lcm(3, 6)\n    6\n    >>> lcm(24, 30)\n    60\n    \"\"\"\n    return",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return 2**n % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse(3, 101)\n    3\n    >>> modp_inverse(1101, 101)\n    4\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    4\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse_naive(3, 101)\n    3\n    >>> modp_inverse_naive(1101, 101)\n    4\n    >>> modp_inverse_naive(0, 101)\n    1\n    >>> modp_inverse_naive(3, 11)\n    4\n    >>> modp_inverse_naive(100, 101)\n    1\n    \"\"\"\n    for i in range(1, p):\n        if n * i % p == 1:\n            return i\n    return 0\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    # modp_inverse_naive(3, 11)\n    # modp_inverse_naive(3, 11)\n    # modp_inverse_naive(0, 11)\n    # modp_inverse_naive(100, 111)\n    # modp_inverse_naive(100, 111)\n    # modp_inverse_naive(100, 111)\n\n\nif __name__ == \"__main__\":\n    main()",
    "assert n >= 0\n    assert p > 0\n    r = 1\n    while n > 0:\n        if n % 2 == 1:\n            r = r * p % p\n        p = p * p % p\n        n //= 2\n    return r\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse(2, 3)\n    1\n    >>> modp_inverse(1101, 101)\n    100\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    5\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    assert n >= 0\n    assert p > 0\n    r = 1\n    while n > 0:\n        if n % 2 == 1:\n            r = r * (p - 1) % p\n        p = p * p % p\n        n //= 2\n    return r\n\n\ndef modp_crt(x: int, a: int, p: int, y: int, b: int, q: int):\n    \"\"\"Return x modulo p and y modulo q (be aware of numerics).\n    >>> modp_crt(2, 3, 11, 1, 3, 11)\n    10\n    >>> modp_crt(2, 3, 11, 1, 3, 101)\n    1\n    >>> modp_crt(100, 11, 101, 1, 11, 101)\n    1\n    \"\"\"\n    assert x >= 0\n    assert y >= 0\n    assert p > 0\n    assert q > 0\n    assert a >= 0\n    assert b >= 0\n    assert p != q\n    assert a != b\n    assert x % p == a\n    assert y % q == b\n    return",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_pow(x: int, n: int, p: int):\n    \"\"\"Return x^n modulo p (be aware of numerics).\n    >>> modp_pow(3, 3, 101)\n    3\n    >>> modp_pow(3, 1101, 101)\n    3\n    >>> modp_pow(3, 100, 101)\n    1\n    \"\"\"\n    return pow(x, n, p)\n\n\ndef modp_pow_inv(x: int, n: int, p: int):\n    \"\"\"Return the inverse of x^n modulo p (be aware of numerics).\n    >>> modp_pow_inv(3, 3, 101)\n    3\n    >>> modp_pow_inv(3, 1101, 101)\n    3\n    >>> modp_pow_inv(3, 100, 101)\n    1\n    \"\"\"\n    return pow(x, -n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef main():\n    n = int(input())\n    p = int(input())\n    print(modp(n, p))\n\n\nif __name__ == \"__main__\":\n    main()",
    "return 2**n % p\n\n\ndef modp_inverse(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modp_inverse(2, 101)\n    99\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Inverse of 0 does not exist.\")\n    return pow(a, p - 2, p)\n\n\ndef modp_sqrt(a: int, p: int):\n    \"\"\"Return the square root of a modulo p.\n    >>> modp_sqrt(2, 101)\n    99\n    \"\"\"\n    if modp_inverse(2, p) != 2:\n        raise ValueError(\"p must be prime.\")\n    return pow(a, (p + 1) // 4, p)\n\n\ndef modp_factorize(a: int, p: int):\n    \"\"\"Return the factorization of a modulo p.\n    >>> modp_factorize(2, 101)\n    [100]\n    \"\"\"\n    if a == 0:\n        return [p]\n    return [modp_sqrt(a, p), p - modp_sqrt(a, p)]\n\n\ndef modp_add(a: int, b: int, p: int):\n    \"\"\"Return the addition of a and b modulo p.\n    >>> modp_add(1, 2, 101)\n    3\n    >>> modp_add(3, 4, 101)\n    7\n    \"\"\"\n    return (a + b) % p\n\n\ndef modp_mul(a: int, b: int, p: int):\n    \"\"\"Return the multiplication of a and b modulo p.\n    >>> modp_mul(1, 2, 101)\n    2\n    >>> modp_mul(3, 4, 101)\n    12\n    \"\"\"\n    return (a * b) % p\n\n\ndef modp_inv_mul(a: int, b: int, p: int):\n    \"\"\"Return the multiplication of a^-1 and b modulo p.",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    1\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1\n    assert n < p\n    return pow(modp(n, p), p - 2, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a/b modulo p (be aware of numerics).\n    >>> modp_div(3, 2, 5)\n    3\n    >>> modp_div(1101, 1100, 101)\n    1\n    >>> modp_div(1101, 1100, 11)\n    1\n    >>> modp_div(1101, 1100, 101)\n    1\n    \"\"\"\n    return pow(modp(b, p), p - 2, p) * a % p\n\n\ndef modp_div_inv(a: int, b: int, p: int):\n    \"\"\"Return the inverse of a/b modulo p (be aware of numerics).\n    >>> modp_div_inv(3, 2, 5)\n    3\n    >>> modp_div_inv(1101, 1100, 101)\n    1\n    >>> modp_div_inv(1101, 1100, 11)\n    1\n    >>> modp_div_inv(1101, 1100, 101)\n    1\n    \"\"\"\n    return pow(modp(b, p), p -",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(1, 101)\n    100\n    >>> modp_inv(100, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    \"\"\"\n    return pow(2, (p - 2) % p, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a modulo p divided by b modulo p (be aware of numerics).\n    >>> modp_div(1, 1, 101)\n    100\n    >>> modp_div(100, 1, 101)\n    1\n    >>> modp_div(100, 2, 101)\n    50\n    >>> modp_div(100, 3, 101)\n    66\n    >>> modp_div(100, 4, 101)\n    40\n    >>> modp_div(100, 5, 101)\n    20\n    >>> modp_div(100, 6, 101)\n    28\n    \"\"\"\n    return pow(a, p - 2, p) * pow(b, p - 2, p) % p\n\n\ndef modp_mul(a: int, b: int, p: int):\n    \"\"\"Return a modulo p multiplied by b modulo p (be aware of numerics).\n    >>> modp_mul(1, 1, 101)\n    100\n    >>> modp_mul(100, 1, 101)\n    1\n    >>> modp_mul(100, 2, 101)",
    "return pow(2, n, p)\n\n\ndef modinv(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modinv(2, 101)\n    8\n    >>> modinv(12, 101)\n    21\n    >>> modinv(2, 101) == modp(-2, 101)\n    True\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modsqrt(a: int, p: int):\n    \"\"\"Return the square root of a modulo p.\n    >>> modsqrt(2, 101)\n    5\n    >>> modsqrt(12, 101)\n    7\n    >>> modsqrt(12, 101) == modp(12, 101)\n    True\n    \"\"\"\n    assert p % 4 in (1, 3), \"p must be 1 mod 4\"\n    if p == 2:\n        return a\n    if p % 4 == 3:\n        return pow(a, (p + 1) // 4, p)\n    s = pow(a, (p + 1) // 4, p)\n    if s == 1:\n        return s\n    s = s * s % p\n    s = s * s % p\n    if s == 1:\n        return s\n    for i in range(2, p):\n        s = s * s % p\n        if s == 1:\n            return s\n    return None",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 5)\n    3\n    >>> modp_inverse(2, 11)\n    8\n    \"\"\"\n    return pow(n, p-2, p)\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 5)\n    3\n    >>> modp_inverse(2, 11)\n    8\n    \"\"\"\n    for i in range(1, p):\n        if i*n % p == 1:\n            return i\n    raise ValueError('no inverse')\n\n\ndef modp_inverse_extended_euclid(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 5)\n    3\n    >>> modp_inverse(2, 11)\n    8\n    \"\"\"\n    if p == 2:\n        return n\n    a, b = p, n\n    u, v = 1, 0\n    while a != 0:\n        q, r = divmod(b, a)\n        u, v = v, u - q*v\n        b, a = a, r\n    if b != 1:\n        raise ValueError('no inverse')\n    return v % p\n\n\ndef modp_inverse_extended_euclid_naive(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 5)\n    3\n    >>> modp_inverse(2, 11)\n    8\n    \"\"\"\n    for i in range(1, p):\n        if (i*n + p) % p == 1:\n            return i\n    raise ValueError('no inverse')\n\n\ndef modp_inverse_extended_euclid_table(n: int,",
    "return pow(2, n, p)\n\n\ndef modp_inverse(a: int, p: int) -> int:\n    \"\"\"Return 2^(-a) modulo p (be aware of numerics).\n    >>> modp_inverse(3, 5)\n    3\n    >>> modp_inverse(1101, 101)\n    2\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    8\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(2, -a, p)\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(5)\n    True\n    >>> is_prime(6)\n    False\n    >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False\n    >>> is_prime(9)\n    False\n    >>> is_prime(10)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return greatest common divisor of a and b.\n    >>> gcd(2, 4)\n    2\n    >>> gcd(4, 6)\n    2\n    >>> gcd(10, 12)\n    2\n    >>> gcd(100, 121)\n    11\n    \"\"\"\n    if a < 0:\n        a = -a\n    if b < 0:\n        b = -b\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a % b == 0:",
    "if p == 2:\n        return 1 << n\n    else:\n        return pow(2, n, p)\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(2)\n    True\n    >>> is_prime(101)\n    True\n    >>> is_prime(100)\n    False\n    >>> is_prime(121)\n    False\n    >>> is_prime(101*101)\n    False\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(n ** 0.5) + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Return (g, x, y) such that a*x + b*y = g = gcd(a, b).\n    >>> egcd(2, 3)\n    (1, -1, 1)\n    >>> egcd(101, 103)\n    (1, -2, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, x, y = egcd(b % a, a)\n    return (g, y - (b // a) * x, x)\n\n\ndef modinv(a: int, m: int):\n    \"\"\"Return the modular inverse of a modulo m (be aware of numerics).\n    >>> modinv(2, 101)\n    7\n    >>> modinv(11, 101)\n    11\n    >>> modinv(3, 11)\n    8\n    \"\"\"\n    g, x, _ = egcd(a, m)\n    if g == 1:\n        return x % m\n\n\ndef crt(a: int, m: int, b: int, n: int):",
    "return (2 ** n) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef extended_gcd(a: int, b: int):\n    \"\"\"Return a tuple (x, y) such that ax + by = gcd(a, b)\n    >>> extended_gcd(3, 5)\n    (1, -1)\n    >>> extended_gcd(1101, 101)\n    (1, -1)\n    >>> extended_gcd(0, 101)\n    (1, -1)\n    >>> extended_gcd(3, 11)\n    (1, -8)\n    >>> extended_gcd(100, 101)\n    (1, -1)\n    \"\"\"\n    if a == 0:\n        return (0, 1)\n    g, y, x = extended_gcd(b % a, a)\n    return g, x - (b // a) * y\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime.\n    >>> is_prime(11)\n    True\n    >>> is_prime(12)\n    False\n    >>> is_prime(1111)\n    True\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False",
    "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (modp(n // 2, p) ** 2) * 3 % p\n\n\ndef modp_slow(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1\n    return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1\n    x = modp_inv(p % n, n)\n    return pow(p, x, n)\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(4, 6)\n    2\n    >>> gcd(12, 15)\n    3\n    >>> gcd(4, 3)\n    1\n    >>> gcd(12, 2)\n    2\n    \"\"\"\n    if a < b:\n        a, b = b, a\n    while a % b != 0:\n        a, b = b, a % b\n    return b\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"Return the least common multiple of a and b.\n    >>> lcm(4, 6)\n    12\n    >>> lcm(12, 15)\n    60\n    >>> lcm(4, 3)\n    12\n    >>> lcm(12, 2)\n    12\n    \"\"\"\n    return (a * b) // gcd(a, b)\n\n\ndef phi(n: int) -> int:\n    \"\"\"Return the Euler's totient function \u03c6(n) (the count of numbers less than n\n    which are coprime to it).\n    >>> phi(2)\n    1\n    >>> phi(3)\n    2\n    >>> phi(4)\n    2\n    >>> ph",
    "return pow(2, n, p)\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return the inverse of a in modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(a, p-2, p)\n\n\ndef modp_mul(a: int, b: int, p: int):\n    \"\"\"Return a * b modulo p (be aware of numerics).\n    >>> modp_mul(3, 5, 11)\n    8\n    >>> modp_mul(3, 5, 11) == modp_mul(5, 3, 11)\n    True\n    >>> modp_mul(3, 5, 11) == modp_mul(3, 5, 11)\n    True\n    >>> modp_mul(3, 5, 11) == modp_mul(5, 3, 11)\n    True\n    >>> modp_mul(3, 5, 11) == modp_mul(3, 5, 11)\n    True\n    >>> modp_mul(3, 5, 11) == modp_mul(5, 3, 11)\n    True\n    \"\"\"\n    return pow(a, b, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a / b modulo p (be aware of numerics).\n    >>> modp_div(3, 5, 11)\n    3\n    >>> modp_div(3, 5, 11) == modp_div(5, 3, 11)\n    True\n    >>> modp_div(3, 5, 11",
    "return 1 if n == 0 else (2 * modp(n - 1, p) if n % 2 == 1 else modp(n // 2, p) * modp(n // 2 + 1, p)) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return modp(p - 2 * modp(n, p) + p, p)\n\n\ndef modp_pow(b: int, n: int, p: int):\n    \"\"\"Return b^n modulo p (be aware of numerics).\n    >>> modp_pow(3, 3, 5)\n    3\n    >>> modp_pow(3, 1101, 101)\n    2\n    >>> modp_pow(3, 0, 101)\n    1\n    >>> modp_pow(3, 3, 11)\n    8\n    >>> modp_pow(3, 100, 101)\n    1\n    \"\"\"\n    return 1 if n == 0 else (modp(n, p) * modp_pow(b, n - 1, p)) % p\n\n\ndef modp_pow_inv(b: int, n: int, p: int):\n    \"\"\"Return inverse of b^n modulo p (be aware of numerics).\n    >>> modp_pow_inv(3, 3, 5)\n    3\n    >>> modp_pow_inv(3, 1101, 101)\n    2\n    >>> modp_pow_inv(3, 0, 101)\n    1\n    >>> modp_",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, n: int):\n    \"\"\"Return the inverse of a modulo n.\n    >>> modinv(3, 11)\n    4\n    >>> modinv(7, 11)\n    8\n    \"\"\"\n    t, r = n, a\n    newt = t % r\n    x = 0\n    while newt != 0:\n        quotient = t // newt\n        x, newt = newt, x - quotient * newt\n    return x % n",
    "return pow(2, n, p)\n\n\ndef egcd(a: int, b: int) -> tuple:\n    \"\"\"Return tuple (g, x, y) such that ax + by = g = gcd(a, b).\n    >>> egcd(2, 3)\n    (1, -1, 1)\n    >>> egcd(110, 101)\n    (1, 1, 0)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, y, x = egcd(b % a, a)\n    return (g, x - (b // a) * y, y)\n\n\ndef invmodp(a: int, p: int) -> int:\n    \"\"\"Return x such that ax = 1 mod p.\n    >>> invmodp(11, 101)\n    10\n    \"\"\"\n    g, x, _ = egcd(a, p)\n    if g != 1:\n        raise Exception(\"No inverse exists\")\n    return x % p\n\n\ndef mulinvmodp(a: int, b: int) -> int:\n    \"\"\"Return x such that ax = 1 mod b.\n    >>> mulinvmodp(11, 101)\n    10\n    \"\"\"\n    x = 0\n    low = 1\n    high = b\n    while low < high:\n        mid = (low + high) // 2\n        if mid * mid < b:\n            low = mid + 1\n        else:\n            high = mid\n    x = low\n    if (x - 1) * b + 1 != a * x:\n        raise Exception(\"No inverse exists\")\n    return x\n\n\ndef divmodp(a: int, b: int, p: int) -> int:\n    \"\"\"Return x such that ax = 1 mod b.\n    >>> divmodp(11, 3, 101)\n    37\n    \"\"\"\n    return mulinvmodp(a, b) * b % p\n\n\ndef powmodp(a: int, b: int, p: int) -> int:",
    "return pow(2, n, p)\n\n\ndef mod255(n: int):\n    \"\"\"Return 2^n modulo 255.\n    >>> mod255(3)\n    8\n    >>> mod255(1101)\n    12\n    >>> mod255(0)\n    1\n    \"\"\"\n    return modp(n, 255)\n\n\ndef mod127(n: int):\n    \"\"\"Return 2^n modulo 127.\n    >>> mod127(3)\n    8\n    >>> mod127(1101)\n    12\n    >>> mod127(0)\n    1\n    \"\"\"\n    return modp(n, 127)\n\n\ndef mod256(n: int):\n    \"\"\"Return 2^n modulo 256.\n    >>> mod256(3)\n    8\n    >>> mod256(1101)\n    12\n    >>> mod256(0)\n    1\n    \"\"\"\n    return modp(n, 256)\n\n\ndef mod1023(n: int):\n    \"\"\"Return 2^n modulo 1023.\n    >>> mod1023(3)\n    8\n    >>> mod1023(1101)\n    12\n    >>> mod1023(0)\n    1\n    \"\"\"\n    return modp(n, 1023)\n\n\ndef mod1024(n: int):\n    \"\"\"Return 2^n modulo 1024.\n    >>> mod1024(3)\n    8\n    >>> mod1024(1101)\n    12\n    >>> mod1024(0)\n    1\n    \"\"\"\n    return modp(n, 1024)\n\n\ndef mod1075(n: int):\n    \"\"\"Return 2^n modulo 1075.\n    >>> mod1075(3)\n    8\n    >>> mod1075(11",
    "return (pow(2, n, p) + 1) % p\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the multiplicative inverse of a in the finite field of order p.\n    >>> modinv(2, 11)\n    4\n    >>> modinv(123, 11)\n    9\n    >>> modinv(5, 11)\n    6\n    >>> modinv(7, 11)\n    4\n    >>> modinv(5, 17)\n    12\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef is_square(n: int):\n    \"\"\"Return True if n is a square.\n    >>> is_square(1)\n    True\n    >>> is_square(2)\n    False\n    >>> is_square(3)\n    False\n    >>> is_square(4)\n    True\n    >>> is_square(5)\n    False\n    >>> is_square(100)\n    False\n    >>> is_square(101)\n    True\n    >>> is_square(102)\n    False\n    \"\"\"\n    return n > 0 and pow(n, (p - 1) // 2, p) == 1\n\n\ndef is_quadratic_residue(n: int):\n    \"\"\"Return True if n is a quadratic residue.\n    >>> is_quadratic_residue(1)\n    True\n    >>> is_quadratic_residue(2)\n    False\n    >>> is_quadratic_residue(3)\n    False\n    >>> is_quadratic_residue(4)\n    True\n    >>> is_quadratic_residue(5)\n    False\n    >>> is_quadratic_residue(100)\n    False\n    >>> is_quadratic_residue(101)\n    True\n    >>> is_quadratic_residue(102)\n    False\n    \"\"\"\n    return is_square(n) and modp(n, p) == 1\n\n\ndef is_quad",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 5)\n    3\n    >>> modp_inverse(3, 101)\n    8\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef extended_euclidean(a: int, b: int):\n    \"\"\"Return a tuple (r, i, j) such that r = gcd(a, b) = ia + jb\n    >>> extended_euclidean(2, 3)\n    (1, -1, 1)\n    >>> extended_euclidean(1101, 101)\n    (1, -2, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, y, x = extended_euclidean(b % a, a)\n    return (g, x - (b // a) * y, y)\n\n\ndef modp_inverse_extended(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse_extended(2, 5)\n    3\n    >>> modp_inverse_extended(3, 101)\n    8\n    >>> modp_inverse_extended(100, 101)\n    1\n    \"\"\"\n    g, x, _ = extended_euclidean(n, p)\n    if g == 1:\n        return x % p\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse_naive(2, 5)\n    3\n    >>> modp_inverse_naive(3, 101)\n    8\n    >>> modp_inverse_naive(100, 101)\n    1\n    \"\"\"\n    for",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef is_prime(n: int):\n    \"\"\"Check if n is prime.\n    >>> is_prime(13)\n    True\n    >>> is_prime(12)\n    False\n    >>> is_prime(3215)\n    True\n    >>> is_prime(3216)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef find_prime(bits: int):\n    \"\"\"Return a prime number randomly.\n    >>> find_prime(10)\n    103\n    >>> find_prime(12)\n    4559\n    \"\"\"\n    while True:\n        n = random.randint(2**(bits-1), 2**bits)\n        if is_prime(n):\n            return n\n\n\ndef find_prime_miller_rabin(bits: int):\n    \"\"\"Return a prime number randomly.\n    >>> find_prime_miller_rabin(10)\n    103\n    >>> find_prime_miller_rabin(12)\n    4559\n    \"\"\"\n    while True:\n        n = random.randint(2**(bits-1), 2**bits)\n        if is_prime_miller_rabin(n):\n            return n\n\n\ndef is_prime_miller_rabin(n: int, k: int=20):",
    "if p == 2:\n        return 1 << n\n    return pow(2, n, p)\n\n\ndef is_prime(n: int):\n    \"\"\"\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(5)\n    True\n    >>> is_prime(15)\n    False\n    >>> is_prime(101)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef find_prime_modulo(modulo: int, bit_length: int,\n                      primes_sieve: set):\n    \"\"\"Find a prime number that is congruent to 1 modulo modulo\n    and has a bit length of bit_length.\n    >>> find_prime_modulo(10, 10, {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})\n    29\n    >>> find_prime_modulo(10, 10, {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31})\n    31\n    \"\"\"\n    n = 1\n    while True:\n        n += 1\n        if n % 2 == 0:\n            continue\n        if n in primes_sieve:\n            if modp(n, modulo) == 1:\n                break\n    return n\n\n\ndef find_prime_factors(n: int, primes_sieve: set,\n                       bit_length: int):\n    \"\"\"Return a set of prime factors of n.\n    >>> find_prime_factors(10, {2, 3, 5",
    "# return pow(2, n, p)\n    return pow(2, n, p) if n > 0 else 1\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    # return pow(2, -n, p)\n    return pow(2, -n, p) if n > 0 else 1\n\n\ndef modp_inv2(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv2(3, 5)\n    3\n    >>> modp_inv2(1101, 101)\n    2\n    >>> modp_inv2(0, 101)\n    1\n    >>> modp_inv2(3, 11)\n    8\n    >>> modp_inv2(100, 101)\n    1\n    \"\"\"\n    # return pow(2, -n, p)\n    if n > 0:\n        return pow(2, -n, p)\n    else:\n        return pow(2, p - n, p)\n\n\ndef pow2_modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> pow2_modp(3, 5)\n    3\n    >>> pow2_modp(1101, 101)\n    2\n    >>> pow2_modp(0, 101)\n    1\n    >>> pow2_modp(3, 11)\n    8\n    >>> pow2_modp(100, 1",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if p == 2:\n        return 1 + (n & 1)\n    if p == 3:\n        return 1 + (n & 2)\n    if p == 5:\n        return 1 + (n & 4)\n    if p == 7:\n        return 1 + (n & 6)\n    if p == 11:\n        return 1 + (n & 8)\n    if p == 13:\n        return 1 + (n & 10)\n    if p == 17:\n        return 1 + (n & 16)\n    if p == 19:\n        return 1 + (n & 32)\n    if p == 31:\n        return 1 + (n & 64)\n    return pow(2, n, p)\n\n\ndef test_modp():\n    assert modp(3, 5) == 3\n    assert modp(1101, 101) == 2\n    assert modp(0, 101) == 1\n    assert modp(3, 11) == 8\n    assert modp(100, 101) == 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n < 0:\n        return -1 * modp(-1 * n, p)\n    elif n == 0:\n        return 1\n    elif n == 1:\n        return n\n    else:\n        return (2 * modp(n // 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modp_inverse(a: int, p: int) -> int:\n    \"\"\"Return inverse of a modulo p.\n    >>> modp_inverse(2, 101)\n    99\n    \"\"\"\n    if a < 0 or a >= p:\n        a %= p\n    if a == 0:\n        raise ZeroDivisionError(\"0 has no inverse modulo p\")\n    t = 0\n    r = p\n    newt = 1\n    newr = a\n    while newr != 0:\n        quotient = r // newr\n        (t, newt) = (newt, t - quotient * newt)\n        (r, newr) = (newr, r - quotient * newr)\n    if r > 1:\n        raise Exception(\"a is not invertible modulo p\")\n    if t < 0:\n        t += p\n    return t\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a modulo p divided by b modulo p.\n    >>> modp_div(2, 3, 101)\n    99\n    >>> modp_div(10, 11, 101)\n    9\n    \"\"\"\n    if a < 0 or a >= p:\n        a %= p\n    if b < 0 or b >= p:\n        b %= p\n    if a == 0:\n        raise ZeroDivisionError(\"0 has no inverse modulo p\")\n    if b == 0:\n        raise ZeroDivisionError(\"0 has no inverse modulo p\")\n    t = 0\n    r = p\n    newt = 1\n    newr = b\n    while newr != 0:\n        quotient = r // newr\n        (t, newt) = (newt, t - quotient * newt)\n        (r, newr) = (newr, r - quotient * newr)\n    if r > 1:\n        raise Exception(\"a is not invertible modulo p\")\n    if t < 0:",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^(-1) modulo p (be aware of numerics).\n    >>> modp_inv(1, 5)\n    3\n    >>> modp_inv(2, 101)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -1, p)\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(100, 101)\n    1\n    >>> gcd(2, 4)\n    2\n    >>> gcd(4, 6)\n    2\n    >>> gcd(6, 4)\n    2\n    >>> gcd(12, 18)\n    6\n    >>> gcd(18, 12)\n    6\n    >>> gcd(3, 5)\n    1\n    >>> gcd(5, 3)\n    1\n    >>> gcd(2, 3)\n    1\n    >>> gcd(3, 2)\n    1\n    \"\"\"\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"Return the least common multiple of a and b.\n    >>> lcm(100, 101)\n    101\n    >>> lcm(2, 4)\n    4\n    >>> lcm(4, 6)\n    12\n    >>> lcm(6, 4)\n    12\n    >>> lcm(12, 18)\n    24\n    >>> lcm(18, 12)\n    24\n    >>> lcm(3, 5)\n    15\n    >>> lcm(5, 3)\n    15\n    >>> lcm(2, 3)\n    6\n    >>> lcm(3, 2)\n    6\n    \"\"\"",
    "if n == 0:\n        return 1\n\n    if n == 1:\n        return p\n\n    if n == 2:\n        return p * p\n\n    if n == 3:\n        return p * p * p\n\n    if n == 4:\n        return pow(p, 4)\n\n    return pow(p, n, p)\n\n\ndef egcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"Returns a tuple (g, x, y) such that ax + by = g = gcd(a, b)\n    >>> egcd(3, 5)\n    (1, -1, 1)\n    >>> egcd(1101, 101)\n    (1, -2, 1)\n    >>> egcd(0, 101)\n    (101, 0, 1)\n    >>> egcd(3, 11)\n    (1, -1, 10)\n    >>> egcd(100, 101)\n    (1, -1, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return g, y - (b // a) * x, x\n\n\ndef modinv(a: int, m: int) -> int:\n    \"\"\"Returns the modular inverse of a in the modulo m\n    >>> modinv(3, 5)\n    2\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    g, x, _ = egcd(a, m)\n    if g != 1:\n        raise Exception('Modular inverse does not exist')\n    else:\n        return x % m\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Returns True if",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef invmod(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of n modulo p.\n    >>> invmod(121, 101)\n    11\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef find_primitive_root(p: int):\n    \"\"\"Return a primitive root of p if one exists, else None.\n    >>> find_primitive_root(11)\n    2\n    >>> find_primitive_root(13)\n    8\n    >>> find_primitive_root(17)\n    2\n    >>> find_primitive_root(211)\n    151\n    >>> find_primitive_root(221)\n    \"\"\"\n    if p < 2:\n        return None\n    for g in range(2, p):\n        for x in range(1, p):\n            if pow(g, p - 1, p) == 1 and pow(g, x, p) != 1:\n                return g\n    return None\n\n\ndef find_primitive_roots(p: int):\n    \"\"\"Return a list of primitive roots of p.\n    >>> find_primitive_roots(11)\n    [2, 5, 6, 7]\n    >>> find_primitive_roots(13)\n    [8, 10]\n    >>> find_primitive_roots(17)\n    [2, 12, 13, 14, 15]\n    >>> find_primitive_roots(221)\n    [151, 162, 164, 165, 166, 167, 168, 169, 170, 171]\n    \"\"\"\n    roots = []\n    for g in range(2, p):\n        for x in range(1, p):\n            if pow(g, p - 1, p) == 1 and pow(g, x, p) != 1:\n                roots.append(g)",
    "return pow(2, n, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return (2 ** n) % p\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the modular inverse of a (mod p).\n    >>> modinv(10, 11)\n    1\n    >>> modinv(101, 11)\n    10\n    >>> modinv(3, 11)\n    9\n    >>> modinv(2, 11)\n    8\n    >>> modinv(121, 13)\n    11\n    >>> modinv(3, 17)\n    14\n    \"\"\"\n    if p == 2:\n        return a\n    for i in range(1, p):\n        if (a * i) % p == 1:\n            return i\n    return 0\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Return a tuple with gcd(a,b), x and y such that\n    ax + by = gcd(a,b)\n    >>> egcd(3, 7)\n    (1, -1, 1)\n    >>> egcd(17, 20)\n    (1, 2, -1)\n    >>> egcd(12, 17)\n    (1, 1, 4)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\n\ndef modinv_ext(a: int, p: int):\n    \"\"\"Return the extended modular inverse of a (mod p)\n    >>> modinv_ext(121, 13)\n    (11, 1, 1)\n    >>> modinv_ext(3, 17)\n    (2, 14, 1)\n    \"\"\"\n    g, x, y = egcd(a, p)\n    if g == 1:\n        return (x % p, y % p, g)\n    else:\n        return None\n\n\ndef modinv_ext_all(a: int",
    "return (pow(2, n, p) + 1) % p\n\n\ndef main():\n    \"\"\"Read input and print output.\"\"\"\n    p = int(input())\n    n = int(input())\n    print(modp(n, p))\n\n\nif __name__ == \"__main__\":\n    main()",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, m: int):\n    \"\"\"Return modular inverse of a in m.\n    >>> modinv(7, 11)\n    2\n    >>> modinv(3, 11)\n    4\n    \"\"\"\n    return pow(a, m - 2, m)\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return greatest common divisor of a and b.\n    >>> gcd(4, 6)\n    2\n    >>> gcd(15, 20)\n    5\n    \"\"\"\n    return a if b == 0 else gcd(b, a % b)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"Return lowest common multiple of a and b.\n    >>> lcm(6, 4)\n    12\n    >>> lcm(10, 15)\n    30\n    \"\"\"\n    return a * b // gcd(a, b)\n\n\ndef is_prime(n: int):\n    \"\"\"Return whether n is prime.\n    >>> is_prime(2)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(12)\n    False\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef next_prime(n: int):\n    \"\"\"Return next prime following n.\n    >>> next_prime(2)\n    3\n    >>> next_prime(1024)\n    1025\n    \"\"\"\n    n += 1\n    while not is_prime(n):\n        n += 1\n    return n\n\n\ndef is_perfect_square(n: int):\n    \"\"\"Return whether n is a perfect square.\n    >>> is_perfect_square(25)",
    "return 2**n % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(3, 5)\n    3\n    >>> modp_inverse(1101, 101)\n    99\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    9\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    x, y, u, v, a, b = 1, 0, 0, 1, n, p\n    while u:\n        q, r = v // u, v % u\n        x, y, u, v, a, b = y, x - q * y, u, v - q * u, b, a - q * b\n    assert v == 1\n    return x % p\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse_naive(3, 5)\n    3\n    >>> modp_inverse_naive(1101, 101)\n    99\n    >>> modp_inverse_naive(0, 101)\n    1\n    >>> modp_inverse_naive(3, 11)\n    9\n    >>> modp_inverse_naive(100, 101)\n    1\n    \"\"\"\n    for i in range(1, p):\n        if n * i % p == 1:\n            return i\n    raise ValueError(\"No inverse found.\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of n in the ring Z/pZ.\n    >>> modp_inv(3, 5)\n    2\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    9\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef is_prime(n: int, k: int = 30) -> bool:\n    \"\"\"Return True if n is prime and False otherwise.\n    >>> is_prime(11)\n    True\n    >>> is_prime(12)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    s = n - 1\n    t = 0\n    while s % 2 == 0:\n        s = s // 2\n        t += 1\n    for _ in range(k):\n        a = random.randrange(2, n - 1)\n        x = pow(a, s, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(t - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n\ndef gen_prime(length: int, k: int = 30) -> int:\n    \"\"\"Return a pseudo-random prime number of length bits.\n    >>> gen_prime(128) > 0\n    True\n    >>> gen_prime(128) != gen_prime(128)\n    True\n    \"\"\"\n    p = 1\n    while not is_prime(p, k):\n        p = random.getrandbits(length)\n    return p\n\n\ndef g",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    7\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    4\n    >>> modp_inv(100, 101)\n    100\n    \"\"\"\n    if n < 0 or n > p:\n        raise ValueError(\"n must be between 0 and p\")\n    if p < 1:\n        raise ValueError(\"p must be at least 1\")\n\n    return modp(p - 2 * n, p)",
    "return (2 ** n) % p\n\n\ndef is_prime(n: int, k: int = 10):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(11, 1)\n    True\n    >>> is_prime(12, 1)\n    False\n    >>> is_prime(12, 3)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n\n        i += w\n        w = 6 - w\n\n    return True\n\n\ndef is_prime_brute(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime_brute(11)\n    True\n    >>> is_prime_brute(12)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\n\ndef prime_factors(n: int):\n    \"\"\"Return the prime factors of n.\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef prime_factors_brute(n: int):\n    \"\"\"Return the prime factors of n.\n    >>> prime_factors_brute(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    factors = []\n    for i in range(",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n in modulo p (be aware of numerics).\n    >>> modp_inverse(3, 5)\n    3\n    >>> modp_inverse(1101, 101)\n    100\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    8\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(n, p-2, p)\n\n\ndef modp_sqrt(n: int, p: int):\n    \"\"\"Return the square root of n in modulo p (be aware of numerics).\n    >>> modp_sqrt(3, 5)\n    3\n    >>> modp_sqrt(1101, 101)\n    100\n    >>> modp_sqrt(0, 101)\n    1\n    >>> modp_sqrt(3, 11)\n    8\n    >>> modp_sqrt(100, 101)\n    1\n    \"\"\"\n    return pow(n, (p+1)//4, p)\n\n\ndef modp_cube_root(n: int, p: int):\n    \"\"\"Return the cube root of n in modulo p (be aware of numerics).\n    >>> modp_cube_root(3, 5)\n    3\n    >>> modp_cube_root(1101, 101)\n    100\n    >>> modp_cube_root(0, 101)\n    1\n    >>> modp_cube_root(3, 11)\n    8\n    >>> modp_cube_root(100, 101)\n    1\n    \"\"\"\n    return pow(n, (p+2)//3, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n / 2, p) ** 2) % p\n    return ((modp(n / 2, p) ** 2) * 3) % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse(2, 11)\n    7\n    >>> modp_inverse(3, 101)\n    8\n    >>> modp_inverse(3, 11)\n    8\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse_naive(2, 11)\n    7\n    >>> modp_inverse_naive(3, 101)\n    8\n    >>> modp_inverse_naive(3, 11)\n    8\n    \"\"\"\n    for i in range(1, p):\n        if (n * i) % p == 1:\n            return i\n\n\ndef main():\n    assert modp(3, 5) == 3\n    assert modp(1101, 101) == 2\n    assert modp(0, 101) == 1\n    assert modp(3, 11) == 8\n    assert modp(100, 101) == 1\n    assert modp_inverse(2, 11) == 7\n    assert modp_inverse(3, 101) == 8\n    assert modp_inverse(3, 11) == 8\n    assert modp_inverse_naive(2, 11) == 7\n    assert modp_inverse_naive(3, 101) == 8\n    assert modp_inverse_naive(3, 11)",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^(-n) modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)",
    "return (2**n) % p\n\n\ndef f_inv(a: int, n: int, p: int):\n    \"\"\"Return a^(-1) modulo p.\n    >>> f_inv(3, 4, 11)\n    9\n    >>> f_inv(2, 6, 11)\n    5\n    >>> f_inv(3, 5, 11)\n    8\n    >>> f_inv(2, 6, 13)\n    7\n    \"\"\"\n    return pow(a, n-2, p)\n\n\ndef f_inv_lst(a: int, p: int):\n    \"\"\"Return a list of a^(-1) modulo p for 1 to p.\n    >>> f_inv_lst(11, 11)\n    [1, 10, 2, 9, 4, 8, 5, 6, 3, 7, 10]\n    >>> f_inv_lst(11, 13)\n    [1, 12, 5, 10, 9, 11, 8, 1, 4, 7, 10, 12]\n    \"\"\"\n    return [pow(a, i-1, p) for i in range(1, p+1)]\n\n\ndef hensel_lift(a: int, n: int, p: int):\n    \"\"\"Return a^(2^n) modulo p.\n    >>> hensel_lift(3, 2, 11)\n    9\n    >>> hensel_lift(2, 3, 11)\n    8\n    >>> hensel_lift(3, 3, 11)\n    2\n    >>> hensel_lift(2, 4, 11)\n    5\n    >>> hensel_lift(3, 4, 11)\n    10\n    >>> hensel_lift(2, 5, 11)\n    10\n    >>> hensel_lift(3, 5, 11)\n    4\n    >>> hensel",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_inv_factorial(n: int, p: int):\n    \"\"\"Return the inverse of n! modulo p.\n    >>> modp_inv_factorial(1, 11)\n    10\n    >>> modp_inv_factorial(2, 11)\n    5\n    >>> modp_inv_factorial(2, 101)\n    26\n    \"\"\"\n    return pow(n, -1, p)\n\n\ndef modp_inv_power(n: int, p: int):\n    \"\"\"Return the inverse of n^k modulo p.\n    >>> modp_inv_power(2, 3)\n    2\n    >>> modp_inv_power(2, 11)\n    4\n    \"\"\"\n    return pow(n, -1, p)\n\n\ndef modp_inv_power_factorial(n: int, p: int):\n    \"\"\"Return the inverse of n^k! modulo p.\n    >>> modp_inv_power_factorial(2, 11)\n    4\n    \"\"\"\n    return pow(n, -1, p)\n\n\ndef modp_inv_power_inv(n: int, p: int):\n    \"\"\"Return the inverse of n^(k! mod p) modulo p.\n    >>> modp_inv_power_inv(2, 11)\n    4\n    \"\"\"\n    return pow(n, -1, p)",
    "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return modp(n / 2, p) * modp(2, p) % p\n    return modp(n - 1, p) * modp(2, p) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(11, 101)\n    10\n    >>> modp_inv(2, 101)\n    7\n    >>> modp_inv(3, 101)\n    9\n    \"\"\"\n    return modp(modp(p - 2, p) * modp(n, p), p)\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return greatest common divisor of a and b.\n    >>> gcd(12, 16)\n    4\n    >>> gcd(12, 15)\n    3\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Return (g, x, y) such that ax + by = g = gcd(a, b).\n    >>> egcd(12, 16)\n    (4, -1, 1)\n    >>> egcd(12, 15)\n    (3, -1, 4)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, y, x = egcd(b % a, a)\n    return (g, x - (b // a) * y, y)\n\n\ndef inv_modp(a: int, p: int):\n    \"\"\"Return inverse of a modulo p.\n    >>> inv_modp(11, 101)\n    10\n    >>> inv_modp(2, 101)\n    7\n    >>> inv_modp(3, 101)\n    9\n    \"\"\"\n    g, x, y = egcd(a,",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modinv(3, 11)\n    8\n    >>> modinv(2, 11)\n    7\n    >>> modinv(3, 101)\n    33\n    >>> modinv(2, 101)\n    78\n    >>> modinv(1, 101)\n    1\n    \"\"\"\n    x, y, u = 1, 0, p\n    while a:\n        q, r = p // a, p % a\n        m, n = x - u * q, y + u * r\n        p, x, y, u = a, m, n, u\n        a = r\n    return x % p\n\n\ndef is_prime(n: int):\n    \"\"\"Check if n is prime.\n    >>> is_prime(11)\n    True\n    >>> is_prime(12)\n    False\n    >>> is_prime(4999899)\n    True\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef factor(n: int):\n    \"\"\"Return a list of prime factors of n.\n    >>> factor(10)\n    [2, 5]\n    >>> factor(7)\n    [7]\n    \"\"\"\n    if n <= 1:\n        return []\n    factors = []\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            factors.append(p)\n            n //= p\n        else:\n            p += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef gcd(a: int, b: int):",
    "if p == 2:\n        return 1 << n\n    else:\n        return (1 << n) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    if p == 2:\n        return 1 << (p - 1 - n)\n    else:\n        return pow(2, n, p)\n\n\ndef modp_inv_pow(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, p - 2 - n, p)\n\n\ndef modp_pow(n: int, e: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_pow(3, 5, 101)\n    3\n    >>> modp_pow(1101, 101, 101)\n    2\n    >>> modp_pow(0, 101, 101)\n    1\n    >>> modp_pow(3, 3, 11)\n    8\n    >>> modp_pow(100, 3, 101)\n    1\n    \"\"\"\n    if e == 0:\n        return 1\n    elif e == 1:\n        return n",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, b: int):\n    \"\"\"Return a^-1 mod b (be aware of numerics).\n    >>> modinv(10, 101)\n    10\n    >>> modinv(11, 101)\n    11\n    >>> modinv(1, 101)\n    1\n    >>> modinv(101, 101)\n    0\n    >>> modinv(2, 101)\n    7\n    \"\"\"\n    return pow(a, b - 2, b)\n\n\ndef get_x(p: int, q: int, e: int, c: int):\n    \"\"\"Return x such that e*x = c mod (p-1)(q-1)\n    >>> get_x(3, 5, 7, 1)\n    2\n    >>> get_x(3, 5, 7, 2)\n    2\n    >>> get_x(3, 5, 7, 3)\n    2\n    >>> get_x(3, 5, 7, 4)\n    2\n    >>> get_x(3, 5, 7, 5)\n    2\n    >>> get_x(3, 5, 7, 6)\n    2\n    >>> get_x(3, 5, 7, 7)\n    2\n    >>> get_x(3, 5, 7, 8)\n    2\n    >>> get_x(3, 5, 7, 9)\n    2\n    >>> get_x(3, 5, 7, 10)\n    2\n    >>> get_x(3, 5, 7, 11)\n    2\n    >>> get_x(3, 5, 7, 12)\n    2\n    >>> get_x(3, 5, 7, 13)\n    2\n    >>> get_x(3, 5, 7, 14)\n    2\n    >>> get_x(3, 5, 7, 15)\n    2",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the modular inverse of a in the ring of integers modulo p.\n    >>> modinv(3, 11)\n    4\n    >>> modinv(3, 101)\n    43\n    \"\"\"\n    b = 1\n    while a*b % p != 1:\n        b += p\n    return b % p\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(4, 6)\n    2\n    >>> gcd(101, 5)\n    1\n    >>> gcd(101, 101)\n    101\n    \"\"\"\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is a prime number, False otherwise.\n    >>> is_prime(101)\n    True\n    >>> is_prime(102)\n    False\n    >>> is_prime(321)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef next_prime(n: int):\n    \"\"\"Return the smallest prime number strictly greater than n.\n    >>> next_prime(10)\n    11\n    >>> next_prime(11)\n    13\n    \"\"\"\n    if n < 2:\n        return 2\n    n += 1\n    while not is_prime(n):\n        n += 1\n    return n\n\n\ndef legendre(a: int, p: int):\n    \"\"\"Return the Legendre symbol (a / p).\n    >>> legendre(2, 5)\n    -1\n    >>> legendre(101, 5)\n    1\n    >>> legendre(2, 3)\n    1\n    \"\"\"\n    return pow(a, (p-1) //",
    "return pow(2, n, p)\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p (be aware of numerics).\n    >>> modp_inv(5, 101)\n    79\n    >>> modp_inv(79, 101)\n    5\n    >>> modp_inv(10, 11)\n    9\n    \"\"\"\n    x, y, g = a, p, 1\n    while y != 0:\n        q = x // y\n        x, y = y, x - q * y\n        g, x = x, g - q * x\n    return (g + p) % p\n\n\ndef modp_inv_naive(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p (be aware of numerics).\n    >>> modp_inv_naive(5, 101)\n    79\n    >>> modp_inv_naive(79, 101)\n    5\n    >>> modp_inv_naive(10, 11)\n    9\n    \"\"\"\n    for i in range(1, p):\n        if a * i % p == 1:\n            return i\n    return None\n\n\ndef modp_inv_extended(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p (be aware of numerics).\n    >>> modp_inv_extended(5, 101)\n    79\n    >>> modp_inv_extended(79, 101)\n    5\n    >>> modp_inv_extended(10, 11)\n    9\n    \"\"\"\n    x, y, g = a, p, 1\n    while y != 0:\n        q = x // y\n        x, y = y, x - q * y\n        g, x = x, g - q * x\n    return (g, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of n in modulo p (be aware of numerics).\n    >>> modp_inverse(10, 101)\n    5\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 0\n    return pow(n, p - 2, p)\n\n\ndef modp_inv_multi(values: list, p: int):\n    \"\"\"Return the multiplicative inverses of a list of values in modulo p (be aware of numerics).\n    >>> modp_inv_multi([10, 100], 101)\n    [5, 1]\n    \"\"\"\n    return [modp_inverse(n, p) for n in values]\n\n\ndef modp_inv_multi_matrix(matrix: list, p: int):\n    \"\"\"Return the multiplicative inverses of a matrix in modulo p (be aware of numerics).\n    >>> modp_inv_multi_matrix([[10, 100], [1000, 1001]], 101)\n    [[5, 1], [5, 1]]\n    \"\"\"\n    return [modp_inv_multi(row, p) for row in matrix]\n\n\ndef modp_multi(values: list, p: int):\n    \"\"\"Return the multiples of a list of values in modulo p (be aware of numerics).\n    >>> modp_multi([10, 100], 101)\n    [10, 1]\n    \"\"\"\n    return [n * v for n, v in enumerate(values, start=1)]\n\n\ndef modp_multi_matrix(matrix: list, p: int):\n    \"\"\"Return the multiples of a matrix in modulo p (be aware of numerics).\n    >>> modp_multi_matrix([[10, 100], [1000, 1001]], 101)",
    "return (2 ** n) % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(11, 101)\n    10\n    >>> modp_inverse(10, 101)\n    10\n    >>> modp_inverse(2, 101)\n    7\n    >>> modp_inverse(111, 101)\n    10\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inverse_crt(a: int, m: int, p: int):\n    \"\"\"Return the inverse of a modulo p (using the Chinese Remainder Theorem).\n    >>> modp_inverse_crt(11, 101, 101)\n    10\n    >>> modp_inverse_crt(10, 101, 101)\n    10\n    >>> modp_inverse_crt(2, 101, 101)\n    7\n    >>> modp_inverse_crt(111, 101, 101)\n    10\n    \"\"\"\n    return pow(a, modp_inverse(m, p), p)\n\n\ndef modp_crt(a: int, b: int, p: int, q: int):\n    \"\"\"Return the modular CRT of a and b.\n    >>> modp_crt(10, 11, 101, 101)\n    11\n    >>> modp_crt(10, 11, 101, 101)\n    11\n    >>> modp_crt(2, 3, 101, 101)\n    5\n    >>> modp_crt(111, 122, 101, 101)\n    122\n    \"\"\"\n    return (a * modp_inverse_crt(b, p, p) * modp_inverse_",
    "return (2 ** n) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    7\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_sqr(n: int, p: int):\n    \"\"\"Return 2^(2*n) modulo p (be aware of numerics).\n    >>> modp_sqr(3, 5)\n    3\n    >>> modp_sqr(1101, 101)\n    2\n    >>> modp_sqr(0, 101)\n    1\n    >>> modp_sqr(3, 11)\n    8\n    >>> modp_sqr(100, 101)\n    1\n    \"\"\"\n    return pow(2, 2 * n, p)\n\n\ndef modp_mul(n: int, m: int, p: int):\n    \"\"\"Return 2^(n*m) modulo p (be aware of numerics).\n    >>> modp_mul(3, 5, 11)\n    8\n    >>> modp_mul(3, 3, 11)\n    5\n    >>> modp_mul(3, 3, 11)\n    5\n    >>> modp_mul(2, 3, 11)\n    4\n    \"\"\"\n    return pow(2, n * m, p)\n\n\ndef modp_div(n: int, d: int, p: int):\n    \"\"\"Return 2^(n/d) modulo p (be aware of numerics).\n    >>> modp_div(3, 5, 11)\n    8\n    >>> modp",
    "return pow(2, n, p)\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return inverse of a in (Z/pZ)*.\n    >>> modp_inv(11, 101)\n    90\n    >>> modp_inv(3, 11)\n    7\n    >>> modp_inv(2, 11)\n    9\n    \"\"\"\n    return pow(a, p-2, p)\n\n\ndef modp_log(a: int, p: int):\n    \"\"\"Return log_2(a) in (Z/pZ).\n    >>> modp_log(11, 101)\n    3\n    >>> modp_log(3, 11)\n    1\n    >>> modp_log(2, 11)\n    0\n    \"\"\"\n    return pow(2, p-2, p) * a % p\n\n\ndef modp_pow(a: int, n: int, p: int):\n    \"\"\"Return a^n in (Z/pZ).\n    >>> modp_pow(11, 3, 101)\n    90\n    >>> modp_pow(3, 11, 101)\n    8\n    \"\"\"\n    return pow(a, n, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a / b in (Z/pZ).\n    >>> modp_div(11, 3, 101)\n    9\n    >>> modp_div(3, 11, 101)\n    7\n    \"\"\"\n    return pow(a, p-2, p) * b % p\n\n\ndef modp_sqrt(a: int, p: int):\n    \"\"\"Return sqrt(a) in (Z/pZ).\n    >>> modp_sqrt(11, 101)\n    3\n    >>> modp_sqrt(3, 11)\n    2\n    \"\"\"\n    return pow(a, (p+1)//4, p)\n\n\ndef modp_crt(x",
    "return 2 ** n % p\n\n\ndef main():\n    \"\"\"Main function\"\"\"\n    p = 101\n    a = 76\n    b = 97\n    m = 101\n    print(f\"a = {a}, b = {b}, m = {m}\")\n    x = 1\n    y = 0\n    print(f\"x = {x}, y = {y}\")\n    for i in range(1, 101):\n        print(f\"i = {i}\")\n        x = (x * a + y) % m\n        y = (y * b) % m\n        print(f\"x = {x}, y = {y}\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n < 0:\n        return -modp(-n, p)\n    elif n == 0:\n        return 1\n    elif n == 1:\n        return 0\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return (modp(n // 2, p) ** 2 % p) * p + modp(n % 2, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(3, 11)\n    4\n    >>> modp_inverse(7, 11)\n    8\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"0 has no inverse modulo p\")\n    return modp(p + n, p)\n\n\ndef modp_sqrt(a: int, p: int):\n    \"\"\"Return the square root of a modulo p.\n    >>> modp_sqrt(3, 11)\n    2\n    >>> modp_sqrt(5, 11)\n    4\n    \"\"\"\n    if modp(a, p) != a:\n        raise ValueError(\"{} is not a quadratic residue modulo {}\".format(a, p))\n    if p % 4 == 3:\n        return pow(a, (p + 1) // 4, p)\n    s = p - 1\n    e = 0\n    while s % 2 == 0:\n        s //= 2\n        e += 1\n    n = 2\n    while modp(n * n, p) != a:\n        n += 1\n    r = e\n    t = ((p + 1) // 4) % 8\n    if t == 5:\n        n = modp_inverse(n, p)\n    elif t == 7:\n        n = modp_inverse(n, p)\n        n = -n % p\n\n    while True:\n        t = r\n        r = (r * n) % p\n        n = (",
    "# Compute 2^n modulo p.\n    # Use binary exponentiation.\n    # See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    result = 1\n    base = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n    return result\n\n\ndef modinv(n: int, p: int):\n    \"\"\"Return the modular inverse of n in Z_p.\n    >>> modinv(2, 5)\n    3\n    >>> modinv(101, 101)\n    1\n    \"\"\"\n    # Use extended Euclidean algorithm.\n    # See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    x, y = 0, 1\n    a, b = p, n\n    while a != 0:\n        q, r = b // a, b % a\n        m, n = x - q * y, y\n        x, y = m, n\n        b, a = a, r\n    return x % p\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is a prime number.\n    >>> is_prime(2)\n    True\n    >>> is_prime(17)\n    True\n    >>> is_prime(101)\n    True\n    >>> is_prime(100)\n    False\n    >>> is_prime(102)\n    False\n    \"\"\"\n    # Test the primality by trial division.\n    # See https://en.wikipedia.org/wiki/Trial_division\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef pollard_rho(n: int):\n    \"\"\"Return a random factor of n.\n    >>> pollard_rho(2017)\n    17\n    \"\"\"\n    # Pollard rho algorithm.\n    # See https://en.wikipedia.org/wiki/Poll",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    9\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    100\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inv_2(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    9\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    100\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inv_3(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    9\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    6\n    >>> modp_inv(100, 101)\n    100\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_inv_4(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    9\n    >>> modp_inv(0, 101",
    "return pow(2, n, p)\n\n\ndef modinv(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modinv(3, 11)\n    8\n    >>> modinv(2, 11)\n    7\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    return pow(n, p-2, p)\n\n\ndef modsqrt(n: int, p: int):\n    \"\"\"Return the square root of n modulo p.\n    >>> modsqrt(2, 5)\n    2\n    >>> modsqrt(3, 5)\n    4\n    >>> modsqrt(8, 9)\n    2\n    >>> modsqrt(8, 11)\n    7\n    >>> modsqrt(0, 11)\n    0\n    >>> modsqrt(3, 11)\n    4\n    >>> modsqrt(1, 101)\n    1\n    \"\"\"\n    if p % 4 == 3:\n        root = pow(n, (p+1)//4, p)\n        assert pow(root, 2, p) == n\n        return root\n    elif p % 8 == 5:\n        d = pow(n, (p-5)//8, p)\n        assert pow(d, 2, p) == n\n        e = modinv(2, p)\n        assert pow(d*e, 2, p) == 1\n        assert pow(d, 4, p) == 1\n        return d*e\n    else:\n        return NotImplemented\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Extended GCD algorithm.\n    >>> egcd(2, 3)\n    (1, -1, 1)\n    >>> egcd(11, 42)\n    (42, -3, 1)\n    >>> egcd(3, 7)\n    (1, -2, 3)\n    >>> egcd(7, 3)\n    (3, -2, 1)\n    \"\"\"\n    if a == 0:",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    4\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_inv_root(n: int, p: int):\n    \"\"\"Return the inverse square root of 2^n modulo p.\n    >>> modp_inv_root(3, 5)\n    3\n    >>> modp_inv_root(1101, 101)\n    4\n    >>> modp_inv_root(0, 101)\n    1\n    >>> modp_inv_root(3, 11)\n    8\n    >>> modp_inv_root(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n // 2, p)",
    "return (2**n % p) % p\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return the inverse of a in the multiplicative group of the integers modulo p.\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    10\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(a, p-2, p)\n\n\ndef extended_gcd(a: int, b: int):\n    \"\"\"Return a tuple (r, i, j) such that r = gcd(a, b) = ia + jb\n    >>> extended_gcd(3, 5)\n    (1, -1, 2)\n    >>> extended_gcd(1101, 101)\n    (1, -100, 110)\n    >>> extended_gcd(3, 11)\n    (1, -8, 5)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, y, x = extended_gcd(b % a, a)\n    return g, x - (b // a) * y, y\n\n\ndef modinv(a: int, m: int):\n    \"\"\"Return the modular inverse of a in the integers modulo m.\n    >>> modinv(3, 11)\n    8\n    >>> modinv(1101, 101)\n    100\n    \"\"\"\n    g, x, _ = extended_gcd(a, m)\n    if g != 1:\n        raise Exception('gcd(a, m) != 1')\n    return x % m\n\n\ndef crt(a: int, m: int, b: int, n: int):\n    \"\"\"Return the solution, x, to the system of congruences:\n    ax \u2261 b (",
    "if p == 2:\n        return n % 2\n    else:\n        return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return 2**n % p\n\n\ndef modp_mul(a: int, b: int, p: int):\n    \"\"\"Return a * b modulo p (be aware of numerics).\n    >>> modp_mul(3, 5, 10)\n    8\n    >>> modp_mul(1101, 101, 101)\n    100\n    >>> modp_mul(0, 101, 101)\n    1\n    >>> modp_mul(3, 11, 101)\n    8\n    >>> modp_mul(100, 101, 101)\n    1\n    \"\"\"\n    return (a * b) % p\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return a^-1 modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef modp_mul_inv(a: int, b: int, p: int):\n    \"\"\"Return a * b^-1 modulo p (be aware of numerics).\n    >>> modp_mul_inv(3, 5, 10)\n    8\n    >>> modp_mul_inv(1101, 101, 101)\n    100\n    >>> modp_mul_inv(0, 101, 101)\n    1\n    >>> modp_mul_inv(3, 11, 101)\n    8\n    >>> modp_mul_inv(100, 101, 101)\n    1\n    \"\"\"\n    return (a * pow(b, p - 2, p))",
    "# 2^n modulo p\n    return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    # 2^-n modulo p\n    return pow(2, -n, p)\n\n\ndef modp_add(n: int, m: int, p: int):\n    \"\"\"Return n + m modulo p (be aware of numerics).\n    >>> modp_add(3, 5, 10)\n    8\n    >>> modp_add(1101, 101, 101)\n    101\n    >>> modp_add(0, 101, 101)\n    1\n    >>> modp_add(3, 11, 11)\n    9\n    >>> modp_add(100, 101, 101)\n    101\n    \"\"\"\n    return (n + m) % p\n\n\ndef modp_sub(n: int, m: int, p: int):\n    \"\"\"Return n - m modulo p (be aware of numerics).\n    >>> modp_sub(3, 5, 10)\n    2\n    >>> modp_sub(1101, 101, 101)\n    100\n    >>> modp_sub(0, 101, 101)\n    100\n    >>> modp_sub(3, 11, 11)\n    2\n    >>> modp_sub(100, 101, 101)\n    100\n    \"\"\"\n    return (n -",
    "return (2 ** n) % p\n\n\ndef modp_mul(a: int, b: int, p: int):\n    \"\"\"Return a * b modulo p (be aware of numerics).\n    >>> modp_mul(3, 2, 5)\n    3\n    >>> modp_mul(1101, 1100, 101)\n    1\n    \"\"\"\n    return (a * b) % p\n\n\ndef modp_sqr(a: int, p: int):\n    \"\"\"Return a^2 modulo p (be aware of numerics).\n    >>> modp_sqr(3, 5)\n    9\n    >>> modp_sqr(1101, 101)\n    1\n    \"\"\"\n    return (a * a) % p\n\n\ndef modp_mul_inv(a: int, p: int):\n    \"\"\"Return a^-1 modulo p (be aware of numerics).\n    >>> modp_mul_inv(3, 5)\n    3\n    >>> modp_mul_inv(1101, 101)\n    100\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a / b modulo p (be aware of numerics).\n    >>> modp_div(3, 2, 5)\n    3\n    >>> modp_div(1101, 1100, 101)\n    1\n    \"\"\"\n    return (a * modp_mul_inv(b, p)) % p\n\n\ndef modp_gcd(a: int, b: int, p: int):\n    \"\"\"Return the GCD of a and b modulo p (be aware of numerics).\n    >>> modp_gcd(3, 5, 11)\n    1\n    >>> modp_gcd(2, 4, 11)\n    2\n    \"\"\"\n    while a != 0:\n        a, b = b % a, a\n    return (b - p) % p",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, n: int):\n    \"\"\"Return the inverse of a modulo n.\n    >>> modinv(7, 101)\n    53\n    >>> modinv(54, 101)\n    100\n    >>> modinv(2, 101)\n    41\n    \"\"\"\n    a %= n\n    for x in range(1, n):\n        if (a * x) % n == 1:\n            return x\n    return -1\n\n\ndef modmulinv(a: int, b: int, n: int):\n    \"\"\"Return the inverse of a * b modulo n.\n    >>> modmulinv(2, 3, 101)\n    53\n    >>> modmulinv(2, 54, 101)\n    100\n    >>> modmulinv(2, 2, 101)\n    41\n    \"\"\"\n    return pow(a * b, -1, n)\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(2)\n    True\n    >>> is_prime(1)\n    False\n    >>> is_prime(89)\n    True\n    >>> is_prime(71)\n    True\n    >>> is_prime(75)\n    False\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_factors(n: int):\n    \"\"\"Return the prime factors of n.\n    >>> prime_factors(10)\n    [2, 5]\n    >>> prime_factors(12)\n    [2, 2, 3]\n    >>> prime_factors(32)\n    [2, 2, 2, 2, 2]\n    \"\"\"\n    factors = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return 2^(-n) modulo p (be aware of numerics).\n    >>> modp_inverse(3, 5)\n    3\n    >>> modp_inverse(1101, 101)\n    2\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    8\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_inverse_naive(n: int, p: int):\n    \"\"\"Return 2^(-n) modulo p (be aware of numerics).\n    >>> modp_inverse_naive(3, 5)\n    3\n    >>> modp_inverse_naive(1101, 101)\n    2\n    >>> modp_inverse_naive(0, 101)\n    1\n    >>> modp_inverse_naive(3, 11)\n    8\n    >>> modp_inverse_naive(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_inverse_extended_euclidean(n: int, p: int):\n    \"\"\"Return 2^(-n) modulo p (be aware of numerics).\n    >>> modp_inverse_extended_euclidean(3, 5)\n    3\n    >>> modp_inverse_extended_euclidean(1101, 101)\n    2\n    >>> modp_inverse_extended_euclidean(0, 101)\n    1\n    >>> modp_inverse_extended_euclidean(3, 11)\n    8\n    >>> modp_inverse_extended_euclidean(100, 101)\n    1\n    \"\"\"\n    if n == 0:",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 11)\n    8\n    >>> modp_inverse(1101, 101)\n    51\n    >>> modp_inverse(0, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_sqrt(n: int, p: int):\n    \"\"\"Return the square root of n modulo p.\n    >>> modp_sqrt(1, 11)\n    1\n    >>> modp_sqrt(2, 11)\n    10\n    >>> modp_sqrt(3, 11)\n    >>> modp_sqrt(4, 11)\n    5\n    >>> modp_sqrt(5, 11)\n    10\n    >>> modp_sqrt(6, 11)\n    5\n    >>> modp_sqrt(7, 11)\n    >>> modp_sqrt(8, 11)\n    1\n    >>> modp_sqrt(9, 11)\n    4\n    >>> modp_sqrt(10, 11)\n    10\n    >>> modp_sqrt(11, 11)\n    1\n    \"\"\"\n    if n == 0:\n        return 0\n    assert (p - 1) % 4 in (1, 3)\n    q = (p - 1) // 4\n    s = 1\n    while s % 2 == 0:\n        s = n % (p - 1)\n        n = n % p\n        while s % 2 == 0:\n            s = s // 2\n            q = 2 * q + 1\n    m = p - 1\n    c = pow(n, q, p)\n    while c != 1:\n        e = m // 2\n        while c != 1:\n            c = pow(c, 2, p)\n            e = e - 1",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    2\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    10\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_sqrt(n: int, p: int):\n    \"\"\"Return square root of n modulo p.\n    >>> modp_sqrt(3, 5)\n    2\n    >>> modp_sqrt(1101, 101)\n    100\n    >>> modp_sqrt(0, 101)\n    1\n    >>> modp_sqrt(3, 11)\n    4\n    >>> modp_sqrt(100, 101)\n    1\n    \"\"\"\n    return pow(n, (p + 1) // 4, p)\n\n\ndef modp_inv_sqrt(n: int, p: int):\n    \"\"\"Return inverse square root of n modulo p.\n    >>> modp_inv_sqrt(3, 5)\n    3\n    >>> modp_inv_sqrt(1101, 101)\n    100\n    >>> modp_inv_sqrt(0, 101)\n    1\n    >>> modp_inv_sqrt(3, 11)\n    5\n    >>> modp_inv_sqrt(100, 101)\n    1\n    \"\"\"\n    return pow(n, (p - 1) // 4, p)",
    "return (2**n) % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the multiplicative inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    4\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    7\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -n, p)\n\n\ndef modp_pow(n: int, e: int, p: int):\n    \"\"\"Return 2^e modulo p (be aware of numerics).\n    >>> modp_pow(3, 3, 5)\n    3\n    >>> modp_pow(1101, 1101, 101)\n    2\n    >>> modp_pow(0, 0, 101)\n    1\n    >>> modp_pow(3, 11, 11)\n    8\n    >>> modp_pow(100, 100, 101)\n    1\n    \"\"\"\n    return pow(2, e, p)\n\n\ndef modp_pow_inv(n: int, e: int, p: int):\n    \"\"\"Return the multiplicative inverse of 2^e modulo p (be aware of numerics).\n    >>> modp_pow_inv(3, 3, 5)\n    3\n    >>> modp_pow_inv(1101, 1101, 101)\n    4\n    >>> modp_pow_inv(0, 0, 101)\n    1\n    >>> modp_pow_inv(3, 11, 11)\n    7\n    >>> modp_pow_inv(100, 100, 101)\n    1\n    \"\"\"\n    return pow(2, -e, p)\n\n\ndef",
    "return pow(2, n, p)\n\n\ndef modp_inv(a: int, p: int):\n    \"\"\"Return the multiplicative inverse of a modulo p.\n    >>> modp_inv(7, 101)\n    69\n    >>> modp_inv(10, 101)\n    31\n    >>> modp_inv(1, 101)\n    1\n    >>> modp_inv(99, 101)\n    1\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef modp_pow(a: int, n: int, p: int):\n    \"\"\"Return a^n modulo p (be aware of numerics).\n    >>> modp_pow(2, 3, 5)\n    3\n    >>> modp_pow(10, 100, 101)\n    1\n    \"\"\"\n    return pow(a, n, p)",
    "return (pow(2, n, p) + 1) % p\n\n\ndef main():\n    from doctest import testmod\n    testmod()\n    print(\"Example:\")\n    print(modp(3, 5))\n\n\nif __name__ == \"__main__\":\n    main()",
    "if p == 2:\n        return 1\n    res = 1\n    for _ in range(n):\n        res = res * 2 % p\n    return res\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^-1 modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return modp(p - 2, p)\n\n\ndef modp_pow(n: int, e: int, p: int):\n    \"\"\"Return 2^e modulo p (be aware of numerics).\n    >>> modp_pow(3, 3, 5)\n    3\n    >>> modp_pow(1101, 1101, 101)\n    1\n    >>> modp_pow(0, 0, 101)\n    1\n    >>> modp_pow(3, 11, 11)\n    8\n    >>> modp_pow(100, 100, 101)\n    1\n    \"\"\"\n    if e == 0:\n        return 1\n    res = modp(n, p)\n    for _ in range(e - 1):\n        res = res * n % p\n    return res\n\n\ndef modp_pow_inv(n: int, e: int, p: int):\n    \"\"\"Return 2^-e modulo p (be aware of numerics).\n    >>> modp_pow_inv(3, 3, 5)\n    3\n    >>> modp_pow_inv(1101, 1101, 101)\n    1\n    >>> modp_pow_inv(0, 0, 101)\n    1\n    >>> modp_pow_inv(",
    "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    return (modp(n // 2, p) ** 2 * 3) % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(3, 5)\n    2\n    >>> modp_inverse(1101, 101)\n    10\n    >>> modp_inverse(0, 101)\n    1\n    >>> modp_inverse(3, 11)\n    7\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(n, p - 2, p)",
    "return pow(2, n, p)\n\n\ndef modp_inverse(a: int, p: int):\n    \"\"\"Return a^-1 modulo p.\n    >>> modp_inverse(3, 11)\n    9\n    >>> modp_inverse(10, 101)\n    67\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(a, p - 2, p)\n\n\ndef modp_div(a: int, b: int, p: int):\n    \"\"\"Return a * b^-1 modulo p.\n    >>> modp_div(3, 10, 11)\n    9\n    >>> modp_div(10, 100, 101)\n    67\n    >>> modp_div(100, 100, 101)\n    1\n    \"\"\"\n    return (a * modp_inverse(b, p)) % p\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Compute the greatest common divisor of a and b.\n    >>> gcd(121, 11)\n    11\n    >>> gcd(122, 11)\n    11\n    >>> gcd(121, 122)\n    1\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\ndef lcm(a: int, b: int):\n    \"\"\"Compute the lowest common multiple of a and b.\n    >>> lcm(12, 15)\n    60\n    >>> lcm(12, 12)\n    12\n    \"\"\"\n    return a * b // gcd(a, b)\n\n\ndef primitive_root(p: int):\n    \"\"\"Return a primitive root of p.\n    >>> primitive_root(11)\n    2\n    >>> primitive_root(101)\n    47\n    \"\"\"\n    # https://stackoverflow.com/questions/44247269/finding-primitive-root-of-",
    "return pow(2, n, p)\n\n\ndef modp_bin(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_bin(3, 5)\n    3\n    >>> modp_bin(1101, 101)\n    2\n    >>> modp_bin(0, 101)\n    1\n    >>> modp_bin(3, 11)\n    8\n    >>> modp_bin(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)\n\n\ndef modp_bin_slow(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_bin_slow(3, 5)\n    3\n    >>> modp_bin_slow(1101, 101)\n    2\n    >>> modp_bin_slow(0, 101)\n    1\n    >>> modp_bin_slow(3, 11)\n    8\n    >>> modp_bin_slow(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)\n\n\ndef modp_bin_naive(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_bin_naive(3, 5)\n    3\n    >>> modp_bin_naive(1101, 101)\n    2\n    >>> modp_bin_naive(0, 101)\n    1\n    >>> modp_bin_naive(3, 11)\n    8\n    >>> modp_bin_naive(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)\n\n\ndef modp_naive(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_naive(3, 5",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return inverse of a modulo p.\n    >>> modinv(3, 11)\n    4\n    >>> modinv(2, 11)\n    9\n    \"\"\"\n    return pow(a, p - 2, p)",
    "if n == 0:\n        return 1\n    x = modp(n // 2, p)\n    x = (x * x) % p\n    if n % 2:\n        x = (x * 2) % p\n    return x\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return n^{-1} modulo p (be aware of numerics).\n    >>> modp_inverse(101, 101)\n    1\n    >>> modp_inverse(2, 11)\n    5\n    >>> modp_inverse(5, 11)\n    7\n    \"\"\"\n    if n == 0:\n        raise ValueError('0 has no inverse modulo p')\n    if p == 1:\n        return 0\n    x = modp_inverse(p, n)\n    x = (x + n) % p\n    return x\n\n\ndef modp_crt(a: int, b: int, p: int, q: int):\n    \"\"\"Return crt(a mod p, b mod q) mod pq.\n    >>> modp_crt(2, 3, 11, 13)\n    14\n    >>> modp_crt(100, 101, 101, 107)\n    108\n    \"\"\"\n    assert p != q\n    assert a < p and b < q\n    assert a % p == a and b % q == b\n    assert a % q != b % q\n    return (a * modp_inverse(q, p) * q + b * modp_inverse(p, q) * p) % (p * q)\n\n\ndef modp_crt_list(a_list, p_list, q_list):\n    \"\"\"Return crt(a mod p, b mod q) mod pq.\n    >>> modp_crt_list([2, 100], [11, 101], [101, 107])\n    108\n    \"\"\"\n    assert len(a_list) == len(p_list)",
    "return 2 ** n % p\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return greatest common divisor of a and b.\n    >>> gcd(4, 16)\n    4\n    >>> gcd(101, 11)\n    1\n    >>> gcd(11, 101)\n    1\n    >>> gcd(123, 456)\n    1\n    \"\"\"\n    while a != 0:\n        a, b = b % a, a\n    return b\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Return x, y and gcd of a and b.\n    >>> egcd(101, 11)\n    (1, -1, 1)\n    >>> egcd(11, 101)\n    (-1, 1, 1)\n    >>> egcd(123, 456)\n    (-1, 1, 1)\n    \"\"\"\n    if a == 0:\n        return (0, 1, b)\n    else:\n        x, y, gcd = egcd(b % a, a)\n        return (y - (b // a) * x, x, gcd)\n\n\ndef inverse(a: int, m: int):\n    \"\"\"Return inverse of a modulo m.\n    >>> inverse(7, 4)\n    3\n    >>> inverse(11, 101)\n    10\n    \"\"\"\n    a %= m\n    gcd, x, _ = egcd(a, m)\n    if gcd != 1:\n        raise ValueError(f\"{a} has no inverse in {m}\")\n    else:\n        return x % m\n\n\ndef crt(a: int, n: int, b: int, m: int):\n    \"\"\"Return solution to system of congruences ax \u2261 b modulo n, by cm b \u2261 c modulo m.\n    >>> crt(2, 3, 1, 5)\n    3\n    >>> crt(11, 13, 1, 101)\n    10",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inverse(1, 101)\n    1\n    >>> modp_inverse(3, 11)\n    8\n    >>> modp_inverse(3, 5)\n    3\n    >>> modp_inverse(3, 101)\n    100\n    >>> modp_inverse(100, 101)\n    1\n    \"\"\"\n    return pow(modp(n, p), p - 2, p)\n\n\ndef modp_inverse_binary(n: int, p: int):\n    \"\"\"Return the inverse of 2^n modulo p (be aware of numerics).\n    >>> modp_inverse_binary(1, 101)\n    1\n    >>> modp_inverse_binary(3, 11)\n    8\n    >>> modp_inverse_binary(3, 5)\n    3\n    >>> modp_inverse_binary(3, 101)\n    100\n    >>> modp_inverse_binary(100, 101)\n    1\n    \"\"\"\n    return pow(modp(n, p), p - 2, p)",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return 2 ** n % p\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inverse(2, 3)\n    1\n    >>> modp_inverse(3, 11)\n    4\n    \"\"\"\n    if n == 0:\n        return 0\n    result, t = pow(n, p - 2, p), p\n    while result * n != 1:\n        result, t = (result * result) % p, t * 2\n    return result\n\n\ndef modp_extended_gcd(a: int, b: int):\n    \"\"\"Return a triple (g, s, t) such that g = gcd(a, b) = sa + tb.\n    >>> modp_extended_gcd(3, 5)\n    (1, -1, 1)\n    \"\"\"\n    s, old_s = 0, 1\n    t, old_t = 1, 0\n    r, old_r = b, a\n    while r != 0:\n        quotient = old_r // r\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n    return old_r, old_s, old_t\n\n\ndef modp_chinese_remainder(a: list, m: list):\n    \"\"\"Return x such that x = a[i] (mod m[i]).\n    >>> modp_chinese_remainder([2, 3, 4], [3, 4, 5])\n    14\n    \"\"\"\n    product = 1\n    for i in m:\n        product *= i\n    sum = 0\n    for i in range(len(m)):\n        b = product // m[i]\n        inv, _, _ = modp_extended_gcd(b, m[i])\n        sum += a[i] * b * inv\n    return sum % product\n\n\ndef",
    "return 2 ** n % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^(-n) modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    12\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return modp(p - 2 * n, p)\n\n\ndef modp_mul(n: int, m: int, p: int):\n    \"\"\"Return (2^n * 2^m) modulo p (be aware of numerics).\n    >>> modp_mul(3, 11, 101)\n    10\n    >>> modp_mul(100, 11, 101)\n    1\n    \"\"\"\n    return (2 ** n * 2 ** m) % p\n\n\ndef modp_div(n: int, m: int, p: int):\n    \"\"\"Return (2^n / 2^m) modulo p (be aware of numerics).\n    >>> modp_div(3, 11, 101)\n    1\n    >>> modp_div(100, 11, 101)\n    1\n    \"\"\"\n    return modp(n - m, p)\n\n\ndef modp_add(n: int, m: int, p: int):\n    \"\"\"Return (2^n + 2^m) modulo p (be aware of numerics).\n    >>> modp_add(3, 11, 101)\n    10\n    >>> modp_add(100, 11, 101)\n    1\n    \"\"\"\n    return (2 ** n + 2 ** m) % p\n\n\ndef modp_sub(n: int, m: int, p: int):\n    \"\"\"Return (2^n -",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "assert n >= 0, \"modp only works for n >= 0\"\n    assert p >= 2, \"modp only works for p >= 2\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n == 2:\n        return 2 * p\n    if n == 3:\n        return p + 2\n    return modp(n - 1, p) * 2 % p\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inv(3, 5)\n    2\n    >>> modp_inv(1101, 101)\n    100\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    9\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    assert n >= 0, \"modp_inv only works for n >= 0\"\n    assert p >= 2, \"modp_inv only works for p >= 2\"\n    return modp(pow(n, p - 2, p), p)\n\n\ndef modp_inv_ext(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p.\n    >>> modp_inv_ext(3, 5)\n    2\n    >>> modp_inv_ext(1101, 101)\n    100\n    >>> modp_inv_ext(0, 101)\n    1\n    >>> modp_inv_ext(3, 11)\n    9\n    >>> modp_inv_ext(100, 101)\n    1\n    \"\"\"\n    assert n >= 0, \"modp_inv only works for n >= 0\"\n    assert p >= 2, \"modp_inv only works for p >= 2\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n == 2:",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return modular inverse of a in modulo p.\n    >>> modinv(11, 101)\n    81\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    inv, _, _ = extended_gcd(a, p)\n    return inv\n\n\ndef extended_gcd(a: int, b: int):\n    \"\"\"Return triple (g, x, y) such that ax + by = g = gcd(a, b)\n    >>> extended_gcd(11, 101)\n    (1, -81, 1)\n    >>> extended_gcd(100, 101)\n    (1, 1, 0)\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    g, x, y = extended_gcd(b % a, a)\n    return g, y - (b // a) * x, x\n\n\ndef get_primitive_root(p: int):\n    \"\"\"Return a random primitive root of a prime number p (be aware of numerics).\n    >>> get_primitive_root(101)\n    10\n    >>> get_primitive_root(101)\n    97\n    \"\"\"\n    if p == 2:\n        return 1\n    if p == 157:\n        return 127\n    if p == 193:\n        return 19\n    if p == 223:\n        return 109\n    if p == 251:\n        return 117\n    if p == 277:\n        return 169\n    if p == 289:\n        return 179\n    if p == 307:\n        return 139\n    if p == 331:\n        return 127\n    if p == 367:\n        return 179\n    if p == 379:\n        return 199",
    "return pow(2, n, p)\n\n\ndef modp_inverse(n: int, p: int):\n    \"\"\"Return the inverse of n modulo p (be aware of numerics).\n    >>> modp_inverse(10, 11)\n    7\n    >>> modp_inverse(10, 101)\n    10\n    >>> modp_inverse(3, 11)\n    4\n    >>> modp_inverse(3, 101)\n    7\n    \"\"\"\n    return pow(n, p - 2, p)\n\n\ndef modp_sqrt(a: int, p: int):\n    \"\"\"Return the square root of a modulo p (be aware of numerics).\n    >>> modp_sqrt(4, 11)\n    2\n    >>> modp_sqrt(100, 101)\n    1\n    >>> modp_sqrt(3, 11)\n    1\n    >>> modp_sqrt(3, 101)\n    3\n    \"\"\"\n    if a == 0:\n        return 0\n    if p == 2:\n        return a\n    if p % 4 == 3:\n        return pow(a, (p + 1) // 4, p)\n    s = p - 1\n    e = 0\n    while s % 2 == 0:\n        s //= 2\n        e += 1\n    n = 2\n    while modp(n * n - a, p) != -1:\n        n += 1\n    r = modp(n * n - a, p)\n    m = modp(s, p)\n    for i in range(1, e):\n        if (s & 1) == 1:\n            m = (m * r) % p\n        r = (r * r) % p\n        s //= 2\n    return (m * r) % p\n\n\ndef modp_pow(a: int, b: int, p: int):\n    \"\"\"Return a^b modulo p (be aware of numerics).\n    >>> modp_pow(10,",
    "if p == 2:\n        return n % p\n    return pow(2, n, p)\n\n\ndef modinv(a: int, p: int) -> int:\n    \"\"\"Return the modular inverse of a modulo p.\n    >>> modinv(3, 11)\n    4\n    >>> modinv(3, 101)\n    43\n    >>> modinv(3, 201)\n    127\n    \"\"\"\n    x, y, u, v = 1, 0, 0, 1\n    while a:\n        q, r = p // a, p % a\n        m, n = x - u * q, y - v * q\n        p, x, y, u, v = a, u, v, m, n\n        a = r\n    return x % p\n\n\ndef modsqrt(a: int, p: int) -> int:\n    \"\"\"Return the square root of a modulo p if it exists, otherwise return None.\n    >>> modsqrt(3, 11)\n    2\n    >>> modsqrt(8, 11)\n    >>> modsqrt(8, 101)\n    5\n    \"\"\"\n    if legendre_symbol(a, p) != 1:\n        return None\n    if a == 0:\n        return 0\n    if p == 2:\n        return a % 2\n    if p % 4 == 3:\n        return pow(a, (p + 1) // 4, p)\n    s = p - 1\n    e = 0\n    while s % 2 == 0:\n        s //= 2\n        e += 1\n    n = 2\n    while legendre_symbol(n, p) != -1:\n        n += 1\n    x = pow(a, (s + 1) // 2, p)\n    b = pow(a, s, p)\n    g = pow(n, s, p)\n    r = e\n    while True:\n        t = b\n        m = 0\n        for m in range(r):\n            if t == 1:\n                break",
    "return pow(2, n, p)\n\n\ndef modp_bin(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_bin(3, 5)\n    3\n    >>> modp_bin(1101, 101)\n    2\n    >>> modp_bin(0, 101)\n    1\n    >>> modp_bin(3, 11)\n    8\n    >>> modp_bin(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(100)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, n, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef prime_factors(n: int):\n    \"\"\"Return a list of the prime factors of n, in ascending order.\n    >>> prime_factors(8)\n    [2, 2, 2]\n    >>> prime_factors(101)\n    [101]\n    >>> prime_factors(12)\n    [2, 2, 3]\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    result = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            result.append(i)\n        i += 1\n    if n > 1:\n        result.append(n)\n    return result\n\n\ndef prime_factors_mult(n: int):\n    \"\"\"",
    "if p == 2:\n        return 1 << n\n    x = 2**n\n    while x >= p:\n        x -= p\n    return x\n\n\ndef is_prime(n: int, k: int = 128):\n    \"\"\"Return True if n is a prime number.\n    >>> is_prime(101)\n    True\n    >>> is_prime(102)\n    False\n    >>> is_prime(101, 1)\n    True\n    \"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    s = 6n + 1\n    r = n - 1\n    t = 0\n    while r % 2 == 0:\n        t += 1\n        r //= 2\n    for i in range(k):\n        a = randint(2, n - 2)\n        x = modp(a, n)\n        y = modp(s, n)\n        for j in range(r):\n            y = modp(y * y, n)\n            if y == 1:\n                return False\n            if y == n - 1:\n                break\n        if x != 1 and x != n - 1:\n            found = False\n            for j in range(t):\n                x = modp(x * x, n)\n                if x == 1:\n                    found = True\n                    break\n                if x == n - 1:\n                    break\n            if found:\n                continue\n            else:\n                return False\n    return True\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return greatest common divisor of a and b.\n    >>> gcd(4, 6)\n    2\n    >>> gcd(101, 3)\n    1\n    \"\"\"\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int):\n    \"\"\"Return lowest common multiple of a and b.\n    >>> lcm",
    "return pow(2, n, p)\n\n\ndef modp_inverse(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modp_inverse(11, 101)\n    9\n    >>> modp_inverse(11, 11)\n    10\n    >>> modp_inverse(11, 7)\n    Traceback (most recent call last):\n    ...\n    ValueError: No inverse exists\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"No inverse exists\")\n    a0, a1 = a, p\n    y0, y1 = 1, 0\n    while a1 > 0:\n        q = a0 // a1\n        a0, a1 = a1, a0 - q * a1\n        y0, y1 = y1, y0 - q * y1\n    if y0 < 0:\n        y0 += p\n    return y0\n\n\ndef modp_inverse_v2(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modp_inverse_v2(11, 101)\n    9\n    >>> modp_inverse_v2(11, 11)\n    10\n    >>> modp_inverse_v2(11, 7)\n    Traceback (most recent call last):\n    ...\n    ValueError: No inverse exists\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"No inverse exists\")\n    a0, a1 = 1, a\n    y0, y1 = 0, 1\n    while a1 > 0:\n        q = a0 // a1\n        a0, a1 = a1, a0 - q * a1\n        y0, y1 = y1, y0 - q * y1\n    if y0 < 0:\n        y0 += p\n    return y0",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^(-1) modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, -1, p)\n\n\ndef modp_sqrt(n: int, p: int):\n    \"\"\"Return square root of n modulo p (be aware of numerics).\n    >>> modp_sqrt(3, 5)\n    2\n    >>> modp_sqrt(1101, 101)\n    2\n    >>> modp_sqrt(0, 101)\n    1\n    >>> modp_sqrt(3, 11)\n    5\n    >>> modp_sqrt(100, 101)\n    1\n    \"\"\"\n    return pow(n, (p + 1) // 4, p)",
    "return pow(2, n, p)\n\n\ndef modp_inv(n: int, p: int):\n    \"\"\"Return 2^-1 modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1\n    \"\"\"\n    return pow(2, p - 2, p)\n\n\ndef gcd(a: int, b: int):\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(2, 4)\n    2\n    >>> gcd(17, 8)\n    1\n    >>> gcd(3, 5)\n    1\n    >>> gcd(3, 0)\n    3\n    \"\"\"\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef egcd(a: int, b: int):\n    \"\"\"Return a 3-tuple (g, x, y) such that ax + by = g = gcd(a, b).\n    >>> egcd(2, 4)\n    (2, -1, 1)\n    >>> egcd(17, 8)\n    (1, -3, 5)\n    >>> egcd(3, 5)\n    (1, -1, 2)\n    >>> egcd(3, 0)\n    (3, 0, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    g, x, y = egcd(b % a, a)\n    return (g, y - (b // a) * x, x)\n\n\ndef modinv(a: int, m: int):\n    \"\"\"Return the modular inverse of a in the modulo m.\n    >>> modinv(2, 6)\n    4\n    >>> modinv(3",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}