{
  "problem": {
    "task_id": "HumanEval/68",
    "prompt": "\ndef pluck(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n",
    "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
    "entry_point": "pluck",
    "docstring": "",
    "problem_id": 68
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "# TODO - IMPLEMENT\n    pass\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))",
    "# Find smallest even value\n    # If none, return []\n    # Find index of smallest even value\n    # Return [smallest_even_value, smallest_even_value_index]\n    pass",
    "if not arr:\n        return []\n    \n    minimum = arr[0]\n    index = 0\n\n    for i, num in enumerate(arr):\n        if num % 2 == 0 and num < minimum:\n            minimum = num\n            index = i\n    \n    return [minimum, index]",
    "if len(arr) == 0:\n        return []\n\n    smallest_even_value = None\n    smallest_even_index = None\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even_value is None or value < smallest_even_value:\n                smallest_even_value = value\n                smallest_even_index = index\n\n    return [smallest_even_value, smallest_even_index]\n\n\ndef test_pluck():\n    assert pluck([4, 2, 3]) == [2, 1]\n    assert pluck([1, 2, 3]) == [2, 1]\n    assert pluck([]) == []\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]",
    "if not arr:\n        return []\n    \n    smallest = [float(\"inf\"), -1]\n    \n    for i, val in enumerate(arr):\n        if val % 2 == 0 and val < smallest[0]:\n            smallest = [val, i]\n\n    return smallest\n\n\ndef test_pluck_1():\n    assert pluck([4,2,3]) == [2, 1]\n\ndef test_pluck_2():\n    assert pluck([1,2,3]) == [2, 1]\n\ndef test_pluck_3():\n    assert pluck([]) == []\n\ndef test_pluck_4():\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]",
    "if len(arr) == 0:\n        return []\n\n    min_value = float('inf')\n    min_index = -1\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if value < min_value:\n                min_value = value\n                min_index = index\n            elif value == min_value and index < min_index:\n                min_index = index\n\n    return [min_value, min_index]\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    smallest_value = None\n    smallest_index = None\n\n    for i, n in enumerate(arr):\n        if n % 2 == 0:\n            if smallest_value is None or n < smallest_value:\n                smallest_value = n\n                smallest_index = i\n            elif n == smallest_value and i < smallest_index:\n                smallest_index = i\n\n    if smallest_value is None:\n        return []\n    else:\n        return [smallest_value, smallest_index]\n\ndef test_pluck():\n    assert pluck([4,2,3]) == [2, 1]\n    assert pluck([1,2,3]) == [2, 1]\n    assert pluck([]) == []\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert pluck([2, 1, 4, 3, 6, 5, 7, 8, 9]) == [2, 0]\n    assert pluck([2, 1, 4, 3, 6, 5, 7, 8, 9, 10]) == [2, 0]\n\nif __name__ == '__main__':\n    test_pluck()",
    "if len(arr) == 0:\n        return []\n    else:\n        return [min([(i, j) for i, j in enumerate(arr) if i % 2 == 0]), min(arr)[1]]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "pass\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    minimum = min(arr)\n    if minimum % 2 == 0:\n        return [minimum, arr.index(minimum)]\n\n    return []\n\n\nassert pluck([4, 2, 3]) == [2, 1]\nassert pluck([1, 2, 3]) == [2, 1]\nassert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nassert pluck([]) == []",
    "arr = sorted(arr)\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            return [arr[i], i]\n    return []",
    "if not arr:\n        return []\n    min_val = min(arr)\n    if min_val % 2 == 0:\n        return [min_val, arr.index(min_val)]\n    return []",
    "if len(arr) == 0:\n        return []\n\n    min_val = float(\"inf\")\n    min_idx = None\n    for idx, val in enumerate(arr):\n        if val % 2 == 0 and val < min_val:\n            min_val = val\n            min_idx = idx\n    \n    return [min_val, min_idx]\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    \n    min_value = float('inf')\n    min_index = None\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < min_value:\n            min_value = value\n            min_index = index\n    \n    return [min_value, min_index]\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "return []\n\n\ndef pluck_fast(arr):\n    \"\"\"\n    Solution explanation:\n        * 1. Find the smallest even value in the array\n        * 2. Find the smallest index of the smallest even value\n        * 3. Return the smallest even value and its index\n    \"\"\"\n    if len(arr) == 0:\n        return []\n    smallest_even_value = min(arr, key=lambda x: x if x % 2 == 0 else float(\"inf\"))\n    smallest_even_value_index = arr.index(smallest_even_value)\n    return [smallest_even_value, smallest_even_value_index]\n\n\nprint(pluck_fast([4, 2, 3]))\nprint(pluck_fast([1, 2, 3]))\nprint(pluck_fast([]))\nprint(pluck_fast([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    min_value = None\n    min_index = None\n    for i, value in enumerate(arr):\n        if value % 2 == 0 and (min_value is None or value < min_value):\n            min_value = value\n            min_index = i\n\n    if min_index is None:\n        return []\n\n    return [min_value, min_index]",
    "if not arr:\n        return []\n    return [min(filter(lambda x: x % 2 == 0, arr), key=arr.index)]",
    "pass\n\n\ndef find_root(arr):\n    \"\"\"\n    \"Given a binary tree of integers, find and return the root node.\n    The root node is the node with the largest value.\n\n    Example 1:\n        Input: [1, 2, 3, 4]\n        Output: 4\n\n    Example 2:\n        Input: [4, 2, 3, 1]\n        Output: 4\n\n    Example 3:\n        Input: [4, 2, 3, 1, 5]\n        Output: 4\n\n    Example 4:\n        Input: [2, 1, 4]\n        Output: 4\n\n    Example 5:\n        Input: [2, 1, 4, 3]\n        Output: 4\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 1 <= node.value <= 10000\n    \"\"\"\n    pass\n\n\ndef find_largest_value(arr):\n    \"\"\"\n    \"Given an array of integers, find the largest value that can be\n    formed by multiplying any subset of the given integers.\n    Example 1:\n        Input: [1, 2, 3]\n        Output: 6\n\n    Example 2:\n        Input: [2, 4, 7]\n        Output: 14\n\n    Example 3:\n        Input: [2, 3, 6, 7]\n        Output: 42\n\n    Constraints:\n        * 1 <= nodes.length <= 1000\n        * 1 <= node.value <= 1000\n    \"\"\"\n    pass\n\n\ndef find_largest_value_in_tree(root):\n    \"\"\"\n    \"Given a binary tree of integers, find and return the largest value that can be\n    formed by summing nodes along a path from the root to any leaf.\n\n    Example 1:\n        Input: [1,2,3,4,5,6,7]\n        Output: 28\n\n    Example 2:\n        Input: [1,null",
    "# Initial Aproach\n    # if len(arr) == 0:\n    #     return []\n    \n    # min_val = min(arr)\n    # if min_val % 2 != 0:\n    #     return []\n    \n    # index = arr.index(min_val)\n    # return [min_val, index]\n    \n    # Optimized\n    if len(arr) == 0:\n        return []\n    \n    min_val = min(arr)\n    if min_val % 2 != 0:\n        return []\n    \n    index = arr.index(min_val)\n    return [min_val, index]",
    "# Find the smallest even number in the array\n    smallest_even = None\n    smallest_even_index = None\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            if smallest_even == None or node < smallest_even:\n                smallest_even = node\n                smallest_even_index = i\n\n    if smallest_even != None:\n        return [smallest_even, smallest_even_index]\n    else:\n        return []\n\ndef test_pluck():\n    assert pluck([4,2,3]) == [2, 1]\n    assert pluck([1,2,3]) == [2, 1]\n    assert pluck([]) == []\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]",
    "if len(arr) == 0:\n        return []\n    smallest_even_value = float(\"inf\")\n    smallest_even_index = float(\"inf\")\n    for i, v in enumerate(arr):\n        if v % 2 == 0 and v < smallest_even_value:\n            smallest_even_value = v\n            smallest_even_index = i\n    return [smallest_even_value, smallest_even_index]",
    "if len(arr) == 0:\n        return []\n    \n    even_vals = []\n    for idx, val in enumerate(arr):\n        if val % 2 == 0:\n            even_vals.append([val, idx])\n\n    if len(even_vals) == 0:\n        return []\n    \n    even_vals.sort(key=lambda x: (x[0], x[1]))\n    return even_vals[0]",
    "arr = sorted(arr, key=lambda x: (x%2, x))\n    if arr and arr[0] % 2 == 0:\n        return [arr[0], arr.index(arr[0])]\n    return []\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if len(arr) == 0:\n        return []\n\n    min_value = arr[0]\n    min_index = 0\n\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0 and arr[i] <= min_value:\n            min_value = arr[i]\n            min_index = i\n\n    return [min_value, min_index]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "# Fill this in.\n\n\nprint (pluck([4,2,3]))\n# [2, 1]\n\nprint (pluck([1,2,3]))\n# [2, 1]\n\nprint (pluck([]))\n# []\n\nprint (pluck([5, 0, 3, 0, 4, 2]))\n# [0, 1]",
    "even = []\n    for i, v in enumerate(arr):\n        if v % 2 == 0:\n            even.append((v, i))\n\n    if not even:\n        return []\n\n    return min(even)\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "even_values = [x for x in arr if x % 2 == 0]\n    if not even_values:\n        return []\n    return [min(even_values), arr.index(min(even_values))]\n\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    return [min(arr), arr.index(min(arr))] if arr else []\n\n\ndef pluck3(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found",
    "if not arr:\n        return []\n\n    # Find the smallest even value\n    smallest_even_value = min([v for v in arr if v % 2 == 0])\n    smallest_even_index = arr.index(smallest_even_value)\n\n    # Find the smallest value\n    smallest_value = min(arr)\n    smallest_index = arr.index(smallest_value)\n\n    return [smallest_even_value, smallest_even_index] if smallest_even_value else [smallest_value, smallest_index]",
    "even_nodes = []\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            even_nodes.append([val, i])\n\n    if len(even_nodes) == 0:\n        return []\n\n    even_nodes.sort(key=lambda x: (x[0], x[1]))\n    return even_nodes[0]\n\n\ndef test_pluck():\n    assert pluck([4,2,3]) == [2, 1]\n    assert pluck([1,2,3]) == [2, 1]\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert pluck([]) == []",
    "# # Initial Understanding\n    # # Sort the array\n    # # Find the first even number\n    # # Return the index\n    # # Time Complexity: O(NlogN)\n    # # Space Complexity: O(N)\n\n    # # Optimized Solution\n    # # Time Complexity: O(N)\n    # # Space Complexity: O(1)\n    # arr.sort()\n    # for i in range(len(arr)):\n    #     if arr[i] % 2 == 0:\n    #         return [arr[i], i]\n    # return []\n\n    # # Optimized Solution\n    # # Time Complexity: O(N)\n    # # Space Complexity: O(1)\n    # if len(arr) == 0:\n    #     return []\n    # min_val = arr[0]\n    # min_val_index = 0\n    # for i in range(1, len(arr)):\n    #     if arr[i] < min_val and arr[i] % 2 == 0:\n    #         min_val = arr[i]\n    #         min_val_index = i\n    # return [min_val, min_val_index]\n\n    # Optimized Solution\n    # Time Complexity: O(N)\n    # Space Complexity: O(1)\n    if len(arr) == 0:\n        return []\n    min_val = arr[0]\n    min_val_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_val and arr[i] % 2 == 0:\n            min_val = arr[i]\n            min_val_index = i\n        elif arr[i] % 2 == 0 and arr[i] < min_val:\n            min_val = arr[i]\n            min_val_index = i\n    return [min_val, min_val_index]\n\n\nprint(pluck([4, 2, 3]))\nprint(pluck([1, 2, 3]))\nprint(pluck([]))\nprint(pluck([5,",
    "# TODO: Write your code here\n\n\ndef flatten(arr):\n    \"\"\"\n    \"Given a two-dimensional array of integers, find the sum of the integers at each corresponding\n    index in the inner arrays.\n    If the inner array is smaller than the index, then that index should be ignored.\n    If the index is out of bounds, then 0 should be assumed.\n\n    Example 1:\n        Input: [[1, 2], [1, 2, 3], [1, 2, 3, 4]]\n        Output: [3, 5, 7]\n        Explanation:\n            The index-0 inner array contains a sum of 1+1=2 at index 0.\n            The index-1 inner array contains a sum of 2+2+3=5 at index 1.\n            The index-2 inner array contains a sum of 3+2+3+4=9 at index 2.\n\n    Example 2:\n        Input: [[1, 2], [1, 2], [1, 2, 3]]\n        Output: [3, 3, 5]\n        Explanation:\n            The index-0 inner array contains a sum of 1+1=2 at index 0.\n            The index-1 inner array contains a sum of 2+1=3 at index 0.\n            The index-2 inner array contains a sum of 3+2+3=5 at index 2.\n\n    Example 3:\n        Input: [[1], [2], [3]]\n        Output: [1, 2, 3]\n        Explanation:\n            The index-0 inner array contains a sum of 1 at index 0.\n            The index-1 inner array contains a sum of 2 at index 0.\n            The index-2 inner array contains a sum of 3 at index 0.\n\n    Example 4:\n        Input: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        Output: [6, 15, 24]\n        Explanation:\n            The index-0 inner array contains a sum of 1+2+",
    "min_val = float('inf')\n    min_val_index = -1\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            if val < min_val:\n                min_val = val\n                min_val_index = i\n            elif val == min_val and min_val_index > i:\n                min_val_index = i\n    return [min_val, min_val_index]",
    "if len(arr) == 0:\n        return []\n\n    min_even_value = None\n    min_even_index = None\n    for i, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even_value is None:\n                min_even_value = value\n                min_even_index = i\n            elif value < min_even_value:\n                min_even_value = value\n                min_even_index = i\n\n    if min_even_value is None:\n        return []\n\n    return [min_even_value, min_even_index]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if len(arr) == 0:\n        return []\n\n    even_vals = [node for node in arr if node % 2 == 0]\n\n    if len(even_vals) == 0:\n        return []\n    \n    return [even_vals[0], arr.index(even_vals[0])]\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if len(arr) == 0: return []\n\n    smallest_value = min(arr)\n    if smallest_value % 2 != 0: return []\n\n    smallest_index = arr.index(smallest_value)\n    return [smallest_value, smallest_index]\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "min_even_val = None\n    min_even_idx = None\n    for idx, node in enumerate(arr):\n        if node % 2 == 0:\n            if not min_even_val:\n                min_even_val = node\n                min_even_idx = idx\n            elif node < min_even_val:\n                min_even_val = node\n                min_even_idx = idx\n\n    if not min_even_val:\n        return []\n\n    return [min_even_val, min_even_idx]\n\n\n\ndef pluck_test():\n    result = pluck([4,2,3])\n    expected = [2, 1]\n    assert result == expected\n\n    result = pluck([1,2,3])\n    expected = [2, 1]\n    assert result == expected\n\n    result = pluck([])\n    expected = []\n    assert result == expected\n\n    result = pluck([5, 0, 3, 0, 4, 2])\n    expected = [0, 1]\n    assert result == expected\n\nif __name__ == \"__main__\":\n    pluck_test()\n    print('pluck: success')",
    "# TODO - IMPLEMENT THIS FUNCTION\n    pass",
    "if len(arr) == 0:\n        return []\n\n    min_val = arr[0]\n    min_val_index = 0\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0 and arr[i] < min_val:\n            min_val = arr[i]\n            min_val_index = i\n    \n    return [min_val, min_val_index]",
    "# TODO: implement\n    pass",
    "if len(arr) == 0:\n        return []\n\n    smallest_value = min([x for x in arr if x % 2 == 0])\n    smallest_index = arr.index(smallest_value)\n    return [smallest_value, smallest_index]\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "# # Initial Understanding\n    # # O(n) time | O(1) space\n    # min_val = float('inf')\n    # min_idx = float('inf')\n    # for idx, val in enumerate(arr):\n    #     if val % 2 == 0 and val < min_val:\n    #         min_val = val\n    #         min_idx = idx\n    # return [min_val, min_idx] if min_val != float('inf') else []\n\n    # # Optimized solution\n    # # O(n) time | O(1) space\n    # min_val = float('inf')\n    # min_idx = float('inf')\n    # min_idx_count = 0\n    # for idx, val in enumerate(arr):\n    #     if val % 2 == 0 and val < min_val:\n    #         min_val = val\n    #         min_idx = idx\n    #     elif val % 2 == 0 and val == min_val:\n    #         min_idx_count += 1\n    #         min_idx = min(idx, min_idx)\n    # return [min_val, min_idx] if min_val != float('inf') else []\n\n    # Optimized solution\n    # O(n) time | O(1) space\n    min_val = float('inf')\n    min_idx = float('inf')\n    min_idx_count = 0\n    for idx, val in enumerate(arr):\n        if val % 2 == 0 and val < min_val:\n            min_val = val\n            min_idx = idx\n        elif val % 2 == 0 and val == min_val:\n            min_idx_count += 1\n            min_idx = min(min_idx, idx)\n    return [min_val, min_idx] if min_val != float('inf') else []\n\n\ndef test_pluck_1():\n    assert pluck([4, 2, 3]) == [2, 1]\n\n\ndef test_pluck_2():\n    assert pluck([1, 2, 3]) == [2,",
    "even_values = []\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            even_values.append([node, i])\n    if not even_values:\n        return []\n    return min(even_values)",
    "if not arr:\n        return []\n    min_value = min(arr, key=lambda x: x % 2 if x % 2 == 0 else 1000000)\n    min_value_index = arr.index(min_value)\n    return [min_value, min_value_index]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4, 2, 3]))\n    print(pluck([1, 2, 3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    \n    smallest_value = None\n    smallest_value_index = None\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_value is None or smallest_value > value:\n                smallest_value = value\n                smallest_value_index = index\n    \n    if smallest_value is None:\n        return []\n    \n    return [smallest_value, smallest_value_index]\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    \n    min_val = arr[0]\n    min_val_index = 0\n    \n    for i in range(1, len(arr)):\n        if arr[i] % 2 == 0 and arr[i] < min_val:\n            min_val = arr[i]\n            min_val_index = i\n        elif arr[i] % 2 == 0 and arr[i] == min_val:\n            if i < min_val_index:\n                min_val_index = i\n    \n    return [min_val, min_val_index]\n\n\ndef pluck_2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not",
    "# O(n) time | O(1) space\n    if not arr:\n        return []\n    min_value = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n    if min_value % 2 == 0:\n        min_index = arr.index(min_value)\n        return [min_value, min_index]\n    return []\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    min_value = arr[0]\n    min_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n            min_index = i\n        elif arr[i] == min_value and i < min_index:\n            min_index = i\n\n    if min_value % 2 == 0:\n        return [min_value, min_index]\n    else:\n        return []",
    "if len(arr) == 0:\n        return []\n\n    even_min_val = float(\"inf\")\n    even_min_idx = float(\"inf\")\n    for idx, val in enumerate(arr):\n        if val % 2 == 0 and val < even_min_val:\n            even_min_val = val\n            even_min_idx = idx\n\n    return [even_min_val, even_min_idx] if even_min_val != float(\"inf\") else []",
    "# TODO: Write your code here",
    "even_nodes = []\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            even_nodes.append([node, i])\n\n    if len(even_nodes) == 0:\n        return []\n\n    even_nodes.sort()\n    return even_nodes[0]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if len(arr) == 0:\n        return []\n\n    smallest_value = min(arr)\n    if smallest_value % 2 != 0:\n        return []\n\n    smallest_index = arr.index(smallest_value)\n    return [smallest_value, smallest_index]\n\nif __name__ == '__main__':\n    # Case 1\n    arr = [4,2,3]\n    result = pluck(arr)\n    print(f'Plucked node is {result}')\n\n    # Case 2\n    arr = [1,2,3]\n    result = pluck(arr)\n    print(f'Plucked node is {result}')\n\n    # Case 3\n    arr = []\n    result = pluck(arr)\n    print(f'Plucked node is {result}')\n\n    # Case 4\n    arr = [5, 0, 3, 0, 4, 2]\n    result = pluck(arr)\n    print(f'Plucked node is {result}')",
    "return [0, 0]",
    "result = []\n    if arr:\n        min_value = min(arr)\n        if min_value % 2 == 0:\n            result.append(min_value)\n            result.append(arr.index(min_value))\n    return result\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    \n    smallest_even = None\n    smallest_even_index = None\n    for i, n in enumerate(arr):\n        if n % 2 == 0 and (not smallest_even or n < smallest_even):\n            smallest_even = n\n            smallest_even_index = i\n    \n    return [smallest_even, smallest_even_index] if smallest_even else []\n\n\ndef pluck_v2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    return [min(arr, key=lambda x: (x % 2 == 0, arr.index(x))) if arr else []]\n\n\nprint(pluck([4,2,3]))\nprint(",
    "# # Version 1: Binary Search\n    # if not arr:\n    #     return []\n\n    # left, right = 0, len(arr) - 1\n    # while left + 1 < right:\n    #     mid = left + (right - left) // 2\n    #     if arr[mid] % 2 == 0:\n    #         right = mid\n    #     else:\n    #         left = mid\n    # if arr[left] % 2 == 0:\n    #     return [arr[left], left]\n    # elif arr[right] % 2 == 0:\n    #     return [arr[right], right]\n    # else:\n    #     return []\n\n    # Version 2: Binary Search\n    if not arr:\n        return []\n    \n    left, right = 0, len(arr) - 1\n    while left + 1 < right:\n        mid = left + (right - left) // 2\n        if arr[mid] % 2 == 0:\n            right = mid\n        else:\n            left = mid\n    if arr[left] % 2 == 0:\n        return [arr[left], left]\n    elif arr[right] % 2 == 0:\n        return [arr[right], right]\n    else:\n        return []\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "min_val = float(\"inf\")\n    min_index = 0\n    for i, node in enumerate(arr):\n        if node % 2 == 0 and node <= min_val:\n            min_val = node\n            min_index = i\n    return [min_val, min_index]\n\ndef main():\n    print(\"Pass\" if ([] == pluck([])) else \"Fail\")\n    print(\"Pass\" if ([] == pluck([1, 3, 5])) else \"Fail\")\n    print(\"Pass\" if ([] == pluck([1, 1, 1])) else \"Fail\")\n    print(\"Pass\" if ([0, 1] == pluck([5, 0, 3, 0, 4, 2])) else \"Fail\")\n    print(\"Pass\" if ([2, 1] == pluck([4, 2, 3])) else \"Fail\")\n    print(\"Pass\" if ([2, 1] == pluck([1, 2, 3])) else \"Fail\")\n\n\nmain()",
    "if not arr:\n        return []\n\n    return [\n        min([(item, index) for index, item in enumerate(arr) if item % 2 == 0])[1]\n    ]",
    "if not arr:\n        return []\n    \n    smallest_value = min([node for node in arr if node % 2 == 0])\n    smallest_index = arr.index(smallest_value)\n\n    return [smallest_value, smallest_index]\n\n\n\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n    \n    return [min(arr, key=lambda x: (x % 2 == 0, arr.index(x)))]\n\n\n\n\ndef pluck3(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes",
    "if len(arr) == 0:\n        return []\n\n    smallest_even_val = None\n    smallest_even_index = None\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            if smallest_even_val is None:\n                smallest_even_val = val\n                smallest_even_index = i\n                continue\n\n            if smallest_even_val > val:\n                smallest_even_val = val\n                smallest_even_index = i\n\n    return [smallest_even_val, smallest_even_index]\n\n\n\nif __name__ == '__main__':\n    # assert pluck([4,2,3]) == [2, 1]\n    # assert pluck([1,2,3]) == [2, 1]\n    assert pluck([]) == []\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert pluck([5, 0, 3, 0, 4, 2, 5, 6, 7, 8, 9]) == [0, 1]\n    assert pluck([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
    "if not arr:\n        return []\n\n    # Find the smallest even number\n    min_val = min(arr)\n    even_nums = [x for x in arr if x % 2 == 0]\n    even_nums.sort()\n    min_even_num = even_nums[0]\n\n    # Find the index of the smallest even number\n    min_even_num_index = arr.index(min_even_num)\n\n    return [min_even_num, min_even_num_index]\n\nif __name__ == '__main__':\n    print(pluck([4,2,3]))",
    "# O(n) time | O(n) space\n    # if not arr:\n    #     return []\n\n    # min_value = float(\"inf\")\n    # min_index = -1\n    # for i, val in enumerate(arr):\n    #     if val % 2 == 0 and val < min_value:\n    #         min_value = val\n    #         min_index = i\n    #     elif val % 2 == 0 and val == min_value and i < min_index:\n    #         min_index = i\n\n    # if min_value % 2 != 0:\n    #     return []\n\n    # return [min_value, min_index]\n\n    # O(n) time | O(1) space\n    if not arr:\n        return []\n\n    min_value = float(\"inf\")\n    min_index = -1\n    for i, val in enumerate(arr):\n        if val % 2 == 0 and val < min_value:\n            min_value = val\n            min_index = i\n        elif val % 2 == 0 and val == min_value and i < min_index:\n            min_index = i\n\n    if min_value % 2 != 0:\n        return []\n\n    return [min_value, min_index]",
    "pass",
    "if not arr: return []\n    min_even = arr[0]\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0 and arr[i] <= min_even:\n            min_even = arr[i]\n            min_even_index = i\n    return [min_even, min_even_index]\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "# Your code here\n    pass\n\n\nprint(pluck([4,2,3]))",
    "smallest_even = None\n    smallest_even_index = None\n    for index, node in enumerate(arr):\n        if node % 2 == 0:\n            if smallest_even is None:\n                smallest_even = node\n                smallest_even_index = index\n            elif node < smallest_even:\n                smallest_even = node\n                smallest_even_index = index\n\n    if smallest_even is None:\n        return []\n    return [smallest_even, smallest_even_index]\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    min_value = min(arr)\n    min_value_indices = [i for i, v in enumerate(arr) if v == min_value]\n    return [min_value, min(min_value_indices)]\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "# Find the node with the smallest even value\n    # if there are multiple nodes with the same smallest even value\n    # return the node with the smallest index\n    # if there are no even values or the given array is empty, return []\n    if not arr:\n        return []\n    smallest = arr[0]\n    smallest_idx = 0\n    for idx, node in enumerate(arr):\n        if node % 2 == 0 and node <= smallest:\n            smallest = node\n            smallest_idx = idx\n    return [smallest, smallest_idx]",
    "# find the smallest even value\n    # if no even value is found, return empty list\n    # if multiple even values, return the smallest index\n    # return the smallest even value with its index in a list\n    if not arr:\n        return []\n    # sort the array in ascending order\n    arr.sort()\n    smallest_even_value = float('inf')\n    smallest_even_index = float('inf')\n    for i, x in enumerate(arr):\n        if x % 2 == 0 and x <= smallest_even_value:\n            smallest_even_value = x\n            smallest_even_index = i\n    if smallest_even_value == float('inf'):\n        return []\n    return [smallest_even_value, smallest_even_index]\n\ndef pluck_test():\n\n    input_array = [4,2,3]\n    expected = [2, 1]\n    output = pluck(input_array)\n    print(output)\n    assert output == expected\n\n    input_array = [1,2,3]\n    expected = [2, 1]\n    output = pluck(input_array)\n    print(output)\n    assert output == expected\n\n    input_array = []\n    expected = []\n    output = pluck(input_array)\n    print(output)\n    assert output == expected\n\n    input_array = [5, 0, 3, 0, 4, 2]\n    expected = [0, 1]\n    output = pluck(input_array)\n    print(output)\n    assert output == expected\n\nif __name__ == \"__main__\":\n    pluck_test()",
    "# pluck the first node with the smallest even value\n    # if there are no even values, return []\n    if not arr:\n        return []\n\n    even_nodes = []\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            even_nodes.append([node, i])\n    # if there are no even nodes, return []\n    if not even_nodes:\n        return []\n    # return the node with the smallest even value\n    return min(even_nodes, key=lambda x: (x[0], x[1]))\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    # Find the smallest even number\n    smallest_even = float('inf')\n    smallest_even_index = float('inf')\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            if arr[i] < smallest_even:\n                smallest_even = arr[i]\n                smallest_even_index = i\n            elif arr[i] == smallest_even:\n                if i < smallest_even_index:\n                    smallest_even_index = i\n\n    if smallest_even == float('inf'):\n        return []\n\n    return [smallest_even, smallest_even_index]\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n\n    # find the min even value\n    min_even = float('inf')\n    min_even_index = -1\n    for i, n in enumerate(arr):\n        if n % 2 == 0 and n < min_even:\n            min_even = n\n            min_even_index = i\n\n    return [min_even, min_even_index]\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "min_even_val = float('inf')\n    min_even_val_index = float('inf')\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            if node < min_even_val:\n                min_even_val = node\n                min_even_val_index = i\n            elif node == min_even_val:\n                if i < min_even_val_index:\n                    min_even_val_index = i\n    return [min_even_val, min_even_val_index]",
    "if not arr:\n        return []\n    even_min = float(\"inf\")\n    even_min_idx = None\n    for idx, val in enumerate(arr):\n        if val % 2 == 0:\n            if val < even_min:\n                even_min = val\n                even_min_idx = idx\n    return [even_min, even_min_idx]\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))\nprint(pluck([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
    "even_values = []\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            even_values.append([node, i])\n\n    if len(even_values) > 0:\n        return min(even_values, key=lambda x: (x[0], x[1]))\n    return []\n\n\ndef test_pluck():\n    assert pluck([4, 2, 3]) == [2, 1]\n    assert pluck([1, 2, 3]) == [2, 1]\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert pluck([]) == []",
    "# O(n) time | O(1) space\n    if len(arr) == 0:\n        return []\n    min_val = min(arr)\n    min_index = arr.index(min_val)\n    for i in range(len(arr)):\n        if arr[i] == min_val and i < min_index:\n            min_index = i\n    return [min_val, min_index]\n\n    # O(n) time | O(n) space\n    # return [min(arr), arr.index(min(arr))]",
    "if not arr: return []\n    smallest_even_value = min([x for x in arr if x % 2 == 0])\n    smallest_even_value_index = arr.index(smallest_even_value)\n    return [smallest_even_value, smallest_even_value_index]\n\n\ndef pluck_2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr: return []\n    smallest_even_value = min([x for x in arr if x % 2 == 0])\n    smallest_even_value_index = arr.index(smallest_even_value)\n    return [smallest_even_value, smallest_even_value_index]",
    "if not arr:\n        return []\n    \n    min_value = min([n for n in arr if n % 2 == 0])\n    return [min_value, arr.index(min_value)]\n\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n    \n    min_value = min([n for n in arr if n % 2 == 0])\n    return [min_value, arr.index(min_value)]\n\n\ndef pluck3(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The pl",
    "if not arr:\n        return []\n\n    min_val = arr[0]\n    min_index = 0\n    for index, val in enumerate(arr):\n        if val <= min_val and val % 2 == 0:\n            min_val = val\n            min_index = index\n\n    if min_val % 2 != 0:\n        return []\n    return [min_val, min_index]\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n\n    min_val = arr[0]\n    min_index = 0\n    for index, val in enumerate(arr):\n        if val <= min_val and val % 2",
    "result = []\n\n    if len(arr) == 0:\n        return result\n\n    minimum_value = min(arr)\n    if minimum_value % 2 == 0:\n        result = [minimum_value, arr.index(minimum_value)]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "even_values = list(filter(lambda x: x % 2 == 0, arr))\n    if not even_values:\n        return []\n    smallest_even = min(even_values)\n    smallest_even_index = arr.index(smallest_even)\n    return [smallest_even, smallest_even_index]",
    "# Your code here\n    return [None]\n\n\ndef main():\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))\n\n\nif __name__ == \"__main__\":\n    main()",
    "result = []\n    smallest = None\n    for i, node in enumerate(arr):\n        if node % 2 == 0 and (smallest is None or node < smallest):\n            smallest = node\n            result = [node, i]\n\n    return result\n\nprint(pluck([4,2,3]))",
    "min_val = float(\"inf\")\n    min_index = float(\"inf\")\n    for i, n in enumerate(arr):\n        if n % 2 == 0 and n < min_val:\n            min_val = n\n            min_index = i\n\n    return [min_val, min_index] if min_val != float(\"inf\") else []\n\n\nprint(pluck([4, 2, 3]))\nprint(pluck([1, 2, 3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))\nprint(pluck([7, 2, 1, 0, 3, 2, 1]))\nprint(pluck([7, 2, 1, 0, 3, 2, 1, 2]))",
    "even_nodes = [node for node in arr if node % 2 == 0]\n    if even_nodes:\n        return [min(even_nodes), even_nodes.index(min(even_nodes))]\n    return []\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))\n\n\"\"\"\nTime Complexity - O(N)\nSpace Complexity - O(1)\n\"\"\"",
    "pass",
    "if len(arr) == 0:\n        return []\n    min_val = min(arr)\n    if min_val % 2 == 0:\n        return [min_val, arr.index(min_val)]\n    else:\n        return []",
    "# Edge cases\n    if not arr:\n        return []\n    \n    # Find the minimum even value\n    min_even_value = min([n for n in arr if n % 2 == 0])\n    \n    # Find the index of the minimum even value\n    min_even_value_index = arr.index(min_even_value)\n    \n    # Return the minimum even value and its index in a list\n    return [min_even_value, min_even_value_index]\n\nprint(pluck([4,2,3])) # [2, 1]\nprint(pluck([1,2,3])) # [2, 1]\nprint(pluck([])) # []\nprint(pluck([5, 0, 3, 0, 4, 2])) # [0, 1]",
    "min_even_val = None\n    min_even_index = None\n    for index, node in enumerate(arr):\n        if node % 2 == 0:\n            if min_even_val is None:\n                min_even_val = node\n                min_even_index = index\n            elif node < min_even_val:\n                min_even_val = node\n                min_even_index = index\n    return [min_even_val, min_even_index]",
    "# pluck(arr):\n    #   return [smallest_value, smallest_index]\n\n    # Solution:\n    #   O(n) time | O(n) space\n    #   If the array is empty, return an empty array.\n    #   If the array has one element, return the array.\n    #   If the array has two or more elements, return the array.\n    #   If the array has three or more elements,\n    #       return the array, but sorted in ascending order.\n    #   If the array has four or more elements,\n    #       return the array, but sorted in descending order.\n    #   If the array has five or more elements,\n    #       return the array, but sorted in ascending order.\n    #   Repeat.\n\n    if len(arr) == 0:\n        return []\n    elif len(arr) == 1:\n        return arr\n    elif len(arr) == 2:\n        return arr\n    elif len(arr) == 3:\n        return sorted(arr)\n    elif len(arr) == 4:\n        return sorted(arr, reverse=True)\n    elif len(arr) == 5:\n        return sorted(arr)\n\n    arr = sorted(arr, reverse=True)\n    # print(arr)\n    plucked = arr[0]\n    plucked_index = arr.index(plucked)\n    arr.pop(plucked_index)\n    # print(arr)\n    return [plucked, plucked_index]\n\n\nprint(pluck([4, 2, 3]))\nprint(pluck([1, 2, 3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "min_val = float('inf')\n    min_index = None\n    for i, node in enumerate(arr):\n        if node % 2 == 0 and node < min_val:\n            min_val = node\n            min_index = i\n\n    if min_val == float('inf'):\n        return []\n\n    return [min_val, min_index]",
    "# TODO: check if this is correct\n    if len(arr) == 0:\n        return []\n    \n    min_value = min(arr)\n    min_index = arr.index(min_value)\n\n    if min_value % 2 != 0:\n        return []\n    \n    return [min_value, min_index]\n\nprint(pluck([4,2,3])) # [2, 1]\nprint(pluck([1,2,3])) # [2, 1]\nprint(pluck([])) # []\nprint(pluck([5, 0, 3, 0, 4, 2])) # [0, 1]",
    "# Find the smallest even value\n    min_even = float('inf')\n    for i, value in enumerate(arr):\n        if value % 2 == 0 and value < min_even:\n            min_even = value\n            min_even_index = i\n    # Return the smallest even value and its index\n    return [min_even, min_even_index] if min_even != float('inf') else []\n\n\ndef main():\n    print('Pluck: ' + str(pluck([4,2,3])))\n    print('Pluck: ' + str(pluck([1,2,3])))\n    print('Pluck: ' + str(pluck([])))\n    print('Pluck: ' + str(pluck([5, 0, 3, 0, 4, 2])))\n\n\nif __name__ == '__main__':\n    main()",
    "if not arr:\n        return []\n    \n    min_val = arr[0]\n    min_index = 0\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            if val < min_val:\n                min_val = val\n                min_index = i\n            elif val == min_val and i < min_index:\n                min_index = i\n    return [min_val, min_index]\n\nprint(pluck([4,2,3]))",
    "min_val = float('inf')\n    min_index = None\n    for i, val in enumerate(arr):\n        if val % 2 == 0 and val < min_val:\n            min_val = val\n            min_index = i\n\n    return [min_val, min_index] if min_index is not None else []\n\n\nprint(pluck([4,2,3]))\nprint(pluck([1,2,3]))\nprint(pluck([]))\nprint(pluck([5, 0, 3, 0, 4, 2]))",
    "even_index = []\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            even_index.append(i)\n    if len(even_index) > 0:\n        return [arr[even_index[0]], even_index[0]]\n    return []\n\n\nif __name__ == \"__main__\":\n    print(pluck([4, 2, 3]))\n    print(pluck([1, 2, 3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    arr.sort()\n    if arr[0] % 2 == 0:\n        return [arr[0], 0]\n    else:\n        for i, el in enumerate(arr):\n            if el % 2 == 0:\n                return [el, i]\n    return []\n\n\nif __name__ == \"__main__\":\n    assert pluck([4, 2, 3]) == [2, 1]\n    assert pluck([1, 2, 3]) == [2, 1]\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert pluck([1, 1, 3, 4, 5, 6, 7]) == [2, 2]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8, 9, 10]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) == [4, 3]\n    assert pluck([1, 1, 3, 4, 5, 6, 7",
    "# find min even value\n    # find min even value index\n    # return [min even value, min even value index]\n    # if no even values return []\n    if not arr:\n        return []\n    even_values = []\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            even_values.append([value, index])\n    if not even_values:\n        return []\n    even_values.sort(key=lambda x: x[0])\n    return even_values[0]\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    # find min even value\n    # find min even value index\n    # return [min even value, min even value",
    "even_vals = []\n    for i, node in enumerate(arr):\n        if node % 2 == 0:\n            even_vals.append((node, i))\n\n    return [] if len(even_vals) == 0 else min(even_vals)\n\ndef pluck2(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    even_vals = [node for node in arr if node % 2 == 0]\n    return [] if len(even_vals) == 0 else min(even_vals, key=lambda x: (x % 2 == 0, arr.index(x)))\n\n\ndef pluck3(arr):\n    \"\"\"\n    \"Given an array representing a",
    "return []\n\n\nif __name__ == \"__main__\":\n    print(pluck([4,2,3]))\n    print(pluck([1,2,3]))\n    print(pluck([]))\n    print(pluck([5, 0, 3, 0, 4, 2]))",
    "if not arr:\n        return []\n    min_val = arr[0]\n    min_idx = 0\n    for idx, num in enumerate(arr):\n        if num % 2 == 0 and num < min_val:\n            min_val = num\n            min_idx = idx\n    return [min_val, min_idx]"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}