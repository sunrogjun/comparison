{
  "problem": {
    "task_id": "MBPP/187",
    "prompt": "Write a function to find the longest common subsequence for the given two sequences.",
    "canonical_solution": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))",
    "test_list": [
      "assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4",
      "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3",
      "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2"
    ],
    "challenge_test_list": [],
    "problem_id": 176
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def longest_common_subsequence(seq1, seq2):\n    \"\"\"\n    :param seq1: first sequence\n    :param seq2: second sequence\n    :return: longest common subsequence\n    :rtype: list\n    \"\"\"\n    n = len(seq1)\n    m = len(seq2)\n    table = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                table[i][j] = table[i - 1][j - 1] + 1\n            else:\n                table[i][j] = max(table[i - 1][j], table[i][j - 1])\n    return table[-1][-1]\n\n\nif __name__ == \"__main__\":\n    seq1 = \"abcde\"\n    seq2 = \"ace\"\n    print(longest_common_subsequence(seq1, seq2))",
    "from typing import List\n\n\nclass Solution:\n    def longest_common_subsequence(self, str1: str, str2: str) -> int:\n        \"\"\"\n        Recursive solution\n\n        Time complexity: O(2 ^ n)\n        Space complexity: O(n)\n        \"\"\"\n        if not str1 or not str2:\n            return 0\n\n        return self.helper(str1, str2, 0, 0)\n\n    def helper(self, str1: str, str2: str, i: int, j: int) -> int:\n        if i == len(str1) or j == len(str2):\n            return 0\n\n        if str1[i] == str2[j]:\n            return 1 + self.helper(str1, str2, i + 1, j + 1)\n        else:\n            return max(self.helper(str1, str2, i + 1, j), self.helper(str1, str2, i, j + 1))\n\n    def longest_common_subsequence_dp(self, str1: str, str2: str) -> int:\n        \"\"\"\n        DP solution\n\n        Time complexity: O(n * m)\n        Space complexity: O(n * m)\n        \"\"\"\n        if not str1 or not str2:\n            return 0\n\n        # Use matrix to record the longest common subsequence\n        dp = [[0 for _ in range(len(str2) + 1)] for _ in range(len(str1) + 1)]\n\n        # Fill the matrix\n        for i in range(1, len(str1) + 1):\n            for j in range(1, len(str2) + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[-1][-1]\n\n    def longest_common_",
    "from functools import lru_cache\n\n\ndef lcs_rec(a, b, i, j):\n    if i == 0 or j == 0:\n        return 0\n\n    if a[i - 1] == b[j - 1]:\n        return 1 + lcs_rec(a, b, i - 1, j - 1)\n\n    return max(lcs_rec(a, b, i - 1, j), lcs_rec(a, b, i, j - 1))\n\n\ndef lcs_dp(a, b):\n    n, m = len(a), len(b)\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\n@lru_cache(maxsize=None)\ndef lcs_dp_lru(a, b, i, j):\n    if i == 0 or j == 0:\n        return 0\n\n    if a[i - 1] == b[j - 1]:\n        return 1 + lcs_dp_lru(a, b, i - 1, j - 1)\n\n    return max(lcs_dp_lru(a, b, i - 1, j), lcs_dp_lru(a, b, i, j - 1))\n\n\nif __name__ == \"__main__\":\n    a = \"ABCBDAB\"\n    b = \"BDCABA\"\n    print(lcs_rec(a, b, len(a), len(b)))\n    print(lcs_dp(a, b))\n    print(l",
    "def lcs(x: list, y: list) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    m = len(x)\n    n = len(y)\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            if x[i] == y[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    x = \"AGGTAB\"\n    y = \"GXTXAYB\"\n    print(lcs(x, y))",
    "def longest_common_subsequence(text_1: str, text_2: str) -> str:\n    \"\"\"\n    Returns the longest common subsequence of two strings.\n    >>> longest_common_subsequence(\"abcde\", \"abcd\")\n    'abcd'\n    >>> longest_common_subsequence(\"abc\", \"def\")\n    ''\n    \"\"\"\n    len_1 = len(text_1)\n    len_2 = len(text_2)\n    dp = [[0 for _ in range(len_2 + 1)] for _ in range(len_1 + 1)]\n\n    for i in range(1, len_1 + 1):\n        for j in range(1, len_2 + 1):\n            if text_1[i - 1] == text_2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return text_1[dp[len_1][len_2] - 1::-1]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()",
    "def longest_common_subsequence(X, Y):\n    \"\"\"\n    :param X: A list of integers\n    :param Y: A list of integers\n    :return: The longest common subsequence of the two sequences.\n    \"\"\"\n    # Find the length of the two sequences\n    m = len(X)\n    n = len(Y)\n\n    # Create a 2-D array to store the length of the longest common subsequence\n    # of the two sequences starting at index (i, j)\n    # The (i, j)th entry of the 2-D array will contain the length of the longest\n    # common subsequence of X[0: i] and Y[0: j]\n    # The (i, j)th entry of the 2-D array will contain the length of the longest\n    # common subsequence of X[0: i] and Y[0: j]\n    l = [[0 for i in range(n + 1)] for j in range(m + 1)]\n\n    # To fill the table, we will go from the rightmost and bottom-most entry to the\n    # top-most entry\n    for i in range(m + 1):\n        for j in range(n + 1):\n            # Base case\n            # If i == 0 or j == 0, then the longest common subsequence of X[0: i]\n            # and Y[0: j] is an empty string\n            if i == 0 or j == 0:\n                l[i][j] = 0\n\n            # If the last elements of both the sequences match\n            elif X[i - 1] == Y[j - 1]:\n                # The longest common subsequence of X[0: i] and Y[0: j] is the\n                # same as the longest common subsequence of X[0: i-1] and\n                # Y[0: j-1] plus the last element of the sequences\n                l[i][j] = l[i - 1][j - 1] + 1\n\n            # If the last elements of both the sequences do not match\n            else:\n                # The longest common subsequence of X[0: i] and Y[0",
    "def lcs(x, y):\n    if not x or not y:\n        return 0\n    elif x[-1] == y[-1]:\n        return 1 + lcs(x[:-1], y[:-1])\n    else:\n        return max(lcs(x, y[:-1]), lcs(x[:-1], y))\n\n\ndef main():\n    print(\"Length of LCS is: \" + str(lcs(\"abcde\", \"ace\")))\n    print(\"Length of LCS is: \" + str(lcs(\"abc\", \"abc\")))\n    print(\"Length of LCS is: \" + str(lcs(\"abc\", \"def\")))\n    print(\"Length of LCS is: \" + str(lcs(\"abcde\", \"acf\")))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def lcs(first: str, second: str) -> str:\n    \"\"\"\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    rows, cols = len(first) + 1, len(second) + 1\n    dp_array = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if first[i - 1] == second[j - 1]:\n                dp_array[i][j] = dp_array[i - 1][j - 1] + 1\n            else:\n                dp_array[i][j] = max(dp_array[i - 1][j], dp_array[i][j - 1])\n\n    index = dp_array[-1][-1]\n    longest_subsequence = \"\"\n\n    while index != 0:\n        if dp_array[-1][-index] == dp_array[-1][-index - 1]:\n            index -= 1\n        else:\n            longest_subsequence = first[-index] + longest_subsequence\n            index -= 1\n\n    return longest_subsequence\n\n\nif __name__ == \"__main__\":\n    print(lcs(\"abcdef\", \"aceg\"))",
    "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Returns the longest common subsequence in two sequences.\n    >>> longest_common_subsequence(\"abcdefg\", \"zbcdxfxg\")\n    'bcdxfg'\n    >>> longest_common_subsequence(\"abc\", \"zbcdxfxg\")\n    'bcd'\n    >>> longest_common_subsequence(\"abc\", \"abc\")\n    'abc'\n    >>> longest_common_subsequence(\"abc\", \"\")\n    ''\n    >>> longest_common_subsequence(\"\", \"abc\")\n    ''\n    >>> longest_common_subsequence(\"\", \"\")\n    ''\n    \"\"\"\n    s1 = s1.lower()\n    s2 = s2.lower()\n    dp = [[0 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return s1[dp[len(s1)][len(s2)] - 1::-1]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()",
    "from functools import lru_cache\n\n\ndef longest_common_subsequence(first: str, second: str) -> str:\n    \"\"\"\n    Return the longest common subsequence of the two sequences.\n\n    >>> longest_common_subsequence(\"abc\", \"abc\")\n    'abc'\n    >>> longest_common_subsequence(\"abc\", \"def\")\n    ''\n    >>> longest_common_subsequence(\"abc\", \"cde\")\n    'c'\n    >>> longest_common_subsequence(\"abc\", \"acd\")\n    'ac'\n    >>> longest_common_subsequence(\"abc\", \"cba\")\n    'abc'\n    >>> longest_common_subsequence(\"abc\", \"acb\")\n    'acb'\n    \"\"\"\n    return longest_common_subsequence_recursive(first, second)\n\n\n@lru_cache(maxsize=None)\ndef longest_common_subsequence_recursive(first: str, second: str) -> str:\n    if not first or not second:\n        return \"\"\n    if first[0] == second[0]:\n        return first[0] + longest_common_subsequence_recursive(first[1:], second[1:])\n    else:\n        return max(\n            longest_common_subsequence_recursive(first[1:], second),\n            longest_common_subsequence_recursive(first, second[1:]),\n            key=len,\n        )\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()",
    "def longest_common_subsequence(a, b):\n    n = len(a)\n    m = len(b)\n    dp = [[0] * (m + 1) for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5, 6, 7]\n    b = [2, 3, 4, 5, 6]\n    print(longest_common_subsequence(a, b))",
    "def longest_common_subsequence(a: list, b: list) -> list:\n    \"\"\"\n    >>> longest_common_subsequence([1,2,3,4,5,6,7], [3,1,7,4,5,6,7])\n    [3, 1, 7, 4, 5, 6, 7]\n    >>> longest_common_subsequence([1,2,3,4,5,6,7], [4,5,6,7,8,9,10])\n    [4, 5, 6, 7]\n    >>> longest_common_subsequence([1,2,3,4,5,6,7], [2,3,4,5,6,7,8])\n    [2, 3, 4, 5, 6, 7]\n    \"\"\"\n    n, m = len(a), len(b)\n\n    # Build the dp table\n    dp = [[0] * (m + 1) for i in range(n + 1)]\n\n    # Fill the table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Fill the list with the result\n    i, j = n, m\n    result = []\n\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            result.append(a[i - 1])\n            i -= 1\n            j -= 1\n        else:\n            if dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n    return list(reversed(result))\n\n\nif __name__ == \"",
    "def lcs(s1, s2):\n    m, n = len(s1), len(s2)\n\n    # Declare the array for storing the dp values\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Following steps build L[m + 1][n + 1] in bottom up fashion\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif s1[i - 1] == s2[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    index = L[m][n]\n    sub = [\"\"] * (index + 1)\n    sub[index] = \"\"\n    i, j = m, n\n\n    # Following steps are used to construct the LCS\n    while i > 0 and j > 0:\n\n        # If current character in X[0...m-1] and Y[0...n-1] matches\n        if s1[i - 1] == s2[j - 1]:\n            index -= 1\n            sub[index] = s1[i - 1]\n            i -= 1\n            j -= 1\n\n        # If not, then find the larger of both and reduce the row or column\n        # by one\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return \"\".join(sub[::-1])\n\n\nif __name__ == \"__main__\":\n    print(lcs(\"AGGTAB\", \"GXTXAYB\"))",
    "def lcs(x, y):\n    \"\"\"\n    >>> lcs('abc', 'abc')\n    'abc'\n    >>> lcs('abc', 'def')\n    ''\n    >>> lcs('abc', 'ac')\n    'ac'\n    >>> lcs('abc', 'axc')\n    'ac'\n    \"\"\"\n    m = len(x)\n    n = len(y)\n    l = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if x[i - 1] == y[j - 1]:\n                l[i][j] = l[i - 1][j - 1] + 1\n            else:\n                l[i][j] = max(l[i - 1][j], l[i][j - 1])\n    return x[l[m][n] - 1 :: -1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def find_longest_common_subsequence(seq1, seq2):\n    \"\"\"Find the longest common subsequence.\"\"\"\n    if not seq1 or not seq2:\n        return []\n    m = len(seq1)\n    n = len(seq2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            if seq1[i] == seq2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n    result = []\n    i, j = m, n\n    while i and j:\n        if dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        elif dp[i][j] == dp[i][j - 1]:\n            j -= 1\n        else:\n            result.append(seq1[i - 1])\n            i -= 1\n            j -= 1\n    return result",
    "from functools import lru_cache\n\n\ndef longest_common_subsequence(a: str, b: str) -> str:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not a or not b:\n        return \"\"\n\n    @lru_cache(maxsize=None)\n    def longest_common_subsequence_dp(i: int, j: int) -> str:\n        if a[i] == b[j]:\n            return a[i] + longest_common_subsequence_dp(i + 1, j + 1)\n        return max(\n            longest_common_subsequence_dp(i, j + 1),\n            longest_common_subsequence_dp(i + 1, j),\n            key=len,\n        )\n\n    return longest_common_subsequence_dp(0, 0)\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == \"ace\"",
    "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef lcs(s1, s2):\n    if s1 == \"\":\n        return s2\n    if s2 == \"\":\n        return s1\n\n    if s1[-1] == s2[-1]:\n        return lcs(s1[:-1], s2[:-1]) + s1[-1]\n\n    return max(lcs(s1[:-1], s2), lcs(s1, s2[:-1]), key=len)\n\n\nif __name__ == \"__main__\":\n    print(lcs(\"abcdefgh\", \"aeiou\"))\n    print(lcs(\"abcdefgh\", \"aeiouxyz\"))\n    print(lcs(\"abcdefg\", \"bcdef\"))\n    print(lcs(\"abcdefg\", \"bcef\"))\n    print(lcs(\"abcdef\", \"bcdefg\"))\n    print(lcs(\"abc\", \"acb\"))\n    print(lcs(\"abc\", \"acb\"))\n    print(lcs(\"abc\", \"cba\"))",
    "from typing import List\n\n\ndef longest_common_subsequence(first: str, second: str) -> str:\n    \"\"\"\n    Time Complexity: O(nm)\n    Space Complexity: O(nm)\n    \"\"\"\n    first_len = len(first)\n    second_len = len(second)\n\n    if first_len == 0 or second_len == 0:\n        return \"\"\n\n    dp = [[0 for _ in range(second_len + 1)] for _ in range(first_len + 1)]\n\n    for i in range(1, first_len + 1):\n        for j in range(1, second_len + 1):\n            if first[i - 1] == second[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    result = \"\"\n    i, j = first_len, second_len\n\n    while i != 0 and j != 0:\n        if first[i - 1] == second[j - 1]:\n            result += first[i - 1]\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return result[::-1]\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == \"ace\"",
    "from typing import List\n\n\ndef lcs(seq1: List[int], seq2: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic Programming solution.\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not seq1 or not seq2:\n        return []\n\n    m, n = len(seq1), len(seq2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    res = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if seq1[i - 1] == seq2[j - 1]:\n            res.append(seq1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return res[::-1]\n\n\nif __name__ == \"__main__\":\n    assert lcs([1, 2, 3, 4], [2, 3, 4, 5]) == [2, 3, 4]\n    assert lcs([1, 2, 3, 4], [2, 3, 4, 5, 6]) == [2, 3, 4]\n    assert lcs([1, 2, 3, 4], [2, 3, 4, 5, 6, 7]) == [2, 3, 4]",
    "def longest_common_subsequence(s1: str, s2: str) -> str:\n    \"\"\"\n    Returns the longest common subsequence in the given two sequences.\n    >>> longest_common_subsequence('abc', 'ac')\n    'ac'\n    >>> longest_common_subsequence('abc', 'adc')\n    'ac'\n    >>> longest_common_subsequence('abc', 'abcd')\n    'abc'\n    >>> longest_common_subsequence('abc', '')\n    ''\n    >>> longest_common_subsequence('', 'abc')\n    ''\n    >>> longest_common_subsequence('', '')\n    ''\n    \"\"\"\n    m = len(s1)\n    n = len(s2)\n\n    lcs = [[0] * (n + 1) for i in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                lcs[i][j] = 1 + lcs[i - 1][j - 1]\n            else:\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1])\n\n    l = lcs[m][n]\n\n    index = m\n    result = \"\"\n    while l > 0:\n        if s1[index - 1] == s2[n - 1]:\n            result = s1[index - 1] + result\n            index -= 1\n            n -= 1\n            l -= 1\n        elif lcs[index - 1][n] > lcs[index][n - 1]:\n            index -= 1\n            l -= 1\n        else:\n            n -= 1\n            l -= 1\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef lcs(x, y):\n    if not x or not y:\n        return 0\n    if x[-1] == y[-1]:\n        return lcs(x[:-1], y[:-1]) + 1\n    else:\n        return max(lcs(x[:-1], y), lcs(x, y[:-1]))\n\n\nif __name__ == \"__main__\":\n    print(lcs(\"abcdefgh\", \"abcef\"))",
    "def longest_common_subsequence(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    s1 = \"abcdefgh\"\n    s2 = \"gfedcba\"\n    print(longest_common_subsequence(s1, s2))",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    Find the longest common subsequence in two sequences.\n    \"\"\"\n    if a == \"\" or b == \"\":\n        return \"\"\n    if a[-1] == b[-1]:\n        return longest_common_subsequence(a[:-1], b[:-1]) + a[-1]\n    return max(longest_common_subsequence(a[:-1], b), longest_common_subsequence(a, b[:-1]), key=len)\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"acb\"))\n    print(longest_common_subsequence(\"abcde\", \"abcdef\"))\n    print(longest_common_subsequence(\"abcde\", \"a\"))\n    print(longest_common_subsequence(\"\", \"abcdef\"))\n    print(longest_common_subsequence(\"abcde\", \"\"))",
    "def lcs(a, b):\n    n = len(a)\n    m = len(b)\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    a = \"abcdefgh\"\n    b = \"abcef\"\n    print(lcs(a, b))",
    "def longest_common_subsequence(s1: str, s2: str) -> str:\n    \"\"\"\n    Dynamic programming solution.\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    len1 = len(s1)\n    len2 = len(s2)\n\n    dp = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)]\n\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    res = []\n    i, j = len1, len2\n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            res.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(reversed(res))\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == \"ace\"\n    assert longest_common_subsequence(\"abc\", \"def\") == \"\"\n    assert longest_common_subsequence(\"abc\", \"def\") == \"\"\n    assert longest_common_subsequence(\"abc\", \"\") == \"\"\n    assert longest_common_subsequence(\"\", \"abc\") == \"\"\n    assert longest_common_subsequence(\"abc\", \"abc\") == \"abc\"\n    assert longest_common_subsequence(\"abc\", \"bc\") == \"bc\"\n    assert longest_common_subsequence(\"abc\", \"cba\") == \"cba\"\n    assert longest_common",
    "def find_longest_common_subsequence(s1, s2):\n    # TODO: Write your code here\n    pass\n\n\ndef main():\n    print(find_longest_common_subsequence(\"abcdefgh\", \"acf\"))\n    print(find_longest_common_subsequence(\"abcdefgh\", \"acfz\"))\n    print(find_longest_common_subsequence(\"abcdefgh\", \"acfgh\"))\n\n\nmain()",
    "from typing import List\n\n\ndef lcs(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic programming solution.\n    Time complexity: O(n*m).\n    Space complexity: O(n*m).\n    \"\"\"\n    # dp[i][j] is the longest common subsequence of a[:i] and b[:j].\n    n, m = len(a), len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Find the last common subsequence.\n    result = []\n    i, j = n, m\n\n    while i >= 0 and j >= 0:\n        if a[i] == b[j]:\n            result.append(a[i])\n            i -= 1\n            j -= 1\n        else:\n            if dp[i][j] == dp[i - 1][j]:\n                i -= 1\n            elif dp[i][j] == dp[i][j - 1]:\n                j -= 1\n\n    return result[::-1]\n\n\nif __name__ == \"__main__\":\n    assert lcs([1, 2, 3, 4], [2, 3, 1, 4, 5]) == [2, 3, 4]",
    "from typing import List\n\n\ndef lcs(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic programming solution.\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    length_a = len(a)\n    length_b = len(b)\n\n    dp = [[0] * (length_b + 1) for _ in range(length_a + 1)]\n\n    for i in range(1, length_a + 1):\n        for j in range(1, length_b + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert lcs([1, 2, 3, 4], [3, 4, 5, 6]) == 2\n    assert lcs([1, 2, 3, 4], [1, 2, 3, 4]) == 4\n    assert lcs([1, 2, 3, 4], [1, 2, 3]) == 3",
    "from typing import List\n\n\ndef longest_common_subsequence(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic programming solution.\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    len_a, len_b = len(a), len(b)\n\n    dp = [[0] * (len_b + 1) for _ in range(len_a + 1)]\n\n    for i in range(1, len_a + 1):\n        for j in range(1, len_b + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    result = []\n    i, j = len_a, len_b\n\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            result.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return result[::-1]\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence([1, 2, 3, 4, 1], [3, 4, 1, 2, 1, 3]) == [1, 2, 3]",
    "def longest_common_subsequence(first_sequence, second_sequence):\n    \"\"\"\n    >>> longest_common_subsequence('abcde', 'acf')\n    'ac'\n    \"\"\"\n    rows = len(first_sequence) + 1\n    cols = len(second_sequence) + 1\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if first_sequence[i - 1] == second_sequence[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return first_sequence[:dp[-1][-1]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef longest_common_subsequence(a: List[int], b: List[int]) -> int:\n    \"\"\"\n    Dynamic programming solution.\n    Time Complexity: O(m * n)\n    \"\"\"\n    m, n = len(a), len(b)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            if a[i] == b[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence([1, 2, 3, 4, 1], [3, 4, 1, 2, 1, 3]) == 3",
    "from typing import List\n\n\ndef lcs(first: str, second: str) -> str:\n    \"\"\"\n    Find longest common subsequence.\n    >>> lcs('abcde', 'ace')\n    'ace'\n    >>> lcs('abc', 'abc')\n    'abc'\n    >>> lcs('abc', 'def')\n    ''\n    >>> lcs('', '')\n    ''\n    >>> lcs('', 'abc')\n    ''\n    >>> lcs('abc', '')\n    ''\n    \"\"\"\n    first_len: int = len(first)\n    second_len: int = len(second)\n    common_seq: List[str] = []\n    if first_len == 0 or second_len == 0:\n        return \"\"\n\n    common_seq = [\n        first[i] for i in range(first_len) if second[i] == first[i]\n    ]\n\n    return \"\".join(common_seq)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def lcs(x, y):\n    m = len(x)\n    n = len(y)\n    l = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if x[i - 1] == y[j - 1]:\n                l[i][j] = l[i - 1][j - 1] + 1\n            else:\n                l[i][j] = max(l[i][j - 1], l[i - 1][j])\n    return l[m][n]\n\n\nif __name__ == \"__main__\":\n    x = \"abcdefgh\"\n    y = \"abcef\"\n    print(lcs(x, y))",
    "class Solution:\n    def longestCommonSubsequence(self, str1: str, str2: str) -> int:\n        \"\"\"\n        DP\n        Time O(mn)\n        Space O(mn)\n        \"\"\"\n        m, n = len(str1), len(str2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]",
    "class Solution:\n    def lcs(self, str1: str, str2: str) -> str:\n        \"\"\"\n        Dynamic Programming\n        Time complexity: O(m*n)\n        Space complexity: O(m*n)\n        \"\"\"\n        if not str1 or not str2:\n            return \"\"\n\n        n1 = len(str1)\n        n2 = len(str2)\n\n        # create a dp array\n        dp = [[0 for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n\n        # fill dp array\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        # create a result list\n        result = []\n\n        # get the longest subsequence\n        i, j = n1, n2\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                result.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n        return \"\".join(result[::-1])\n\n\nif __name__ == \"__main__\":\n    assert Solution().lcs(\"abc\", \"def\") == \"\"\n    assert Solution().lcs(\"abc\", \"def\") == \"\"\n    assert Solution().lcs(\"abcde\", \"ace\") == \"ace\"\n    assert Solution().lcs(\"abc\", \"abc\") == \"abc\"\n    assert Solution().lcs(\"abc\", \"defg\") == \"\"\n    assert Solution().lcs(\"abcde\", \"ace\") == \"ace\"",
    "def lcs(a, b):\n    \"\"\"\n    >>> lcs([1, 2, 3, 4, 1], [3, 4, 1, 2, 1, 3, 4, 1, 12, 2, 1, 1])\n    4\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            if a[i] == b[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(seq1, seq2):\n    \"\"\"\n    Dynamic programming approach for finding longest common subsequence\n\n    :param seq1: first sequence\n    :param seq2: second sequence\n    :return: longest common subsequence\n    \"\"\"\n    dp = [[0 for _ in range(len(seq2) + 1)] for _ in range(len(seq1) + 1)]\n    max_length = 0\n    index = 0\n\n    for i in range(1, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                index = i\n\n    sub_sequence = [seq1[index - 1]]\n\n    while index > 0 and dp[index][j] > 0:\n        if dp[index][j] == dp[index - 1][j]:\n            index -= 1\n        elif dp[index][j] == dp[index][j - 1]:\n            j -= 1\n        else:\n            index -= 1\n            j -= 1\n            sub_sequence.append(seq1[index - 1])\n\n    return sub_sequence[::-1]\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"ace\"))",
    "def lcs(X: str, Y: str) -> str:\n    \"\"\"\n    >>> lcs(\"AC\", \"ACG\")\n    'AC'\n    >>> lcs(\"ACCGGGT\", \"GGTGGTTTT\")\n    'GGGT'\n    >>> lcs(\"ACCGGGT\", \"GGTGGTTTT\")\n    'GGGT'\n    >>> lcs(\"AGGTAB\", \"GXTXAYB\")\n    'GTAB'\n    >>> lcs(\"ABCDGH\", \"AEDFHR\")\n    'ADH'\n    \"\"\"\n\n    # Create a table to store results of subproblems\n    # m rows and n columns\n    lookup_table = [[0 for i in range(len(Y) + 1)] for j in range(len(X) + 1)]\n\n    for i in range(len(X) + 1):\n        for j in range(len(Y) + 1):\n            # Base condition\n            if i == 0 or j == 0:\n                lookup_table[i][j] = 0\n\n            # If last character of both sequences match\n            elif X[i - 1] == Y[j - 1]:\n                lookup_table[i][j] = lookup_table[i - 1][j - 1] + 1\n\n            # If last character of both sequences don't match\n            else:\n                lookup_table[i][j] = max(lookup_table[i - 1][j], lookup_table[i][j - 1])\n\n    # Read the table from right corner and construct the sequence\n    index_i = len(X)\n    index_j = len(Y)\n    lcs_string = \"\"\n    while index_i != 0 and index_j != 0:\n        # If last character of both sequences match\n        if X[index_i - 1] == Y[index_j - 1]:\n            lcs_string += X[index_i - 1]\n            index_i -= 1\n            index_j -= 1\n\n        # If last character of both sequences don't match\n        else:\n            # If one character is ski",
    "def lcs(s1, s2):\n    m, n = len(s1), len(s2)\n    # dp[i][j] stores the length of the longest common subsequence\n    # ending at s1[i] and s2[j]\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Fill table in bottom up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n\ndef main():\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    print(lcs(s1, s2))\n\n\nif __name__ == '__main__':\n    main()",
    "def lcs(X: list, Y: list) -> int:\n    \"\"\"\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n\n    m, n = len(X) + 1, len(Y) + 1\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    X = \"AGGTAB\"\n    Y = \"GXTXAYB\"\n    print(lcs(X, Y))",
    "def lcs(s1: str, s2: str) -> str:\n    \"\"\"\n    >>> lcs(\"abcde\", \"abcde\")\n    'abcde'\n    >>> lcs(\"abcde\", \"abc\")\n    'abc'\n    >>> lcs(\"abcde\", \"acd\")\n    'acd'\n    >>> lcs(\"abcde\", \"abce\")\n    'abc'\n    \"\"\"\n    m = len(s1)\n    n = len(s2)\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    res = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            res.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(reversed(res))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    >>> longest_common_subsequence('abcde', 'abc')\n    'abc'\n    >>> longest_common_subsequence('abcde', 'abcdf')\n    'abc'\n    >>> longest_common_subsequence('abcde', 'acdf')\n    'acd'\n    >>> longest_common_subsequence('abcde', 'acde')\n    'acde'\n    >>> longest_common_subsequence('abcde', 'acdea')\n    'acde'\n    \"\"\"\n    len_s1 = len(s1)\n    len_s2 = len(s2)\n    dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]\n    for i in range(1, len_s1 + 1):\n        for j in range(1, len_s2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    i, j = len_s1, len_s2\n    ans = ''\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            ans += s1[i - 1]\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n    return ans[::-1]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "def lcs(s1, s2):\n    \"\"\"\n    >>> lcs('abcde', 'ace')\n    'ace'\n    >>> lcs('ace', 'abcde')\n    'ace'\n    >>> lcs('abcde', 'aceg')\n    'ace'\n    >>> lcs('aceg', 'abcde')\n    'ace'\n    >>> lcs('aceg', 'abcdefg')\n    'aceg'\n    >>> lcs('abcdefg', 'aceg')\n    'aceg'\n    >>> lcs('', 'aceg')\n    ''\n    >>> lcs('aceg', '')\n    ''\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return s1[dp[m][n] - dp[m - 1][n]:]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "def find_lcs(X, Y, m, n):\n    if m == 0 or n == 0:\n        return 0\n    elif X[m-1] == Y[n-1]:\n        return 1 + find_lcs(X, Y, m-1, n-1)\n    else:\n        return max(find_lcs(X, Y, m, n-1), find_lcs(X, Y, m-1, n))\n\n\nif __name__ == \"__main__\":\n    X = \"AGGTAB\"\n    Y = \"GXTXAYB\"\n    print(find_lcs(X, Y, len(X), len(Y)))",
    "def longest_common_subsequence(x: str, y: str) -> str:\n    \"\"\"\n    Finds the longest common subsequence of two given sequences.\n    >>> longest_common_subsequence(\"abcdefgh\", \"ef\")\n    'ef'\n    >>> longest_common_subsequence(\"abcdefgh\", \"ac\")\n    'ac'\n    >>> longest_common_subsequence(\"abcdefgh\", \"axc\")\n    'ac'\n    >>> longest_common_subsequence(\"abcdefgh\", \"axcz\")\n    'ac'\n    >>> longest_common_subsequence(\"abcdefgh\", \"bxcz\")\n    'bc'\n    >>> longest_common_subsequence(\"abcdefgh\", \"acb\")\n    'acb'\n    \"\"\"\n    n = len(x)\n    m = len(y)\n\n    if n == 0 or m == 0:\n        return \"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if x[i - 1] == y[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Get the length of longest common subsequence\n    length = dp[-1][-1]\n\n    # Create a character array to store the longest common subsequence\n    z = [\"\"] * (length + 1)\n\n    # Start from the right-bottom\n    # and one by one store characters in longest common subsequence\n    i = n\n    j = m\n    k = length - 1\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then\n        # current character is part of LCS\n        if x[i - 1] == y[j - 1]:\n            z[k] = x[i -",
    "from typing import List\n\n\ndef lcs(x: List[int], y: List[int]) -> List[int]:\n    \"\"\"\n    The longest common subsequence is a subsequence that is common to both the sequences.\n    The longest common subsequence is found by working backwards from the end of both the sequences.\n\n    Time Complexity: O(mn)\n    Space Complexity: O(mn)\n    \"\"\"\n\n    m: int = len(x)\n    n: int = len(y)\n\n    # We can have at most mn elements in the LCS.\n    # We create a 2D array for storing the LCS.\n    lcs: List[List[int]] = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if x[j - 1] == y[i - 1]:\n                lcs[i][j] = 1 + lcs[i - 1][j - 1]\n            else:\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1])\n\n    # We need to print the LCS in reverse order.\n    index = lcs[n][m]\n    subsequence: List[int] = []\n\n    while index != 0:\n        # We need to print the character at the end of both the sequences.\n        if x[m - 1] == y[n - 1]:\n            subsequence.append(x[m - 1])\n\n        # If the last element of both the sequences doesn't match,\n        # we need to consider the last element of the sequence with the highest value in the 2D array.\n        if lcs[n][m] == lcs[n - 1][m]:\n            n -= 1\n        elif lcs[n][m] == lcs[n][m - 1]:\n            m -= 1\n\n        index -= 1\n\n    return subsequence[::-1]\n\n\nif __name__ == \"__main__\":",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    >>> longest_common_subsequence([], [])\n    0\n    >>> longest_common_subsequence([1], [])\n    0\n    >>> longest_common_subsequence([1, 2, 3], [1, 2, 4])\n    2\n    >>> longest_common_subsequence([1, 2, 3], [2, 3, 4])\n    2\n    >>> longest_common_subsequence([1, 2, 3, 4], [2, 3, 4, 5])\n    3\n    \"\"\"\n    m = len(a)\n    n = len(b)\n\n    # Base Case\n    if m == 0 or n == 0:\n        return 0\n\n    # if last elements of both sequences are equal,\n    # then problem reduces to the problem with length\n    # of both sequences minus 1\n    if a[m - 1] == b[n - 1]:\n        return 1 + longest_common_subsequence(a[: m - 1], b[: n - 1])\n\n    # if last elements are not equal, then we have to\n    # consider the LCS for all elements before last and\n    # choose the max of both these LCS\n    return max(\n        longest_common_subsequence(a[: m - 1], b),\n        longest_common_subsequence(a, b[: n - 1]),\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef lcs(first: List[int], second: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic Programming solution for LCS problem.\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    @param first: List[int]\n    @param second: List[int]\n    @return: List[int]\n    \"\"\"\n    # create a table to store results of subproblems\n    table: List[List[int]] = [[0 for _ in range(len(second) + 1)] for _ in range(len(first) + 1)]\n\n    # fill the table row by row\n    for i in range(len(first) + 1):\n        for j in range(len(second) + 1):\n            # if first[i] and second[j] are equal then the LCS will have one more element\n            if i == 0 or j == 0:\n                table[i][j] = 0\n            elif first[i - 1] == second[j - 1]:\n                table[i][j] = table[i - 1][j - 1] + 1\n            else:\n                table[i][j] = max(table[i - 1][j], table[i][j - 1])\n\n    # create a list to store the result\n    result: List[int] = []\n\n    # read the table from the bottom right corner and construct the result\n    i = len(first)\n    j = len(second)\n\n    while i > 0 and j > 0:\n        if first[i - 1] == second[j - 1]:\n            result.append(first[i - 1])\n            i -= 1\n            j -= 1\n        elif table[i - 1][j] > table[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert lcs([3, 5, 1, 2, 4, 6], [2, 4, 3,",
    "def lcs(x, y):\n    # create table to store results of subproblems\n    # first row and column are 0\n    table = [[0 for _ in range(len(y)+1)] for _ in range(len(x)+1)]\n\n    for i in range(1, len(x)+1):\n        for j in range(1, len(y)+1):\n            if x[i-1] == y[j-1]:\n                table[i][j] = table[i-1][j-1] + 1\n            else:\n                table[i][j] = max(table[i-1][j], table[i][j-1])\n\n    return table[-1][-1]\n\nprint(lcs('abcdefgh', 'abcadb'))",
    "def lcs(X, Y):\n    \"\"\"\n    X: a list of integers\n    Y: a list of integers\n    \"\"\"\n    # BASE CASE\n    if len(X) == 0 or len(Y) == 0:\n        return 0\n\n    # RECURSIVE CASE\n    if X[-1] == Y[-1]:\n        return 1 + lcs(X[:-1], Y[:-1])\n    else:\n        return max(lcs(X[:-1], Y), lcs(X, Y[:-1]))\n\n\n# print(lcs([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]))\n# print(lcs([1, 2, 3, 4, 5], [1, 2, 3, 4]))\n# print(lcs([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]))\n\n\n\"\"\"\nGiven two strings, write a method to decide if one is a permutation of the other.\n\"\"\"\n\n\ndef is_permutation(s1, s2):\n    \"\"\"\n    s1: a string\n    s2: a string\n    \"\"\"\n    # BASE CASE\n    if len(s1) != len(s2):\n        return False\n\n    # RECURSIVE CASE\n    # create a dict of chars in s1 and their counts\n    d1 = {}\n    for c in s1:\n        if c in d1:\n            d1[c] += 1\n        else:\n            d1[c] = 1\n\n    # create a dict of chars in s2 and their counts\n    d2 = {}\n    for c in s2:\n        if c in d2:\n            d2[c] += 1\n        else:\n            d2[c] = 1\n\n    # compare the two dicts\n    for k in d1.keys():\n        if k not in d2 or d1[k] != d2[k]:\n            return False\n\n    return True\n\n\n#",
    "def longest_common_subsequence(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return 0\n\n    if a[-1] == b[-1]:\n        return 1 + longest_common_subsequence(a[:-1], b[:-1])\n\n    return max(\n        longest_common_subsequence(a[:-1], b),\n        longest_common_subsequence(a, b[:-1]),\n    )",
    "def longest_common_subsequence(seq1, seq2):\n    \"\"\"\n    >>> longest_common_subsequence(\"abcde\", \"abc\")\n    'abc'\n    >>> longest_common_subsequence(\"abcde\", \"abcde\")\n    'abcde'\n    >>> longest_common_subsequence(\"abcde\", \"ace\")\n    'ace'\n    >>> longest_common_subsequence(\"abcde\", \"acb\")\n    'acb'\n    >>> longest_common_subsequence(\"abcde\", \"acbce\")\n    'acbce'\n    \"\"\"\n    m = len(seq1)\n    n = len(seq2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            if seq1[i] == seq2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n    return seq1[dp[m][n] - 1 :]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(s1, s2):\n    if not s1 or not s2:\n        return \"\"\n\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n\n    i, j = m - 1, n - 1\n    subsequence = []\n    while i >= 0 and j >= 0:\n        if s1[i] == s2[j]:\n            subsequence.append(s1[i])\n            i -= 1\n            j -= 1\n        elif dp[i + 1][j] > dp[i][j + 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(subsequence[::-1])",
    "from typing import List\n\n\ndef longest_common_subsequence(x: List[int], y: List[int]) -> List[int]:\n    \"\"\"\n    Dynamic programming solution.\n    Time: O(2n)\n    Space: O(n)\n    \"\"\"\n    n = len(x)\n    m = len(y)\n\n    if n == 0 or m == 0:\n        return []\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if x[i - 1] == y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = n, m\n    result = []\n\n    while i > 0 and j > 0:\n        if x[i - 1] == y[j - 1]:\n            result.append(x[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return list(reversed(result))\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence([1, 2, 3, 4], [4, 3, 2, 1]) == [4, 3, 2, 1]\n    assert longest_common_subsequence([1, 2, 3, 4], [4, 3, 2]) == [4, 3, 2]\n    assert longest_common_subsequence([1, 2, 3, 4], [1, 2, 3, 4]) == [1, 2, 3, 4]",
    "def lcs(a, b):\n    \"\"\"\n    Time Complexity: O(n*m)\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    assert lcs(\"abcdefgh\", \"zxywvutsrq\") == 0\n    assert lcs(\"abcdefgh\", \"fedcba\") == 6\n    assert lcs(\"abcdefgh\", \"abcdefgh\") == 8\n    assert lcs(\"abcdefgh\", \"abcdefhij\") == 7\n    assert lcs(\"abcdefgh\", \"abcdefghi\") == 8",
    "from functools import lru_cache\n\n\ndef longest_common_subsequence(x, y):\n    \"\"\"\n    The longest common subsequence of two strings is the longest\n    sequence of characters which are present in both strings in the same order.\n    Example: longest_common_subsequence('abcde', 'ace') = 'ace'\n    \"\"\"\n    return longest_common_subsequence_aux(x, y, len(x), len(y))\n\n\n@lru_cache(maxsize=None)\ndef longest_common_subsequence_aux(x, y, i, j):\n    if i == 0 or j == 0:\n        return \"\"\n\n    if x[i - 1] == y[j - 1]:\n        return longest_common_subsequence_aux(x, y, i - 1, j - 1) + x[i - 1]\n\n    return max(\n        longest_common_subsequence_aux(x, y, i - 1, j),\n        longest_common_subsequence_aux(x, y, i, j - 1),\n        key=len\n    )\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"ace\"))\n    print(longest_common_subsequence(\"abc\", \"def\"))\n    print(longest_common_subsequence(\"abc\", \"def\"))\n    print(longest_common_subsequence(\"abc\", \"def\"))",
    "from typing import List\n\n\ndef lcs(s1: List[str], s2: List[str]) -> List[str]:\n    \"\"\"\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    if not s1 or not s2:\n        return []\n\n    m, n = len(s1), len(s2)\n\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n\n    res = []\n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            res.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return res[::-1]\n\n\nif __name__ == \"__main__\":\n    s1 = \"ABCBDAB\"\n    s2 = \"BDCABA\"\n    print(lcs(s1, s2))",
    "def lcs(X: str, Y: str) -> str:\n    \"\"\"\n    >>> lcs(\"abcde\", \"abcde\")\n    'abcde'\n    >>> lcs(\"abcde\", \"abc\")\n    'abc'\n    >>> lcs(\"abcde\", \"abce\")\n    'abc'\n    >>> lcs(\"abcde\", \"abcf\")\n    'abc'\n    >>> lcs(\"abcde\", \"a\")\n    'a'\n    >>> lcs(\"abcde\", \"\")\n    ''\n    >>> lcs(\"\", \"a\")\n    ''\n    >>> lcs(\"\", \"\")\n    ''\n    \"\"\"\n    m = len(X)\n    n = len(Y)\n\n    # If one of the strings is empty, the length of the longest common subsequence is 0.\n    if m == 0 or n == 0:\n        return \"\"\n\n    # Generate a matrix to store the LCS length.\n    lcs_length = [[0 for i in range(n + 1)] for j in range(m + 1)]\n\n    # Fill the matrix.\n    for i in range(m + 1):\n        for j in range(n + 1):\n            # Base case: when one of the strings is empty, the length of the longest common subsequence is 0.\n            if i == 0 or j == 0:\n                lcs_length[i][j] = 0\n            # If the letters are equal, increase the length of the longest common subsequence by 1.\n            elif X[i - 1] == Y[j - 1]:\n                lcs_length[i][j] = lcs_length[i - 1][j - 1] + 1\n            # If the letters are not equal, choose the maximum length of the longest common subsequence from the previous row or the previous column.\n            else:\n                lcs_length[i][j] = max(lcs_length[i - 1][j], lcs_length[i][j - 1])\n\n    # Build the LCS from the matrix.\n    i = m\n    j = n\n    lcs = \"\"\n    while i > 0",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    a = \"abcdefgh\"\n    b = \"aceg\"\n    assert longest_common_subsequence(a, b) == 5",
    "def find_longest_common_subsequence(sequence_one, sequence_two):\n    \"\"\"\n    This is a classic dynamic programming problem.\n    https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n    \"\"\"\n    # Create an empty 2D matrix\n    matrix = [[0 for i in range(len(sequence_two) + 1)] for j in range(len(sequence_one) + 1)]\n\n    # Fill the matrix\n    for i in range(len(sequence_one) + 1):\n        for j in range(len(sequence_two) + 1):\n            # Base case\n            if i == 0 or j == 0:\n                matrix[i][j] = 0\n            # If the last elements of the two sequences match\n            elif sequence_one[i - 1] == sequence_two[j - 1]:\n                matrix[i][j] = matrix[i - 1][j - 1] + 1\n            # If the last elements of the two sequences do not match\n            else:\n                matrix[i][j] = max(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print(find_longest_common_subsequence(\"abcde\", \"ace\"))\n    print(find_longest_common_subsequence(\"abc\", \"abc\"))\n    print(find_longest_common_subsequence(\"abc\", \"def\"))\n    print(find_longest_common_subsequence(\"abc\", \"def\"))\n    print(find_longest_common_subsequence(\"abcde\", \"ace\"))\n    print(find_longest_common_subsequence(\"abcdef\", \"ace\"))\n    print(find_longest_common_subsequence(\"abcdefg\", \"ace\"))",
    "def longest_common_subsequence(s1: str, s2: str) -> int:\n    \"\"\"\n    Dynamic Programming:\n    Fill a matrix with the length of the longest common subsequence\n    of s1[i] and s2[j].\n    \"\"\"\n    rows = len(s1)\n    cols = len(s2)\n\n    lcs = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]\n\n    for row in range(1, rows + 1):\n        for col in range(1, cols + 1):\n            if s1[row - 1] == s2[col - 1]:\n                lcs[row][col] = 1 + lcs[row - 1][col - 1]\n            else:\n                lcs[row][col] = max(lcs[row - 1][col], lcs[row][col - 1])\n\n    return lcs[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcdef\", \"ace\"))\n    print(longest_common_subsequence(\"abcdef\", \"aceb\"))\n    print(longest_common_subsequence(\"abcdef\", \"abcdefg\"))\n    print(longest_common_subsequence(\"abcdef\", \"abcdefhijkl\"))\n    print(longest_common_subsequence(\"abcdef\", \"\"))\n    print(longest_common_subsequence(\"\", \"abcdef\"))",
    "def lcs_length(a, b):\n    m = len(a)\n    n = len(b)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[-1][-1]\n\n\nprint(lcs_length(\"abcde\", \"ace\"))\nprint(lcs_length(\"abcde\", \"abc\"))\nprint(lcs_length(\"abcde\", \"abce\"))\nprint(lcs_length(\"abcde\", \"abcdef\"))\nprint(lcs_length(\"abcde\", \"abcdefg\"))\nprint(lcs_length(\"abcde\", \"abcd\"))",
    "def lcs_length(x, y):\n    \"\"\"Returns the length of the longest common subsequence of x and y.\"\"\"\n    if x == [] or y == []:\n        return 0\n    if x[-1] == y[-1]:\n        return 1 + lcs_length(x[:-1], y[:-1])\n    else:\n        return max(lcs_length(x, y[:-1]), lcs_length(x[:-1], y))\n\n\ndef lcs(x, y):\n    \"\"\"Returns the longest common subsequence of x and y.\"\"\"\n    if x == [] or y == []:\n        return []\n    if x[-1] == y[-1]:\n        return [x[-1]] + lcs(x[:-1], y[:-1])\n    else:\n        l1 = lcs(x, y[:-1])\n        l2 = lcs(x[:-1], y)\n        if len(l1) > len(l2):\n            return l1\n        else:\n            return l2",
    "from functools import lru_cache\n\n\ndef longest_common_subsequence(a: list, b: list) -> list:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not a or not b:\n        return []\n\n    @lru_cache(maxsize=None)\n    def get_longest_common_subsequence(i: int, j: int) -> list:\n        if i == len(a) or j == len(b):\n            return []\n\n        if a[i] == b[j]:\n            return [a[i]] + get_longest_common_subsequence(i + 1, j + 1)\n\n        left = get_longest_common_subsequence(i, j + 1)\n        right = get_longest_common_subsequence(i + 1, j)\n\n        if len(left) > len(right):\n            return left\n        return right\n\n    return get_longest_common_subsequence(0, 0)\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]))\n    print(longest_common_subsequence([\"a\", \"b\", \"c\", \"d\", \"e\"], [\"c\", \"d\", \"e\", \"f\", \"g\"]))",
    "def longest_common_subsequence(s1: str, s2: str) -> str:\n    \"\"\"\n    Longest common subsequence\n    \"\"\"\n    len_s1 = len(s1)\n    len_s2 = len(s2)\n\n    if len_s1 == 0 or len_s2 == 0:\n        return \"\"\n\n    dp = [[0 for _ in range(len_s2 + 1)] for _ in range(len_s1 + 1)]\n\n    for i in range(1, len_s1 + 1):\n        for j in range(1, len_s2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i = len_s1\n    j = len_s2\n    result = []\n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            result.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(result)[::-1]\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"ace\"))\n    print(longest_common_subsequence(\"abc\", \"def\"))",
    "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    >>> longest_common_subsequence(\"abcde\", \"abcd\")\n    'abcd'\n    >>> longest_common_subsequence(\"abc\", \"def\")\n    ''\n    >>> longest_common_subsequence(\"abc\", \"def\")\n    ''\n    >>> longest_common_subsequence(\"abcde\", \"abc\")\n    'abc'\n    >>> longest_common_subsequence(\"abcde\", \"acb\")\n    'acb'\n    >>> longest_common_subsequence(\"abcde\", \"deab\")\n    'deab'\n    >>> longest_common_subsequence(\"abcde\", \"dabc\")\n    'dabc'\n    >>> longest_common_subsequence(\"abcde\", \"dacb\")\n    'dacb'\n    \"\"\"\n    # create an empty matrix\n    matrix = [\n        [0 for _ in range(len(str2) + 1)] for _ in range(len(str1) + 1)\n    ]\n\n    # fill the matrix\n    for i in range(len(str1)):\n        for j in range(len(str2)):\n            if str1[i] == str2[j]:\n                matrix[i + 1][j + 1] = matrix[i][j] + 1\n            else:\n                matrix[i + 1][j + 1] = max(\n                    matrix[i][j + 1], matrix[i + 1][j]\n                )\n\n    # find the longest common subsequence\n    result = \"\"\n    i, j = len(str1), len(str2)\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result = str1[i - 1] + result\n            i -= 1\n            j -= 1\n        elif matrix[i][j] == matrix[i][j - 1]:\n            j -= 1\n        else:\n            i -= 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest",
    "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Dynamic Programming solution\n\n    Time complexity: O(n*m)\n    Space complexity: O(n*m)\n    \"\"\"\n    # Create a table to store the results of sub problems\n    # We will fill the table in a bottom-up fashion.\n    # table[i][j] contains the length of the longest common subsequence of s1[:i] and s2[:j]\n    table = [[0 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            # If the two characters match, we will take 1 + result of the sub problem\n            # with the same characters removed from both strings.\n            if s1[i - 1] == s2[j - 1]:\n                table[i][j] = 1 + table[i - 1][j - 1]\n            # If the characters do not match, we will take the maximum result of the\n            # sub problems with the same characters removed from both strings.\n            else:\n                table[i][j] = max(table[i - 1][j], table[i][j - 1])\n\n    # Return the last element of the table\n    return table[-1][-1]\n\n\ndef main():\n    print(\"Test case 1: \" + str(longest_common_subsequence(\"abcdefg\", \"aceg\")))\n    print(\"Test case 2: \" + str(longest_common_subsequence(\"abcdefg\", \"acegjk\")))\n    print(\"Test case 3: \" + str(longest_common_subsequence(\"abcdefghijklmnopqrstuvwxyz\", \"acegjk\")))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def find_lcs(a: list, b: list) -> list:\n    \"\"\"\n    >>> find_lcs([1, 2, 3, 4, 5, 6], [4, 5, 6, 7, 8, 9])\n    [4, 5, 6]\n    >>> find_lcs([1, 2, 3, 4, 5, 6], [4, 7, 8, 9])\n    []\n    >>> find_lcs([1, 2, 3, 4, 5, 6], [4, 5, 6, 7, 8, 9, 10])\n    [4, 5, 6]\n    \"\"\"\n    n, m = len(a), len(b)\n    if n == 0 or m == 0:\n        return []\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    res = []\n    i, j = n, m\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            res.append(a[i - 1])\n            i -= 1\n            j -= 1\n        else:\n            if dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n    return res[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(X, Y):\n    \"\"\"\n    Returns the longest common subsequence for the given two sequences.\n\n    >>> longest_common_subsequence(\"abcde\", \"abzde\")\n    'abde'\n\n    >>> longest_common_subsequence(\"abc\", \"xyz\")\n    ''\n\n    >>> longest_common_subsequence(\"abc\", \"abc\")\n    'abc'\n\n    >>> longest_common_subsequence(\"abc\", \"cde\")\n    'c'\n\n    >>> longest_common_subsequence(\"abc\", \"\")\n    ''\n\n    >>> longest_common_subsequence(\"\", \"abc\")\n    ''\n    \"\"\"\n    if X == \"\" or Y == \"\":\n        return \"\"\n\n    m = len(X)\n    n = len(Y)\n    longest_common_subsequence = []\n\n    def find_longest_common_subsequence(X, Y, m, n, longest_common_subsequence):\n        if m == 0 or n == 0:\n            return\n\n        if X[m - 1] == Y[n - 1]:\n            longest_common_subsequence.append(X[m - 1])\n            find_longest_common_subsequence(X, Y, m - 1, n - 1, longest_common_subsequence)\n\n        else:\n            find_longest_common_subsequence(X, Y, m - 1, n, longest_common_subsequence)\n            find_longest_common_subsequence(X, Y, m, n - 1, longest_common_subsequence)\n\n    find_longest_common_subsequence(X, Y, m, n, longest_common_subsequence)\n\n    return \"\".join(longest_common_subsequence)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "def longest_common_subsequence(str1, str2):\n    \"\"\"\n    Time Complexity: O(n*m)\n    \"\"\"\n    m = len(str1)\n    n = len(str2)\n    dp = [[0 for x in range(n + 1)] for y in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    >>> longest_common_subsequence([1, 2, 3, 4], [3, 4, 5, 6])\n    [3, 4]\n    >>> longest_common_subsequence([1, 2, 3, 4], [1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> longest_common_subsequence([1, 2, 3, 4], [1, 2, 5, 6])\n    [1, 2]\n    >>> longest_common_subsequence([1, 2, 3, 4], [5, 6, 7, 8])\n    []\n    \"\"\"\n    m = len(a)\n    n = len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # reconstruct the longest common subsequence\n    idx = m\n    jdx = n\n    sub = []\n    while idx > 0 and jdx > 0:\n        if a[idx - 1] == b[jdx - 1]:\n            sub.append(a[idx - 1])\n            idx -= 1\n            jdx -= 1\n        elif dp[idx - 1][jdx] > dp[idx][jdx - 1]:\n            idx -= 1\n        else:\n            jdx -= 1\n    sub.reverse()\n    return sub\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def lcs_rec(x, y):\n    if not x or not y:\n        return \"\"\n\n    if x[-1] == y[-1]:\n        return lcs_rec(x[:-1], y[:-1]) + x[-1]\n\n    without_x = lcs_rec(x, y[:-1])\n    without_y = lcs_rec(x[:-1], y)\n\n    return without_x if len(without_x) > len(without_y) else without_y\n\n\ndef lcs_dp(x, y):\n    m, n = len(x), len(y)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if x[i - 1] == y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return x[:dp[m][n]]\n\n\ndef main():\n    x = \"abcdef\"\n    y = \"acd\"\n    print(lcs_rec(x, y))\n    print(lcs_dp(x, y))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def lcs(x, y):\n    m = len(x)\n    n = len(y)\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if x[i - 1] == y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    x = \"AGGTAB\"\n    y = \"GXTXAYB\"\n    print(lcs(x, y))",
    "from typing import List\n\n\ndef lcs(seq1: List[int], seq2: List[int]) -> List[int]:\n    \"\"\"\n    Return longest common subsequence of the two given sequences.\n    >>> lcs([1, 2, 3, 4, 5, 6], [7, 5, 3, 4, 6, 7])\n    [3, 4, 6]\n    >>> lcs([1, 2, 3, 4, 5, 6], [7, 5, 3, 4, 6, 7, 1, 2, 3, 4, 5, 6])\n    [3, 4, 6]\n    >>> lcs([1, 2, 3, 4, 5, 6], [7, 5, 3, 4, 6, 7, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])\n    [3, 4, 6]\n    >>> lcs([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    >>> lcs([1, 2, 3, 4, 5, 6], [7, 5, 3, 4, 6, 7, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])\n    [3, 4, 6]\n    \"\"\"\n    length1 = len(seq1)\n    length2 = len(seq2)\n    if length1 == 0 or length2 == 0:\n        return []\n\n    if seq1[length1 - 1] == seq2[length2 - 1]:\n        return lcs(seq1[:-1], seq2[:-1]) + [seq1[-1]]\n\n    if seq1[length1 - 1] != seq2[",
    "from typing import List\n\n\ndef lcs_rec(a: List[int], b: List[int], n: int, m: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if n == 0 or m == 0:\n        return 0\n\n    if a[n - 1] == b[m - 1]:\n        return 1 + lcs_rec(a, b, n - 1, m - 1)\n\n    return max(lcs_rec(a, b, n - 1, m), lcs_rec(a, b, n, m - 1))\n\n\ndef lcs_dp(a: List[int], b: List[int], n: int, m: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    dp: List[List[int]] = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif a[i - 1] == b[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert lcs_rec([3, 4, 5, 6, 7, 0, 1, 2], [4, 5, 6, 0, 1, 3, 2], 8, 7) == 5\n    assert lcs_dp([3, 4, 5, 6, 7, 0, 1, 2], [4, 5,",
    "def lcs(s1, s2):\n    \"\"\"\n    Longest common subsequence.\n    \"\"\"\n\n    # if both s1 and s2 are empty, return empty string\n    if len(s1) == 0 or len(s2) == 0:\n        return \"\"\n\n    # if last char of s1 and s2 are equal, return the longest subsequence of s1 and s2 without the last char\n    if s1[-1] == s2[-1]:\n        return lcs(s1[:-1], s2[:-1]) + s1[-1]\n\n    # else, return the longest subsequence of s1 or s2\n    return max(lcs(s1[:-1], s2), lcs(s1, s2[:-1]), key=len)",
    "from typing import List\n\n\ndef lcs(x: List[int], y: List[int]) -> List[int]:\n    m = len(x)\n    n = len(y)\n\n    # Create a table to store lengths of\n    # subproblems. The value at table[i, j]\n    # would be length of LCS of X[0..i-1]\n    # and Y[0..j-1]\n    table = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if x[i - 1] == y[j - 1]:\n                table[i][j] = 1 + table[i - 1][j - 1]\n            else:\n                table[i][j] = max(table[i - 1][j], table[i][j - 1])\n\n    # Start from the bottom-right corner\n    # and add the elements in order to\n    # create the longest common subsequence\n    index = table[m][n]\n    lcs = [None] * index\n    i, j = m, n\n\n    while i > 0 and j > 0:\n        # If current element in X[] and Y are\n        # same, then add it to result.\n        if x[i - 1] == y[j - 1]:\n            lcs[index - 1] = x[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two\n        # elements and go in the direction of larger\n        # element\n        elif table[i - 1][j] > table[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return lcs\n\n\nif __name__ == \"__main__\":\n    x = [1, 2, 3, 4, 1]\n    y = [2, 2, 3, 4]\n    print(f\"Input: x =",
    "def lcs(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n    return dp[m][n]\n\n\ndef lcs2(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m - 1][n - 1]\n\n\nif __name__ == '__main__':\n    s1 = 'ABCBDAB'\n    s2 = 'BDCABA'\n    print(lcs(s1, s2))\n    print(lcs2(s1, s2))",
    "def lcs(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    dp = [[0 for x in range(n+1)] for y in range(m+1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n\nif __name__ == \"__main__\":\n    str1 = \"ACBDGH\"\n    str2 = \"AEDFHR\"\n    print(lcs(str1, str2))",
    "def lcs(x: list[int], y: list[int]) -> list[int]:\n    \"\"\"\n    >>> lcs([1, 2, 3, 4, 5], [3, 5, 6, 7, 8])\n    [3, 5]\n    >>> lcs([1, 2, 3, 4, 5], [3, 6, 7, 8])\n    [3]\n    \"\"\"\n    # dp[i][j] stores the LCS of x[:i] and y[:j]\n    dp = [[0] * (len(y) + 1) for _ in range(len(x) + 1)]\n\n    # base case\n    for i in range(len(x) + 1):\n        for j in range(len(y) + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif x[i - 1] == y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # backtracking\n    res = []\n    i, j = len(x), len(y)\n    while i > 0 and j > 0:\n        if x[i - 1] == y[j - 1]:\n            res.append(x[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return res[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(x: list, y: list):\n    \"\"\"\n    >>> longest_common_subsequence([1,2,3,4], [2,1,3,4])\n    [[2, 1, 3, 4]]\n    >>> longest_common_subsequence([1,2,3,4], [2,3,1,4])\n    [[2, 3, 1, 4]]\n    \"\"\"\n    if not x or not y:\n        return []\n    if len(x) == 1 or len(y) == 1:\n        return [[i] for i in x if i in y]\n    x_head, *x_tail = x\n    y_head, *y_tail = y\n    if x_head == y_head:\n        return longest_common_subsequence(x_tail, y_tail) + [[x_head]]\n    x_tail_longest_common_subsequence = longest_common_subsequence(x_tail, y)\n    y_tail_longest_common_subsequence = longest_common_subsequence(x, y_tail)\n    return (\n        x_tail_longest_common_subsequence\n        if len(x_tail_longest_common_subsequence)\n        > len(y_tail_longest_common_subsequence)\n        else y_tail_longest_common_subsequence\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    :param s1: first string\n    :param s2: second string\n    :return: longest common subsequence\n    \"\"\"\n    m = len(s1)\n    n = len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    s1 = \"abcde\"\n    s2 = \"ace\"\n    assert longest_common_subsequence(s1, s2) == 3",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    O(n*m) & O(n*m)\n    \"\"\"\n    if not a or not b:\n        return 0\n\n    dp = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]\n    max_len = 0\n\n    for i in range(1, len(a) + 1):\n        for j in range(1, len(b) + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            max_len = max(max_len, dp[i][j])\n\n    return max_len\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == 3",
    "def longest_common_subsequence(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[-1][-1]\n\n\ndef longest_common_subsequence_eff(s1, s2):\n    m = len(s1)\n    n = len(s2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else:\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[-1][-1]\n\n\ndef main():\n    s1 = \"abcde\"\n    s2 = \"ace\"\n    s3 = \"abc\"\n    print(longest_common_subsequence(s1, s2))\n    print(longest_common_subsequence_eff(s1, s2))\n    print(longest_common_subsequence(s3, s2))\n    print(longest_common_sub",
    "def lcs(x, y):\n    \"\"\"\n    >>> lcs('abc', 'abc')\n    'abc'\n    >>> lcs('abc', 'def')\n    ''\n    >>> lcs('abc', 'ac')\n    'ac'\n    \"\"\"\n    m = len(x)\n    n = len(y)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif x[i - 1] == y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return x[i - dp[i][j] : i]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(seq1: list, seq2: list) -> list:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not seq1 or not seq2:\n        return []\n\n    dp = [[0] * (len(seq2) + 1) for _ in range(len(seq1) + 1)]\n\n    for i in range(1, len(seq1) + 1):\n        for j in range(1, len(seq2) + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    result = []\n    i, j = len(seq1), len(seq2)\n    while i > 0 and j > 0:\n        if seq1[i - 1] == seq2[j - 1]:\n            result.append(seq1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return result[::-1]\n\n\nif __name__ == \"__main__\":\n    seq1 = [1, 2, 3, 4, 1]\n    seq2 = [2, 4, 1, 3, 5]\n    print(longest_common_subsequence(seq1, seq2))",
    "def longest_common_subsequence(a, b):\n    m = len(a)\n    n = len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    a = \"abcde\"\n    b = \"ace\"\n    print(longest_common_subsequence(a, b))",
    "def lcs(s1, s2):\n    n = len(s1)\n    m = len(s2)\n\n    # create a 2d array to store the lcs\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    print(lcs(\"abcde\", \"ace\"))\n    print(lcs(\"abc\", \"abc\"))",
    "def longest_common_subsequence(X, Y):\n    m = len(X)\n    n = len(Y)\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n\n\ndef main():\n    X = \"abcdefgh\"\n    Y = \"aebd\"\n    print(longest_common_subsequence(X, Y))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def lcs_rec(string1, string2, m, n):\n    if m == 0 or n == 0:\n        return 0\n    elif string1[m-1] == string2[n-1]:\n        return 1 + lcs_rec(string1, string2, m-1, n-1)\n    else:\n        return max(lcs_rec(string1, string2, m, n-1), lcs_rec(string1, string2, m-1, n))\n\n\ndef lcs_memo(string1, string2, m, n):\n    lcs_memo = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if string1[i-1] == string2[j-1]:\n                lcs_memo[i][j] = 1 + lcs_memo[i-1][j-1]\n            else:\n                lcs_memo[i][j] = max(lcs_memo[i-1][j], lcs_memo[i][j-1])\n    return lcs_memo[m][n]\n\n\ndef lcs_tab(string1, string2):\n    m = len(string1)\n    n = len(string2)\n    lcs_tab = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if string1[i-1] == string2[j-1]:\n                lcs_tab[i][j] = 1 + lcs_tab[i-1][j-1]\n            else:\n                lcs_tab[i][j] = max(lcs_tab[i-1][j], lcs_tab[i][j-1])\n    return lcs_tab[m][n]\n\n\ndef print_lcs(string1, string2, m, n):\n    if m == 0 or n",
    "def longest_common_subsequence(s1, s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    dp = [[0 for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n\n    for i in range(1, n1 + 1):\n        for j in range(1, n2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    s1 = \"abcde\"\n    s2 = \"ace\"\n    print(longest_common_subsequence(s1, s2))",
    "from typing import List, Tuple\n\n\ndef lcs_rec(\n    seq1: List[int], seq2: List[int], index1: int, index2: int\n) -> Tuple[List[int], int]:\n    if index1 == -1 or index2 == -1:\n        return [], 0\n    if seq1[index1] == seq2[index2]:\n        subseq, length = lcs_rec(seq1, seq2, index1 - 1, index2 - 1)\n        return subseq + [seq1[index1]], length + 1\n    else:\n        subseq1, length1 = lcs_rec(seq1, seq2, index1, index2 - 1)\n        subseq2, length2 = lcs_rec(seq1, seq2, index1 - 1, index2)\n        return (subseq1, length1) if length1 > length2 else (subseq2, length2)\n\n\ndef lcs_dp(seq1: List[int], seq2: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    m = len(seq1)\n    n = len(seq2)\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    subseq: List[int] = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if seq1[i - 1] == seq2[j - 1]:\n            subseq.append(seq1[i - 1])\n            i -= 1",
    "def longest_common_subsequence(first: str, second: str) -> str:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if len(first) == 0 or len(second) == 0:\n        return \"\"\n\n    dp = [[0] * (len(second) + 1) for _ in range(len(first) + 1)]\n\n    for i in range(1, len(first) + 1):\n        for j in range(1, len(second) + 1):\n            if first[i - 1] == second[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = len(first), len(second)\n    result = []\n    while i > 0 and j > 0:\n        if first[i - 1] == second[j - 1]:\n            result.append(first[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(reversed(result))\n\n\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"ace\"))\n    print(longest_common_subsequence(\"abc\", \"def\"))",
    "from typing import List\n\n\ndef longest_common_subsequence(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    dp = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]\n\n    for i in range(1, len(a) + 1):\n        for j in range(1, len(b) + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = len(a), len(b)\n    sequence = []\n\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            sequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return list(reversed(sequence))\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence([1, 2, 3, 4], [2, 4]) == [2, 4]\n    assert longest_common_subsequence([1, 2, 3, 4], [2, 3, 4, 5]) == [2, 3, 4]\n    assert longest_common_subsequence(\n        [1, 2, 3, 4], [2, 3, 4, 5, 6]\n    ) == [2, 3, 4]\n    assert longest_common_subsequence([1, 2, 3, 4], [1, 2, 3, 4]) ==",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    :param a: a list\n    :param b: a list\n    :return: an int\n    \"\"\"\n    return 0\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = longest_common_subsequence(test_input[0], test_input[1])\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function(([1, 2, 3, 4, 1, 0, 5, 6, 7, 8, 9, 1, 2, 3, 4, 1, 0, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9]))\ntest_function(([1, 2, 3, 4, 1, 0, 5, 6, 7, 8, 9, 1, 2, 3, 4, 1, 0, 5, 6, 7, 8, 9], [1, 2, 3, 4, 1, 2, 3, 4]))\ntest_function(([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4], [1, 2, 3, 4, 1, 2, 3, 4]))\ntest_function(([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1,",
    "def lcs(X, Y):\n    \"\"\"\n    >>> lcs(\"abcdefgh\", \"abcefgh\")\n    'abcdefgh'\n\n    >>> lcs(\"abcdefgh\", \"acdfegh\")\n    'acdfegh'\n    \"\"\"\n    m = len(X)\n    n = len(Y)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    subsequence = []\n    while i > 0 and j > 0:\n        if X[i - 1] == Y[j - 1]:\n            subsequence.append(X[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    return \"\".join(reversed(subsequence))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def longest_common_subsequence(first, second):\n    longest = 0\n    longest_sequence = []\n    for i in range(len(first)):\n        for j in range(len(second)):\n            if first[i] == second[j]:\n                if i != 0 and j != 0:\n                    if longest <= 1 + lcs(first, second, i - 1, j - 1):\n                        longest = 1 + lcs(first, second, i - 1, j - 1)\n                        longest_sequence = [first[i]] + lcs(first, second, i - 1, j - 1)\n                elif i == 0 and j == 0:\n                    longest = 1\n                    longest_sequence = [first[i]]\n                elif i == 0 and j != 0:\n                    longest = 1 + lcs(first, second, i, j - 1)\n                    longest_sequence = [first[i]] + lcs(first, second, i, j - 1)\n                elif i != 0 and j == 0:\n                    longest = 1 + lcs(first, second, i - 1, j)\n                    longest_sequence = [first[i]] + lcs(first, second, i - 1, j)\n    return longest_sequence\n\n\ndef lcs(first, second, i, j):\n    if i == 0 or j == 0:\n        return []\n    if first[i] == second[j]:\n        return [first[i]] + lcs(first, second, i - 1, j - 1)\n    else:\n        return max(lcs(first, second, i - 1, j), lcs(first, second, i, j - 1), key=len)\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == [\"a\", \"c\", \"e\"]",
    "def longest_common_subsequence(seq1, seq2):\n    # The basic idea is to create a new matrix that will contain the length of the longest\n    # common subsequence for every pair of elements in the two sequences.\n    # The matrix will have a shape of len(seq1) + 1 by len(seq2) + 1.\n    # The first row and first column of the matrix are filled with 0.\n    # Then we will start from the second row and the second column and work our way down to\n    # the end.\n    # We will check every element in the two sequences and we will update the value in the\n    # current cell of the matrix.\n    # If the two elements are the same, the value will be equal to 1 + the value in the\n    # upper left cell.\n    # If the two elements are different, the value will be equal to the maximum of the\n    # values in the cells to the left and above of the current cell.\n    # If we reach the end of either sequence, we will break out of the loop.\n    # The value in the last cell of the matrix will be the length of the longest common\n    # subsequence.\n    # We will have to return the longest common subsequence itself.\n    # To do this, we will create a list with the length of the longest common subsequence,\n    # and we will start from the last cell of the matrix and work our way up to the first\n    # row.\n    # Every time we update the value in a cell, we will check the value in the cell above\n    # and to the left.\n    # If the value in the cell above is equal to the value in the current cell, we will\n    # append the element in the current cell to the longest common subsequence.\n    # If the value in the cell above is greater than the value in the current cell, we will\n    # add the element in the current cell to the longest common subsequence.\n    # We will do this until we reach the first row.\n    # If the value in the cell to the left is greater than the value in the current cell,\n    # we will add the element in the current cell to the longest common subsequence.\n    # We will do this until we reach the first column.",
    "from typing import List\n\n\ndef longest_common_subsequence(s1: str, s2: str) -> List[str]:\n    \"\"\"\n    Dynamic programming solution.\n    Time complexity: O(m * n)\n    Space complexity: O(m * n)\n    \"\"\"\n    m, n = len(s1), len(s2)\n\n    # dp[i][j] means the length of longest common subsequence between s1[:i] and s2[:j]\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    res = []\n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            res.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        else:\n            if dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n    return res[::-1]\n\n\nif __name__ == \"__main__\":\n    assert longest_common_subsequence(\"abcde\", \"ace\") == [\"a\", \"c\", \"e\"]",
    "def longest_common_subsequence(a, b):\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n\n    Parameters\n    ----------\n    a: list\n        A list of integers\n\n    b: list\n        A list of integers\n\n    Returns\n    -------\n    list\n        The longest common subsequence.\n\n    \"\"\"\n    if not a or not b:\n        return []\n\n    n = len(a)\n    m = len(b)\n\n    # dp[i][j] represents the longest common subsequence of a[:i] and b[:j]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the longest common subsequence\n    i, j = n, m\n    result = []\n    while i and j:\n        if a[i - 1] == b[j - 1]:\n            result.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return list(reversed(result))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}