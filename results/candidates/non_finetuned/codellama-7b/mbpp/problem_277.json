{
  "problem": {
    "task_id": "MBPP/288",
    "prompt": "Write a function to count array elements having modular inverse under given prime number p equal to itself.",
    "canonical_solution": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element",
    "test_list": [
      "assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2",
      "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3",
      "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1"
    ],
    "challenge_test_list": [],
    "problem_id": 277
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from typing import List\n\n\ndef count_modular_inverse_equals_itself(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if num % p == p - 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_modular_inverse_equals_itself([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 11) == 4\n    assert count_modular_inverse_equals_itself([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 13) == 2\n    assert count_modular_inverse_equals_itself([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 17) == 3",
    "from typing import List\n\n\ndef count_inverse_elements(primes: List[int], arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n    for element in arr:\n        count += 1 if element % primes[-1] == primes[-1] - primes[0] else 0\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_inverse_elements([3, 5, 7], [1, 3, 2, 6, 7, 5]) == 3",
    "from typing import List\n\n\ndef count_inversions(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    return count_inversions_recursive(arr, 0, len(arr), p)\n\n\ndef count_inversions_recursive(arr: List[int], start: int, end: int, p: int) -> int:\n    if end - start <= 1:\n        return 0\n\n    mid: int = (end - start) // 2 + start\n\n    count_left: int = count_inversions_recursive(arr, start, mid, p)\n    count_right: int = count_inversions_recursive(arr, mid, end, p)\n    count_swap: int = count_swap_inversions(arr, start, mid, end, p)\n\n    return count_left + count_right + count_swap\n\n\ndef count_swap_inversions(arr: List[int], start: int, mid: int, end: int, p: int) -> int:\n    result: int = 0\n\n    left_index: int = start\n    right_index: int = mid\n\n    while left_index < mid and right_index < end:\n        left_element: int = arr[left_index]\n        right_element: int = arr[right_index]\n\n        if left_element < right_element:\n            left_index += 1\n            continue\n\n        if left_element > right_element:\n            right_index += 1\n            continue\n\n        if left_element % p == right_element % p:\n            left_index += 1\n            right_index += 1\n            continue\n\n        while left_index < mid and arr[left_index] % p == left_element % p:\n            left_index += 1\n\n        while right_index < end and arr[right_index] % p == right_element % p:\n            right_index += 1\n\n        result += mid - left_index\n\n    return result\n\n\nif __name__ == \"__main",
    "from typing import List\n\n\ndef count_inverse_elements_in_array(array: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    result = 0\n\n    for i in array:\n        if pow(i, -1, p) == i:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert count_inverse_elements_in_array([1, 2, 3, 4, 5], 5) == 2\n    assert count_inverse_elements_in_array([2, 3, 4, 5, 6], 7) == 3",
    "from math import gcd\n\n\ndef count_self_inverse(arr, p):\n    count = 0\n\n    for i in arr:\n        if gcd(i, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = list(map(int, input().split()))\n    p = int(input())\n    print(count_self_inverse(arr, p))",
    "from gfg.search.hash_tables.disjoint_set import DisjointSet\nfrom gfg.trees.binary_utils import BinaryTreeNode\n\n\ndef find_modular_inverse(p: int, num: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def helper(num: int) -> int:\n        nonlocal count, p\n        if num == 1:\n            count += 1\n            return 1\n\n        if num % 2 == 0:\n            return helper(num // 2)\n\n        return helper(num * p - 1)\n\n    count = 0\n    helper(num)\n    return count\n\n\ndef modular_inverse_count(num: int, p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    disjoint_set = DisjointSet(num)\n\n    for i in range(1, num + 1):\n        if i % p == 0:\n            disjoint_set.union(i, i // p)\n\n    return disjoint_set.count_sets()\n\n\ndef main():\n    p = 5\n    num = 21\n    print(find_modular_inverse(p, num))\n    print(modular_inverse_count(num, p))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def count_inv(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] * arr[j] % p == arr[i] % p):\n                count += 1\n    return count\n\n\ndef main():\n    arr = [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17]\n    print(count_inv(arr, 17))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def count_inv(arr, p):\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (arr[i] * arr[j] % p == arr[i]):\n                count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_inv([1, 2, 3, 4], 5))\n    print(count_inv([1, 2, 4, 4], 5))",
    "from typing import List\n\n\ndef count_mod_inverse_self(arr: List[int], p: int) -> int:\n    \"\"\"\n    Count the number of elements in the array that have their modular inverse equal to themselves\n    under given prime number p.\n    \"\"\"\n    # check if given array is empty\n    if not arr:\n        return 0\n\n    # check if given array is already sorted\n    if arr == sorted(arr):\n        return 1\n\n    # sort the array in-place\n    arr.sort()\n\n    # initialize count\n    count = 0\n\n    # initialize the index of the first element\n    first_index = 0\n\n    # initialize the index of the last element\n    last_index = len(arr) - 1\n\n    # iterate over the array\n    while first_index <= last_index:\n        # check if the first element is a modular inverse of itself under given prime number\n        if pow(arr[first_index], p - 2, p) == 1:\n            # increment the count\n            count += 1\n\n            # increment the index of the first element\n            first_index += 1\n        else:\n            # decrement the index of the last element\n            last_index -= 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_mod_inverse_self([1, 2, 3, 4, 5], 5))",
    "from collections import Counter\n\ndef count_mod_inverse_self(arr, p):\n    \"\"\"\n    :param: arr - input array\n    :param: p - prime number\n    return - array element count with mod inverse p equal to itself\n    \"\"\"\n    count = Counter()\n\n    for i in arr:\n        count[i] += 1\n\n    return len([count[i] for i in count if i**(-1) % p == i])\n\ndef test_function(test_case):\n    arr = test_case[0]\n    p = test_case[1]\n    solution = test_case[2]\n    output = count_mod_inverse_self(arr, p)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\narr = [1, 2, 3, 4, 2]\np = 3\nsolution = 3\ntest_case = [arr, p, solution]\ntest_function(test_case)\n\narr = [1, 2, 3, 4, 2]\np = 2\nsolution = 3\ntest_case = [arr, p, solution]\ntest_function(test_case)",
    "def modular_inverse(arr, p):\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if arr[i]**(p-2) % p == arr[i]:\n            count += 1\n    return count\n\n\narr = [2, 3, 4, 5, 6, 7, 8, 9, 10]\np = 11\nprint(modular_inverse(arr, p))",
    "def count_inverse(arr, p):\n    count = 0\n    for i in arr:\n        if i * i % p == i:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    print(count_inverse([2, 3, 4, 5, 6, 7], 3))",
    "def count_self_inverse_elements(arr, p):\n    count = 0\n    for el in arr:\n        if el % p == 0:\n            count += 1\n        else:\n            count += 1 if self_inverse_exists(el, p) else 0\n\n    return count\n\n\ndef self_inverse_exists(x, p):\n    if x == 0:\n        return False\n    if x == 1:\n        return True\n\n    x_inv = pow(x, p - 2, p)\n    return x_inv == 1\n\n\nprint(count_self_inverse_elements([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 19))",
    "def modular_inverse(arr, p):\n    count = 0\n    for num in arr:\n        if num % p == 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 4, 7, 8, 11, 13, 16, 19, 22, 25, 26, 29, 31, 34, 37]\n    p = 7\n    print(modular_inverse(arr, p))",
    "def count_elements(A, p):\n    c = 0\n    for i in range(len(A)):\n        if A[i] % p == A[i]:\n            c += 1\n    return c\n\n\ndef main():\n    A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    p = 3\n    print(count_elements(A, p))\n\n\nif __name__ == '__main__':\n    main()",
    "from gfg.dynamic_programming.fib import get_fibonacci_huge\n\n\ndef modular_inverse_count(arr: list, p: int) -> int:\n    size = len(arr)\n    fib = get_fibonacci_huge(size, p)\n\n    # arr[i] = a^i, a = arr[0]\n    # a^i = a * a^(i-1)\n    # a^i mod p = a mod p * a^(i-1) mod p\n    # a^i mod p = fib[i] * a^(i-1) mod p\n    # a^(i-1) mod p = a mod p * a^(i-2) mod p\n    # a^(i-2) mod p = a mod p * a^(i-3) mod p\n    # ...\n    # a^i mod p = fib[i] * a^(i-1) mod p = a mod p * a^(i-1) mod p * a^(i-2) mod p * a^(i-3) mod p * ...\n\n    result = 0\n\n    for i in range(size):\n        result += fib[i]\n\n    return result % p\n\n\nif __name__ == \"__main__\":\n    print(modular_inverse_count([2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5], 7))\n    print(modular_inverse_count([2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5], 11))",
    "from typing import List\n\n\ndef count_self_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5], 5) == 2",
    "from typing import List\nfrom collections import Counter\n\n\ndef count_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    O(n) and O(n)\n    \"\"\"\n    cnt = Counter(arr)\n    result = 0\n\n    for key, value in cnt.items():\n        if pow(key, -1, p) == key:\n            result += value * (value - 1) // 2\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert count_inverse([2, 3, 2, 3, 2, 5], 5) == 8\n    assert count_inverse([2, 3, 2, 3, 2, 5], 7) == 0",
    "def count_inverse_mod(arr, p):\n    count = 0\n    for i in range(len(arr)):\n        if (p - arr[i]) % p == arr[i]:\n            count += 1\n    return count\n\n\nprint(count_inverse_mod([2, 3, 4, 5], 5))",
    "class Solution:\n    def count_self_inverse(self, arr, p):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] ** (p - 2) % p == arr[i]:\n                count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    p = 5\n    s = Solution()\n    print(s.count_self_inverse(arr, p))",
    "def count_mod_inverse(arr, p):\n    count = 0\n    for i in arr:\n        if (i * i) % p == 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    p = 5\n    print(count_mod_inverse(arr, p))",
    "def mod_count(arr, p):\n    count = 0\n    for i in arr:\n        if i % p == p - 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 2, 6, 1, 2, 3, 4, 5, 3]\n    p = 5\n    print(mod_count(arr, p))",
    "from typing import List\n\n\ndef count_self_inverse_mod(arr: List[int], prime: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    count = 0\n\n    for el in arr:\n        if pow(el, 2, prime) == el:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse_mod([1, 2, 3, 4, 5], 3) == 3\n    assert count_self_inverse_mod([2, 3, 4, 5], 5) == 4",
    "def count_modular_inverse(array, p):\n    if len(array) == 0:\n        return 0\n\n    count = 0\n\n    for element in array:\n        if element % p == p - 1:\n            count += 1\n\n    return count\n\n\ndef main():\n    print(count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], 3))\n    print(count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], 5))\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef count_mod_inverse_elements(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    count = 0\n\n    for i in arr:\n        if i * i % p == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_mod_inverse_elements([1, 2, 3, 4, 5], 5) == 2",
    "from typing import List\nfrom gfg.divide_and_conquer.modular_division import modular_division\n\n\ndef count_self_modular_inverse(elements: List[int], p: int) -> int:\n    result = 0\n\n    for element in elements:\n        if modular_division(element, p) == element:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(count_self_modular_inverse([2, 3, 4, 5, 6, 8], 3))",
    "def count_self_inverse_under_given_prime(array, p):\n    return [sum([1 for i in array if (i ** -1) % p == i])]\n\n\nassert count_self_inverse_under_given_prime([2, 3, 6, 3], 7) == [3]\nassert count_self_inverse_under_given_prime([2, 3, 6, 3], 11) == [4]",
    "from typing import List\n\n\ndef count_self_inverse(array: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param array: array of numbers\n    :param p: prime number\n    :return: number of elements in array having modular inverse equal to itself under given prime number p\n    \"\"\"\n\n    count = 0\n    for number in array:\n        if (number - 1) % p == 0:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5], 3) == 3",
    "from typing import List\n\n\ndef count_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count: int = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_inverse([1, 2, 3, 4, 5, 6, 7], 7) == 2",
    "def count_inverse_mod(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        if (arr[i] % p == arr[i]):\n            count += 1\n\n    return count\n\nif __name__ == \"__main__\":\n    print(count_inverse_mod([4, 7, 5, 9, 9, 9, 9, 9], 9))",
    "from typing import List\n\n\ndef count_self_inverse_array(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse_array([2, 3, 4, 5, 7, 8, 11, 13, 14], 13) == 3",
    "from typing import List\n\n\ndef count_elements(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count: int = 0\n\n    for num in arr:\n        if pow(num, p - 2, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_elements([1, 2, 3, 4, 5], 5) == 2\n    assert count_elements([1, 2, 3, 4, 5], 7) == 3\n    assert count_elements([1, 2, 3, 4, 5], 11) == 4",
    "from typing import List\n\n\ndef count_inverse_mod(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    count = 0\n    hash_map = {}\n\n    for num in arr:\n        if num in hash_map:\n            count += hash_map[num]\n        else:\n            count += 1\n            hash_map[num] = 1\n\n        if p in hash_map:\n            hash_map[p] += 1\n        else:\n            hash_map[p] = 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_inverse_mod([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 2) == 10",
    "def count_mod(arr, p):\n    count = 0\n    for i in range(len(arr)):\n        if arr[i]**(p-2)%p == 1:\n            count+=1\n    return count\n\nif __name__ == '__main__':\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    p = 11\n    print(count_mod(arr, p))",
    "from gfg.arrays.find_prime import prime_factors\n\n\ndef count_elements(a: list, p: int) -> int:\n    count = 0\n    for i in a:\n        if pow(i, -1, p) == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_elements([2, 3, 4, 5, 6, 7, 8, 9], 3))\n    print(count_elements([1, 2, 3, 4, 5, 6, 7, 8, 9], 3))",
    "from math import gcd\n\n\ndef count_elements_with_modular_inverse(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for element in arr:\n        if gcd(element, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_elements_with_modular_inverse([1, 2, 3, 4, 5], 2))\n    print(count_elements_with_modular_inverse([1, 2, 3, 4, 5], 5))",
    "def count_modular_inverse_elements(arr, p):\n    count = 0\n    for i in arr:\n        if pow(i, p-2, p) == 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 13),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 15),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 17)\n    ]\n    for test_case in test_cases:\n        print(count_modular_inverse_elements(test_case[0], test_case[1]))",
    "def count_inv(arr, p):\n    inv_map = dict()\n    count = 0\n    for num in arr:\n        if num in inv_map:\n            count += inv_map[num]\n        else:\n            inv_num = pow(num, p-2, p)\n            count += inv_map[inv_num]\n            inv_map[num] = inv_map.get(inv_num, 0) + 1\n    return count\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    p = 11\n    print(count_inv(arr, p))",
    "from typing import List\nfrom gfg.dynamic_programming.subset_sum.subset_sum_recur import subset_sum_recur\n\n\ndef count_inverse_modulo(arr: List[int], n: int, p: int) -> int:\n    \"\"\"\n    Time complexity: O(2^n)\n    Space complexity: O(n)\n    \"\"\"\n    if n == 1:\n        return 0\n\n    total_inverse_modulo = 0\n\n    for i in range(1, n):\n        subset_sum = subset_sum_recur(arr, i, n)\n\n        for s in subset_sum:\n            if s % p == 0:\n                total_inverse_modulo += 1\n\n    return total_inverse_modulo\n\n\nif __name__ == \"__main__\":\n    print(count_inverse_modulo([3, 2, 4], 3, 2))",
    "def count_mod(array, p):\n    count = 0\n    for i in array:\n        if i % p == i:\n            count += 1\n    return count\n\n\nassert count_mod([1, 2, 3, 4, 5], 3) == 3\nassert count_mod([2, 4, 6, 8], 2) == 4",
    "def count_self_inverse(array, p):\n    count = 0\n\n    for i in range(len(array)):\n        if array[i] % p == array[i] and array[i] != 0:\n            count += 1\n\n    return count\n\narray = [1, 2, 3, 4, 5, 6, 7]\nprint(count_self_inverse(array, 3))",
    "from typing import List\n\n\ndef count_element(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for i in arr:\n        if i % p == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_element([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], 3) == 8",
    "from typing import List\n\n\ndef modular_inverse_count(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    result = 0\n\n    for i in arr:\n        if i % p == p - 1:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert modular_inverse_count([1, 2, 3, 4, 5], 5) == 1\n    assert modular_inverse_count([2, 3, 4, 5, 6], 5) == 3",
    "def count_self_inverse(arr, p):\n    count = 0\n    for i in arr:\n        if i % p == i:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 3))\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 5))\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 7))\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 11))\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 13))\n    print(count_self_inverse([2, 3, 4, 5, 6, 7, 8, 9], 17))",
    "def count_inverse_modulo(array, p):\n    array_set = set(array)\n    count = 0\n    for i in array_set:\n        if i ** (p - 2) % p == i:\n            count += array.count(i)\n    return count\n\n\nif __name__ == \"__main__\":\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    p = 17\n    print(count_inverse_modulo(array, p))",
    "from typing import List\n\n\ndef count_self_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if num % p == p - num % p:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5], 5) == 3",
    "def count_modular_inverse_elements(p, array):\n    count = 0\n    for i in array:\n        if i % p == p - 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    p = 7\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert count_modular_inverse_elements(p, array) == 4",
    "from collections import Counter\n\n\ndef count_elements(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    counter = Counter(arr)\n    return sum(\n        counter[i] * counter[i * p] for i in range(1, p) if i in counter\n    )\n\n\nif __name__ == \"__main__\":\n    assert count_elements([1, 2, 3, 4, 3, 2, 1], 3) == 5",
    "from typing import List\n\n\ndef count_self_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5, 3, 1], 7) == 3",
    "from gfg.algorithms.maths.extended_gcd import extended_gcd\n\n\ndef count_modular_inverse_equal_to_self(p, arr):\n    result = 0\n\n    for num in arr:\n        if extended_gcd(num, p)[1] == 1:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(count_modular_inverse_equal_to_self(7, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(count_modular_inverse_equal_to_self(5, [1, 2, 3, 4, 5, 6, 7, 8, 9]))",
    "def count_modular_inverse(arr, p):\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] % p == arr[i]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    p = 3\n    assert count_modular_inverse(arr, p) == 6",
    "from gfg.dynamic_programming.fibonacci import get_fib\n\n\ndef mod_inverse_count(arr: list, p: int) -> int:\n    n = len(arr)\n    result = 0\n\n    for i in range(n):\n        if get_fib(i) % p == arr[i] % p:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(mod_inverse_count([1, 2, 3, 4, 5, 6, 7, 8, 9], 3))",
    "from typing import List\n\n\ndef count_self_inverse(arr: List[int], prime: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for elem in arr:\n        if pow(elem, 2, prime) == elem:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5, 6, 7], 11) == 3",
    "from typing import List\nfrom gfg.trees.tree_utils import Node\nfrom gfg.trees.binary_tree_traversal import preorder, inorder\n\n\ndef count_equal_mod(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    res = 0\n\n    for element in arr:\n        if (element % p) * (p - 1) == p - 1:\n            res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    p = 3\n\n    print(count_equal_mod(arr, p))",
    "from typing import List\n\n\ndef count_self_inverse_array(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for element in arr:\n        if element % p == p - element % p:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse_array([1, 2, 3, 4, 5], 5) == 3\n    assert count_self_inverse_array([1, 1, 1, 1, 1], 5) == 1\n    assert count_self_inverse_array([1, 2, 3, 4, 5, 6], 7) == 0",
    "def count_self_inverse(arr, p):\n    count = 0\n\n    for i in range(len(arr)):\n        if arr[i] % p == arr[i]**2 % p:\n            count += 1\n\n    return count\n\n\nprint(count_self_inverse([1, 2, 3, 4, 5], 3))\nprint(count_self_inverse([1, 2, 3, 4, 5], 5))",
    "from typing import List\nfrom math import gcd\n\n\ndef count_self_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    count = 0\n    for num in arr:\n        if gcd(num, p) == 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([2, 3, 6, 7], 3) == 2",
    "def count_inverse_equal_to_self(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    count = 0\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_inverse_equal_to_self([2, 7, 1, 8, 4], 3) == 3",
    "from math import gcd\n\n\ndef count_mod(arr, p):\n    count = 0\n\n    for i in range(len(arr)):\n        if gcd(arr[i], p) == 1:\n            count += 1\n\n    return count\n\n\ndef main():\n\n    arr = list(map(int, input(\"Enter the array elements: \").split()))\n    p = int(input(\"Enter the prime number: \"))\n\n    print(f\"Array elements having modular inverse under prime number {p} equal to itself are: {count_mod(arr, p)}\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "def count_inverse_elements(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        if arr[i] ** 2 % p == arr[i] % p:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_inverse_elements([2, 3, 4, 5, 2], 5))",
    "def count_modular_inverse(a, p):\n    \"\"\"\n    Time Complexity: O(n*p)\n    Space Complexity: O(n)\n    \"\"\"\n    mod_inverse = [0] * (p + 1)\n    count = [0] * (p + 1)\n    for i in range(1, p + 1):\n        mod_inverse[i] = i * i % p\n        count[i] = 1\n    for i in range(1, p + 1):\n        for j in range(i * 2, p + 1, i):\n            count[j] += count[i]\n    return count[a]\n\n\ndef count_modular_inverse2(a, p):\n    \"\"\"\n    Time Complexity: O(p)\n    Space Complexity: O(p)\n    \"\"\"\n    count = [0] * (p + 1)\n    count[a] = 1\n    for i in range(2, p + 1):\n        if count[i] == 0:\n            continue\n        for j in range(i * 2, p + 1, i):\n            count[j] += count[i]\n    return count[a]\n\n\nif __name__ == \"__main__\":\n    a, p = 3, 11\n    print(count_modular_inverse(a, p))\n    print(count_modular_inverse2(a, p))\n\n    a, p = 4, 13\n    print(count_modular_inverse(a, p))\n    print(count_modular_inverse2(a, p))\n\n    a, p = 6, 17\n    print(count_modular_inverse(a, p))\n    print(count_modular_inverse2(a, p))",
    "from gfg.dynamic_programming.fibonacci import get_fibonacci_last_digit\n\n\ndef modular_inverse_count(arr, p):\n    n = len(arr)\n    count = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        count[i] = (get_fibonacci_last_digit(i) + count[i - 1]) % p\n\n    total = 0\n\n    for i in range(n):\n        if arr[i] % p == count[i]:\n            total += 1\n\n    return total\n\n\nif __name__ == \"__main__\":\n    print(modular_inverse_count([1, 2, 3, 4, 5], 5))",
    "from typing import List\n\n\ndef count_inverse_elements(arr: List[int], p: int) -> int:\n    \"\"\"\n    O(n) and O(1) extra space\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        if (arr[i] ** 2) % p == arr[i] % p:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_inverse_elements([1, 1, 2, 2, 3, 3, 4, 5], 5) == 4",
    "def count_self_inverses(array, p):\n    return len([num for num in array if num % p == num])\n\n\narray = [2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(count_self_inverses(array, 3))\nprint(count_self_inverses(array, 5))\nprint(count_self_inverses(array, 7))\nprint(count_self_inverses(array, 9))\nprint(count_self_inverses(array, 11))",
    "from gfg.dynamic_programming.number_of_ways_to_climb_stairs import num_ways_to_climb_stairs\n\n\ndef count_modular_inverse(a: int, p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if a == 0:\n        return 1\n\n    num_ways_to_climb_stairs(a, p)\n\n    return a % p\n\n\nif __name__ == \"__main__\":\n    print(count_modular_inverse(5, 3))\n    print(count_modular_inverse(10, 3))\n    print(count_modular_inverse(12, 11))",
    "def count_equal_inverses(array: list, p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    count: int = 0\n\n    for i in array:\n        if pow(i, -1, p) == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_equal_inverses([2, 3, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 21, 22, 23, 25, 26, 27, 29, 31, 32, 33, 34], 17) == 10",
    "from math import gcd\n\n\ndef count_mod(arr, p):\n    count = 0\n    for x in arr:\n        if gcd(x, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [3, 2, 4, 5, 6, 8, 7, 3]\n    p = 5\n    assert count_mod(arr, p) == 4",
    "from typing import List\nfrom math import gcd\n\n\ndef count_mod(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    ans = 0\n\n    for num in arr:\n        if gcd(num, p) == 1:\n            ans += 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    assert count_mod([2, 4, 3, 6, 3, 2, 4, 6], 3) == 6",
    "from collections import defaultdict\n\ndef count_self_inverse(arr, p):\n    \"\"\"\n    :param: arr - input array\n    :param: p - prime number\n    return - number of elements in arr which have modular inverse equal to itself\n    \"\"\"\n    count = 0\n    count_dict = defaultdict(int)\n\n    for num in arr:\n        if num == 0:\n            count += 1\n        elif num % p == 0:\n            count += 1\n        elif num % p == num:\n            count += 1\n\n    return count\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    p = test_case[1]\n    solution = test_case[2]\n    output = count_self_inverse(arr, p)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\narr = [0, 1, 2, 3, 4, 5]\np = 11\nsolution = 4\ntest_case = [arr, p, solution]\ntest_function(test_case)\n\narr = [1, 3, 2, 4, 2]\np = 3\nsolution = 3\ntest_case = [arr, p, solution]\ntest_function(test_case)",
    "def count_inverse_modulo(array, p):\n    # write your code here\n    count = 0\n    for i in array:\n        if i % p == i:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    print(\"Example:\")\n    print(count_inverse_modulo([2, 3, 4, 7, 8, -4, 13, 8, 11], 7))\n\n    # These \"asserts\" are used for self-checking and not for an auto-testing\n    assert count_inverse_modulo([2, 3, 4, 7, 8, -4, 13, 8, 11], 7) == 4\n    assert count_inverse_modulo([-2, 0, 0, 0, 3, 0, 0, 0, 0], 5) == 1\n    assert count_inverse_modulo([2, 4, 6, 8], 2) == 4\n    print(\"Coding complete? Click 'Check' to earn cool rewards!\")",
    "from typing import List\n\n\ndef count_inv(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    def sort_arr(arr: List[int]) -> List[int]:\n        for i in range(len(arr) - 1):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n    def mod_inv(a: int, m: int) -> int:\n        return pow(a, m - 2, m)\n\n    def binary_search(arr: List[int], l: int, r: int, x: int) -> int:\n        if r >= l:\n            mid = (l + r) // 2\n            if arr[mid] == x:\n                return mid\n            if arr[mid] > x:\n                return binary_search(arr, l, mid - 1, x)\n            return binary_search(arr, mid + 1, r, x)\n        return -1\n\n    def count_inv_recursive(arr: List[int], n: int, p: int) -> int:\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0 if arr[0] == arr[1] else 1\n\n        x = arr[n - 1]\n        i = binary_search(arr, 0, n - 2, x)\n\n        count_inv_left = count_inv_recursive(arr[:i], i, p)\n        count_inv_right = count_inv_recursive(arr[i + 1 :], n - i - 1, p)\n        count_inv_cross = (\n            n - i - 1\n        ) * (\n            n - i - 2\n        ) - count_inv_right\n        return count_inv_left + count_inv_right + count_inv_cross\n\n    count = count_inv_recursive(sort_arr",
    "from typing import List\n\n\ndef count_inversions(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    temp = [0 for _ in range(n)]\n\n    def merge_sort(l: int, r: int):\n        if r - l <= 1:\n            return\n\n        m = (l + r) // 2\n        merge_sort(l, m)\n        merge_sort(m, r)\n        merge(l, m, r)\n\n    def merge(l: int, m: int, r: int):\n        i = l\n        j = m\n        k = l\n        while i < m and j < r:\n            if arr[i] * p + 1 == arr[j]:\n                temp[k] = arr[i]\n                i += 1\n                j += 1\n            elif arr[i] * p + 1 < arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                j += 1\n            k += 1\n        while i < m:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        while j < r:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n\n        for k in range(l, r):\n            arr[k] = temp[k]\n\n    merge_sort(0, n)\n    return merge_sort(0, n)\n\n\nif __name__ == \"__main__\":\n    assert count_inversions([2, 3, 5, 7, 8, 10, 12, 14], 2) == 5\n    assert count_inversions([3, 5, 7, 9, 11, 13], 3) == 6\n    assert count_inversions([2, 3, 5, 7, 8, 10, 12",
    "from typing import List\n\n\ndef count_self_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse([1, 2, 3, 4, 5, 3, 1], 7) == 3",
    "from gfg.dynamic_programming.subset_sum import knapsack\nfrom typing import List\n\n\ndef count_equal_modular_inverse(arr: List[int], p: int) -> int:\n    length = len(arr)\n\n    dp = [[0 for _ in range(length + 1)] for _ in range(length + 1)]\n\n    for i in range(length + 1):\n        dp[i][0] = 1\n\n    for i in range(1, length + 1):\n        for j in range(1, length + 1):\n            if i == j:\n                dp[i][j] = dp[i - 1][j]\n            elif arr[i - 1] % p == arr[j - 1] % p:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n\n    return dp[length][length]\n\n\nif __name__ == \"__main__\":\n    print(count_equal_modular_inverse([1, 2, 3, 4, 5, 6, 7], 2))",
    "def count_mod_inverse_elements(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param arr: list of integers\n    :param p: prime number\n    :return: count of elements in the list that have modular inverse under p equal to itself\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        if pow(arr[i], 2, p) == arr[i]:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_mod_inverse_elements([1, 2, 3, 4], 5) == 1\n    assert count_mod_inverse_elements([1, 2, 3, 4], 3) == 2\n    assert count_mod_inverse_elements([1, 2, 3, 4], 4) == 3\n    assert count_mod_inverse_elements([1, 2, 3, 4], 101) == 3\n    assert count_mod_inverse_elements([1, 2, 3, 4], 1011) == 4\n    assert count_mod_inverse_elements([1, 2, 3, 4], 10111) == 3",
    "def count_mod(arr, p):\n    count = 0\n    for i in arr:\n        if i % p == p-1:\n            count += 1\n    return count\n\n\nif __name__ == '__main__':\n    n = int(input())\n    arr = list(map(int, input().split()))\n    p = int(input())\n\n    print(count_mod(arr, p))",
    "from typing import List\n\n\ndef count_modular_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for i in arr:\n        if i % p == p - 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 3) == 6\n    assert count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5) == 5",
    "from typing import List\n\n\ndef count_modular_inverses(numbers: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in numbers:\n        if pow(num, p - 2, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_modular_inverses([2, 3, 4, 5, 7], 13) == 3",
    "from gfg.dynamic_programming.one_away_edit import edit_distance\n\n\ndef count_elements_with_inverse(arr, p):\n    \"\"\"\n    Using edit distance.\n    Time Complexity: O(n*p)\n    Space Complexity: O(n)\n    \"\"\"\n    count = [0] * p\n\n    for i in range(len(arr)):\n        if arr[i] < p:\n            count[arr[i]] += 1\n\n    count[0] += count[p-1]\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_elements_with_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9], 11))",
    "from typing import List\n\n\ndef count_modular_inverse(arr: List[int], p: int) -> int:\n    \"\"\"\n    >>> count_modular_inverse([1, 2, 3, 4, 5, 6, 7], 7)\n    1\n    >>> count_modular_inverse([1, 2, 3, 4, 5, 6, 7], 11)\n    4\n    >>> count_modular_inverse([1, 2, 3, 4, 5, 6, 7], 13)\n    2\n    \"\"\"\n    count = 0\n\n    for i in arr:\n        if i % p == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef count_elements(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count: int = 0\n\n    for num in arr:\n        if pow(num, -1, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 4\n    assert count_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) == 10",
    "def count_modular_inverse(arr, p):\n    count = 0\n\n    for i in arr:\n        if (i * i) % p == i:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 11))\n    print(count_modular_inverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 13))",
    "from gfg.maths.gcd import gcd\n\n\ndef count_elements_with_mod_inverse(arr: list, p: int) -> int:\n    count = 0\n    for i in range(len(arr)):\n        if gcd(arr[i], p) == 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_elements_with_mod_inverse([2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22], 3))",
    "def count_inversions(arr, p):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    temp = [0] * n\n\n    return merge_count_inversions(arr, temp, 0, n - 1, p)\n\n\ndef merge_count_inversions(arr, temp, left, right, p):\n    if left >= right:\n        return 0\n\n    mid = (left + right) // 2\n    left_count = merge_count_inversions(arr, temp, left, mid, p)\n    right_count = merge_count_inversions(arr, temp, mid + 1, right, p)\n\n    count = merge_count(arr, temp, left, mid, right, p)\n\n    return left_count + right_count + count\n\n\ndef merge_count(arr, temp, left, mid, right, p):\n    i = left\n    j = mid + 1\n    k = left\n\n    count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] * p == arr[j]:\n            count += 1\n            temp[k] = arr[i]\n            i += 1\n        elif arr[i] * p < arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n\n        k += 1\n\n    while i <= mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n\n    return count\n\n\nassert count_inversions([1, 2, 3, 4, 5], 2) == 1\nassert count_inversions([2, 4, 1, 3, 5], 2) ==",
    "from gfg.dynamic_programming.fibonacci import get_fibonacci_last_digit\n\n\ndef count_mod_inverse_equal_to_self(arr: list, p: int) -> int:\n    \"\"\"\n    Time complexity: O(n).\n    Space complexity: O(1).\n    \"\"\"\n    count = 0\n\n    for i in arr:\n        if i % p == get_fibonacci_last_digit(i, p):\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_mod_inverse_equal_to_self([3, 5, 7, 11, 13, 17, 19], 3))",
    "from collections import Counter\n\n\ndef count_inverse(arr, p):\n    counter = Counter(x % p for x in arr)\n    return sum(v*(v-1)//2 for v in counter.values())\n\n\nif __name__ == \"__main__\":\n    arr = [2, 5, 2, 2, 3, 4, 2, 2, 2]\n    p = 3\n    print(count_inverse(arr, p))",
    "from typing import List\n\n\ndef modular_inverse_count(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for x in arr:\n        if pow(x, p - 2, p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert modular_inverse_count([2, 4, 5, 3, 2, 4, 3], 5) == 3",
    "def count_same_mod(p, arr):\n    count = 0\n    for i in arr:\n        if (i * i) % p == i:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_same_mod(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(count_same_mod(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    print(count_same_mod(13, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))",
    "def count_self_inverse(array, p):\n    count = 0\n    for element in array:\n        if element % p == 0:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the number of elements in the array: \"))\n    array = list(map(int, input(\"Enter the array elements separated by spaces: \").strip().split()))[:n]\n    p = int(input(\"Enter the prime number p: \"))\n    print(count_self_inverse(array, p))",
    "from typing import List\n\n\ndef count_mod(arr: List[int], p: int) -> int:\n    \"\"\"\n    >>> count_mod([2, 3, 4, 7, 8, 9, 14, 15, 16], 11)\n    3\n    >>> count_mod([2, 3, 4, 7, 8, 9, 14, 15, 16], 17)\n    5\n    \"\"\"\n    mod_count = 0\n\n    for i in range(len(arr)):\n        if arr[i] % p == arr[i]:\n            mod_count += 1\n\n    return mod_count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from gfg.search.hash_tables import check_prime\nfrom typing import List\n\n\ndef count_modular_inverse(arr: List[int], p: int) -> int:\n    if not check_prime(p):\n        raise ValueError(\"P is not a prime number\")\n\n    count = 0\n\n    for num in arr:\n        if num % p == p - 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_modular_inverse([1, 2, 3, 4, 5, 6, 7], 3))",
    "from gfg.dynamic_programming.one_away_edit import edit_distance\n\n\ndef count_equal_mod_inverse(nums: list, p: int) -> int:\n    count = 0\n    for num in nums:\n        if edit_distance(str(num), str(num % p)) == 0:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_equal_mod_inverse([2, 3, 4, 5, 7, 8, 10, 11, 12, 14, 15, 17], 13))",
    "def count_mod_inverse(p, arr):\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] % p == p - 1:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    p = 5\n    arr = [0, 1, 2, 3, 4, 5]\n    print(count_mod_inverse(p, arr))",
    "def count_mod(arr, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    for i in range(n):\n        if arr[i] % p == 1:\n            count += 1\n\n    return count\n\nif __name__ == \"__main__\":\n    print(count_mod([1, 1, 2, 3, 4, 5, 6, 6, 6, 6], 3))",
    "from typing import List\n\n\ndef count_self_inverse_mod(nums: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in nums:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse_mod([1, 2, 3, 4, 5], 3) == 3",
    "def count_equal_mod(p, arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n    for elem in arr:\n        if (elem * p) % p == elem:\n            count += 1\n    return count",
    "from typing import List\n\n\ndef count_mod(arr: List[int], prime: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    mod_count: int = 0\n    for num in arr:\n        if num % prime == 1:\n            mod_count += 1\n    return mod_count\n\n\nif __name__ == \"__main__\":\n    assert count_mod([1, 2, 3, 4, 5, 6, 7], 2) == 4\n    assert count_mod([1, 2, 3, 4, 5, 6, 7], 3) == 3\n    assert count_mod([1, 2, 3, 4, 5, 6, 7], 5) == 2\n    assert count_mod([1, 2, 3, 4, 5, 6, 7], 7) == 1\n    assert count_mod([1, 2, 3, 4, 5, 6, 7], 11) == 0",
    "def count_mod_inverse(a, p):\n    if a == 0:\n        return 0\n    count = 0\n    for i in range(a):\n        if (i * a) % p == i:\n            count += 1\n    return count\n\n\ndef main():\n    a, p = map(int, input().strip().split(' '))\n    print(count_mod_inverse(a, p))\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef count_self_inverse_mod(arr: List[int], p: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if pow(num, 2, p) == num:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert count_self_inverse_mod([1, 2, 3, 4, 5, 3, 2, 1], 3) == 3\n    assert count_self_inverse_mod([2, 3, 4, 2, 3, 2], 5) == 3",
    "def count_elements(arr, p):\n    \"\"\"\n    :param: arr - input array\n    :param: p - prime number\n    return: count - number of elements having modular inverse under given prime number p equal to itself\n\n    >>> count_elements([1,2,3,4,5,6,7,8,9,10], 3)\n    4\n    \"\"\"\n    count = 0\n    for i in arr:\n        if (i ** (p - 2) % p) == 1:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}