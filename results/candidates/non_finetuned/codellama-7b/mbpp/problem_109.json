{
  "problem": {
    "task_id": "MBPP/120",
    "prompt": "Write a function to find the maximum product from the pairs of tuples within a given list.",
    "canonical_solution": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max",
    "test_list": [
      "assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36",
      "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200",
      "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"
    ],
    "challenge_test_list": [],
    "problem_id": 109
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def max_product(list_of_tuples):\n    \"\"\"\n    >>> max_product([(1,2), (2,3), (3,4), (1,3), (1,4), (2,4)])\n    12\n    >>> max_product([(1,2), (1,4), (2,3), (3,4), (1,3), (2,4)])\n    12\n    >>> max_product([(1,2), (1,4), (2,3), (3,4), (1,3)])\n    8\n    \"\"\"\n    return max(\n        [\n            min(tuple_1[0] * tuple_2[0], tuple_1[0] * tuple_2[1], tuple_1[1] * tuple_2[0], tuple_1[1] * tuple_2[1])\n            for tuple_1 in list_of_tuples\n            for tuple_2 in list_of_tuples\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# O(n) time | O(n) space\ndef maxProduct(listOfTuples):\n    if len(listOfTuples) < 2:\n        return None\n\n    maxProd = listOfTuples[0]\n    minProd = listOfTuples[0]\n\n    for i in range(1, len(listOfTuples)):\n        prod = listOfTuples[i]\n        maxProd, minProd = handleTuple(maxProd, minProd, prod)\n\n    return maxProd\n\n\ndef handleTuple(maxProd, minProd, prod):\n    prodMax = max(maxProd[0] * prod[0], maxProd[1] * prod[1])\n    prodMin = min(minProd[0] * prod[0], minProd[1] * prod[1])\n    return prodMax, prodMin",
    "def max_product(lst):\n    \"\"\"\n    Find the maximum product of pairs of tuples within a given list.\n\n    :param lst: list of tuples\n    :type lst: list\n    :return: maximum product of pairs of tuples\n    :rtype: int\n    \"\"\"\n    # If there is only one tuple in the list, return the first element of the tuple.\n    if len(lst) == 1:\n        return lst[0][0]\n\n    # Sort the list in descending order.\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n\n    # Get the maximum product of the first two tuples.\n    max_product_1 = lst[0][0] * lst[1][0]\n\n    # Get the maximum product of the last two tuples.\n    max_product_2 = lst[-1][0] * lst[-2][0]\n\n    # Get the maximum product of the three tuples.\n    max_product_3 = max(max_product_1, max_product_2)\n\n    # Get the maximum product of the four tuples.\n    max_product_4 = lst[0][0] * lst[-1][0]\n\n    # Return the maximum of the maximum products.\n    return max(max_product_3, max_product_4)\n\n\nprint(max_product([(2, 5), (2, 3), (3, 4), (2, 2)]))",
    "from typing import List\n\n\ndef max_product(tuples: List[List[int]]) -> int:\n    \"\"\"\n    The function returns the maximum product of tuples in the list.\n    >>> max_product([[1, 2], [4, 5], [5, 6]])\n    60\n    >>> max_product([[5, 4], [2, 3], [1, 2]])\n    24\n    >>> max_product([[5, 4], [2, 3], [2, 2]])\n    24\n    \"\"\"\n    tuples.sort(key=lambda x: x[1])\n    return max(tuples[0][0] * tuples[1][0], tuples[0][0] * tuples[1][1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def max_prod(tuples):\n    if not tuples:\n        return None\n\n    tuples.sort()\n    first_tuple = tuples[0]\n    second_tuple = tuples[1]\n\n    first_tuple_max = first_tuple[0] * first_tuple[1]\n    second_tuple_max = second_tuple[0] * second_tuple[1]\n\n    return max(first_tuple_max, second_tuple_max)\n\n\nprint(max_prod([(1, 2), (3, 4), (5, 6)]))\nprint(max_prod([(1, 2), (3, 4), (5, 6), (-1, 1)]))\nprint(max_prod([(1, 2), (-1, 1), (5, 6)]))",
    "from typing import List\n\n\ndef max_product_of_two(l: List[tuple]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    l.sort(key=lambda x: x[0])\n    if len(l) % 2:\n        return max(l[-1][1] * l[-2][1], l[-1][1] * l[-3][1])\n    else:\n        return l[-1][1] * l[-2][1]\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_two([(1, 2), (2, 3), (1, 3)]) == 6",
    "from typing import List, Tuple\n\n\ndef max_product(lst: List[Tuple[int, int]]) -> int:\n    \"\"\"Returns the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (List[Tuple[int, int]]): list of tuples\n\n    Examples:\n        >>> assert max_product([(1, 2), (2, 3), (1, 4)]) == 12\n        >>> assert max_product([(1, 2), (2, 3), (1, 4), (1, 5)]) == 20\n    \"\"\"\n    lst.sort(key=lambda x: x[0])\n\n    if lst[0][0] < 0:\n        return max(lst[0][1] * lst[1][1], lst[0][1] * lst[1][0])\n    elif lst[-1][0] > 0:\n        return max(lst[-1][0] * lst[-2][0], lst[-1][1] * lst[-2][1])\n    else:\n        return max(\n            max(lst[0][1] * lst[1][1], lst[0][1] * lst[1][0]),\n            max(lst[-1][1] * lst[-2][1], lst[-1][1] * lst[-2][0]),\n        )\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (2, 3), (1, 4), (1, 5)]))",
    "def max_product(arr):\n    # sort the list in descending order\n    arr.sort(reverse=True)\n\n    # initialize two variables\n    max_product = 0\n    min_product = 0\n\n    # iterate through the list\n    for i in range(len(arr)):\n        # if the first number is smaller than the second number, swap the numbers\n        if arr[i][0] < arr[i][1]:\n            temp = arr[i][0]\n            arr[i][0] = arr[i][1]\n            arr[i][1] = temp\n\n        # calculate the product of the first and last number\n        product = arr[i][0] * arr[i][-1]\n\n        # if the product is greater than the maximum product, set the product to the maximum product\n        if product > max_product:\n            max_product = product\n\n        # if the product is smaller than the minimum product, set the product to the minimum product\n        if product < min_product:\n            min_product = product\n\n    # return the maximum product\n    return max(max_product, min_product)\n\n\nprint(max_product([(1, 2), (3, 4), (5, 6)]))\nprint(max_product([(1, 2), (2, 3), (5, 6)]))\nprint(max_product([(1, 2), (3, 4), (5, 6), (10, 11), (12, 13)]))\nprint(max_product([(1, 2), (3, 4), (5, 6), (10, 11), (12, 13), (14, 15)]))\nprint(max_product([(1, 2), (3, 4), (5, 6), (10, 11), (12, 13), (14, 15), (16, 17)]))",
    "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n    arr.sort(key=lambda x: x[1])\n    return max(arr[0][0] * arr[1][0], arr[-1][0] * arr[-2][0])\n\n\ndef main():\n    print(max_product([(1, 2), (2, 3)]))\n    print(max_product([(1, 2), (2, 3), (1, 1), (1, 2), (2, 3)]))\n    print(max_product([(1, 2), (2, 3), (1, 1), (1, 2), (2, 3), (1, 2), (2, 3)]))\n    print(max_product([(1, 2), (2, 3), (1, 1), (1, 2), (2, 3), (1, 2), (2, 3), (1, 2), (2, 3)]))\n    print(max_product([(1, 2), (2, 3), (1, 1), (1, 2), (2, 3), (1, 2), (2, 3), (1, 2), (2, 3), (1, 2), (2, 3)]))\n\n\nif __name__ == '__main__':\n    main()",
    "def max_product(lst):\n    \"\"\"\n    >>> max_product([(2, 1), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7)])\n    298\n    >>> max_product([(2, 1), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7)])\n    298\n    >>> max_product([(2, 1), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7)])\n    298\n    >>> max_product([(2, 1), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5, 7), (4, 8), (2, 4), (2, 7), (0, 3), (5,",
    "from itertools import permutations\n\n\ndef maximum_product(numbers):\n    \"\"\"\n    Time Complexity: O(n^2)\n    Space Complexity: O(n)\n\n    :param numbers: List[int]\n    :return: int\n    \"\"\"\n    # find all permutations of the list\n    all_permutations = list(permutations(numbers, 2))\n\n    # get all the products of the tuples\n    products = [a * b for a, b in all_permutations]\n\n    # return the max of the products\n    return max(products)\n\n\nprint(maximum_product([2, 7, 4, 1, 8, 1]))",
    "# O(nlogn) time | O(n) space\ndef maxProduct(list):\n    list.sort()\n    maxProduct = list[-1]\n    for i in range(len(list) - 1):\n        product = list[i] * list[i + 1]\n        maxProduct = max(product, maxProduct)\n    return maxProduct",
    "def max_product(tuples: list) -> int:\n    \"\"\"Returns the maximum product of tuples in a list.\n\n    Args:\n        tuples (list): list of tuples.\n\n    Examples:\n        >>> assert max_product([(1, 2), (4, 5), (7, 8)]) == 24\n        >>> assert max_product([(1, 2), (7, 8), (4, 5)]) == 24\n        >>> assert max_product([(1, 2), (7, 8), (4, 5), (2, 3)]) == 24\n    \"\"\"\n    tuples = sorted(tuples, key=lambda x: x[1])\n\n    return max(\n        tuples[0][0] * tuples[1][0],\n        tuples[0][0] * tuples[1][1],\n        tuples[0][1] * tuples[1][1],\n    )\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (4, 5), (7, 8)]))",
    "def find_max_product(tuples):\n    \"\"\"\n    >>> find_max_product([(1,2), (2,3), (2,4), (1, 5)])\n    12\n    >>> find_max_product([(2, 1), (1, 2), (3, 4), (2, 3), (1, 3)])\n    12\n    >>> find_max_product([(1, 2), (2, 3), (3, 4), (4, 5)])\n    48\n    \"\"\"\n    tuples.sort(key=lambda t: t[0])\n    return max(\n        tuples[i][0] * tuples[i + 1][1],\n        tuples[i][1] * tuples[i + 1][0],\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def max_product(tuples):\n    tuples.sort(key=lambda x: x[1])\n    print(tuples)\n    return max(tuples[0][0] * tuples[-1][0], tuples[0][0] * tuples[1][0])\n\n\nprint(max_product([(1, 2), (2, 3), (3, 4)]))\nprint(max_product([(2, 3), (1, 2), (3, 4)]))\nprint(max_product([(2, 3), (3, 4), (1, 2)]))",
    "from typing import List\n\n\ndef max_product(list_: List) -> int:\n    \"\"\"Returns the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        list_ (List): list of tuples\n\n    Examples:\n        >>> assert max_product([(2, 4), (5, 6), (7, 8)]) == 112\n    \"\"\"\n    list_.sort(key=lambda x: x[0])\n    return max(\n        list_[-1][0] * list_[-2][1],\n        list_[-1][1] * list_[-2][0],\n        list_[-2][0] * list_[-3][1],\n        list_[-2][1] * list_[-3][0],\n    )\n\n\nif __name__ == \"__main__\":\n    print(max_product([(2, 4), (5, 6), (7, 8)]))",
    "from typing import List, Tuple\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef get_max_product(lst: List[Tuple[int, int]]) -> int:\n    if not lst:\n        return None\n\n    max_pos = max(lst, key=lambda x: x[0])\n    min_neg = min(lst, key=lambda x: x[0])\n\n    return max(max_pos[0] * max_pos[1], min_neg[0] * min_neg[1])\n\n\nif __name__ == \"__main__\":\n    assert get_max_product([(1, 2), (2, 3)]) == 6\n    assert get_max_product([(1, -2), (-2, -3)]) == -6\n    assert get_max_product([(-1, -2), (-2, -3)]) == 6\n    assert get_max_product([(1, -2), (-2, 3)]) == 6",
    "from typing import List\n\n\ndef max_product(lst: List[tuple]) -> int:\n    \"\"\"Returns the maximum product of a pair of tuples within a given list.\n\n    Args:\n        lst (List[tuple]): list of tuples\n\n    Examples:\n        >>> assert max_product([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 90\n    \"\"\"\n    lst.sort(key=lambda x: x[0])\n\n    max_1 = max(lst[0][0] * lst[1][0], lst[0][0] * lst[1][1])\n    max_2 = max(lst[1][0] * lst[2][0], lst[1][0] * lst[2][1])\n\n    return max(max_1, max_2)\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]))",
    "from itertools import combinations\n\n\ndef max_product(tuples):\n    \"\"\"Returns the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        tuples: list of tuples\n\n    Returns:\n        int: maximum product from the pairs of tuples within a given list\n\n    \"\"\"\n    return max(\n        [\n            product(pair)\n            for pair in combinations(tuples, 2)\n        ]\n    )\n\n\ndef product(tuples):\n    \"\"\"Returns the product of the tuples.\n\n    Args:\n        tuples: tuple\n\n    Returns:\n        int: product of the tuples\n\n    \"\"\"\n    return tuples[0] * tuples[1]",
    "from typing import List, Tuple\n\n\n# O(n) time | O(n) space\ndef max_product_of_two(array: List[Tuple[int, int]]) -> int:\n    array.sort(key=lambda x: x[0])\n\n    first = 0\n    second = 1\n    first_product = array[first][0] * array[first][1]\n    second_product = array[second][0] * array[second][1]\n\n    while first < len(array) - 1 and second < len(array):\n        if array[first][1] * array[second][0] > first_product:\n            first_product = array[first][1] * array[second][0]\n        if array[first][1] * array[second][1] > first_product:\n            first_product = array[first][1] * array[second][1]\n        if array[first][0] * array[second][1] > second_product:\n            second_product = array[first][0] * array[second][1]\n        if array[first + 1][0] * array[second][1] > second_product:\n            second_product = array[first + 1][0] * array[second][1]\n        first += 1\n        second += 1\n\n    return max(first_product, second_product)\n\n\nif __name__ == \"__main__\":\n    print(max_product_of_two([(1, 2), (2, 3), (3, 4), (4, 5)]))",
    "from typing import List\n\n\n# Time Complexity O(nlogn)\n# Space Complexity O(1)\ndef max_product(arr: List[List[int]]) -> int:\n    arr.sort()\n\n    first_num, second_num = arr[-1]\n    max_product = first_num * second_num\n\n    first_num, second_num = arr[-2]\n    max_product = max(first_num * second_num, max_product)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    arr = [[1, 2], [4, 5], [7, 8]]\n    print(max_product(arr))",
    "from itertools import combinations\n\n\ndef max_product_from_tuples(tuples):\n    max_product = 0\n    for tup1, tup2 in combinations(tuples, 2):\n        product = max(tup1[0] * tup2[0], tup1[0] * tup2[1], tup1[1] * tup2[0], tup1[1] * tup2[1])\n        if product > max_product:\n            max_product = product\n    return max_product\n\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (2, 3), (1, 4), (4, 5), (5, 6), (2, 7), (1, 8)]\n    print(max_product_from_tuples(tuples))",
    "from typing import List\n\n\ndef max_product(lst: List[tuple]) -> int:\n    \"\"\"Finds the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (List[tuple]): input list\n\n    Examples:\n        >>> assert max_product([(1, 2), (2, 3), (3, 4), (4, 5)]) == 12\n        >>> assert max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 24\n        >>> assert max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) == 30\n    \"\"\"\n    lst = sorted(lst, key=lambda x: x[0])\n    max_product = lst[0][0] * lst[0][1]\n    for i in range(1, len(lst)):\n        if lst[i][0] > lst[i - 1][1]:\n            max_product = max(max_product, lst[i][0] * lst[i][1])\n        else:\n            max_product = max(max_product, lst[i - 1][0] * lst[i][1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]))",
    "from typing import List\n\n\ndef max_product_of_pairs(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_pairs([1, -2, 3, 4]) == 12",
    "from typing import List, Tuple\n\n\ndef max_product_of_pairs(arr: List[int]) -> int:\n    arr.sort()\n\n    max_value = arr[-1] * arr[-2]\n\n    return max_value\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_pairs([1, 2, 3, 4, 5]) == 12\n    assert max_product_of_pairs([1, 2, 3, 4, 5, 6]) == 12\n    assert max_product_of_pairs([1, 2, 3, 4, 5, 6, 7, 8]) == 32\n    assert max_product_of_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 72",
    "from typing import List, Tuple\n\n\ndef max_product(arr: List[Tuple[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n\n    arr.sort()\n\n    return max(\n        arr[i][0] * arr[i + 1][0],\n        arr[i][0] * arr[i - 1][0],\n        arr[i][0] * arr[i + 1][1],\n        arr[i][0] * arr[i - 1][1],\n        arr[i][1] * arr[i + 1][0],\n        arr[i][1] * arr[i - 1][0],\n        arr[i][1] * arr[i + 1][1],\n        arr[i][1] * arr[i - 1][1],\n    )\n\n\nif __name__ == \"__main__\":\n    arr = [(1, 2), (4, 3), (5, 6), (7, 8)]\n    print(max_product(arr))\n\n    arr = [(1, 2), (4, 3), (5, 6), (7, 8), (9, 10)]\n    print(max_product(arr))\n\n    arr = [(1, 2), (4, 3), (5, 6), (7, 8), (9, 10), (11, 12)]\n    print(max_product(arr))",
    "from typing import List\n\n\ndef find_max_product(data: List[tuple]) -> int:\n    \"\"\"\n    Sorts the list by the first tuple value and then\n    iterates through the list and finds the maximum product\n    by multiplying the last tuple value with the previous tuple value\n    if the new tuple value is greater than the previous one.\n    \"\"\"\n    data.sort()\n\n    max_product = 0\n    prev_tuple = data[0]\n\n    for tuple_ in data[1:]:\n        if tuple_[0] > prev_tuple[0]:\n            max_product = max(max_product, prev_tuple[-1] * tuple_[-1])\n\n        prev_tuple = tuple_\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert find_max_product([(1, 3), (1, 4), (1, 5), (1, 6)]) == 9",
    "def max_product(tuples):\n    tuples.sort(key=lambda x: x[0])\n    return max(tuples[i][0] * tuples[i + 1][1], tuples[i][1] * tuples[i + 1][0])",
    "from typing import List\n\n\ndef max_product(lst: List) -> int:\n    lst.sort()\n\n    return max(lst[-1] * lst[-2], lst[0] * lst[1])\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 4, 0, 1, 3]))",
    "from typing import List, Tuple\n\n\ndef max_product_of_pairs(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    array.sort()\n\n    return max(\n        array[-1] * array[-2] + array[-3] * array[-4],\n        array[-1] * array[-2] + array[-3] * array[-5],\n    )\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_pairs([1, 2, 3, 4, 5, 6]) == 72",
    "from typing import List, Tuple\n\n\ndef maximum_product(arr: List[Tuple[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n    arr.sort()\n    max_1 = arr[-1][0] * arr[-2][1]\n    max_2 = arr[-2][0] * arr[-1][1]\n    return max(max_1, max_2)\n\n\nif __name__ == \"__main__\":\n    assert maximum_product([(1, 2), (3, 4), (5, 3), (2, 1), (1, 4)]) == 12",
    "def max_product(lst):\n    if len(lst) < 2:\n        return None\n\n    max_product = -float('inf')\n    max_product_indices = []\n\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if lst[i][0] * lst[j][1] > lst[j][0] * lst[i][1]:\n                if lst[i][0] * lst[j][1] > max_product:\n                    max_product = lst[i][0] * lst[j][1]\n                    max_product_indices = [i, j]\n            else:\n                if lst[j][0] * lst[i][1] > max_product:\n                    max_product = lst[j][0] * lst[i][1]\n                    max_product_indices = [j, i]\n\n    print(lst[max_product_indices[0]][0], lst[max_product_indices[0]][1], lst[max_product_indices[1]][0], lst[max_product_indices[1]][1])\n    return max_product\n\n\nif __name__ == '__main__':\n    assert max_product([(1, 2), (2, 3), (2, 1), (2, 3), (2, 1), (1, 2)]) == 12\n    assert max_product([(1, 2), (2, 3), (2, 1), (2, 3), (2, 1), (1, 2), (1, 3)]) == 12",
    "def max_product_tuples(tuples):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    tuples.sort()\n    return max(tuples[0][0] * tuples[-1][1], tuples[-1][0] * tuples[0][1])\n\n\nif __name__ == \"__main__\":\n    print(max_product_tuples([(2, 3), (-1, 2), (-3, 1), (3, 1)]))",
    "from functools import reduce\nfrom itertools import permutations\nfrom typing import List\n\n\ndef max_product_1(lst: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*n)\n    \"\"\"\n    max_product = -float(\"inf\")\n\n    for i, j in permutations(lst, 2):\n        max_product = max(max_product, *i, *j)\n\n    return max_product\n\n\ndef max_product_2(lst: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*n)\n    \"\"\"\n    max_product = -float(\"inf\")\n\n    for i, j in permutations(lst, 2):\n        max_product = max(max_product, reduce(lambda x, y: x * y, i), reduce(lambda x, y: x * y, j))\n\n    return max_product\n\n\ndef max_product_3(lst: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*n)\n    \"\"\"\n    max_product = -float(\"inf\")\n\n    for i in lst:\n        max_product = max(max_product, reduce(lambda x, y: x * y, i))\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_1([[1, 2], [3, 4]]) == 12\n    assert max_product_1([[2, 3], [5, 6], [7, 8]]) == 336\n\n    assert max_product_2([[1, 2], [3, 4]]) == 12\n    assert max_product_2([[2, 3], [5, 6], [7, 8]]) == 336\n\n    assert max_product_3([[1, 2], [3, 4]]) == 12\n    assert max_product_3([[2, 3], [5, 6], [7, 8]]) == 336",
    "def find_max_product(input_list):\n    \"\"\"\n    Given a list of tuples, find the maximum product of tuples.\n\n    Args:\n       input_list(list): List of tuples\n    Returns:\n       int: The maximum product of tuples\n    \"\"\"\n    input_list.sort(key=lambda x: x[0])\n    return max(\n        input_list[i][0] * input_list[i+1][1]\n        for i in range(len(input_list) - 1)\n    )\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = find_max_product(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3), (10, 5), (2, 10)], 60))\ntest_function(([(1, 2), (2, 3)], 6))\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3), (10, 5)], 30))\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3)], 12))\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3), (10, 5), (2, 10), (6, 7)], 120))\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3), (10, 5), (2, 10), (6, 7), (9, 10)], 180))\ntest_function(([(1, 2), (2, 3), (3, 4), (1, 3), (10, 5), (2, 10), (6, 7), (9",
    "from typing import List\n\n\ndef max_product_of_pairs(array: List[int]) -> int:\n    \"\"\"\n    First sort the list in descending order\n    Then start from the first and last and check the product of each pair\n    If the product is greater than the max, update the max\n    \"\"\"\n    array.sort(reverse=True)\n\n    max_product = -1\n    for i in range(len(array) - 1):\n        product = array[i] * array[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_pairs([1, 2, 3, 4, 5]) == 12\n    assert max_product_of_pairs([-1, -2, -3, -4, -5]) == -6\n    assert max_product_of_pairs([-10, 1, 2, 3, 4]) == 40\n    assert max_product_of_pairs([1, 2, 3, 4, -5]) == 24",
    "# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef findPairs(tree, k):\n    result = []\n    if tree is None:\n        return result\n    queue = [(tree, tree.value)]\n    while queue:\n        node, value = queue.pop(0)\n        if node.left:\n            queue.append((node.left, node.left.value))\n        if node.right:\n            queue.append((node.right, node.right.value))\n        if abs(value - k) in (node.value, node.right.value, node.left.value):\n            result.append([value, node.value])\n    return result",
    "def max_product_tuples(lst):\n    \"\"\"\n    We can sort the list in ascending order and pick the last two elements.\n    We can also sort the list in descending order and pick the first two elements.\n    In both the cases, we have to multiply the first element with the second last element.\n    \"\"\"\n    if not lst:\n        return None\n\n    lst.sort()\n    return lst[-1] * lst[-2]\n\n\ndef max_product_tuples_2(lst):\n    \"\"\"\n    We can also sort the list in descending order and then take the two highest elements.\n    We can also sort the list in ascending order and then take the two lowest elements.\n    In both the cases, we have to multiply the first element with the second highest element.\n    \"\"\"\n    if not lst:\n        return None\n\n    lst.sort()\n    lst.reverse()\n    return lst[0] * lst[1]",
    "def max_product(tuples):\n    tuples.sort(key=lambda x: x[0])\n    product_1 = tuples[0][0] * tuples[1][1]\n    product_2 = tuples[0][1] * tuples[1][0]\n    return max(product_1, product_2)\n\n\nprint(max_product([(1, 4), (2, 3)]))\nprint(max_product([(1, 1), (2, 2)]))\nprint(max_product([(1, 5), (2, 2), (3, 3), (4, 4)]))\nprint(max_product([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]))\nprint(max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]))",
    "from typing import List\nfrom itertools import combinations\n\n\n# Time Complexity: O(N^2)\n# Space Complexity: O(N)\ndef max_product_naive(list_of_tuples: List[tuple]) -> int:\n    max_product = 0\n\n    for i, j in combinations(list_of_tuples, 2):\n        if max_product < i[0] * j[0] and i[1] * j[1] > 0:\n            max_product = i[0] * j[0]\n        elif max_product < i[0] * j[1] and i[1] * j[0] > 0:\n            max_product = i[0] * j[1]\n        elif max_product < j[0] * i[1] and i[0] * j[1] > 0:\n            max_product = j[0] * i[1]\n        elif max_product < j[1] * i[0] and i[0] * j[1] > 0:\n            max_product = j[1] * i[0]\n\n    return max_product\n\n\n# Time Complexity: O(N)\n# Space Complexity: O(N)\ndef max_product_pythonic(list_of_tuples: List[tuple]) -> int:\n    min_tuple = min(list_of_tuples, key=lambda x: x[0] * x[1])\n    list_of_tuples.remove(min_tuple)\n\n    max_product = max(list_of_tuples, key=lambda x: x[0] * x[1])\n\n    return max_product[0] * max_product[1] * min_tuple[0] * min_tuple[1]\n\n\n# Time Complexity: O(N)\n# Space Complexity: O(1)\ndef max_product_dutch_flag_problem(list_of_tuples: List[tuple]) -> int:\n    max_product = 0\n\n    for i in range(len(list_of_tuples)):\n        for j in range(i + 1, len(list",
    "def max_product(nums):\n    nums.sort()\n    return nums[-1] * nums[-2]\n\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\n\"\"\"\nWrite a function to find the maximum product from the pairs of tuples within a given list.\n\"\"\"\n\ndef max_product(nums):\n    nums.sort()\n    return nums[-1] * nums[-2]\n\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
    "def max_product(tuples):\n    tuples.sort()\n    return max(tuples[0][0] * tuples[1][0], tuples[0][0] * tuples[1][1], tuples[0][1] * tuples[1][0], tuples[0][1] * tuples[1][1])\n\n\nprint(max_product([(1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (2, 4)]))\n\n\n\"\"\"\nThe idea here is to sort the list of tuples and then simply pick the maximum of the four possible products.\n\nThere is a problem with this solution, namely, it works only if all the tuples are positive.\nIn the case of negative tuples, it will return the wrong answer.\n\nWe need to consider the case when there are negative numbers.\n\nWe can sort the list by the first element of the tuples in ascending order and then find the maximum of the four possible products.\n\"\"\"\n\ndef max_product_v2(tuples):\n    tuples.sort(key = lambda t: t[0])\n    return max(tuples[0][0] * tuples[1][0], tuples[0][0] * tuples[1][1], tuples[0][1] * tuples[1][0], tuples[0][1] * tuples[1][1])\n\n\nprint(max_product_v2([(1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (2, 4)]))\nprint(max_product_v2([(-1, 2), (-2, 3), (-3, 4), (-1, 3), (-1, 4), (-2, 4)]))",
    "from functools import reduce\n\n\ndef max_prod_tuples(lst):\n    \"\"\"Return the maximum product from the pairs of tuples within a given list.\"\"\"\n    return reduce(lambda x, y: max(x, y),\n                  [reduce(lambda x, y: x * y, tup) for tup in lst])",
    "from typing import List, Tuple\n\n\ndef max_product_pairs(input: List[Tuple[int]]) -> int:\n    \"\"\"\n    O(nlogn) & O(n)\n    \"\"\"\n    sorted_input = sorted(input, key=lambda x: x[0])\n    max_product = -float(\"inf\")\n\n    for i in range(len(sorted_input)):\n        for j in range(i + 1, len(sorted_input)):\n            product = sorted_input[i][0] * sorted_input[j][0]\n            max_product = max(max_product, product)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_pairs([(1, 2), (4, 3), (5, -6)]) == 6\n    assert max_product_pairs([(1, 2), (-4, 3), (5, -6)]) == 18\n    assert max_product_pairs([(1, 2), (-4, 3), (-5, -6)]) == 9",
    "from typing import List\n\n\ndef max_product(array: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    array.sort(key=lambda x: x[0])\n\n    max_value = array[0][0] * array[0][1]\n    min_value = array[0][0] * array[0][1]\n\n    for i in range(1, len(array)):\n        first = array[i][0]\n        second = array[i][1]\n\n        if first >= second:\n            max_value = max(max_value, first * second)\n        else:\n            max_value = max(max_value, second * first)\n\n        min_value = min(min_value, first * second)\n\n    return max_value if max_value > min_value else min_value\n\n\nif __name__ == \"__main__\":\n    assert max_product([[2, 4], [5, 12], [1, 2], [2, 5]]) == 480\n    assert max_product([[1, 3], [2, 4], [5, 12], [1, 2], [2, 5]]) == 240\n    assert max_product([[1, 3], [2, 4], [5, 12], [1, 2], [2, 5], [3, 6]]) == 360",
    "from typing import List\n\n\ndef max_product_tuples(tuples: List[tuple]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    tuples_sorted = sorted(tuples, key=lambda x: x[1])\n    max_product = tuples_sorted[0][0] * tuples_sorted[0][1]\n\n    for i in range(len(tuples_sorted) - 1):\n        max_product = max(max_product, tuples_sorted[i][0] * tuples_sorted[i + 1][1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product_tuples([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]))\n    print(max_product_tuples([(1, 3), (2, 4), (5, 6), (7, 8), (9, 10)]))\n    print(max_product_tuples([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (10, 11)]))",
    "def max_product(lst):\n    # sort the list in ascending order\n    lst.sort()\n    # get the first and the last element of the list\n    first = lst[0]\n    last = lst[-1]\n    # return the maximum value\n    return max(first*last, first*last)\n\n\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9]))",
    "def max_product(tuples):\n    \"\"\"Returns the maximum product of tuples within a given list.\"\"\"\n    # get the length of the list\n    length = len(tuples)\n    # sort the list in ascending order\n    tuples = sorted(tuples)\n    # initialize the maximum product\n    max_product = 0\n    # loop through each tuple\n    for i in range(length):\n        # get the maximum product of the current tuple with the last tuple\n        max_product = max(max_product, tuples[i][0] * tuples[length - 1][1])\n        # get the maximum product of the current tuple with the next tuple\n        max_product = max(max_product, tuples[i][1] * tuples[i + 1][0])\n    # return the maximum product\n    return max_product\n\n\n# test case 1\ntuples = [(2, 1), (3, 4), (5, 1), (3, 4)]\nprint(max_product(tuples))  # 12\n\n# test case 2\ntuples = [(1, 2), (3, 4), (5, 1), (3, 4)]\nprint(max_product(tuples))  # 12\n\n# test case 3\ntuples = [(1, 2), (3, 4), (5, 1), (3, 4), (1, 2)]\nprint(max_product(tuples))  # 24\n\n# test case 4\ntuples = [(1, 2), (3, 4), (5, 1), (3, 4), (1, 2), (1, 2)]\nprint(max_product(tuples))  # 24",
    "from typing import List\n\n\ndef maximum_product(lst: List[List[int]]) -> int:\n    \"\"\"\n    O(nlogn) & O(1)\n    \"\"\"\n    lst.sort()\n    first_max = lst[-1][0] * lst[-2][1]\n    second_max = lst[-1][1] * lst[-2][0]\n\n    return max(first_max, second_max)\n\n\nif __name__ == \"__main__\":\n    lst = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    print(maximum_product(lst))",
    "def max_product(list_of_tuples):\n    list_of_tuples.sort(key=lambda x: x[0])\n    max_product = 0\n    for i in range(len(list_of_tuples)):\n        for j in range(i + 1, len(list_of_tuples)):\n            if list_of_tuples[i][0] <= list_of_tuples[j][0] and list_of_tuples[i][1] <= list_of_tuples[j][1]:\n                continue\n            else:\n                product = list_of_tuples[i][0] * list_of_tuples[j][1]\n                if product > max_product:\n                    max_product = product\n    return max_product\n\n\nlist_of_tuples = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nprint(max_product(list_of_tuples))",
    "def max_product(input_list):\n    \"\"\"\n    >>> max_product([(2,3),(7,8),(1,2)])\n    56\n    >>> max_product([(2,3),(7,8),(8,9)])\n    72\n    >>> max_product([(2,3),(7,8),(8,9),(2,3)])\n    72\n    \"\"\"\n    input_list = sorted(input_list)\n    max_product = input_list[-1][0] * input_list[-1][1]\n    for i in range(len(input_list)):\n        for j in range(i + 1, len(input_list)):\n            max_product = max(max_product, input_list[i][0] * input_list[j][1])\n    return max_product\n\n\ndef max_product_optimized(input_list):\n    \"\"\"\n    >>> max_product_optimized([(2,3),(7,8),(1,2)])\n    56\n    >>> max_product_optimized([(2,3),(7,8),(8,9)])\n    72\n    >>> max_product_optimized([(2,3),(7,8),(8,9),(2,3)])\n    72\n    \"\"\"\n    input_list = sorted(input_list)\n    max_product = input_list[-1][0] * input_list[-1][1]\n    max_num = input_list[-1][0]\n    min_num = input_list[-1][1]\n    for i in range(len(input_list)):\n        if input_list[i][0] > max_num:\n            max_num = input_list[i][0]\n        if input_list[i][1] < min_num:\n            min_num = input_list[i][1]\n        max_product = max(max_product, max_num * min_num)\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List, Tuple\n\n\ndef max_product(lst: List[Tuple[int]]) -> int:\n    \"\"\"\n    >>> max_product([(1, 2), (2, 3), (1, 4)])\n    9\n    >>> max_product([(1, 4), (2, 3), (1, 4)])\n    16\n    >>> max_product([(1, 4), (2, 3), (1, 4), (2, 3)])\n    16\n    >>> max_product([(1, 4), (2, 3), (1, 4), (2, 3), (1, 4), (2, 3)])\n    16\n    >>> max_product([(1, 4), (2, 3), (1, 4), (2, 3), (1, 4), (2, 3), (1, 4), (2, 3)])\n    16\n    >>> max_product([(1, 2), (2, 3), (1, 4), (2, 3), (1, 4), (2, 3), (1, 4), (2, 3)])\n    32\n    \"\"\"\n    lst.sort(key=lambda x: x[1])\n\n    max_product = float(\"-inf\")\n\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            max_product = max(max_product, lst[i][0] * lst[j][1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List, Tuple\n\n\ndef max_product(lst: List[Tuple[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n    lst.sort(key=lambda x: x[0])\n\n    max_product = -float(\"inf\")\n    for i in range(len(lst) - 1):\n        max_product = max(\n            max_product, lst[i][1] * lst[i + 1][1], lst[i][1] * lst[i][0]\n        )\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (2, 1), (3, 4), (2, 3)]))",
    "from typing import List\n\n\n# O(nlogn)\ndef maximum_product_naive(list_of_tuples: List[List[int]]) -> int:\n    \"\"\"\n    Return the maximum product of tuples from list_of_tuples\n\n    :param list_of_tuples: list of tuples of integers\n    :return: maximum product\n    >>> maximum_product_naive([(1,2),(1,2),(1,3),(1,4)])\n    24\n    >>> maximum_product_naive([(1,2),(1,2),(1,3),(1,4),(1,1)])\n    24\n    >>> maximum_product_naive([(1,1)])\n    1\n    >>> maximum_product_naive([(1,2),(1,2),(1,3),(1,4),(1,1),(-1,-1)])\n    2\n    >>> maximum_product_naive([(1,2),(1,2),(1,3),(1,4),(1,1),(1,1)])\n    2\n    >>> maximum_product_naive([(1,2),(1,2),(1,3),(1,4),(1,1),(1,1),(-1,-1)])\n    2\n    \"\"\"\n    list_of_tuples.sort(key=lambda x: x[0] + x[1])\n    return max(\n        list_of_tuples[-1][0] * list_of_tuples[-1][1],\n        list_of_tuples[0][0] * list_of_tuples[0][1],\n    )\n\n\n# O(n)\ndef maximum_product_optimized(list_of_tuples: List[List[int]]) -> int:\n    \"\"\"\n    Return the maximum product of tuples from list_of_tuples\n\n    :param list_of_tuples: list of tuples of integers\n    :return: maximum product\n    >>> maximum_product_optimized([(1,2),(1,2),(1,3),(1,4)])\n    24\n    >>> maximum_product_optimized([(1,2),(1,2),(1,3),(1",
    "def max_product(tuples):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    tuples.sort()\n    return max(tuples[i][0] * tuples[i + 1][0], tuples[i][1] * tuples[i + 1][1])\n\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (2, 3), (1, 4), (2, 6)]\n    print(max_product(tuples))",
    "def max_product_pairs(tuples):\n    tuples.sort(key=lambda x: x[0])\n    return max(tuples[i][0] * tuples[i + 1][0], tuples[i][0] * tuples[i + 1][1])\n\n\nprint(max_product_pairs([(3, 5), (2, 3), (1, 2), (1, 3)]))\nprint(max_product_pairs([(3, 5), (2, 3), (1, 2), (1, 3), (2, 5), (2, 1)]))\nprint(max_product_pairs([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]))",
    "def max_product(lst):\n    lst.sort()\n    return max(lst[-1] * lst[-2], lst[-1] * lst[-3])\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 4, 6, 8, 3, 5, 7, 9]))\n    print(max_product([1, 2, 3, 4, 5, 6, 7]))",
    "def max_product(arr):\n    \"\"\"\n    First, we need to sort the list, then we need to iterate through the list, and check if\n    the current element is bigger than the next. If it is, then we need to check if the current\n    element multiplied by the next element is bigger than the current maximum product. If it\n    is, then we need to replace the current maximum product with the current element multiplied\n    by the next element. If it isn't, then we need to check if the current element multiplied by\n    the previous element is bigger than the current maximum product. If it is, then we need to\n    replace the current maximum product with the current element multiplied by the previous\n    element. If it isn't, then we need to replace the current maximum product with the current\n    element multiplied by the previous element.\n    \"\"\"\n    arr.sort()\n    max_product = arr[0] * arr[1]\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            if arr[i] * arr[i + 1] > max_product:\n                max_product = arr[i] * arr[i + 1]\n        else:\n            if arr[i] * arr[i - 1] > max_product:\n                max_product = arr[i] * arr[i - 1]\n    return max_product\n\n\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\nprint(max_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\nprint(max_product([1",
    "from itertools import combinations\nfrom typing import List\n\n\n# Time complexity: O(n^2)\n# Space complexity: O(1)\ndef max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time complexity: O(n^2)\n    Space complexity: O(1)\n    \"\"\"\n    result = nums[0]\n\n    for num1, num2 in combinations(nums, 2):\n        result = max(result, num1 * num2)\n\n    return result\n\n\n# Time complexity: O(n^2)\n# Space complexity: O(1)\ndef max_product_with_min(nums: List[int]) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    min_nums = [nums[0]]\n\n    for i in range(1, len(nums)):\n        min_nums.append(min(nums[i], min_nums[i - 1] * nums[i]))\n\n    max_nums = [nums[0]]\n\n    for i in range(1, len(nums)):\n        max_nums.append(max(nums[i], max_nums[i - 1] * nums[i]))\n\n    return max(max_nums[-1], min_nums[-1])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_stack(nums: List[int]) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    result = nums[0]\n    stack = []\n\n    for num in nums:\n        if not stack or num > stack[-1]:\n            stack.append(num)\n        else:\n            while stack and num > stack[-1]:\n                result = max(result, stack.pop() * num)\n            stack.append(num)\n\n    if len(stack) == len(nums):\n        return result\n\n    stack.reverse()\n    return max(result, stack[0] * stack[1",
    "def max_product(tuples):\n    \"\"\"Returns the maximum product of pairs from tuples.\"\"\"\n    tuples = sorted(tuples)\n    return max(tuples[-1][0] * tuples[-1][1], tuples[0][0] * tuples[1][1])\n\n\nif __name__ == '__main__':\n    print(max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]))\n    print(max_product([(5, 2), (3, 5), (4, 4), (2, 6)]))\n    print(max_product([(1, 10), (2, 2), (4, 1)]))\n    print(max_product([(1, 1), (2, 2), (4, 1)]))",
    "from itertools import combinations\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef max_product(tuples):\n    \"\"\"\n    :param tuples: list of tuples\n    :return: maximum product\n\n    >>> max_product([(1, 2), (5, 6), (7, 8)])\n    16\n    >>> max_product([(1, 2), (5, 6), (7, 8), (1, 9)])\n    72\n    >>> max_product([(1, 2), (5, 6), (7, 8), (1, 9), (2, 3)])\n    84\n    \"\"\"\n    if not tuples:\n        return 0\n\n    if len(tuples) == 1:\n        return tuples[0][0] * tuples[0][1]\n\n    max_prod = 0\n\n    # for each pair in the list of tuples, find the product\n    # and find the maximum product\n    for pair in combinations(tuples, 2):\n        prod = pair[0][0] * pair[1][0]\n        max_prod = prod if prod > max_prod else max_prod\n\n        prod = pair[0][1] * pair[1][1]\n        max_prod = prod if prod > max_prod else max_prod\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\n# O(n) time | O(1) space\ndef max_tuple_product(tuples: List[List[int]]) -> int:\n    tuples.sort(key=lambda x: x[0])\n\n    max_product = tuples[0][0] * tuples[0][1]\n    min_product = tuples[0][0] * tuples[0][1]\n\n    for i in range(1, len(tuples)):\n        max_product = max(max_product, tuples[i][0] * tuples[i - 1][1], tuples[i - 1][0] * tuples[i][1])\n        min_product = min(min_product, tuples[i][0] * tuples[i - 1][1], tuples[i - 1][0] * tuples[i][1])\n\n    return max(max_product, min_product)\n\n\nprint(max_tuple_product([(1, 2), (2, 3), (1, 4), (4, 5)]))",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef max_product(list_of_tuples: List[tuple]) -> int:\n    # Max and min are stored for each tuple.\n    # The max for a tuple is stored in the min variable for the next tuple.\n    # The min for a tuple is stored in the max variable for the next tuple.\n    max_min_list = []\n\n    for i, t in enumerate(list_of_tuples):\n        if i == 0:\n            max_min_list.append((t[0], t[1]))\n        else:\n            max_min_list.append((max(t[0], max_min_list[i - 1][0]), min(t[1], max_min_list[i - 1][1])))\n\n    # If there are two tuples in the list, the maximum product is the product of the max and min.\n    if len(list_of_tuples) == 2:\n        return max_min_list[-1][0] * max_min_list[-1][1]\n\n    # The maximum product is the maximum of the maximum of the max and min of each tuple.\n    return max(max_min_list[-1][0], max_min_list[-1][1])",
    "def max_product(lst):\n    lst.sort(key=lambda x: x[1])\n    return max(lst[0][0] * lst[1][0], lst[-1][0] * lst[-2][0])",
    "def max_product(lst):\n    \"\"\"\n    >>> max_product([(3, 2), (4, 3), (5, 6), (7, 8), (10, 9)])\n    72\n    >>> max_product([(3, 2), (4, 3), (5, 6), (7, 8), (10, 9), (1, 1)])\n    72\n    >>> max_product([(3, 2), (4, 3), (5, 6), (7, 8), (10, 9), (1, 0)])\n    14\n    \"\"\"\n    sorted_lst = sorted(lst, key=lambda x: x[0])\n    max_product = 0\n    for i in range(len(sorted_lst) - 1):\n        for j in range(i + 1, len(sorted_lst)):\n            if sorted_lst[i][0] * sorted_lst[j][1] > max_product:\n                max_product = sorted_lst[i][0] * sorted_lst[j][1]\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef max_product(lst: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(1)\n    \"\"\"\n    lst.sort(key=lambda x: x[0])\n\n    max_left, min_left = 0, 0\n    max_right, min_right = 0, 0\n\n    for i in range(len(lst) - 1):\n        if lst[i][0] >= lst[i + 1][0]:\n            max_left, min_left = lst[i], lst[i + 1]\n        else:\n            max_right, min_right = lst[i], lst[i + 1]\n\n    return max(max_left[1] * max_right[1], min_left[1] * min_right[1])\n\n\nif __name__ == \"__main__\":\n    assert max_product([[1, 4], [2, 3], [3, 2], [2, 4], [2, 3]]) == 12",
    "def max_product(lst):\n    # Find the maximum value of the first tuple\n    lst.sort(key=lambda x: x[0], reverse=True)\n    # Find the maximum value of the second tuple\n    lst.sort(key=lambda x: x[1], reverse=True)\n    # Multiply the maximum values\n    return lst[0][0] * lst[0][1]\n\n\nif __name__ == \"__main__\":\n    lst = [(1, 2), (2, 3), (4, 5), (5, 6), (7, 8), (8, 9)]\n    print(max_product(lst))",
    "from typing import List\n\n\ndef max_product_tuples(arr: List[tuple]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    arr.sort()\n\n    return max(\n        arr[i][0] * arr[i + 1][1]\n        for i in range(len(arr) - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert max_product_tuples([(2, 4), (5, 2), (1, 6), (7, 8), (1, 5)]) == 64",
    "from typing import List\n\n\ndef max_product(lst: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    lst.sort()\n\n    return max(\n        lst[-1] * lst[-2],\n        lst[-1] * lst[-3] if lst[-1] * lst[-2] < 0 else lst[-1] * lst[-2] * lst[-3],\n    )\n\n\nif __name__ == \"__main__\":\n    assert max_product([1, 2, 3, 4]) == 24\n    assert max_product([1, 2, 3, 4, 5]) == 120\n    assert max_product([-1, -2, -3, -4]) == -24\n    assert max_product([-1, -2, -3, -4, -5]) == -120\n    assert max_product([-1, 2, -3, 4, -5]) == 24\n    assert max_product([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 288",
    "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n# Sort the list of tuples in descending order.\n# Take the first two tuples, multiply them and store the product in a variable.\n# Repeat this for all the remaining tuples in the list.\n# Keep updating the variable if the product is greater than the current maximum.\n# Return the maximum.\ndef max_product_tuples(tuples: List[tuple]) -> int:\n    tuples.sort(reverse=True)\n    max_product = tuples[0][0] * tuples[0][1]\n\n    for i in range(1, len(tuples)):\n        product = tuples[i][0] * tuples[i][1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product_tuples([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]))\n    print(max_product_tuples([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]))",
    "from itertools import combinations\n\ndef max_product(list_of_tuples):\n    \"\"\"\n    >>> max_product([(1, 2), (2, 3), (3, 4), (1, 5), (2, 6), (3, 7)])\n    35\n    \"\"\"\n    max_product = 0\n    for tuple_pair in combinations(list_of_tuples, 2):\n        product = tuple_pair[0][0] * tuple_pair[1][0]\n        if product > max_product:\n            max_product = product\n    return max_product\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from typing import List\n\n\ndef max_product(tuples: List[tuple]) -> int:\n    \"\"\"Returns the maximum product of tuples.\n\n    Args:\n        tuples (List[tuple]): list of tuples.\n\n    Examples:\n        >>> assert max_product([(1, 2), (2, 3), (3, 4), (4, 5)]) == 12\n    \"\"\"\n    tuples.sort()\n    return max(\n        tuples[i][0] * tuples[i + 1][1]\n        for i in range(len(tuples) - 1)\n    )\n\n\nif __name__ == '__main__':\n    print(max_product([(1, 2), (2, 3), (3, 4), (4, 5)]))",
    "from typing import List\n\n\ndef maximum_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[-1] * nums[0], nums[-2] * nums[1])\n\n\nif __name__ == \"__main__\":\n    assert maximum_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 90",
    "from functools import reduce\nfrom typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    arr.sort()\n\n    max_product = reduce(\n        lambda a, b: a * b,\n        [arr[-1] * arr[-2], arr[0] * arr[1], arr[-1] * arr[0], arr[-2] * arr[1]],\n    )\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([1, 2, 3, 4]) == 24\n    assert max_product([-1, 2, 3, 4]) == 24\n    assert max_product([-1, -2, 3, 4]) == 24\n    assert max_product([-1, -2, -3, 4]) == 24\n    assert max_product([-1, -2, -3, -4]) == -24\n    assert max_product([-4, -3, -2, -1]) == -24\n    assert max_product([-1, 0, 1, 2]) == 0\n    assert max_product([-1, 1, 0, -2]) == 0\n    assert max_product([-1, 1, 0, 2]) == 2\n    assert max_product([-1, 1, 0, 4]) == 4",
    "from typing import List\n\n\ndef max_product(list_of_tuples: List[tuple]) -> int:\n    \"\"\"Returns the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        list_of_tuples (List[tuple]): a list of tuples\n\n    Examples:\n        >>> assert max_product([(1, 2), (2, 3), (3, 4), (4, 5)]) == 12\n    \"\"\"\n    list_of_tuples.sort(key=lambda x: x[0])\n    return max(\n        list_of_tuples[-1][0] * list_of_tuples[-2][1],\n        list_of_tuples[-2][0] * list_of_tuples[-1][1],\n    )\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (2, 3), (3, 4), (4, 5)]))",
    "def find_max_product(l):\n    # Write your code here.\n    if len(l) == 0:\n        return 0\n\n    l.sort(key=lambda x: x[0])\n    max_product = l[0][0] * l[0][1]\n\n    for i in range(1, len(l)):\n        if l[i][0] > l[i - 1][0]:\n            max_product = max(max_product, l[i][0] * l[i - 1][1])\n        else:\n            max_product = max(max_product, l[i][0] * l[i][1])\n\n    return max_product\n\n\ndef test_find_max_product():\n    assert find_max_product([]) == 0\n    assert find_max_product([(1, -2, 3)]) == 0\n    assert find_max_product([(2, 3), (1, 2)]) == 6\n    assert find_max_product([(2, 3), (2, 3)]) == 12\n    assert find_max_product([(2, 3), (2, 3), (2, 3)]) == 12\n    assert find_max_product([(2, 3), (3, 4), (5, 6), (7, 8)]) == 56\n    assert find_max_product([(2, 3), (3, 4), (5, 6), (7, 8), (9, 10)]) == 56\n    assert find_max_product([(2, 3), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12)]) == 72\n    assert find_max_product([(2, 3), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14)]) == 72\n    assert find_max_product([(2, 3), (3,",
    "from typing import List, Tuple\n\n\ndef max_product(lst: List[Tuple[int, int]]) -> int:\n    \"\"\"Return the maximum product of two numbers in a list of tuples.\"\"\"\n    if len(lst) == 0:\n        return 0\n\n    lst.sort(key=lambda x: x[0])\n\n    max_product = 0\n\n    for i in range(len(lst) - 1):\n        max_product = max(max_product, lst[i][0] * lst[i + 1][1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 54\n    assert max_product([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (1, 10)]) == 90",
    "def find_max_product(array):\n    array.sort()\n    return max(array[-1] * array[-2], array[0] * array[-1])",
    "from typing import List\n\n\ndef max_product(tuples: List[tuple]) -> int:\n    \"\"\"Returns the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        tuples (List[tuple]): list of tuples to find maximum product from.\n\n    Examples:\n        >>> max_product([(1, 2), (2, 3), (3, 4), (4, 5)])\n        12\n        >>> max_product([(2, 7), (7, 1), (1, 8), (8, 10), (10, 1)])\n        100\n        >>> max_product([(2, 3), (3, 4), (1, 2), (2, 5), (5, 6), (6, 7)])\n        120\n    \"\"\"\n    if not tuples:\n        raise ValueError(\"Please provide a list of tuples to find maximum product from\")\n\n    tuples.sort(key=lambda x: x[0] + x[1])\n\n    max_product = tuples[0][0] * tuples[0][1]\n\n    for i in range(len(tuples) - 1):\n        max_product = max(max_product, tuples[i][0] * tuples[i + 1][1])\n        max_product = max(max_product, tuples[i][1] * tuples[i + 1][0])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 2), (2, 3), (3, 4), (4, 5)]))\n    print(max_product([(2, 7), (7, 1), (1, 8), (8, 10), (10, 1)]))\n    print(max_product([(2, 3), (3, 4), (1, 2), (2, 5), (5, 6), (6, 7)]))",
    "from typing import List\n\n\ndef max_product(tuples: List[tuple]) -> int:\n    \"\"\"\n    >>> max_product([(1, 2), (2, 3), (3, 4), (4, 5)])\n    4\n    >>> max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])\n    9\n    >>> max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)])\n    18\n    \"\"\"\n    tuples = sorted(tuples, key=lambda t: t[0])\n\n    def max_product_helper(left, right):\n        if left == right:\n            return 0\n\n        max_product = 0\n\n        for i in range(left + 1, right):\n            prod = tuples[left][0] * tuples[i][0]\n\n            if prod > max_product:\n                max_product = prod\n\n        return max_product\n\n    return max(\n        max_product_helper(left, right)\n        for left in range(len(tuples) - 1)\n        for right in range(left + 1, len(tuples))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def max_product_pairs(lst):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    max_product = float(\"-inf\")\n\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            product = lst[i][0] * lst[j][0]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\n\nassert max_product_pairs([(2, 4), (5, 6), (7, 8)]) == 112",
    "from typing import List, Tuple\n\n\ndef max_product_of_pairs(numbers: List[int]) -> int:\n    \"\"\"\n    O(n log n) & O(1)\n    \"\"\"\n\n    numbers = sorted(numbers)\n\n    return max(\n        numbers[-1] * numbers[-2] if len(numbers) > 1 else 0,\n        numbers[0] * numbers[1] if len(numbers) > 2 else 0,\n    )\n\n\nif __name__ == \"__main__\":\n    assert max_product_of_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 72",
    "from typing import List\n\n\ndef max_product_of_pairs(lst: List[int]) -> int:\n    \"\"\"\n    >>> max_product_of_pairs([-10, -10, 5, 2])\n    50\n    >>> max_product_of_pairs([-10, 10, 5, 2])\n    100\n    >>> max_product_of_pairs([-10, -10, -5, -2])\n    25\n    >>> max_product_of_pairs([-10, -10, 0, 2])\n    0\n    >>> max_product_of_pairs([1, 2, 3, 4])\n    24\n    >>> max_product_of_pairs([-1, -2, -3, -4])\n    -24\n    >>> max_product_of_pairs([-1, 2, -3, 4])\n    6\n    \"\"\"\n    lst.sort()\n\n    first_max = lst[-1] * lst[-2]\n    last_max = lst[0] * lst[1]\n\n    return max(first_max, last_max)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List, Tuple\n\n\ndef find_max_product(tuples: List[Tuple[int, int]]) -> int:\n    \"\"\"Finds the maximum product from the pairs of tuples within a given list.\n\n    Args:\n        tuples (List[Tuple[int, int]]): list of tuples\n\n    Returns:\n        int: maximum product\n    \"\"\"\n    # sort tuples by first element\n    tuples = sorted(tuples, key=lambda x: x[0])\n\n    # initialize variables\n    min_tuple, max_tuple, max_product = None, None, None\n\n    # iterate through tuples\n    for index, tuple in enumerate(tuples):\n        # if index is even\n        if index % 2 == 0:\n            # assign tuple to max tuple\n            max_tuple = tuple\n        # otherwise\n        else:\n            # assign tuple to min tuple\n            min_tuple = tuple\n\n        # find maximum product of max tuple and min tuple\n        max_product = max(max_tuple[0] * max_tuple[1], min_tuple[0] * min_tuple[1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    # doctest\n    import doctest\n\n    doctest.testmod()\n\n    # print results\n    print(find_max_product([(1, 2), (4, 5), (6, 7), (9, 8), (3, 4), (2, 4), (5, 6)]))",
    "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n# def max_product(nums: List[int]) -> int:\n#     if len(nums) == 0:\n#         return 0\n#\n#     max_prod = nums[0]\n#     min_num = nums[0]\n#\n#     for i in range(1, len(nums)):\n#         num = nums[i]\n#         max_prod = max(num, max_prod * num, min_num * num)\n#         min_num = min(num, min_num * num)\n#\n#     return max_prod\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef max_product(nums: List[int]) -> int:\n    if len(nums) == 0:\n        return 0\n\n    max_prod = nums[0]\n    max_num = nums[0]\n    min_num = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        max_num, min_num = (num, max_num * num) if num >= max_num else (max_num, min_num * num)\n        max_prod = max(max_num, min_num, max_prod)\n\n    return max_prod",
    "def max_product(tuples):\n    \"\"\"\n    >>> max_product([(1, 2), (2, 3), (1, 4)])\n    12\n    >>> max_product([(1, 2), (2, 3), (3, 4)])\n    18\n    >>> max_product([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])\n    224\n    \"\"\"\n    tuples.sort(key=lambda x: x[0])\n    return max(\n        [\n            tuples[i][0] * tuples[i + 1][1]\n            for i in range(len(tuples) - 1)\n            if tuples[i][1] <= tuples[i + 1][0]\n        ]\n        or [1]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef max_tuple_product(arr: List[int]) -> int:\n    \"\"\"Returns the maximum product of the tuples.\n    >>> max_tuple_product([1, 2, 3, 4, 5])\n    12\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1])\n    12\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2])\n    24\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2, 3])\n    36\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2, 3, 4])\n    48\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2, 3, 4, 5])\n    60\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1])\n    60\n    >>> max_tuple_product([1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2])\n    72\n    \"\"\"\n    arr.sort()\n    return max(\n        arr[-1] * arr[-2]\n        + arr[-3] * arr[-4]\n        + arr[-5] * arr[-6]\n        + arr[-7] * arr[-8]\n        + arr[-9] * arr[-10],\n        arr[-1] * arr[-2]\n        + arr[-3] * arr[-4]\n        + arr[-5] * arr[-6]\n        + arr[-7] * arr[-8],\n        arr[-1] * arr[-2] + arr[-3] * arr[-4] + arr[-5] * arr[-6],\n        arr[-1] * arr[-2] + arr[-3] * arr[-4],\n    )",
    "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef max_product(array: List[int]) -> int:\n    array.sort()\n    return max(\n        array[0] * array[-1],\n        array[-1] * array[-2],\n        array[1] * array[-1],\n        array[0] * array[-2],\n    )\n\n\nif __name__ == \"__main__\":\n    print(max_product([1, 2, 3, 4, 5, 6, 7, 8]))",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_sort(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[-1] * nums[-3] * nums[-2], nums[0] * nums[1])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_sort_v2(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[-1] * nums[-3], nums[0] * nums[1])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_sort_v3(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[-1] * nums[-3] * nums[-4] + nums[-3] * nums[-4])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_sort_v4(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[-1] * nums[-3] * nums[-4], nums[-1] * nums[-5] * nums[-4] * nums[-3])\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_with_sort_v5(nums: List[int]) -> int:\n    nums.sort()\n    return max(nums[-",
    "def max_product(lst):\n    lst.sort(key=lambda x: x[0])\n    if len(lst) % 2 != 0:\n        return max(lst[-1][0] * lst[-2][1], lst[-2][0] * lst[-1][1])\n    else:\n        return max(lst[-1][0] * lst[-2][1], lst[-2][0] * lst[-3][1])\n\n\nif __name__ == \"__main__\":\n    print(max_product([(1, 4), (3, 2), (2, 3), (1, 5)]))",
    "def max_product(tuples):\n    if not tuples:\n        return None\n\n    # sort tuples by their first element\n    tuples.sort(key=lambda x: x[0])\n\n    # initialize maximum product to be the product of the last two tuples\n    max_product = tuples[-1][0] * tuples[-2][0]\n\n    # iterate from the first tuple to the second to last tuple\n    for i in range(len(tuples) - 1):\n        # update maximum product if the product of the current tuple and the next tuple is bigger\n        max_product = max(max_product, tuples[i][0] * tuples[i + 1][0])\n\n    return max_product\n\n\nprint(max_product([(1, 2), (2, 3), (3, 4), (1, 3)]))\nprint(max_product([(1, 2), (2, 3), (3, 4), (1, 4)]))\nprint(max_product([(1, 2), (2, 3), (3, 4), (1, 5)]))",
    "from typing import List, Tuple\n\n\ndef max_product_tuples(tuples: List[Tuple[int, int]]) -> int:\n    \"\"\"Return the maximum product of tuples.\n\n    Time complexity: O(n log n).\n    Space complexity: O(1).\n    \"\"\"\n    # Edge case.\n    if not tuples:\n        return 0\n\n    # Sort tuples by first element.\n    tuples.sort(key=lambda t: t[0])\n\n    # Sort tuples by second element.\n    tuples.sort(key=lambda t: t[1])\n\n    # Edge case.\n    if len(tuples) == 1:\n        return tuples[0][0] * tuples[0][1]\n\n    # Maximum product of tuples.\n    max_product = 0\n\n    # Loop over tuples.\n    for i in range(len(tuples)):\n        if i == len(tuples) - 1:\n            # Last tuple.\n            max_product = max(max_product, tuples[i][0] * tuples[i][1])\n        else:\n            # Product of tuples.\n            product = tuples[i][0] * tuples[i + 1][1]\n\n            max_product = max(max_product, product)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_tuples([]) == 0\n    assert max_product_tuples([(1, 2)]) == 2\n    assert max_product_tuples([(1, 2), (2, 3)]) == 6\n    assert max_product_tuples([(1, 2), (2, 3), (3, 4)]) == 12\n    assert max_product_tuples([(1, 2), (2, 3), (3, 4), (4, 5)]) == 20\n    assert max_product_tuples([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 30",
    "def max_product(tuples):\n    tuples.sort(key=lambda x: x[0])\n    max_value = tuples[0][0] * tuples[0][1]\n    min_value = tuples[0][0] * tuples[0][1]\n    for i in range(1, len(tuples)):\n        if tuples[i][0] > tuples[i - 1][0]:\n            max_value = max(max_value, tuples[i][0] * tuples[i][1])\n        elif tuples[i][0] == tuples[i - 1][0]:\n            max_value = max(max_value, tuples[i][0] * tuples[i][1], tuples[i - 1][0] * tuples[i - 1][1])\n        else:\n            max_value = max(max_value, tuples[i][0] * tuples[i][1], tuples[i - 1][1] * tuples[i][0])\n        min_value = min(min_value, tuples[i][0] * tuples[i][1])\n    return max(max_value, min_value)\n\n\nprint(max_product([(2, 3), (5, 2), (2, 2), (2, 4), (6, 1)]))\nprint(max_product([(2, 3), (5, 2), (2, 2), (2, 4), (6, 1), (1, 1)]))\nprint(max_product([(1, 1), (1, 1), (1, 1), (1, 1)]))\nprint(max_product([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]))\nprint(max_product([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]))\nprint(max_product([(1, 1), (",
    "def max_product(tuples):\n    # Sort the tuples\n    tuples.sort(key=lambda x: x[0])\n\n    # Initialize the maximum product\n    max_product = 0\n\n    # Iterate over the tuples\n    for i in range(len(tuples) - 1):\n        # Get the tuples at the current and next indices\n        cur_tuple = tuples[i]\n        next_tuple = tuples[i + 1]\n\n        # Compute the maximum product\n        max_product = max(\n            max_product,\n            (cur_tuple[0] * next_tuple[0]) * (cur_tuple[1] * next_tuple[1]),\n            (cur_tuple[0] * next_tuple[1]) * (cur_tuple[1] * next_tuple[0]),\n        )\n\n    # Return the maximum product\n    return max_product\n\n\n# Driver code\ntuples = [(1, 2), (2, 3), (1, 4), (3, 4), (1, 1), (2, 2), (3, 3), (4, 4)]\nprint(max_product(tuples))",
    "from itertools import combinations\n\n\ndef max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    arr.sort()\n    max_product = 0\n    for comb in combinations(arr, 2):\n        max_product = max(max_product, comb[0] * comb[1])\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product([-100, -90, -50, -10, -5, 100, 200]))",
    "def max_product(arr):\n    \"\"\"\n    Finds the maximum product of tuples in a list.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"List must have at least 2 elements.\")\n\n    # Sort the list by the first element of each tuple\n    sorted_arr = sorted(arr, key=lambda x: x[0])\n\n    # Initialize variables\n    max_prod = 0\n    max_prod_index = 0\n\n    # Iterate through the list, comparing each adjacent pair of tuples\n    for i in range(len(sorted_arr) - 1):\n        prod = sorted_arr[i][1] * sorted_arr[i + 1][1]\n\n        if prod > max_prod:\n            max_prod = prod\n            max_prod_index = i\n\n    return sorted_arr[max_prod_index]\n\n\ndef test_max_product():\n    \"\"\"\n    Tests the max_product function.\n    \"\"\"\n    assert max_product([(1, 2), (3, 4)]) == (3, 4)\n    assert max_product([(2, 3), (1, 2)]) == (2, 3)\n    assert max_product([(2, 4), (3, 2), (1, 3)]) == (3, 2)\n\n    try:\n        max_product([(1, 2)])\n    except ValueError:\n        pass\n    else:\n        assert False",
    "def max_product(tuples):\n    tuples = sorted(tuples, key=lambda tup: tup[1])\n    max_prod = tuples[0][0] * tuples[0][1]\n    for i in range(len(tuples) - 1):\n        max_prod = max(max_prod, tuples[i][0] * tuples[i + 1][0])\n        max_prod = max(max_prod, tuples[i][0] * tuples[i + 1][1])\n        max_prod = max(max_prod, tuples[i][1] * tuples[i + 1][0])\n        max_prod = max(max_prod, tuples[i][1] * tuples[i + 1][1])\n    return max_prod\n\n\ndef test_max_product():\n    assert max_product([(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9)]) == 72\n    assert max_product([(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10)]) == 84\n    assert max_product([(1, 10), (1, 100), (1, 1000), (1, 10000), (1, 100000), (1, 1000000), (1, 10000000), (1, 100000000), (1, 1000000000)]) == 1000000000\n    assert max_product([(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (",
    "def maximum_product_from_pairs(tuples: list) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    tuples.sort(key=lambda x: x[0])\n    max_val = tuples[0][0]\n    min_val = tuples[0][1]\n\n    for i in range(1, len(tuples)):\n        if tuples[i][0] > max_val:\n            max_val = tuples[i][0]\n        elif tuples[i][1] > max_val:\n            max_val = tuples[i][1]\n\n        if tuples[i][1] < min_val:\n            min_val = tuples[i][1]\n\n    return max(max_val * min_val, max_val * max_val)\n\n\nif __name__ == \"__main__\":\n    assert maximum_product_from_pairs([(1, 5), (10, 2), (3, 2), (1, 3)]) == 30",
    "from typing import List\n\n\ndef max_product(arr: List[List[int]]) -> int:\n    arr.sort(key=lambda x: x[0])\n\n    max_product = 0\n\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            max_product = max(max_product, arr[i][0] * arr[j][1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([[2, 10], [2, 10], [2, 10], [2, 10], [2, 10], [2, 10], [2, 10], [2, 10], [2, 10], [2, 10]]) == 100\n    assert max_product([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12]]) == 300\n    assert max_product([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13]]) == 300",
    "def max_product(lst):\n    \"\"\"\n    >>> max_product([(1, 2), (3, 4), (5, 6), (7, 8)])\n    34\n    >>> max_product([(1, 2), (3, 4), (5, 6), (7, 8), (-1, 1)])\n    5\n    \"\"\"\n    max_product = 0\n    lst.sort(key=lambda x: x[0])\n    for i in range(len(lst) - 1):\n        if lst[i][0] < 0:\n            continue\n        if lst[i][1] < 0:\n            if lst[i][0] * lst[i + 1][1] > max_product:\n                max_product = lst[i][0] * lst[i + 1][1]\n        else:\n            if lst[i][0] * lst[i + 1][1] > max_product:\n                max_product = lst[i][0] * lst[i + 1][1]\n            if lst[i][1] * lst[i + 1][0] > max_product:\n                max_product = lst[i][1] * lst[i + 1][0]\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}