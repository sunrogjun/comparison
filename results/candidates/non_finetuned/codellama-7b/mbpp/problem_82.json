{
  "problem": {
    "task_id": "MBPP/93",
    "prompt": "Write a function to calculate the value of 'a' to the power 'b'.",
    "canonical_solution": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)",
    "test_list": [
      "assert power(3,4) == 81",
      "assert power(2,3) == 8",
      "assert power(5,5) == 3125"
    ],
    "challenge_test_list": [],
    "problem_id": 82
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def power(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "def power(a: int, b: int) -> int:\n    \"\"\"\n    >>> power(2, 10)\n    1024\n    >>> power(2, 3)\n    8\n    >>> power(10, 2)\n    100\n    >>> power(1, 1)\n    1\n    >>> power(2, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    \"\"\"\n    >>> power(2, 3)\n    8\n    >>> power(2, 0)\n    1\n    >>> power(2, -2)\n    0.25\n    >>> power(0, 0)\n    1\n    >>> power(0, 3)\n    0\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "\"\"\"Question:\n        Write a function to calculate the value of 'a' to the power 'b'.\n  Example:\n    Input:\n        a = 2, b = 3\n    Output:\n        8\nHints:\n    Use ** operator\n\n\"\"\"\ndef power(a, b):\n    return a**b",
    "def calculate_power(a: int, b: int) -> int:\n    \"\"\"\n    :param a: int - a\n    :param b: int - b\n    :return: int\n    \"\"\"\n    return a ** b\n\n\ndef test_calculate_power():\n    assert calculate_power(2, 10) == 1024\n    assert calculate_power(3, 2) == 9\n    assert calculate_power(1, 0) == 1\n    assert calculate_power(1, 3) == 1\n    assert calculate_power(1, 1) == 1\n    assert calculate_power(2, 0) == 1\n    assert calculate_power(2, 1) == 2\n\n\nif __name__ == \"__main__\":\n    test_calculate_power()",
    "from functools import reduce\nfrom math import gcd\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(1)\ndef power_iterative(a: int, b: int) -> int:\n    \"\"\"Finds 'a' to the power 'b'.\"\"\"\n    if b == 0:\n        return 1\n\n    if b < 0:\n        return 1 / power_iterative(a, -b)\n\n    if b % 2 == 0:\n        return power_iterative(a, b / 2) * power_iterative(a, b / 2)\n    else:\n        return a * power_iterative(a, b / 2) * power_iterative(a, b / 2)\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(1)\ndef power_recursive(a: int, b: int) -> int:\n    \"\"\"Finds 'a' to the power 'b'.\"\"\"\n    if b == 0:\n        return 1\n\n    if b < 0:\n        return 1 / power_iterative(a, -b)\n\n    if b % 2 == 0:\n        return power_recursive(a, b / 2) * power_recursive(a, b / 2)\n    else:\n        return a * power_recursive(a, b / 2) * power_recursive(a, b / 2)\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(1)\ndef power_iterative_mod(a: int, b: int) -> int:\n    \"\"\"Finds 'a' to the power 'b'.\"\"\"\n    if b == 0:\n        return 1\n\n    if b < 0:\n        return 1 / power_iterative_mod(a, -b)\n\n    if b % 2 == 0:\n        return power_iterative_mod(a, b / 2) * power_iterative_mod(a, b / 2)\n    else:\n        return a * power_iterative_mod(a, b / 2",
    "def power(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    return a * power(a, b - 1)\n\nprint(power(5, 2))\nprint(power(5, 3))\nprint(power(5, 4))",
    "from functools import reduce\n\n\n# Time complexity: O(log(n))\n# Space complexity: O(1)\ndef power_v1(a, b):\n    if b == 0:\n        return 1\n    elif b % 2:\n        return a * power_v1(a, b - 1)\n    else:\n        return power_v1(a, b // 2) * power_v1(a, b // 2)\n\n\n# Time complexity: O(log(n))\n# Space complexity: O(log(n))\ndef power_v2(a, b):\n    if b == 0:\n        return 1\n    elif b % 2:\n        return a * power_v2(a, b - 1)\n    else:\n        return power_v2(a * a, b // 2)\n\n\n# Time complexity: O(log(n))\n# Space complexity: O(log(n))\ndef power_v3(a, b):\n    if b == 0:\n        return 1\n    elif b % 2:\n        return a * power_v3(a, b - 1)\n    else:\n        half_power = power_v3(a, b // 2)\n        return half_power * half_power\n\n\n# Time complexity: O(log(n))\n# Space complexity: O(1)\ndef power_v4(a, b):\n    if b == 0:\n        return 1\n    elif b % 2:\n        return a * power_v4(a, b - 1)\n    else:\n        half_power = power_v4(a, b // 2)\n        return half_power * half_power\n\n\n# Time complexity: O(log(n))\n# Space complexity: O(1)\ndef power_v5(a, b):\n    if b == 0:\n        return 1\n    elif b % 2:\n        return a * power_v5(a, b - 1)\n    else:\n        half_power = power_v5(a, b // 2)\n        return half_power *",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    else:\n        return a * power(a, b - 1)\n\nprint(power(5, 3))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    else:\n        return a * power(a, b-1)\n\nprint(power(2, 3))",
    "def power(a, b):\n    if b == 0:\n        return 1\n\n    temp = power(a, b // 2)\n    if b % 2 == 0:\n        return temp * temp\n    else:\n        return temp * temp * a\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "from functools import reduce\n\n\n# def power(a, b):\n#     return reduce(lambda x, y: x * y, [a] * b)\n\n\ndef power(a, b):\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    print(power(5, 3))",
    "def power(a, b):\n    if a < 0 and b is not float:\n        return -1\n    elif a == 0:\n        return 0\n    else:\n        return a ** b\n\n\nif __name__ == '__main__':\n    print(power(2, 3))\n    print(power(0, 3))\n    print(power(-2, 3.0))",
    "def power(a: int, b: int) -> int:\n    \"\"\"\n    >>> power(2, 3)\n    8\n    >>> power(2, -2)\n    0.25\n    >>> power(-2, 2)\n    -4\n    >>> power(-2, -2)\n    0.25\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import Union\n\n\ndef power_of_a(a: int, b: Union[int, float]) -> Union[int, float]:\n    \"\"\"\n    >>> power_of_a(2, 3)\n    8\n    >>> power_of_a(2, 2.5)\n    4.0\n    >>> power_of_a(2, 2)\n    4\n    >>> power_of_a(2, 1.5)\n    2.0\n    >>> power_of_a(2, 0.5)\n    0.5\n    >>> power_of_a(2, 0)\n    1\n    >>> power_of_a(2, -1)\n    0.5\n    >>> power_of_a(2, -2)\n    0.25\n    >>> power_of_a(2, -2.5)\n    0.125\n    >>> power_of_a(2, 3.5)\n    16.0\n    >>> power_of_a(2, -3)\n    0.04\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import Union\n\n\n# def power(a: int, b: int) -> int:\n#     if a < 0 or b < 0:\n#         raise ValueError('a and b should be non-negative')\n#     return int(a ** b)\n\n\ndef power(a: int, b: int) -> Union[int, float]:\n    \"\"\"\n    Calculate a to the power b\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError('a and b should be non-negative')\n    return a ** b\n\n\nif __name__ == '__main__':\n    print(power(2, 3))\n    print(power(3, 3))\n    print(power(2, -3))\n    print(power(-3, 3))\n    print(power(-2, -3))\n    print(power(-2, 3.5))",
    "def power(a, b):\n    if b == 0:\n        return 1\n\n    if b == 1:\n        return a\n\n    if b == 2:\n        return a * a\n\n    return a * power(a, b - 1)\n\n\nif __name__ == '__main__':\n    print(power(3, 3))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b // 2) * power(a, b // 2)\n    else:\n        return a * power(a, b // 2) * power(a, b // 2)\n\nprint(power(3, 4))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)\n\n\nprint(power(2, 10))",
    "from functools import lru_cache\n\n\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    Space Complexity: O(1)\n    \"\"\"\n    if b == 0:\n        return 1\n    if b < 0:\n        return 0\n    return a * power(a, b - 1)\n\n\n@lru_cache\ndef power_cache(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    Space Complexity: O(1)\n    \"\"\"\n    if b == 0:\n        return 1\n    if b < 0:\n        return 0\n    return a * power_cache(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 2))\n    print(power(2, 3))\n    print(power(2, 4))\n    print(power(2, 5))\n    print(power(2, 6))\n    print(power(2, 7))\n    print(power(2, 8))\n    print(power(2, 9))\n    print(power(2, 10))\n\n    print(power_cache(2, 2))\n    print(power_cache(2, 3))\n    print(power_cache(2, 4))\n    print(power_cache(2, 5))\n    print(power_cache(2, 6))\n    print(power_cache(2, 7))\n    print(power_cache(2, 8))\n    print(power_cache(2, 9))\n    print(power_cache(2, 10))",
    "from functools import reduce\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(log(b))\ndef power_iterative(a, b):\n    if b == 0:\n        return 1\n\n    result = a\n\n    for _ in range(b - 1):\n        result *= a\n\n    return result\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(log(b))\ndef power_recursive(a, b):\n    if b == 0:\n        return 1\n\n    if b % 2 == 0:\n        return power_recursive(a, b // 2) * power_recursive(a, b // 2)\n    else:\n        return a * power_recursive(a, b // 2) * power_recursive(a, b // 2)\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(log(b))\ndef power_recursive_with_memo(a, b, memo=None):\n    if memo is None:\n        memo = {}\n\n    if b == 0:\n        return 1\n\n    if b in memo:\n        return memo[b]\n\n    if b % 2 == 0:\n        memo[b] = power_recursive_with_memo(a, b // 2, memo) * power_recursive_with_memo(a, b // 2, memo)\n    else:\n        memo[b] = a * power_recursive_with_memo(a, b // 2, memo) * power_recursive_with_memo(a, b // 2, memo)\n\n    return memo[b]\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(log(b))\ndef power_recursive_with_reduce(a, b):\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\n# Time complexity: O(log(b))\n# Space complexity: O(log(b))\ndef power_recursive_with",
    "from functools import reduce\n\n\n# Time complexity: O(b)\n# Space complexity: O(1)\ndef power_v1(a, b):\n    if b == 0:\n        return 1\n\n    return a * power_v1(a, b - 1)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_v2(a, b):\n    if b == 0:\n        return 1\n\n    if b % 2 == 0:\n        return power_v2(a, b // 2) * power_v2(a, b // 2)\n    else:\n        return a * power_v2(a, b // 2) * power_v2(a, b // 2)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_v3(a, b):\n    if b == 0:\n        return 1\n\n    half = power_v3(a, b // 2)\n    if b % 2 == 0:\n        return half * half\n    else:\n        return half * half * a\n\n\n# Time complexity: O(logb)\n# Space complexity: O(logb)\ndef power_v4(a, b):\n    if b == 0:\n        return 1\n\n    half = [a] * (b // 2)\n    if b % 2 == 0:\n        half = half + half\n\n    return reduce(lambda x, y: x * y, half)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(logb)\ndef power_v5(a, b):\n    if b == 0:\n        return 1\n\n    half = power_v5(a, b // 2)\n    return half * half * a if b % 2 == 0 else half * half\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_v6(a, b):\n    if b == 0:\n        return 1\n\n    half = power_v6(",
    "def power(a, b):\n    if a == 0 or b == 0:\n        return 0\n    elif a == 1:\n        return 1\n    else:\n        return a * power(a, b - 1)\n\n\ndef main():\n    print(power(2, 3))\n    print(power(10, 10))\n\n\nif __name__ == '__main__':\n    main()",
    "from icecream import ic\n\n\ndef power(a, b):\n    \"\"\"\n    >>> power(2, 3)\n    8\n    >>> power(2, -3)\n    0.125\n    >>> power(2, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    if b < 0:\n        return 1 / a * power(a, -b)\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nif __name__ == '__main__':\n    print(power(5, 5))",
    "def power(a, b):\n    if a == 0 and b == 0:\n        return None\n    elif a == 0:\n        return 0\n    elif b == 0:\n        return 1\n    elif b < 0:\n        return 1 / power(a, -b)\n    elif b % 2 == 0:\n        return power(a, b / 2) * power(a, b / 2)\n    else:\n        return a * power(a, b / 2) * power(a, b / 2)\n\nif __name__ == '__main__':\n    print(power(2, 3))\n    print(power(3, 3))\n    print(power(2, 0))\n    print(power(0, 3))\n    print(power(0, 0))",
    "from functools import reduce\n\n\n# iterative solution\ndef power_iter(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n\n\n# recursive solution\ndef power_rec(a, b):\n    if b == 0:\n        return 1\n    return a * power_rec(a, b - 1)\n\n\n# recursive solution with reduce\ndef power_rec_reduce(a, b):\n    return reduce(lambda x, y: x * y, [a] * b)",
    "from math import log\n\n\ndef power(a, b):\n    \"\"\"\n    This function uses the log function to solve the power problem.\n    >>> power(2, 3)\n    8\n    >>> power(1, 10)\n    1024\n    >>> power(2, 0)\n    1\n    >>> power(0, 0)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: float division by zero\n    \"\"\"\n    return round(a ** b)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import reduce\n\n\n# def power(a, b):\n#     return reduce(lambda x, y: x * y, [a] * b)\n\n\ndef power(a, b):\n    return a ** b\n\n\ndef main():\n    print(power(2, 10))\n    print(power(3, 4))\n    print(power(4, 5))\n\n\nif __name__ == '__main__':\n    main()",
    "from functools import reduce\nfrom typing import Union\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    :param a: int\n    :param b: int\n    :return: int\n    >>> power(2, 2)\n    4\n    >>> power(3, 3)\n    27\n    >>> power(10, 2)\n    100\n    >>> power(5, 0)\n    1\n    \"\"\"\n    if a == 0:\n        return 0\n    if b == 0:\n        return 1\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import Union\n\n\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Calculates the value of 'a' to the power 'b'.\n    >>> power(3, 2)\n    9\n    >>> power(4, 3)\n    64\n    >>> power(2, 10)\n    1024\n    >>> power(3, 0)\n    1\n    >>> power(0, 4)\n    0\n    >>> power(2, -2)\n    0.25\n    >>> power(0, -3)\n    0\n    >>> power(-2, 2)\n    -4\n    >>> power(-3, 3)\n    -27\n    >>> power(-2, -2)\n    0.25\n    \"\"\"\n    return int(a ** b)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import reduce\nfrom math import log\n\n\ndef power(a, b):\n    \"\"\"\n    >>> power(2, 10)\n    1024\n    >>> power(10, 10)\n    10000000000\n    >>> power(10, 100)\n    10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "def power(a, b):\n    \"\"\"\n    :param a: int - base number\n    :param b: int - power number\n    :return: int - a^b\n    \"\"\"\n    if a < 0 and b % 2 == 0:\n        return 0\n    elif a < 0 and b % 2 == 1:\n        return -1 * power(-a, b - 1)\n    elif b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)\n\nprint(power(3, 5))",
    "from functools import reduce\n\n\ndef power(a, b):\n    \"\"\"\n    >>> power(2, 4)\n    16\n    >>> power(2, 3)\n    8\n    >>> power(3, 3)\n    27\n    >>> power(4, 2)\n    16\n    >>> power(2, 0)\n    1\n    >>> power(0, 0)\n    1\n    >>> power(0, 1)\n    0\n    \"\"\"\n    if b == 0:\n        return 1\n    return reduce(lambda x, y: x * y, [a for _ in range(b)])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b/2) * power(a, b/2)\n    else:\n        return a * power(a, b/2) * power(a, b/2)\n\nprint(power(3, 5))",
    "from typing import Tuple\n\n\ndef power_iterative(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    \"\"\"\n    if b == 0:\n        return 1\n\n    res = 1\n\n    for _ in range(b):\n        res *= a\n\n    return res\n\n\ndef power_recursive(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    \"\"\"\n    if b == 0:\n        return 1\n\n    return a * power_recursive(a, b - 1)\n\n\ndef power_recursive_with_cache(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    \"\"\"\n    if b == 0:\n        return 1\n\n    cache = {}\n\n    def _power_recursive(a: int, b: int) -> int:\n        if b == 0:\n            return 1\n\n        if b in cache:\n            return cache[b]\n\n        cache[b] = a * _power_recursive(a, b - 1)\n\n        return cache[b]\n\n    return _power_recursive(a, b)\n\n\ndef power_recursive_with_memoization(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    \"\"\"\n\n    def _power_recursive(a: int, b: int) -> int:\n        if b == 0:\n            return 1\n\n        if b in cache:\n            return cache[b]\n\n        cache[b] = a * _power_recursive(a, b - 1)\n\n        return cache[b]\n\n    cache: dict[int, int] = {}\n\n    return _power_recursive(a, b)\n\n\ndef power_recursive_with_memoization_2(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(b)\n    \"\"\"\n\n    def _power_recursive(a: int, b: int",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b // 2) * power(a, b // 2)\n    else:\n        return a * power(a, b // 2) * power(a, b // 2)\n\n\nprint(power(2, 2))",
    "# 1. A naive recursive solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     return a * power(a, b - 1)\n\n# 2. A naive iterative solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     result = 1\n#     for i in range(b):\n#         result *= a\n#     return result\n\n# 3. A more efficient iterative solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     if b < 0:\n#         a = 1 / a\n#         b = -b\n#     result = 1\n#     while b > 0:\n#         if b & 1:\n#             result *= a\n#         a *= a\n#         b >>= 1\n#     return result\n\n# 4. A more efficient recursive solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     if b < 0:\n#         a = 1 / a\n#         b = -b\n#     if b & 1:\n#         return a * power(a, b - 1)\n#     return power(a * a, b // 2)\n\n# 5. A more efficient recursive solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     if b & 1:\n#         return a * power(a, b - 1)\n#     return power(a * a, b // 2)\n\n# 6. A more efficient recursive solution:\n# def power(a, b):\n#     if b == 0:\n#         return 1\n#     if b < 0:\n#         a = 1 / a\n#         b = -b\n#     if b & 1:\n#         return a * power(a, b - 1)\n#     x = power(a, b // 2)\n#     return x * x",
    "def power(a, b):\n    \"\"\"\n    >>> power(3, 5)\n    243\n    >>> power(3, 0)\n    1\n    >>> power(0, 5)\n    0\n    \"\"\"\n    if b == 0:\n        return 1\n    if a == 0:\n        return 0\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    return a * power(a, b - 1)\n\n\ndef test_power():\n    assert power(2, 0) == 1\n    assert power(2, 1) == 2\n    assert power(2, 2) == 4\n    assert power(2, 3) == 8\n    assert power(3, 2) == 9",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b < 0:\n        return power(1 / a, -b)\n    else:\n        return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "def power_of(a: int, b: int) -> int:\n    if a == 0 or b == 0:\n        return 0\n    if b < 0:\n        a = 1 / a\n        b = -b\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n\n\nif __name__ == \"__main__\":\n    print(power_of(2, 3))\n    print(power_of(2, -3))\n    print(power_of(0, 3))\n    print(power_of(0, 0))",
    "def power(a, b):\n    \"\"\"\n    This function calculates the value of 'a' to the power 'b'.\n\n    >>> power(2, 2)\n    4\n\n    >>> power(2, 3)\n    8\n\n    >>> power(3, 2)\n    9\n\n    >>> power(2, -2)\n    0.25\n\n    >>> power(2, 0)\n    1\n\n    >>> power(0, 0)\n    1\n\n    >>> power(0, 2)\n    0\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from math import log, exp\n\n\ndef power_func(a, b):\n    \"\"\"Returns the value of a to the power b.\"\"\"\n    if b == 0:\n        return 1\n    else:\n        return exp(b * log(a))\n\n\ndef test_power_func():\n    \"\"\"Test for power_func.\"\"\"\n    assert power_func(2, 3) == 8\n    assert power_func(2, 0) == 1\n    assert power_func(3, 3) == 27",
    "def power(a, b):\n    \"\"\"\n    >>> power(2, 10)\n    1024\n    >>> power(10, 2)\n    100\n    >>> power(0, 0)\n    1\n    >>> power(2, -2)\n    0.25\n    \"\"\"\n    if a < 0 and b % 2 == 0:\n        return 0\n\n    if b < 0:\n        return 1 / power(a, -b)\n\n    if a == 0:\n        return 0\n\n    if b == 0:\n        return 1\n\n    if b % 2 == 0:\n        return power(a * a, b / 2)\n    else:\n        return a * power(a, b - 1)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# My solution\n\n\ndef a_to_power_b(a, b):\n    return a ** b\n\n\nprint(a_to_power_b(2, 3))\n\n\n# Given solution\n\n\ndef a_to_power_b_solution(a, b):\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    if b == 2:\n        return a * a\n\n    return a * a_to_power_b_solution(a, b-1)",
    "from typing import Tuple\n\n\ndef calculate_power(a: int, b: int) -> int:\n    \"\"\"\n    This function will calculate the value of 'a' to the power 'b'.\n    >>> calculate_power(3, 5)\n    243\n    >>> calculate_power(10, 10)\n    10000000000\n    >>> calculate_power(10, -10)\n    9223372036854775808\n    >>> calculate_power(0, 0)\n    1\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"a should be greater than or equal to 0\")\n    if b < 0:\n        return calculate_power(1 / a, -b)\n\n    if a == 0:\n        return 0 if b < 0 else 1\n\n    if b == 0:\n        return 1\n\n    if b % 2:\n        return a * calculate_power(a, b - 1)\n\n    temp = calculate_power(a, b // 2)\n    return temp * temp\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef power_of_a(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n\n    return a * power_of_a(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power_of_a(2, 4))",
    "def power(a, b):\n    \"\"\"\n    >>> power(2, 2)\n    4\n    >>> power(2, 10)\n    1024\n    \"\"\"\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return power(a, b // 2) ** 2\n    return a * power(a, b // 2) ** 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    if b == 0:\n        return 1\n\n    if b == 1:\n        return a\n\n    if b % 2 == 0:\n        return power(a, b // 2) ** 2\n\n    return a * power(a, b // 2) ** 2\n\n\nif __name__ == '__main__':\n    print(power(2, 10))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    else:\n        return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "def power(a, b):\n    result = 1\n    for i in range(1, b + 1):\n        result = result * a\n    return result\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "from functools import reduce\n\n\n# recursive solution\ndef recursive_power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return recursive_power(a * a, b / 2)\n    else:\n        return a * recursive_power(a, b - 1)\n\n\n# iterative solution\ndef iterative_power(a, b):\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\n# test cases\nassert recursive_power(2, 10) == 1024\nassert recursive_power(2, 20) == 1024 * 1024\nassert recursive_power(2, 0) == 1\nassert iterative_power(2, 10) == 1024\nassert iterative_power(2, 20) == 1024 * 1024\nassert iterative_power(2, 0) == 1",
    "def power(a, b):\n    \"\"\"\n    >>> power(2, 3)\n    8\n    >>> power(2, 2)\n    4\n    >>> power(2, 1)\n    2\n    >>> power(2, 0)\n    1\n    >>> power(2, -1)\n    0.5\n    >>> power(2, -2)\n    0.25\n    >>> power(3, 3)\n    27\n    >>> power(3, 2)\n    9\n    >>> power(3, 1)\n    3\n    >>> power(3, 0)\n    1\n    >>> power(3, -1)\n    1.0\n    >>> power(3, -2)\n    1.0\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import reduce\n\n\ndef power(a, b):\n    return reduce(lambda x, y: x * y, [a for _ in range(b)], 1)\n\n\nprint(power(2, 10))\nprint(power(10, 10))\nprint(power(100, 100))",
    "def power(a, b):\n    return a ** b\n\n\nprint(power(2, 3))",
    "from icecream import ic\n\n\ndef power(a, b):\n    \"\"\"\n    Calculates the value of 'a' to the power 'b'\n    \"\"\"\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    ic(power(2, 3))\n    ic(power(3, 3))\n    ic(power(10, 2))\n    ic(power(5, 5))\n    ic(power(11, 11))",
    "from math import log\n\n\ndef power(a, b):\n    return round(a**b)\n\n\ndef power_log(a, b):\n    return round(a**b)\n\n\nif __name__ == \"__main__\":\n    a = 10\n    b = 100\n    print(power(a, b))\n    print(power_log(a, b))",
    "def power(a, b):\n    if a < 0 or b < 0:\n        raise Exception(\"a and b should be positive\")\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    print(power(2, 4))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nprint(power(3, 2))\nprint(power(2, 0))",
    "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b // 2) ** 2\n    else:\n        return a * power(a, b // 2) ** 2\n\n\nif __name__ == '__main__':\n    print(power(2, 10))",
    "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n\n\nif __name__ == \"__main__\":\n    print(power(5, 3))",
    "def power(a, b):\n    return a**b\n\n\nif __name__ == '__main__':\n    print(power(2, 3))",
    "from functools import reduce\n\n\n# def power(a, b):\n#     return reduce(lambda x, y: x * y, [a] * b)\n\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 10))",
    "from typing import Tuple\n\n\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    >>> power(2, 3)\n    8\n    >>> power(2, 10)\n    1024\n    >>> power(2, 0)\n    1\n    >>> power(2, -1)\n    0.5\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power(a, b):\n    result = 1\n    for i in range(b):\n        result *= a\n    return result\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 2))",
    "def power(a, b):\n    \"\"\"\n    >>> power(2, 2)\n    4\n    >>> power(2, 3)\n    8\n    >>> power(2, 10)\n    1024\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def power_of_a(a, b):\n    if b == 0:\n        return 1\n\n    if b == 1:\n        return a\n\n    if b % 2 == 0:\n        return power_of_a(a, b / 2) * power_of_a(a, b / 2)\n\n    return a * power_of_a(a, b - 1)\n\nprint(power_of_a(2, 5))",
    "from functools import reduce\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_iter(a, b):\n    if b == 0:\n        return 1\n\n    result = 1\n\n    while b > 0:\n        if b % 2 == 1:\n            result *= a\n\n        a *= a\n        b //= 2\n\n    return result\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_recursion(a, b):\n    if b == 0:\n        return 1\n\n    if b % 2 == 1:\n        return a * power_recursion(a, b - 1)\n    else:\n        return power_recursion(a * a, b // 2)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(logb)\ndef power_recursion_memo(a, b, memo):\n    if b == 0:\n        return 1\n\n    if b in memo:\n        return memo[b]\n\n    if b % 2 == 1:\n        result = a * power_recursion_memo(a, b - 1, memo)\n    else:\n        result = power_recursion_memo(a * a, b // 2, memo)\n\n    memo[b] = result\n\n    return result\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_recursion_memo_bottom_up(a, b):\n    memo = {0: 1}\n\n    for i in range(1, b + 1):\n        if i % 2 == 1:\n            memo[i] = a * memo[i - 1]\n        else:\n            memo[i] = memo[i // 2] * memo[i // 2]\n\n    return memo[b]\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef power_recursion",
    "def power(a, b):\n    \"\"\"\n    Time Complexity: O(log(n))\n    Space Complexity: O(1)\n    \"\"\"\n    if b == 0:\n        return 1\n    if b < 0:\n        return 1 / power(a, -b)\n    if b % 2:\n        return a * power(a, b - 1)\n    return power(a, b // 2) * power(a, b // 2)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 5))",
    "from functools import reduce\nfrom operator import mul\n\n\ndef power(a, b):\n    return reduce(mul, [a for _ in range(b)])\n\n\nprint(power(2, 10))",
    "from functools import reduce\n\n\ndef power(a, b):\n    return reduce(lambda x, y: x*y, [a] * b, 1)\n\n\nprint(power(2, 3))",
    "from functools import wraps\n\n\ndef power(func):\n    @wraps(func)\n    def wrapper(a, b):\n        return func(a, b)\n    return wrapper\n\n\n@power\ndef calculate_power(a, b):\n    return a ** b\n\n\nprint(calculate_power(2, 3))\nprint(calculate_power(3, 4))",
    "def power(a: int, b: int) -> int:\n    \"\"\"\n    >>> power(2, 3)\n    8\n    >>> power(3, 2)\n    9\n    \"\"\"\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n\n    return a * power(a, b - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import reduce\n\n\n# recursive solution\ndef power_recursive(a, b):\n    if b == 0:\n        return 1\n    else:\n        return a * power_recursive(a, b - 1)\n\n\n# iterative solution\ndef power_iterative(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n\n\n# iterative solution using reduce()\ndef power_iterative_reduce(a, b):\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\nif __name__ == '__main__':\n    print(power_recursive(2, 3))\n    print(power_iterative(2, 3))\n    print(power_iterative_reduce(2, 3))",
    "from icecream import ic\n\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    elif b > 1:\n        return a * power(a, b - 1)\n    else:\n        return a / power(a, -b)\n\n\nif __name__ == \"__main__\":\n    ic(power(2, 3))\n    ic(power(10, 2))\n    ic(power(2, 0))\n    ic(power(2, -3))",
    "from functools import reduce\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_iterative(a, b):\n    if a == 0 or b == 0:\n        return 1\n\n    result = 1\n    while b > 0:\n        if b & 1:\n            result *= a\n\n        a *= a\n        b >>= 1\n\n    return result\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_recursive(a, b):\n    if a == 0 or b == 0:\n        return 1\n\n    if b % 2:\n        return a * power_recursive(a, b - 1)\n\n    return power_recursive(a * a, b >> 1)\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_math_library(a, b):\n    return reduce(lambda x, y: x * y, [a] * b, 1)\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_math_library_optimized(a, b):\n    if b < 0:\n        a = 1 / a\n        b = -b\n\n    return reduce(lambda x, y: x * y, [a] * b, 1)\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_recursive_optimized(a, b):\n    if b == 0:\n        return 1\n\n    half = power_recursive_optimized(a, b >> 1)\n    result = half * half\n    if b & 1:\n        result *= a\n\n    return result\n\n\n# Time complexity: O(log(a))\n# Space complexity: O(log(a))\ndef power_iterative_optimized(a, b):\n    if b < 0:\n        a = 1 / a\n        b = -b\n\n    result = 1",
    "def power(a, b):\n    if b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)\n\nprint(power(3, 3))\nprint(power(2, 4))\nprint(power(4, 5))\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nWrite a function to calculate the factorial of a number.\n\"\"\"\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(3))\nprint(factorial(4))\nprint(factorial(5))\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nWrite a function to calculate the value of 'a' raised to the power 'b' modulo 'm'.\n\"\"\"\n\ndef power_mod(a, b, m):\n    if b == 0:\n        return 1\n    else:\n        return (a % m) * power_mod((a % m), (b - 1), m) % m\n\nprint(power_mod(3, 3, 5))\nprint(power_mod(2, 4, 5))\nprint(power_mod(4, 5, 7))\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nWrite a function to calculate the greatest common divisor of two numbers.\n\"\"\"\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\nprint(gcd(12, 8))\nprint(gcd(16, 4))\nprint(gcd(18, 12))\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nWrite a function to calculate the least common multiple of two numbers.\n\"\"\"\n\ndef lcm(a, b):\n    return a * b / gcd(a, b)\n\nprint(lcm(12, 8))\nprint(lcm(16, 4))\nprint(lcm(18,",
    "from typing import Tuple\n\n\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Return the value of 'a' to the power 'b'.\n\n    >>> power(2, 3)\n    8\n    >>> power(2, 10)\n    1024\n    >>> power(3, 3)\n    27\n    >>> power(10, 0)\n    1\n    \"\"\"\n    return int(a ** b)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from functools import reduce\n\n\ndef power(a, b):\n    return reduce(lambda x, y: x * y, [a for _ in range(b)])\n\n\nif __name__ == \"__main__\":\n    print(power(2, 10))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)\n\n\nprint(power(2, 10))\nprint(power(2, 10000000))",
    "from functools import reduce\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef power(a, b):\n    if b == 0:\n        return 1\n    return a * power(a, b - 1)\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef power2(a, b):\n    if b == 0:\n        return 1\n\n    if b % 2 == 0:\n        return power2(a * a, b / 2)\n    else:\n        return a * power2(a * a, (b - 1) / 2)\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef power3(a, b):\n    if b == 0:\n        return 1\n\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef power4(a, b):\n    if b == 0:\n        return 1\n\n    return reduce(lambda x, y: x * y, [a ** (b / (i + 1)) for i in range(int(b / 2))], 1) * \\\n           reduce(lambda x, y: x * y, [a ** (b / (i + 1)) for i in range(int(b / 2))], 1) if b % 2 == 0 else \\\n           reduce(lambda x, y: x * y, [a ** (b / (i + 1)) for i in range(int(b / 2) + 1)], 1)\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef power5(a, b):\n    if b == 0:\n        return 1\n\n    return reduce(lambda x, y: x * y, [a ** (b / (i + 1)) for i in range(int(b / 2))], 1) * \\\n           a if b % 2 == 0 else \\\n           reduce(lambda x, y: x",
    "def power(a, b):\n    if b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)\n\n\nprint(power(2, 3))",
    "def power(a, b):\n    if a == 0 and b == 0:\n        return \"You can't raise a number to the power of 0\"\n\n    if a < 0 and b % 2 == 0:\n        return \"Negative number can only be raised to an odd power\"\n\n    if a < 0 and b % 2 == 1:\n        return -1 * power(-a, b)\n\n    if b == 0:\n        return 1\n\n    if b < 0:\n        return 1 / power(a, -b)\n\n    if b % 2 == 0:\n        return power(a*a, b/2)\n\n    return a * power(a, b-1)\n\n\nprint(power(2, 2))\nprint(power(2, 3))\nprint(power(2, 4))\nprint(power(2, 5))\nprint(power(2, 6))\nprint(power(2, 7))\nprint(power(2, 8))\nprint(power(2, 9))\nprint(power(2, 10))\nprint(power(2, 11))\nprint(power(2, 12))\nprint(power(2, 13))\nprint(power(2, 14))\nprint(power(2, 15))\nprint(power(2, 16))\nprint(power(2, 17))\nprint(power(2, 18))\nprint(power(2, 19))\nprint(power(2, 20))\nprint(power(2, 21))\nprint(power(2, 22))\nprint(power(2, 23))\nprint(power(2, 24))\nprint(power(2, 25))\nprint(power(2, 26))\nprint(power(2, 27))\nprint(power(2, 28))\nprint(power(2, 29))\nprint(power(2, 30))\nprint(power(2, 31))\nprint(power(2, 32))",
    "from functools import reduce\n\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\ndef test_power():\n    assert power(2, 3) == 8\n    assert power(3, 4) == 81\n    assert power(4, 5) == 1024\n    assert power(5, 6) == 15625\n    assert power(6, 7) == 46656\n    assert power(7, 8) == 390625\n    assert power(8, 9) == 6708164\n    assert power(9, 10) == 943216608\n\n\nif __name__ == \"__main__\":\n    test_power()",
    "from typing import Union\n\n\ndef calculate(a: int, b: int) -> Union[int, float]:\n    \"\"\"Calculate value of 'a' to the power 'b'.\n\n    Args:\n        a (int): base value\n        b (int): power value\n\n    Examples:\n        >>> assert calculate(2, 3) == 8\n        >>> assert calculate(1, 3) == 1\n        >>> assert calculate(2, 10) == 1024\n    \"\"\"\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    print(calculate(2, 3))  # = 8",
    "def power(a, b):\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))",
    "from functools import reduce\n\n\ndef power(a, b):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    return reduce(lambda x, y: x * y, [a for _ in range(b)], 1)\n\n\nif __name__ == \"__main__\":\n    assert power(2, 3) == 8",
    "def calculate_power(a, b):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    Where n is the number of times the number is multiplied\n    \"\"\"\n    if b == 0:\n        return 1\n    if b < 0:\n        return calculate_power(1/a, -b)\n    return a * calculate_power(a, b-1)\n\n\nif __name__ == \"__main__\":\n    print(calculate_power(2, 4))\n    print(calculate_power(2, -4))\n    print(calculate_power(3, 2))\n    print(calculate_power(3, 3))\n    print(calculate_power(3, 4))\n    print(calculate_power(3, 5))",
    "def power(a, b):\n    if b == 0:\n        return 1\n    else:\n        return a * power(a, b - 1)\n\n\nif __name__ == '__main__':\n    print(power(2, 4))",
    "from typing import Tuple\n\n\ndef power(a: int, b: int) -> int:\n    \"\"\"\n    Time Complexity: O(log(b))\n    Space Complexity: O(1)\n    \"\"\"\n    result = 1\n\n    while b > 0:\n        if b & 1:\n            result *= a\n\n        b >>= 1\n        a *= a\n\n    return result\n\n\ndef test(power: Tuple[int, int]) -> None:\n    \"\"\"\n    >>> test((2, 2))\n    4\n    >>> test((2, 3))\n    8\n    >>> test((2, 4))\n    16\n    >>> test((2, 10))\n    1024\n    >>> test((3, 3))\n    27\n    >>> test((3, 10))\n    2187\n    \"\"\"\n    a, b = power(a=power[0], b=power[1])\n\n    print(a)\n\n\nif __name__ == \"__main__\":\n    test((2, 2))\n    test((2, 3))\n    test((2, 4))\n    test((2, 10))\n    test((3, 3))\n    test((3, 10))",
    "from functools import reduce\n\n\ndef power(a, b):\n    return reduce(lambda x, y: x * y, [a for _ in range(b)])\n\n\ndef test_power():\n    assert power(2, 3) == 8\n    assert power(2, 10) == 1024",
    "def power(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b / 2) * power(a, b / 2)\n    else:\n        return a * power(a, b / 2) * power(a, b / 2)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 3))\n    print(power(2, 0))\n    print(power(2, 1))",
    "def power(a, b):\n    if b == 0:\n        return 1\n\n    return a * power(a, b - 1)\n\nif __name__ == '__main__':\n    print(power(2, 4))",
    "def calculate_a_to_power_b(a, b):\n    return a ** b\n\n\nif __name__ == \"__main__\":\n    print(calculate_a_to_power_b(5, 5))",
    "from functools import reduce\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef recursive_power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    elif b % 2 == 0:\n        return recursive_power(a * a, b / 2)\n    else:\n        return a * recursive_power(a, b - 1)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(logb)\ndef iterative_power(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n\n    stack = [a]\n\n    while b > 1:\n        stack.append(stack[-1] * a)\n        b -= 1\n\n    return reduce(lambda x, y: x * y, stack)\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef iterative_power_2(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n\n    result = 1\n    while b > 1:\n        b, remainder = divmod(b, 2)\n        if remainder:\n            result *= a\n        a *= a\n\n    return result * a\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef iterative_power_3(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n\n    result = 1\n    while b > 1:\n        b -= 1\n        result *= a\n        a *= a\n\n    return result * a\n\n\n# Time complexity: O(logb)\n# Space complexity: O(1)\ndef iterative_power_4(a, b):\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n\n    result = 1\n    while b > 0:\n        b, remainder = div",
    "from functools import reduce\n\n\ndef power(a, b):\n    return reduce(lambda x, y: x * y, [a] * b)\n\n\nif __name__ == \"__main__\":\n    print(power(2, 10))",
    "from functools import reduce\n\n\n# Time complexity is O(log(b))\ndef power(a, b):\n    def multiply(a, b):\n        return a * b\n    return reduce(multiply, [a] * b)\n\n\n# Time complexity is O(b)\ndef power_2(a, b):\n    if b == 1:\n        return a\n    elif b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power_2(a, b // 2) * power_2(a, b // 2)\n    else:\n        return a * power_2(a, b // 2) * power_2(a, b // 2)\n\n\nif __name__ == '__main__':\n    print(power(2, 3))\n    print(power_2(2, 3))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}