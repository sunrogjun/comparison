{
  "problem": {
    "task_id": "MBPP/31",
    "prompt": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
    "canonical_solution": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result",
    "test_list": [
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
    ],
    "challenge_test_list": [],
    "problem_id": 20
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from heapq import heappush, heappop\n\n\ndef find_top_k(lists, k):\n    if not lists or k < 1:\n        return []\n\n    queue = []\n\n    for nums in lists:\n        for num in nums:\n            heappush(queue, num)\n            if len(queue) > k:\n                heappop(queue)\n\n    return queue\n\n\ndef main():\n    lists = [[1, 2, 3, 4, 5], [1, 3, 5, 7, 9], [1, 5, 10, 20, 30], [1, 2, 2]]\n    print find_top_k(lists, 3)\n\n\nif __name__ == '__main__':\n    main()",
    "from heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for key in count:\n        heappush(heap, (count[key], key))\n    result = []\n    for i in range(k):\n        result.append(heappop(heap)[1])\n    return result\n\n\nif __name__ == '__main__':\n    print(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "from heapq import heapify, heappush, heappop\n\n\ndef find_top_k_most_frequent(lists, k):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    # create a map to store the number and the number of times it appears in the lists\n    num_count_map = {}\n    for lst in lists:\n        for num in lst:\n            if num in num_count_map:\n                num_count_map[num] += 1\n            else:\n                num_count_map[num] = 1\n\n    # create a min heap queue to store the numbers and the number of times it appears in the lists\n    min_heap = []\n    for num in num_count_map:\n        heappush(min_heap, (num_count_map[num], num))\n\n    # pop the numbers from the heap queue and add them to the result list until k elements are added to the list\n    result = []\n    while len(result) < k:\n        result.append(heappop(min_heap)[1])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(find_top_k_most_frequent([[1, 1, 1, 2, 2, 3], [3, 3, 3, 3, 4, 4, 4, 4, 5, 5], [1, 1, 2, 2, 3, 3, 4, 5]], 3))",
    "import heapq\nfrom typing import List\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements\"\"\"\n\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    heap = []\n    for num, freq in counter.items():\n        heapq.heappush(heap, (freq, num))\n\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert top_k_frequent([1], 1) == [1]\n    assert top_k_frequent([-1, 1, -6, 4, 2, 1, -7, 5], 3) == [-1, 1, 2]",
    "import heapq\n\nclass Solution():\n    # @param A : list of integers\n    # @param B : list of integers\n    # @param K : integer\n    # @return a list of integers\n    def topKFrequent(self, A, B, K):\n        # Write your code here\n        heap = []\n        d = dict()\n        for i in A:\n            d[i] = d.get(i, 0) + 1\n\n        for k, v in d.items():\n            heapq.heappush(heap, (-v, k))\n\n        res = []\n        for i in range(K):\n            res.append(heapq.heappop(heap)[1])\n\n        return res\n\n\nA = [1, 1, 1, 2, 2, 3]\nB = [2, 3, 4, 5, 6, 1]\nK = 2\n\ns = Solution()\nprint(s.topKFrequent(A, B, K))",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(k, arr):\n    freq = {}\n\n    for i in arr:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n\n    heap = []\n\n    for i, j in freq.items():\n        heappush(heap, (j, i))\n\n        if len(heap) > k:\n            heappop(heap)\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    print(top_k_freq(2, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]))",
    "from heapq import heappush, heappop\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums or k <= 0:\n        return []\n    d = {}\n    for num in nums:\n        d[num] = d.get(num, 0) + 1\n    h = []\n    for key in d:\n        heappush(h, (d[key], key))\n        if len(h) > k:\n            heappop(h)\n    res = []\n    for i in range(len(h)):\n        res.append(h[i][1])\n    return res\n\nnums = [1,1,1,2,2,3]\nk = 2\nprint(top_k_frequent(nums, k))",
    "from heapq import heappush, heappop\n\n\ndef find_k_most_frequent_numbers(nums, k):\n    if k < 1 or len(nums) < k:\n        return []\n\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n\n    heap = []\n    for num, freq in count.items():\n        heappush(heap, (-freq, num))\n\n    result = []\n    for i in range(k):\n        result.append(heappop(heap)[1])\n\n    return result\n\n\nprint(find_k_most_frequent_numbers([1, 3, 4, 5, 2, 6, 7, 8], 3))",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(lists, k):\n    heap = []\n    for l in lists:\n        for num in l:\n            heappush(heap, (l.count(num), num))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == '__main__':\n    print(top_k_freq([[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], 3))",
    "import heapq\n\ndef find_k_freq_number(nums, k):\n    if len(nums) == 0 or len(nums) < k:\n        return []\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, num)\n    heap.sort(reverse=True)\n    return heap\n\n\n# test case\nprint(find_k_freq_number([1, 3, 5, 7, 7, 9, 10, 10, 10, 15], 3))",
    "import heapq\n\ndef top_k_freq(nums, k):\n    # O(nlogk)\n    heap = []\n    count = {}\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n\n    for key, val in count.items():\n        heapq.heappush(heap, (-val, key))\n\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\nprint(top_k_freq([1, 2, 3, 2, 4, 3, 5, 6, 2, 4, 1, 4, 6, 7, 8, 9, 1, 3], 3))",
    "import heapq\n\n\ndef top_k_frequent(nums, k):\n    count = {}\n    for n in nums:\n        count[n] = count.get(n, 0) + 1\n\n    pq = []\n    for n, c in count.items():\n        heapq.heappush(pq, (-c, n))\n\n    return [heapq.heappop(pq)[1] for _ in range(k)]\n\n\n# test\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(top_k_frequent(nums, k))",
    "from heapq import heapify, heappop, heappush\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # O(n)\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    # O(n log n)\n    heap = []\n    heapify(heap)\n    for key, value in count.items():\n        heappush(heap, (value, key))\n    return [heappop(heap)[1] for _ in range(k)]\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert top_k_frequent([1], 1) == [1]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_freq(lists, k):\n    if k < 1:\n        raise ValueError(\"k must be positive\")\n\n    c = Counter(lists)\n    heap = []\n\n    for key, value in c.items():\n        heappush(heap, (-value, key))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    print(top_k_freq([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3))",
    "from heapq import heappush, heappop\n\ndef top_k_freq(lists, k):\n    if not lists: return []\n    heap = []\n    for i in lists:\n        heappush(heap, [i, 1])\n    topk = []\n    while k:\n        topk.append(heappop(heap)[0])\n        k -= 1\n    return topk\n\nlists = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7, 9, 10, 11], [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\nprint(top_k_freq(lists, 3))",
    "from typing import List\nfrom heapq import heappush, heappop\n\n\nclass TopKFreq:\n    def __init__(self, k: int):\n        self.k = k\n        self.topk = []\n        self.heap = []\n\n    def push(self, num: int):\n        if num not in self.topk:\n            if len(self.topk) < self.k:\n                self.topk.append(num)\n                heappush(self.heap, (1, num))\n            else:\n                heappush(self.heap, (1, num))\n                if self.heap[0][1] != num:\n                    heappop(self.heap)\n                    self.topk.remove(self.heap[0][1])\n                    self.topk.append(num)\n                    heappush(self.heap, (1, num))\n\n    def get(self) -> List[int]:\n        return sorted(self.topk)\n\n\nif __name__ == \"__main__\":\n    # Test cases:\n    # Input:\n    # [[1, 2, 3, 4, 5], [5, 6, 7, 8], [5, 6, 7, 8], [5, 6, 7, 8]]\n    # 3\n    # Output:\n    # [5, 6, 7]\n    k = 3\n    lists = [[1, 2, 3, 4, 5], [5, 6, 7, 8], [5, 6, 7, 8], [5, 6, 7, 8]]\n    obj = TopKFreq(k)\n    for l in lists:\n        for num in l:\n            obj.push(num)\n    print(obj.get())",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(lists, k):\n    if not lists or not k:\n        return []\n\n    heap = []\n    max_heap = []\n    for num in lists:\n        if num not in heap:\n            heap[num] = 1\n        else:\n            heap[num] += 1\n\n        if len(heap) > k:\n            heappush(max_heap, (-heap[num], num))\n            if len(max_heap) > k:\n                heappop(max_heap)\n\n    heap = dict(heap)\n    for _, num in max_heap:\n        heap[num] += 1\n\n    return heap.keys()\n\n\nassert top_k_freq([], 0) == []\nassert top_k_freq([], 1) == []\nassert top_k_freq([1], 0) == []\nassert top_k_freq([1], 1) == [1]\nassert top_k_freq([1, 2, 3, 3, 3, 4, 5, 5, 5, 5], 0) == []\nassert top_k_freq([1, 2, 3, 3, 3, 4, 5, 5, 5, 5], 1) == [5]\nassert top_k_freq([1, 2, 3, 3, 3, 4, 5, 5, 5, 5], 2) == [5, 3]\nassert top_k_freq([1, 2, 3, 3, 3, 4, 5, 5, 5, 5], 3) == [5, 3, 2]\nassert top_k_freq([1, 2, 3, 3, 3, 4, 5, 5, 5, 5], 4) == [5, 3, 2, 1]\nassert top_k_freq([1, 2, 3, 3,",
    "from heapq import heapify, heappush, heappop\n\ndef topk(lst, k):\n    heap = lst[:k]\n    heapify(heap)\n\n    for num in lst[k:]:\n        if num > heap[0]:\n            heappop(heap)\n            heappush(heap, num)\n\n    return heap\n\nlst = [1, 2, 2, 3, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12]\nprint(topk(lst, 3))",
    "from heapq import heappush, heappop\n\ndef most_freq_k(nums, k):\n    if not nums:\n        return []\n    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n    heap = []\n    for num, freq in freq.items():\n        heappush(heap, (freq, num))\n        if len(heap) > k:\n            heappop(heap)\n    return [item[1] for item in heap]\n\nprint(most_freq_k([1,1,2,3,4,4,4,4,5,6,6,6,7,7,7,8,8,9,9,9,9,10], 4))\nprint(most_freq_k([1,1,1,2,2,3,4,4,4,5,6,6,6,7,7,7,8,8,9,9,9,10], 4))\nprint(most_freq_k([1,1,1,2,2,3,4,4,4,5,6,6,6,7,7,7,8,8,9,9,9,10], 10))\nprint(most_freq_k([1,1,1,2,2,3,4,4,4,5,6,6,6,7,7,7,8,8,9,9,9,10], 1))\nprint(most_freq_k([1,1,1,2,2,3,4,4,4,5,6,6,6,7,7,7,8,8,9,9,9,10], 0))",
    "import heapq\n\n\n# O(N) time, O(k) space\ndef top_k_frequent(nums, k):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    heap = []\n    for num, count in count.items():\n        heapq.heappush(heap, (-count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return [num for _, num in heap]\n\n\n# O(N + KlogN) time, O(k) space\ndef top_k_frequent_sorted_queue(nums, k):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    heap = []\n    for num, count in count.items():\n        heapq.heappush(heap, (count, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return [num for _, num in heap]\n\n\n# O(N + KlogN) time, O(k) space\ndef top_k_frequent_sorted_list(nums, k):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    heap = []\n    for num, count in count.items():\n        heap.append((count, num))\n        heap.sort(reverse=True)\n        if len(heap) > k:\n            heap.pop()\n    return [num for _, num in heap]\n\n\n# O(N) time, O(k) space\ndef top_k_frequent_freq_dict(nums, k):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    return heapq.nlargest(k, count, key=count.get)\n\n\n# O(N) time, O(1) space\ndef top_k_frequent_freq",
    "from heapq import heapify, heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n\t\"\"\"\n\t:type nums: List[int]\n\t:type k: int\n\t:rtype: List[int]\n\t\"\"\"\n\tcount = {}\n\tfor n in nums:\n\t\tcount[n] = count.get(n, 0) + 1\n\t\n\t# max heap\n\theap = []\n\theapify(heap)\n\tfor n, c in count.items():\n\t\theappush(heap, (-c, n))\n\t\n\treturn [n for c, n in heapq.nlargest(k, heap)]\n\n\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))\nprint(top_k_frequent([1], 1))",
    "import heapq\n\n\ndef top_k_freq(k, nums):\n    if k < 1 or not nums:\n        return []\n\n    h = []\n    d = {}\n\n    for n in nums:\n        if n not in d:\n            d[n] = 1\n        else:\n            d[n] += 1\n\n        if len(h) < k:\n            heapq.heappush(h, (d[n], n))\n        else:\n            heapq.heappushpop(h, (d[n], n))\n\n    return [x[1] for x in h]\n\n\n# test case\nprint(top_k_freq(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(top_k_freq(2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(top_k_freq(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(top_k_freq(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\nprint(top_k_freq(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))",
    "from heapq import heapify, heappush, heappop\n\ndef get_top_k_numbers(lists, k):\n    heap = []\n    for lst in lists:\n        for num in lst:\n            heappush(heap, num)\n\n    heapq.heapify(heap)\n\n    return [heapq.heappop(heap) for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    print(get_top_k_numbers([[1, 2, 3, 4, 5], [2, 3, 5, 7, 9], [1, 3, 5, 7, 9, 11]], 2))\n    print(get_top_k_numbers([[1, 2, 3, 4, 5], [2, 3, 5, 7, 9], [1, 3, 5, 7, 9, 11]], 3))\n    print(get_top_k_numbers([[1, 2, 3, 4, 5], [2, 3, 5, 7, 9], [1, 3, 5, 7, 9, 11]], 1))\n    print(get_top_k_numbers([[1, 2, 3, 4, 5], [2, 3, 5, 7, 9], [1, 3, 5, 7, 9, 11]], 6))",
    "import heapq\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k > len(nums):\n        return []\n    if k <= 0:\n        return []\n    counter = {}\n    for n in nums:\n        if n in counter:\n            counter[n] += 1\n        else:\n            counter[n] = 1\n    heap = []\n    for key, value in counter.items():\n        heapq.heappush(heap, (value, key))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent_2(nums, k):\n    counter = {}\n    for n in nums:\n        if n in counter:\n            counter[n] += 1\n        else:\n            counter[n] = 1\n    heap = []\n    for key, value in counter.items():\n        heapq.heappush(heap, (value, key))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == '__main__':\n    # Output: [1]\n    nums = [1]\n    k = 1\n    print(top_k_frequent(nums, k))\n    print(top_k_frequent_2(nums, k))\n\n    # Output: [1, 2]\n    nums = [1, 1, 1, 2, 2, 3]\n    k = 2\n    print(top_k_frequent(nums, k))\n    print(top_k_frequent_2(nums, k))\n\n    # Output: [3, 1]\n    nums = [1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,",
    "from Queue import PriorityQueue\n\ndef top_k_freq(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) == 0 or k == 0:\n        return []\n    pq = PriorityQueue()\n    d = dict()\n    for num in nums:\n        if num in d:\n            d[num] += 1\n        else:\n            d[num] = 1\n        if pq.qsize() < k:\n            pq.put(num)\n        else:\n            if d[pq.get()] < d[num]:\n                pq.put(num)\n    res = []\n    while not pq.empty():\n        res.append(pq.get())\n    return res[::-1]",
    "from heapq import *\n\nclass Solution():\n    # @param A : list of integers\n    # @param B : list of integers\n    # @param C : list of integers\n    # @param D : list of integers\n    # @param E : list of integers\n    # @param F : list of integers\n    # @param G : list of integers\n    # @param H : list of integers\n    # @param K : integer\n    # @return a list of integers\n    def topKFrequent(self, A, B, C, D, E, F, G, H, K):\n        arr = [A, B, C, D, E, F, G, H]\n        for i in range(len(arr)):\n            if len(arr[i]) == 0:\n                arr[i] = []\n            elif len(arr[i]) == 1:\n                arr[i] = [arr[i][0]]\n            else:\n                arr[i] = list(set(arr[i]))\n\n        result = []\n        for i in range(len(arr)):\n            if arr[i]:\n                heappush(result, (arr[i].count(-1), -1))\n                for j in range(len(arr[i])):\n                    heappush(result, (arr[i][j], arr[i][j]))\n\n        ret = []\n        while len(ret) < K:\n            ret.append(heappop(result)[1])\n\n        return ret\n\n\nA = [1, 1, 1, 2, 2, 3]\nB = [1, 2, 2, 3, 3, 4]\nC = [1, 1, 2, 2, 3, 3]\nD = [1, 1, 2, 2, 3, 3]\nE = [1, 2, 2, 3, 3, 4]\nF = [1, 1, 2, 2, 3, 3]\nG = [1, 1, 2, 2, 3, 3]\nH = [1, 2, 2,",
    "import heapq\n\nclass Solution():\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        count = {}\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n\n        heap = []\n        for key, value in count.items():\n            heapq.heappush(heap, (-value, key))\n\n        res = []\n        for i in range(k):\n            res.append(heapq.heappop(heap)[1])\n        return res\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.topKFrequent([1,1,1,2,2,3], 2))",
    "import heapq\nfrom typing import List\n\n\nclass HeapNode:\n    def __init__(self, value: int, freq: int):\n        self.value = value\n        self.freq = freq\n\n    def __lt__(self, other):\n        if self.freq != other.freq:\n            return self.freq < other.freq\n        else:\n            return self.value > other.value\n\n    def __str__(self):\n        return f\"{self.value}-{self.freq}\"\n\n\ndef find_top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogk)\n    Space Complexity: O(k)\n    \"\"\"\n    top_k = []\n    heap = []\n\n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, HeapNode(num, 1))\n        else:\n            if num in heap:\n                heapq.heapreplace(heap, HeapNode(num, heapq.heappop(heap).freq + 1))\n            else:\n                heapq.heappushpop(heap, HeapNode(num, 1))\n\n    while heap:\n        top_k.append(heapq.heappop(heap).value)\n\n    return top_k[::-1]\n\n\nif __name__ == \"__main__\":\n    assert find_top_k_frequent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,",
    "from heapq import heappush, heappop\n\ndef most_frequent_numbers(nums, k):\n    \"\"\"\n    :param nums: list[int]\n    :param k: int\n    :return: list[int]\n    \"\"\"\n    if not nums:\n        return []\n\n    heap = []\n\n    for num in nums:\n        heappush(heap, (num, 1))\n\n    result = []\n    while len(result) < k:\n        num, freq = heappop(heap)\n        result.append(num)\n        heappush(heap, (num, freq + 1))\n\n    return result\n\n\nprint(most_frequent_numbers([1, 2, 3, 4, 2, 3, 1, 2], 2))",
    "from collections import Counter, defaultdict\nfrom heapq import heappush, heappop\n\n\nclass Node:\n    def __init__(self, value, count):\n        self.value = value\n        self.count = count\n\n    def __lt__(self, other):\n        if self.count == other.count:\n            return self.value > other.value\n        return self.count < other.count\n\n    def __eq__(self, other):\n        return self.value == other.value and self.count == other.count\n\n    def __repr__(self):\n        return f\"Node({self.value}, {self.count})\"\n\n\ndef get_most_frequent_items(items, k):\n    counter = Counter(items)\n    most_frequent = heapq.nlargest(k, counter.keys(), key=counter.get)\n    return most_frequent\n\n\ndef get_most_frequent_items_using_heap(items, k):\n    counter = defaultdict(int)\n    heap = []\n\n    for item in items:\n        counter[item] += 1\n        heappush(heap, Node(item, counter[item]))\n\n    most_frequent = []\n    while len(most_frequent) < k:\n        node = heappop(heap)\n        most_frequent.append(node.value)\n\n    return most_frequent\n\n\ndef main():\n    items = [1, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9]\n    k = 3\n    print(get_most_frequent_items(items, k))\n    print(get_most_frequent_items_using_heap(items, k))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from heapq import heappush, heappop\n\ndef top_k_freq(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # we need to get the frequency of each number\n    # we can use a hash table\n    # then we need to find the k top frequency\n    # we can use a max heap\n    # we push the num into the heap, if the size of heap is greater than k, we pop the smallest one\n    # finally, we pop the heap, we will get the top k frequency\n\n    # we use a hash table to get the frequency of each number\n    # we use a max heap to get the top k frequency\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we use a hash table to get the frequency of each number\n    # we use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency\n\n    # we need to use a hash table to get the frequency of each number\n    # we need to use a max heap to get the top k frequency",
    "from heapq import heappush, heappop\n\n\ndef most_frequent_k_numbers(lists, k):\n    \"\"\"\n    :type lists: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for lst in lists:\n        for num in lst:\n            heappush(heap, num)\n            if len(heap) > k:\n                heappop(heap)\n    return heap\n\n\ndef main():\n    print(most_frequent_k_numbers([[1, 3, 4, 5], [2, 3, 5, 6], [3, 4, 5, 6]], 2))\n\n\nif __name__ == '__main__':\n    main()",
    "import heapq\nfrom typing import List\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"Time Complexity: O(Nlogk)\n    Space Complexity: O(N)\n    \"\"\"\n    count = {}\n\n    for num in nums:\n        if num not in count:\n            count[num] = 0\n\n        count[num] += 1\n\n    heap = []\n\n    for key, val in count.items():\n        heapq.heappush(heap, (val, key))\n\n    result = []\n\n    while len(result) < k:\n        result.append(heapq.heappop(heap)[1])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(top_k_frequent([1, 1, 2, 2, 2, 3], 2))\n    print(top_k_frequent([1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4], 3))\n    print(top_k_frequent([1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4], 2))",
    "import heapq\n\n\n# def find_top_k(lst, k):\n#     if not lst or len(lst) < k:\n#         return []\n#\n#     heap = []\n#     for num in lst:\n#         if len(heap) < k:\n#             heapq.heappush(heap, num)\n#         else:\n#             if num > heap[0]:\n#                 heapq.heappop(heap)\n#                 heapq.heappush(heap, num)\n#\n#     return heapq.nlargest(k, heap)\n\n\ndef find_top_k(lst, k):\n    if not lst or len(lst) < k:\n        return []\n\n    heap = []\n    for num in lst:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heapreplace(heap, num)\n\n    return heapq.nlargest(k, heap)\n\n\n# lst = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n# lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n# lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27",
    "from heapq import *\n\n\ndef topk(lists, k):\n    heap = []\n    for l in lists:\n        for i in l:\n            if len(heap) < k:\n                heappush(heap, i)\n            else:\n                if i > heap[0]:\n                    heappop(heap)\n                    heappush(heap, i)\n    return heap\n\n\nif __name__ == \"__main__\":\n    print(topk([[1, 2, 2, 3, 4, 5, 5, 5], [1, 2, 2, 3, 4, 5, 5, 5]], 2))",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    count = Counter(nums)\n    heap = []\n    for key, value in count.items():\n        heappush(heap, (value, key))\n        if len(heap) > k:\n            heappop(heap)\n    return [x[1] for x in heap]\n\n\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "import heapq\nfrom typing import List\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements/\n    \"\"\"\n\n    if k > len(nums):\n        raise ValueError(\"k should be less than len(nums)\")\n\n    # Use heap queue to store top k most frequent elements\n    heap = []\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n        if len(heap) < k:\n            heapq.heappush(heap, (count[num], num))\n        else:\n            if count[num] > heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (count[num], num))\n\n    return [x[1] for x in heap]\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    count = Counter(nums)\n    heap = []\n    for num, count in count.items():\n        if len(heap) < k:\n            heappush(heap, (count, num))\n        elif heap[0][0] < count:\n            heappop(heap)\n            heappush(heap, (count, num))\n    return [item[1] for item in heap]\n\n\ndef main():\n    print(top_k_frequent([1, 1, 1, 2, 2, 3], 2))\n\n\nif __name__ == \"__main__\":\n    main()",
    "class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def __swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n    def __parent(self, i):\n        return (i - 1) // 2\n\n    def __left(self, i):\n        return 2 * i + 1\n\n    def __right(self, i):\n        return 2 * i + 2\n\n    def __up_heapify(self, i):\n        l = self.__left(i)\n        r = self.__right(i)\n        largest = i\n        if l < len(self.heap) and self.heap[largest][1] < self.heap[l][1]:\n            largest = l\n        if r < len(self.heap) and self.heap[largest][1] < self.heap[r][1]:\n            largest = r\n        if largest != i:\n            self.__swap(i, largest)\n            self.__up_heapify(largest)\n\n    def __down_heapify(self, i):\n        l = self.__left(i)\n        r = self.__right(i)\n        smallest = i\n        if l < len(self.heap) and self.heap[smallest][1] > self.heap[l][1]:\n            smallest = l\n        if r < len(self.heap) and self.heap[smallest][1] > self.heap[r][1]:\n            smallest = r\n        if smallest != i:\n            self.__swap(i, smallest)\n            self.__down_heapify(smallest)\n\n    def insert(self, item):\n        self.heap.append(item)\n        i = len(self.heap) - 1\n        while i != 0 and self.heap[i][1] > self.heap[self.__parent(i)][1]:\n            self.__swap(i, self.__parent(i))\n            i = self.__parent",
    "from heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    counter = dict()\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n    heap = []\n    for key, val in counter.items():\n        heappush(heap, (-val, key))\n    return [heappop(heap)[1] for _ in range(k)]\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(lists, k):\n    if not lists:\n        return []\n\n    heap = []\n\n    for l in lists:\n        heappush(heap, (l, 1))\n\n    result = []\n    while len(result) < k:\n        n, c = heappop(heap)\n        result.append(n)\n        heappush(heap, (n, c + 1))\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(top_k_freq([[1, 2, 2, 3, 4, 4, 5, 5, 5, 5], [1, 1, 1, 2, 2, 2, 3, 3], [1, 2, 3, 3, 4, 5, 5, 5, 5, 5]], 3))",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_freq(nums, k):\n    counter = Counter(nums)\n    heap = []\n    for num, cnt in counter.items():\n        heappush(heap, (cnt, num))\n        if len(heap) > k:\n            heappop(heap)\n    return [heappop(heap)[1] for _ in range(len(heap))]\n\n\ndef main():\n    print(top_k_freq([1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6], 3))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from typing import List\nimport heapq\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements/\n    \"\"\"\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    heap = []\n    for key, val in count.items():\n        heapq.heappush(heap, (-val, key))\n\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert top_k_frequent([1], 1) == [1]\n    assert top_k_frequent([1, 2], 2) == [1, 2]\n    assert top_k_frequent([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 6], 2) == [5, 1]",
    "from typing import List\n\nfrom gfg.trees.heap_queue import MinHeap\n\n\ndef find_top_k(lists: List[List[int]], k: int) -> List[int]:\n    heap = MinHeap()\n\n    for list in lists:\n        for num in list:\n            if heap.size < k:\n                heap.push(num)\n            elif num > heap.peek():\n                heap.pop()\n                heap.push(num)\n\n    return heap.extract()\n\n\nif __name__ == \"__main__\":\n    print(find_top_k([[1, 2, 3, 4, 5], [1, 2, 2, 3, 4, 5, 5], [1, 2, 3, 3, 4, 5, 5]], 2))",
    "def top_k_frequent(self, nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(Nlogk)\n    Space Complexity: O(N)\n\n    Note:\n    Use a heap queue to store the frequencies.\n    \"\"\"\n    from collections import Counter, defaultdict\n    from heapq import heappush, heappop\n\n    counts = defaultdict(int)\n    for num in nums:\n        counts[num] += 1\n\n    heap = []\n    for num, count in counts.items():\n        heappush(heap, (-count, num))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent(self, nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(Nlogk)\n    Space Complexity: O(N)\n    \"\"\"\n    from collections import Counter\n    from heapq import heappush, heappop\n\n    counts = Counter(nums)\n\n    heap = []\n    for num, count in counts.items():\n        heappush(heap, (-count, num))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent(self, nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(Nlogk)\n    Space Complexity: O(N)\n\n    Note:\n    Use a dictionary to store the frequencies and a heap queue to store the frequencies.\n    \"\"\"\n    from heapq import heappush, heappop\n\n    counts = defaultdict(int)\n    for num in nums:\n        counts[num] += 1\n\n    heap = []\n    for num, count in counts.items():\n        heappush(heap, (-count, num))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent(self, nums: List[int], k: int) -> List",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(nums: list[int], k: int) -> list[int]:\n    \"\"\"Returns top k frequent integers.\n    \"\"\"\n    if not nums:\n        return []\n\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # build heap with top k most frequent\n    heap = []\n    for num, freq in freq.items():\n        if len(heap) < k:\n            heappush(heap, (-freq, num))\n        elif freq > -heap[0][0]:\n            heappushpop(heap, (-freq, num))\n\n    return [num for _, num in heap]\n\n\nif __name__ == \"__main__\":\n    assert top_k_freq([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert top_k_freq([1, 2, 2, 3, 4, 5], 2) == [1, 2]\n    assert top_k_freq([1, 2, 2, 3, 4, 5], 3) == [2, 1, 3]",
    "from heapq import heappush, heappop\n\ndef top_k_freq(nums, k):\n    \"\"\"\n    :param nums: list[int]\n    :param k: int\n    :return: list[int]\n    \"\"\"\n    if not nums or len(nums) < k:\n        return []\n\n    heap = []\n\n    for n in nums:\n        if len(heap) < k:\n            heappush(heap, (n, 1))\n        elif n > heap[0][0]:\n            heappop(heap)\n            heappush(heap, (n, 1))\n        elif n == heap[0][0]:\n            heap[0] = (n, heap[0][1]+1)\n\n    return [h[0] for h in heap]\n\n\nif __name__ == '__main__':\n    print(top_k_freq([1, 2, 3, 1, 2, 4, 2, 3, 1], 2))\n    print(top_k_freq([1, 2, 3, 1, 2, 4, 2, 3, 1], 3))",
    "from heapq import heapify, heappush, heappop\n\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counter = {}\n        for n in nums:\n            if n in counter:\n                counter[n] += 1\n            else:\n                counter[n] = 1\n        heap = []\n        for k, v in counter.items():\n            heappush(heap, (-v, k))\n        return [heappop(heap)[1] for _ in range(k)]\n\n\na = Solution().topKFrequent([1, 1, 1, 2, 2, 3], 2)\nprint(a)",
    "from heapq import heappush, heappop\n\n\nclass Solution():\n    # @param A : list of integers\n    # @param B : list of integers\n    # @param C : list of integers\n    # @param D : list of integers\n    # @param E : list of integers\n    # @param F : list of integers\n    # @param G : list of integers\n    # @param H : list of integers\n    # @param K : integer\n    # @return a list of integers\n    def topKFrequent(self, A, B, C, D, E, F, G, H, K):\n        heap = []\n        for i in A:\n            heappush(heap, i)\n        return heappop(heap)\n\n\nA = [1, 2]\nB = [2, 3]\nC = [1, 2, 3, 1, 2, 3, 1, 2]\nD = [1, 2, 3]\nE = [1, 1, 1, 2, 2, 2]\nF = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nG = [1]\nH = [1, 2]\nK = 1\n\ns = Solution()\nprint(s.topKFrequent(A, B, C, D, E, F, G, H, K))",
    "from collections import Counter\nfrom heapq import heapify, heappushpop, heappush, heappop\n\n\ndef top_k_freq(lst, k):\n    \"\"\"\n    :param lst: list of integers\n    :param k: integer\n    :return: top k integers that occur most frequently\n    \"\"\"\n    if not lst or len(lst) == 0 or k < 0:\n        return []\n\n    # Create a counter for all the elements in the list\n    counter = Counter(lst)\n    # Create a heap queue with all the elements and their frequency\n    heap = []\n    for key, value in counter.items():\n        heappush(heap, (value, key))\n    # Pop the top k elements from the heap\n    top_k_elements = [heappop(heap) for _ in range(k)]\n    # Sort the elements in descending order and return\n    return sorted(top_k_elements, reverse=True)\n\n\nif __name__ == \"__main__\":\n    print(top_k_freq([1, 2, 2, 3, 4, 5, 6, 6, 6, 7], 3))",
    "from heapq import heapify, heappush, heappop\n\ndef most_frequent_k(lists, k):\n    \"\"\"\n    :param lists: list of sorted and distinct integers\n    :param k: number of most frequent integers\n    :return: k most frequent integers\n    \"\"\"\n    if not lists:\n        return []\n    heap = []\n    heapify(heap)\n    for num in lists:\n        heappush(heap, (-num, num))\n        if len(heap) > k:\n            heappop(heap)\n    result = []\n    while heap:\n        result.append(heappop(heap)[1])\n    return result\n\nimport unittest\nclass TestMostFrequentK(unittest.TestCase):\n\n    def test_most_frequent_k(self):\n        lists = [[1, 2, 3], [2, 3, 4], [2, 3, 5], [2, 3, 6], [2, 3, 7], [2, 3, 8], [2, 3, 9], [2, 3, 10], [2, 3, 11], [2, 3, 12], [2, 3, 13], [2, 3, 14], [2, 3, 15]]\n        self.assertEqual(most_frequent_k(lists, 3), [3, 2, 2])\n\nif __name__ == '__main__':\n    unittest.main()",
    "from heapq import heapify, heappop, heappush\n\n\ndef get_k_most_frequent_items(input_list, k):\n    counter = {}\n\n    for item in input_list:\n        if item not in counter:\n            counter[item] = 1\n        else:\n            counter[item] += 1\n\n    heap = []\n    heapify(heap)\n\n    for key, value in counter.items():\n        heappush(heap, (value, key))\n\n    result = []\n\n    for _ in range(k):\n        result.append(heappop(heap)[1])\n\n    return result\n\n\nprint(get_k_most_frequent_items([1, 2, 1, 1, 2, 3], 2))\nprint(get_k_most_frequent_items([1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4], 2))",
    "from heapq import heappush, heappop\n\ndef topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # use a dict to count the number of each num\n    num_count = {}\n    for num in nums:\n        num_count[num] = num_count.get(num, 0) + 1\n\n    # use a max heap to store the top k frequent number\n    heap = []\n    for num, count in num_count.items():\n        heappush(heap, (-count, num))\n        if len(heap) > k:\n            heappop(heap)\n\n    return [heappop(heap)[1] for _ in range(len(heap))]\n\n\n# test\nnums = [1,1,1,2,2,3]\nk = 2\nprint(topKFrequent(nums, k))",
    "from heapq import heappush, heappop\n\nclass Queue:\n    def __init__(self):\n        self.data = []\n\n    def __bool__(self):\n        return bool(self.data)\n\n    def push(self, x):\n        heappush(self.data, x)\n\n    def pop(self):\n        return heappop(self.data)\n\n\ndef topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k == len(nums):\n        return nums\n\n    freq = {}\n    for num in nums:\n        freq[num] = 1 + freq.get(num, 0)\n\n    heap = Queue()\n    for num, f in freq.items():\n        heap.push((-f, num))\n\n    ans = []\n    for _ in range(k):\n        ans.append(heap.pop()[1])\n    return ans\n\n\n# Test cases:\nprint(topKFrequent([1, 1, 1, 2, 2, 3], 2))\nprint(topKFrequent([1], 1))\nprint(topKFrequent([1, 2], 2))\nprint(topKFrequent([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 6], 1))",
    "import heapq\n\n\ndef find_top_k_frequent_heap(nums, k):\n    \"\"\"\n    :param nums: list[int]\n    :param k: int\n    :return: list[int]\n    \"\"\"\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n\n    heap = []\n    for num, count in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (-count, num))\n        else:\n            heapq.heappushpop(heap, (-count, num))\n\n    return [num for _, num in heap]\n\n\ndef main():\n    print(find_top_k_frequent_heap([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,",
    "from heapq import *\n\n\ndef top_k_freq(arr, k):\n    \"\"\"\n    :param arr: list of sorted and distinct integers\n    :param k: k integers that occur most frequently\n    :return: list of top k integers\n    >>> top_k_freq([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2)\n    [4, 2]\n    >>> top_k_freq([1, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], 3)\n    [5, 4, 1]\n    \"\"\"\n    heap = []\n    for item in arr:\n        if len(heap) < k:\n            heappush(heap, item)\n        else:\n            if item > heap[0]:\n                heappop(heap)\n                heappush(heap, item)\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from heapq import heappush, heappop\n\n\ndef get_top_k_freq(lists, k):\n    top_k_freq = []\n    for lst in lists:\n        for num in lst:\n            if len(top_k_freq) < k:\n                heappush(top_k_freq, (num, 1))\n            else:\n                top_k_freq[0] = heappushpop(top_k_freq, (num, 1))\n    return [x for x, _ in top_k_freq]\n\n\nif __name__ == \"__main__\":\n    assert get_top_k_freq([[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]], 3) == [1, 2, 3]",
    "from heapq import *\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums or k <= 0:\n        return []\n\n    # Create a frequency map\n    freq_map = {}\n    for num in nums:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n\n    # Use a heap queue to store the top k elements\n    heap = []\n    for num, freq in freq_map.items():\n        if len(heap) < k:\n            heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heappushpop(heap, (freq, num))\n\n    return [x[1] for x in heap]\n\n\ndef main():\n    print(top_k_frequent([1, 1, 1, 2, 2, 3], 2))\n    print(top_k_frequent([1], 1))\n\n\nif __name__ == '__main__':\n    main()",
    "import heapq\n\n\ndef find_top_k(lists, k):\n    \"\"\"\n    :type lists: List[List[int]]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # initialize a heap queue\n    heap = []\n\n    # iterate over each list\n    for list_ in lists:\n        # iterate over each element in the list\n        for num in list_:\n            # check if the heap is full\n            if len(heap) == k:\n                # if it is full, check if the current element is greater than the smallest element in the heap\n                if num > heap[0]:\n                    # if it is, pop the smallest element and insert the current element\n                    heapq.heapreplace(heap, num)\n            else:\n                # if it is not full, insert the current element\n                heapq.heappush(heap, num)\n\n    # return the heap\n    return heap\n\n\n# test cases\nlists = [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10], [11, 12, 13, 14, 15]]\nk = 3\nprint(find_top_k(lists, k))",
    "from typing import List\nfrom heapq import heappush, heappop\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements/\"\"\"\n    counter = {}\n    for num in nums:\n        if num in counter:\n            counter[num] += 1\n        else:\n            counter[num] = 1\n\n    heap = []\n\n    for key, value in counter.items():\n        heappush(heap, (value, key))\n        if len(heap) > k:\n            heappop(heap)\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]",
    "class Queue(object):\n    def __init__(self):\n        self.items = []\n\n    def __str__(self):\n        return \"{}\".format(self.items)\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if self.isempty():\n            return None\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n\n    def peek(self):\n        if self.isEmpty():\n            return None\n        return self.items[0]\n\nclass HeapQueue(object):\n    def __init__(self):\n        self.items = []\n\n    def __str__(self):\n        return \"{}\".format(self.items)\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.append(item)\n        self.siftUp(len(self.items) - 1)\n\n    def siftUp(self, i):\n        while i != 0:\n            parent = (i - 1) // 2\n            if self.items[parent] > self.items[i]:\n                self.items[i], self.items[parent] = self.items[parent], self.items[i]\n            i = parent\n\n    def dequeue(self):\n        if self.isEmpty():\n            return None\n        self.siftDown(0, len(self.items) - 1)\n        return self.items.pop()\n\n    def siftDown(self, i, n):\n        while True:\n            minIndex = i\n            l = 2 * i + 1\n            r = 2 * i + 2\n            if l <= n and self.items[l] < self.items[minIndex]:\n                minIndex = l\n            if r <= n and self.items[r] < self.items[minIndex]:\n                minIndex = r\n            if i != minIndex:\n                self.items[i], self.items[min",
    "from collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\n\ndef top_k_frequent(nums: list[int], k: int) -> list[int]:\n    \"\"\"\n    Using heap queue algorithm.\n    \"\"\"\n\n    counter = defaultdict(int)\n    for num in nums:\n        counter[num] += 1\n\n    # We can also use heapq.nlargest(k, counter.values())\n    top_k = sorted(counter.keys(), key=lambda x: counter[x], reverse=True)[:k]\n    return top_k\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], k=2) == [1, 2]\n    assert top_k_frequent([1], k=1) == [1]\n    assert top_k_frequent([1, 2], k=2) == [1, 2]",
    "import heapq\n\nclass Queue:\n    def __init__(self):\n        self.item = []\n\n    def push(self, item):\n        self.item.append(item)\n\n    def pop(self):\n        return self.item.pop(0)\n\n    def empty(self):\n        return len(self.item) == 0\n\n    def size(self):\n        return len(self.item)\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k == 0 or k > len(nums):\n        return []\n\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n\n    heap = Queue()\n    for num in count:\n        heapq.heappush(heap, (count[num], num))\n\n    res = []\n    while not heap.empty() and k > 0:\n        res.append(heapq.heappop(heap)[1])\n        k -= 1\n\n    return res\n\n\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "from collections import Counter\nfrom heapq import heapify, heappush, heappop\n\n\ndef top_k_freq(lists, k):\n    # create a counter\n    cnt = Counter(lists)\n\n    # create a heap\n    heap = []\n    heapify(heap)\n\n    # push each element into heap\n    for key, value in cnt.items():\n        heappush(heap, (-value, key))\n\n    # pop the top k elements from heap\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nlists = [1, 2, 2, 3, 4, 5, 6, 6, 6, 7]\nk = 3\nprint(top_k_freq(lists, k))",
    "from typing import List\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements\"\"\"\n    from collections import Counter\n    from heapq import heappush, heappop\n\n    counts = Counter(nums)\n    heap: List[tuple[int, int]] = []\n    for num, count in counts.items():\n        heappush(heap, (count, num))\n        if len(heap) > k:\n            heappop(heap)\n    return [x[1] for x in heap][::-1]\n\n\nif __name__ == \"__main__\":\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(nums: list, k: int) -> list:\n    \"\"\"Return top k integers that occur most frequently.\n\n    Args:\n        nums: list of sorted and distinct integers\n        k: number of integers to return\n\n    Returns:\n        list of integers that occur most frequently\n\n    Raises:\n        AssertionError: if nums is not list of sorted and distinct integers\n        AssertionError: if k is not positive integer\n    \"\"\"\n    assert isinstance(nums, list)\n    assert all(isinstance(n, int) for n in nums)\n    assert all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1))\n    assert isinstance(k, int)\n    assert k > 0\n\n    freq = {}\n    for n in nums:\n        freq[n] = freq.get(n, 0) + 1\n\n    heap = []\n    for key, value in freq.items():\n        heappush(heap, (value, key))\n\n    return [heappop(heap)[1] for _ in range(k)]",
    "def top_k_freq(nums, k):\n    # init a heap queue with size k\n    # with (count, num) pair\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, (num, 1))\n        else:\n            # pop the smallest one\n            smallest = heapq.heappop(heap)\n            # if current num is bigger than smallest one, put it back\n            if num > smallest[0]:\n                heapq.heappush(heap, (num, 1))\n            # if smaller than smallest one, put it back with plus 1 count\n            else:\n                heapq.heappush(heap, (smallest[0], smallest[1] + 1))\n    return heap\n\n\nprint(top_k_freq([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 15, 15, 15, 16, 17, 17, 17], 3))",
    "def top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) < k:\n        return []\n\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    heap = []\n    for num, count in counter.items():\n        heapq.heappush(heap, (count, num))\n\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent_v2(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) < k:\n        return []\n\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    heap = []\n    for num, count in counter.items():\n        heapq.heappush(heap, (-count, num))\n\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\ndef top_k_frequent_v3(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) < k:\n        return []\n\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    return [key for key, _ in counter.items() if counter[key] == max(counter.values())]\n\n\ndef top_k_frequent_v4(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) < k:\n        return",
    "def top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # O(n)\n    num_dict = dict()\n    for num in nums:\n        num_dict[num] = num_dict.get(num, 0) + 1\n    # O(nlogn)\n    heap = []\n    for num, freq in num_dict.items():\n        heapq.heappush(heap, (freq, num))\n    # O(nlogk)\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from collections import defaultdict\n\n\ndef top_k_frequent(self, nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # O(nlogn)\n    # O(n)\n    # return self.top_k_frequent_heap(nums, k)\n    # O(n)\n    # return self.top_k_frequent_counting(nums, k)\n    # O(n)\n    # return self.top_k_frequent_hashmap(nums, k)\n    # O(n)\n    # return self.top_k_frequent_dict(nums, k)\n    # O(n)\n    # return self.top_k_frequent_bucket_sort(nums, k)\n    # O(n)\n    return self.top_k_frequent_max_heap(nums, k)\n\n\ndef top_k_frequent_heap(self, nums, k):\n    \"\"\"\n    T: O(nlogk)\n    The heap queue algorithm\n\n    Heap queue algorithm is the most intuitive one.\n    The idea is to use a heap queue to store the top k most frequent integers.\n    For each integer in the array, we count the frequency of that integer.\n    Then we push the integer into the heap queue.\n    Finally, we pop the top k integers in the heap queue.\n\n    The time complexity is O(nlogk) since we push n integers into the heap queue and pop k integers from it.\n    The space complexity is O(k) since we only use a heap queue to store the top k integers.\n    \"\"\"\n    import heapq\n\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    max_heap = []\n    for num in count:\n        heapq.heappush(max_heap, (-count[num], num))\n        if len(max_heap) > k:\n            heapq.heappop(max_heap)\n\n    return [x[1]",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\ndef top_k_freq(lists, k):\n    if not lists or k == 0:\n        return []\n\n    # counts\n    counter = Counter(lists)\n\n    # heap\n    heap = []\n\n    for i in range(k):\n        heappush(heap, (-counter[i], i))\n\n    for key, val in counter.items():\n        if key < k:\n            heappush(heap, (-val, key))\n\n    res = []\n    while heap:\n        res.append(heappop(heap)[1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(top_k_freq([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10], 5))\n\n\n\n\n\n\n    \"\"\"\n    Ideas/thoughts:\n    1) use counter to count the elements\n    2) use heap to sort the elements, then pop the top k elements\n    3) iterate through the counter to find the elements and insert into heap\n\n    \"\"\"",
    "import heapq\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    count = {}\n    for i in range(len(nums)):\n        if nums[i] not in count:\n            count[nums[i]] = 1\n        else:\n            count[nums[i]] += 1\n    for key, value in count.items():\n        heapq.heappush(heap, (-value, key))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\nif __name__ == '__main__':\n    print(top_k_frequent([1, 1, 1, 2, 2, 3], 2))",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(nums, k):\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    heap = []\n    for key, val in counter.items():\n        heappush(heap, (-val, key))\n\n    result = []\n    for _ in range(k):\n        val, num = heappop(heap)\n        result.append(num)\n\n    return result\n\n\nprint(top_k_freq([-1, -1, 1, 1, 2, 2, 3, 3, 4, 5], 2))",
    "from heapq import heappush, heappop\n\n\ndef get_most_frequent(lists, k):\n    \"\"\"Get top k frequent elements.\n\n    Args:\n        lists (list): list of list of integers\n        k (int): the number of frequent elements\n\n    Returns:\n        list: list of integers\n    \"\"\"\n    heap = []\n    for lst in lists:\n        for num in lst:\n            heappush(heap, num)\n            if len(heap) > k:\n                heappop(heap)\n    return sorted(heap)\n\n\nif __name__ == '__main__':\n    lists_ = [[1, 2, 3, 4, 5], [2, 3, 5, 6, 7], [1, 3, 5, 7, 9]]\n    print(get_most_frequent(lists_, 3))",
    "from Queue import PriorityQueue\n\n\nclass Heap(object):\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.size = 0\n        self.heap = [0] * capacity\n        self.position = [0] * capacity\n\n    def push(self, element):\n        if self.size >= self.capacity:\n            return False\n\n        self.size += 1\n        self.heap[self.size - 1] = element\n        self.position[element] = self.size - 1\n\n        self.shift_up(self.size - 1)\n\n    def pop(self):\n        if self.size == 0:\n            return False\n\n        ret = self.heap[0]\n        self.size -= 1\n        self.heap[0] = self.heap[self.size]\n        self.position[self.heap[0]] = 0\n        self.shift_down(0)\n\n        return ret\n\n    def top(self):\n        return self.heap[0]\n\n    def shift_up(self, index):\n        while index != 0 and self.heap[index] > self.heap[index // 2]:\n            self.swap(index, index // 2)\n            index = index // 2\n\n    def shift_down(self, index):\n        while index * 2 < self.size:\n            min_child_index = self.min_child(index)\n            if self.heap[index] > self.heap[min_child_index]:\n                self.swap(index, min_child_index)\n            index = min_child_index\n\n    def min_child(self, index):\n        if index * 2 + 1 >= self.size:\n            return index * 2\n        else:\n            if self.heap[index * 2] < self.heap[index * 2 + 1]:\n                return index * 2\n            else:\n                return index * 2 + 1\n\n    def swap(self, index_a, index_b):\n        self.heap[index",
    "from heapq import heappush, heappop\nfrom typing import List\nfrom collections import Counter\n\n\ndef top_k_freq(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements\"\"\"\n\n    counter = Counter(nums)\n    heap = []\n    for num, count in counter.items():\n        heappush(heap, (count, num))\n\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nif __name__ == \"__main__\":\n    # Test 1\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    k = 4\n    print(top_k_freq(nums, k))\n\n    # Test 2\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    k = 2\n    print(top_k_freq(nums, k))",
    "from heapq import heappush, heappop\n\ndef top_k_freq(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    counter = {}\n    for num in nums:\n        if num in counter:\n            counter[num] += 1\n        else:\n            counter[num] = 1\n\n    heap = []\n    for num, count in counter.items():\n        if len(heap) == k:\n            if count > heap[0][0]:\n                heappop(heap)\n                heappush(heap, (count, num))\n        else:\n            heappush(heap, (count, num))\n\n    return [item[1] for item in heap]\n\nprint(top_k_freq([1, 1, 1, 2, 2, 3], 2))",
    "import heapq\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    freq = {}\n    for num in nums:\n        if num not in freq:\n            freq[num] = 1\n        else:\n            freq[num] += 1\n    heap = []\n    for num, freq in freq.items():\n        heapq.heappush(heap, (-freq, num))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert top_k_frequent([1], 1) == [1]\n    assert top_k_frequent([1, 2], 2) == [1, 2]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from heapq import *\n\n\ndef top_k_freq(k, arr):\n    heap = []\n    for item in arr:\n        if len(heap) < k:\n            heappush(heap, item)\n        elif item > heap[0]:\n            heappushpop(heap, item)\n\n    return heap\n\n\nprint(top_k_freq(3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]))",
    "from heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    h = []\n    d = {}\n    for num in nums:\n        d[num] = d.get(num, 0) + 1\n\n    for key, value in d.items():\n        heappush(h, (value, key))\n\n    result = []\n    for i in range(k):\n        result.append(heappop(h)[1])\n\n    return result\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from heapq import heapify, heappop, heapreplace\n\n\ndef top_k_freq(lists, k):\n    \"\"\"\n    :param: lists - list of sorted distinct integers\n    :param: k - number of integers to return\n    :return: list of integers with top k frequency\n    \"\"\"\n    if not lists or k <= 0:\n        return []\n    heap = lists[:k]\n    heapify(heap)\n    for num in lists[k:]:\n        if num > heap[0]:\n            heapreplace(heap, num)\n    return sorted(heappop(heap) for _ in range(k))\n\n\ndef test_function(test_case):\n    lists = test_case[0]\n    k = test_case[1]\n    solution = test_case[2]\n    output = top_k_freq(lists, k)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\nlists = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nk = 5\nsolution = [10, 9, 8, 7, 6]\ntest_case = [lists, k, solution]\ntest_function(test_case)\n\nlists = [5, 3, 2, 1, 4, 6, 8, 10, 9, 7]\nk = 4\nsolution = [10, 9, 8, 7]\ntest_case = [lists, k, solution]\ntest_function(test_case)\n\nlists = [5, 3, 2, 1, 4, 6, 8, 10, 9, 7]\nk = 1\nsolution = [10]\ntest_case = [lists, k, solution]\ntest_function(test_case)\n\nlists = [5, 3, 2, 1, 4, 6, 8, 10, 9, 7]\nk = 10\nsolution = [10, 9, 8",
    "from heapq import heappush, heappop\n\ndef topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    heap = []\n    for num, freq in count.items():\n        heappush(heap, (freq, num))\n\n    result = []\n    while k:\n        result.append(heappop(heap)[1])\n        k -= 1\n\n    return result\n\n\nprint(topKFrequent([1,1,1,2,2,3], 2))",
    "import heapq\n\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        d = {}\n        for num in nums:\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n        heap = []\n        for key, val in d.items():\n            heapq.heappush(heap, (val, key))\n        return [heapq.heappop(heap)[1] for _ in range(k)]",
    "from heapq import heapify, heappush, heappop\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k <= 0 or not nums:\n        return []\n    freq = {}\n    for num in nums:\n        if num not in freq:\n            freq[num] = 1\n        else:\n            freq[num] += 1\n    heap = []\n    heapify(heap)\n    for num, freq in freq.items():\n        heappush(heap, (-freq, num))\n    return [heappop(heap)[1] for _ in range(k)]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(top_k_frequent(nums, 2))",
    "import heapq\n\n\n# time complexity: O(nlogk), space complexity: O(k)\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n\n    # create a dictionary to store the count of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    # create a max heap to store the numbers\n    heap = []\n    for num, count in count.items():\n        heapq.heappush(heap, (-count, num))\n\n    # create a list to store the top k numbers\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n\n    return res\n\n\n# test cases:\nprint(top_k_frequent([1, 1, 1, 2, 2, 3], 2))\nprint(top_k_frequent([1], 1))\nprint(top_k_frequent([1, 2], 2))",
    "import heapq\n\n\ndef top_k_freq(lists, k):\n\tif not lists:\n\t\treturn []\n\n\theap = []\n\tfor list in lists:\n\t\tfor num in list:\n\t\t\tif len(heap) < k:\n\t\t\t\theapq.heappush(heap, num)\n\t\t\telse:\n\t\t\t\tif num > heap[0]:\n\t\t\t\t\theapq.heappop(heap)\n\t\t\t\t\theapq.heappush(heap, num)\n\n\treturn heapq.nlargest(k, heap)\n\n\nif __name__ == '__main__':\n\tprint(top_k_freq([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8]], 3))\n\tprint(top_k_freq([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8]], 10))\n\tprint(top_k_freq([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8]], 1))",
    "from heapq import heappush, heappop\n\n\ndef top_k_frequent(nums: list[int], k: int) -> list[int]:\n    \"\"\"\n    Using heap queue algorithm.\n    \"\"\"\n    if not nums:\n        return []\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    heap = []\n    for num, freq in count.items():\n        heappush(heap, (freq, num))\n    return [num for freq, num in [heappop(heap) for _ in range(k)]]\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([[1, 1, 1, 2, 2, 3], 2], [1, 2]),\n        ([[1], 1], [1]),\n        ([[1, 1, 2, 2, 3, 3], 3], [1, 2, 3]),\n    ]\n    for test_case, expected_result in test_cases:\n        assert expected_result == top_k_frequent(*test_case)",
    "import heapq\n\n\nclass HeapQueue:\n    def __init__(self):\n        self.q = []\n\n    def push(self, item):\n        heapq.heappush(self.q, item)\n\n    def pop(self):\n        return heapq.heappop(self.q)\n\n    def peek(self):\n        return self.q[0]\n\n    def __len__(self):\n        return len(self.q)\n\n\ndef top_k_freq(arr, k):\n    # O(n)\n    freq = {}\n    for i in arr:\n        if i not in freq:\n            freq[i] = 0\n        freq[i] += 1\n\n    heap = HeapQueue()\n    for key, value in freq.items():\n        if len(heap) < k:\n            heap.push((-value, key))\n        else:\n            if value > -heap.peek()[0]:\n                heap.pop()\n                heap.push((-value, key))\n\n    res = []\n    while len(heap) > 0:\n        _, item = heap.pop()\n        res.append(item)\n    return res\n\n\nif __name__ == \"__main__\":\n    # fmt: off\n    test_cases = [\n        [[1, 2, 3, 4, 5], 3],\n        [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 5]\n    ]\n    results = [\n        [3, 4, 5],\n        [10, 9, 8]\n    ]\n    # fmt: on\n\n    for test_case, correct_result in zip(test_cases, results):\n        assert (\n            top_k_freq(test_case[0], test_case[1]) == correct_result\n        ), f\"My result: {top_k_freq(test_case[0], test_case[1])}; Correct result: {correct_result}\"",
    "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_freq(k, nums):\n    cnt = Counter(nums)\n    heap = []\n    for key, value in cnt.items():\n        if len(heap) < k:\n            heappush(heap, (value, key))\n        elif heap[0][0] < value:\n            heappop(heap)\n            heappush(heap, (value, key))\n\n    return [x[1] for x in heap]\n\n\nprint(top_k_freq(1, [1, 2, 3, 2, 1, 1, 2, 3, 1]))",
    "from typing import List, Tuple\nfrom heapq import heappush, heappop\n\n\ndef top_k_frequent(nums: List[int], k: int) -> List[int]:\n    \"\"\"https://leetcode.com/problems/top-k-frequent-elements\"\"\"\n\n    def top_k(nums: List[int], k: int) -> List[int]:\n        heap = []\n\n        for num in nums:\n            heappush(heap, (num, 1))\n\n        return [heappop(heap)[0] for _ in range(k)]\n\n    def top_k_v2(nums: List[int], k: int) -> List[int]:\n        counter = {}\n\n        for num in nums:\n            if num in counter:\n                counter[num] += 1\n            else:\n                counter[num] = 1\n\n        return top_k(counter, k)\n\n    def top_k_v3(nums: List[int], k: int) -> List[int]:\n        counter = {}\n\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n\n        return top_k(counter, k)\n\n    def top_k_v4(nums: List[int], k: int) -> List[int]:\n        counter = {}\n\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n\n        heap = []\n\n        for num, count in counter.items():\n            heappush(heap, (count, num))\n\n        return [heappop(heap)[1] for _ in range(k)]\n\n    def top_k_v5(nums: List[int], k: int) -> List[int]:\n        counter = {}\n\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n\n        heap = []\n\n        for num, count in counter.items():\n            heappush(heap, (count, num))\n\n        return [heappop(",
    "import heapq\n\nclass Queue(object):\n    def __init__(self):\n        self.data = []\n\n    def push(self, x):\n        heapq.heappush(self.data, x)\n\n    def pop(self):\n        return heapq.heappop(self.data)\n\n    def peek(self):\n        return self.data[0]\n\n    def size(self):\n        return len(self.data)\n\nclass Solution():\n    # @param A : list of integers\n    # @param B : list of integers\n    # @param C : list of integers\n    # @param K : integer\n    # @return a list of integers\n    def topKFrequent(self, A, B, C, K):\n        freq = {}\n        for i in A:\n            if i not in freq:\n                freq[i] = 1\n            else:\n                freq[i] += 1\n        for i in B:\n            if i not in freq:\n                freq[i] = 1\n            else:\n                freq[i] += 1\n        for i in C:\n            if i not in freq:\n                freq[i] = 1\n            else:\n                freq[i] += 1\n        queue = Queue()\n        for k, v in freq.iteritems():\n            queue.push((-v, k))\n        res = []\n        while queue.size() > K:\n            res.append(queue.pop()[1])\n        return res\n\nA = [1, 1, 1, 2, 2, 3]\nB = [1, 2, 2, 3, 3, 4, 4, 4, 5]\nC = [1, 2, 2, 3, 4, 4, 4, 5, 5]\nK = 2\nprint Solution().topKFrequent(A, B, C, K)",
    "def most_frequent_k_numbers(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums or len(nums) < k:\n        return []\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    pq = []\n    for num, cnt in count.items():\n        if len(pq) == k:\n            if cnt > -pq[0][0]:\n                heapq.heapreplace(pq, (-cnt, num))\n        else:\n            heapq.heappush(pq, (-cnt, num))\n    res = []\n    for cnt, num in pq:\n        res.append(-cnt)\n    return res\n\n\ndef test_most_frequent_k_numbers():\n    assert most_frequent_k_numbers([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n    assert most_frequent_k_numbers([1], 1) == [1]\n    assert most_frequent_k_numbers([1, 2], 2) == [1, 2]\n    assert most_frequent_k_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [10, 9, 8, 7, 6]\n\n\nif __name__ == '__main__':\n    test_most_frequent_k_numbers()",
    "import heapq\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    counter = {}\n    for num in nums:\n        if num not in counter:\n            counter[num] = 1\n        else:\n            counter[num] += 1\n\n    min_heap = []\n    for num, count in counter.items():\n        heapq.heappush(min_heap, (count, num))\n\n    return [heapq.heappop(min_heap)[1] for _ in range(k)]\n\n\ndef test_top_k_frequent():\n    assert top_k_frequent([1, 1, 1, 2, 2, 3], 2) == [1, 2]\n\n\nif __name__ == '__main__':\n    test_top_k_frequent()",
    "from heapq import heappush, heappop\n\n\nclass Node:\n    def __init__(self, value, count):\n        self.value = value\n        self.count = count\n\n    def __lt__(self, other):\n        return self.count > other.count\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    counts = {}\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    heap = []\n    for num, count in counts.items():\n        node = Node(num, count)\n        heappush(heap, node)\n        if len(heap) > k:\n            heappop(heap)\n    result = []\n    while heap:\n        node = heappop(heap)\n        result.append(node.value)\n    return result\n\n\n# test case\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nk = 3\nprint(top_k_frequent(nums, k))",
    "from heapq import heapify, heappush, heappop\n\n\nclass Frequency:\n    def __init__(self, num, freq):\n        self.num = num\n        self.freq = freq\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :param: nums - input array\n    :param: k - top k elements\n    return: k most frequent elements\n    \"\"\"\n    if not nums or k == 0:\n        return []\n\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    heap = []\n    heapify(heap)\n\n    for num, freq in count.items():\n        heappush(heap, Frequency(num, freq))\n\n        if len(heap) > k:\n            heappop(heap)\n\n    result = []\n    while heap:\n        freq = heappop(heap)\n        result.append(freq.num)\n\n    return result\n\n\nprint(top_k_frequent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56",
    "import heapq\n\nclass Solution():\n    def top_k_freq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or k == 0:\n            return []\n\n        # build a frequency dict\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        # build a max heap with k elements\n        heap = []\n        for num, freq in freq.items():\n            if len(heap) < k:\n                heapq.heappush(heap, (freq, num))\n            elif freq > heap[0][0]:\n                heapq.heappushpop(heap, (freq, num))\n\n        # return the top k elements in a list\n        result = []\n        while heap:\n            result.append(heapq.heappop(heap)[1])\n\n        return result\n\n\na = Solution()\nprint(a.top_k_freq([1,1,1,2,2,3], 2))\nprint(a.top_k_freq([1], 1))\nprint(a.top_k_freq([1,1,1,2,2,3,3,3,3], 3))",
    "from heapq import heappush, heappop\n\n\ndef top_k_freq(nums, k):\n    top_k = []\n\n    for num in nums:\n        if len(top_k) < k:\n            heappush(top_k, (num, 1))\n        elif num > top_k[0][0]:\n            heappush(top_k, (num, 1))\n            heappop(top_k)\n\n    return top_k\n\n\nprint(top_k_freq([1, 1, 2, 2, 3, 3, 4, 4, 5, 5], 2))\nprint(top_k_freq([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4))",
    "from heapq import heappush, heappop\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    heap = []\n    for key, value in count.items():\n        heappush(heap, (value, key))\n    result = []\n    for i in range(k):\n        result.append(heappop(heap)[1])\n    return result\n\n\nnums = [1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,",
    "from heapq import heappush, heappop\n\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums or not k:\n        return []\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    heap = []\n    for key, val in count.items():\n        heappush(heap, (val, key))\n    res = []\n    while k:\n        res.append(heappop(heap)[1])\n        k -= 1\n    return res\n\n\n# test case\nprint(top_k_frequent([1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], 3))",
    "from heapq import heappush, heappop\n\ndef topKFrequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    h = []\n    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n\n    for num, freq in freq.items():\n        heappush(h, (freq, num))\n\n    return [heappop(h)[1] for _ in range(k)]\n\n# test\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}