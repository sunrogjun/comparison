{
  "problem": {
    "task_id": "MBPP/39",
    "prompt": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
    "canonical_solution": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")",
    "test_list": [
      "assert rearange_string(\"aab\")==('aba')",
      "assert rearange_string(\"aabb\")==('abab')",
      "assert rearange_string(\"abccdd\")==('cdabcd')"
    ],
    "challenge_test_list": [],
    "problem_id": 28
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from collections import Counter\n\n\ndef re_arrange(string):\n    if len(string) == 0:\n        return True\n    string_counter = Counter(string)\n    visited = [False] * len(string)\n    visited[0] = True\n    prev = string[0]\n    for i in range(1, len(string)):\n        if string_counter[prev] > 1:\n            string_counter[prev] -= 1\n            visited[i] = True\n            prev = string[i]\n        else:\n            for j in range(i):\n                if not visited[j] and string[j] != prev:\n                    prev = string[j]\n                    visited[j] = True\n                    break\n            else:\n                return False\n    return True\n\n\nif __name__ == \"__main__\":\n    assert re_arrange(\"aab\") == True\n    assert re_arrange(\"aabb\") == False\n    assert re_arrange(\"abcdefghijklmopqrstuvwxyz\") == True",
    "def rearrange(s):\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    odd_count = 0\n    for c in count:\n        if c % 2 == 1:\n            odd_count += 1\n    if odd_count > 1:\n        return False\n\n    visited = [False] * 26\n    for i in range(len(s) - 1):\n        if not visited[ord(s[i]) - ord('a')] and not visited[ord(s[i + 1]) - ord('a')]:\n            if s[i] == s[i + 1]:\n                return False\n            visited[ord(s[i]) - ord('a')] = True\n            visited[ord(s[i + 1]) - ord('a')] = True\n    return True",
    "def rearrange_string(input_string):\n    input_string = sorted(input_string)\n    # print(input_string)\n    index_list = []\n    for i in range(len(input_string)):\n        if i != 0:\n            if input_string[i] == input_string[i - 1]:\n                index_list.append(i)\n    index_list.append(len(input_string))\n    # print(index_list)\n    result = \"\"\n    for i in range(len(index_list) - 1):\n        for j in range(index_list[i], index_list[i + 1]):\n            result += input_string[j]\n    return result\n\n\n# print(rearrange_string(\"aab\"))",
    "def rearrange_string(str):\n    if len(str) <= 1:\n        return str\n\n    result = \"\"\n    used_chars = set()\n    str_list = list(str)\n    str_list.sort()\n\n    for i in range(len(str_list)):\n        if str_list[i] in used_chars:\n            continue\n\n        result += str_list[i]\n        used_chars.add(str_list[i])\n\n        j = i + 1\n        while j < len(str_list):\n            if str_list[j] not in used_chars:\n                result += str_list[j]\n                used_chars.add(str_list[j])\n            j += 1\n\n    return result\n\n\nprint(rearrange_string(\"aab\"))\nprint(rearrange_string(\"vvvlo\"))\nprint(rearrange_string(\"aabb\"))\nprint(rearrange_string(\"aaab\"))",
    "def can_be_rearranged(string):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if not string:\n        return False\n\n    char_count = {}\n\n    for char in string:\n        if char not in char_count:\n            char_count[char] = 1\n        else:\n            char_count[char] += 1\n\n    sorted_count = sorted(char_count.values())\n\n    if sorted_count[-1] == 1:\n        return True\n\n    if sorted_count[-1] == 2:\n        if sorted_count[-2] == 1:\n            return True\n        if sorted_count[-2] == 2:\n            return False\n        if sorted_count[-2] > 2:\n            return True\n\n    if sorted_count[-1] > 2:\n        return False\n\n    return False\n\ndef main():\n    print(can_be_rearranged(\"\"))\n    print(can_be_rearranged(\"abc\"))\n    print(can_be_rearranged(\"aabb\"))\n    print(can_be_rearranged(\"aabbcc\"))\n    print(can_be_rearranged(\"abcabc\"))\n    print(can_be_rearranged(\"abcabca\"))\n    print(can_be_rearranged(\"abcabcabca\"))\n\nif __name__ == \"__main__\":\n    main()",
    "def rearrange_chars(input_string):\n    # TODO: Write your solution here\n    pass\n\n\n# Test Cases:\nprint(rearrange_chars(\"programming\"))\nprint(rearrange_chars(\"apples\"))\nprint(rearrange_chars(\"pleasant\"))\nprint(rearrange_chars(\"pale\"))\nprint(rearrange_chars(\"ale\"))\nprint(rearrange_chars(\"alexp\"))",
    "def check_rearranged_string(string: str) -> bool:\n    \"\"\"\n    We can use a dictionary to keep track of the count of each character in the string.\n    Then we can check if any of the counts are greater than 1.\n    If so, we can check if the difference between the max and min is greater than 1.\n    \"\"\"\n    char_count = {}\n\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in char_count:\n        if char_count[char] > 1:\n            if max(char_count.values()) - min(char_count.values()) > 1:\n                return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert check_rearranged_string(\"aab\") is True\n    assert check_rearranged_string(\"aabb\") is False",
    "from collections import Counter\n\n\ndef check_adjacent_different(string):\n    if len(string) <= 1:\n        return True\n\n    char_count = Counter(string)\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n\n    if sorted_chars[0][1] > 1:\n        return False\n\n    for i in range(1, len(string) - 1):\n        if sorted_chars[i][1] > 1 and sorted_chars[i - 1][0] == sorted_chars[i][0]:\n            return False\n\n    return True\n\n\nprint(check_adjacent_different(\"aab\"))\nprint(check_adjacent_different(\"aabb\"))\nprint(check_adjacent_different(\"abcdefghijklmno\"))\nprint(check_adjacent_different(\"aabbcdeefghijklmno\"))",
    "def check_adjacent_different(str):\n    if len(str) < 2:\n        return False\n    sorted_str = sorted(str)\n    for i in range(len(sorted_str) - 1):\n        if sorted_str[i] == sorted_str[i + 1]:\n            return False\n    return True\n\nprint(check_adjacent_different(\"aab\"))\nprint(check_adjacent_different(\"aabb\"))\nprint(check_adjacent_different(\"abc\"))",
    "def check_adjacent(string):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if not string:\n        return True\n\n    if len(string) == 1:\n        return False\n\n    if len(string) == 2:\n        return True\n\n    # sort the string\n    string = \"\".join(sorted(string))\n\n    # get the first char\n    first_char = string[0]\n\n    # iterate over the string\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            return False\n\n        if i == len(string) - 1:\n            return True\n\n        # check if the next char is the same as the first char\n        if string[i] == first_char:\n            return False\n\n    return True\n\n\ndef check_adjacent_without_sorting(string):\n    \"\"\"\n    Time Complexity: O(n^2)\n    Space Complexity: O(n)\n    \"\"\"\n    if not string:\n        return True\n\n    if len(string) == 1:\n        return False\n\n    if len(string) == 2:\n        return True\n\n    # use a set to store the chars in the string\n    char_set = set()\n\n    # iterate over the string\n    for i in range(len(string)):\n        char_set.add(string[i])\n\n    # check if the length is odd\n    if len(char_set) % 2 == 1:\n        return False\n\n    # check if the chars are adjacent\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            return False\n\n    return True\n\n\ndef main():\n\n    string = \"abcde\"\n    print(check_adjacent(string))\n\n    string = \"aabb\"\n    print(check_adjacent(string))\n\n    string = \"aabbc\"\n    print(check_adjacent(string))\n\n    string = \"abba\"\n    print(check_",
    "def rearrange_string(s):\n    if len(s) <= 1:\n        return True\n\n    letter_count = {}\n    for letter in s:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n\n    max_count = max(letter_count.values())\n    min_count = min(letter_count.values())\n\n    if max_count == min_count:\n        return True\n\n    if max_count == 1:\n        return False\n\n    max_letter = max([(letter_count[letter], letter) for letter in letter_count], key=lambda x: x[0])[1]\n\n    s = s.replace(max_letter, \"\")\n    return rearrange_string(s)\n\n\nprint(rearrange_string(\"aab\"))\nprint(rearrange_string(\"leetcode\"))\nprint(rearrange_string(\"abbcccddddeeeeedcba\"))\nprint(rearrange_string(\"triplepillooooow\"))\nprint(rearrange_string(\"hooraaaaaaaaaaay\"))\nprint(rearrange_string(\"hooraaaaaaaaaaayx\"))",
    "def check_adjacent_diff(string):\n    if len(string) <= 1:\n        return True\n\n    string = string.lower()\n    sorted_string = sorted(string)\n\n    for i in range(len(string) - 1):\n        if sorted_string[i] == sorted_string[i + 1]:\n            return False\n\n    return True\n\n\nassert check_adjacent_diff(\"a\") == True, \"Should be True\"\nassert check_adjacent_diff(\"aab\") == True, \"Should be True\"\nassert check_adjacent_diff(\"abb\") == True, \"Should be True\"\nassert check_adjacent_diff(\"abbbc\") == False, \"Should be False\"\nassert check_adjacent_diff(\"abccb\") == False, \"Should be False\"\nassert check_adjacent_diff(\"abcdef\") == True, \"Should be True\"\nassert check_adjacent_diff(\"abcdefa\") == True, \"Should be True\"",
    "def check_adjacent_characters(string):\n    # Sort the string\n    string = sorted(string)\n\n    # Create a dictionary of characters and their frequency\n    char_dict = {}\n    for char in string:\n        if char not in char_dict:\n            char_dict[char] = 1\n        else:\n            char_dict[char] += 1\n\n    # Check if the string can be rearranged\n    if len(string) > len(char_dict):\n        return False\n    else:\n        return True\n\n\nprint(check_adjacent_characters(\"aab\"))\nprint(check_adjacent_characters(\"abc\"))\nprint(check_adjacent_characters(\"abb\"))\nprint(check_adjacent_characters(\"abcc\"))\nprint(check_adjacent_characters(\"abbc\"))\nprint(check_adjacent_characters(\"abccc\"))\nprint(check_adjacent_characters(\"abbcc\"))",
    "def check_adjacent_characters(string):\n    string = string.lower()\n    string = sorted(string)\n    for i in range(len(string)-1):\n        if string[i] == string[i+1]:\n            return False\n    return True",
    "def check(string):\n    \"\"\"\n    Checks if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Args:\n       string(string): String to check\n    Returns:\n       bool: Returns True if the letters can be rearranged, False otherwise\n    \"\"\"\n    if string == \"\":\n        return True\n\n    if len(string) == 1:\n        return False\n\n    if len(string) == 2:\n        return True\n\n    string = sorted(string)\n\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            return False\n\n    return True\n\n\ndef test_function(test_case):\n    string = test_case[0]\n    solution = test_case[1]\n    output = check(string)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\nstring = \"aappp\"\nsolution = False\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"Programming\"\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"aab\"\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"Code\"\nsolution = False\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"abcdefghijklmnopqrstuvwxyz\"\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"a\"\nsolution = False\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = \"ab\"\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)",
    "from collections import defaultdict\n\ndef rearrange_string(input_string):\n    \"\"\"\n    Time Complexity: O(n*n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(input_string) <= 1:\n        return True\n\n    char_count = defaultdict(int)\n\n    for char in input_string:\n        char_count[char] += 1\n\n    selected_chars = []\n\n    for char in input_string:\n        if char_count[char] > 0:\n            selected_chars.append(char)\n            char_count[char] -= 1\n\n    if len(selected_chars) <= 1:\n        return True\n\n    selected_chars_set = set(selected_chars)\n\n    for char in selected_chars:\n        for other_char in selected_chars_set - {char}:\n            if is_adjacent(char, other_char):\n                return True\n\n    return False\n\n\ndef is_adjacent(char1, char2):\n    return abs(ord(char1) - ord(char2)) == 1\n\n\nif __name__ == \"__main__\":\n    print(rearrange_string(\"a\"))\n    print(rearrange_string(\"abc\"))\n    print(rearrange_string(\"aa\"))\n    print(rearrange_string(\"abcd\"))\n    print(rearrange_string(\"abcda\"))\n    print(rearrange_string(\"aabb\"))",
    "from collections import defaultdict\nfrom typing import List\n\n\ndef check_adjacent(string: str) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(string) < 2:\n        return True\n\n    string_to_char_index = defaultdict(list)\n\n    for index, char in enumerate(string):\n        string_to_char_index[char].append(index)\n\n    visited = [False] * len(string)\n    result = True\n\n    for index, char in enumerate(string):\n        if visited[index]:\n            continue\n\n        visited[index] = True\n\n        for next_index in string_to_char_index[char]:\n            if next_index == index:\n                continue\n\n            if not visited[next_index]:\n                visited[next_index] = True\n                break\n        else:\n            result = False\n\n    return result\n\n\ndef check_adjacent_2(string: str) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(string) < 2:\n        return True\n\n    string_to_char_index = defaultdict(list)\n\n    for index, char in enumerate(string):\n        string_to_char_index[char].append(index)\n\n    sorted_string_to_char_index = sorted(string_to_char_index.items())\n\n    start, end = 0, len(string) - 1\n\n    while start < end:\n        char, indexes = sorted_string_to_char_index[start]\n\n        if indexes[-1] >= end:\n            return False\n\n        start += 1\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent(\"aab\") == True\n    assert check_adjacent(\"aabb\") == True\n    assert check_adjacent(\"abc\") == True\n    assert check_adjacent(\"abcc\") == False\n    assert check_adjacent(\"abbc\") == False\n    assert check_adjacent(\"",
    "def check_adjacent_chars(s):\n    chars = {}\n    for c in s:\n        if c in chars:\n            chars[c] += 1\n        else:\n            chars[c] = 1\n\n    for key, value in chars.items():\n        if value > 1:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    print(check_adjacent_chars('aab'))\n    print(check_adjacent_chars('aabb'))\n    print(check_adjacent_chars('abcabc'))\n    print(check_adjacent_chars('aaa'))",
    "def check_adjacent_different(s):\n    # create a hashmap to track the frequency of each char in the string\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # sort the hashmap by frequency\n    sorted_freq = sorted(char_freq.items(), key=lambda kv: kv[1])\n\n    # check if the adjacent chars are different\n    for i in range(len(sorted_freq) - 1):\n        if sorted_freq[i][0] == sorted_freq[i+1][0]:\n            return False\n\n    return True",
    "from collections import defaultdict\n\n\ndef rearrange_string(input_str):\n    char_map = defaultdict(list)\n\n    for index, char in enumerate(input_str):\n        char_map[char].append(index)\n\n    sorted_char_map = sorted(char_map.items(), key=lambda item: len(item[1]), reverse=True)\n\n    result = [\"#\"] * len(input_str)\n\n    for char, indexes in sorted_char_map:\n        indexes = sorted(indexes)\n\n        for index in indexes:\n            if result[index] == \"#\":\n                result[index] = char\n            else:\n                return False\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"aba\", \"a#b#\"),\n        (\"abc\", \"a#b#c#\"),\n        (\"aaab\", \"b#a#a#\"),\n        (\"vvvvvvv\", \"vvvvvvv\"),\n        (\"vvvvvvve\", \"vvvvvve#\"),\n        (\"vvvvvvev\", \"vvvvv#e#v\"),\n        (\"vvvvvevv\", \"vvvv#e#vv\"),\n        (\"vvvvevvv\", \"vvv#e#vvv\"),\n        (\"vvvevvvv\", \"vv#e#vvvv\"),\n        (\"vvevvvvv\", \"v#e#vvvvv\"),\n        (\"vevvvvvv\", \"#e#vvvvvv\"),\n        (\"hefedcba\", \"#e#vvvvvv\"),\n        (\"zxvftsrgmikcuohwjblpyndqema\", \"#e#vvvvvv\"),\n    ]\n\n    for test_string, expected_output in test_cases:\n        output = rearrange_string(test_string)\n        assert output == expected_output, f\"expected {expected_output}, got {output}\"",
    "def rearrange_chars(input_str):\n    input_str = list(input_str)\n    input_str.sort()\n    for i in range(len(input_str)-1):\n        if input_str[i] == input_str[i+1]:\n            return False\n    return True\n\nprint(rearrange_chars('aappp'))\nprint(rearrange_chars('Programming'))\nprint(rearrange_chars('aottpp'))\nprint(rearrange_chars('Programming Is Cool'))",
    "def rearrange_letters(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    # check if the length of the string is odd, if so, return empty string\n    if len(s) % 2 != 0:\n        return \"\"\n\n    # initialize a dictionary to store the frequency of each letter in the string\n    freq_map = {}\n    for char in s:\n        if char not in freq_map:\n            freq_map[char] = 1\n        else:\n            freq_map[char] += 1\n\n    # check if there is a letter appears more than once\n    for key in freq_map:\n        if freq_map[key] > 1:\n            return \"\"\n\n    # sort the characters of the string\n    sorted_s = \"\".join(sorted(s))\n\n    # initialize two pointers to the first and last letters of the string\n    left, right = 0, len(sorted_s)-1\n    res = []\n    # iterate through the sorted string\n    while left < right:\n        # append the first letter to the result\n        res.append(sorted_s[left])\n        # move the left pointer to the first letter which is not the same as the previous letter\n        while left < right and sorted_s[left] == sorted_s[left+1]:\n            left += 1\n        # append the last letter to the result\n        res.append(sorted_s[right])\n        # move the right pointer to the last letter which is not the same as the previous letter\n        while left < right and sorted_s[right] == sorted_s[right-1]:\n            right -= 1\n        # decrease the length of the string by 2\n        left, right = left+1, right-1\n\n    # append the last letter to the result\n    res.append(sorted_s[right])\n\n    return \"\".join(res)\n\n# test case 1\ns = \"aab\"\nprint(rearrange_letters(s))\n\n# test case 2\ns = \"aaab\"\nprint(rearrange_letters(s))\n\n# test case",
    "from collections import defaultdict\n\n\ndef rearrange_string(input_str):\n    if len(input_str) <= 1:\n        return True\n    dict_count = defaultdict(int)\n    for i in input_str:\n        dict_count[i] += 1\n    print(dict_count)\n    # check if two letters that are adjacent to each other are different\n    # check if a letter that is not adjacent to the other letter is present\n    for i in range(len(input_str) - 1):\n        if input_str[i] == input_str[i + 1]:\n            return False\n    for i in range(len(input_str) - 2):\n        if dict_count[input_str[i]] > 1:\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    assert rearrange_string(\"aab\") == True\n    assert rearrange_string(\"aaab\") == True\n    assert rearrange_string(\"vvvlo\") == True\n    assert rearrange_string(\"vvvo\") == False\n    assert rearrange_string(\"baccd\") == True",
    "def rearrange_chars(input_string):\n    if not input_string:\n        return False\n\n    char_freq = {}\n    for char in input_string:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    sorted_freq = sorted(char_freq.values())\n\n    if len(sorted_freq) == 1:\n        return True\n\n    if sorted_freq[0] > 1:\n        return False\n\n    for i in range(1, len(sorted_freq)):\n        if sorted_freq[i] == sorted_freq[i - 1]:\n            return False\n\n    return True\n\n\nprint(rearrange_chars(\"aabbcc\"))\nprint(rearrange_chars(\"aaaabbc\"))\nprint(rearrange_chars(\"ababcb\"))",
    "def check_adjacent_chars(string: str) -> bool:\n    \"\"\"Checks if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Args:\n        string (str): the string to check.\n\n    Examples:\n        >>> assert check_adjacent_chars(\"aab\") == True\n        >>> assert check_adjacent_chars(\"aabb\") == False\n        >>> assert check_adjacent_chars(\"abc\") == True\n    \"\"\"\n    string_list = list(string)\n    string_list.sort()\n    string_list.append(string_list[0])\n    for i in range(len(string_list) - 1):\n        if string_list[i] == string_list[i + 1]:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_chars(\"aab\"))\n    print(check_adjacent_chars(\"aabb\"))\n    print(check_adjacent_chars(\"abc\"))",
    "from collections import Counter\n\n\ndef check_adjacent_different(string):\n    string = string.lower()\n    if len(string) == 0:\n        return True\n\n    count = Counter(string)\n    if len(count) == 1:\n        return True\n\n    used = set()\n    for i, char in enumerate(string):\n        if i == 0:\n            used.add(char)\n            continue\n        if string[i - 1] != char and char in count and count[char] > 0:\n            used.add(char)\n        if i == len(string) - 1 and len(used) != len(count):\n            return False\n    return True\n\n\n# test\nstring = 'aabb'\nprint(check_adjacent_different(string))\n\nstring = 'aab'\nprint(check_adjacent_different(string))\n\nstring = 'aabc'\nprint(check_adjacent_different(string))\n\nstring = 'abc'\nprint(check_adjacent_different(string))\n\nstring = 'abc'\nprint(check_adjacent_different(string))\n\nstring = 'aaaa'\nprint(check_adjacent_different(string))\n\nstring = 'aaaaa'\nprint(check_adjacent_different(string))\n\nstring = ''\nprint(check_adjacent_different(string))",
    "def rearrange_string(input_string):\n    # O(n log n)\n    input_string = sorted(input_string)\n    print(input_string)\n    i = 0\n    while i < len(input_string):\n        if i > 0 and input_string[i] == input_string[i - 1]:\n            return False\n        i += 1\n    return True\n\n\nprint(rearrange_string(\"aacc\"))\nprint(rearrange_string(\"abc\"))",
    "def rearrange_string(input_string):\n    # 1. get all the characters in the string\n    char_list = [char for char in input_string]\n    # 2. sort the list\n    char_list.sort()\n\n    # 3. create a list with all the adjacent characters\n    # 4. check if they are different\n    # 5. if they are not, return false\n    for i in range(len(char_list) - 1):\n        if char_list[i] == char_list[i+1]:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(rearrange_string(\"aabb\"))\n    print(rearrange_string(\"aab\"))\n    print(rearrange_string(\"abc\"))",
    "from collections import Counter\n\ndef rearrange_letters(s):\n    freq = Counter(s)\n    result = []\n    for i in range(len(s)):\n        if freq[s[i]] == 1:\n            continue\n        freq[s[i]] -= 1\n        for j in range(len(s)):\n            if i != j and freq[s[j]] > 0:\n                freq[s[j]] -= 1\n                result.append((s[i], s[j]))\n                break\n    return result\n\n\nif __name__ == \"__main__\":\n    assert rearrange_letters(\"aab\") == [(\"a\", \"b\")]\n    assert rearrange_letters(\"aaabbb\") == [(\"a\", \"b\"), (\"a\", \"b\"), (\"a\", \"b\")]\n    assert rearrange_letters(\"aaabbc\") == [(\"a\", \"c\"), (\"a\", \"c\")]\n    assert rearrange_letters(\"axyz\") == []",
    "def rearrange_chars(string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(string) <= 1:\n        return True\n\n    freq = {}\n    for char in string:\n        if char not in freq:\n            freq[char] = 1\n        else:\n            freq[char] += 1\n\n    count = 0\n    for char, value in freq.items():\n        if value % 2 == 1:\n            count += 1\n\n    return count < 2\n\n\nif __name__ == \"__main__\":\n    print(rearrange_chars(\"a\"))\n    print(rearrange_chars(\"aaaa\"))\n    print(rearrange_chars(\"aabb\"))\n    print(rearrange_chars(\"aabbc\"))\n    print(rearrange_chars(\"aabbcc\"))",
    "from collections import Counter\n\n\ndef check_adjacent(string):\n    if len(string) < 2:\n        return False\n    string_count = Counter(string)\n    string_list = list(string)\n    sorted_string = sorted(string_list)\n    sorted_string_count = Counter(sorted_string)\n    for i in range(len(string_list) - 1):\n        if sorted_string[i] == sorted_string[i + 1]:\n            if string_count[sorted_string[i]] > 1:\n                string_count[sorted_string[i]] -= 1\n                sorted_string_count[sorted_string[i]] -= 1\n            else:\n                return False\n        else:\n            if sorted_string_count[sorted_string[i]] == 1:\n                sorted_string_count[sorted_string[i]] -= 1\n                string_count[sorted_string[i]] -= 1\n                continue\n            if sorted_string_count[sorted_string[i + 1]] == 1:\n                sorted_string_count[sorted_string[i + 1]] -= 1\n                string_count[sorted_string[i + 1]] -= 1\n                continue\n            else:\n                string_count[sorted_string[i]] -= 1\n                sorted_string_count[sorted_string[i]] -= 1\n                string_count[sorted_string[i + 1]] -= 1\n                sorted_string_count[sorted_string[i + 1]] -= 1\n    return True\n\n\nprint(check_adjacent(\"aab\"))\nprint(check_adjacent(\"abc\"))\nprint(check_adjacent(\"abac\"))\nprint(check_adjacent(\"aabb\"))\nprint(check_adjacent(\"aabbc\"))\nprint(check_adjacent(\"aabbcc\"))\nprint(check_adjacent(\"abcabc\"))\nprint(check_adjacent(\"abcabcabc\"))",
    "def check_adjacent_difference(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(input_str) == 0:\n        return False\n\n    input_str = sorted(input_str)\n    char_set = set()\n    char_map = {}\n    for i in range(len(input_str)):\n        if input_str[i] in char_set:\n            return True\n        char_set.add(input_str[i])\n        if input_str[i] not in char_map:\n            char_map[input_str[i]] = []\n        char_map[input_str[i]].append(i)\n\n    for i in range(len(input_str) - 1):\n        if input_str[i] == input_str[i + 1]:\n            return True\n\n        if char_map[input_str[i]][0] < char_map[input_str[i + 1]][0]:\n            if input_str[i + 1] not in char_map[input_str[i]]:\n                return True\n        else:\n            if input_str[i] not in char_map[input_str[i + 1]]:\n                return True\n\n    return False\n\n\ndef test_function(test_case):\n    string = test_case[0]\n    solution = test_case[1]\n    output = check_adjacent_difference(string)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\nstring = 'aappp'\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = 'Programming'\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = 'mississippi'\nsolution = False\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = 'aaba'\nsolution = False\ntest_case = [string, solution]\ntest_function",
    "def check_adjacent_different(string):\n    if len(string) < 2:\n        return True\n\n    string = sorted(string)\n    if string[0] == string[1]:\n        return False\n\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_different(\"aab\"))\n    print(check_adjacent_different(\"aabb\"))\n    print(check_adjacent_different(\"abc\"))\n    print(check_adjacent_different(\"abbc\"))\n    print(check_adjacent_different(\"abbca\"))",
    "def reorder_string(s):\n    # find the max number of occurrences of each char\n    max_count = {}\n    for c in s:\n        max_count[c] = max_count.get(c, 0) + 1\n    \n    # find the minimum number of occurrences\n    min_count = min([max_count[c] for c in max_count])\n\n    # check if the number of occurrences is the same\n    if min_count == len(max_count):\n        return \"No\"\n\n    # check if there are more than 1 char with the same minimum number of occurrences\n    if len([max_count[c] for c in max_count if max_count[c] == min_count]) > 1:\n        return \"No\"\n\n    return \"Yes\"\n\nprint(reorder_string(\"abbcccdddd\"))\nprint(reorder_string(\"abbccddee\"))\nprint(reorder_string(\"abcdefgh\"))",
    "def rearrange(string):\n    # check if all characters are unique\n    if len(set(string)) != len(string):\n        return False\n\n    # sort the characters of the string\n    string = sorted(string)\n    # create a list of all adjacent letters\n    adjacent_letters = []\n    for i in range(len(string) - 1):\n        adjacent_letters.append((string[i], string[i + 1]))\n\n    # check if adjacent letters are different\n    for i in range(len(adjacent_letters) - 1):\n        if adjacent_letters[i] == adjacent_letters[i + 1]:\n            return False\n\n    return True",
    "from collections import Counter\n\n\ndef re_arrange(string):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if not string:\n        return False\n\n    c = Counter(string)\n    if len(c) == 1:\n        return True\n\n    sorted_char = sorted(c.items(), key=lambda x: x[1], reverse=True)\n\n    if sorted_char[0][1] == 1:\n        sorted_char = sorted_char[1:]\n    if sorted_char[-1][1] == 1:\n        sorted_char = sorted_char[:-1]\n\n    if sorted_char[0][1] == 1:\n        return False\n\n    sorted_char_2 = sorted(sorted_char[1:], key=lambda x: x[1], reverse=True)\n    for i in range(len(sorted_char_2)):\n        if sorted_char[0][0] != sorted_char_2[i][0]:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert re_arrange(\"abc\") == True\n    assert re_arrange(\"aaa\") == False\n    assert re_arrange(\"aabb\") == False\n    assert re_arrange(\"aabbc\") == True",
    "from collections import Counter\n\n\ndef rearrange_letters(string: str) -> str:\n    \"\"\"Checks if the letters of a given string can be rearranged so that two characters\n    that are adjacent to each other are different.\n\n    Args:\n        string (str): input string.\n\n    Examples:\n        >>> assert rearrange_letters('aappp')\n        >>> assert rearrange_letters('Programming')\n        >>> assert not rearrange_letters('Programming Language')\n    \"\"\"\n    if len(string) <= 1:\n        return True\n\n    count = Counter(string)\n\n    first = []\n    second = []\n\n    for character in string:\n        if count[character] == 1:\n            first.append(character)\n        elif count[character] == 2:\n            second.append(character)\n        else:\n            count[character] -= 1\n\n    if len(first) > len(second):\n        first, second = second, first\n\n    return _rearrange_letters(first, second, count)\n\n\ndef _rearrange_letters(first: list[str], second: list[str], count: Counter) -> bool:\n    if not second:\n        return True\n\n    for character in second:\n        count[character] -= 1\n        if count[character] == 1:\n            first.append(character)\n        elif count[character] == 0:\n            second.remove(character)\n            count.pop(character)\n\n    return _rearrange_letters(first, second, count)\n\n\nif __name__ == \"__main__\":\n    print(rearrange_letters(\"Programming\"))",
    "# O(n * n!) time | O(n) space\ndef generate_permutations(string):\n    permutations = []\n\n    def generate_permutations_recursive(idx, current_permutation):\n        if idx == len(string):\n            permutations.append(\"\".join(current_permutation))\n            return\n\n        for i in range(len(string)):\n            if string[i] not in current_permutation:\n                current_permutation[idx] = string[i]\n                generate_permutations_recursive(idx + 1, current_permutation)\n\n    generate_permutations_recursive(0, [\"\"] * len(string))\n    return permutations\n\n\ndef generate_adjacent_characters(string):\n    adjacent_characters = []\n    for i in range(len(string) - 1):\n        adjacent_characters.append(string[i] + string[i + 1])\n    return adjacent_characters\n\n\ndef rearrangable(string):\n    permutations = generate_permutations(string)\n    adjacent_characters = generate_adjacent_characters(string)\n    return len(adjacent_characters) in [\n        len(permutation)\n        for permutation in permutations\n        if all(pair not in permutation for pair in adjacent_characters)\n    ]",
    "from collections import Counter\n\n\ndef can_be_rearranged(input_str):\n    if len(input_str) < 2:\n        return False\n\n    freq_count = Counter(input_str)\n    sorted_chars = sorted(freq_count.keys())\n    sorted_freq_count = [freq_count[c] for c in sorted_chars]\n\n    for i in range(len(sorted_freq_count)):\n        if sorted_freq_count[i] == 1:\n            continue\n\n        for j in range(i + 1, len(sorted_freq_count)):\n            if sorted_freq_count[j] > 1:\n                sorted_freq_count[i] -= 1\n                sorted_freq_count[j] -= 1\n\n                if i < j:\n                    sorted_chars[i], sorted_chars[j] = sorted_chars[j], sorted_chars[i]\n\n                if can_be_rearranged(\"\".join(sorted_chars)):\n                    return True\n\n                sorted_freq_count[i] += 1\n                sorted_freq_count[j] += 1\n\n                if i < j:\n                    sorted_chars[i], sorted_chars[j] = sorted_chars[j], sorted_chars[i]\n\n    return False\n\n\nprint(can_be_rearranged(\"aab\"))\nprint(can_be_rearranged(\"aabb\"))",
    "def check_adjacent(input_str):\n    letters = {}\n\n    for char in input_str:\n        if char.isalpha():\n            if char.lower() in letters:\n                letters[char.lower()] += 1\n            else:\n                letters[char.lower()] = 1\n\n    print(letters)\n\n    for letter, count in letters.items():\n        if count > 1:\n            return False\n\n    return True\n\nprint(check_adjacent(\"abcdef\"))\nprint(check_adjacent(\"aabcd\"))\nprint(check_adjacent(\"abcde\"))",
    "from collections import Counter\n\ndef rearrange_string(input_str):\n    input_str = list(input_str)\n    hash_table = Counter(input_str)\n    max_count = max(hash_table.values())\n    min_count = min(hash_table.values())\n    if max_count - min_count > 1:\n        return False\n    for key, value in hash_table.items():\n        if value == max_count:\n            hash_table.pop(key)\n            break\n    for key, value in hash_table.items():\n        if value == min_count:\n            hash_table.pop(key)\n            break\n    return True\n\n\ndef test_function():\n    assert rearrange_string(\"abba\") == False\n    assert rearrange_string(\"abcd\") == True\n    assert rearrange_string(\"qwerty\") == False\n    assert rearrange_string(\"maxx\") == True\n    assert rearrange_string(\"aabb\") == True\n    assert rearrange_string(\"aabBc\") == False",
    "def check_adjacent_diff(str):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(str) < 2:\n        return True\n\n    str = list(str)\n    str.sort()\n\n    for i in range(len(str)-1):\n        if str[i] == str[i+1]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    print(check_adjacent_diff(\"abcde\"))\n    print(check_adjacent_diff(\"aabb\"))\n    print(check_adjacent_diff(\"vvvw\"))",
    "def can_be_rearranged(string):\n    \"\"\"\n    Time Complexity: O(n*n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(string) <= 1:\n        return True\n    freq_dict = {}\n    for char in string:\n        if char not in freq_dict:\n            freq_dict[char] = 0\n        freq_dict[char] += 1\n\n    sorted_freq_dict = sorted(freq_dict.items(), key=lambda x: x[1])\n    if len(sorted_freq_dict) <= 1:\n        return True\n\n    char_count = 0\n    for char, count in sorted_freq_dict:\n        char_count += count\n        if char_count > 1:\n            return False\n\n    return True\n\n\nprint(can_be_rearranged(\"abc\"))\nprint(can_be_rearranged(\"aabb\"))\nprint(can_be_rearranged(\"aab\"))\nprint(can_be_rearranged(\"aaabb\"))",
    "def check_adjacent(string: str) -> bool:\n    \"\"\"\n    >>> check_adjacent(\"abcde\")\n    True\n    >>> check_adjacent(\"aabbcde\")\n    False\n    \"\"\"\n    string = string.lower()\n    chars = sorted(set(string))\n    last_char = chars[0]\n    for i in range(1, len(chars)):\n        if chars[i] == last_char:\n            return False\n        last_char = chars[i]\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def check_adjacent_different(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_str:\n        return False\n\n    from collections import Counter\n    freq = Counter(input_str)\n\n    if len(freq) == 1:\n        return True\n\n    from itertools import permutations\n    for perm in permutations(freq.keys()):\n        for i in range(len(perm) - 1):\n            if perm[i] == perm[i + 1]:\n                return False\n    return True\n\ndef check_adjacent_different2(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_str:\n        return False\n\n    from itertools import permutations\n    for perm in permutations(input_str):\n        for i in range(len(perm) - 1):\n            if perm[i] == perm[i + 1]:\n                return False\n    return True\n\n\ndef check_adjacent_different3(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_str:\n        return False\n\n    from itertools import permutations\n    for perm in permutations(input_str):\n        for i in range(len(perm) - 1):\n            if perm[i] == perm[i + 1]:\n                return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_different(\"aab\"))\n    print(check_adjacent_different(\"aabb\"))\n    print(check_adjacent_different(\"abcde\"))\n    print(check_adjacent_different(\"abcdef\"))\n    print(check_adjacent_different(\"abab\"))",
    "def check_adjacent_chars_different(string):\n    \"\"\"\n    Time complexity: O(n*n!)\n    Space complexity: O(n)\n    \"\"\"\n    string = list(string)\n    def is_solvable(string, used_chars=[]):\n        if len(string) == 1:\n            return True\n        for i in range(len(string)):\n            if string[i] in used_chars:\n                continue\n            used_chars.append(string[i])\n            string = string[:i] + string[i+1:]\n            if is_solvable(string, used_chars):\n                return True\n            string = string[:i] + string[i] + string[i+1:]\n        return False\n    return is_solvable(string)\n\n\ndef check_adjacent_chars_different_2(string):\n    \"\"\"\n    Time complexity: O(n*n!)\n    Space complexity: O(n)\n    \"\"\"\n    string = list(string)\n    def is_solvable(string, used_chars=[]):\n        if len(string) == 1:\n            return True\n        for i in range(len(string)):\n            if string[i] in used_chars:\n                continue\n            used_chars.append(string[i])\n            string = string[:i] + string[i+1:]\n            if is_solvable(string, used_chars):\n                return True\n            string = string[:i] + string[i] + string[i+1:]\n        return False\n    return is_solvable(string)\n\n\ndef check_adjacent_chars_different_3(string):\n    \"\"\"\n    Time complexity: O(n*n!)\n    Space complexity: O(n)\n    \"\"\"\n    string = list(string)\n    def is_solvable(string, used_chars=[]):\n        if len(string) == 1:\n            return True\n        for i in range(len(string)):\n            if string[i] in used_chars:\n                continue\n            used_chars.append(string[",
    "from collections import Counter\n\n\ndef check_adjacent_chars(string: str) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(string) < 2:\n        return False\n\n    char_count = Counter(string)\n\n    def check_adjacent(i: int, j: int) -> bool:\n        if string[j] == string[i + 1]:\n            return True\n        elif string[i] == string[j + 1]:\n            return True\n        return False\n\n    for i in range(len(string) - 1):\n        for j in range(i + 1, len(string)):\n            if char_count[string[i]] > 1 and char_count[string[j]] > 1:\n                if check_adjacent(i, j):\n                    return True\n    return False\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent_chars(\"aab\") == True\n    assert check_adjacent_chars(\"adbc\") == False\n    assert check_adjacent_chars(\"acdcd\") == True\n    assert check_adjacent_chars(\"cdcdb\") == True\n    assert check_adjacent_chars(\"aaa\") == False\n    assert check_adjacent_chars(\"\") == False\n    assert check_adjacent_chars(\"a\") == False\n    assert check_adjacent_chars(\"abc\") == False",
    "def check_adjacent(str):\n    if len(str) == 0:\n        return True\n\n    if len(str) == 1:\n        return False\n\n    # we sort the string so that we can check if the next character is different\n    str = sorted(str)\n\n    # we keep track of the index\n    idx = 0\n\n    # we keep track of the previous character\n    prev = str[0]\n\n    # we check if the next character is different\n    while idx < len(str) - 1:\n        if prev != str[idx + 1]:\n            idx += 1\n            prev = str[idx]\n        else:\n            return False\n\n    return True",
    "from collections import Counter\n\n\ndef check_adjacent_diff(string):\n    \"\"\"Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Args:\n       string(string): Input string to be checked\n    Returns:\n       bool: Either the string can be rearranged so that two characters that are adjacent to each other are different or not\n\n    Raises:\n       AssertionError: If the input string is not a string or None\n\n    \"\"\"\n    assert isinstance(string, str), \"Please provide a string input\"\n\n    # If input is None or empty\n    if not string:\n        return False\n\n    # Convert string to lowercase\n    string = string.lower()\n\n    # Create a counter object\n    counter = Counter(string)\n\n    # Get the most common character\n    most_common_char = counter.most_common(1)[0][0]\n\n    # If the most common character occurs only once, return True\n    if counter[most_common_char] == 1:\n        return True\n\n    # Otherwise, get the second most common character\n    second_most_common_char = counter.most_common(2)[1][0]\n\n    # If the most common character occurs more than twice, return True\n    if counter[most_common_char] > 2:\n        return True\n\n    # Otherwise, return False\n    return False\n\n\ndef test_function(test_case):\n    string = test_case[0]\n    solution = test_case[1]\n    output = check_adjacent_diff(string)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\nstring = 'aab'\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = 'aabb'\nsolution = True\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = 'abc'\nsolution = False\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = ''\nsolution = False",
    "def check_adjacent_chars_different(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_str:\n        return True\n\n    letter_freq = {}\n    for letter in input_str:\n        letter_freq[letter] = letter_freq.get(letter, 0) + 1\n\n    sorted_letter_freq = sorted(letter_freq.items(), key=lambda x: x[0])\n\n    for i in range(len(sorted_letter_freq) - 1):\n        if sorted_letter_freq[i][0] == sorted_letter_freq[i + 1][0]:\n            sorted_letter_freq[i][1] -= 1\n            sorted_letter_freq[i + 1][1] -= 1\n\n    for letter, freq in sorted_letter_freq:\n        if freq >= 2:\n            return False\n\n    return True\n\n\ndef check_adjacent_chars_different_optimized(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_str:\n        return True\n\n    letter_freq = {}\n    for letter in input_str:\n        letter_freq[letter] = letter_freq.get(letter, 0) + 1\n\n    sorted_letter_freq = sorted(letter_freq.items(), key=lambda x: x[0])\n\n    for i in range(len(sorted_letter_freq) - 1):\n        if sorted_letter_freq[i][0] == sorted_letter_freq[i + 1][0]:\n            sorted_letter_freq[i][1] -= 1\n            sorted_letter_freq[i + 1][1] -= 1\n\n    for letter, freq in sorted_letter_freq:\n        if freq >= 2:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(",
    "from collections import Counter\n\ndef check_if_adjacent_characters_are_different(input_string):\n    \"\"\"\n    Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n    \"\"\"\n    input_string_list = list(input_string)\n    input_string_list.sort()\n    print(input_string_list)\n    counter = Counter(input_string_list)\n    print(counter)\n\n    for key, value in counter.items():\n        if value == 1:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_if_adjacent_characters_are_different(\"aab\"))",
    "from collections import Counter\n\n\ndef can_be_rearranged(string):\n    # TODO: Write your solution here\n    return True\n\n\n# Test Cases:\nprint(can_be_rearranged(\"abcdef\"))\nprint(can_be_rearranged(\"aab\"))\nprint(can_be_rearranged(\"aabb\"))\nprint(can_be_rearranged(\"abcdefg\"))\nprint(can_be_rearranged(\"abcdefghi\"))\nprint(can_be_rearranged(\"abcdefghij\"))",
    "def check_adjacent_chars(string):\n    if len(string) <= 1:\n        return True\n\n    sorted_string = sorted(string)\n\n    for i in range(len(string) - 1):\n        if sorted_string[i] == sorted_string[i + 1]:\n            return False\n\n    return True",
    "def can_be_rearranged(s):\n    s = list(s)\n    used = set()\n    result = True\n    for i in range(len(s)):\n        if s[i] not in used:\n            used.add(s[i])\n        else:\n            for j in range(i+1, len(s)):\n                if s[j] not in used:\n                    used.add(s[j])\n                    s[i], s[j] = s[j], s[i]\n                    result = False\n                    break\n                else:\n                    s[i], s[j] = s[j], s[i]\n            if result == False:\n                break\n    return result\n\n\nprint(can_be_rearranged(\"aab\"))\nprint(can_be_rearranged(\"abc\"))\nprint(can_be_rearranged(\"aaab\"))",
    "def re_arr(input_string):\n    # Write your code here.\n\tadj_list = []\n\tchar_map = {}\n\t\n\tfor char in input_string:\n\t\tif char not in char_map:\n\t\t\tchar_map[char] = 1\n\t\telse:\n\t\t\tchar_map[char] += 1\n\t\n\tfor char in input_string:\n\t\tif char_map[char] > 1:\n\t\t\tadj_list.append(char)\n\t\n\tfor i in range(len(adj_list)):\n\t\tfor j in range(i+1, len(adj_list)):\n\t\t\tif adj_list[i] == adj_list[j]:\n\t\t\t\treturn False\n\t\n\treturn True",
    "def rearrange_string(input_string):\n    \"\"\"\n    Time Complexity: O(n*n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_string:\n        return True\n\n    char_frequency = {}\n    for char in input_string:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    sorted_char_frequency = {}\n    for char in input_string:\n        if char in sorted_char_frequency:\n            sorted_char_frequency[char] += 1\n        else:\n            sorted_char_frequency[char] = 1\n\n    for char in sorted_char_frequency:\n        if char_frequency[char] > 1:\n            return False\n\n    sorted_char_frequency = sorted(sorted_char_frequency.items(), key=lambda x: x[1])\n\n    def is_valid(sorted_char_frequency, visited_index):\n        if visited_index == len(sorted_char_frequency):\n            return True\n\n        for i in range(visited_index, len(sorted_char_frequency)):\n            char = sorted_char_frequency[i][0]\n            if char in visited_char:\n                continue\n\n            visited_char.add(char)\n            if i == visited_index:\n                if is_valid(sorted_char_frequency, i + 1):\n                    return True\n            else:\n                if is_valid(sorted_char_frequency, i + 1):\n                    return True\n\n        return False\n\n    visited_char = set()\n    return is_valid(sorted_char_frequency, 0)\n\n\ndef rearrange_string_2(input_string):\n    \"\"\"\n    Time Complexity: O(n*n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not input_string:\n        return True\n\n    char_frequency = {}\n    for char in input_string:\n        if char in char_frequency:\n            char_fre",
    "from collections import defaultdict\n\n\ndef can_be_rearranged(s):\n    if len(s) == 1:\n        return True\n\n    # O(1)\n    if len(s) == 2:\n        return s[0] != s[1]\n\n    # O(n)\n    chars = defaultdict(int)\n    for char in s:\n        chars[char] += 1\n\n    # O(n)\n    for i, char in enumerate(s):\n        if chars[char] > 1:\n            break\n    else:\n        return True\n\n    # O(n)\n    for j in range(i + 1, len(s)):\n        if s[j] != s[i] and chars[s[j]] > 0:\n            return True\n\n    return False\n\n\ntestable_functions = [can_be_rearranged]\n\n\ndef test_can_be_rearranged():\n    assert can_be_rearranged(\"abc\")\n    assert can_be_rearranged(\"aabb\") is False\n    assert can_be_rearranged(\"aabbcc\") is False\n    assert can_be_rearranged(\"abcdef\") is True\n    assert can_be_rearranged(\"abcdefa\") is True\n    assert can_be_rearranged(\"abcdefg\") is False\n    assert can_be_rearranged(\"abcdefgh\") is False\n    assert can_be_rearranged(\"abcdefghi\") is False\n    assert can_be_rearranged(\"abcdefghij\") is True\n\n\nif __name__ == '__main__':\n    test_can_be_rearranged()",
    "from collections import Counter\n\ndef rearrange_string(s):\n\t\"\"\"\n\t:type s: str\n\t:rtype: bool\n\t\"\"\"\n\ts = s + \" \"\n\tcount = Counter(s)\n\tprint(count)\n\n\ti = 0\n\twhile i < len(s) - 1:\n\t\tif s[i] == s[i+1]:\n\t\t\treturn False\n\t\telse:\n\t\t\ti += 1\n\treturn True\n\n\ndef main():\n\tprint(rearrange_string(\"aab\"))\n\nif __name__ == '__main__':\n\tmain()",
    "def check_rearrange_string(input_string):\n    # sort the string\n    sorted_string = sorted(input_string)\n    # create an empty list to append to\n    check_list = []\n\n    # iterate through the sorted string\n    for i in range(len(sorted_string)):\n        # if the i is not equal to the i + 1 and i + 1 is not in the check_list\n        if sorted_string[i] != sorted_string[i + 1] and sorted_string[i + 1] not in check_list:\n            # append i to the check_list\n            check_list.append(i)\n        # if the i is equal to the i + 1\n        elif sorted_string[i] == sorted_string[i + 1]:\n            # return false\n            return False\n\n    # return true\n    return True\n\n\nprint(check_rearrange_string(\"aab\"))\nprint(check_rearrange_string(\"abc\"))",
    "def check_adjacent_characters(s):\n    if len(s) == 0:\n        return True\n\n    # get all letters\n    letters = list(set(s))\n\n    # count how many times each letter appears\n    counts = [s.count(l) for l in letters]\n\n    # sort letters and counts in ascending order\n    # by counts (number of times letter appears)\n    zipped = zip(letters, counts)\n    sorted_zipped = sorted(zipped, key=lambda x: x[1])\n    sorted_letters = [x[0] for x in sorted_zipped]\n    sorted_counts = [x[1] for x in sorted_zipped]\n\n    # for each letter, check if the number of times it appears\n    # is even. If so, we have no problem. If not, we have a problem\n    # if we have an odd number of a letter and all of the letters\n    # next to it are the same letter.\n    problem = False\n    for i in range(len(sorted_letters)):\n        if sorted_counts[i] % 2 == 1:\n            # if the last letter is odd, we have a problem\n            if i == len(sorted_letters) - 1:\n                problem = True\n            # if the next letter is the same, we have a problem\n            elif sorted_letters[i] == sorted_letters[i+1]:\n                problem = True\n    return not problem\n\n\ndef main():\n    print(check_adjacent_characters(\"abcde\")) # True\n    print(check_adjacent_characters(\"aabb\")) # False\n    print(check_adjacent_characters(\"aabbcde\")) # False\n    print(check_adjacent_characters(\"aaabbb\")) # True\n    print(check_adjacent_characters(\"aaabbbccc\")) # False\n    print(check_adjacent_characters(\"aaabbbcccd\")) # True\n    print(check_adjacent_characters(\"aaabbbcccc\")) # True\n    print(check_adjacent_characters(\"aaabbbccccddd\")) # False\n    print(check",
    "def rearrange(input_string):\n    # check if input_string is empty\n    if len(input_string) == 0:\n        return False\n\n    # sort the input_string\n    input_string = sorted(input_string)\n\n    # iterate over the string\n    for i in range(len(input_string)-1):\n        # check if the character at the current index is the same as the next\n        if input_string[i] == input_string[i+1]:\n            # return False if they are the same\n            return False\n\n    # if the function has not returned False\n    return True\n\nif __name__ == '__main__':\n    # accept input from the user\n    input_string = input(\"Enter a string: \")\n\n    # check if the letters of the string can be rearranged\n    if rearrange(input_string):\n        print(\"The letters of the string can be rearranged\")\n    else:\n        print(\"The letters of the string can not be rearranged\")",
    "def can_rearrange(s):\n    # sort string\n    sorted_s = sorted(s)\n    # create a list of indices to track current position\n    # e.g. for string 'aabbc', indices are [0, 1, 2, 3, 4]\n    indices = list(range(len(sorted_s)))\n\n    # iterate through string\n    for i in range(len(sorted_s)):\n        # get current character\n        c = sorted_s[i]\n        # get index of current character\n        c_index = indices[i]\n        # iterate through indices\n        for j in range(i + 1, len(sorted_s)):\n            # get adjacent character\n            c_adjacent = sorted_s[j]\n            # get index of adjacent character\n            c_adjacent_index = indices[j]\n            # check if adjacent character is different from current character\n            if c != c_adjacent:\n                # check if adjacent character is next to current character\n                if abs(c_index - c_adjacent_index) == 1:\n                    # if so, return True\n                    return True\n    # if no such adjacent character was found, return False\n    return False\n\n\nprint(can_rearrange(\"aabbc\"))\nprint(can_rearrange(\"aabbbc\"))\nprint(can_rearrange(\"abcdef\"))",
    "from collections import Counter\n\n\ndef check_rearrange(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    # create a counter\n    counter = Counter(input_str)\n    # create a set of keys\n    keys = set(counter.keys())\n    # create a sorted list of keys\n    sorted_keys = sorted(keys)\n    # create a list of adjacent keys\n    adjacent_keys = []\n\n    # iterate through sorted keys\n    for i in range(0, len(sorted_keys)):\n        # check if the keys are adjacent\n        if i + 1 < len(sorted_keys) and sorted_keys[i] + 1 == sorted_keys[i + 1]:\n            # add to adjacent keys\n            adjacent_keys.append((sorted_keys[i], sorted_keys[i + 1]))\n        # check if the keys are adjacent\n        elif i - 1 >= 0 and sorted_keys[i] - 1 == sorted_keys[i - 1]:\n            # add to adjacent keys\n            adjacent_keys.append((sorted_keys[i], sorted_keys[i - 1]))\n\n    # check if there are adjacent keys\n    if adjacent_keys:\n        # iterate through adjacent keys\n        for i in range(0, len(adjacent_keys)):\n            # get the key at index i\n            key = adjacent_keys[i]\n            # check if the key at index i exists in counter\n            if key[0] in counter and key[1] in counter:\n                # decrease the count of key at index i\n                counter[key[0]] -= 1\n                # decrease the count of key at index i + 1\n                counter[key[1]] -= 1\n                # check if the count is 0\n                if counter[key[0]] == 0:\n                    # remove the key at index i\n                    del counter[key[0]]\n                # check if the count is 0\n                if counter[key[1]] == 0:\n                    # remove the key at index i + 1\n                    del counter[key[1]]\n\n    # return if the",
    "from collections import Counter\n\n\n# Time Complexity: O(nlogn)\n# Space Complexity: O(n)\ndef rearrange_letters(input_string):\n    if len(input_string) < 2:\n        return True\n\n    char_count = Counter(input_string)\n\n    heap = []\n    for char in char_count:\n        heapq.heappush(heap, (-char_count[char], char))\n\n    result = []\n    while len(result) < len(input_string) - 1:\n        count, char = heapq.heappop(heap)\n        result.append(char)\n        char_count[char] -= 1\n        if char_count[char] > 0:\n            heapq.heappush(heap, (-char_count[char], char))\n\n    return result == sorted(result)",
    "from collections import defaultdict\n\n\ndef rearrange_chars(input_str):\n    if not input_str or len(input_str) <= 1:\n        return False\n\n    char_count = defaultdict(int)\n    for char in input_str:\n        char_count[char] += 1\n\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    sorted_chars = [x[0] for x in sorted_chars]\n\n    if len(sorted_chars) % 2 != 0:\n        return False\n\n    for i in range(0, len(sorted_chars) - 1, 2):\n        if sorted_chars[i] == sorted_chars[i + 1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert rearrange_chars(\"aabb\") == True\n    assert rearrange_chars(\"aabbbc\") == False\n    assert rearrange_chars(\"abcdef\") == True",
    "def rearrange(input_string):\n    chars = list(input_string)\n    chars.sort()\n\n    for i in range(len(chars) - 1):\n        if chars[i] == chars[i + 1]:\n            return False\n\n    return True\n\n\nprint(rearrange(\"aab\"))\nprint(rearrange(\"leetcode\"))\nprint(rearrange(\"abcdef\"))\nprint(rearrange(\"accc\"))",
    "from collections import Counter\n\ndef check_adjacent_chars(input_string):\n    counter = Counter(input_string)\n    sorted_counter = sorted(counter.items(), key=lambda x:x[1])\n    result = True\n    for i in range(len(sorted_counter)-1):\n        if sorted_counter[i][1] == sorted_counter[i+1][1]:\n            result = False\n            break\n    return result\n\nprint(check_adjacent_chars(\"aab\"))\nprint(check_adjacent_chars(\"aabb\"))\nprint(check_adjacent_chars(\"abcdefghijklmno\"))\nprint(check_adjacent_chars(\"abcdefghijklmno1234567890\"))",
    "def check_adjacent_characters(input_string):\n    if input_string == None:\n        return None\n    characters = {}\n    for character in input_string:\n        if character not in characters:\n            characters[character] = 1\n        else:\n            characters[character] += 1\n    sorted_characters = sorted(characters.items(), key=lambda x: x[1], reverse=True)\n    for i in range(len(sorted_characters) - 1):\n        if sorted_characters[i][1] > 1:\n            for j in range(i + 1, len(sorted_characters)):\n                if sorted_characters[j][1] > 0:\n                    return True\n    return False\n\nprint(check_adjacent_characters(\"aab\"))\nprint(check_adjacent_characters(\"abc\"))\nprint(check_adjacent_characters(\"abb\"))\nprint(check_adjacent_characters(\"abba\"))\nprint(check_adjacent_characters(\"ababc\"))\nprint(check_adjacent_characters(\"ababcbc\"))\nprint(check_adjacent_characters(\"ababcbbc\"))\nprint(check_adjacent_characters(\"ababccbc\"))\nprint(check_adjacent_characters(\"abacccbc\"))\nprint(check_adjacent_characters(\"abaccccca\"))\nprint(check_adjacent_characters(\"abaccccccc\"))\nprint(check_adjacent_characters(\"abaccccccccc\"))\nprint(check_adjacent_characters(\"abacccccccccc\"))\nprint(check_adjacent_characters(\"abaccccccccccc\"))\nprint(check_adjacent_characters(\"abacccccccccccc\"))\nprint(check_adjacent_characters(\"abaccccccccccccc\"))\nprint(check_adjacent_characters(\"abacccccccccccccc\"))\nprint(check_adjacent_characters(\"abaccccccccccccccc\"))\nprint(check_adjacent_characters(\"abacccccccccccccccc\"))\nprint(check_adjacent_characters(\"abaccc",
    "# O(n * n!) time | O(n * n!) space\ndef generate_permutations(string):\n    permutations = []\n    generate_permutations_helper(string, \"\", permutations)\n    return permutations\n\n\ndef generate_permutations_helper(string, current, permutations):\n    if not string:\n        permutations.append(current)\n\n    for index, char in enumerate(string):\n        generate_permutations_helper(string[:index] + string[index + 1:], current + char, permutations)\n\n\ndef generate_permutations_helper_2(string):\n    if len(string) <= 1:\n        return [string]\n\n    permutations = []\n    for index, char in enumerate(string):\n        permutations_for_next_char = generate_permutations_helper_2(string[:index] + string[index + 1:])\n        for permutation in permutations_for_next_char:\n            permutations.append(char + permutation)\n\n    return permutations\n\n\ndef can_be_rearranged(string):\n    permutations = generate_permutations(string)\n    for permutation in permutations:\n        if check_if_valid(permutation):\n            return True\n\n    return False\n\n\ndef check_if_valid(string):\n    if len(string) <= 1:\n        return True\n\n    for index in range(len(string) - 1):\n        if string[index] == string[index + 1]:\n            return False\n\n    return True\n\n\nprint(can_be_rearranged(\"aab\"))\nprint(can_be_rearranged(\"abc\"))\nprint(can_be_rearranged(\"abb\"))\nprint(can_be_rearranged(\"bbb\"))",
    "def check_adjacent_chars(input_str: str) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(input_str) < 2:\n        return True\n\n    dict_count: dict = {}\n\n    for char in input_str:\n        if char not in dict_count:\n            dict_count[char] = 1\n        else:\n            dict_count[char] += 1\n\n    sorted_dict_count = sorted(dict_count.items(), key=lambda x: x[1])\n\n    start_index = 0\n    end_index = len(sorted_dict_count) - 1\n\n    while start_index < end_index:\n        if sorted_dict_count[start_index][1] > 1:\n            start_index += 1\n        elif sorted_dict_count[end_index][1] > 1:\n            end_index -= 1\n        else:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent_chars(\"aab\") == True\n    assert check_adjacent_chars(\"aabb\") == False\n    assert check_adjacent_chars(\"abcdefghijklmopqrstuvwxyz\") == True\n    assert check_adjacent_chars(\"abcdefghijklmnopqrstuvwxy\") == False",
    "from collections import Counter\n\n\ndef check_adjacent_different(string: str) -> bool:\n    \"\"\"Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(string) <= 1:\n        return True\n\n    counter = Counter(string)\n\n    if len(string) % 2 == 0:\n        check_char = lambda x: counter[x] % 2 == 0\n    else:\n        check_char = lambda x: counter[x] % 2 == 1\n\n    for i, char in enumerate(string):\n        if i == 0:\n            if check_char(char):\n                return False\n        else:\n            if string[i - 1] == char:\n                return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_different(\"abcde\"))\n    print(check_adjacent_different(\"aabb\"))\n    print(check_adjacent_different(\"abcdef\"))",
    "# Time Complexity: O(nlogn)\n# Space Complexity: O(n)\ndef rearrange_letters(string):\n    if len(string) == 1:\n        return True\n    if len(string) == 2:\n        return string[0] != string[1]\n    if len(string) == 3:\n        return string[0] != string[1] and string[1] != string[2]\n    if len(string) == 4:\n        return string[0] != string[1] and string[2] != string[3]\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    sorted_char_count = sorted(char_count.items(), key=lambda x: x[1])\n    sorted_chars = [x[0] for x in sorted_char_count]\n    sorted_counts = [x[1] for x in sorted_char_count]\n\n    if sorted_chars[0] == sorted_chars[-1]:\n        return False\n\n    for i in range(1, len(sorted_chars)):\n        if sorted_chars[i-1] == sorted_chars[i]:\n            return False\n\n    for i in range(1, len(sorted_chars)):\n        if sorted_chars[i] == sorted_chars[-1]:\n            return False\n\n    for i in range(len(sorted_chars)-1):\n        if sorted_chars[i] == sorted_chars[i+1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(rearrange_letters(\"aabb\"))\n    print(rearrange_letters(\"aaab\"))\n    print(rearrange_letters(\"abc\"))\n    print(rearrange_letters(\"abb\"))\n    print(rearrange_letters(\"bba\"))",
    "def check_adjacent_characters(s):\n    chars = {}\n    for c in s:\n        chars[c] = chars.get(c, 0) + 1\n    print(chars)\n    for c in chars:\n        if chars[c] == 1:\n            return False\n    return True\n\nprint(check_adjacent_characters(\"aab\"))\nprint(check_adjacent_characters(\"aabb\"))\nprint(check_adjacent_characters(\"abcdefghijklmopqrstuvwxyz\"))",
    "def check_adjacent_different(string):\n    if len(string) == 0:\n        return False\n\n    alphabets = {}\n    for char in string:\n        if char not in alphabets:\n            alphabets[char] = 1\n        else:\n            alphabets[char] += 1\n\n    for char in alphabets:\n        if alphabets[char] > 1:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_different(\"aab\"))\n    print(check_adjacent_different(\"aabb\"))\n    print(check_adjacent_different(\"abcdef\"))\n    print(check_adjacent_different(\"abcdefg\"))\n    print(check_adjacent_different(\"abcdefgh\"))",
    "from collections import Counter\n\ndef check_adjacent_different(input_str):\n    \"\"\"\n    Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different\n    \"\"\"\n    if not input_str:\n        return True\n\n    # get frequency of each character\n    freq = Counter(input_str)\n\n    # get a list of characters\n    char_list = list(freq.keys())\n\n    # sort the list by the frequency\n    sorted_char_list = sorted(char_list, key=lambda x: freq[x], reverse=True)\n\n    # initialize an empty set of pairs\n    pairs = set()\n\n    # loop through the sorted list\n    for char in sorted_char_list:\n        # if the char is not in the set\n        if char not in pairs:\n            # add it to the set\n            pairs.add(char)\n        else:\n            # if the char is in the set, check if there is a pair\n            # if there is no pair, return False\n            if len(pairs) == 1:\n                return False\n\n            # get the pair\n            pair = pairs.pop()\n\n            # add the pair to the set\n            pairs.add(pair)\n\n            # add the char to the set\n            pairs.add(char)\n\n    return True",
    "from collections import Counter\n\ndef check_adjacent_diff(string):\n    c = Counter(string)\n    if len(c) == len(string):\n        return False\n    freq_list = []\n    for key, value in c.items():\n        freq_list.append((key, value))\n    freq_list.sort(key=lambda x: x[0])\n    for i in range(1, len(freq_list)):\n        if freq_list[i][0] == freq_list[i-1][0]:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_diff(\"aba\"))\n    print(check_adjacent_diff(\"abba\"))\n    print(check_adjacent_diff(\"abcb\"))",
    "def check_adjacent_different(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    input_str = list(input_str)\n    input_str.sort()\n    hash_map = dict()\n\n    for i in range(len(input_str)):\n        if i == 0:\n            hash_map[input_str[i]] = 1\n        else:\n            if input_str[i] == input_str[i - 1]:\n                hash_map[input_str[i]] += 1\n            else:\n                hash_map[input_str[i]] = 1\n\n    for i in range(len(input_str)):\n        if i == 0:\n            if hash_map[input_str[i]] > 1:\n                return False\n        else:\n            if input_str[i] == input_str[i - 1]:\n                if hash_map[input_str[i]] > 2:\n                    return False\n            else:\n                if hash_map[input_str[i]] > 1:\n                    return False\n\n    return True\n\n\nif __name__ == '__main__':\n    print(check_adjacent_different('aab'))\n    print(check_adjacent_different('leetcode'))\n    print(check_adjacent_different('abcdef'))\n    print(check_adjacent_different('aaa'))",
    "from collections import Counter\n\ndef rearrange_letters(input_string):\n\n    input_string = input_string.lower()\n    input_string = ''.join(c for c in input_string if c.isalpha())\n\n    if len(input_string) <= 1:\n        return True\n\n    counter = Counter(input_string)\n    check_list = []\n\n    for i in input_string:\n        if counter[i] == 1:\n            check_list.append(i)\n\n    if len(check_list) > 0:\n        return False\n\n    for i in range(len(input_string)):\n        for j in range(i+1, len(input_string)):\n            if input_string[i] == input_string[j]:\n                return False\n\n    return True\n\n\nif __name__ == '__main__':\n    input_string = input()\n    if rearrange_letters(input_string):\n        print('true')\n    else:\n        print('false')",
    "def check_adjacent(s):\n    if len(s) <= 1:\n        return True\n\n    # store the position of the character in the string\n    # and its frequency\n    counter = {}\n    for i, char in enumerate(s):\n        counter[char] = counter.get(char, []) + [i]\n\n    # sort the positions by value\n    for char, positions in counter.items():\n        counter[char] = sorted(positions)\n\n    # check if the characters are adjacent to each other\n    # and they are not the same character\n    for i in range(len(s) - 1):\n        if counter[s[i]][i] == counter[s[i + 1]][i + 1] and s[i] == s[i + 1]:\n            return False\n\n    return True\n\nprint(check_adjacent(\"aab\"))\nprint(check_adjacent(\"aabb\"))",
    "def check_adjacent_characters(string: str) -> bool:\n    \"\"\"Check if the letters of a given string can be rearranged.\n\n    Args:\n        string (str): given string.\n\n    Returns:\n        bool: True if the letters of a given string can be rearranged, False otherwise.\n    \"\"\"\n    if len(string) < 2:\n        return True\n\n    string = list(string)\n\n    string.sort()\n\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(check_adjacent_characters(\"a\"))\n    print(check_adjacent_characters(\"abc\"))\n    print(check_adjacent_characters(\"aaa\"))\n    print(check_adjacent_characters(\"abcd\"))\n    print(check_adjacent_characters(\"aaabb\"))\n    print(check_adjacent_characters(\"aaab\"))",
    "def check_adjacent_different(string):\n    if len(string) <= 1:\n        return True\n\n    char_map = {}\n    for c in string:\n        if c in char_map:\n            char_map[c] += 1\n        else:\n            char_map[c] = 1\n\n    for c in string:\n        if char_map[c] > 1:\n            char_map[c] -= 1\n        else:\n            del char_map[c]\n\n    return len(char_map) == 0\n\n\nprint(check_adjacent_different('a'))\nprint(check_adjacent_different('aabc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adjacent_different('abbc'))\nprint(check_adjacent_different('abcc'))\nprint(check_adjacent_different('abc'))\nprint(check_adj",
    "def rearrange_string(input_str):\n    if not input_str: return \"\"\n    if len(input_str) <= 1: return input_str\n\n    freq_map = {}\n    for char in input_str:\n        freq_map[char] = freq_map.get(char, 0) + 1\n\n    heap = []\n    for key, val in freq_map.items():\n        heapq.heappush(heap, (-val, key))\n\n    result = \"\"\n    while heap:\n        count, char = heapq.heappop(heap)\n        result += char\n        if count != -1:\n            heapq.heappush(heap, (count+1, char))\n\n    return result\n\ndef rearrange_string_v2(input_str):\n    if not input_str: return \"\"\n    if len(input_str) <= 1: return input_str\n\n    freq_map = {}\n    for char in input_str:\n        freq_map[char] = freq_map.get(char, 0) + 1\n\n    heap = []\n    for key, val in freq_map.items():\n        heapq.heappush(heap, (-val, key))\n\n    result = \"\"\n    while heap:\n        count, char = heapq.heappop(heap)\n        result += char\n        if count != -1:\n            heapq.heappush(heap, (count+1, char))\n\n    return result\n\nprint(rearrange_string(\"aab\"))\nprint(rearrange_string_v2(\"aab\"))",
    "def rearrange_string(s):\n    # We need to check if the length of the string is even or odd\n    # If the length of the string is even then we can have two adjacent characters that are different\n    # If the length of the string is odd then we need to check if the string has two adjacent characters that are different\n    # If we have two adjacent characters that are different then we can rearrange the string\n    # If the string has only one adjacent character that is different then we cannot rearrange the string\n    # The time complexity of this solution is O(n)\n    # The space complexity of this solution is O(1)\n    # The solution is inspired by @nivvank in the discussion forum\n    if not s:\n        return True\n\n    if len(s) == 1:\n        return False\n\n    if len(s) == 2:\n        return s[0] != s[1]\n\n    count_map = dict()\n\n    for char in s:\n        count_map[char] = count_map.get(char, 0) + 1\n\n    odd_count = 0\n\n    for value in count_map.values():\n        if value % 2 == 1:\n            odd_count += 1\n\n        if odd_count > 1:\n            return False\n\n    return True\n\n\nprint(rearrange_string(\"aabb\"))\nprint(rearrange_string(\"aabbc\"))\nprint(rearrange_string(\"abcdef\"))\nprint(rearrange_string(\"abcdefg\"))\nprint(rearrange_string(\"abcdefgh\"))\nprint(rearrange_string(\"abcdefghhgfedcba\"))\nprint(rearrange_string(\"aa\"))",
    "def check_adjacent(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(input_str) < 2:\n        return True\n\n    # Build a hash set of characters\n    char_set = set()\n    for char in input_str:\n        char_set.add(char)\n\n    # Initialize a bucket for each character\n    bucket = [0] * len(char_set)\n    for char in input_str:\n        bucket[ord(char) - ord('a')] += 1\n\n    # Loop through the string again\n    # if two characters are adjacent, they must be in different buckets\n    # if two characters are not adjacent, they must be in different buckets\n    for i in range(len(input_str) - 1):\n        first_char = input_str[i]\n        second_char = input_str[i + 1]\n\n        if abs(ord(first_char) - ord(second_char)) == 1:\n            bucket[ord(first_char) - ord('a')] -= 1\n            bucket[ord(second_char) - ord('a')] -= 1\n\n    # Check if any bucket has more than 1\n    for count in bucket:\n        if count > 1:\n            return False\n\n    return True\n\ninput_str = \"aabba\"\nprint(\"Is rearrangement possible in \" + input_str + \"? - \", check_adjacent(input_str))\n\ninput_str = \"aabb\"\nprint(\"Is rearrangement possible in \" + input_str + \"? - \", check_adjacent(input_str))",
    "def can_rearrange_adjacent(input_str):\n    if not input_str:\n        return True\n\n    # We're going to use a hash table to store the frequency of each character.\n    char_freq = {}\n\n    # Store the frequency of each character.\n    for char in input_str:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # We're going to use a heap to store the frequency of each character.\n    freq_heap = []\n\n    # Store the frequency of each character in a heap.\n    for char in char_freq:\n        freq_heap.append([char_freq[char], char])\n\n    # We're going to use a priority queue to store the characters that have a frequency of 1.\n    char_queue = []\n\n    # Store the characters that have a frequency of 1 in a priority queue.\n    for freq in freq_heap:\n        if freq[0] == 1:\n            char_queue.append(freq[1])\n            freq_heap.remove(freq)\n\n    # If there are no characters that have a frequency of 1, we return false.\n    if not char_queue:\n        return False\n\n    # We're going to use a priority queue to store the characters that have a frequency of 2 or more.\n    char_queue = sorted(char_queue)\n    char_queue = [char_queue[i] for i in range(len(char_queue)) if i % 2 == 0]\n\n    # We're going to use a set to store the characters that have been used.\n    used_char = set()\n\n    # Check if we can rearrange the characters.\n    for char in char_queue:\n        if char in used_char:\n            return False\n        else:\n            used_char.add(char)\n\n    return True\n\n\nprint(can_rearrange_adjacent(\"abcde\"))\nprint(can_rearrange_adjacent(\"aabb\"))",
    "def check_adjacent_chars(string):\n    \"\"\"\n    We will create a dictionary to keep track of the letters in the string. We will then check if any of the values in the dictionary are 1.\n    If there is a value of 1, then the letters in the string can be rearranged to have adjacent characters that are different.\n    \"\"\"\n    char_dict = {}\n    for char in string:\n        if char in char_dict:\n            char_dict[char] += 1\n        else:\n            char_dict[char] = 1\n    for value in char_dict.values():\n        if value == 1:\n            return True\n    return False\n\nif __name__ == '__main__':\n    print(check_adjacent_chars(\"aab\"))\n    print(check_adjacent_chars(\"aabb\"))\n    print(check_adjacent_chars(\"abcdefghijklmopqrstuvwxyz\"))",
    "def rearrange_string(input_str):\n    \"\"\"\n    :param: input_str (string)\n    return: (bool) true if characters can be rearranged, false otherwise\n    \"\"\"\n    if len(input_str) <= 1:\n        return True\n\n    char_count = {}\n\n    for char in input_str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    sorted_char_count = sorted(char_count.items(), key=lambda item: item[1])\n    sorted_char_count.reverse()\n\n    # print(sorted_char_count)\n\n    # for each character, check if it can be placed in the correct position\n    for index in range(len(sorted_char_count)):\n        current_char = sorted_char_count[index][0]\n        current_char_count = sorted_char_count[index][1]\n\n        # check for each adjacent character if it can be placed in the correct position\n        for adjacent_index in range(index + 1, len(sorted_char_count)):\n            adjacent_char = sorted_char_count[adjacent_index][0]\n            adjacent_char_count = sorted_char_count[adjacent_index][1]\n\n            if current_char != adjacent_char:\n                if current_char_count == adjacent_char_count:\n                    return False\n                else:\n                    return rearrange_string(input_str[:index] + input_str[index + 1:adjacent_index + 1] + input_str[adjacent_index + 1:])\n\n    return True\n\n\nprint(rearrange_string('aab'))\nprint(rearrange_string('aaab'))\nprint(rearrange_string('vtkgnb'))\nprint(rearrange_string('vtkgnbb'))\nprint(rearrange_string('vtkgnbbb'))",
    "from collections import Counter\n\ndef check_adjacent_characters(string):\n    count = Counter(string)\n    if len(count) == 1:\n        return True\n\n    if len(count) == 2:\n        if len(string) == 2:\n            return True\n        else:\n            return False\n\n    if len(count) == 3:\n        return True\n\n    if len(count) == 4:\n        return False\n\n    # if len(count) == 5:\n    #     return False\n\n    # if len(count) == 6:\n    #     return False\n\n    # if len(count) == 7:\n    #     return False\n\n    # if len(count) == 8:\n    #     return False\n\n    # if len(count) == 9:\n    #     return False\n\n    return False\n\nprint(check_adjacent_characters(\"abcdefghi\"))\nprint(check_adjacent_characters(\"abcdefghia\"))\nprint(check_adjacent_characters(\"aabbccdd\"))\nprint(check_adjacent_characters(\"aabbccddee\"))\nprint(check_adjacent_characters(\"abcdefgh\"))\nprint(check_adjacent_characters(\"abcdefghiabcdefghi\"))\nprint(check_adjacent_characters(\"abcdefghiabcdefghij\"))\nprint(check_adjacent_characters(\"abcdefghiabcdefghiabcdefghi\"))",
    "from collections import Counter\n\n\ndef check_adjacent(input_str):\n    \"\"\"\n    We can solve this problem by using a sliding window.\n    We take a sliding window of 2 characters and check if the two characters in the sliding window are not the same.\n    If they are not the same, we move on to the next window.\n    If they are the same, we remove the first character and add the next character to the sliding window.\n    \"\"\"\n    characters = Counter(input_str)\n    window = set()\n    for character in input_str:\n        if character in window:\n            return True\n        window.add(character)\n        characters[character] -= 1\n        if characters[character] == 0:\n            window.remove(character)\n    return False",
    "from collections import Counter\n\n\ndef check_adjacent(string: str) -> bool:\n    if not string:\n        return False\n\n    chars = Counter(string)\n    visited = set()\n    for char, count in chars.items():\n        if count == 1:\n            continue\n        if count % 2 == 0:\n            continue\n        if char in visited:\n            return False\n        visited.add(char)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent(\"abcdef\") is True\n    assert check_adjacent(\"aabbcd\") is False\n    assert check_adjacent(\"abcdeff\") is True\n    assert check_adjacent(\"aabbccdd\") is False",
    "def rearrange_chars(s):\n    # Time: O(n log n)\n    # Space: O(n)\n    if not s:\n        return s\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    # sort count by value\n    char_count = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    # greedy\n    # Time: O(n)\n    # Space: O(n)\n    visited = [False] * len(char_count)\n    res = []\n    i = 0\n    while i < len(char_count):\n        if not visited[i]:\n            # if we have not visited this char, put it in the res and mark it as visited\n            res.append(char_count[i][0])\n            visited[i] = True\n            # check if we can find a neighbor char that is not visited\n            for j in range(len(char_count)):\n                if j != i and not visited[j] and char_count[i][0] != char_count[j][0]:\n                    res.append(char_count[j][0])\n                    visited[j] = True\n                    break\n        i += 1\n    return ''.join(res)\n\n\nprint(rearrange_chars(\"abbcc\"))\nprint(rearrange_chars(\"abbccc\"))\nprint(rearrange_chars(\"abcabc\"))\nprint(rearrange_chars(\"abcabca\"))",
    "def check_adjacent_differences(string: str) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    string = list(string)\n    sorted_string = sorted(string)\n\n    if sorted_string == string:\n        return False\n\n    for i in range(len(string) - 1):\n        if sorted_string[i] == string[i] and sorted_string[i + 1] == string[i + 1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent_differences(\"aab\") is True\n    assert check_adjacent_differences(\"aabb\") is False",
    "from collections import Counter\n\n\ndef check_adjacent_different(s):\n    \"\"\"\n    :param s: str - string to evaluate\n    :return: bool - whether the string is rearrangable\n    \"\"\"\n    #   Create a dictionary with the characters and their number of occurences\n    #   in the string\n    d = Counter(s)\n\n    #   Create a list of the characters in the string\n    char_list = list(s)\n\n    #   Create a list of the indexes of the characters in the string\n    indexes = list(range(0, len(s)))\n\n    #   Create a list of the indexes of the characters in the string\n    #   and remove the first character\n    indexes_2 = list(range(1, len(s)))\n\n    #   Create a list of the characters in the string\n    #   and remove the first character\n    char_list_2 = list(s)[1:]\n\n    #   Create a list of the indexes of the characters in the string\n    #   and remove the first character\n    indexes_3 = list(range(2, len(s)))\n\n    #   Create a list of the characters in the string\n    #   and remove the first character\n    char_list_3 = list(s)[2:]\n\n    #   Create a list of the indexes of the characters in the string\n    #   and remove the first character\n    indexes_4 = list(range(3, len(s)))\n\n    #   Create a list of the characters in the string\n    #   and remove the first character\n    char_list_4 = list(s)[3:]\n\n    #   Create a list of the indexes of the characters in the string\n    #   and remove the first character\n    indexes_5 = list(range(4, len(s)))\n\n    #   Create a list of the characters in the string\n    #   and remove the first character\n    char_list_5 = list(s)[4:]\n\n    #   Create a list of the indexes of the characters in the string\n    #   and remove the first character\n    indexes_6 = list(range(5, len(s)))\n\n    #   Create a list of the characters in the string",
    "def check_adjacent_different(input_string):\n    chars = {}\n    for char in input_string:\n        if char in chars:\n            chars[char] += 1\n        else:\n            chars[char] = 1\n\n    sorted_chars = sorted(chars.items(), key=lambda x: x[1], reverse=True)\n\n    used = [False] * len(sorted_chars)\n\n    for i in range(len(sorted_chars) - 1):\n        if sorted_chars[i][1] == 1:\n            used[i] = True\n        else:\n            for j in range(i + 1, len(sorted_chars)):\n                if sorted_chars[i][0] != sorted_chars[j][0] and sorted_chars[i][1] > 1 and sorted_chars[j][1] > 1:\n                    used[j] = True\n\n    if sum(used) == len(used):\n        return True\n    return False\n\nif __name__ == '__main__':\n    print(check_adjacent_different('aab'))\n    print(check_adjacent_different('aaabc'))\n    print(check_adjacent_different('aaabcd'))",
    "def check_adjacent_different(str):\n    # Create a dictionary of all the characters\n    char_dict = {}\n    for c in str:\n        if c in char_dict:\n            char_dict[c] += 1\n        else:\n            char_dict[c] = 1\n    # Get the count of each character\n    # Create a list of tuples of characters and counts\n    tuples = char_dict.items()\n    # Sort the list by the count\n    tuples.sort(key=lambda x: x[1])\n    # Create a list of all the characters\n    chars = []\n    for t in tuples:\n        for i in range(t[1]):\n            chars.append(t[0])\n    # Get the length of the string\n    str_len = len(str)\n    # Check if all the characters are in the list\n    if str_len <= len(chars):\n        # Create a dictionary to hold the indices of each character\n        char_indices = {}\n        for i in range(str_len):\n            char = str[i]\n            if char in char_indices:\n                char_indices[char].append(i)\n            else:\n                char_indices[char] = [i]\n        # Check if all the characters are in the list\n        for c in chars:\n            if c not in char_indices:\n                return False\n        # Get the total number of characters\n        total = len(chars)\n        # Create a list of indices\n        indices = []\n        for i in range(total):\n            indices.append(i)\n        # Create a list of booleans\n        bools = [False] * total\n        # Keep a count of the number of pairs\n        count = 0\n        # Loop through the list of indices\n        for i in range(total):\n            # Get the current index\n            index = indices[i]\n            # Get the current character\n            char = chars[index]\n            # Get the indices of the current character\n            char_indices = char_indices[char]\n            # Get the current index of the current character\n            char_index = char_indices[0]",
    "def check_adjacent_characters(string):\n    \"\"\"\n    We will sort the string and check if the adjacent characters are different.\n\n    Time complexity is O(nlogn).\n    Space complexity is O(1).\n    \"\"\"\n    string = sorted(string)\n\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent_characters(\"aab\") == True\n    assert check_adjacent_characters(\"abb\") == True\n    assert check_adjacent_characters(\"abc\") == True\n    assert check_adjacent_characters(\"abcd\") == False",
    "from collections import Counter\n\n\ndef check_adjacent_difference(string: str) -> bool:\n    string = string.lower()\n    counter = Counter(string)\n    if len(string) < 2:\n        return False\n    sorted_string = sorted(string)\n    index = 0\n    for key, value in counter.items():\n        if value > 1:\n            index = sorted_string.index(key)\n            break\n    if index == 0:\n        return False\n    for i in range(index + 1, len(sorted_string)):\n        if sorted_string[i] == sorted_string[i - 1]:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_adjacent_difference(\"aab\") is True\n    assert check_adjacent_difference(\"aabb\") is False\n    assert check_adjacent_difference(\"abc\") is True\n    assert check_adjacent_difference(\"abbc\") is True\n    assert check_adjacent_difference(\"abcc\") is False\n    assert check_adjacent_difference(\"aabbc\") is False\n    assert check_adjacent_difference(\"aabcc\") is True\n    assert check_adjacent_difference(\"aabbcc\") is True\n    assert check_adjacent_difference(\"aabbccc\") is False\n    assert check_adjacent_difference(\"abcdefghijklmnopqrstuvwxyz\") is True",
    "def check_adjacent_different(input_str):\n    # Create a list from input_str\n    input_list = list(input_str)\n\n    # Sort the list\n    input_list.sort()\n\n    # Create an empty list to hold the indices\n    indices = []\n\n    # Iterate over the input_list\n    for i in range(len(input_list)):\n        # Check if the current item is not the last item\n        if i != len(input_list) - 1:\n            # If the current item is the same as the next item\n            if input_list[i] == input_list[i + 1]:\n                # Add the index of the current item to the indices list\n                indices.append(i)\n\n    # If the indices list is not empty\n    if indices:\n        # Remove the last index from the indices list\n        indices.pop()\n\n        # Iterate over the indices\n        for i in range(len(indices)):\n            # Remove the current index from the indices list\n            indices.pop(0)\n            # Remove the current index from the input_list\n            input_list.pop(indices[0])\n\n    # If the input_list is empty\n    if not input_list:\n        # Return True\n        return True\n    else:\n        # Return False\n        return False\n\n\n# Tests\ndef check_adjacent_different_test():\n\n    input_str_1 = 'aab'\n    input_str_2 = 'leetcode'\n    input_str_3 = 'abbccddddeeeeedcba'\n    input_str_4 = 'catandog'\n\n    expected_1 = True\n    expected_2 = False\n    expected_3 = True\n    expected_4 = False\n\n    result_1 = check_adjacent_different(input_str_1)\n    result_2 = check_adjacent_different(input_str_2)\n    result_3 = check_adjacent_different(input_str_3)\n    result_4 = check_adjacent_different(input_str_4)\n\n    return (result_1 == expected_1",
    "def check_adjacent_different(string):\n    \"\"\"\n    O(nlogn) time | O(n) space\n    \"\"\"\n\n    # sort the string to have adjacent characters next to each other\n    string = \"\".join(sorted(string))\n\n    # initialize two pointers, one at the beginning and one at the end\n    left, right = 0, len(string) - 1\n\n    # iterate through the string, checking if the characters at the pointers are different\n    while left < right:\n        if string[left] == string[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True",
    "def rearrange_string(s):\n    # create a set of characters\n    char_set = set(s)\n    # sort the characters\n    sorted_char_set = sorted(char_set)\n    # create a new string with all the characters in sorted order\n    new_s = \"\".join(sorted_char_set)\n    # create a new string with the same characters but in a different order\n    new_s_reversed = new_s[::-1]\n    # create a new string with the same characters but in a different order\n    new_s_reversed_with_spaces = new_s_reversed.replace(\" \", \"\")\n    # check if the new string and the original string are anagrams\n    return new_s_reversed_with_spaces == s\n\n\ndef test_function(test_case):\n    s = test_case[0]\n    solution = test_case[1]\n    output = rearrange_string(s)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ns = \"aappp\"\nsolution = True\ntest_case = [s, solution]\ntest_function(test_case)\n\ns = \"Programming\"\nsolution = False\ntest_case = [s, solution]\ntest_function(test_case)\n\ns = \"abba\"\nsolution = True\ntest_case = [s, solution]\ntest_function(test_case)"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}