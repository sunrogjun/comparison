{
  "problem": {
    "task_id": "MBPP/366",
    "prompt": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.",
    "canonical_solution": "def adjacent_num_product(list_nums):\r\n    return max(a*b for a, b in zip(list_nums, list_nums[1:]))",
    "test_list": [
      "assert adjacent_num_product([1,2,3,4,5,6]) == 30",
      "assert adjacent_num_product([1,2,3,4,5]) == 20",
      "assert adjacent_num_product([2,3]) == 6"
    ],
    "challenge_test_list": [],
    "problem_id": 355
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from functools import reduce\n\n\ndef adjacent_element_product(list_integer):\n    \"\"\"\n    >>> adjacent_element_product([1,2,3,4])\n    12\n    >>> adjacent_element_product([1,2,3,4,5])\n    12\n    >>> adjacent_element_product([1,2,3,4,5,6])\n    24\n    \"\"\"\n    return max(\n        [\n            reduce(lambda x, y: x * y, pair)\n            for pair in zip(list_integer, list_integer[1:])\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def largest_product_of_adjacent_elements(lst):\n    if len(lst) <= 2:\n        return None\n    if len(lst) == 3:\n        return max(lst[0] * lst[1], lst[1] * lst[2])\n    else:\n        return max(largest_product_of_adjacent_elements(lst[0:2]), largest_product_of_adjacent_elements(lst[1:3]))",
    "from typing import List\n\n\ndef adjacent_element_product(input_list: List[int]) -> int:\n    \"\"\"Returns the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        input_list (List[int]): list of integers\n\n    Examples:\n        >>> assert adjacent_element_product([1, 2, 3, 4, 5]) == 20\n    \"\"\"\n    return max(\n        [\n            input_list[index] * input_list[index + 1]\n            for index in range(len(input_list) - 1)\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_product([1, 2, 3, 4, 5]))",
    "def max_adj(nums):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \n    Parameters:\n        nums: list\n    \"\"\"\n    max_prod = 0\n    for i in range(len(nums)-1):\n        max_prod = max(max_prod, nums[i] * nums[i+1])\n    return max_prod\n\n\nprint(max_adj([1,2,3,4,5]))",
    "def adjacent_element_product(input_list):\n    \"\"\"\n    Takes a list as an input and return the largest product of the pair of adjacent elements\n    >>> adjacent_element_product([1, 2, 3, 4, 5])\n    20\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6])\n    30\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6, 7])\n    42\n    \"\"\"\n    if len(input_list) <= 2:\n        return None\n\n    max_product = 0\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_product:\n            max_product = input_list[i] * input_list[i+1]\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from typing import List\n\n\ndef adjacent_element_product(integers: List[int]) -> int:\n    \"\"\"Returns the largest product of the pair of adjacent elements from a given list of integers.\n\n    Examples:\n        >>> assert adjacent_element_product([1, 2, 3, 4, 5]) == 20\n    \"\"\"\n    if len(integers) < 2:\n        raise ValueError(\"List must contain at least 2 elements.\")\n\n    return max(a * b for a, b in zip(integers, integers[1:]))\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_product([1, 2, 3, 4, 5]))",
    "def adjacent_element_product(list_of_ints):\n    if len(list_of_ints) <= 2:\n        return max(list_of_ints)\n    return max(list_of_ints[i] * list_of_ints[i+1] for i in range(len(list_of_ints)-1))\n\n\nprint(adjacent_element_product([1,2,3,4]))\nprint(adjacent_element_product([1,2,3,4,5]))\nprint(adjacent_element_product([1,2,3,4,5,6]))",
    "def adjacent_elements_product(list_of_int):\n    largest_product = 0\n    for i in range(len(list_of_int) - 1):\n        product = list_of_int[i] * list_of_int[i + 1]\n        if product > largest_product:\n            largest_product = product\n    return largest_product\n\n\ndef main():\n    list_of_int = [1, 2, 3, 4, 5]\n    print(adjacent_elements_product(list_of_int))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def adjacent_element_product(lst):\n    largest = 0\n    for i in range(len(lst) - 1):\n        if lst[i] * lst[i + 1] > largest:\n            largest = lst[i] * lst[i + 1]\n    return largest\n\n\nprint(adjacent_element_product([2, 4, 6, 2, 5]))",
    "def adjacent_element_product(a: list) -> int:\n    \"\"\"\n    >>> adjacent_element_product([1, 2, 3, 4])\n    12\n    >>> adjacent_element_product([1, 2, 3, 4, 5])\n    15\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6])\n    36\n    \"\"\"\n    if len(a) < 2:\n        raise ValueError(\"List must be of length 2 or more\")\n\n    return max(a[i] * a[i + 1] for i in range(len(a) - 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def adjacent_product(input_list):\n    if len(input_list) <= 2:\n        return 0\n    output = [0] * (len(input_list)-1)\n    for i in range(len(input_list)-1):\n        output[i] = input_list[i] * input_list[i+1]\n    return max(output)\n\n\nprint(adjacent_product([1, 2, 3, 4, 5]))\nprint(adjacent_product([1, 2, 3, 4]))\nprint(adjacent_product([1, 2, 3]))",
    "from typing import List\n\n\ndef max_product_adjacent(integers: List[int]) -> int:\n    \"\"\"Return the largest product of the pair of adjacent elements from a given list of integers.\n\n    Examples:\n        >>> assert max_product_adjacent([1, 2, 3, 4]) == 12\n        >>> assert max_product_adjacent([1, 2, 3, 4, 5]) == 12\n        >>> assert max_product_adjacent([1, 2, -3, 4, 5]) == 6\n        >>> assert max_product_adjacent([1, 2, -3, 4, 5, -6]) == 30\n    \"\"\"\n    if len(integers) < 2:\n        raise ValueError(\"list must have at least 2 elements\")\n    if any(not isinstance(integer, int) for integer in integers):\n        raise TypeError(\"list must contain only integers\")\n\n    max_product = float(\"-inf\")\n    for index, integer in enumerate(integers):\n        if index == len(integers) - 1:\n            break\n        max_product = max(max_product, integers[index] * integers[index + 1])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product_adjacent([1, 2, 3, 4]))\n    print(max_product_adjacent([1, 2, 3, 4, 5]))\n    print(max_product_adjacent([1, 2, -3, 4, 5]))\n    print(max_product_adjacent([1, 2, -3, 4, 5, -6]))",
    "def adjacent_element_product(a):\n    return max(a[i] * a[i + 1] for i in range(len(a) - 1))",
    "def adjacent_product(input_list):\n    # Checking if the input list is empty\n    if not input_list:\n        return 0\n\n    # Initializing a variable to store the max product\n    max_product = 0\n\n    # Traversing through the list\n    for index in range(len(input_list)):\n        # Checking if the index is the last element\n        if index == len(input_list) - 1:\n            continue\n\n        # Finding the product of the adjacent elements\n        product = input_list[index] * input_list[index + 1]\n\n        # Checking if the product is greater than the max product\n        if product > max_product:\n            max_product = product\n\n    # Returning the max product\n    return max_product\n\n\ndef main():\n    print(\"Maximum product of adjacent elements from the list is: \", adjacent_product([1, 2, 3, 4, 5]))\n    print(\"Maximum product of adjacent elements from the list is: \", adjacent_product([1, 2, 3, 4, 5, 6]))\n    print(\"Maximum product of adjacent elements from the list is: \", adjacent_product([1, 2, 3, 4, 5, 6, 7]))\n    print(\"Maximum product of adjacent elements from the list is: \", adjacent_product([-1, 2, 3, 4, 5, 6, 7]))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def adjacent_element_product(input_list):\n    if len(input_list) == 0:\n        return 0\n    elif len(input_list) == 1:\n        return input_list[0]\n    elif len(input_list) == 2:\n        return input_list[0] * input_list[1]\n    else:\n        max_product = input_list[0] * input_list[1]\n        for i in range(0, len(input_list) - 1):\n            if input_list[i] * input_list[i + 1] > max_product:\n                max_product = input_list[i] * input_list[i + 1]\n    return max_product\n\n\ndef adjacent_element_product_mod(input_list):\n    if len(input_list) == 0:\n        return 0\n    elif len(input_list) == 1:\n        return input_list[0]\n    elif len(input_list) == 2:\n        return input_list[0] * input_list[1]\n    else:\n        max_product = input_list[0] * input_list[1]\n        min_product = input_list[0] * input_list[1]\n        for i in range(0, len(input_list) - 1):\n            if input_list[i] * input_list[i + 1] > max_product:\n                max_product = input_list[i] * input_list[i + 1]\n            elif input_list[i] * input_list[i + 1] < min_product:\n                min_product = input_list[i] * input_list[i + 1]\n    return max_product\n\n\ndef adjacent_element_product_mod_2(input_list):\n    if len(input_list) == 0:\n        return 0\n    elif len(input_list) == 1:\n        return input_list[0]\n    elif len(input_list) == 2:\n        return input_list[0] * input_list[1]\n    else:",
    "def adjacent_element_product(input_list):\n    if len(input_list) < 2:\n        return None\n    max_product = -1 * float(\"inf\")\n    for i in range(len(input_list) - 1):\n        if input_list[i] * input_list[i + 1] > max_product:\n            max_product = input_list[i] * input_list[i + 1]\n    return max_product\n\n\nprint(adjacent_element_product([1, 2, 3]))\nprint(adjacent_element_product([-1, 2, 3]))\nprint(adjacent_element_product([-1, -2, -3]))\nprint(adjacent_element_product([-1, -2, 3]))\nprint(adjacent_element_product([1, 2, 3, 4]))\nprint(adjacent_element_product([1, 2, 3, 4, 5]))",
    "from functools import reduce\n\n\ndef adjacent_element_product(lst):\n    \"\"\"\n    >>> adjacent_element_product([1, 2, 3, 4])\n    12\n    >>> adjacent_element_product([1, 2, 3, 4, 5])\n    12\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6])\n    36\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6, 7])\n    42\n    \"\"\"\n    return reduce(\n        lambda acc, elem: acc if acc > elem * lst[elem] else elem * lst[elem],\n        range(len(lst) - 1),\n        0,\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def adjacent_product(a):\n    if len(a) < 2:\n        return None\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1] > max_prod:\n            max_prod = a[i] * a[i+1]\n    return max_prod\n\n\ndef adjacent_product_2(a):\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1] > max_prod:\n            max_prod = a[i] * a[i+1]\n    return max_prod\n\n\ndef adjacent_product_3(a):\n    if len(a) < 2:\n        return None\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1] > max_prod:\n            max_prod = a[i] * a[i+1]\n    return max_prod\n\n\ndef adjacent_product_4(a):\n    if len(a) < 2:\n        return None\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1] > max_prod:\n            max_prod = a[i] * a[i+1]\n    return max_prod\n\n\ndef adjacent_product_5(a):\n    if len(a) < 2:\n        return None\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1] > max_prod:\n            max_prod = a[i] * a[i+1]\n    return max_prod\n\n\ndef adjacent_product_6(a):\n    if len(a) < 2:\n        return None\n    max_prod = float(\"-inf\")\n    for i in range(len(a)-1):\n        if a[i] * a[i+1]",
    "def adjacent_element_product(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        max_product = lst[0] * lst[1]\n        for i in range(len(lst) - 1):\n            if lst[i] * lst[i + 1] > max_product:\n                max_product = lst[i] * lst[i + 1]\n        return max_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))",
    "def adjacent_elements_product(lst):\n    if len(lst) <= 1:\n        return None\n    max_product = lst[0] * lst[1]\n    for i in range(len(lst)-1):\n        if lst[i]*lst[i+1] > max_product:\n            max_product = lst[i] * lst[i+1]\n    return max_product\n\n\nprint(adjacent_elements_product([2, 4, 9, 5, 7, 8, 6, 0]))",
    "def largest_product(list_of_ints):\n    max_product = 0\n    for index in range(len(list_of_ints)):\n        if index == 0:\n            max_product = list_of_ints[index] * list_of_ints[index + 1]\n        elif index == len(list_of_ints) - 1:\n            max_product = list_of_ints[index - 1] * list_of_ints[index]\n        else:\n            max_product = max(max_product, list_of_ints[index - 1] * list_of_ints[index])\n    return max_product\n\n\nprint(largest_product([-10, -10, 5, 2]))",
    "# solution 1\ndef largest_product(input_list):\n    if len(input_list) <= 1:\n        return \"Invalid Input\"\n    else:\n        max_product = 0\n        for i in range(len(input_list) - 1):\n            if input_list[i] * input_list[i + 1] > max_product:\n                max_product = input_list[i] * input_list[i + 1]\n        return max_product\n\n\n# solution 2\ndef largest_product_2(input_list):\n    if len(input_list) <= 1:\n        return \"Invalid Input\"\n    else:\n        max_product = 0\n        for i in range(len(input_list) - 1):\n            if input_list[i] * input_list[i + 1] > max_product:\n                max_product = input_list[i] * input_list[i + 1]\n        return max_product",
    "def largest_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    Parameters\n    ----------\n    arr : list\n        list of integers\n\n    Returns\n    -------\n    largest product of adjacent elements\n    \"\"\"\n    if len(arr) < 2:\n        return None\n\n    max_product = -float(\"inf\")\n    for i in range(len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(largest_product([1, 2, 3, 4, 5]))",
    "from functools import reduce\n\n\ndef largest_adjacent_product(list_of_integers):\n    \"\"\"\n    Find the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n       list_of_integers(list): List of integers to find the largest product of the pair of adjacent elements\n    Returns:\n       (int): Largest product of the pair of adjacent elements\n    \"\"\"\n    if not list_of_integers:\n        return None\n\n    if len(list_of_integers) == 1:\n        return list_of_integers[0]\n\n    # Convert to string to avoid leading zeros\n    return max(\n        reduce(\n            lambda acc, x: acc + [int(x) * int(x)],\n            \" \".join(map(str, list_of_integers)).split(\" \"),\n            [],\n        )\n    )\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = largest_adjacent_product(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function(([1, 2, 3], 6))\ntest_function(([1, 2, 0, 9], 18))\ntest_function(([5, 2, 3], 6))\ntest_function(([1, -2, 3], 6))\ntest_function(([2, 3, 7, 4, 8], 56))\ntest_function(([5, 2, 4, 0, 4, 3, 3], 48))\ntest_function(([1, 2, 3, 4, 5, 6], 30))\ntest_function(([1, 1, 1], 2))\ntest_function(([0, 0, 0], 0))\ntest_function(([1], 1))\ntest_function(([], None))\ntest_function(([1, 1], 1))\ntest_function(([1",
    "def adjacent_product(nums):\n    max_product = 0\n    for i in range(len(nums)):\n        if i + 1 < len(nums):\n            max_product = max(max_product, nums[i] * nums[i + 1])\n    return max_product",
    "def adjacentElementsProduct(inputList):\n    max_prod = 0\n    for i in range(len(inputList)-1):\n        if inputList[i]*inputList[i+1] > max_prod:\n            max_prod = inputList[i]*inputList[i+1]\n    return max_prod\n\ndef test_cases():\n    assert adjacentElementsProduct([1, 2, 3, 4]) == 12\n    assert adjacentElementsProduct([1, 2, 3, 4, 5]) == 20\n    assert adjacentElementsProduct([1, 2, 3, 4, 5, 6]) == 30\n    print(\"Test Success!\")\n\ntest_cases()",
    "def adjacent_element_product(lst):\n    product = 0\n    for i in range(len(lst)-1):\n        if (lst[i]*lst[i+1]) > product:\n            product = lst[i]*lst[i+1]\n    return product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))\nprint(adjacent_element_product([1, 2, 3, 4]))\nprint(adjacent_element_product([1, 2, 3]))",
    "def adjacent_elements(a):\n    if len(a) < 2:\n        return None\n    max_product = -1\n    for i in range(len(a) - 1):\n        max_product = max(max_product, a[i] * a[i + 1])\n    return max_product\n\n\nassert adjacent_elements([1, 2, 3]) == 6\nassert adjacent_elements([1, 2, 1]) == 2\nassert adjacent_elements([2, 3, 4]) == 12\nassert adjacent_elements([-1, 2, 3]) == 6",
    "def adjacent_element_product(a):\n    \"\"\"\n    >>> adjacent_element_product([1, 2, 3, 4, 5])\n    12\n    >>> adjacent_element_product([2, 3, 4, 5, 6])\n    24\n    >>> adjacent_element_product([1, 2, 1, 4, 1])\n    4\n    \"\"\"\n    if len(a) < 2:\n        return None\n    max_product = -float(\"inf\")\n    for i in range(len(a) - 1):\n        if a[i] * a[i + 1] > max_product:\n            max_product = a[i] * a[i + 1]\n    return max_product\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def adjacent_element_product(input_list):\n    \"\"\"\n    Takes a list and returns the largest product of adjacent elements.\n\n    >>> adjacent_element_product([1, 2, 3, 4, 5])\n    20\n    >>> adjacent_element_product([1, 2, 3, 4, 5, 6])\n    30\n    >>> adjacent_element_product([1, 2, 3, 4])\n    8\n    \"\"\"\n\n    if len(input_list) < 2:\n        return -1\n\n    max_product = 0\n    for i in range(len(input_list)-1):\n        max_product = max(input_list[i] * input_list[i+1], max_product)\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def adjacent_element_product(list_of_num):\n    if len(list_of_num) <= 2:\n        return max(list_of_num)\n    else:\n        max_product = list_of_num[0] * list_of_num[1]\n        for i in range(1, len(list_of_num) - 1):\n            product = list_of_num[i] * list_of_num[i + 1]\n            if product > max_product:\n                max_product = product\n        return max_product\n\n\ndef adjacent_element_product_2(list_of_num):\n    if len(list_of_num) <= 2:\n        return max(list_of_num)\n    else:\n        max_product = list_of_num[0] * list_of_num[1]\n        for i in range(len(list_of_num) - 2):\n            product = list_of_num[i] * list_of_num[i + 2]\n            if product > max_product:\n                max_product = product\n        return max_product",
    "def adjacent_element(lst):\n    return max(a*b for a,b in zip(lst, lst[1:]))\n\nprint(adjacent_element([1, 2, 3, 4]))\nprint(adjacent_element([1, 2, 3, 4, 5]))\nprint(adjacent_element([1, 2, 3, 4, 5, 6]))\nprint(adjacent_element([1, 2, 3, 4, 5, 6, 7]))\n\n\"\"\"\nWrite a python function to find the largest product of the pair of elements from a given list of integers.\n\"\"\"\n\ndef largest_product(lst):\n    return max(a*b for a,b in zip(lst, lst[1:]))\n\nprint(largest_product([1, 2, 3, 4]))\nprint(largest_product([1, 2, 3, 4, 5]))\nprint(largest_product([1, 2, 3, 4, 5, 6]))\nprint(largest_product([1, 2, 3, 4, 5, 6, 7]))\n\n\"\"\"\nWrite a python program to find the longest substring of a given string that has all characters at least twice.\n\"\"\"\n\ndef longest_substring(string):\n    result = \"\"\n    for i in range(len(string)):\n        for j in range(i+1,len(string)+1):\n            substring = string[i:j]\n            if len(substring) == len(set(substring)):\n                if len(substring) > len(result):\n                    result = substring\n    return result\n\nprint(longest_substring(\"abcda\"))\nprint(longest_substring(\"abcb\"))\nprint(longest_substring(\"abcbabcb\"))\nprint(longest_substring(\"abcdefghijklmnopqrstuvwxyz\"))\n\n\"\"\"\nWrite a python program to find the longest palindrome subsequence in a given string.\n\"\"\"\n\ndef longest_palindrome(string):\n    n = len(string)\n    table = [[0 for i in range(n",
    "def adjacent_product(list_of_nums):\n    if len(list_of_nums) < 2:\n        return None\n\n    largest_product = None\n\n    for i in range(len(list_of_nums) - 1):\n        product = list_of_nums[i] * list_of_nums[i + 1]\n        if not largest_product or largest_product < product:\n            largest_product = product\n\n    return largest_product\n\n\ndef adjacent_product_2(list_of_nums):\n    if len(list_of_nums) < 2:\n        return None\n\n    largest_product = None\n\n    for i in range(len(list_of_nums) - 1):\n        product = list_of_nums[i] * list_of_nums[i + 1]\n        if not largest_product or largest_product < product:\n            largest_product = product\n\n    return largest_product\n\n\ndef adjacent_product_3(list_of_nums):\n    if len(list_of_nums) < 2:\n        return None\n\n    largest_product = None\n\n    for i in range(len(list_of_nums) - 1):\n        product = list_of_nums[i] * list_of_nums[i + 1]\n        if not largest_product or largest_product < product:\n            largest_product = product\n\n    return largest_product\n\n\ndef adjacent_product_4(list_of_nums):\n    if len(list_of_nums) < 2:\n        return None\n\n    largest_product = None\n\n    for i in range(len(list_of_nums) - 1):\n        product = list_of_nums[i] * list_of_nums[i + 1]\n        if not largest_product or largest_product < product:\n            largest_product = product\n\n    return largest_product\n\n\ndef adjacent_product_5(list_of_nums):\n    if len(list_of_nums) < 2:",
    "def max_product_of_adjacent_elements(input_list):\n    max_product = 0\n\n    for i in range(len(input_list) - 1):\n        product = input_list[i] * input_list[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\ndef max_product_of_adjacent_elements_2(input_list):\n    max_product = 0\n\n    for i in range(len(input_list) - 1):\n        product = input_list[i] * input_list[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\ndef max_product_of_adjacent_elements_3(input_list):\n    max_product = 0\n\n    for i in range(len(input_list) - 1):\n        product = input_list[i] * input_list[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product",
    "def max_adj_prod(nums):\n    \"\"\"\n    :param: nums - list of integers\n    Should return the largest product of adjacent numbers.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    max_prod = 0\n    for i in range(len(nums) - 1):\n        prod = nums[i] * nums[i + 1]\n        if prod > max_prod:\n            max_prod = prod\n    return max_prod",
    "def adjacent_product(lst):\n    if len(lst) == 0:\n        return 0\n\n    if len(lst) == 1:\n        return lst[0]\n\n    if len(lst) == 2:\n        return lst[0] * lst[1]\n\n    prod = lst[0] * lst[1]\n    largest_prod = prod\n    for i in range(1, len(lst) - 1):\n        prod = prod * lst[i + 1]\n        if prod > largest_prod:\n            largest_prod = prod\n\n    return largest_prod\n\n\nif __name__ == \"__main__\":\n    assert adjacent_product([5, 1, 1, 5]) == 25\n    assert adjacent_product([1, 2, 3, 4]) == 24\n    assert adjacent_product([1, 2, 3, 4, 5, 6]) == 120",
    "from functools import reduce\n\n\ndef adjacent_element_product(lst):\n    \"\"\"Return the largest product of the pair of adjacent elements from a given list of integers.\"\"\"\n    return reduce(lambda x, y: x * y, lst)\n\n\ndef adjacent_element_product2(lst):\n    \"\"\"Return the largest product of the pair of adjacent elements from a given list of integers.\"\"\"\n    if len(lst) < 2:\n        return None\n    max_prod = 0\n    for i in range(len(lst) - 1):\n        max_prod = max(max_prod, lst[i] * lst[i + 1])\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_product([1, 2, 3]))\n    print(adjacent_element_product([1, 2, 3, 4, 5]))\n    print(adjacent_element_product([2, 3, 4, 5, 6]))\n    print(adjacent_element_product([-1, 2, 3, 4, 5]))",
    "def largest_product_of_adjacent_elements(list_of_ints):\n    \"\"\"\n    Return the largest product of the pair of adjacent elements from a given list of integers.\n\n    >>> largest_product_of_adjacent_elements([1,2,3,4,5,6,7,8,9])\n    72\n    >>> largest_product_of_adjacent_elements([1,2,3,-4,5,6,-7,8,9])\n    35\n    >>> largest_product_of_adjacent_elements([-1,2,3,4,-5,6,-7,8,9])\n    35\n    \"\"\"\n    if len(list_of_ints) < 2:\n        return None\n    largest_product = list_of_ints[0] * list_of_ints[1]\n    for i in range(len(list_of_ints) - 1):\n        product = list_of_ints[i] * list_of_ints[i + 1]\n        if product > largest_product:\n            largest_product = product\n    return largest_product\n\n\ndef largest_product_of_adjacent_elements_2(list_of_ints):\n    \"\"\"\n    Return the largest product of the pair of adjacent elements from a given list of integers.\n\n    >>> largest_product_of_adjacent_elements_2([1,2,3,4,5,6,7,8,9])\n    72\n    >>> largest_product_of_adjacent_elements_2([1,2,3,-4,5,6,-7,8,9])\n    35\n    >>> largest_product_of_adjacent_elements_2([-1,2,3,4,-5,6,-7,8,9])\n    35\n    \"\"\"\n    largest_product = max(list_of_ints[0], list_of_ints[-1])\n    for i in range(len(list_of_ints) - 1):\n        product = list_of_ints[i] * list_of_ints[i + 1]\n        if product > largest_product:\n            largest_product = product\n    return largest",
    "def adjacentElementsProduct(inputArray):\n    \"\"\"\n    :param inputArray: list - list of integers\n    :return: int - the maximum product of two adjacent elements.\n    \"\"\"\n    if len(inputArray) < 2:\n        return None\n\n    max_prod = -1\n    for i in range(len(inputArray) - 1):\n        max_prod = max(max_prod, inputArray[i] * inputArray[i + 1])\n\n    return max_prod",
    "def largest_product(list):\n    max_product = 0\n    for i in range(len(list)-1):\n        if list[i] * list[i+1] > max_product:\n            max_product = list[i] * list[i+1]\n    return max_product\n\n\nprint(largest_product([2, 4, 6, 8, 10]))\nprint(largest_product([5, 4, 2, 1, 3, 5]))\nprint(largest_product([2, 4, 6, 8, 10, 3, 2, 10, 2]))",
    "from typing import List\n\n\ndef adjacent_element_product(a: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(a) <= 2:\n        return -1\n\n    max_product = -1\n    for i in range(len(a) - 1):\n        max_product = max(a[i] * a[i + 1], max_product)\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert adjacent_element_product([1, 2, 3, 4]) == 8\n    assert adjacent_element_product([1, 2, 3, 4, 5]) == 12\n    assert adjacent_element_product([1, 2, 3, 4, 5, 6]) == 18",
    "def largest_product_of_adjacent_elements(list_of_ints):\n    \"\"\"\n    Return largest product of the pair of adjacent elements from a given list of integers.\n    \"\"\"\n    if not list_of_ints:\n        return 0\n    if len(list_of_ints) == 1:\n        return list_of_ints[0]\n\n    largest_product = list_of_ints[0] * list_of_ints[1]\n\n    for i in range(len(list_of_ints) - 1):\n        if list_of_ints[i] * list_of_ints[i + 1] > largest_product:\n            largest_product = list_of_ints[i] * list_of_ints[i + 1]\n\n    return largest_product\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = largest_product_of_adjacent_elements(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\ntest_function(([1, 2, 3], 6))\ntest_function(([1, 2, -3], 6))\ntest_function(([2, 3, 6, 4], 24))\ntest_function(([2, 3, 6, -4], 12))\ntest_function(([2, 3, 6, 4, 0], 24))\ntest_function(([2, 3, 6, -4, 0], 12))\ntest_function(([], 0))\ntest_function(([2, 3], 6))\ntest_function(([2, 3, 5], 15))\ntest_function(([2, 3, 5, 4], 20))\ntest_function(([2, 3, 5, 4, 0], 20))\ntest_function(([2, 3, 5, 4, 0, 1], 20))\ntest_function(([2, 3,",
    "def adjacentElementsProduct(inputArray):\n    largest_product = 0\n    for i in range(len(inputArray)-1):\n        if inputArray[i]*inputArray[i+1] > largest_product:\n            largest_product = inputArray[i]*inputArray[i+1]\n    return largest_product",
    "def adjacent_element_product(list_):\n    max_product = -9999999\n    for i in range(len(list_)-1):\n        if list_[i]*list_[i+1] > max_product:\n            max_product = list_[i]*list_[i+1]\n    return max_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))",
    "from functools import reduce\nfrom typing import List, Tuple\n\n\ndef adjacent_element_product(lst: List[int]) -> int:\n    \"\"\"Returns the largest product of the pair of adjacent elements in the given list.\n\n    Examples:\n        >>> assert adjacent_element_product([1, 2, 3, 4]) == 12\n        >>> assert adjacent_element_product([0, 0, 0, 0]) == 0\n        >>> assert adjacent_element_product([-1, -2, -3, -4]) == -12\n        >>> assert adjacent_element_product([-1, 2, 3, 4]) == 8\n        >>> assert adjacent_element_product([-1, 2, -3, 4]) == 12\n\n    References:\n        - https://www.geeksforgeeks.org/largest-product-of-adjacent-elements-in-a-list/\n    \"\"\"\n    return max(\n        reduce(lambda a, b: a * b, lst[i : i + 2]) for i in range(len(lst) - 1)\n    )\n\n\ndef adjacent_element_product_rec(lst: List[int]) -> int:\n    \"\"\"Returns the largest product of the pair of adjacent elements in the given list.\n\n    Examples:\n        >>> assert adjacent_element_product([1, 2, 3, 4]) == 12\n        >>> assert adjacent_element_product([0, 0, 0, 0]) == 0\n        >>> assert adjacent_element_product([-1, -2, -3, -4]) == -12\n        >>> assert adjacent_element_product([-1, 2, 3, 4]) == 8\n        >>> assert adjacent_element_product([-1, 2, -3, 4]) == 12\n\n    Args:\n        lst: list of integers\n\n    Returns:\n        int: largest product of the pair of adjacent elements in the given list\n\n    Examples:\n        >>> adjacent_element_product_rec([1, 2, 3, 4])\n        12\n        >>> adjacent_element_",
    "def adjacent_element_product(lst):\n    result = 0\n    for i in range(len(lst) - 1):\n        result = max(result, lst[i] * lst[i + 1])\n    return result\n\n\ndef main():\n    print(adjacent_element_product([1, 2, 3, 4, 5]))\n    print(adjacent_element_product([1, 2, 3, 4, -10, 5]))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def adjacent_elements(list_of_ints):\n    list_of_ints = list(list_of_ints)\n    if len(list_of_ints) < 2:\n        return None\n    largest = list_of_ints[0] * list_of_ints[1]\n    for i in range(len(list_of_ints) - 1):\n        if list_of_ints[i] * list_of_ints[i + 1] > largest:\n            largest = list_of_ints[i] * list_of_ints[i + 1]\n    return largest\n\n\ndef adjacent_elements_2(list_of_ints):\n    list_of_ints = list(list_of_ints)\n    if len(list_of_ints) < 2:\n        return None\n    largest = 0\n    for i in range(len(list_of_ints) - 1):\n        if list_of_ints[i] * list_of_ints[i + 1] > largest:\n            largest = list_of_ints[i] * list_of_ints[i + 1]\n    return largest\n\n\nprint(adjacent_elements([1, 2, 3, 4, 5]))\nprint(adjacent_elements([1, 2, 3, 4, 5, 6, 7, 8, 9]))\nprint(adjacent_elements_2([1, 2, 3, 4, 5]))\nprint(adjacent_elements_2([1, 2, 3, 4, 5, 6, 7, 8, 9]))",
    "def largest_product_of_adjacent_elements(list):\n    max_product = 0\n    for i in range(len(list) - 1):\n        max_product = max(max_product, list[i] * list[i + 1])\n    return max_product",
    "def largest_product(list_of_ints):\n    if len(list_of_ints) < 2:\n        return None\n    else:\n        largest_product = list_of_ints[0] * list_of_ints[1]\n        for i in range(1, len(list_of_ints)-1):\n            product = list_of_ints[i] * list_of_ints[i+1]\n            if product > largest_product:\n                largest_product = product\n        return largest_product\n\n\nprint(largest_product([1, 2, 3, 4, 5]))\nprint(largest_product([1, 2, 3, 4]))\nprint(largest_product([1, 2, 3, 4, 5, 6, 7, 8]))\nprint(largest_product([1, 2, 3, 4, -10, 5, 6, 7, 8]))",
    "def adjacent_product(lst):\n    max_product = 0\n    for i in range(len(lst)-1):\n        if lst[i]*lst[i+1] > max_product:\n            max_product = lst[i]*lst[i+1]\n    return max_product\n\n\nprint(adjacent_product([1, 2, 3, 4]))",
    "from problem_1 import adjacent_elements_product\n\n\ndef adjacent_elements_product_v2(arr):\n    \"\"\"\n    Return the largest product of the pair of adjacent elements from a given list of integers.\n\n    >>> adjacent_elements_product_v2([1, 2, 3, 4])\n    12\n    >>> adjacent_elements_product_v2([1, 2, 3, 4, 5])\n    12\n    >>> adjacent_elements_product_v2([1, 2, 3, 4, 5, 6])\n    18\n    >>> adjacent_elements_product_v2([1, 2, 3, 4, 5, 6, 7])\n    21\n    >>> adjacent_elements_product_v2([1, 2, 3, 4, 5, 6, 7, 8])\n    24\n    \"\"\"\n    return max(adjacent_elements_product(arr))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def adjacent_element_product(lst):\n    max_product = 0\n    for i in range(len(lst)-1):\n        max_product = max(max_product, lst[i]*lst[i+1])\n    return max_product\n\n\nprint(adjacent_element_product([1,2,3,4,5,6,7,8,9]))\nprint(adjacent_element_product([1,2,3,4,5,-6,-7,8,9]))\nprint(adjacent_element_product([-1,-2,-3,-4,-5,6,7,-8,-9]))",
    "def adjacentElementsProduct(inputArray):\n    \"\"\"\n    :param inputArray: list - list of integers\n    :return: int - the max product of two adjacent numbers in the list\n    \"\"\"\n    max_prod = 0\n    for i in range(len(inputArray)-1):\n        max_prod = max(max_prod, inputArray[i]*inputArray[i+1])\n    return max_prod\n\ndef test_cases():\n    assert adjacentElementsProduct([1,2,3,4]) == 12\n    assert adjacentElementsProduct([1,2,0,1]) == 2\n    assert adjacentElementsProduct([-1,2,-3,4]) == 24\n    assert adjacentElementsProduct([-1,2,3,-4]) == 6\n    print(\"Test Success!\")\n\ntest_cases()",
    "from functools import reduce\n\n\ndef adjacent_product(lst):\n    return reduce(lambda x, y: x if x > y else y, [lst[i] * lst[i + 1] for i in range(len(lst) - 1)])\n\n\nif __name__ == \"__main__\":\n    print(adjacent_product([1, 2, 3, 4]))\n    print(adjacent_product([2, 3, 4, 5]))",
    "def adjacent_list_product(l):\n    product = 0\n    for i in range(len(l)-1):\n        product = max(l[i] * l[i+1], product)\n    return product\n\n\ndef adjacent_list_product_2(l):\n    product = 0\n    for i in range(len(l)-1):\n        product = max(l[i+1] * l[i], product)\n    return product\n\n\ndef adjacent_list_product_3(l):\n    product = 0\n    for i in range(len(l)-1):\n        if l[i]*l[i+1] > product:\n            product = l[i]*l[i+1]\n    return product\n\n\ndef adjacent_list_product_4(l):\n    product = 0\n    for i in range(len(l)-1):\n        if l[i]*l[i+1] > product:\n            product = l[i]*l[i+1]\n    return product",
    "def max_adjacent_product(lst):\n    max_prod = 0\n    for i in range(len(lst)):\n        if i+1 >= len(lst):\n            break\n        max_prod = max(max_prod, lst[i]*lst[i+1])\n    return max_prod\n\n\nprint(max_adjacent_product([2, 4, 6, 2, 5]))\nprint(max_adjacent_product([1, 2, 3, 4]))",
    "def adjacentElementsProduct(inputArray):\n    # Write your code here.\n    max_prod = -1\n    for i in range(len(inputArray)-1):\n        prod = inputArray[i] * inputArray[i+1]\n        if prod > max_prod:\n            max_prod = prod\n    return max_prod",
    "def largest_product(list):\n    largest = list[0]*list[1]\n    for i in range(len(list)):\n        if i+1<len(list):\n            if largest<list[i]*list[i+1]:\n                largest = list[i]*list[i+1]\n    return largest",
    "def largest_product(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):\n        if list_of_numbers[i] * list_of_numbers[i+1] > product:\n            product = list_of_numbers[i] * list_of_numbers[i+1]\n    return product\n\n\ndef largest_product2(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):\n        if list_of_numbers[i] * list_of_numbers[i + 1] > product:\n            product = list_of_numbers[i] * list_of_numbers[i + 1]\n    return product\n\n\ndef largest_product3(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):\n        if list_of_numbers[i] * list_of_numbers[i + 1] > product:\n            product = list_of_numbers[i] * list_of_numbers[i + 1]\n    return product\n\n\ndef largest_product4(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):\n        if list_of_numbers[i] * list_of_numbers[i + 1] > product:\n            product = list_of_numbers[i] * list_of_numbers[i + 1]\n    return product\n\n\ndef largest_product5(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):\n        if list_of_numbers[i] * list_of_numbers[i + 1] > product:\n            product = list_of_numbers[i] * list_of_numbers[i + 1]\n    return product\n\n\ndef largest_product6(list_of_numbers):\n    product = 0\n\n    for i in range(len(list_of_numbers) - 1):",
    "from problem_2 import adjacent_product\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the size of the list: \"))\n    arr = []\n    print(\"Enter the list elements:\")\n    for i in range(n):\n        arr.append(int(input()))\n\n    print(\"The largest product of the pair of adjacent elements is:\", adjacent_product(arr))",
    "def adjacent_largest_product(lst):\n    \"\"\"\n    >>> adjacent_largest_product([1, 2, 3, 4])\n    12\n    >>> adjacent_largest_product([2, 3, 4, 5])\n    20\n    >>> adjacent_largest_product([5, 4, 3, 2])\n    20\n    >>> adjacent_largest_product([5, 4, 3, 2, 1])\n    10\n    >>> adjacent_largest_product([1, 2, 3, 4, 5])\n    15\n    >>> adjacent_largest_product([1, 2, 3, 4, 5, 6])\n    24\n    >>> adjacent_largest_product([-1, 2, 3, 4, 5, 6])\n    24\n    \"\"\"\n    return max(\n        [\n            lst[i] * lst[i + 1]\n            for i in range(len(lst) - 1)\n            if lst[i] * lst[i + 1] > 0\n        ]\n        + [\n            lst[i - 1] * lst[i]\n            for i in range(1, len(lst))\n            if lst[i - 1] * lst[i] > 0\n        ]\n        + [\n            lst[i] * lst[i + 1]\n            for i in range(len(lst) - 1)\n            if lst[i] * lst[i + 1] < 0\n        ]\n        + [\n            lst[i - 1] * lst[i]\n            for i in range(1, len(lst))\n            if lst[i - 1] * lst[i] < 0\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def adjacent_element_product(lst):\n    max_product = 0\n    for i in range(len(lst)):\n        if (i+1) < len(lst):\n            product = lst[i] * lst[i+1]\n            if max_product < product:\n                max_product = product\n    return max_product\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))",
    "def largest_product(l):\n    \"\"\"\n    Return the largest product of the pair of adjacent elements from a given list of integers.\n\n    >>> largest_product([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    72\n    >>> largest_product([1, 2, 3, 4, -5, 6, 7, 8, 9])\n    35\n    >>> largest_product([-1, -2, -3, -4, -5, -6, -7, -8, -9])\n    -72\n    >>> largest_product([1, 2, 3, 4, 5, 6, 7, 8, -9])\n    63\n    >>> largest_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    72\n    \"\"\"\n    if len(l) < 2:\n        return None\n    if l[0] < 0 or l[-1] < 0:\n        return largest_product(l[1:])\n    elif l[0] > l[-1]:\n        return largest_product(l[1:])\n    else:\n        return l[0] * l[1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "from typing import List\n\n\ndef adjacent_element_product(lst: List) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    max_prod = lst[0] * lst[1]\n\n    for i in range(len(lst) - 1):\n        if lst[i] * lst[i + 1] > max_prod:\n            max_prod = lst[i] * lst[i + 1]\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    assert adjacent_element_product([1, 2, 3, 4, 5]) == 20\n    assert adjacent_element_product([1, 2, 3, 4, 1, 2, 3, 4]) == 12\n    assert adjacent_element_product([1, 2]) is None",
    "from typing import List\n\n\ndef adjacent_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    if len(nums) <= 2:\n        return -1\n\n    max_prod = nums[0] * nums[1]\n\n    for i in range(1, len(nums) - 1):\n        curr_prod = nums[i] * nums[i + 1]\n        if curr_prod > max_prod:\n            max_prod = curr_prod\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    print(adjacent_product([5, 1, 2, 5, 1, 2]))\n    print(adjacent_product([1, 2, 3]))",
    "from functools import reduce\n\n\ndef largest_product(list_nums):\n    \"\"\"Return largest product of adjacent numbers.\"\"\"\n    if len(list_nums) < 2:\n        return \"List too short\"\n    else:\n        for i in range(len(list_nums)):\n            if list_nums[i] == 0:\n                return \"List cannot have 0\"\n        return reduce(lambda x, y: x * y, list_nums)",
    "def adjacent_element_product(input_list):\n    if len(input_list) == 0:\n        return 0\n    elif len(input_list) == 1:\n        return 0\n    elif len(input_list) == 2:\n        return input_list[0] * input_list[1]\n    else:\n        max_product = input_list[0] * input_list[1]\n        for i in range(0, len(input_list) - 1):\n            if (input_list[i] * input_list[i+1]) > max_product:\n                max_product = input_list[i] * input_list[i+1]\n        return max_product\n\ndef adjacent_element_product_pythonic(input_list):\n    if len(input_list) == 0:\n        return 0\n    elif len(input_list) == 1:\n        return 0\n    elif len(input_list) == 2:\n        return input_list[0] * input_list[1]\n    else:\n        max_product = input_list[0] * input_list[1]\n        for i in range(0, len(input_list) - 1):\n            if (input_list[i] * input_list[i+1]) > max_product:\n                max_product = input_list[i] * input_list[i+1]\n        return max_product\n\ndef main():\n    inp = [1, 2, 3, -4, 5]\n    print(\"Adjacent element product using for loop: \" + str(adjacent_element_product(inp)))\n    print(\"Adjacent element product using pythonic: \" + str(adjacent_element_product_pythonic(inp)))\n\nif __name__ == '__main__':\n    main()",
    "def adjacent_element_product(input_list):\n    if len(input_list) < 2:\n        return -1\n\n    max_product = -1\n    for i in range(len(input_list) - 1):\n        product = input_list[i] * input_list[i + 1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4]))\nprint(adjacent_element_product([1, 2, 3, 4, 5]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7, 8]))",
    "def adjacent_product(input_list):\n    if len(input_list) < 2:\n        return 0\n    else:\n        result = 0\n        for i in range(len(input_list)-1):\n            result = max(result, input_list[i] * input_list[i+1])\n        return result\n\n\nif __name__ == \"__main__\":\n    input_list = [1, 2, 3]\n    print(adjacent_product(input_list))",
    "def adjacent_element_product(lst):\n    # loop through the list\n    # calculate the product of the current element and the next element\n    # compare with the largest product\n    # if it is larger, update the largest product\n    largest_product = 0\n    for i in range(len(lst)-1):\n        product = lst[i] * lst[i+1]\n        if product > largest_product:\n            largest_product = product\n    return largest_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4]))\nprint(adjacent_element_product([9, 51, 2, 7, 3, -1]))",
    "def adjacent_element_product(list_of_int):\n    max_product = 0\n    for i in range(len(list_of_int) - 1):\n        if max_product < list_of_int[i] * list_of_int[i + 1]:\n            max_product = list_of_int[i] * list_of_int[i + 1]\n    return max_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))\nprint(adjacent_element_product([1, 2, 3, 4, -10]))",
    "def largest_product_of_adjacent_elements(lst):\n    if len(lst) == 0:\n        return 0\n\n    largest_product = lst[0] * lst[1]\n\n    for i in range(1, len(lst) - 1):\n        if (lst[i] - 1) * lst[i + 1] > largest_product:\n            largest_product = (lst[i] - 1) * lst[i + 1]\n\n        if (lst[i] + 1) * lst[i + 1] > largest_product:\n            largest_product = (lst[i] + 1) * lst[i + 1]\n\n    return largest_product\n\n\nprint(largest_product_of_adjacent_elements([10, -2, 5, -6, 1, 6, 8, 2, 1, 2, 3, -1, 4, 5]))\nprint(largest_product_of_adjacent_elements([10, -2, 5, -6, 1, 6, 8, 2, 1, 2, 3, -1, 4, 5, 10]))\nprint(largest_product_of_adjacent_elements([10, -2, 5, -6, 1, 6, 8, 2, 1, 2, 3, -1, 4, 5, 10, -10]))\nprint(largest_product_of_adjacent_elements([10, -2, 5, -6, 1, 6, 8, 2, 1, 2, 3, -1, 4, 5, 10, -10, 10]))\nprint(largest_product_of_adjacent_elements([]))",
    "from typing import List\n\n\ndef adjacent_element_product(lst: List) -> int:\n    \"\"\"Returns the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        lst (List): list of integers\n\n    Examples:\n        >>> assert adjacent_element_product([1,2,3,4]) == 12\n    \"\"\"\n    if not lst:\n        return\n    else:\n        return max(\n            [\n                lst[i] * lst[i + 1]\n                for i in range(len(lst) - 1)\n                if lst[i] * lst[i + 1] > 0\n            ]\n        )\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_product([1, 2, 3, 4]))",
    "from functools import reduce\n\n\ndef adjacent_element_product(input_list):\n    \"\"\"Return largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n        input_list (list): list of integers\n\n    Returns:\n        int: largest product of the pair of adjacent elements from a given list of integers\n\n    \"\"\"\n    return reduce(\n        lambda x, y: x * y,\n        filter(\n            lambda x: x > 0,\n            map(\n                lambda x: x[0] * x[1],\n                zip(input_list, input_list[1:])\n            )\n        ),\n        0\n    )\n\n\nif __name__ == '__main__':\n    print(adjacent_element_product([2, 4, 0, 5, 6, 2, 3]))\n    print(adjacent_element_product([-2, 2, 3, -4, 2, 0, 2, 4]))\n    print(adjacent_element_product([-2, 2, 3, -4, 2, 0, 2, 4, -1]))",
    "def adjacent_elements(nums):\n    max_product = 0\n    for i in range(len(nums)-1):\n        product = nums[i] * nums[i+1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\ndef main():\n    nums = [2, 3, 5, 1, 1, 2]\n    max_product = adjacent_elements(nums)\n    print(f\"The largest product of the pair of adjacent elements from a given list of integers {nums} is {max_product}\")\n\n\nif __name__ == '__main__':\n    main()",
    "def adjacent_element_product(list_of_integers):\n    \"\"\"\n    Find the largest product of the pair of adjacent elements from a given list of integers\n\n    Args:\n       list_of_integers(list): List of integers\n    Returns:\n       int: The largest product of the pair of adjacent elements from a given list of integers\n    \"\"\"\n\n    if len(list_of_integers) < 2:\n        return 0\n\n    max_product = 0\n\n    for i in range(len(list_of_integers) - 1):\n        max_product = max(max_product, list_of_integers[i] * list_of_integers[i+1])\n\n    return max_product\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = adjacent_element_product(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function(([1, 2, 3], 6))\ntest_function(([1, 2, -3], 6))\ntest_function(([-1, 2, 3], 6))\ntest_function(([1, 2, 3, 4], 24))\ntest_function(([-1, -2, -3], -6))\ntest_function(([], 0))\ntest_function(([1], 0))\ntest_function(([1, 2], 2))\ntest_function(([1, 2, 3, 4, 5], 20))",
    "from functools import reduce\n\n\ndef largest_product(list_of_int):\n    \"\"\"\n    Return the largest product of the pair of adjacent elements from a given list of integers.\n    \"\"\"\n    return reduce(lambda x, y: max(x, y), [a * b for a, b in zip(list_of_int, list_of_int[1:])])",
    "def adjacent_product(lst):\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    largest = 0\n    for i in range(1, len(lst)):\n        largest = max(largest, lst[i - 1] * lst[i])\n    return largest\n\n\nprint(adjacent_product([1, 2, 3, 4, 5]))\nprint(adjacent_product([1, 2, 3, 4, -10, 5]))",
    "def adjacent_element_product(list_of_integers):\n    if len(list_of_integers) < 2:\n        return None\n    else:\n        largest_product = 0\n        for i in range(len(list_of_integers)-1):\n            product = list_of_integers[i] * list_of_integers[i+1]\n            if product > largest_product:\n                largest_product = product\n        return largest_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))\nprint(adjacent_element_product([1, 2, 3, 4, 0]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7, 8]))",
    "def adjacentElementsProduct(inputArray):\n    return max(inputArray[i] * inputArray[i + 1] for i in range(len(inputArray) - 1))",
    "def largest_product(lst):\n    largest_product = 0\n    for i in range(len(lst) - 1):\n        product = lst[i] * lst[i + 1]\n        if product > largest_product:\n            largest_product = product\n    return largest_product\n\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 3, 4, 5]\n    print(largest_product(lst))",
    "def adjacent_element_product(lst):\n    \"\"\"\n    Takes a list of integers as an argument.\n    Returns the largest product of the pair of adjacent elements from the list.\n    \"\"\"\n    largest_product = 0\n    for i in range(len(lst) - 1):\n        product = lst[i] * lst[i + 1]\n        if product > largest_product:\n            largest_product = product\n    return largest_product",
    "def largest_product(list):\n    \"\"\"\n    >>> largest_product([1,2,3,4,5])\n    120\n    >>> largest_product([2,3,-2,-2,6,4])\n    12\n    \"\"\"\n    max_product = list[0] * list[1]\n    for i in range(len(list) - 1):\n        product = list[i] * list[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "def largest_product(lst):\n    \"\"\"\n    Find the largest product of the pair of adjacent elements from a given list of integers.\n\n    Args:\n       lst(list): List of integers to find the largest product\n    Returns:\n       (int): Largest product between adjacent elements\n    \"\"\"\n    # TODO: Write your solution here\n    # if len(lst) < 2:\n    #     return None\n    # elif len(lst) == 2:\n    #     return lst[0] * lst[1]\n    # else:\n    #     return max(lst[i] * lst[i + 1] for i in range(len(lst) - 1))\n\n    # O(N) solution\n    # max_product = lst[0] * lst[1]\n    # for i in range(1, len(lst) - 1):\n    #     curr_product = max(lst[i], lst[i] * lst[i - 1], lst[i] * lst[i + 1])\n    #     max_product = max(max_product, curr_product)\n    # return max_product\n\n    # O(N) solution\n    if len(lst) < 2:\n        return None\n    elif len(lst) == 2:\n        return lst[0] * lst[1]\n    else:\n        max_product = lst[0] * lst[1]\n        min_product = lst[0] * lst[1]\n        for i in range(1, len(lst) - 1):\n            if lst[i - 1] * lst[i + 1] > lst[i] * max_product:\n                max_product = lst[i - 1] * lst[i + 1]\n            if lst[i - 1] * lst[i + 1] < lst[i] * min_product:\n                min_product = lst[i - 1] * lst[i + 1]\n        return max(max_product, min_product)\n\n\n# Test Cases\n\n# Test Case 1\nprint(\"Calling largest_product([10, 2, 3, 4]) is:",
    "def adjacent_elements_product(input_list):\n    if len(input_list) == 0:\n        return None\n    elif len(input_list) == 1:\n        return input_list[0]\n    elif len(input_list) == 2:\n        return input_list[0]\n    else:\n        max_product = 0\n        for i in range(len(input_list)-1):\n            if input_list[i] * input_list[i+1] > max_product:\n                max_product = input_list[i] * input_list[i+1]\n        return max_product",
    "def adjacent_element_product(lst):\n    \"\"\"\n    >>> adjacent_element_product([1,2,3,4])\n    12\n    >>> adjacent_element_product([-10,-9,-8,-7,-6])\n    90\n    >>> adjacent_element_product([-1,1,-1,1])\n    0\n    \"\"\"\n\n    if len(lst)<2:\n        return 0\n\n    prod = lst[0]*lst[1]\n    for i in range(len(lst)-1):\n        if (lst[i]*lst[i+1]) > prod:\n            prod = lst[i]*lst[i+1]\n    return prod\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def largest_product_of_adjacent_elements(input_list):\n    \"\"\"\n    >>> largest_product_of_adjacent_elements([-10, -10, 5, 2])\n    50\n    >>> largest_product_of_adjacent_elements([-4, 5, 0, 4, 3, -2])\n    20\n    \"\"\"\n    output = 0\n    for i in range(len(input_list) - 1):\n        output = max(output, input_list[i] * input_list[i + 1])\n    return output\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# Solution\ndef adjacent_elements_product(input_list):\n    max_product = 0\n    for i in range(len(input_list) - 1):\n        if (input_list[i] * input_list[i + 1]) > max_product:\n            max_product = input_list[i] * input_list[i + 1]\n    return max_product\n\n\n# Tests\ndef test_function(test_case):\n    input_list = test_case[0]\n    solution = test_case[1]\n    output = adjacent_elements_product(input_list)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function([[1, 2, 3, 4, 5], 120])\ntest_function([[1, 2, 3, 4, -10], 20])\ntest_function([[-10, 1, 2, 3, -10], 60])",
    "# solution 1:\ndef max_product_adjacent_elements(input_list):\n    if len(input_list) <= 2:\n        return None\n    max_product = 0\n    for i in range(1, len(input_list)-1):\n        if input_list[i-1] * input_list[i] > max_product:\n            max_product = input_list[i-1] * input_list[i]\n    return max_product\n\n\n# solution 2:\ndef max_product_adjacent_elements_v2(input_list):\n    if len(input_list) <= 2:\n        return None\n    max_product = 0\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_product:\n            max_product = input_list[i] * input_list[i+1]\n    return max_product\n\n\n# solution 3:\ndef max_product_adjacent_elements_v3(input_list):\n    if len(input_list) <= 2:\n        return None\n    max_product = 0\n    for i in range(len(input_list)-1):\n        if input_list[i] < 0:\n            first_number = input_list[i+1]\n        else:\n            first_number = input_list[i]\n        if input_list[i+1] < 0:\n            second_number = input_list[i]\n        else:\n            second_number = input_list[i+1]\n        if first_number * second_number > max_product:\n            max_product = first_number * second_number\n    return max_product\n\n\nprint(max_product_adjacent_elements([1, 2, 3, 4, 5]))\nprint(max_product_adjacent_elements([-1, 2, -3, 4, 5]))\nprint(max_product_adjacent_elements([-1, -2, -3, -4, -5]))\nprint(max_product_adjacent_elements([",
    "def largest_adjacent_product(input_list):\n    largest_product = 0\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > largest_product:\n            largest_product = input_list[i] * input_list[i+1]\n    return largest_product\n\n\nprint(largest_adjacent_product([2, 4, 3, 6, 2, 5]))",
    "def adjacent_list_product(list_of_numbers):\n    list_of_products = []\n    for i in range(len(list_of_numbers)-1):\n        list_of_products.append(list_of_numbers[i]*list_of_numbers[i+1])\n    return max(list_of_products)\n\ndef test_cases():\n    return [\n        {\n            \"assertion\": adjacent_list_product([1, 2, 3, 4, 5]),\n            \"expected\": 12,\n        },\n        {\n            \"assertion\": adjacent_list_product([-1, 2, 3, 4, 5]),\n            \"expected\": 6,\n        },\n        {\n            \"assertion\": adjacent_list_product([-1, -2, 3, 4, 5]),\n            \"expected\": -6,\n        },\n        {\n            \"assertion\": adjacent_list_product([-1, 2, -3, 4, 5]),\n            \"expected\": -6,\n        },\n        {\n            \"assertion\": adjacent_list_product([1, 2, 3, -4, 5]),\n            \"expected\": 6,\n        },\n        {\n            \"assertion\": adjacent_list_product([1, 2, 3, 4, 0]),\n            \"expected\": 0,\n        },\n        {\n            \"assertion\": adjacent_list_product([-1, 2, 3, 4, 0]),\n            \"expected\": 0,\n        },\n    ]\n\ndef main():\n    test_cases_results = map(lambda test_case: print(f'Expected: {test_case[\"expected\"]}, actual: {test_case[\"assertion\"]}'), test_cases())\n\nif __name__ == '__main__':\n    main()",
    "def adjacent_product(input_list):\n    max_prod = input_list[0] * input_list[1]\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_prod:\n            max_prod = input_list[i] * input_list[i+1]\n    return max_prod\n\n\ndef adjacent_product_2(input_list):\n    max_prod = input_list[0] * input_list[1]\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_prod:\n            max_prod = input_list[i] * input_list[i+1]\n    return max_prod\n\n\ndef adjacent_product_3(input_list):\n    max_prod = input_list[0] * input_list[1]\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_prod:\n            max_prod = input_list[i] * input_list[i+1]\n    return max_prod\n\n\ndef adjacent_product_4(input_list):\n    max_prod = input_list[0] * input_list[1]\n    for i in range(len(input_list)-1):\n        if input_list[i] * input_list[i+1] > max_prod:\n            max_prod = input_list[i] * input_list[i+1]\n    return max_prod",
    "def largest_product_adjacent(lst):\n    largest_product = 0\n    for i in range(len(lst)-1):\n        largest_product = max(largest_product, lst[i]*lst[i+1])\n    return largest_product\n\n\nprint(largest_product_adjacent([1, 2, 3, 4]))\nprint(largest_product_adjacent([1, 2, -3, 4]))\nprint(largest_product_adjacent([-1, -2, -3, -4]))",
    "def adjacent_element_product(list_of_integer):\n    \"\"\"\n    This function returns the largest product of the pair of adjacent elements from a given list of integers\n    :param list_of_integer: list of integers\n    :return: largest product of the pair of adjacent elements from a given list of integers\n    \"\"\"\n    if len(list_of_integer) < 2:\n        raise Exception(\"List must have at least two elements\")\n\n    largest_product = list_of_integer[0] * list_of_integer[1]\n    for i in range(len(list_of_integer) - 1):\n        product = list_of_integer[i] * list_of_integer[i + 1]\n        if product > largest_product:\n            largest_product = product\n\n    return largest_product\n\n\nprint(adjacent_element_product([1, 2, 3, 4, 5]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7, 8]))\nprint(adjacent_element_product([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
    "def largest_product_of_adjacent_elements(lst):\n    if len(lst) < 2:\n        return None\n    max_product = lst[0] * lst[1]\n    for i in range(len(lst) - 1):\n        if max_product < lst[i] * lst[i + 1]:\n            max_product = lst[i] * lst[i + 1]\n    return max_product\n\n\nprint(largest_product_of_adjacent_elements([1, 2, 3, 4, 5]))\nprint(largest_product_of_adjacent_elements([-1, -2, -3, -4, -5]))\nprint(largest_product_of_adjacent_elements([-1, 2, 3, 4, 5]))\nprint(largest_product_of_adjacent_elements([-1, -2, 3, 4, 5]))\nprint(largest_product_of_adjacent_elements([1, -2, 3, 4, 5]))\nprint(largest_product_of_adjacent_elements([1, 2, 3, 4, -5]))",
    "def adjacent_element_product(input_list):\n    max_product = -999999999999\n    for i in range(len(input_list)):\n        if i < len(input_list) - 1:\n            product = input_list[i] * input_list[i + 1]\n            if product > max_product:\n                max_product = product\n    return max_product\n\n\ndef main():\n    print(adjacent_element_product([2, 4, 6, 2, 5]))\n    print(adjacent_element_product([2, 4, 6, 2, 5, 10]))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def largest_product(list):\n    result = 0\n    for i in range(len(list)):\n        if i == len(list) - 1:\n            break\n        result = max(result, list[i]*list[i+1])\n    return result\n\nprint(largest_product([1,2,3,4,5]))\nprint(largest_product([-1,2,3,4,5]))",
    "from typing import List\n\n\ndef adjacent_element_product(numbers: List[int]) -> int:\n    \"\"\"Returns largest product of the pair of adjacent elements from a given list of integers.\n\n    Examples:\n        >>> assert adjacent_element_product([1, 2, 3, 4]) == 12\n    \"\"\"\n    return max(\n        (numbers[i] * numbers[i + 1] for i in range(len(numbers) - 1)), default=0\n    )\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_product([1, 2, 3, 4]))",
    "def adjacent_element(list_of_integers):\n    if len(list_of_integers) < 2:\n        return None\n\n    max_product = 0\n\n    for i in range(len(list_of_integers) - 1):\n        product = list_of_integers[i] * list_of_integers[i+1]\n        if product > max_product:\n            max_product = product\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    list_of_integers = [1,2,3,4,5]\n    print(adjacent_element(list_of_integers))",
    "def largest_product(lst):\n    largest_product = 0\n    for i in range(len(lst)):\n        if i + 1 < len(lst):\n            if lst[i] * lst[i + 1] > largest_product:\n                largest_product = lst[i] * lst[i + 1]\n    return largest_product"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}