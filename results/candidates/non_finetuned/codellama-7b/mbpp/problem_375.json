{
  "problem": {
    "task_id": "MBPP/386",
    "prompt": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.",
    "canonical_solution": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap",
    "test_list": [
      "assert swap_count(\"[]][][\") == 2",
      "assert swap_count(\"[[][]]\") == 0",
      "assert swap_count(\"[[][]]][\") == 1"
    ],
    "challenge_test_list": [],
    "problem_id": 375
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def min_swaps_bracket_balancing(s):\n    stack = []\n    swaps = 0\n\n    for ch in s:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    swaps += len(stack)\n\n    return swaps\n\n\nif __name__ == '__main__':\n    print(\"Minimum swaps required for bracket balancing is: \" +\n          str(min_swaps_bracket_balancing('(((((())')))\n    print(\"Minimum swaps required for bracket balancing is: \" +\n          str(min_swaps_bracket_balancing('(()))')))\n    print(\"Minimum swaps required for bracket balancing is: \" +\n          str(min_swaps_bracket_balancing(')(')))",
    "def min_bracket_balance(string):\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_balance('((()))'))\n    print(min_bracket_balance('(()))('))\n    print(min_bracket_balance('((((()))))'))\n    print(min_bracket_balance('((())))('))",
    "def min_swaps(s):\n    open_brackets = []\n    swaps = 0\n\n    for c in s:\n        if c == \"(\":\n            open_brackets.append(c)\n        elif c == \")\":\n            if len(open_brackets) == 0:\n                swaps += 1\n            else:\n                open_brackets.pop()\n\n    return swaps\n\n\ndef main():\n    s = input()\n    print(min_swaps(s))\n\n\nif __name__ == '__main__':\n    main()",
    "def min_bracket_swaps(s: str) -> int:\n    \"\"\"\n    The idea is to use a stack to keep track of the opening brackets.\n    The idea is to check if the top of the stack is the closing bracket of the\n    current opening bracket. If so, then we pop the top of the stack.\n    If the top of the stack is not the closing bracket, then we push it to the\n    stack.\n\n    Since we need to find the minimum number of swaps, we keep track of the number of swaps.\n    \"\"\"\n    swaps = 0\n    stack = []\n    for c in s:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if stack and stack[-1] == \"(\":\n                stack.pop()\n            else:\n                stack.append(c)\n                swaps += 1\n    swaps += len(stack)\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_swaps(\"()(((())()\"))\n    print(min_bracket_swaps(\"()((())()\"))",
    "from collections import deque\n\n\ndef minimum_swaps(arr):\n    open_brackets = deque()\n    swaps = 0\n\n    for i in range(len(arr)):\n        if arr[i] == '(':\n            open_brackets.append(i)\n        else:\n            if open_brackets:\n                open_brackets.pop()\n                swaps += 1\n            else:\n                open_brackets.append(i)\n\n    return swaps + len(open_brackets)\n\n\ndef main():\n    arr = input(\"Enter a string: \")\n    print(minimum_swaps(arr))\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\nclass Solution:\n    \"\"\"\n    Greedy approach.\n    Check if current symbol is closing bracket and the last symbol is not the matching opening bracket.\n    If so, remove both symbols and add 1 to the number of swaps.\n    Then swap the current symbol with the last symbol.\n\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n\n    def minSwaps(self, s: str) -> int:\n        swaps = 0\n        stack = []\n        for i in range(len(s)):\n            if s[i] == \")\":\n                if len(stack) == 0 or stack[-1] != \"(\":\n                    swaps += 1\n                else:\n                    stack.pop()\n            else:\n                stack.append(s[i])\n        return swaps\n\n\nclass Solution2:\n    \"\"\"\n    Similar to the first solution, but here we use stack for keeping track of the opening brackets.\n    We can use the stack for keeping track of the number of opening brackets,\n    so that we don't need to do any swaps.\n\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n\n    def minSwaps(self, s: str) -> int:\n        swaps = 0\n        stack = []\n        for i in range(len(s)):\n            if s[i] == \")\":\n                if len(stack) == 0 or stack[-1] != \"(\":\n                    swaps += 1\n                else:\n                    stack.pop()\n            else:\n                stack.append(s[i])\n        return swaps\n\n\nif __name__ == \"__main__\":\n    solutions = [Solution(), Solution2()]\n    tc = (\n        (\"()()\", 0),\n        (\"()(()\", 3),\n        (\")(\", 1),\n        (\"))(\", 1),\n        (\"((\", 2),\n        (\"(((\", 2),\n        (\")\", 0),\n        (\")(\", 1),\n        (\"((\", 2),\n        (\"(())\", 1),\n        (\"()()",
    "def min_swaps(s: str) -> int:\n    \"\"\"\n    Algorithm:\n    - Make a stack and push the opening bracket and count the number of swaps.\n    - Now pop the topmost element of the stack.\n    - If the element is closing bracket and stack is empty, then the string is not balanced.\n    - If the element is closing bracket and stack is not empty, then the topmost element in the stack is opening bracket.\n    - Then pop the topmost element of the stack and count the number of swaps.\n    - Push the closing bracket to the stack.\n    - Else push the opening bracket to the stack.\n    - Repeat the process until the stack is empty.\n\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for char in s:\n        if char in \"(\":\n            stack.append(char)\n        elif char in \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n        else:\n            raise Exception(\"Invalid Input\")\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_swaps(\"()\"))\n    print(min_swaps(\"(())\"))\n    print(min_swaps(\"()(\"))\n    print(min_swaps(\"(()))\"))",
    "def min_swaps(arr):\n    n = len(arr)\n    swaps = 0\n    open_count = 0\n    for i in range(n):\n        if arr[i] == '(':\n            open_count += 1\n        else:\n            open_count -= 1\n\n        if open_count < 0:\n            swaps += 1\n            open_count = 0\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        arr = input().strip()\n        print(min_swaps(arr))",
    "from collections import deque\n\n\ndef min_bracket_swaps(expression: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = deque()\n    swaps = 0\n\n    for i in expression:\n        if i == \"(\":\n            stack.append(i)\n        elif i == \")\":\n            if stack and stack[-1] == \"(\":\n                stack.pop()\n            else:\n                stack.append(i)\n                swaps += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"(()()\") == 1\n    assert min_bracket_swaps(\")(\") == 2\n    assert min_bracket_swaps(\"()\") == 0\n    assert min_bracket_swaps(\"((()())\") == 1\n    assert min_bracket_swaps(\"(()\") == 1",
    "class Stack:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n\n\ndef minSwaps(string):\n    openBrackets = Stack()\n    swaps = 0\n\n    for char in string:\n        if char == \"(\":\n            openBrackets.push(char)\n        else:\n            if openBrackets.isEmpty():\n                swaps += 1\n            else:\n                openBrackets.pop()\n\n    return swaps + openBrackets.size()\n\n\nif __name__ == \"__main__\":\n    print(minSwaps(\"(()()\"))\n    print(minSwaps(\")()())\"))",
    "from collections import deque\n\n\ndef min_bracket_swaps(s):\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"(())\") == 0\n    assert min_bracket_swaps(\"()\") == 0\n    assert min_bracket_swaps(\"()()\") == 0\n    assert min_bracket_swaps(\"(()\") == 1\n    assert min_bracket_swaps(\")(\") == 1\n    assert min_bracket_swaps(\"(((((((((\") == 8\n    assert min_bracket_swaps(\"))))))))\")) == 0\n    assert min_bracket_swaps(\"())\") == 1\n    assert min_bracket_swaps(\")))((((\") == 3\n    assert min_bracket_swaps(\"((())\") == 1",
    "from collections import deque\n\n\ndef bracket_balancing(string):\n    stack = deque()\n    for i in range(len(string)):\n        if string[i] == '(':\n            stack.append(i)\n        elif string[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(i)\n    if stack:\n        return -1\n    else:\n        return 0\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        {\"input\": \"((()))\", \"output\": 0},\n        {\"input\": \"(((())\", \"output\": 1},\n        {\"input\": \"((())\", \"output\": 0},\n        {\"input\": \"((())\", \"output\": 0},\n        {\"input\": \"((())\", \"output\": 0},\n        {\"input\": \"((())\", \"output\": 0},\n        {\"input\": \"((())\", \"output\": 0},\n        {\"input\": \"((())\", \"output\": 0},\n    ]\n    for test_case in test_cases:\n        result = bracket_balancing(test_case[\"input\"])\n        assert result == test_case[\"output\"], test_case[\"input\"]",
    "from collections import deque\n\n\ndef minimum_swaps(input_string):\n    if not input_string:\n        return 0\n\n    open_brackets = deque()\n    close_brackets = deque()\n\n    for i in input_string:\n        if i == \"(\":\n            open_brackets.append(i)\n        elif i == \")\":\n            close_brackets.append(i)\n        else:\n            open_brackets.pop()\n            close_brackets.pop()\n\n    return len(open_brackets) + len(close_brackets)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        {\"input\": \"(()()\", \"expected\": 1},\n        {\"input\": \"()()\", \"expected\": 0},\n        {\"input\": \"())()\", \"expected\": 1},\n        {\"input\": \"())()\", \"expected\": 1},\n        {\"input\": \"((((\", \"expected\": 3},\n        {\"input\": \"))))\", \"expected\": 4},\n        {\"input\": \"((())\", \"expected\": 2},\n        {\"input\": \"((()\", \"expected\": 1},\n        {\"input\": \"())\", \"expected\": 1},\n        {\"input\": \"()(()\", \"expected\": 1},\n        {\"input\": \"))(())\", \"expected\": 2},\n        {\"input\": \")()())\", \"expected\": 2},\n        {\"input\": \"(()\", \"expected\": 1},\n    ]\n\n    for test_case in test_cases:\n        result = minimum_swaps(test_case[\"input\"])\n        assert result == test_case[\"expected\"], test_case",
    "def get_swap_count(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            stack.pop()\n\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    print(get_swap_count(\"((())\"))\n    print(get_swap_count(\"()\"))\n    print(get_swap_count(\"((()()))\"))\n    print(get_swap_count(\"(()))(\"))",
    "def min_bracket_swaps(string):\n    stack = []\n    for i in range(len(string)):\n        if string[i] == \"(\":\n            stack.append(i)\n        elif string[i] == \")\":\n            if stack == []:\n                stack.append(i)\n            elif string[stack[-1]] == \")\":\n                stack.append(i)\n            else:\n                stack.pop()\n    swaps = 0\n    while stack:\n        swaps += 1\n        stack.pop()\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_swaps(\"(())()\"))\n    print(min_bracket_swaps(\"(()))(\"))\n    print(min_bracket_swaps(\")(\"))\n    print(min_bracket_swaps(\"(\"))\n    print(min_bracket_swaps(\"()\"))",
    "from typing import List\n\n\ndef find_min_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if not string:\n        return 0\n\n    if len(string) % 2 != 0:\n        return -1\n\n    pairs: List[int] = []\n\n    for i in range(len(string)):\n        if string[i] == \"(\":\n            pairs.append(i)\n        elif string[i] == \")\":\n            if pairs:\n                pairs.pop()\n            else:\n                pairs.append(i)\n\n    if not pairs:\n        return 0\n\n    swaps: int = 0\n\n    for i in range(len(pairs) // 2):\n        temp: int = pairs[i]\n        pairs[i] = pairs[len(pairs) - 1 - i]\n        pairs[len(pairs) - 1 - i] = temp\n        swaps += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert find_min_swaps(\"(())\") == 0\n    assert find_min_swaps(\"(()))(\") == 1\n    assert find_min_swaps(\"((()))\") == 0\n    assert find_min_swaps(\")(\") == -1",
    "from collections import Counter\n\n\ndef min_swaps_for_bracket_balancing(string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    swaps = 0\n    counter = Counter(string)\n    left_count = counter[\"(\"]\n    right_count = counter[\")\"]\n\n    while left_count > right_count:\n        swaps += left_count - right_count\n        counter[\"(\"] -= left_count - right_count\n        counter[\")\"] = 0\n        left_count = counter[\"(\"]\n        right_count = counter[\")\"]\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (1, \"((()))\"),\n        (2, \"(()))(\"),\n        (0, \"((((()))))\"),\n        (2, \"((((((()))))))\"),\n        (0, \"\"),\n        (0, \"()\"),\n    ]\n\n    for expected_output, test_input in test_cases:\n        output = min_swaps_for_bracket_balancing(test_input)\n        assert output == expected_output, (output, expected_output)",
    "def min_bracket_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    stack = []\n    min_swaps = 0\n\n    for char in string:\n        if char in [\"(\", \"[\", \"{\"]:\n            stack.append(char)\n\n        elif char in [\")\", \"]\", \"}\"]:\n            if not stack or stack[-1] not in [\"(\", \"[\", \"{\"]:\n                min_swaps += 1\n            else:\n                stack.pop()\n\n    return min_swaps\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"([])[]({})\") == 0\n    assert min_bracket_swaps(\"{[)])\") == 3\n    assert min_bracket_swaps(\"{{[[(())]]}}\") == 0\n    assert min_bracket_swaps(\"{[}\") == 5",
    "from collections import deque\n\n\ndef min_swaps(arr: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    :param arr: string of brackets\n    :return: minimum number of swaps\n    \"\"\"\n    stack = deque()\n    for char in arr:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            stack.pop()\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"((()\") == 2\n    assert min_swaps(\"(()\") == 0",
    "def min_bracket_balancing(input_str):\n    stack = []\n    for i in input_str:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(i)\n    return len(stack)\n\n\ndef main():\n    print(\"Minimum no of swaps: \" +\n          str(min_bracket_balancing(\"((((((((\")))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from collections import Counter\n\n\ndef minimum_swaps(brackets: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = Counter(brackets)\n\n    open_brackets = count[\"(\"]\n    close_brackets = count[\")\"]\n\n    swaps = 0\n    if open_brackets > close_brackets:\n        swaps = open_brackets - close_brackets\n    elif close_brackets > open_brackets:\n        swaps = close_brackets - open_brackets\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(minimum_swaps(\"((((((\"))",
    "def minimum_bracket_swaps(brackets):\n    \"\"\"\n    Find the minimum number of swaps required to make a given string of brackets\n    balanced.\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        else:\n            if len(stack) == 0:\n                swaps += 1\n            else:\n                stack.pop()\n\n    swaps += len(stack)\n    return swaps\n\n\ndef test_minimum_bracket_swaps():\n    \"\"\"\n    >>> test_minimum_bracket_swaps()\n    \"\"\"\n    assert minimum_bracket_swaps(\"((()\") == 3\n    assert minimum_bracket_swaps(\"((())\") == 2\n    assert minimum_bracket_swaps(\"((()))\") == 0\n    assert minimum_bracket_swaps(\"(()())\") == 1\n    assert minimum_bracket_swaps(\"((())(()())(()(()))\") == 1\n\nif __name__ == \"__main__\":\n    test_minimum_bracket_swaps()",
    "def min_swaps(str1):\n    stack = []\n    swaps = 0\n    for i in str1:\n        if i == '(':\n            stack.append(i)\n        else:\n            if stack == []:\n                swaps += 1\n            else:\n                stack.pop()\n    return swaps\n\n\ndef main():\n    str1 = input()\n    print(min_swaps(str1))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from collections import deque\n\n\ndef bracket_balancing(input_str):\n    stack = deque()\n    for char in input_str:\n        if char in [\"(\", \"[\", \"{\"]:\n            stack.append(char)\n        else:\n            if not stack:\n                return -1\n            if char == \")\":\n                last = stack.pop()\n                if last != \"(\":\n                    return -1\n            elif char == \"]\":\n                last = stack.pop()\n                if last != \"[\":\n                    return -1\n            else:\n                last = stack.pop()\n                if last != \"{\":\n                    return -1\n\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"()()[]{}(())\", 0),\n        (\"{[()]}\", 0),\n        (\"([)]\", -1),\n        (\"{[]}\", 0),\n        (\"{(})\", 1),\n    ]\n    for test_string, expected_output in test_cases:\n        assert expected_output == bracket_balancing(test_string)",
    "from collections import Counter\n\n\ndef minimum_swaps(arr):\n    swaps = 0\n    freq = Counter(arr)\n\n    i = 0\n    while i < len(arr):\n        if arr[i] != i + 1:\n            arr[i], arr[arr[i] - 1] = arr[arr[i] - 1], arr[i]\n            swaps += 1\n            i -= 1\n        i += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        {\"input\": [\"{}[]{}\", \"{}\", \"{[]}\"], \"output\": 1},\n        {\"input\": [\"{[}]}\"], \"output\": -1},\n        {\"input\": [\"{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}\"], \"output\": 24},\n        {\"input\": [\"{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]{}[]",
    "from typing import List\n\n\ndef min_bracket_swaps(brackets: str) -> int:\n    \"\"\"\n    Bracket swaps are only allowed for matching brackets.\n    If not, then the input string is invalid.\n\n    If the string is valid, then the number of swaps is the number of opening brackets minus\n    the number of closing brackets.\n    \"\"\"\n    opening_brackets = brackets.count(\"(\")\n    closing_brackets = brackets.count(\")\")\n\n    return abs(opening_brackets - closing_brackets)\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"(())\") == 0\n    assert min_bracket_swaps(\"(()\") == 1\n    assert min_bracket_swaps(\"())\") == 1\n    assert min_bracket_swaps(\"((()\") == 2\n    assert min_bracket_swaps(\"())(\") == 2\n    assert min_bracket_swaps(\"((())\") == 0\n    assert min_bracket_swaps(\"(()))\") == 1\n    assert min_bracket_swaps(\"((())(()))(()))(()((())\") == 4",
    "def min_bracket_swaps(brackets: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    stack = []\n    swaps = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                swaps += 1\n            else:\n                stack.pop()\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_swaps(\"(())\"))\n    print(min_bracket_swaps(\"()\"))\n    print(min_bracket_swaps(\"())\"))\n    print(min_bracket_swaps(\"((()\"))\n    print(min_bracket_swaps(\"(()\"))\n    print(min_bracket_swaps(\"((()))\"))",
    "def find_min_swaps(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                swaps += 1\n            else:\n                stack.pop()\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert find_min_swaps(\"(()((()())())())(\") == 1",
    "from collections import deque\n\n\ndef min_swaps(strs: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    stack: deque = deque()\n    swaps = 0\n\n    for char in strs:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            if not stack or stack[-1] == \")\":\n                swaps += 1\n                stack.append(char)\n            else:\n                stack.pop()\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"(((\") == 2\n    assert min_swaps(\")(\") == 1\n    assert min_swaps(\"))(\") == 1\n    assert min_swaps(\"(()\") == 2\n    assert min_swaps(\"())\") == 2\n    assert min_swaps(\"(((\") == 2\n    assert min_swaps(\"()())\") == 1\n    assert min_swaps(\"())())\") == 2\n    assert min_swaps(\"(()())\") == 1\n    assert min_swaps(\"((((((\") == 2",
    "class Solution:\n    def findMinSwaps(self, s: str) -> int:\n        stack = []\n        swaps = 0\n        for i in s:\n            if i == '(':\n                stack.append(i)\n            else:\n                if stack and stack[-1] == ')':\n                    stack.pop()\n                else:\n                    stack.append(i)\n                    swaps += 1\n        return swaps\n\n\nif __name__ == \"__main__\":\n    s = \"(((\"\n    out = 3\n    res = Solution().findMinSwaps(s)\n    assert res == out, (res, out)\n\n    s = \"()())\"\n    out = 1\n    res = Solution().findMinSwaps(s)\n    assert res == out, (res, out)\n\n    s = \"(())\"\n    out = 0\n    res = Solution().findMinSwaps(s)\n    assert res == out, (res, out)",
    "def min_swaps(s: str) -> int:\n    \"\"\"\n    Since the given string is already balanced, we need to find out\n    the minimum swaps to make it unbalanced.\n    So, we will use a stack and push the opening brackets in it.\n    We will pop the opening bracket whenever we encounter a closing bracket.\n    If the stack is empty, then there are no swaps needed.\n    Otherwise, we will pop the opening bracket.\n    If the next element in the string is a closing bracket,\n    then no swaps needed.\n    Otherwise, we will add the popped opening bracket to the string.\n    This will ensure that we are swapping the opening bracket with the next element.\n    \"\"\"\n    opening_brackets = \"({[\"\n    closing_brackets = \")}]\"\n    stack = []\n    swaps = 0\n\n    for char in s:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                swaps += 1\n            else:\n                if stack[-1] == opening_brackets[closing_brackets.index(char)]:\n                    stack.pop()\n                else:\n                    stack.append(stack.pop())\n                    swaps += 1\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"({[]})\") == 1",
    "def minimum_bracket_swaps(string):\n    \"\"\"\n    :param string: string of braces\n    :return: minimum number of swaps\n    \"\"\"\n    stack = []\n    for char in string:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack or char[0] != stack.pop()[0]:\n                return -1\n    return len(stack)\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('[](){()}', 0),\n        ('({[(((([])))))]}', 0),\n        ('{[({})]}' , 0),\n        ('{[({})]', -1),\n        ('{[({})', -1),\n    ]\n\n    for string, expected_result in test_cases:\n        assert minimum_bracket_swaps(string) == expected_result, string",
    "def min_swaps(s):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            count = 0\n    return count\n\n\nif __name__ == \"__main__\":\n    s = \"(((({}[][)(()]){})([])[])]\"\n    assert min_swaps(s) == 1",
    "from collections import deque\n\n\ndef min_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    stack = deque()\n    swaps = 0\n\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack and stack[-1] == \")\":\n                stack.pop()\n                swaps += 1\n            else:\n                stack.append(char)\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"(((((((((((((((((()))))))))))))))))))\") == 10\n    assert min_swaps(\"((((((()))))))\") == 1",
    "def min_bracket_balancing(input_str):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for char in input_str:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                swaps += 1\n            else:\n                stack.pop()\n\n    return swaps + len(stack)\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_balancing(\"((()\"))\n    print(min_bracket_balancing(\"(()))\"))\n    print(min_bracket_balancing(\"()((((()))))\"))",
    "from collections import deque\n\n\ndef min_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    left_brackets = deque()\n    right_brackets = deque()\n    for char in string:\n        if char == \"(\":\n            left_brackets.append(char)\n        else:\n            right_brackets.append(char)\n\n    swaps = 0\n    while left_brackets and right_brackets:\n        left_bracket = left_brackets.popleft()\n        right_bracket = right_brackets.pop()\n        if left_bracket == \")\":\n            swaps += 1\n        else:\n            left_brackets.append(left_bracket)\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"()[]{}\") == 0\n    assert min_swaps(\"{[]}()\") == 1\n    assert min_swaps(\"{[][{})\") == 3",
    "def minimum_swaps(brackets: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for b in brackets:\n        if b == \"(\":\n            stack.append(b)\n        elif not stack or stack[-1] == \")\":\n            swaps += 1\n            stack.append(b)\n        else:\n            stack.pop()\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert minimum_swaps(\"(()()\") == 1\n    assert minimum_swaps(\")())(\") == 3",
    "def min_bracket_swaps(s):\n    \"\"\"\n    Use stack to count balanced brackets.\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    swaps += len(stack)\n\n    return swaps\n\n\ndef test_min_bracket_swaps():\n    \"\"\"Test for min_bracket_swaps function.\"\"\"\n    assert min_bracket_swaps('(())') == 0\n    assert min_bracket_swaps('(()') == 1\n    assert min_bracket_swaps('())') == 1\n    assert min_bracket_swaps('()(()(') == 2\n    assert min_bracket_swaps('()(()(') == 2\n    assert min_bracket_swaps('()(()())') == 0\n    assert min_bracket_swaps('((()))') == 0\n    assert min_bracket_swaps('((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "from collections import deque\n\n\ndef find_minimum_swaps(input_str):\n    stack = deque()\n    swaps = 0\n\n    for ch in input_str:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(ch)\n                swaps += 1\n    return swaps\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('(()))', 1),\n        ('(()', 1),\n        ('(()))((()()', 2),\n        ('((((', 3),\n        (')))))', 3),\n        ('()', 0),\n        ('((((()()()))))', 0),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),\n        ('((((()()())))', 1),",
    "def min_bracket_swaps(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n\n    swaps = 0\n    while stack:\n        swaps += 1\n        stack.pop()\n    return swaps\n\n\ndef main():\n    t = int(input())\n    while t:\n        t -= 1\n        s = input()\n        ans = min_bracket_swaps(s)\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()",
    "def minimum_bracket_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    stack: list = []\n    swaps: int = 0\n    for bracket in string:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                swaps += 1\n            else:\n                stack.pop()\n\n    if stack:\n        swaps += len(stack)\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert minimum_bracket_swaps(\"((((()))))\") == 0\n    assert minimum_bracket_swaps(\"((((()))))(\") == 1\n    assert minimum_bracket_swaps(\"(()())(()())\") == 1\n    assert minimum_bracket_swaps(\"(((((((())\") == 1\n    assert minimum_bracket_swaps(\"()())(()())\") == 2\n    assert minimum_bracket_swaps(\"()((())()\") == 1\n    assert minimum_bracket_swaps(\"()((())())))\") == 2\n    assert minimum_bracket_swaps(\"(()()(((((((()\") == 1\n    assert minimum_bracket_swaps(\"(()()((((((((()()\") == 2",
    "from collections import deque\n\n\ndef min_bracket_balancing(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not s:\n        return 0\n\n    stack = deque()\n    swaps = 0\n\n    for i in s:\n        if i == \"(\":\n            stack.append(i)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    if stack:\n        swaps += len(stack)\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_balancing(\"(())\"))\n    print(min_bracket_balancing(\"()()\"))\n    print(min_bracket_balancing(\"((()\"))\n    print(min_bracket_balancing(\"(()))\"))\n    print(min_bracket_balancing(\"()()\"))",
    "def bracket_balancing(string):\n    \"\"\"\n    >>> bracket_balancing('(())()')\n    1\n    >>> bracket_balancing('((())(())())')\n    1\n    >>> bracket_balancing('((())(())()()()()()()()())')\n    1\n    >>> bracket_balancing('(()())')\n    0\n    >>> bracket_balancing('()(())()')\n    2\n    >>> bracket_balancing('((()(()))())')\n    2\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(-1)\n    return sum(stack)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def min_bracket_swaps(input_str):\n    stack = []\n    for i in range(len(input_str)):\n        if input_str[i] == '(':\n            stack.append(i)\n        elif input_str[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(i)\n    return len(stack)\n\n\nprint(min_bracket_swaps('(((((())((()()))())))'))",
    "def minimum_bracket_swaps(string):\n    stack = []\n    swaps = 0\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"()\", 0),\n        (\"((()))\", 0),\n        (\"(())\", 0),\n        (\"((()())\", 1),\n        (\"((()())\", 1),\n        (\"((())\", 1),\n        (\"((())()\", 2),\n        (\"((())(()\", 3),\n        (\"((())(()()\", 3),\n        (\"((())(()()()\", 3),\n        (\"((())(()()())\", 3),\n        (\"((())(()()())((((((()))))))\", 3),\n    ]\n\n    for string, expected in test_cases:\n        assert minimum_bracket_swaps(string) == expected",
    "from collections import Counter\n\n\ndef min_bracket_swaps(input_str: str) -> int:\n    \"\"\"\n    O(n) & O(1)\n    \"\"\"\n    if not input_str:\n        return 0\n\n    open_brackets = 0\n    count_swaps = 0\n\n    for char in input_str:\n        if char == \"(\":\n            open_brackets += 1\n        elif char == \")\":\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                count_swaps += 1\n    return count_swaps\n\n\ndef min_bracket_swaps_using_counter(input_str: str) -> int:\n    \"\"\"\n    O(n) & O(n)\n    \"\"\"\n    if not input_str:\n        return 0\n\n    counter = Counter()\n    count_swaps = 0\n\n    for char in input_str:\n        if char == \"(\":\n            counter[\"(\"] += 1\n        elif char == \")\":\n            if counter[\")\"] > 0:\n                counter[\")\"] -= 1\n            else:\n                count_swaps += 1\n    return count_swaps\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"(()()\") == 1\n    assert min_bracket_swaps(\")()(\") == 2\n    assert min_bracket_swaps(\"()()()()\") == 0\n    assert min_bracket_swaps(\"()())()\") == 2\n    assert min_bracket_swaps_using_counter(\"(()()\") == 1\n    assert min_bracket_swaps_using_counter(\")()(\") == 2\n    assert min_bracket_swaps_using_counter(\"()()()()\") == 0\n    assert min_bracket_swaps_using_counter(\"()())()\") == 2",
    "def min_bracket_balancing(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(bracket)\n    return len(stack)\n\n\nprint(min_bracket_balancing(\"(())()\"))\nprint(min_bracket_balancing(\"(()))(\"))\nprint(min_bracket_balancing(\")()(\"))\nprint(min_bracket_balancing(\"((((()))))\"))",
    "from collections import deque\n\n\ndef min_swaps(expression: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    length = len(expression)\n    swaps = 0\n\n    for i in range(length):\n        if expression[i] == \")\":\n            continue\n        if expression[i] == \"(\":\n            swaps += 1\n        else:\n            swaps -= 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"()[]{}\") == 0\n    assert min_swaps(\"(]\") == 1\n    assert min_swaps(\"([)]\") == 2\n    assert min_swaps(\"{[]}\") == 0\n    assert min_swaps(\"[]({})\") == 2",
    "from collections import deque\n\n\ndef find_bracket_balance(s):\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(char)\n\n    return len(stack)\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('(())', 0),\n        ('()()()', 0),\n        ('(())()', 0),\n        ('()()(()', 1),\n        ('((((', 3),\n        ('((()', 1),\n    ]\n\n    for t in test_cases:\n        assert find_bracket_balance(t[0]) == t[1]",
    "from collections import deque\n\n\ndef minimum_swaps(arr):\n    arr = deque(arr)\n    swaps = 0\n    for i in range(len(arr)):\n        if arr[i] == '(':\n            continue\n        while arr[i] != '(':\n            arr.appendleft(arr.popleft())\n            swaps += 1\n    return swaps\n\n\nif __name__ == '__main__':\n    arr = '()())()('\n    print(minimum_swaps(arr))",
    "def min_bracket_balancing(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    if stack:\n        swaps += len(stack)\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_balancing(\"(())\") == 0\n    assert min_bracket_balancing(\"(()\") == 1\n    assert min_bracket_balancing(\"())\") == 1\n    assert min_bracket_balancing(\"())()(\") == 2\n    assert min_bracket_balancing(\"(()))())\") == 3",
    "def min_swaps(arr):\n    open_bracket = 0\n    swaps = 0\n    for i in range(len(arr)):\n        if arr[i] == \"(\":\n            open_bracket += 1\n        elif arr[i] == \")\":\n            open_bracket -= 1\n        if open_bracket < 0:\n            open_bracket += 1\n            swaps += 1\n    return swaps\n\n\nif __name__ == \"__main__\":\n    arr = input(\"Enter the string: \")\n    print(min_swaps(arr))",
    "def min_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    swaps: int = 0\n    stack: list = []\n\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    return swaps + len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"(())\") == 0\n    assert min_swaps(\"()()()\") == 0\n    assert min_swaps(\"((()()\") == 1\n    assert min_swaps(\"((())\") == 1\n    assert min_swaps(\"((()))\") == 0\n    assert min_swaps(\"((())))\") == 1",
    "from collections import Counter\n\n\ndef min_swaps(str_input):\n    open_brackets = Counter(str_input)[\"(\"]\n    close_brackets = Counter(str_input)[\")\"]\n    swaps = open_brackets - close_brackets\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"())\") == 1\n    assert min_swaps(\"(((\") == 3\n    assert min_swaps(\")()())\") == 1",
    "def min_bracket_balancing(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    stack = []\n    count = 0\n    for i in s:\n        if i == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                count += 1\n            else:\n                stack.pop()\n    return count\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_balancing(\"(())\") == 0\n    assert min_bracket_balancing(\"(()())\") == 0\n    assert min_bracket_balancing(\"((())\") == 1\n    assert min_bracket_balancing(\"())(\") == 2",
    "def min_bracket_swaps(s):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = []\n    swaps = 0\n    for i, char in enumerate(s):\n        if char == \"(\":\n            stack.append(i)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    swaps += len(stack)\n    return swaps\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()\", 0),\n        (\"()\", 0),\n        (\"(()\", 1),\n        (\"())\", 1),\n        (\"((\", 2),\n        (\")(\", 2),\n        (\"(()))\", 1),\n        (\"((())\", 1),\n        (\"((((\", 3),\n        (\"(((())\", 2),\n        (\"(((()))\", 1),\n        (\"(((()))()\", 1),\n        (\"((((((\", 4),\n        (\"(((((((\", 5),\n        (\")))\", 2),\n        (\")()()()()()()()()()()()()()()\", 0),\n        (\")()()()()()()()()()()()()()()\", 0),\n        (\"()()()()()()()()()()()()()()()\", 0),\n        (\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "def min_bracket_balancing(string: str) -> int:\n    \"\"\"\n    We will use the stack to keep track of opening brackets.\n    Whenever we encounter a closing bracket, we will pop the opening bracket from the stack.\n    If the stack is empty, we will push the closing bracket to the stack.\n    If the stack is not empty, we will check if the opening bracket is the expected bracket.\n    If the opening bracket is not the expected bracket, we will swap the opening bracket and the closing bracket.\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for bracket in string:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if stack:\n                stack.pop()\n            else:\n                stack.append(bracket)\n        else:\n            raise ValueError(\"Invalid character encountered.\")\n\n    return swaps",
    "from collections import deque\n\n\ndef get_minimum_swaps(brackets: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    stack = deque()\n    swaps = 0\n\n    for bracket in brackets:\n        if bracket in \"({[\":\n            stack.append(bracket)\n        elif not stack or bracket == \")}\"[stack.pop()]:\n            swaps += 1\n        elif bracket == \")}\"[stack[-1]]:\n            stack.pop()\n        else:\n            stack.append(bracket)\n\n    return swaps + len(stack)\n\n\nif __name__ == \"__main__\":\n    assert get_minimum_swaps(\"({[]})\") == 1\n    assert get_minimum_swaps(\"({})\") == 0\n    assert get_minimum_swaps(\"([{}])\") == 0\n    assert get_minimum_swaps(\"([{])\") == 1",
    "from collections import Counter\n\n\ndef minimum_swaps(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    swaps = 0\n    i = 0\n\n    while i < len(arr):\n        if arr[i] == \"(\":\n            i += 1\n        else:\n            if arr[i] == \")\":\n                if i - 1 < 0:\n                    swaps += 1\n                    i += 1\n                elif arr[i - 1] == \")\":\n                    swaps += 1\n                    i += 1\n                else:\n                    i += 1\n            else:\n                i += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(minimum_swaps(\"((()())))\"))",
    "from typing import List\n\n\ndef find_min_bracket_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    opening_brackets = []\n    closing_brackets = []\n    min_swaps = 0\n\n    for i in range(len(string)):\n        if string[i] == \"(\":\n            opening_brackets.append(i)\n        elif string[i] == \")\":\n            closing_brackets.append(i)\n        else:\n            continue\n\n    if len(opening_brackets) != len(closing_brackets):\n        return -1\n\n    while len(opening_brackets) != 0:\n        index = opening_brackets.pop()\n        last_index = closing_brackets.pop()\n\n        if index > last_index:\n            min_swaps += index - last_index\n        else:\n            min_swaps += last_index - index\n\n    return min_swaps\n\n\nif __name__ == \"__main__\":\n    assert find_min_bracket_swaps(\"()[]{}\") == 0\n    assert find_min_bracket_swaps(\"(]\") == -1\n    assert find_min_bracket_swaps(\"([)]\") == -1",
    "def min_bracket_swaps(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    count = 0\n    stack = []\n\n    for c in s:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if not stack:\n                count += 1\n            else:\n                stack.pop()\n\n    return count + len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swaps(\"((((((\") == 3\n    assert min_bracket_swaps(\")(\") == 1\n    assert min_bracket_swaps(\"()\") == 0\n    assert min_bracket_swaps(\"()())\") == 0",
    "from collections import deque\n\n\ndef min_bracket_swaps(string):\n    \"\"\"\n    >>> min_bracket_swaps('[[[][]][][][][][][][][][][][][][][][]]')\n    0\n    >>> min_bracket_swaps('[[[][]][][][][][][][][][][][][][][][]]()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()",
    "def bracket_balancing(s):\n    stack = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append('(')\n        elif s[i] == ')':\n            if len(stack) == 0:\n                return -1\n            stack.pop()\n\n    return len(stack)\n\n\ndef main():\n    test_cases = [\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),\n        (\"((()()\", -1),\n        (\"(())\", 0),\n        (\"((()))\", 0),\n        (\"()()()\", 0),\n        (\"(()))\", -1),",
    "from collections import Counter\n\n\ndef min_bracket_balancing(input_str):\n    stack = []\n    swaps = 0\n    for i in input_str:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if not stack:\n                swaps += 1\n            else:\n                stack.pop()\n    return swaps + len(stack)\n\n\ndef min_bracket_balancing_using_counter(input_str):\n    counter = Counter(input_str)\n    return counter['('] - counter[')']\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('(())', 0),\n        ('(()))', 1),\n        ('((()))', 0),\n        ('()(()))', 1),\n        ('()((()))', 2),\n        ('(()()(()))', 1),\n        ('((((()))))', 0),\n        ('((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "from typing import List\n\n\ndef min_swaps(brackets: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack: List[str] = []\n\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(\"(\")\n        elif bracket == \")\":\n            if not stack:\n                stack.append(\")\")\n            elif stack[-1] == \")\":\n                stack.pop()\n\n    swaps: int = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            swaps += 1\n        elif bracket == \")\":\n            swaps -= 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"()\") == 0\n    assert min_swaps(\"(())\") == 0\n    assert min_swaps(\"()()()\") == 0\n    assert min_swaps(\"(()())\") == 0\n    assert min_swaps(\")()(\") == 3\n    assert min_swaps(\"(()))(\") == 1",
    "from collections import defaultdict\n\n\ndef min_bracket_swaps(s):\n    stack = []\n    swaps = 0\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps\n\n\ndef min_bracket_swaps_2(s):\n    stack = defaultdict(int)\n    swaps = 0\n    for c in s:\n        if c == '(':\n            stack[c] += 1\n        else:\n            if stack['(']:\n                stack[c] += 1\n            else:\n                swaps += 1\n    return swaps\n\n\ndef main():\n    assert min_bracket_swaps('(()') == 1\n    assert min_bracket_swaps('(()))') == 1\n    assert min_bracket_swaps(')()(') == 2\n    assert min_bracket_swaps(')()(()') == 2\n    assert min_bracket_swaps('))((') == 2\n    assert min_bracket_swaps(')(((') == 2\n    assert min_bracket_swaps('((())') == 2\n    assert min_bracket_swaps(')((())') == 2\n    assert min_bracket_swaps('()((())') == 1\n    assert min_bracket_swaps('(())()') == 1\n    assert min_bracket_swaps('(())((())') == 1\n    assert min_bracket_swaps('((())()') == 1\n    assert min_bracket_swaps('((((((()))))))') == 0\n\n\nif __name__ == '__main__':\n    main()",
    "def min_swaps(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            count += 1\n    return count // 2\n\n\nif __name__ == \"__main__\":\n    print(min_swaps(\"(((((())())))\"))\n    print(min_swaps(\"((((((()))))))\"))",
    "def minimum_swaps(arr):\n    swaps = 0\n    for i in range(len(arr)):\n        if arr[i] == i + 1:\n            continue\n        swaps += 1\n        arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    return swaps\n\n\ndef minimum_swaps_eff(arr):\n    swaps = 0\n    pos = [i for i in range(len(arr))]\n    for i in range(len(arr)):\n        if pos[i] == i + 1:\n            continue\n        pos[arr[i] - 1], pos[i] = pos[i], pos[arr[i] - 1]\n        swaps += 1\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert minimum_swaps_eff([1, 2, 3, 4]) == 1\n    assert minimum_swaps_eff([3, 1, 2, 4]) == 2",
    "def min_bracket_swaps(string):\n    stack = []\n    for i in string:\n        if i == \"(\":\n            stack.append(i)\n        elif i == \")\":\n            if len(stack) == 0:\n                return -1\n            stack.pop()\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"(())\", 0),\n        (\"(()))\", -1),\n        (\"((((\", 2),\n        (\"((())\", 1),\n        (\"((())()\", 1),\n        (\"(((()))\", 1),\n        (\"((((())))\", 2),\n        (\"((((((()))))))\", 3),\n        (\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "from collections import deque\n\n\ndef min_bracket_balancing(string):\n    \"\"\"\n    :param: string - input string\n    Return the minimum no of swaps required to balance the brackets in the string\n    \"\"\"\n    # Base case\n    if len(string) % 2 != 0:\n        return -1\n\n    # Initialize an empty stack and for loop to iterate over string\n    stack = deque()\n    for i in range(len(string)):\n        # If the character is an opening bracket, append it to stack\n        if string[i] == '(':\n            stack.append(string[i])\n        # If the character is a closing bracket, pop from stack\n        elif string[i] == ')':\n            if len(stack) != 0:\n                stack.pop()\n            else:\n                stack.append(string[i])\n        # If the stack is empty, append the character to stack\n        else:\n            stack.append(string[i])\n\n    return len(stack) // 2\n\n\ndef test_function(test_case):\n    string = test_case[0]\n    solution = test_case[1]\n    output = min_bracket_balancing(string)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\nstring = '(()))'\nsolution = 1\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = '())'\nsolution = -1\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = '(((((('\nsolution = 6\ntest_case = [string, solution]\ntest_function(test_case)\n\nstring = ')))))))'\nsolution = 1\ntest_case = [string, solution]\ntest_function(test_case)",
    "def min_swaps(str_):\n    stack = []\n    swaps = 0\n    for char in str_:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps\n\n\ndef main():\n    str_ = input(\"Enter string: \")\n    print(min_swaps(str_))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def min_bracket_balancing(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_balancing(\"(()(((((()))))))\") == 1\n    assert min_bracket_balancing(\"((())())\") == 0\n    assert min_bracket_balancing(\"())\") == 1\n    assert min_bracket_balancing(\"((())\") == 1\n    assert min_bracket_balancing(\"((())(\") == 2",
    "def min_swap(arr):\n    n = len(arr)\n    swaps = 0\n\n    for i in range(n):\n        if arr[i] == '(':\n            continue\n\n        if arr[i] == ')':\n            if i % 2 == 0:\n                if arr[i-1] == ')':\n                    swaps += 1\n                    arr[i-1] = ')'\n                else:\n                    arr[i-1] = ')'\n            else:\n                if arr[i-1] == '(':\n                    swaps += 1\n                    arr[i-1] = '('\n                else:\n                    arr[i-1] = '('\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    arr = input(\"Enter the string: \")\n    print(\"Minimum swaps: \", min_swap(arr))",
    "def min_bracket_swap(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    opening = 0\n    closing = 0\n    result = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            opening += 1\n        else:\n            closing += 1\n        if opening == closing:\n            result += max(opening, closing)\n            opening = 0\n            closing = 0\n\n    result += max(opening, closing)\n    return result\n\n\nif __name__ == \"__main__\":\n    s = \"(((((())\"\n    print(min_bracket_swap(s))",
    "from collections import deque\n\n\ndef bracket_balancing(input_str):\n    stack = deque()\n    for char in input_str:\n        if char in \"({[\" and char not in stack:\n            stack.append(char)\n        elif char == \")\":\n            if stack[-1] == \"(\":\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == \"]\":\n            if stack[-1] == \"[\":\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == \"}\":\n            if stack[-1] == \"{\":\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"{([])}\", 0),\n        (\"{[()()]}\", 0),\n        (\"{{[(())]]}\", 0),\n        (\"{(())}\", 2),\n        (\"{(([])})\", 2),\n        (\"{(([])({})})}\", 4),\n        (\"{[(])}\", 1),\n    ]\n    for test_string, expected_result in test_cases:\n        assert bracket_balancing(test_string) == expected_result",
    "def find_min_swaps(str1):\n    stack = []\n    mapping = {}\n    for i in range(len(str1)):\n        if str1[i] == \"(\":\n            stack.append(i)\n        elif str1[i] == \")\":\n            if len(stack) == 0:\n                mapping[i] = -1\n            else:\n                mapping[i] = stack.pop()\n\n    swap_count = 0\n    for key, value in mapping.items():\n        if value != -1 and key != value:\n            swap_count += 1\n\n    return swap_count\n\n\nif __name__ == \"__main__\":\n    print(find_min_swaps(\"((((\"))\n    print(find_min_swaps(\"((())\"))\n    print(find_min_swaps(\"((()))\"))\n    print(find_min_swaps(\"(((())\"))",
    "def find_min_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    stack = []\n    swaps = 0\n\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert find_min_swaps(\"((()))\") == 0\n    assert find_min_swaps(\"(()())\") == 1\n    assert find_min_swaps(\"((()())())\") == 1",
    "from collections import defaultdict\n\n\ndef min_bracket_swaps(expression):\n    \"\"\"\n    :param expression: input string\n    :return: min no of swaps required for bracket balancing\n    \"\"\"\n    swaps = 0\n    open_brackets = 0\n    stack = defaultdict(int)\n    for i, char in enumerate(expression):\n        if char == \"(\":\n            open_brackets += 1\n            stack[i] = open_brackets\n        elif char == \")\":\n            open_brackets -= 1\n            stack[i] = open_brackets\n            if stack[i] < 0:\n                swaps += 1\n                stack[i] = 0\n    return swaps\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_swaps(\"(())(())\"))",
    "def minSwaps(string):\n    \"\"\"\n    >>> minSwaps(\"[[][]][]\")\n    1\n    >>> minSwaps(\"[[[][]][]]\")\n    0\n    \"\"\"\n    stack = []\n    swaps = 0\n    for char in string:\n        if char == \"[\" and stack[-1:] == [\"[\"]:\n            stack.pop()\n            swaps += 1\n        else:\n            stack.append(char)\n    return swaps\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from collections import deque\n\n\ndef min_bracket_balancing(str_input):\n    stack = deque()\n    for index, val in enumerate(str_input):\n        if val == '(':\n            stack.append(index)\n        elif val == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(index)\n\n    return len(stack)\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('(())', 0),\n        ('(())()', 0),\n        ('((())', 1),\n        ('((())()))', 0),\n        ('((())())))))', 0),\n        ('((())()))))', 1),\n        ('((((((', 2),\n        ('((((()))))', 1),\n        ('((((((((((', 2),\n        ('((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "def min_bracket_swap(str_in):\n    stack = []\n    for ch in str_in:\n        if ch == \"(\":\n            stack.append(ch)\n        elif ch == \")\":\n            if stack and stack[-1] == \")\":\n                stack.pop()\n            else:\n                stack.append(ch)\n\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"((()))\", 0),\n        (\"((())\", 1),\n        (\"((())(\", 1),\n        (\"((\", 2),\n        (\"()\", 0),\n        (\"\", 0),\n    ]\n    for test_string, expected_output in test_cases:\n        assert min_bracket_swap(test_string) == expected_output",
    "def min_swaps(arr):\n    if not arr:\n        return 0\n\n    open_brackets = 0\n    swaps = 0\n    for i in range(len(arr)):\n        if arr[i] == '(':\n            open_brackets += 1\n        else:\n            open_brackets -= 1\n\n        if open_brackets < 0:\n            swaps += 1\n            open_brackets = 0\n\n    return swaps\n\n\ndef main():\n    arr = input(\"Enter string: \")\n    print(\"Minimum swaps required for balancing brackets in the given string:\", min_swaps(arr))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def min_bracket_balancing(string):\n    stack = []\n    for i in range(len(string)):\n        if string[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(i)\n    return len(stack)\n\n\nprint(min_bracket_balancing('((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "class Solution:\n    def minSwap(self, s: str, t: str) -> int:\n        \"\"\"\n        Swap the characters in the string such that the number of balanced brackets is maximized.\n        The no. of balanced brackets can be calculated by finding the difference between the number\n        of opening and closing brackets in the string.\n\n        If the string is balanced, the no. of swaps needed is 0.\n        If the string is unbalanced, we can find the minimum no. of swaps by calculating the number\n        of swaps required for the two strings with the minimum difference between the number of\n        balanced brackets.\n\n        To calculate the minimum no. of swaps for a string, we can find the minimum no. of swaps\n        for the substrings with the minimum difference.\n\n        The minimum no. of swaps for a substring can be calculated by performing the following steps:\n\n        - Find the minimum no. of swaps for the first half of the substring.\n        - Find the minimum no. of swaps for the second half of the substring.\n        - Swap the characters in the first and second half of the substring.\n        - Add the minimum no. of swaps for the first and second half of the substring.\n        - Swap the characters in the first and second half of the substring again.\n        - Minimize the no. of swaps for the whole substring.\n\n        To find the minimum no. of swaps for the first half of the substring, we can use the same\n        method recursively.\n\n        To find the minimum no. of swaps for the second half of the substring, we can use the same\n        method recursively.\n        \"\"\"\n        if len(s) == 0:\n            return 0\n\n        swaps = 0\n        if s[0] != t[0]:\n            swaps += 1\n\n        # Minimum no. of swaps for the first half of the substring\n        swaps_first_half = self.minSwap(s[1:], t[1:])\n\n        # Minimum no. of swaps for the second half of the substring\n        swaps_second_half = self.minSwap(s[:-1], t[:-1",
    "def minimum_swaps(arr):\n    swap = 0\n    for i in range(len(arr)):\n        while arr[i] != i + 1:\n            swap += 1\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    return swap\n\n\ndef main():\n    arr = [int(i) for i in input(\"Enter the elements of array: \").split()]\n    print(f\"Minimum swaps required for bracket balancing in the given string: {minimum_swaps(arr)}\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "def min_swaps(s: str) -> int:\n    \"\"\"\n    Idea is to find out the count of open and close brackets and compare the count of them.\n    If the count is unequal, then the minimum swaps required is difference of counts.\n    If the count is equal, then there is no need of swapping.\n    If the count is unequal and difference of counts is even, then we can swap any even no of brackets.\n    If the count is unequal and difference of counts is odd, then we cannot swap any odd no of brackets.\n    \"\"\"\n    count_open = count_close = 0\n\n    for char in s:\n        if char == \"(\":\n            count_open += 1\n        elif char == \")\":\n            count_close += 1\n\n    if count_open == count_close:\n        return 0\n    elif abs(count_open - count_close) % 2 == 0:\n        return abs(count_open - count_close) // 2\n    else:\n        return -1\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"(((((())\") == 1\n    assert min_swaps(\"((((())))\") == 0\n    assert min_swaps(\"(((((((((()))))))))))\") == 0\n    assert min_swaps(\"())\") == -1\n    assert min_swaps(\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((",
    "class Solution:\n    def minSwap(self, s: str, t: str) -> int:\n        n = len(s)\n        dp = [[0] * 2 for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 1 if s[i] == t[i] else 2\n\n        for i in range(1, n):\n            for j in range(i):\n                if s[j] == t[i]:\n                    dp[i][0] = min(dp[i][0], dp[j][1] + 1)\n\n                if s[i] == t[j]:\n                    dp[i][1] = min(dp[i][1], dp[j][0] + 1)\n\n        return min(dp[n - 1][0], dp[n - 1][1])\n\n\nif __name__ == \"__main__\":\n    s = \"][][[]\"\n    t = \"[]][[]]\"\n    out = 3\n    res = Solution().minSwap(s, t)\n    assert res == out, (res, out)\n\n    s = \"[][]\"\n    t = \"[][]\"\n    out = 0\n    res = Solution().minSwap(s, t)\n    assert res == out, (res, out)\n\n    s = \"[][]\"\n    t = \"[][]\"\n    out = 0\n    res = Solution().minSwap(s, t)\n    assert res == out, (res, out)",
    "def find_minimum_swaps(input_string):\n    stack = []\n    swaps = 0\n    for i in input_string:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    return swaps\n\nif __name__ == \"__main__\":\n    input_string = \"((((((\"\n    print(find_minimum_swaps(input_string))\n\n    input_string = \"()())\"\n    print(find_minimum_swaps(input_string))\n\n    input_string = \"))(((((\"\n    print(find_minimum_swaps(input_string))\n\n    input_string = \")))(((\",\n    print(find_minimum_swaps(input_string))\n\n    input_string = \"))(())((\"\n    print(find_minimum_swaps(input_string))\n\n    input_string = \"))(())(((\"\n    print(find_minimum_swaps(input_string))\n\n    input_string = \")))(())((\"\n    print(find_minimum_swaps(input_string))",
    "def min_bracket_balancing(input_string):\n    opening_brackets = 0\n    closing_brackets = 0\n    for i in range(len(input_string)):\n        if input_string[i] == \"(\":\n            opening_brackets += 1\n        elif input_string[i] == \")\":\n            closing_brackets += 1\n        if closing_brackets > opening_brackets:\n            opening_brackets += 1\n    return min(closing_brackets, opening_brackets)\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_balancing(\"((()\"))\n    print(min_bracket_balancing(\"()\"))\n    print(min_bracket_balancing(\"()()\"))\n    print(min_bracket_balancing(\"(()\"))\n    print(min_bracket_balancing(\"()()()\"))\n    print(min_bracket_balancing(\"(()()\"))\n    print(min_bracket_balancing(\"((((()))))\"))\n    print(min_bracket_balancing(\"(())()()\"))\n    print(min_bracket_balancing(\"((((()))))))\"))\n    print(min_bracket_balancing(\"(()()()()\"))",
    "def min_swaps(string):\n    \"\"\"\n    Returns the minimum number of swaps to balance the brackets.\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    stack = []\n    swaps = 0\n    for i in range(len(string)):\n        if string[i] == '(':\n            stack.append(i)\n        elif string[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                swaps += 1\n    swaps += len(stack)\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_swaps(\"()\") == 0\n    assert min_swaps(\"(())\") == 0\n    assert min_swaps(\"((())\") == 1\n    assert min_swaps(\"(()))\") == 1\n    assert min_swaps(\")(\") == 2\n    assert min_swaps(\"(((\") == 3\n    assert min_swaps(\"))(\") == 2\n    assert min_swaps(\"((((((\") == 6\n    assert min_swaps(\"))(\") == 2\n    assert min_swaps(\")()()(\") == 1",
    "def min_bracket_swap(str_):\n    stack = []\n    for char in str_:\n        if char == '(':\n            stack.append('(')\n        elif char == ')':\n            if not stack:\n                return -1\n            stack.pop()\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swap(\"(()\") == 1\n    assert min_bracket_swap(\")(\") == -1\n    assert min_bracket_swap(\"(((\") == 2\n    assert min_bracket_swap(\"()()\") == 0\n    assert min_bracket_swap(\")()(\") == -1",
    "def min_bracket_swaps(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    left_bracket_stack = []\n    swaps = 0\n\n    for char in string:\n        if char == \"(\":\n            left_bracket_stack.append(char)\n        elif char == \")\":\n            if not left_bracket_stack:\n                swaps += 1\n            else:\n                left_bracket_stack.pop()\n\n    return swaps + len(left_bracket_stack)\n\n\nif __name__ == \"__main__\":\n    print(min_bracket_swaps(\"((((\"))\n    print(min_bracket_swaps(\")(\"))\n    print(min_bracket_swaps(\"((())\"))\n    print(min_bracket_swaps(\"(())\"))\n    print(min_bracket_swaps(\"(((\"))\n    print(min_bracket_swaps(\"((\"))\n    print(min_bracket_swaps(\"()\"))",
    "def min_bracket_swap(s):\n    if not s:\n        return 0\n\n    stack = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            if not stack:\n                return -1\n            stack.pop()\n\n    if stack:\n        return -1\n\n    swaps = 0\n    for i in range(len(s)):\n        if s[i] == ')':\n            swaps += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    assert min_bracket_swap(\"(((((())()))))\") == 2\n    assert min_bracket_swap(\"((((((()))))))\") == 0\n    assert min_bracket_swap(\"((((((()()))))))\") == 1\n    assert min_bracket_swap(\"(()()())\") == 0\n    assert min_bracket_swap(\"(((((((())))))))\") == 0\n    assert min_bracket_swap(\"((((((((())))))))))\") == -1\n    assert min_bracket_swap(\"((((((((()())))))))))\") == 1\n    assert min_bracket_swap(\"()()()\") == 0\n    assert min_bracket_swap(\"(()()()())\") == 0\n    assert min_bracket_swap(\"(()()()())()\") == 0\n    assert min_bracket_swap(\"(((())))\") == 1\n    assert min_bracket_swap(\"()()(()()())()\") == 0\n    assert min_bracket_swap(\"((())\") == -1\n    assert min_bracket_swap(\"(()()()()())\") == 0",
    "from collections import deque\n\n\ndef min_swaps(arr):\n    swaps = 0\n    stack = deque()\n\n    for i in range(len(arr)):\n        if arr[i] == '(':\n            stack.append(arr[i])\n        else:\n            if len(stack) == 0:\n                swaps += 1\n            else:\n                stack.pop()\n\n    if len(stack) != 0:\n        swaps += len(stack)\n\n    return swaps\n\n\ndef main():\n    arr = input(\"Enter the string: \")\n    print(min_swaps(arr))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from collections import deque\n\n\ndef minimum_bracket_swaps(str1):\n    stack = deque()\n    for i in range(len(str1)):\n        if str1[i] == \"(\":\n            stack.append(str1[i])\n        else:\n            if stack and stack[-1] == \"(\":\n                stack.pop()\n            else:\n                stack.append(str1[i])\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert minimum_bracket_swaps(\"((()))\") == 0\n    assert minimum_bracket_swaps(\")(\") == 1\n    assert minimum_bracket_swaps(\"(((((((((\") == 12\n    assert minimum_bracket_swaps(\"()(((((((((()\") == 1",
    "def min_bracket_swaps(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                stack.append(char)\n            else:\n                stack.pop()\n        else:\n            continue\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"()\", 0),\n        (\"((()))\", 0),\n        (\"(())\", 0),\n        (\"(()))\", 1),\n        (\"(((((((())\", 7),\n        (\"(((((((((\", 1),\n        (\"((((((\", 1),\n        (\"()(((((((()\", 1),\n        (\"()((((((()\", 1),\n        (\"()((((((())))\", 0),\n        (\"(()()()(()\", 0),\n        (\"(()()()(())\", 0),\n        (\"(()()())\", 0),\n        (\"(()())\", 1),\n        (\"((())\", 1),\n        (\"((()\", 1),\n        (\"((\", 0),\n        (\")\", 0),\n        (\"\", 0),\n    ]\n    for test_string, expected_result in test_cases:\n        result = min_bracket_swaps(test_string)\n        assert result == expected_result",
    "def min_bracket_balancing(string):\n    stack = []\n    for i in range(len(string)):\n        if string[i] == '(':\n            stack.append(i)\n        elif string[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(i)\n    if stack:\n        return len(stack)\n    else:\n        return 0\n\n\nif __name__ == '__main__':\n    test_cases = int(input())\n    for t in range(test_cases):\n        string = input()\n        print(min_bracket_balancing(string))",
    "from collections import deque\n\n\ndef min_bracket_swaps(string):\n    stack = deque()\n    swaps = 0\n\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                swaps += 1\n\n    return swaps\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"(())\", 0),\n        (\"(()))((\", 3),\n        (\"((((\", 2),\n        (\"()))\", 0),\n        (\"()\", 0),\n        (\"((\", 1),\n        (\"())\", 1),\n        (\"(((()))\", 2),\n        (\"()((\", 1),\n        (\")))(\", 1),\n        (\"()(())\", 0),\n        (\"((()\", 1),\n        (\"))(())\", 2),\n        (\"(()\", 1),\n        (\"(()))\", 1),\n        (\"(())\", 0),\n        (\"()(()\", 1),\n        (\"((((((((\", 10),\n        (\"((((((((\"),\n        (\")))(((((\", 1),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),\n        (\"((((((((\"),\n        (\"((((((((\", 10),\n        (\")))(((((\", 1),",
    "def minimum_swaps(s):\n    swaps = 0\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            continue\n        j = i\n        while s[j] != \"(\":\n            j += 1\n        if j == i:\n            continue\n        s[j], s[i] = s[i], s[j]\n        swaps += 1\n    return swaps\n\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        s = input()\n        print(minimum_swaps(s))\n\n\nif __name__ == \"__main__\":\n    main()",
    "def minimum_bracket_swaps(string):\n    stack = []\n    for ch in string:\n        if ch == '(':\n            stack.append(ch)\n        else:\n            if len(stack) == 0:\n                return -1\n            stack.pop()\n\n    if len(stack) == 0:\n        return 0\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    string = input()\n    print(minimum_bracket_swaps(string))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}