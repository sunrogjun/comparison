{
  "problem": {
    "task_id": "MBPP/152",
    "prompt": "Write a function to sort the given array by using merge sort.",
    "canonical_solution": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n",
    "test_list": [
      "assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]",
      "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]",
      "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]"
    ],
    "challenge_test_list": [],
    "problem_id": 141
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm.\n\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    if len(array) <= 1:\n        return array\n\n    middle = len(array) // 2\n    left = merge_sort(array[:middle])\n    right = merge_sort(array[middle:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays.\n\n    :param left: left array\n    :param right: right array\n    :return: merged array\n    \"\"\"\n    merged = []\n    left_pointer = 0\n    right_pointer = 0\n\n    while left_pointer < len(left) and right_pointer < len(right):\n        if left[left_pointer] <= right[right_pointer]:\n            merged.append(left[left_pointer])\n            left_pointer += 1\n        else:\n            merged.append(right[right_pointer])\n            right_pointer += 1\n\n    merged += left[left_pointer:]\n    merged += right[right_pointer:]\n\n    return merged\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([]) == []\n    assert merge_sort([1]) == [1]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm.\n    Time Complexity: O(n*log(n)).\n    Space Complexity: O(n).\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 6, 2, 5, 9, 8]) == [2, 4, 5, 6, 8, 9]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\narr = [1, 4, 2, 9, 5, 6, 3]\nmerge_sort(arr)\nprint(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) <= 1:\n        return\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    merge_sort(left)\n    merge_sort(right)\n\n    i = 0\n    j = 0\n    k = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 4, 5, 2, 6, 0, -1, -2, 5]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort is a divide and conquer algorithm.\n    It is similar to merge step in merge sort.\n    It repeatedly divides the array into two halves\n    until we have single elements and then keeps merging the two halves.\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6]) == [3, 4, 6, 7]",
    "def merge_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    print(merge_sort([5, 4, 3, 2, 1]))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort function.\n\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    if len(array) > 1:\n        middle = len(array) // 2\n        left_array = array[:middle]\n        right_array = array[middle:]\n        merge_sort(left_array)\n        merge_sort(right_array)\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left_array) and j < len(right_array):\n            if left_array[i] < right_array[j]:\n                array[k] = left_array[i]\n                i += 1\n            else:\n                array[k] = right_array[j]\n                j += 1\n            k += 1\n\n        while i < len(left_array):\n            array[k] = left_array[i]\n            i += 1\n            k += 1\n\n        while j < len(right_array):\n            array[k] = right_array[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 3, 1, 2, 4]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(nums) < 2:\n        return nums\n\n    mid: int = len(nums) // 2\n    left: List[int] = nums[:mid]\n    right: List[int] = nums[mid:]\n\n    return merge(merge_sort(left), merge_sort(right))\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    sorted: List[int] = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted.append(left[i])\n            i += 1\n        else:\n            sorted.append(right[j])\n            j += 1\n\n    sorted.extend(left[i:])\n    sorted.extend(right[j:])\n\n    return sorted\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 2, 5]) == [2, 3, 4, 5, 7]\n    assert merge_sort([1, 3, 5, 2, 4]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 5, 3, 2, 4]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 3, 2, 4, 5]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        while left and right:\n            merged.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        return merged + left + right\n\n    def sort(array: List[int]) -> List[int]:\n        if len(array) <= 1:\n            return array\n        mid = len(array) // 2\n        left, right = sort(array[:mid]), sort(array[mid:])\n        return merge(left, right)\n\n    return sort(array)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n * log n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        sorted_list = []\n        while left and right:\n            sorted_list.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        return sorted_list + left + right\n\n    def merge_sort_recursive(array: List[int]) -> List[int]:\n        if len(array) <= 1:\n            return array\n        mid = len(array) // 2\n        return merge(merge_sort_recursive(array[:mid]), merge_sort_recursive(array[mid:]))\n\n    return merge_sort_recursive(arr)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6]) == [3, 4, 6, 7]\n    assert merge_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    \"\"\"\n\n    def merge(arr: List[int], low: int, mid: int, high: int):\n        # Create temporary arrays\n        left = arr[low:mid]\n        right = arr[mid:high]\n\n        # Initial indices for left and right sub-arrays\n        left_index = 0\n        right_index = 0\n\n        # Initial index of merged sub-array array\n        merged_index = low\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] < right[right_index]:\n                arr[merged_index] = left[left_index]\n                left_index += 1\n            else:\n                arr[merged_index] = right[right_index]\n                right_index += 1\n            merged_index += 1\n\n        # Copy remaining elements of left, if any\n        while left_index < len(left):\n            arr[merged_index] = left[left_index]\n            left_index += 1\n            merged_index += 1\n\n        # Copy remaining elements of right, if any\n        while right_index < len(right):\n            arr[merged_index] = right[right_index]\n            right_index += 1\n            merged_index += 1\n\n    def merge_sort_helper(arr: List[int], low: int, high: int):\n        if low < high:\n            mid = (low + high) // 2\n            merge_sort_helper(arr, low, mid)\n            merge_sort_helper(arr, mid + 1, high)\n            merge(arr, low, mid + 1, high)\n\n    merge_sort_helper(arr, 0, len(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([]) == []\n    assert merge_sort([5]) == [5]\n    assert merge_sort([5, 4]) == [4, 5",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge_sort_helper(arr: List[int], left: int, right: int) -> None:\n        if left >= right:\n            return\n\n        middle = (left + right) // 2\n\n        merge_sort_helper(arr, left, middle)\n        merge_sort_helper(arr, middle + 1, right)\n\n        merge(arr, left, middle, right)\n\n    def merge(arr: List[int], left: int, middle: int, right: int) -> None:\n        temp = []\n        i, j = left, middle + 1\n\n        while i <= middle and j <= right:\n            if arr[i] < arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n\n        for index in range(i, middle + 1):\n            temp.append(arr[index])\n\n        for index in range(j, right + 1):\n            temp.append(arr[index])\n\n        for index in range(left, right + 1):\n            arr[index] = temp[index - left]\n\n    merge_sort_helper(arr, 0, len(arr) - 1)\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [5, 4, 3, 2, 1]\n    print(merge_sort(arr))",
    "from typing import List\n\n\n# Time Complexity: O(n * log(n))\n# Space Complexity: O(n)\ndef merge_sort(arr: List[int]):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        merge_array(arr, left, right)\n\n\ndef merge_array(arr: List[int], left: List[int], right: List[int]):\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [5, 4, 3, 2, 1]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([]) == []\n    assert merge_sort([1]) == [1]\n    assert merge_sort([1, 2]) == [1, 2]\n    assert merge_sort([2, 1]) == [1, 2]\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result: List[int] = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result += left[i:]\n    result += right[j:]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    arr = [2, 4, 3, 1, 5, 7, 10, 15, 8, 16, 18, 20]\n    print(merge_sort(arr))",
    "from typing import List\n\n\n# Time complexity: O(n*log n)\n# Space complexity: O(n)\ndef merge_sort(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if len(nums) > 1:\n        mid = len(nums) // 2\n        left = nums[:mid]\n        right = nums[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n\n# Time complexity: O(n*log n)\n# Space complexity: O(log n)\ndef merge_sort_recursive(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if len(nums) > 1:\n        mid = len(nums) // 2\n        left = nums[:mid]\n        right = nums[mid:]\n\n        merge_sort_recursive(left)\n        merge_sort_recursive(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr)//2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6, 7]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n * log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        i, j = 0, 0\n        result = []\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        return result + left[i:] + right[j:]\n\n    if len(nums) <= 1:\n        return nums\n\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n    return merge(left, right)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 5, 6, 3, 2, 1]) == [1, 2, 3, 4, 5, 6]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm implementation.\n\n    :param array: given array to sort\n    :return: sorted array\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_half, right_half = array[:mid], array[mid:]\n        merge_sort(left_half)\n        merge_sort(right_half)\n        i, j, k = 0, 0, 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                array[k] = left_half[i]\n                i += 1\n            else:\n                array[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            array[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            array[k] = right_half[j]\n            j += 1\n            k += 1\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 5, 3, 2, 7, 6, 4]) == [1, 2, 3, 4, 5, 6, 7]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result: List[int] = []\n        while left and right:\n            result.append(\n                left.pop(0) if left[0] < right[0] else right.pop(0)\n            )\n        result.extend(left if left else right)\n        return result\n\n    def merge_sort_util(arr: List[int]) -> List[int]:\n        if len(arr) < 2:\n            return arr\n        mid: int = len(arr) // 2\n        return merge(\n            merge_sort_util(arr[:mid]),\n            merge_sort_util(arr[mid:]),\n        )\n\n    return merge_sort_util(arr)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([3, 1, 2, 5, 4]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 1, 3, 2, 4]) == [1, 2, 3, 4, 5]",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [1, 4, 2, 5, 3, 7, 2]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        merge(arr, left, right)\n\n\ndef merge(arr, left, right):\n    i, j, k = 0, 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n\ndef main():\n    arr_list: List[List[int]] = [[1, 5, 6, 4, 3, 2, 8, 7, 9, 11, 15, 10, 13, 14, 12]]\n    for arr in arr_list:\n        merge_sort(arr)\n        print(arr)\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge_sort_helper(arr: List[int], start: int, end: int):\n        if start == end:\n            return\n\n        mid = (start + end) // 2\n        merge_sort_helper(arr, start, mid)\n        merge_sort_helper(arr, mid + 1, end)\n        merge(arr, start, mid, end)\n\n    def merge(arr: List[int], start: int, mid: int, end: int):\n        tmp = [0] * len(arr)\n        left = start\n        right = mid + 1\n        idx = start\n\n        while left <= mid and right <= end:\n            if arr[left] < arr[right]:\n                tmp[idx] = arr[left]\n                left += 1\n            else:\n                tmp[idx] = arr[right]\n                right += 1\n            idx += 1\n\n        while left <= mid:\n            tmp[idx] = arr[left]\n            left += 1\n            idx += 1\n\n        while right <= end:\n            tmp[idx] = arr[right]\n            right += 1\n            idx += 1\n\n        for i in range(start, end + 1):\n            arr[i] = tmp[i]\n\n    merge_sort_helper(arr, 0, len(arr) - 1)\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(nums) <= 1:\n        return nums\n\n    mid = len(nums) // 2\n\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    merged = []\n\n    while len(left) and len(right):\n        if left[0] < right[0]:\n            merged.append(left.pop(0))\n        else:\n            merged.append(right.pop(0))\n\n    merged += left + right\n\n    return merged\n\n\nif __name__ == \"__main__\":\n    nums = [5, 3, 4, 2, 1, 6, 7, 8, 0]\n    print(merge_sort(nums))",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    length = len(arr)\n\n    if length <= 1:\n        return arr\n\n    mid = length // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    merged = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged += left[i:]\n    merged += right[j:]\n\n    return merged\n\n\nif __name__ == \"__main__\":\n    arr = [2, 4, 5, 6, 3, 7, 1, 8, 9, 10]\n    print(merge_sort(arr))",
    "def merge_sort(arr):\n    if len(arr) == 1:\n        return arr\n    else:\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    i = 0\n    j = 0\n    merged = []\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n    return merged\n\n\nif __name__ == \"__main__\":\n    arr = [8, 4, 2, 1, 3]\n    print(merge_sort(arr))",
    "def merge_sort(arr):\n    n = len(arr)\n    if n > 1:\n        mid = n//2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return arr\n\n\narr = [12, 11, 13, 5, 6, 7]\nprint(merge_sort(arr))",
    "def merge_sort(arr: list) -> list:\n    \"\"\"\n    Sort a list using merge sort algorithm.\n    >>> merge_sort([4, 3, 7, 6, 5, 2, 1])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge_sort([-2, 1, -5, 0, 11, 5, 13, -2, -4])\n    [-5, -4, -2, -2, 0, 1, 5, 5, 11, 13]\n    >>> merge_sort([4, 2, 2, 1, 0, 3, 5, 1])\n    [0, 1, 1, 2, 2, 3, 4, 5]\n    >>> merge_sort([-1, -2, -3, -4, -5, -6, -7])\n    [-7, -6, -5, -4, -3, -2, -1]\n    >>> merge_sort([1, 2, 3, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge_sort([1, 2, 3])\n    [1, 2, 3]\n    >>> merge_sort([1])\n    [1]\n    >>> merge_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> merge_sort([-1, -2, 0, 1, 2, 3])\n    [-3, -2, 0, 1, 2, 3]\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return arr\n\n    mid = n // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\ndef merge(left: list, right: list) -> list:\n    \"\"\"\n    Merge two sorted lists.",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Merge sort.\n\n    Time complexity: O(n log n).\n    Space complexity: O(n).\n    \"\"\"\n    # Base case.\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n\n    # Recursive case.\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Merge two sorted lists into a new sorted list.\"\"\"\n    merged = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    # Append any remaining elements.\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged\n\n\nif __name__ == '__main__':\n    test_cases = [\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [3, 1, 2, 4, 5],\n        [1, 1, 1, 1, 1],\n    ]\n    for nums in test_cases:\n        assert merge_sort(nums) == sorted(nums)",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(array: List[int], left: int, mid: int, right: int) -> None:\n        \"\"\"\n        Time Complexity: O(n*log(n))\n        Space Complexity: O(n)\n        \"\"\"\n        n1 = mid - left + 1\n        n2 = right - mid\n        left_array = array[left : left + n1]\n        right_array = array[mid + 1 : right + 1]\n        i, j, k = 0, 0, left\n\n        while i < n1 and j < n2:\n            if left_array[i] <= right_array[j]:\n                array[k] = left_array[i]\n                i += 1\n            else:\n                array[k] = right_array[j]\n                j += 1\n            k += 1\n\n        while i < n1:\n            array[k] = left_array[i]\n            i += 1\n            k += 1\n\n        while j < n2:\n            array[k] = right_array[j]\n            j += 1\n            k += 1\n\n    def merge_sort_helper(array: List[int], left: int, right: int) -> None:\n        if left < right:\n            mid = (left + right) // 2\n            merge_sort_helper(array, left, mid)\n            merge_sort_helper(array, mid + 1, right)\n            merge(array, left, mid, right)\n\n    merge_sort_helper(array, 0, len(array) - 1)\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6, 5, 2, 1]) == [1, 2, 3, 4, 5, 6, 7]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Merge sort\n\n    Args:\n        array (List[int]): list of integers to sort\n\n    Returns:\n        List[int]: sorted list\n    \"\"\"\n    if len(array) > 1:\n        middle = len(array) // 2\n        left = array[:middle]\n        right = array[middle:]\n\n        # Recursively sort both halves\n        merge_sort(left)\n        merge_sort(right)\n\n        # Two iterators for traversing the two halves\n        i = 0\n        j = 0\n\n        # Iterator for the main list\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6]) == [3, 4, 6, 7]\n    assert merge_sort([1, 2, 5, 4, 3, 7, 6]) == [1, 2, 3, 4, 5, 6, 7]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(arr: List[int], low: int, mid: int, high: int) -> None:\n        temp = [0] * (high - low + 1)\n        left = low\n        right = mid + 1\n        index = 0\n\n        while left <= mid and right <= high:\n            if arr[left] < arr[right]:\n                temp[index] = arr[left]\n                left += 1\n            else:\n                temp[index] = arr[right]\n                right += 1\n            index += 1\n\n        while left <= mid:\n            temp[index] = arr[left]\n            left += 1\n            index += 1\n\n        while right <= high:\n            temp[index] = arr[right]\n            right += 1\n            index += 1\n\n        for i in range(len(temp)):\n            arr[low + i] = temp[i]\n\n    def sort(arr: List[int], low: int, high: int) -> None:\n        if low < high:\n            mid = low + (high - low) // 2\n            sort(arr, low, mid)\n            sort(arr, mid + 1, high)\n            merge(arr, low, mid, high)\n\n    sort(arr, 0, len(arr) - 1)\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort(left)\n    right = merge_sort(right)\n    return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        [12, 11, 13, 5, 6, 7],\n        [2, 4, 6, 8, 1, 3, 5, 7, 9, 0],\n        [5, 4, 3, 2, 1],\n        [1, 2, 3, 4, 5, 6],\n        [1, 2, 3, 4, 5, 6, 7],\n        [1, 2, 3, 4, 5, 6, 7, 8],\n    ]\n    for test_case in test_cases:\n        sorted_arr = merge_sort(test_case)\n        print(sorted_arr)",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 2, 3, 20]\n    merge_sort(arr)\n    print(arr)",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    if len(left) > 0:\n        result += left\n    if len(right) > 0:\n        result += right\n    return result\n\n\narr = [5, 4, 3, 2, 1]\nprint(merge_sort(arr))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Divide and conquer algorithm.\"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n        merge_sort(left)\n        merge_sort(right)\n\n        left_index = 0\n        right_index = 0\n        array_index = 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] < right[right_index]:\n                array[array_index] = left[left_index]\n                left_index += 1\n            else:\n                array[array_index] = right[right_index]\n                right_index += 1\n            array_index += 1\n\n        while left_index < len(left):\n            array[array_index] = left[left_index]\n            left_index += 1\n            array_index += 1\n\n        while right_index < len(right):\n            array[array_index] = right[right_index]\n            right_index += 1\n            array_index += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    array = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6]\n    print(merge_sort(array))",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([]) == []\n    assert merge_sort([1]) == [1]\n    assert merge_sort([1, 2, 3]) == [1, 2, 3]\n    assert merge_sort([2, 1, 3]) == [1, 2, 3]\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(arr) == 1:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result: List[int] = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([2, 4, 5, 7, 9, 1, 3, 8, 6, 0]) == sorted(\n        [2, 4, 5, 7, 9, 1, 3, 8, 6, 0]\n    )",
    "from typing import List\n\n\n# Time Complexity: O(n*log(n))\n# Space Complexity: O(n)\ndef merge_sort(array: List[int]):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_half = array[:mid]\n        right_half = array[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                array[k] = left_half[i]\n                i += 1\n            else:\n                array[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            array[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            array[k] = right_half[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [8, 4, 23, 42, 16, 15]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> None:\n    \"\"\"\n    Merge sort.\n\n    :param nums: given array\n    :return: None\n    >>> nums = [1, 5, 8, 9, 2, 3]\n    >>> merge_sort(nums)\n    >>> nums\n    [1, 2, 3, 5, 8, 9]\n    \"\"\"\n    _merge_sort(nums, 0, len(nums) - 1)\n\n\ndef _merge_sort(nums: List[int], left: int, right: int) -> None:\n    \"\"\"\n    Recursive merge sort.\n\n    :param nums: given array\n    :param left: leftmost index of the array\n    :param right: rightmost index of the array\n    :return: None\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        _merge_sort(nums, left, mid)\n        _merge_sort(nums, mid + 1, right)\n        _merge(nums, left, mid, right)\n\n\ndef _merge(nums: List[int], left: int, mid: int, right: int) -> None:\n    \"\"\"\n    Merge two sorted subarrays.\n\n    :param nums: given array\n    :param left: leftmost index of the array\n    :param mid: middle index of the array\n    :param right: rightmost index of the array\n    :return: None\n    \"\"\"\n    temp = []\n    left_idx, right_idx = left, mid + 1\n\n    while left_idx <= mid and right_idx <= right:\n        if nums[left_idx] < nums[right_idx]:\n            temp.append(nums[left_idx])\n            left_idx += 1\n        else:\n            temp.append(nums[right_idx])\n            right_idx += 1\n\n    remainder = left_idx - left if left_idx <= mid else right_idx - (mid + 1)\n    if remainder == 0:\n        temp = num",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n        merge_sort(left_half)\n        merge_sort(right_half)\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\narr = [12, 11, 13, 5, 6, 7]\nprint(merge_sort(arr))",
    "from typing import List\n\n\n# Time complexity: O(nlogn)\n# Space complexity: O(n)\ndef merge_sort(array: List[int]) -> None:\n    \"\"\"\n    Sort the array in-place.\n    \"\"\"\n    if len(array) <= 1:\n        return\n\n    mid = len(array) // 2\n    left, right = array[:mid], array[mid:]\n\n    merge_sort(left)\n    merge_sort(right)\n\n    merge(array, left, right)\n\n\ndef merge(array: List[int], left: List[int], right: List[int]) -> None:\n    i = j = k = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n\n        k += 1\n\n    while i < len(left):\n        array[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        array[k] = right[j]\n        j += 1\n        k += 1\n\n\ndef main():\n    arr = [3, 2, 5, 1, 4, 6, 7, 8, 0]\n    merge_sort(arr)\n    print(arr)\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 6, 2, 5, 9, 8]) == [2, 4, 5, 6, 8, 9]",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Merge Sort\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        i, j = 0, 0\n        result = []\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        result += left[i:]\n        result += right[j:]\n\n        return result\n\n    if len(nums) <= 1:\n        return nums\n\n    mid = len(nums) // 2\n    left = merge_sort(nums[:mid])\n    right = merge_sort(nums[mid:])\n\n    return merge(left, right)\n\n\nif __name__ == \"__main__\":\n    nums = [5, 3, 4, 8, 2, 1, 9, 6]\n    assert merge_sort(nums) == sorted(nums)",
    "from typing import List\n\n\n# Time complexity: O(n log n)\n# Space complexity: O(n)\ndef merge_sort(array: List[int]) -> None:\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef main():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    merge_sort(arr)\n    print(arr)\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm.\n\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    if len(array) == 1:\n        return array\n\n    mid = len(array) // 2\n    left, right = merge_sort(array[:mid]), merge_sort(array[mid:])\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted array.\n\n    :param left: left array\n    :param right: right array\n    :return: merged array\n    \"\"\"\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 3, 2, 4, 6, 5]) == [1, 2, 3, 4, 5, 6]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm.\n\n    Time complexity: O(n log n).\n    Space complexity: O(n).\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n\n    # Divide the array into two halves.\n    left_arr = arr[:mid]\n    right_arr = arr[mid:]\n\n    # Sort left and right halves recursively.\n    left_arr = merge_sort(left_arr)\n    right_arr = merge_sort(right_arr)\n\n    return merge(left_arr, right_arr)\n\n\ndef merge(left_arr: List[int], right_arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays.\n\n    Time complexity: O(n).\n    Space complexity: O(n).\n    \"\"\"\n    merged_arr = []\n    left_idx = 0\n    right_idx = 0\n\n    while left_idx < len(left_arr) and right_idx < len(right_arr):\n        if left_arr[left_idx] <= right_arr[right_idx]:\n            merged_arr.append(left_arr[left_idx])\n            left_idx += 1\n        else:\n            merged_arr.append(right_arr[right_idx])\n            right_idx += 1\n\n    # Append remaining elements.\n    merged_arr += left_arr[left_idx:]\n    merged_arr += right_arr[right_idx:]\n\n    return merged_arr\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 4, 3, 5, 6, 7, 9, 8]\n    result = merge_sort(arr)\n    print(result)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(arr: List[int], left: int, mid: int, right: int) -> None:\n        left_arr = arr[left : mid + 1]\n        right_arr = arr[mid + 1 : right + 1]\n\n        left_arr_idx, right_arr_idx = 0, 0\n        arr_idx = left\n\n        while left_arr_idx < len(left_arr) and right_arr_idx < len(right_arr):\n            if left_arr[left_arr_idx] <= right_arr[right_arr_idx]:\n                arr[arr_idx] = left_arr[left_arr_idx]\n                left_arr_idx += 1\n            else:\n                arr[arr_idx] = right_arr[right_arr_idx]\n                right_arr_idx += 1\n            arr_idx += 1\n\n        while left_arr_idx < len(left_arr):\n            arr[arr_idx] = left_arr[left_arr_idx]\n            left_arr_idx += 1\n            arr_idx += 1\n\n        while right_arr_idx < len(right_arr):\n            arr[arr_idx] = right_arr[right_arr_idx]\n            right_arr_idx += 1\n            arr_idx += 1\n\n    def merge_sort_helper(arr: List[int], left: int, right: int) -> None:\n        if left < right:\n            mid = (left + (right - 1)) // 2\n            merge_sort_helper(arr, left, mid)\n            merge_sort_helper(arr, mid + 1, right)\n            merge(arr, left, mid, right)\n\n    merge_sort_helper(arr, 0, len(arr) - 1)\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr_list:",
    "def merge_sort(a):\n    if len(a) == 1:\n        return\n    mid = len(a) // 2\n    left = a[:mid]\n    right = a[mid:]\n    merge_sort(left)\n    merge_sort(right)\n    merge(a, left, right)\n\n\ndef merge(a, left, right):\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            a[k] = left[i]\n            i += 1\n        else:\n            a[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        a[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        a[k] = right[j]\n        j += 1\n        k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6, 7]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result: List[int] = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    if i < len(left):\n        result.extend(left[i:])\n    if j < len(right):\n        result.extend(right[j:])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 5, 8, 0, 3, 2]) == [0, 1, 2, 3, 5, 8]",
    "def merge_sort(nums: list):\n    \"\"\"\n    The merge sort algorithm recursively splits the array into\n    subarrays until they're sorted and then merge them back\n    together in a sorted order.\n    \"\"\"\n\n    if len(nums) > 1:\n        # Find the middle of the array\n        mid = len(nums) // 2\n\n        # Split the array into two halves\n        left = nums[:mid]\n        right = nums[mid:]\n\n        # Sort the left and right halves\n        merge_sort(left)\n        merge_sort(right)\n\n        # Merge the sorted left and right halves\n        merge(nums, left, right)\n\ndef merge(nums: list, left: list, right: list):\n    \"\"\"\n    Merge the sorted left and right halves of the array into a single array\n    \"\"\"\n\n    i = 0\n    j = 0\n    k = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            nums[k] = left[i]\n            i += 1\n        else:\n            nums[k] = right[j]\n            j += 1\n\n        k += 1\n\n    # Copy any leftover elements from the left subarray\n    while i < len(left):\n        nums[k] = left[i]\n        i += 1\n        k += 1\n\n    # Copy any leftover elements from the right subarray\n    while j < len(right):\n        nums[k] = right[j]\n        j += 1\n        k += 1\n\nif __name__ == \"__main__\":\n    nums = [54, 23, 45, 12, 34, 98, 99, 99, 100, 34]\n\n    print(\"Unsorted:\", nums)\n    merge_sort(nums)\n    print(\"Sorted:\", nums)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result = []\n\n        while left and right:\n            if left[-1] >= right[-1]:\n                result.append(left.pop())\n            else:\n                result.append(right.pop())\n\n        return result + left + right\n\n    def sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left, right = sort(arr[:mid]), sort(arr[mid:])\n\n        return merge(left, right)\n\n    return sort(arr)\n\n\nif __name__ == \"__main__\":\n    print(merge_sort([1, 2, 3, 4, 5, 6]))",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    length = len(arr)\n\n    if length < 2:\n        return arr\n\n    mid_index = length // 2\n    left_side = merge_sort(arr[:mid_index])\n    right_side = merge_sort(arr[mid_index:])\n\n    return merge(left_side, right_side)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    sorted_list = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            sorted_list.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_list.append(right[right_index])\n            right_index += 1\n\n    sorted_list.extend(left[left_index:] or right[right_index:])\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(arr) > 1:\n        mid: int = len(arr) // 2\n        left: List[int] = arr[:mid]\n        right: List[int] = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6, 5, 2, 1]) == [1, 2, 3, 4, 5, 6, 7]",
    "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return merge(merge_sort(left), merge_sort(right))\n\n\ndef merge(left, right):\n    result = []\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    if len(left) > 0:\n        result.extend(left)\n    if len(right) > 0:\n        result.extend(right)\n    return result\n\n\nif __name__ == '__main__':\n    arr = [2, 5, 3, 1, 7, 8, 6, 4]\n    print(merge_sort(arr))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm implementation.\n    :param array: the array to sort.\n    :return: sorted array.\n    >>> merge_sort([4, 3, 7, 6])\n    [3, 4, 6, 7]\n    >>> merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge_sort([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge_sort([1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \"\"\"\n    if len(array) > 1:\n        middle = len(array) // 2\n        left_array = array[:middle]\n        right_array = array[middle:]\n\n        merge_sort(left_array)\n        merge_sort(right_array)\n\n        left_index = 0\n        right_index = 0\n        index = 0\n\n        while left_index < len(left_array) and right_index < len(right_array):\n            if left_array[left_index] < right_array[right_index]:",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        \"\"\"\n        Merge two sorted list into one.\n        \"\"\"\n        result: List[int] = []\n\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        result += left[i:]\n        result += right[j:]\n\n        return result\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(array) == 1:\n        return array\n\n    mid = len(array) // 2\n\n    left = array[:mid]\n    right = array[mid:]\n\n    return merge(merge_sort(left), merge_sort(right))\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 5, 2, 1]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 2, 1, 4, 3]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> None:\n    \"\"\"\n    Time Complexity: O(n * log(n))\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef test(input_data, expected_answer):\n    \"\"\"Test driver function.\"\"\"\n    answer = merge_sort(input_data)\n    if answer != expected_answer:\n        raise Exception(\n            f\"Wrong answer {answer}. Expected answer was {expected_answer}.\"\n        )\n\n\ndef test_merge_sort():\n    \"\"\"Test driver function.\"\"\"\n    test([4, 2, 3, 1, 0], [0, 1, 2, 3, 4])\n    test([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    test([5, 4, 3, 2, 1], [1, 2, 3, 4, 5])\n    test([4, 3, 5, 1, 2], [1, 2, 3, 4, 5])\n    print(\"All tests passed!\")\n\n\nif __name__ == \"__main__\":\n    test_merge_sort()",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half, right_half = arr[:mid], arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 3, 1, 2, 4]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\n# Time Complexity: O(n*log(n))\n# Space Complexity: O(n)\ndef merge_sort(arr: List[int]) -> List[int]:\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        merge(arr, left, right)\n    return arr\n\n\ndef merge(arr: List[int], left: List[int], right: List[int]) -> None:\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n\ntest_cases = [\n    ([3, 2, 6, 1, 5, 4], [1, 2, 3, 4, 5, 6]),\n    ([4, 2, 1, 3], [1, 2, 3, 4]),\n    ([3, 1, 2], [1, 2, 3]),\n]\n\ntestable_functions = [merge_sort]\n\n\ndef test_merge_sort():\n    for merge_sort_solution in testable_functions:\n        for arr, expected in test_cases:\n            assert merge_sort_solution(arr) == expected",
    "from typing import List\n\n\n# Time complexity: O(n * log n)\n# Space complexity: O(n)\ndef merge_sort(array: List[int]) -> None:\n    \"\"\"\n    Merge sort\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    n = len(array)\n\n    # Base case\n    if n <= 1:\n        return array\n\n    # Divide\n    mid = n // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n\n    # Merge\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    if i < len(left):\n        result.extend(left[i:])\n    if j < len(right):\n        result.extend(right[j:])\n\n    return result\n\n\n# Time complexity: O(n * log n)\n# Space complexity: O(n)\ndef merge_sort_inplace(array: List[int]) -> None:\n    \"\"\"\n    Merge sort\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    n = len(array)\n\n    # Base case\n    if n <= 1:\n        return array\n\n    # Divide\n    mid = n // 2\n    left = array[:mid]\n    right = array[mid:]\n\n    # Merge\n    i, j, k = 0, 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n        k += 1\n\n    if i < len(left):\n        array[k:k + (len(left) - i)] = left",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    length = len(array)\n\n    if length <= 1:\n        return array\n\n    mid_index = length // 2\n    left = array[:mid_index]\n    right = array[mid_index:]\n\n    left = merge_sort(left)\n    right = merge_sort(right)\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    i, j = 0, 0\n    result = []\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result += left[i:]\n    result += right[j:]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\narr = [10, 7, 8, 9, 1, 5]\nmerge_sort(arr)\nprint(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    def merge_sort_helper(nums: List[int]) -> List[int]:\n        if len(nums) < 2:\n            return nums\n        mid = len(nums) // 2\n        left = merge_sort_helper(nums[:mid])\n        right = merge_sort_helper(nums[mid:])\n        return merge(left, right)\n\n    merge_sort_helper(arr)\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 2, 4, 6, 8]\n    merge_sort(nums)\n    print(nums)",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        sorted_nums = []\n        while left and right:\n            sorted_nums.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        return sorted_nums + left + right\n\n    def sort(nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = sort(nums[:mid])\n        right = sort(nums[mid:])\n        return merge(left, right)\n\n    return sort(nums)\n\n\nif __name__ == \"__main__\":\n    print(merge_sort([4, 3, 2, 10, 12, 1, 5, 6]))",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n\n    left_arr = merge_sort(arr[:mid])\n    right_arr = merge_sort(arr[mid:])\n\n    return merge(left_arr, right_arr)\n\n\ndef merge(left_arr: List[int], right_arr: List[int]) -> List[int]:\n    merged_arr = []\n\n    while left_arr and right_arr:\n        if left_arr[0] < right_arr[0]:\n            merged_arr.append(left_arr.pop(0))\n        else:\n            merged_arr.append(right_arr.pop(0))\n\n    while left_arr:\n        merged_arr.append(left_arr.pop(0))\n\n    while right_arr:\n        merged_arr.append(right_arr.pop(0))\n\n    return merged_arr\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 7, 6, 5, 8, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Merge sort.\n\n    Time complexity: O(n log n).\n    Space complexity: O(n).\n    \"\"\"\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n\n    return _merge(left, right)\n\n\ndef _merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Merge two sorted list.\"\"\"\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged += left[i:]\n    merged += right[j:]\n\n    return merged\n\n\nif __name__ == '__main__':\n    print(merge_sort([1, 4, 2, 8, 3, 9, 5, 10, 7, 6]))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(array) <= 1:\n        return array\n\n    mid = len(array) // 2\n    left = array[:mid]\n    right = array[mid:]\n\n    left = merge_sort(left)\n    right = merge_sort(right)\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]):\n    merged = []\n    while len(left) and len(right):\n        if left[0] <= right[0]:\n            merged.append(left.pop(0))\n        else:\n            merged.append(right.pop(0))\n\n    return merged + left + right\n\n\nif __name__ == \"__main__\":\n    array = [5, 4, 3, 2, 1]\n    print(*merge_sort(array))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Divide and Conquer.\"\"\"\n    if len(array) > 1:\n        middle = len(array) // 2\n        left = array[:middle]\n        right = array[middle:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 6, 2, 5, 9, 8]) == [2, 4, 5, 6, 8, 9]",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [34, 56, 23, 67, 3, 68]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\n# Time Complexity: O(n*log(n))\n# Space Complexity: O(n)\ndef merge_sort(array: List[int]) -> List[int]:\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    print(merge_sort([5, 6, 1, 2, 0, 7, 4]))",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> None:\n    \"\"\"\n    Merge sort.\n    Time Complexity: O(n*log(n)).\n    Space Complexity: O(n).\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [3, 4, 1, 2, 9, 8, 0, 6, 7, 5]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n\n    def merge(left, right):\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] < right[0] else right.pop(0))\n        return result + left + right\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\n\nif __name__ == \"__main__\":\n    arr: List[int] = [1, 5, 6, 8, 9, 10, 4, 3, 2, 7]\n    print(merge_sort(arr))",
    "def merge_sort(a):\n    if len(a) == 1:\n        return a\n    else:\n        mid = len(a) // 2\n        left = merge_sort(a[:mid])\n        right = merge_sort(a[mid:])\n        return merge(left, right)\n\ndef merge(a, b):\n    result = []\n    i = j = 0\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            result.append(a[i])\n            i += 1\n        else:\n            result.append(b[j])\n            j += 1\n\n    while i < len(a):\n        result.append(a[i])\n        i += 1\n    while j < len(b):\n        result.append(b[j])\n        j += 1\n    return result\n\ndef main():\n    a = [12, 11, 13, 5, 6, 7]\n    print(merge_sort(a))\n\nif __name__ == \"__main__\":\n    main()",
    "from typing import List\n\n\ndef merge_sort(nums: List[int]) -> None:\n    \"\"\"\n    Merge sort algorithm to sort the given array.\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(nums: List[int], left: int, mid: int, right: int) -> None:\n        i = left\n        j = mid + 1\n        k = left\n\n        while i <= mid and j <= right:\n            if nums[i] < nums[j]:\n                nums[k] = nums[i]\n                i += 1\n            else:\n                nums[k] = nums[j]\n                j += 1\n            k += 1\n\n        while i <= mid:\n            nums[k] = nums[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            nums[k] = nums[j]\n            j += 1\n            k += 1\n\n    def merge_sort_recursive(nums: List[int], left: int, right: int) -> None:\n        if left < right:\n            mid = (left + right) // 2\n            merge_sort_recursive(nums, left, mid)\n            merge_sort_recursive(nums, mid + 1, right)\n            merge(nums, left, mid, right)\n\n    merge_sort_recursive(nums, 0, len(nums) - 1)\n\n\ndef main():\n    arr = [4, 1, 3, 9, 7]\n    merge_sort(arr)\n    print(arr)\n\n\nif __name__ == \"__main__\":\n    main()",
    "def merge_sort(arr):\n    if len(arr) == 1:\n        return arr\n    mid = len(arr)//2\n    left_arr = arr[:mid]\n    right_arr = arr[mid:]\n\n    left_arr = merge_sort(left_arr)\n    right_arr = merge_sort(right_arr)\n\n    return merge(left_arr, right_arr)\n\ndef merge(left_arr, right_arr):\n    result = []\n    while len(left_arr) and len(right_arr):\n        if left_arr[0] < right_arr[0]:\n            result.append(left_arr.pop(0))\n        else:\n            result.append(right_arr.pop(0))\n\n    while len(left_arr):\n        result.append(left_arr.pop(0))\n\n    while len(right_arr):\n        result.append(right_arr.pop(0))\n\n    return result\n\narr = [1, 4, 5, 3, 6, 7, 2]\nprint(merge_sort(arr))",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(array) == 1:\n        return array\n\n    mid_index = len(array) // 2\n    left = merge_sort(array[:mid_index])\n    right = merge_sort(array[mid_index:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    result = []\n\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n\n    if len(left) == 0:\n        result.extend(right)\n    else:\n        result.extend(left)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([2, 1, 4, 3, 6, 5]) == [1, 2, 3, 4, 5, 6]",
    "from typing import List\n\n\n# O(n * log n)\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    1. Divide the unsorted array into equal halves\n    2. Call merge sort on the left half\n    3. Call merge sort on the right half\n    4. Merge the sorted left half and the sorted right half\n    \"\"\"\n    # base case\n    if len(array) <= 1:\n        return array\n\n    middle = len(array) // 2\n\n    # recursive case\n    left = merge_sort(array[:middle])\n    right = merge_sort(array[middle:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result = []\n\n    # iterate over both lists\n    while left and right:\n        # if left is smaller than right, append left and remove it\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n\n    # if left is remaining, append it\n    if left:\n        result += left\n    if right:\n        result += right\n\n    return result\n\n\nif __name__ == \"__main__\":\n    nums = [1, 4, 2, 3, 10, 5]\n    assert merge_sort(nums) == [1, 2, 3, 4, 5, 10]",
    "from timeit import default_timer as timer\n\n\ndef merge_sort(arr):\n    \"\"\"Merge sort.\"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef main():\n    \"\"\"Print the unsorted list, sorted list and time elapsed.\"\"\"\n    unsorted_list = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6]\n    start_time = timer()\n    merge_sort(unsorted_list)\n    elapsed_time = timer() - start_time\n    print(unsorted_list)\n    print(elapsed_time)\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 6, 2, 5, 9, 8]) == [2, 4, 5, 6, 8, 9]",
    "from typing import List\n\n\n# Time complexity: O(n * log n)\n# Space complexity: O(n)\ndef merge_sort(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    merge_sort_helper(nums, 0, len(nums) - 1)\n\n\ndef merge_sort_helper(nums: List[int], left: int, right: int) -> None:\n    if left < right:\n        mid = (left + right) // 2\n        merge_sort_helper(nums, left, mid)\n        merge_sort_helper(nums, mid + 1, right)\n        merge(nums, left, mid, right)\n\n\ndef merge(nums: List[int], left: int, mid: int, right: int) -> None:\n    temp = []\n    i, j = left, mid + 1\n    while i <= mid and j <= right:\n        if nums[i] < nums[j]:\n            temp.append(nums[i])\n            i += 1\n        else:\n            temp.append(nums[j])\n            j += 1\n    if i <= mid:\n        temp.extend(nums[i:mid + 1])\n    if j <= right:\n        temp.extend(nums[j:right + 1])\n    nums[left:right + 1] = temp\n\n\n# Time complexity: O(n * log n)\n# Space complexity: O(log n)\ndef merge_sort_2(nums: List[int]) -> None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if len(nums) > 1:\n        mid = len(nums) // 2\n        left = nums[:mid]\n        right = nums[mid:]\n        merge_sort_2(left)\n        merge_sort_2(right)\n        merge_2(nums, left, right)\n\n\ndef merge_2(nums: List[int], left: List[int], right: List[int",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(array) < 2:\n        return array\n\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result += left[i:]\n    result += right[j:]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 5, 3, 2, 7, 6, 4]) == [1, 2, 3, 4, 5, 6, 7]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Divide and conquer algorithm.\n\n    :param array: given array to sort\n    :return: sorted array\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        merge(array, left, right)\n    return array\n\n\ndef merge(array: List[int], left: List[int], right: List[int]) -> None:\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        array[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        array[k] = right[j]\n        j += 1\n        k += 1\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12]",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge Sort\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n\n        return result\n\n    def sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = sort(arr[:mid])\n        right = sort(arr[mid:])\n\n        return merge(left, right)\n\n    return sort(arr)\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 5, 8, 4, 2, 9, 6, 0, 3, 7]) == sorted(\n        [1, 5, 8, 4, 2, 9, 6, 0, 3, 7]\n    )",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert merge_sort([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7]\n    assert merge_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert merge_sort([1, 2, 3]) == [1, 2, 3]\n    assert merge_sort([",
    "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    result = []\n\n    while left and right:\n        result.append(\n            left.pop(0) if left[0] <= right[0] else right.pop(0)\n        )\n\n    return result + left + right\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([5, 3, 2, 1, 4]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 5, 4]) == [1, 2, 3, 4, 5]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort algorithm.\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert merge_sort([1, 4, 6, 3, 5, 2]) == [1, 2, 3, 4, 5, 6]\n    assert merge_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert merge_sort([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert merge_sort([1, 2, 3]) == [1, 2, 3]\n    assert merge_sort([1, 2]) == [1, 2]\n    assert merge_sort([1]) == [1]",
    "from typing import List\n\n\ndef merge_sort(array: List[int]):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_array = array[:mid]\n        right_array = array[mid:]\n        merge_sort(left_array)\n        merge_sort(right_array)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left_array) and j < len(right_array):\n            if left_array[i] < right_array[j]:\n                array[k] = left_array[i]\n                i += 1\n            else:\n                array[k] = right_array[j]\n                j += 1\n            k += 1\n\n        while i < len(left_array):\n            array[k] = left_array[i]\n            i += 1\n            k += 1\n\n        while j < len(right_array):\n            array[k] = right_array[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    array: List[int] = [3, 1, 5, 7, 2, 4]\n    merge_sort(array)\n    print(array)",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr)//2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [10, 8, 9, 5, 1, 2]\n    merge_sort(arr)\n    print(arr)",
    "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    sorted_arr = merge_sort(arr)\n    print(sorted_arr)",
    "from typing import List\n\n\ndef merge_sort(array: List[int]):\n    \"\"\"\n    Merge sort algorithm.\n\n    :param array: given array\n    :return: sorted array\n    \"\"\"\n    if len(array) == 1:\n        return array\n\n    mid = len(array) // 2\n    left = array[:mid]\n    right = array[mid:]\n\n    merge_sort(left)\n    merge_sort(right)\n\n    i = 0\n    j = 0\n    k = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        array[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        array[k] = right[j]\n        j += 1\n        k += 1\n\n\ndef main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    merge_sort(array)\n    print(array)\n\n\nif __name__ == '__main__':\n    main()",
    "from timeit import timeit\n\n\ndef merge_sort(array):\n    \"\"\"\n    Sort the given array by using merge sort.\n\n    :param array: list\n    :return: sorted list\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    arr = [1, 6, 2, 3, 7, 4, 8, 9, 5]\n    print(timeit(lambda: merge_sort(arr), number=100))\n    print(merge_sort(arr))",
    "from typing import List\n\n\n# Time Complexity: O(n*log(n))\n# Space Complexity: O(n)\ndef merge_sort(arr: List[int]) -> None:\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n\nif __name__ == \"__main__\":\n    arr = [10, 7, 8, 9, 1, 5]\n    merge_sort(arr)\n    print(arr)",
    "from typing import List\n\n\n# Time complexity: O(nlogn)\n# Space complexity: O(n)\ndef merge_sort(array: List[int]) -> None:\n    \"\"\"\n    Do in-place merge sort.\n    :param array: list of integers\n    :return: None\n    \"\"\"\n    # 1. base case\n    if len(array) <= 1:\n        return\n\n    # 2. Divide\n    mid = len(array) // 2\n    left = array[:mid]\n    right = array[mid:]\n\n    # 3. Conquer (recursive)\n    merge_sort(left)\n    merge_sort(right)\n\n    # 4. Combine (merge)\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n        k += 1\n\n    # 5. Leftovers (post-processing)\n    while i < len(left):\n        array[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        array[k] = right[j]\n        j += 1\n        k += 1\n\n\n# Time complexity: O(nlogn)\n# Space complexity: O(n)\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result = []\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n    return result",
    "from typing import List\n\n\ndef merge_sort(array: List[int]):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef test(array):\n    merge_sort(array)\n    print(array)\n\n\nif __name__ == \"__main__\":\n    test([5, 4, 3, 2, 1])\n    test([1, 5, 4, 3, 2])\n    test([2, 4, 3, 1, 5])\n    test([1, 2, 3, 4, 5])\n    test([5, 3, 2, 1, 4])\n    test([3, 7, 3, 2, 1])",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"Merge sort.\n\n    Time complexity: O(n log n).\n    Space complexity: O(n).\n    \"\"\"\n    n = len(array)\n\n    def sort(array: List[int], left: int, right: int) -> None:\n        if right - left > 1:\n            mid = (left + right) // 2\n            sort(array, left, mid)\n            sort(array, mid, right)\n            merge(array, left, mid, right)\n\n    def merge(array: List[int], left: int, mid: int, right: int) -> None:\n        temp = []\n\n        i = left\n        j = mid\n\n        while i < mid and j < right:\n            if array[i] < array[j]:\n                temp.append(array[i])\n                i += 1\n            else:\n                temp.append(array[j])\n                j += 1\n\n        while i < mid:\n            temp.append(array[i])\n            i += 1\n\n        while j < right:\n            temp.append(array[j])\n            j += 1\n\n        for k in range(left, right):\n            array[k] = temp[k - left]\n\n    sort(array, 0, n)\n    return array\n\n\nif __name__ == '__main__':\n    # Print merge sort.\n    array = [1, 3, 2, 5, 7, 4, 6]\n    result = merge_sort(array)\n    print(result)",
    "from typing import List\n\n\ndef merge_sort(array: List[int]):\n    \"\"\"\n    :param array: The array to be sorted.\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_array = array[:mid]\n        right_array = array[mid:]\n        merge_sort(left_array)\n        merge_sort(right_array)\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left_array) and j < len(right_array):\n            if left_array[i] < right_array[j]:\n                array[k] = left_array[i]\n                i += 1\n            else:\n                array[k] = right_array[j]\n                j += 1\n            k += 1\n\n        while i < len(left_array):\n            array[k] = left_array[i]\n            i += 1\n            k += 1\n\n        while j < len(right_array):\n            array[k] = right_array[j]\n            j += 1\n            k += 1\n\n\ndef main():\n    array = [34, 5, 23, 11, 1, 5, 2, 4, 1]\n    merge_sort(array)\n    print(array)\n\n\nif __name__ == '__main__':\n    main()",
    "from typing import List\n\n\ndef merge_sort(array: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_part = array[:mid]\n        right_part = array[mid:]\n\n        merge_sort(left_part)\n        merge_sort(right_part)\n\n        i = j = k = 0\n\n        while i < len(left_part) and j < len(right_part):\n            if left_part[i] < right_part[j]:\n                array[k] = left_part[i]\n                i += 1\n            else:\n                array[k] = right_part[j]\n                j += 1\n            k += 1\n\n        while i < len(left_part):\n            array[k] = left_part[i]\n            i += 1\n            k += 1\n\n        while j < len(right_part):\n            array[k] = right_part[j]\n            j += 1\n            k += 1\n\n    return array\n\n\nif __name__ == \"__main__\":\n    print(merge_sort([3, 2, 5, 7, 3, 4, 6, 1, 5, 6, 3, 4]))"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}