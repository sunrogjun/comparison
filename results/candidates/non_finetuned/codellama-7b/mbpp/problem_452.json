{
  "problem": {
    "task_id": "MBPP/463",
    "prompt": "Write a function to find the maximum product subarray of the given array.",
    "canonical_solution": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far",
    "test_list": [
      "assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112",
      "assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ",
      "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"
    ],
    "challenge_test_list": [],
    "problem_id": 452
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "num_candidates": 100,
  "candidates": [
    "def max_product_subarray(array):\n    # Your code here\n    pass",
    "def max_subarray(arr, low, high):\n    if low == high:\n        return arr[low]\n\n    mid = (low + high) // 2\n    left_max = max_subarray(arr, low, mid)\n    right_max = max_subarray(arr, mid + 1, high)\n    cross_max = max_crossing_subarray(arr, low, mid, high)\n\n    return max(left_max, right_max, cross_max)\n\n\ndef max_crossing_subarray(arr, low, mid, high):\n    left_sum = float('-inf')\n    sum = 0\n    for i in range(mid, low - 1, -1):\n        sum += arr[i]\n        if sum > left_sum:\n            left_sum = sum\n            max_left = i\n\n    right_sum = float('-inf')\n    sum = 0\n    for i in range(mid + 1, high + 1):\n        sum += arr[i]\n        if sum > right_sum:\n            right_sum = sum\n            max_right = i\n\n    return arr[max_left:max_right + 1]\n\n\ndef max_subarray_eff(arr, low, high):\n    if low == high:\n        return arr[low]\n\n    mid = (low + high) // 2\n    left_max = max_subarray_eff(arr, low, mid)\n    right_max = max_subarray_eff(arr, mid + 1, high)\n    cross_max = max_crossing_subarray_eff(arr, low, mid, high)\n\n    return max(left_max, right_max, cross_max)\n\n\ndef max_crossing_subarray_eff(arr, low, mid, high):\n    left_sum = arr[mid]\n    sum = 0\n    for i in range(mid, low - 1, -1):\n        sum += arr[i]\n        if sum > left_sum:\n            left_sum = sum\n            max_left = i\n\n    right_sum = arr[mid + 1",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_subarray = float(\"-inf\")\n    max_ending_here = 1\n    min_ending_here = 1\n\n    for num in array:\n        temp_max = max_ending_here\n        max_ending_here = max(num, max_ending_here * num, min_ending_here * num)\n        min_ending_here = min(num, temp_max * num, min_ending_here * num)\n        max_subarray = max(max_subarray, max_ending_here)\n\n    return max_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([-10, -1, 2, 3, -10, 5, 2, -1]) == 30",
    "def max_product_subarray(arr):\n    if not arr: return\n    m1 = m2 = arr[0]\n    mx = m1\n    for i in range(1, len(arr)):\n        a = max(m1 * arr[i], m2 * arr[i], arr[i])\n        b = min(m1 * arr[i], m2 * arr[i], arr[i])\n        m1, m2 = a, b\n        mx = max(mx, a)\n    return mx\n\n\ndef main():\n    arr = [2, 3, -2, 4]\n    print(max_product_subarray(arr))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_subarray(nums: List[int]) -> int:\n    max_product = nums[0]\n    current_max = nums[0]\n    current_min = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        # update current_max and current_min\n        current_max = max(num, num * current_max, num * current_min)\n        current_min = min(num, num * current_max, num * current_min)\n\n        # update max_product\n        max_product = max(max_product, current_max)\n\n    return max_product\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_subarray_dp(nums: List[int]) -> int:\n    if not nums:\n        return 0\n\n    # set the first element as the max product\n    max_product = nums[0]\n\n    # set the first element as the current max and min product\n    current_max = nums[0]\n    current_min = nums[0]\n\n    # traverse the array\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        # update current_max and current_min\n        current_max = max(num, num * current_max, num * current_min)\n        current_min = min(num, num * current_max, num * current_min)\n\n        # update max_product\n        max_product = max(max_product, current_max)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_subarray([-1, 2, 3, -4]))\n    print(max_subarray_dp([-1, 2, 3, -4]))",
    "from typing import List\n\n\ndef max_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i - 1] > 0:\n            arr[i] = arr[i] * arr[i - 1]\n        else:\n            arr[i] = arr[i]\n        max_product = max(max_product, arr[i])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_subarray([-2, -3, -1, -2, -1, 2, 1, -5, 4]) == 6",
    "def max_product_subarray(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_subarray_prod = float('-inf')\n    min_subarray_prod = float('-inf')\n    max_subarray_prod_curr = 1\n    min_subarray_prod_curr = 1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            max_subarray_prod_curr, min_subarray_prod_curr = min_subarray_prod_curr, max_subarray_prod_curr\n        max_subarray_prod_curr = max(max_subarray_prod_curr * arr[i], arr[i])\n        min_subarray_prod_curr = min(min_subarray_prod_curr * arr[i], arr[i])\n        max_subarray_prod = max(max_subarray_prod, max_subarray_prod_curr)\n    return max_subarray_prod\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, -2, 4]\n    print(max_product_subarray(arr))",
    "def max_product_subarray(arr):\n    \"\"\"\n    :param arr: list of ints\n    :return: int\n    \"\"\"\n    n = len(arr)\n    max_sub = [1 for _ in range(n)]\n    min_sub = [1 for _ in range(n)]\n    max_so_far = -1000000000\n    min_so_far = 1000000000\n    for i in range(n):\n        max_sub[i] = max(max_sub[i - 1] * arr[i], arr[i], min_sub[i - 1] * arr[i])\n        min_sub[i] = min(min_sub[i - 1] * arr[i], arr[i], max_sub[i - 1] * arr[i])\n        max_so_far = max(max_so_far, max_sub[i])\n    return max_so_far\n\n\ndef main():\n    print(max_product_subarray([-2, 3, -4, 5, -1]))\n\n\nif __name__ == \"__main__\":\n    main()",
    "from typing import List\n\n\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    nums_length = len(nums)\n\n    if nums_length == 0:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_subarray_product = nums[0]\n\n    for i in range(1, nums_length):\n        current = nums[i]\n\n        if current < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(max_product * current, current)\n        min_product = min(min_product * current, current)\n\n        max_subarray_product = max(max_subarray_product, max_product)\n\n    return max_subarray_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    cur_min = cur_max = global_max = arr[0]\n\n    for num in arr[1:]:\n        cur_min, cur_max = (\n            min(cur_min * num, cur_max * num, num),\n            max(cur_min * num, cur_max * num, num),\n        )\n        global_max = max(global_max, cur_max)\n\n    return global_max\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0\n    assert max_product_subarray([0, 2]) == 2\n    assert max_product_subarray([-2, -3, -1]) == -3",
    "def max_product(arr):\n    if len(arr) < 2:\n        return\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    for num in arr[1:]:\n        if num > 0:\n            max_ending_here = max(max_ending_here * num, num)\n            min_ending_here = min(min_ending_here * num, num)\n        elif num == 0:\n            max_ending_here = num\n            min_ending_here = num\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * num, num)\n            min_ending_here = min(temp * num, num)\n\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\ndef main():\n    print(\"Maximum product subarray: \" + str(max_product([2, 3, -2, 4])))\n    print(\"Maximum product subarray: \" + str(max_product([-2, 0, -1])))\n\n\nmain()\n\n\"\"\"\nTime complexity: O(n)\nSpace complexity: O(1)\n\"\"\"",
    "from typing import List\n\n\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_crossing = nums[0]\n\n    for num in nums[1:]:\n        if num > 0:\n            max_so_far = max(max_so_far * num, num)\n            min_so_far = min(min_so_far * num, num)\n        elif num == 0:\n            max_so_far = max_crossing = num\n            min_so_far = num\n        else:\n            max_so_far = max_crossing\n            min_so_far = min_crossing\n            max_crossing = num\n\n    return max(max_so_far, max_crossing)\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0",
    "def max_product(arr):\n    \"\"\"\n    :param arr: list[int]\n    :return: int\n    \"\"\"\n    max_prod = arr[0]\n    min_prod = arr[0]\n    prod = arr[0]\n    for i in range(1, len(arr)):\n        cur = arr[i]\n        if cur < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(max_prod * cur, cur)\n        min_prod = min(min_prod * cur, cur)\n        prod = max(prod, max_prod)\n    return prod\n\n\ndef test_max_product():\n    assert max_product([2, 3, -2, 4, -1]) == 6\n    assert max_product([-2, 0, -1]) == 0\n    assert max_product([0, 2]) == 2\n\n\nif __name__ == '__main__':\n    test_max_product()",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = 0\n    min_product = 0\n    max_subarray_product = 0\n    for num in arr:\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        max_subarray_product = max(max_product, max_subarray_product)\n\n    return max_subarray_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(array) == 0:\n        raise ValueError(\"Array cannot be empty\")\n\n    max_prod = array[0]\n    min_prod = array[0]\n    max_prod_array = array[0]\n\n    for i in range(1, len(array)):\n        num = array[i]\n\n        # max_prod and min_prod are the max and min products of the subarray up to the current index\n        max_prod, min_prod = (\n            max(num, max_prod * num, min_prod * num),\n            min(num, max_prod * num, min_prod * num),\n        )\n        max_prod_array = max(max_prod_array, max_prod)\n\n    return max_prod_array\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0\n    assert max_product_subarray([2, -5, -2, -4, 3]) == 24",
    "def max_product(arr):\n    # Find the max and min subarray values and their starting and ending indexes\n    min_prod, max_prod = float('inf'), float('-inf')\n    min_prod_start, max_prod_start = 0, 0\n    min_prod_end, max_prod_end = 0, 0\n\n    for i in range(len(arr)):\n        if arr[i] > max_prod:\n            max_prod = arr[i]\n            max_prod_start = i\n            max_prod_end = i\n        elif arr[i] > max_prod:\n            max_prod_end = i\n\n        if arr[i] < min_prod:\n            min_prod = arr[i]\n            min_prod_start = i\n            min_prod_end = i\n        elif arr[i] < min_prod:\n            min_prod_end = i\n\n    # Handle subarrays that are only one element\n    if max_prod == min_prod:\n        return arr[max_prod_start]\n\n    # Return the max product\n    return max(max_prod, arr[max_prod_end] * arr[min_prod_start])",
    "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = arr[0]\n\n    for i in range(len(arr)):\n        if i == 0:\n            min_product = arr[i]\n            max_product = arr[i]\n        else:\n            min_product = min(arr[i], min_product * arr[i], max_product * arr[i])\n            max_product = max(arr[i], min_product * arr[i], max_product * arr[i])\n\n        if max_product > max_product:\n            max_product = max_product\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4]) == 6",
    "def max_product_subarray(arr):\n    # TODO: Write your code here\n    if len(arr) == 0:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    res = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = max_so_far\n        max_so_far = max(max_so_far*arr[i], min_so_far*arr[i], arr[i])\n        min_so_far = min(temp*arr[i], min_so_far*arr[i], arr[i])\n\n        res = max(res, max_so_far)\n\n    return res",
    "def max_product_subarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = nums[0]\n    for i in nums[1:]:\n        if i > 0:\n            max_so_far, min_so_far = max(i, max_so_far * i), min(i, min_so_far * i)\n        else:\n            max_so_far, min_so_far = max(i, min_so_far * i), min(i, max_so_far * i)\n        result = max(max_so_far, result)\n    return result\n\n\ndef test_max_product_subarray():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0\n\n\nif __name__ == '__main__':\n    test_max_product_subarray()",
    "from typing import List\n\n\n# O(n) time | O(n) space\ndef maxProduct(array: List[int]) -> int:\n    # O(1)\n    max_so_far = array[0]\n    min_so_far = array[0]\n    max_product = array[0]\n\n    for i in range(1, len(array)):\n        # O(1)\n        curr_num = array[i]\n\n        # O(1)\n        temp_max = max_so_far\n        temp_min = min_so_far\n\n        # O(1)\n        max_so_far = max(max(temp_max * curr_num, temp_min * curr_num), curr_num)\n        min_so_far = min(min(temp_max * curr_num, temp_min * curr_num), curr_num)\n\n        # O(1)\n        max_product = max(max_product, max_so_far)\n\n    # O(1)\n    return max_product\n\n\nprint(maxProduct([2, 3, -2, 4]))",
    "def find_max_product(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0]*arr[1], arr[0], arr[1])\n\n    max_product = arr[0] * arr[1]\n    min_product = arr[0] * arr[1]\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] > 0:\n            max_product = max(max_product*arr[i], arr[i], max_so_far*arr[i])\n            min_product = min(min_product*arr[i], arr[i], min_so_far*arr[i])\n        else:\n            tmp = max_product\n            max_product = max(min_product*arr[i], arr[i], min_so_far*arr[i])\n            min_product = min(tmp*arr[i], arr[i], max_so_far*arr[i])\n        max_so_far = max(max_so_far*arr[i], arr[i])\n        min_so_far = min(min_so_far*arr[i], arr[i])\n\n    return max(max_product, max_so_far)\n\n\narr = [2, 3, -2, 4]\nprint(find_max_product(arr))",
    "def max_product_subarray(array):\n    if not array:\n        return\n    max_so_far = min_so_far = array[0]\n    result = array[0]\n    for i in array[1:]:\n        max_so_far = max(i, max_so_far * i)\n        min_so_far = min(i, min_so_far * i)\n        result = max(result, max_so_far)\n    return result\n\n\nif __name__ == \"__main__\":\n    print(max_product_subarray([2, 3, -2, 4]))\n    print(max_product_subarray([-2, 0, -1]))",
    "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_product = arr[0]\n    min_product = arr[0]\n    max_product_subarray = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_product, min_product = max(arr[i], max_product * arr[i]), min(arr[i], min_product * arr[i])\n        elif arr[i] == 0:\n            max_product, min_product = 0, 0\n        else:\n            max_product, min_product = min(arr[i], max_product * arr[i]), max(arr[i], min_product * arr[i])\n\n        max_product_subarray = max(max_product_subarray, max_product)\n\n    return max_product_subarray\n\n\nif __name__ == \"__main__\":\n    arr: List[int] = [2, 3, -2, 4, -2, 2]\n    assert max_product(arr) == 6\n\n    arr = [-2, 0, -1]\n    assert max_product(arr) == 0",
    "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_sub = nums[0]\n        min_sub = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_sub, min_sub = min_sub, max_sub\n\n            max_sub = max(max_sub * nums[i], nums[i])\n            min_sub = min(min_sub * nums[i], nums[i])\n\n            result = max(max_sub, result)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    inp = [2, 3, -2, 4]\n    out = 6\n    res = Solution().maxProduct(inp)\n    assert res == out, (res, out)\n\n    inp = [-2, 0, -1]\n    out = 0\n    res = Solution().maxProduct(inp)\n    assert res == out, (res, out)\n\n    inp = [-2, 3, -4]\n    out = 24\n    res = Solution().maxProduct(inp)\n    assert res == out, (res, out)",
    "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n\n    if len(arr) == 0:\n        return 0\n\n    min_product = max_product = arr[0]\n    for num in arr[1:]:\n        if num > 0:\n            max_product = max(max_product * num, num)\n            min_product = min(min_product * num, num)\n        elif num == 0:\n            min_product = max_product = 0\n        else:\n            max_product = max(min_product * num, num)\n            min_product = min(max_product * num, num)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, -5, -2, -4, 3]) == 24",
    "def max_product_subarray(arr):\n    \"\"\"\n    :param: arr - list of integers\n    return: int - maximum product subarray\n    TODO: Write your solution here\n    \"\"\"\n    if len(arr) == 0:\n        return None\n\n    # for all subarrays of length 1, the product is the subarray itself\n    # so the maximum product subarray is the max product of any subarray\n    max_product = max(arr)\n\n    # for all subarrays of length 2, the maximum product is the product of\n    # the two numbers in the array\n    # max_product = max(arr[0] * arr[1], arr[-1] * arr[-2])\n\n    # for all subarrays of length 3, we can find the maximum product of any\n    # subarray of length 2 and multiply it with the third number in the array\n    # max_product = max(arr[0] * arr[1] * arr[2], arr[1] * arr[2] * arr[0],\n    # arr[2] * arr[0] * arr[1])\n\n    # for all subarrays of length 4, we can find the maximum product of any\n    # subarray of length 3 and multiply it with the last number in the array\n    # max_product = max(arr[0] * arr[1] * arr[2] * arr[3], arr[1] * arr[2] *\n    # arr[3] * arr[0], arr[2] * arr[3] * arr[0] * arr[1])\n\n    # for all subarrays of length 5, we can find the maximum product of any\n    # subarray of length 4 and multiply it with the last number in the array\n    # max_product = max(arr[0] * arr[1] * arr[2] * arr[3] * arr[4],\n    # arr[1] * arr[2] * arr[3] * arr[4] * arr[0], arr[2] * arr[3] * arr[4]\n    # * arr[0] * arr[1])\n\n    # for all subarrays of length 6",
    "def max_sub_array(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n\n    max_so_far = max_ending_here = nums[0]\n\n    for num in nums[1:]:\n        max_ending_here = max(max_ending_here*num, num)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    min_so_far = array[0]\n    max_so_far = array[0]\n    max_global = array[0]\n\n    for i in range(1, len(array)):\n        curr = array[i]\n        min_so_far = min(min(curr, min_so_far * curr), max_so_far * curr)\n        max_so_far = max(max(curr, max_so_far * curr), min_so_far * curr)\n        max_global = max(max_global, max_so_far)\n\n    return max_global\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0",
    "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_ending_here = arr[0]\n\n    for i in arr[1:]:\n        if i < 0:\n            max_so_far, min_so_far = min(min_so_far, max_ending_here), max(min_so_far, max_ending_here)\n\n        max_ending_here = max(i, max_ending_here * i)\n\n    return max(max_so_far, min_so_far, max_ending_here)\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 3, -2, 4]))",
    "from typing import List\n\n\n# O(n)\ndef max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_prod: int = nums[0]\n    min_prod: int = nums[0]\n    res: int = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        # case 1: num is positive\n        # max_prod, min_prod = num, min(num, min_prod * num)\n        # case 2: num is negative\n        # max_prod, min_prod = min(max_prod * num, num), num\n\n        # we need to find the maximum product subarray\n        # so, we will always keep track of the maximum product and the minimum product\n        # if the current num is positive, we will update the minimum product\n        # if the current num is negative, we will update the maximum product\n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        res = max(res, max_prod)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4]) == 6\n    assert max_product([-2, 0, -1]) == 0",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_prod = arr[0]\n    curr_max = arr[0]\n    curr_min = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n\n        # Case 1: num > 0\n        if num > 0:\n            curr_max = max(num, curr_max * num)\n            curr_min = min(num, curr_min * num)\n        # Case 2: num == 0\n        elif num == 0:\n            curr_max = num\n            curr_min = num\n        # Case 3: num < 0\n        else:\n            temp = curr_max\n            curr_max = max(curr_min * num, curr_max * num)\n            curr_min = min(curr_min * num, temp * num)\n\n        max_prod = max(max_prod, curr_max)\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, -3, -2, 2, 7]) == 14",
    "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef max_product_subarray(nums: List[int]) -> int:\n    if len(nums) == 0:\n        raise ValueError(\"Empty array\")\n\n    max_product = nums[0]\n    curr_max = nums[0]\n    curr_min = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        curr_max, curr_min = (\n            max(curr_max * num, curr_min * num, num),\n            min(curr_max * num, curr_min * num, num),\n        )\n\n        max_product = max(max_product, curr_max)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product_subarray([-2, 3, -4]))\n    print(max_product_subarray([-1, 1, -2, 1, -1, 1, 3, 5]))\n    print(max_product_subarray([-1, 1, -2, 1, -1, 1]))\n    print(max_product_subarray([-1, 1, -2, 1, -1, 1, 3, 5, 10]))",
    "def max_product(array):\n    \"\"\"\n    :param: array - input integer array\n    Return: int - maximum product subarray\n    TODO: Write your solution here\n    \"\"\"\n    # A: max_product_from_i_to_j = max(max(array[i:j+1]) * max(array[i:j+1]), min(array[i:j+1]) * min(array[i:j+1]))\n    # B: max_product_from_i_to_j = max(max_product_from_i_to_k * min(array[k+1:j+1]), min_product_from_i_to_k * max(array[k+1:j+1]))\n    # C: max_product_from_i_to_j = max(max_product_from_i_to_k * min(array[k+1:j+1]), max_product_from_k_to_j * min(array[i:j]))\n\n    # Edge case: empty array\n    if not array:\n        return None\n\n    # Edge case: one element array\n    if len(array) == 1:\n        return array[0]\n\n    # Initialize\n    max_product = array[0]\n    min_product = array[0]\n    max_product_from_i_to_j = array[0]\n\n    # Iterate through the array\n    for num in array[1:]:\n        max_product, min_product = (\n            max(num, max_product * num, min_product * num),\n            min(num, max_product * num, min_product * num),\n        )\n        max_product_from_i_to_j = max(max_product_from_i_to_j * num, num)\n\n    return max_product_from_i_to_j\n\n\n# Test cases\nprint(max_product([2, 3, -2, 4]))\nprint(max_product([-2, 0, -1]))\nprint(max_product([-2, 3, -4]))\nprint(max_product([2, -5, -2, -",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_product = array[0]\n    max_ending = array[0]\n    min_ending = array[0]\n\n    for i in range(1, len(array)):\n        num = array[i]\n        max_ending, min_ending = max(num, max_ending * num, min_ending * num), min(num, max_ending * num, min_ending * num)\n        max_product = max(max_product, max_ending)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_product_subarray([2, 3, -2, 4]))\n    print(max_product_subarray([-2, 0, -1]))",
    "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef max_product(arr: List[int]) -> int:\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n\n        if num > 0:\n            max_so_far = max(max_so_far * num, num)\n            min_so_far = min(min_so_far * num, num)\n        elif num == 0:\n            max_so_far = 0\n            min_so_far = 0\n        else:\n            max_so_far = max(min_so_far * num, num)\n            min_so_far = min(max_so_far * num, num)\n\n        result = max(result, max_so_far)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 3, -2, 4]))\n    print(max_product([-2, 0, -1]))",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_subarray(nums: List[int]) -> int:\n    max_subarray = nums[0]\n    max_subarray_so_far = nums[0]\n    min_subarray = nums[0]\n    min_subarray_so_far = nums[0]\n\n    for i in range(1, len(nums)):\n        # If the current number is positive, then the subarray\n        # starting from the previous number can only be increased\n        # by adding it to the subarray.\n        if nums[i] > 0:\n            max_subarray = max(max_subarray * nums[i], nums[i])\n            min_subarray = min(min_subarray * nums[i], nums[i])\n        # If the current number is negative, then the subarray\n        # starting from the previous number can only be decreased\n        # by multiplying it with the current number.\n        elif nums[i] < 0:\n            max_subarray = max(max_subarray_so_far * nums[i], nums[i])\n            min_subarray = min(min_subarray_so_far * nums[i], nums[i])\n        # If the current number is zero, then the subarray\n        # starting from the previous number can either be\n        # increased or decreased by multiplying it with the\n        # current number.\n        else:\n            max_subarray = max(max_subarray_so_far * nums[i], nums[i])\n            min_subarray = min(min_subarray_so_far * nums[i], nums[i])\n\n        max_subarray_so_far = max(max_subarray, max_subarray_so_far)\n        min_subarray_so_far = min(min_subarray, min_subarray_so_far)\n\n    return max(max_subarray_so_far, min_subarray_so_far)\n\n\n# Time complexity: O(n)\n#",
    "def max_product(arr):\n    \"\"\"\n    :param arr: list[int]\n    :return: int\n    \"\"\"\n    max_product_so_far = arr[0]\n    min_product_so_far = arr[0]\n    max_product_ending_here = arr[0]\n\n    for i in range(1, len(arr)):\n        current_num = arr[i]\n        max_product_ending_here = max(current_num, current_num * max_product_ending_here, current_num * min_product_so_far)\n        min_product_so_far = min(current_num, current_num * max_product_ending_here, current_num * min_product_so_far)\n        max_product_so_far = max(max_product_so_far, max_product_ending_here)\n\n    return max_product_so_far\n\n\nif __name__ == \"__main__\":\n    print(max_product([-2, 3, -4]))\n    print(max_product([-2, 3, -4, 2]))",
    "def max_subarray(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_sum = arr[0]\n    max_curr = arr[0]\n\n    for i in range(1, len(arr)):\n        max_curr = max(arr[i], max_curr * arr[i])\n        max_sum = max(max_sum, max_curr)\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    assert max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) == 9",
    "from typing import List\n\n\ndef max_product(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(array) == 0:\n        return 0\n\n    maximum = array[0]\n    minimum = array[0]\n    maximum_subarray = array[0]\n\n    for num in array[1:]:\n        if num < 0:\n            maximum, minimum = minimum, maximum\n\n        maximum = max(maximum * num, num)\n        minimum = min(minimum * num, num)\n        maximum_subarray = max(maximum, maximum_subarray)\n\n    return maximum_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4]) == 6",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_subarray(array: List[int]) -> int:\n    max_ending_here = array[0]\n    min_ending_here = array[0]\n    max_so_far = array[0]\n    for num in array[1:]:\n        if num > 0:\n            max_ending_here = max(max_ending_here * num, num)\n            min_ending_here = min(min_ending_here * num, num)\n        else:\n            max_ending_here = max(min_ending_here * num, num)\n            min_ending_here = min(max_ending_here * num, num)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_subarray_with_zero(array: List[int]) -> int:\n    max_ending_here = array[0]\n    min_ending_here = array[0]\n    max_so_far = array[0]\n\n    for num in array[1:]:\n        if num == 0:\n            max_ending_here = 0\n            min_ending_here = 0\n        else:\n            if num > 0:\n                max_ending_here = max(max_ending_here * num, num)\n                min_ending_here = min(min_ending_here * num, num)\n            else:\n                temp = max_ending_here\n                max_ending_here = max(min_ending_here * num, num)\n                min_ending_here = min(temp * num, num)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    array = [-10, -1, 2, 3, 4, -8, -3, 5]\n    assert max_product_subarray(array",
    "from typing import List\n\n\ndef max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n\n    # Initialize max_product to be the first element\n    max_product = nums[0]\n    # Initialize min_product to be the first element\n    min_product = nums[0]\n\n    # Initialize max_subarray_product to be the first element\n    max_subarray_product = nums[0]\n    # Initialize min_subarray_product to be the first element\n    min_subarray_product = nums[0]\n\n    for i in range(1, len(nums)):\n        current_num = nums[i]\n        current_num_product = current_num * max_product\n\n        current_num_product_product = min(\n            current_num_product,\n            current_num_product / min_product,\n            current_num\n        )\n\n        current_num_product_sum = max(\n            current_num_product,\n            current_num_product / max_product,\n            current_num\n        )\n\n        max_product = current_num_product_sum\n        min_product = current_num_product_product\n\n        max_subarray_product = max(max_subarray_product, max_product)\n        min_subarray_product = min(min_subarray_product, min_product)\n\n    return max_subarray_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4]) == 6\n    assert max_product([-2, 0, -1]) == 0",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    if len(array) == 0:\n        return 0\n\n    if len(array) == 1:\n        return array[0]\n\n    max_subarray = array[0]\n    max_ending = array[0]\n    min_ending = array[0]\n\n    for i in range(1, len(array)):\n        num = array[i]\n\n        max_ending = max(max_ending * num, num)\n        min_ending = min(min_ending * num, num)\n\n        max_subarray = max(max_subarray, max_ending)\n\n    return max_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0",
    "from typing import List\n\n\ndef max_subarray_product(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    length = len(array)\n\n    if length == 0:\n        return 0\n\n    max_product = array[0]\n    min_product = array[0]\n\n    for i in range(1, length):\n        temp = max_product\n        max_product = max(max(array[i], min_product * array[i]), temp * array[i])\n        min_product = min(min(array[i], max_product * array[i]), temp * array[i])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_subarray_product([2, 4, -2, 4, -3, -1, 5, -1, 1, -3, -5]) == 16",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    min_so_far = array[0]\n    max_so_far = array[0]\n    max_global = array[0]\n\n    for num in array[1:]:\n        if num > 0:\n            max_so_far = max(max_so_far * num, num)\n            min_so_far = min(min_so_far * num, num)\n        else:\n            temp = min_so_far\n            min_so_far = min(max_so_far * num, num)\n            max_so_far = max(temp * num, num)\n\n        max_global = max(max_global, max_so_far)\n\n    return max_global\n\n\nif __name__ == \"__main__\":\n    arr = [-10, -1, 2, 3, -2, 20]\n    max_product = max_product_subarray(arr)\n    print(max_product)",
    "def max_product(arr):\n    \"\"\"\n    :param: arr - input array\n    TODO: complete this function\n    \"\"\"\n    max_prod = arr[0]\n    max_ending = arr[0]\n    min_ending = arr[0]\n    for i in range(1, len(arr)):\n        prod = max_ending * arr[i]\n        min_prod = min_ending * arr[i]\n        max_ending = max(arr[i], max_ending * arr[i], min_ending * arr[i])\n        min_ending = min(arr[i], prod, min_prod)\n        max_prod = max(max_prod, max_ending)\n    return max_prod\n\n\ndef main():\n    arr = [1, 2, -1, 3, 6, 0, -100, 10]\n    print(\"Maximum Subarray Product is \" + str(max_product(arr)))\n    print(\"Maximum Subarray Product is \" + str(max_product([-1, -2])))\n    print(\"Maximum Subarray Product is \" + str(max_product([-1000, 1, 2, 3, 4, 5, 6])))\n\n\nmain()",
    "from typing import List\n\n\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_so_far = nums[0]\n    curr_max = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_max = max(nums[i], curr_max * nums[i])\n        max_so_far = max(max_so_far, curr_max)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_sub_array([-2, -3, 4, -1, -2, 1, 5, -3]) == 7",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_global = arr[0]\n\n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, min_so_far * curr, max_so_far * curr)\n        temp_min = min(curr, min_so_far * curr, max_so_far * curr)\n\n        min_so_far = temp_min\n        max_so_far = temp_max\n\n        max_global = max(max_so_far, max_global)\n\n    return max_global\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, -2, 4]\n    assert max_product_subarray(arr) == 6\n\n    arr = [-2, 0, -1]\n    assert max_product_subarray(arr) == 0",
    "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_product = nums[0]\n    max_end = nums[0]\n    min_end = nums[0]\n    for i in nums[1:]:\n        if i < 0:\n            max_end, min_end = min_end, max_end\n        max_end = max(i, max_end * i)\n        min_end = min(i, min_end * i)\n        max_product = max(max_product, max_end)\n    return max_product\n\n\ndef max_product_v2(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_product = nums[0]\n    max_end = nums[0]\n    min_end = nums[0]\n    for i in nums[1:]:\n        if i < 0:\n            max_end, min_end = min_end, max_end\n        max_end = max(i, max_end * i)\n        min_end = min(i, min_end * i)\n        max_product = max(max_product, max_end)\n    return max_product\n\n\ndef max_product_v3(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_product = nums[0]\n    max_end = nums[0]\n    min_end = nums[0]\n    for i in nums[1:]:\n        if i < 0:\n            max_end, min_end = min_end, max_end\n        max_end = max(i, max_end * i)\n        min_end = min(i, min_end * i)\n        max_product = max(max_product, max_end)\n    return max_product",
    "def max_product_subarray(arr):\n    max_product = arr[0]\n    min_product = arr[0]\n    max_global = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_product, min_product = max(arr[i], max_product * arr[i], min_product * arr[i]), min(arr[i], max_product * arr[i], min_product * arr[i])\n        elif arr[i] == 0:\n            max_product, min_product = 0, 0\n        else:\n            max_product, min_product = min(arr[i], max_product * arr[i], min_product * arr[i]), max(arr[i], max_product * arr[i], min_product * arr[i])\n\n        max_global = max(max_global, max_product)\n\n    return max_global\n\ndef max_product_subarray_optimized(arr):\n    max_product = arr[0]\n    min_product = arr[0]\n    max_global = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_product, min_product = max(arr[i], max_product * arr[i], min_product * arr[i]), min(arr[i], max_product * arr[i], min_product * arr[i])\n        elif arr[i] == 0:\n            max_product, min_product = 0, 0\n        else:\n            max_product, min_product = min(arr[i], max_product * arr[i], min_product * arr[i]), max(arr[i], max_product * arr[i], min_product * arr[i])\n\n        max_global = max(max_global, max_product)\n\n    return max_global\n\ndef main():\n    arr = [-1, -2, -3, -4, -5]\n    print(max_product_subarray(arr))\n\n    arr = [1, -2, -3, -",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    current_max = local_max = local_min = array[0]\n\n    for num in array[1:]:\n        if num > 0:\n            local_max, local_min = max(num, local_max * num), min(num, local_min * num)\n        else:\n            local_max, local_min = max(num, local_min * num), min(num, local_max * num)\n\n        current_max = max(current_max, local_max)\n\n    return current_max\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([-4, -3, -2, -1, 7, 8, -2, 3, 2, 1, -1, 4]) == 230",
    "def max_subarray(arr):\n    max_sub = arr[0]\n    curr_max = arr[0]\n\n    for i in range(1, len(arr)):\n        curr_max = max(arr[i], curr_max * arr[i])\n        max_sub = max(max_sub, curr_max)\n\n    return max_sub\n\n\nif __name__ == \"__main__\":\n    print(max_subarray([2, 3, -2, 4]))\n    print(max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]))",
    "def max_product_subarray(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_prod = arr[0]\n    min_prod = arr[0]\n    max_global = arr[0]\n\n    for num in arr[1:]:\n        if num > 0:\n            max_prod, min_prod = max(num, max_prod * num), min(num, min_prod * num)\n        else:\n            max_prod, min_prod = min(num, max_prod * num), max(num, min_prod * num)\n\n        max_global = max(max_prod, max_global)\n\n    return max_global\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, -2, 4]\n    print(max_product_subarray(arr))",
    "from typing import List\n\n\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_prod = nums[0]\n    curr_min = nums[0]\n    curr_max = nums[0]\n\n    for num in nums[1:]:\n        if num > 0:\n            curr_max, curr_min = max(num, curr_max * num), min(num, curr_min * num)\n        else:\n            curr_max, curr_min = max(num, curr_min * num), min(num, curr_max * num)\n\n        max_prod = max(max_prod, curr_max)\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6",
    "def max_sub_array(arr):\n    \"\"\"\n    :param arr: list\n    :return: int\n    \"\"\"\n    max_so_far = arr[0]\n    curr_max = arr[0]\n    for num in arr[1:]:\n        curr_max = max(num, curr_max * num)\n        max_so_far = max(max_so_far, curr_max)\n    return max_so_far",
    "from typing import List\n\n\n# O(n)\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    global_max = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n\n        max_so_far = max(num, max_so_far * num)\n        min_so_far = min(num, min_so_far * num)\n\n        global_max = max(global_max, max_so_far)\n\n    return global_max\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6",
    "from typing import List\n\n\ndef max_product(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = array[0]\n    min_product = array[0]\n    max_prod_subarray = array[0]\n\n    for num in array[1:]:\n        if num > 0:\n            max_product, min_product = max(num, max_product * num), min(num, min_product * num)\n        else:\n            max_product, min_product = max(num, min_product * num), min(num, max_product * num)\n\n        max_prod_subarray = max(max_product, max_prod_subarray)\n\n    return max_prod_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4]) == 6\n    assert max_product([-2, 0, -1]) == 0",
    "def max_product_subarray(array):\n    if len(array) == 0:\n        return 0\n\n    max_product = array[0]\n    min_product = array[0]\n    max_subarray = array[0]\n    for i in range(1, len(array)):\n        # current subarray ends with ith element\n        # check for max product subarray\n        max_product = max(array[i], max_product * array[i])\n        min_product = min(array[i], min_product * array[i])\n        max_subarray = max(max_product, max_subarray)\n\n    return max_subarray\n\ndef main():\n    print(max_product_subarray([-2, 3, -4]))\n    print(max_product_subarray([2, 3, -2, 4]))\n    print(max_product_subarray([-4, 2, 0, 3, -5]))\n\n\nmain()",
    "def max_subarray(arr):\n    if len(arr) == 0:\n        return 0\n\n    max_product = 0\n    product = 1\n    for i in range(len(arr)):\n        product *= arr[i]\n        max_product = max(max_product, product)\n        if product == 0:\n            product = 1\n        else:\n            product = product // arr[i]\n    return max_product\n\n\ndef max_subarray2(arr):\n    if len(arr) == 0:\n        return 0\n\n    max_product = 0\n    product = 1\n    for i in range(len(arr)):\n        product *= arr[i]\n        max_product = max(max_product, product)\n        if product == 0:\n            product = 1\n        else:\n            product = product // arr[i]\n    return max_product\n\n\n# Test cases\nprint(max_subarray2([-1, -2, -3, -4, -5]))",
    "def max_product(arr):\n    \"\"\"\n    Time complexity: O(n).\n    Space complexity: O(1).\n    \"\"\"\n    # Find max subarray for positive and negative numbers.\n    if not arr or len(arr) == 0:\n        return 0\n\n    pos_max = 0\n    neg_max = 0\n    pos_min = 0\n    neg_min = 0\n    max_product = arr[0]\n\n    for num in arr:\n        if num > 0:\n            # If num is positive, then update pos_max, pos_min.\n            if num > pos_max:\n                pos_max = num\n                pos_min = num\n            elif num < pos_max:\n                pos_max = num\n            elif num == pos_max:\n                pos_min = num\n\n            # Update neg_max, neg_min.\n            if num < neg_max:\n                neg_max = num\n                neg_min = num\n            elif num > neg_max:\n                neg_max = num\n            elif num == neg_max:\n                neg_min = num\n        elif num == 0:\n            pos_max = 0\n            neg_max = 0\n            pos_min = 0\n            neg_min = 0\n        else:\n            # If num is negative, then update neg_max, neg_min.\n            if num < neg_min:\n                neg_min = num\n                neg_max = num\n            elif num > neg_min:\n                neg_min = num\n            elif num == neg_min:\n                neg_max = num\n\n            # Update pos_max, pos_min.\n            if num > pos_min:\n                pos_min = num\n                pos_max = num\n            elif num < pos_min:\n                pos_min = num\n            elif num == pos_min:\n                pos_max = num\n\n        # Update max_product.\n        if pos_max * neg_min > max_product:\n            max_product = pos_max * neg_min\n\n    return max_product\n\n\ndef main():\n    arr = [1, 2, -1,",
    "def max_subarray(arr):\n    if len(arr) == 0:\n        return 0\n\n    max_prod = arr[0]\n    max_curr = arr[0]\n    min_curr = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n        max_curr = max(max_curr * num, num)\n        min_curr = min(min_curr * num, num)\n        max_prod = max(max_prod, max_curr)\n\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    print(max_subarray([-10, 2, -1, 3, 4, 10, 2]))",
    "def max_product(arr):\n    \"\"\"\n    :param arr: list - sorted list of numbers\n    :return: int - maximum value in the array\n    \"\"\"\n    if len(arr) == 0:\n        return None\n\n    if len(arr) == 1:\n        return arr[0]\n\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n\n    if arr[0] < 0:\n        min_val = arr[0]\n        max_val = arr[1]\n    else:\n        min_val = max_val = arr[0]\n\n    max_product = max_val\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            min_val, max_val = max_val, min_val\n        max_val = max(max_val * arr[i], arr[i])\n        min_val = min(min_val * arr[i], arr[i])\n        max_product = max(max_product, max_val)\n\n    return max_product\n\n\nif __name__ == '__main__':\n    print(max_product([2, 3, -2, 4]))",
    "def max_subarray(a):\n    if not a:\n        return 0\n\n    max_so_far = a[0]\n    max_ending_here = a[0]\n\n    for x in a[1:]:\n        max_ending_here = max(x, max_ending_here*x)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\nif __name__ == \"__main__\":\n    print(max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]))\n    print(max_subarray([-2, -3, 4, -1, -2, 1, -5, -3]))",
    "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_curr = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_curr = max(max_curr * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        elif arr[i] == 0:\n            max_curr = max(max_curr * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        else:\n            temp = max_curr\n            max_curr = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(temp * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_curr)\n\n    return max_so_far\n\n\nprint(max_product([-2, -3, 4, -1, -2, 1, 5, -3]))",
    "def maxProduct(array):\n\tmax_product = array[0]\n\tmax_so_far = array[0]\n\tmin_so_far = array[0]\n\n\tfor num in array[1:]:\n\t\tif num < 0:\n\t\t\tmax_product = max(max_so_far * num, min_so_far * num)\n\t\t\tmin_so_far, max_so_far = min_so_far * num, max_so_far * num\n\t\telse:\n\t\t\tmax_so_far = max_so_far * num\n\t\t\tmin_so_far = min_so_far * num\n\n\t\tmax_product = max(max_so_far, max_product)\n\n\treturn max_product\n\nprint(maxProduct([2, -5, 4, 3, -2, 1, -7]))\nprint(maxProduct([-2, 0, -1]))\nprint(maxProduct([-2, -3, -1]))\nprint(maxProduct([0, 2, 3, 4, 5]))\nprint(maxProduct([-1, -1, -1, -1]))\nprint(maxProduct([-1, -2, 1, -2, 2]))\nprint(maxProduct([-1, -2, 1, -2, 2, 3, 4, 5]))\nprint(maxProduct([-1, -2, 1, -2, 2, 3, 4, 5, 6]))\nprint(maxProduct([-1, -2, 1, -2, 2, 3, 4, 5, 6, 7]))",
    "def max_product_subarray(arr):\n    \"\"\"\n    :param: arr - list of integers\n    return: int - maximum product subarray of the given array\n\n    FOLLOW UP\n    1. Can you do it in time better than O(n)?\n    2. Can you improve it if the elements of the array are not integers?\n    \"\"\"\n    # O(n)\n    # O(n)\n    if not arr:\n        return None\n\n    current_max = arr[0]\n    current_min = arr[0]\n    global_max = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n\n        current_max, current_min = max_min_current(num, current_max, current_min)\n\n        global_max = max(current_max, global_max)\n\n    return global_max\n\n\ndef max_min_current(num, current_max, current_min):\n    current_max, current_min = (\n        max(num, current_max * num, current_min * num),\n        min(num, current_max * num, current_min * num),\n    )\n\n    return current_max, current_min\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    solution = test_case[1]\n    output = max_product_subarray(arr)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [2, 3, -2, 4]\nsolution = 6\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [-2, 0, -1]\nsolution = 0\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = []\nsolution = None\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [0, 2]\nsolution = 2\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [-4,",
    "def max_product(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_ending_here = arr[0]\n    for i in range(1, len(arr)):\n        x = max_ending_here * arr[i]\n        y = min_so_far * arr[i]\n        max_ending_here = max(arr[i], x, y)\n        min_so_far = min(arr[i], x, y)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\nif __name__ == \"__main__\":\n    arr = [-2, -3, 4, -1, -2, 1, 5, -3]\n    print(max_product(arr))",
    "def find_max_product_subarray(arr):\n    if len(arr) == 0:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    max_product_subarray = arr[0]\n    for i in range(1, len(arr)):\n        temp_max_product = max(arr[i], max_product * arr[i], min_product * arr[i])\n        temp_min_product = min(arr[i], max_product * arr[i], min_product * arr[i])\n        max_product = max(max_product, temp_max_product)\n        min_product = min(min_product, temp_min_product)\n        max_product_subarray = max(max_product, max_product_subarray)\n    return max_product_subarray\n\n\ndef main():\n    print(\"Maximum product subarray: \" +\n          str(find_max_product_subarray([-10, -1, 2, 3, 4, 5])))\n    print(\"Maximum product subarray: \" +\n          str(find_max_product_subarray([-1, -2, 3, 4, 5])))\n    print(\"Maximum product subarray: \" +\n          str(find_max_product_subarray([-10, -1, -2, -3, -4, -5])))\n    print(\"Maximum product subarray: \" +\n          str(find_max_product_subarray([-1, -2, 0, -3, -4, -5])))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(1)\n\"\"\"",
    "def max_product(arr):\n    \"\"\"\n    :param arr: list of integers\n    :return: int\n    \"\"\"\n    max_prod = arr[0]\n    min_prod = arr[0]\n    prod = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            min_prod, max_prod = max_prod, min_prod\n        max_prod = max(arr[i], max_prod * arr[i])\n        min_prod = min(arr[i], min_prod * arr[i])\n        prod = max(prod, max_prod)\n    return prod\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 3, -2, 4]))\n    print(max_product([-2, 0, -1]))\n    print(max_product([2, 3, -2, 4, -2, 4]))",
    "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Let's consider the following two subarrays of the given array:\n            [1, 2, 3, 4, 5, 6, 7, 8, 9]\n            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n        For the first subarray, we can see that the maximum product subarray is\n        [1, 2, 3, 4, 5, 6, 7, 8, 9] with product 288.\n\n        For the second subarray, we can see that the maximum product subarray is\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] with product 300.\n\n        The maximum product subarray for the second subarray is bigger than the\n        maximum product subarray for the first subarray, so we need to return\n        the product of the maximum product subarray of the second subarray.\n\n        For the first subarray, we can see that the minimum product subarray is\n        [1, 2, 3, 4, 5, 6, 7, 8, 9] with product 8.\n\n        For the second subarray, we can see that the minimum product subarray is\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] with product 20.\n\n        The minimum product subarray for the second subarray is smaller than the\n        minimum product subarray for the first subarray, so we need to return\n        the product of the minimum product subarray of the second subarray.\n\n        So, the answer is the maximum of the products of the maximum product\n        subarrays of the two subarrays.\n        \"\"\"\n        if not nums:\n            return 0\n\n        max_prod = nums[0]\n        min_prod = nums[0]\n        max_prod_subarray = max",
    "def maxProduct(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1], arr[0]*arr[1])\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        temp_max = max_so_far\n        temp_min = min_so_far\n        max_so_far = max(arr[i], temp_max*arr[i], temp_min*arr[i])\n        min_so_far = min(arr[i], temp_max*arr[i], temp_min*arr[i])\n        result = max(result, max_so_far)\n    return result\n\nif __name__ == \"__main__\":\n    arr = [10, -4, 20, -2]\n    print(maxProduct(arr))",
    "def max_product_subarray(arr):\n    if len(arr) == 0:\n        return 0\n\n    min_product = max_product = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        else:\n            temp = max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n    return max_product\n\n\nif __name__ == \"__main__\":\n    arr = [-10, -1, 2, 3, 4, -9]\n    print(max_product_subarray(arr))",
    "from typing import List\n\n\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_ending_here = max_so_far = nums[0]\n\n    for num in nums[1:]:\n        max_ending_here = max(max_ending_here * num, num)\n        max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_sub_array([2, 3, -2, 4]) == 6",
    "def max_product(A):\n    max_end = max_start = A[0]\n    min_end = min_start = A[0]\n    ans = A[0]\n    for i in range(1, len(A)):\n        max_end = max(A[i], max_end * A[i], min_end * A[i])\n        min_end = min(A[i], max_end * A[i], min_end * A[i])\n        max_start = max(max_start, min_end)\n        ans = max(ans, max_end, max_start)\n        min_start = min(min_start, max_end)\n    return ans\n\nprint(max_product([-2, 3, -4, 5, -12, 6, -7, 8, -9]))\n\n# Time Complexity = O(N)\n# Space Complexity = O(1)",
    "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        max_so_far = min_so_far = nums[0]\n        res = nums[0]\n\n        for num in nums[1:]:\n            if num > 0:\n                max_so_far = max(num, max_so_far * num)\n                min_so_far = min(num, min_so_far * num)\n            else:\n                tmp = max_so_far\n                max_so_far = max(num, min_so_far * num)\n                min_so_far = min(num, tmp * num)\n\n            res = max(res, max_so_far)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, -2, 4]\n    out = 6\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)\n\n    nums = [-2, 0, -1]\n    out = 0\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)\n\n    nums = [-1, -2, -3]\n    out = -6\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)",
    "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        return max(arr[0], arr[1])\n    else:\n        max_subarr = [0, 0]\n        max_subarr[0] = max(arr[0], arr[1])\n        max_subarr[1] = max(arr[0], arr[1])\n        min_subarr = [0, 0]\n        min_subarr[0] = min(arr[0], arr[1])\n        min_subarr[1] = min(arr[0], arr[1])\n        for i in range(2, len(arr)):\n            max_subarr[i] = max(\n                max(max_subarr[i - 1] * arr[i], min_subarr[i - 1] * arr[i]),\n                arr[i],\n            )\n            min_subarr[i] = min(\n                min(max_subarr[i - 1] * arr[i], min_subarr[i - 1] * arr[i]),\n                arr[i],\n            )\n        return max(max_subarr[len(arr) - 1], min_subarr[len(arr) - 1])\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 3, -2, 4]))\n    print(max_product([-2, 0, -1]))",
    "def max_product_subarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    min_product = 0\n    max_product = 1\n    for num in nums:\n        if num == 0:\n            min_product = max_product = 0\n        else:\n            min_product = min(num, min_product * num)\n            max_product = max(num, max_product * num)\n\n    return max(max_product, min_product)\n\n\ndef test_max_product_subarray():\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0\n\n\nif __name__ == '__main__':\n    test_max_product_subarray()",
    "from typing import List\n\n\ndef max_sub_array(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param nums: list of numbers\n    :return: max product subarray\n    \"\"\"\n\n    # initialize max_product with the first element in the array\n    max_product = nums[0]\n\n    # initialize current_product with the first element in the array\n    current_product = nums[0]\n\n    for i in range(1, len(nums)):\n        # Multiply current product with the next element in the array\n        current_product *= nums[i]\n        # Update current product if it is smaller than 0\n        current_product = max(current_product, nums[i])\n        # Update max product if it is smaller than current product\n        max_product = max(max_product, current_product)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    print(max_sub_array([-2, -3, -1, -5]))",
    "from typing import List\n\n\n# O(n) time | O(1) space\ndef maxProduct(array: List[int]) -> int:\n    # edge cases\n    if len(array) == 0:\n        return 0\n    if len(array) == 1:\n        return array[0]\n\n    # variables\n    min_subarray = array[0]\n    max_subarray = array[0]\n    max_product = array[0]\n\n    # traverse the array\n    for num in array[1:]:\n        # find max subarray\n        max_subarray = max(max_subarray * num, num, min_subarray * num)\n        min_subarray = min(min_subarray * num, num, max_subarray)\n        # find max product\n        max_product = max(max_subarray, max_product)\n\n    return max_product\n\n\nprint(maxProduct([2, 3, -2, 4]))",
    "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_ending = arr[0]\n    min_ending = arr[0]\n\n    for num in arr[1:]:\n        max_ending, min_ending = max(num, max_ending * num, min_ending * num), min(num, max_ending * num, min_ending * num)\n        max_so_far = max(max_so_far, max_ending)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product([-10, -1, 2, 3, -20, 1]) == 60",
    "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_ending_here = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        elif arr[i] == 0:\n            max_ending_here = 0\n            min_so_far = 0\n        else:\n            temp = max_ending_here\n            max_ending_here = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(temp * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\n\ndef main():\n    arr = [-2, -3, -4, -1]\n    print(max_product(arr))\n\n\nif __name__ == '__main__':\n    main()",
    "def max_product_subarray(array):\n    \"\"\"\n    Finds the maximum product subarray.\n\n    Args:\n       array(array): input array\n    Returns:\n       int: maximum product subarray\n    \"\"\"\n    if not array:\n        return None\n\n    curr_min, curr_max, max_prod = array[0], array[0], array[0]\n\n    for num in array[1:]:\n        curr_min, curr_max = min(num, curr_min * num, curr_max * num), max(num, curr_min * num, curr_max * num)\n        max_prod = max(max_prod, curr_max)\n\n    return max_prod\n\n\ndef test_function(test_case):\n    array = test_case[0]\n    solution = test_case[1]\n    output = max_product_subarray(array)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\n# Tests\ntest_function([[1, 2, 3, 4, 5, 6, 7, 8, 9], 64])\ntest_function([[-1, 2, 3, -1, 4, -5], 4] )\ntest_function([[-10, 1, 2, 3, -10], 30] )\ntest_function([[1, 2, -3, 4, -2], 24] )\ntest_function([[-10, -10], -100] )\ntest_function([[], None] )",
    "from typing import List\n\n\ndef max_subarray(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_ending_here = max_so_far = nums[0]\n\n    for num in nums[1:]:\n        max_ending_here = max(num, max_ending_here * num)\n        max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6",
    "def max_product(arr):\n    max_prod = float(\"-inf\")\n    prod = 1\n\n    for i in range(len(arr)):\n        prod *= arr[i]\n        max_prod = max(max_prod, prod)\n        prod = prod ** (1.0 / arr[i])\n\n    prod = 1\n\n    for i in range(len(arr) - 1, -1, -1):\n        prod *= arr[i]\n        max_prod = max(max_prod, prod)\n        prod = prod ** (1.0 / arr[i])\n\n    return max_prod\n\nprint(max_product([-2, 3, -4]))\nprint(max_product([-2, -3, 4]))\nprint(max_product([2, 3, -2, 4, -1]))\nprint(max_product([-2, 0, -1, 2, -3, 1]))",
    "from typing import List\n\n\ndef max_sub_array(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_sum = arr[0]\n    curr_sum = arr[0]\n\n    for num in arr[1:]:\n        curr_sum = max(num, curr_sum * num)\n        max_sum = max(curr_sum, max_sum)\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    assert max_sub_array([-2, -3, 4, -1, -2, 1, 5, -3]) == 7",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = array[0]\n    min_product = array[0]\n    max_subarray_product = array[0]\n\n    for num in array[1:]:\n        if num > 0:\n            max_product = max(max_product * num, num)\n            min_product = min(min_product * num, num)\n        else:\n            max_product, min_product = min_product, max_product\n\n        max_subarray_product = max(max_product, max_subarray_product)\n\n    return max_subarray_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([-1, 2, 3, 6, -1, 2, 3, -1, 2, 3, 6, -1, 2, 3, 6]) == 72",
    "def max_product(arr):\n    if len(arr) < 2:\n        return arr[0]\n    max_so_far = min_so_far = arr[0]\n    for i in arr[1:]:\n        if i < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        max_so_far = max(i, i * max_so_far)\n        min_so_far = min(i, i * min_so_far)\n    return max(max_so_far, min_so_far)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 3, -2, 4]),\n        ([-2, 0, -1]),\n        ([-2, 3, -4, -2]),\n        ([-4, -3, -2]),\n    ]\n    for test_case in test_cases:\n        print(max_product(test_case))",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not array:\n        return 0\n\n    max_so_far = array[0]\n    min_so_far = array[0]\n    max_product = array[0]\n\n    for num in array[1:]:\n        if num > 0:\n            max_so_far = max(max_so_far * num, num)\n            min_so_far = min(min_so_far * num, num)\n        else:\n            temp = max_so_far\n            max_so_far = max(min_so_far * num, num)\n            min_so_far = min(temp * num, num)\n\n        max_product = max(max_so_far, max_product)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6\n    assert max_product_subarray([-2, 0, -1]) == 0",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    global_max = arr[0]\n\n    for num in arr[1:]:\n        num_product = num * max_product\n        num_min_product = num * min_product\n        max_product = max(num, num_min_product, num_product)\n        min_product = min(num, num_min_product, num_product)\n        global_max = max(global_max, max_product)\n\n    return global_max\n\n\nif __name__ == \"__main__\":\n    print(max_product_subarray([-100, 200, -10, -100, -1, -100]))",
    "from typing import List\n\n\n# Time complexity: O(n). We iterate the array only once\n# Space complexity: O(1). We create a new array to store the result\ndef max_product_subarray(array: List[int]) -> int:\n    if not array:\n        raise ValueError(\"Array cannot be empty\")\n\n    # We use two variables to keep track of the current maximum and minimum subarray product\n    # and their respective indices\n    max_product = array[0]\n    min_product = array[0]\n    max_product_index = 0\n    min_product_index = 0\n\n    # We iterate through the array to get the subarray with the maximum product\n    for index, value in enumerate(array[1:]):\n        # If the current element is positive, we update the minimum product\n        if value > 0:\n            min_product = min(min_product, value)\n            min_product_index = index\n        # If the current element is negative, we update the maximum product\n        elif value < 0:\n            max_product = max(max_product, value)\n            max_product_index = index\n        # If the current element is 0, we update both products and indices\n        else:\n            max_product = value\n            max_product_index = index\n            min_product = value\n            min_product_index = index\n\n        # We update the maximum product if the product of the current element and the previous\n        # element is bigger than the maximum product\n        if index > 0:\n            max_product = max(max_product, array[index] * array[index - 1])\n        # We update the minimum product if the product of the current element and the next\n        # element is smaller than the minimum product\n        if index < len(array) - 1:\n            min_product = min(min_product, array[index] * array[index + 1])\n\n    return array[max_product_index] * array[min_product_index]\n\n\nif __name__ == \"__main__\":\n    print(max_product_subarray([-100, -90, -1, -2, -3, -4]))",
    "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_subarray(nums: List[int]) -> int:\n    \"\"\"\n    dp[i] = max(dp[i-1] * nums[i], dp[i-1] * nums[i-1], nums[i])\n    \"\"\"\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n\n    for i in range(1, n):\n        dp[i] = max(dp[i-1] * nums[i], dp[i-1] * nums[i-1], nums[i])\n\n    return max(dp)\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product_subarray2(nums: List[int]) -> int:\n    \"\"\"\n    dp[i] = max(dp[i-1] * nums[i], dp[i-1] * nums[i-1], nums[i])\n    \"\"\"\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n\n    min_i = nums[0]\n    max_i = nums[0]\n\n    for i in range(1, n):\n        num = nums[i]\n\n        # dp[i] = max(dp[i-1] * nums[i], dp[i-1] * nums[i-1], nums[i])\n        # dp[i] = max(dp[i-1] * num, dp[i-1] * nums[i-1], nums[i])\n        # dp[i] = max(dp[i-1] * num, dp[i-1] * nums[i-1], nums[i])\n        # dp[i] = max(dp[i-1] * num, dp[i-1] * nums[i-1], nums[i",
    "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 0:\n        return None\n\n    max_so_far = min_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        temp_min = min(min_so_far * arr[i], max_so_far * arr[i], arr[i])\n        temp_max = max(min_so_far * arr[i], max_so_far * arr[i], arr[i])\n\n        min_so_far = temp_min\n        max_so_far = temp_max\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product([-10, -1, -2, 0, -5, -1, -4]) == 0",
    "def max_product(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_prod = nums[0]\n    min_prod = nums[0]\n    res = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > 0:\n            max_prod = max(nums[i], max_prod * nums[i])\n            min_prod = min(nums[i], min_prod * nums[i])\n        else:\n            max_prod = max(nums[i], min_prod * nums[i])\n            min_prod = min(nums[i], max_prod * nums[i])\n        res = max(res, max_prod)\n    return res\n\nprint(max_product([-2, -3, -1, -4, 2, 3, 1, 4]))",
    "def max_subarray_product(array):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(array) < 2:\n        return array\n\n    max_product = array[0]\n    min_product = array[0]\n    result = array[0]\n\n    for i in range(1, len(array)):\n        temp_max = max(array[i], max_product * array[i], min_product * array[i])\n        temp_min = min(array[i], max_product * array[i], min_product * array[i])\n        max_product = temp_max\n        min_product = temp_min\n        result = max(max_product, result)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(max_subarray_product([-1, -3, -10, 0, 6]))\n    print(max_subarray_product([1, -2, -3, 4, -1, 2, 1, -5, 4]))\n    print(max_subarray_product([-10, 0, 1, 2]))\n    print(max_subarray_product([-1, -2]))",
    "from typing import List\n\n\ndef max_product_subarray(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_subarray = array[0]\n    max_product = array[0]\n    min_product = array[0]\n\n    for i in range(1, len(array)):\n        num = array[i]\n\n        max_product = max(max_product * num, num)\n        min_product = min(min_product * num, num)\n        max_subarray = max(max_product, max_subarray)\n\n    return max_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([2, 3, -2, 4]) == 6",
    "def max_product_subarray(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: int\n    \"\"\"\n    if not array:\n        return\n    length = len(array)\n    if length == 1:\n        return array[0]\n\n    max_sub_array_product = array[0]\n    min_sub_array_product = array[0]\n    max_sub_array = [array[0]]\n    min_sub_array = [array[0]]\n    for i in range(1, length):\n        current = array[i]\n        current_max_sub_array_product = max(\n            current, max_sub_array_product * current, min_sub_array_product * current)\n        current_min_sub_array_product = min(\n            current, max_sub_array_product * current, min_sub_array_product * current)\n        max_sub_array_product = current_max_sub_array_product\n        min_sub_array_product = current_min_sub_array_product\n        if max_sub_array_product > max_sub_array[0]:\n            max_sub_array = [current]\n            max_sub_array.extend(max_sub_array_product)\n        elif max_sub_array_product == max_sub_array[0]:\n            max_sub_array.append(current)\n\n        if min_sub_array_product < min_sub_array[0]:\n            min_sub_array = [current]\n            min_sub_array.extend(min_sub_array_product)\n        elif min_sub_array_product == min_sub_array[0]:\n            min_sub_array.append(current)\n\n    return max(max_sub_array)\n\n\nif __name__ == \"__main__\":\n    print max_product_subarray([2, -3, -2, 4, -1, -2, 1, 5, -3])",
    "def max_product_subarray(arr):\n    \"\"\"\n    :param: arr - input array\n    return: int - maximum product subarray\n    TODO: Write your solution here\n    \"\"\"\n    # Find the max subarray\n    # For each element, store the max subarray ending with that element\n    # Update the max subarray ending with that element\n    # Return the max of all max subarrays\n\n    # If array is empty\n    if len(arr) == 0:\n        return None\n\n    # If array has only one element\n    if len(arr) == 1:\n        return arr[0]\n\n    # Initialize max_subarray_ending_at_i\n    max_subarray_ending_at_i = [arr[0]] * len(arr)\n    # Initialize min_subarray_ending_at_i\n    min_subarray_ending_at_i = [arr[0]] * len(arr)\n    # Initialize max_subarray\n    max_subarray = arr[0]\n\n    # Initialize max_product_ending_at_i\n    max_product_ending_at_i = arr[0]\n    # Initialize min_product_ending_at_i\n    min_product_ending_at_i = arr[0]\n\n    # Initialize max_subarray\n    max_subarray = arr[0]\n\n    # Traverse through all array elements\n    for i in range(1, len(arr)):\n\n        # Handle negative numbers\n        max_product_ending_at_i = max(max_product_ending_at_i * arr[i], min_product_ending_at_i * arr[i], arr[i])\n        min_product_ending_at_i = min(max_product_ending_at_i * arr[i], min_product_ending_at_i * arr[i], arr[i])\n\n        # Update max_subarray_ending_at_i[i]\n        max_subarray_ending_at_i[i] = max(\n            max_product_ending_at_i, min_product_ending_at_i, arr[i])\n\n        # Update min_subarray_ending",
    "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    max_so_far = min_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_so_far = max(max_so_far * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        elif arr[i] == 0:\n            max_so_far = min_so_far = 0\n        else:\n            tmp = max_so_far\n            max_so_far = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(tmp * arr[i], arr[i])\n\n    return max(max_so_far, min_so_far)\n\n\ndef max_product_dp(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    max_so_far = min_so_far = arr[0]\n    max_ending_here = min_ending_here = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        elif arr[i] == 0:\n            max_ending_here = min_ending_here = 0\n        else:\n            tmp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(tmp * arr[i], arr[i])\n\n        max_so_far = max(max_ending_here, max_so_far)",
    "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        # dp[i][0] = max product of subarray ending with i, negative flag\n        # dp[i][1] = max product of subarray ending with i, positive flag\n        dp = [[0, 0] for _ in range(len(nums))]\n        for i in range(len(nums)):\n            if nums[i] >= 0:\n                dp[i][0] = dp[i][1] = nums[i]\n            else:\n                dp[i][0] = dp[i][1] = -nums[i]\n\n            for j in range(i - 1, -1, -1):\n                if nums[j] >= 0:\n                    dp[j][0] = max(dp[j][0] * nums[j], nums[j])\n                    dp[j][1] = min(dp[j][1] * nums[j], nums[j])\n                else:\n                    dp[j][0] = max(dp[j][0] * nums[j], -nums[j])\n                    dp[j][1] = min(dp[j][1] * nums[j], -nums[j])\n\n            print(dp)\n        return max(dp[i][0] for i in range(len(nums)))\n\n\nif __name__ == \"__main__\":\n    nums = [-100, -90, -80, -70, -60, -50, -40, -30, -20, -10]\n    out = 720\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)\n\n    nums = [-1, -2, -3, -4, -5]\n    out = -120\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)\n\n    nums = [1, 2, 3,",
    "def max_product_subarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_subarray = [nums[0]]\n    max_subarray = [nums[0]]\n    for i in range(1, len(nums)):\n        min_subarray.append(\n            min(\n                min_subarray[i - 1] * nums[i],\n                max_subarray[i - 1] * nums[i],\n                nums[i],\n            )\n        )\n        max_subarray.append(\n            max(\n                min_subarray[i - 1] * nums[i],\n                max_subarray[i - 1] * nums[i],\n                nums[i],\n            )\n        )\n    return max(max_subarray)\n\n\ndef test_max_product_subarray():\n    assert max_product_subarray([-1, -2, -3, -4, -5]) == -120\n    assert max_product_subarray([-1, 2, -3, -4, -5]) == 24\n    assert max_product_subarray([]) == 0\n    assert max_product_subarray([-1, 0, 0, 1, -2, 1]) == 0\n    assert max_product_subarray([-1, 0, 0, 1, -2, 1, 1]) == 2\n\n\nif __name__ == \"__main__\":\n    test_max_product_subarray()",
    "from typing import List\n\n\ndef max_product_subarray(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_subarray = arr[0]\n    cur_max_subarray = arr[0]\n    cur_min_subarray = arr[0]\n\n    for i in range(1, len(arr)):\n        cur_num = arr[i]\n        cur_max_subarray = max(cur_max_subarray * cur_num, cur_num)\n        cur_min_subarray = min(cur_min_subarray * cur_num, cur_num)\n\n        max_subarray = max(max_subarray, cur_max_subarray)\n\n    return max_subarray\n\n\nif __name__ == \"__main__\":\n    assert max_product_subarray([-10, -1, 2, 3, -100]) == 300"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}