{
  "problem": {
    "task_id": "HumanEval/49",
    "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
    "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
    "entry_point": "modp",
    "docstring": "",
    "problem_id": 49
  },
  "model_name": "codet5-770m",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "if n < 0:\n        n = p - n\n    if n % 2 == 0:\n        return 2 ** (p - 1 - n)\n    return modp(n - 1, p)\n\n\ndef modinv(a: int, m: int) -> int:\n    \"\"\"Return the inverse of a mod m.\n    >>> modinv(2, 101)\n    3\n    >>> modinv(2, 0)\n    1\n    \"\"\"\n    if a < 0:\n        a = p - a\n    if a % 2 == 0:\n        return a\n    return modinv(a // 2, m)\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is prime.\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    False\n    >>> is_prime(4)\n    True\n    >>> is_prime(5)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Return True if s is a palindrome.\n    >>> is_palindrome(\"aab\")\n    True\n    >>> is_palindrome(\"abcb\")\n    False\n    >>> is_palindrome(\"abcd\")\n    False\n    \"\"\"\n    if len(s) < 2:\n        return False\n    if s[0]!= s[-1]:\n        return False\n    return all(s[i] == s[-i - 1] for i in range(1, len(s) - 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    return (modp(n // 2, p) * 2) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n <= 0:\n        raise ValueError\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 8\n    if n == 4:\n        return 4\n    if n == 5:\n        return 8\n    if n == 6:\n        return 4\n    if n == 7:\n        return 8\n    if n == 8:\n        return 4\n    if n == 9:\n        return 8\n    if n == 10:\n        return 8\n    if n == 11:\n        return 8\n    if n == 12:\n        return 8\n    if n == 13:\n        return 8\n    if n == 14:\n        return 8\n    if n == 15:\n        return 8\n    if n == 16:\n        return 8\n    if n == 17:\n        return 8\n    if n == 18:\n        return 8\n    if n == 19:\n        return 8\n    if n == 20:\n        return 8\n    if n == 21:\n        return 8\n    if n == 22:\n        return 8\n    if n == 23:\n        return 8\n    if n == 24:\n        return 8\n    if n == 25:\n        return 8\n    if n == 26:\n        return 8\n    if n == 27:\n        return 8\n    if n == 28:\n        return 8\n    if n == 29:\n        return 8\n    if n == 30:\n        return 8\n    if n == 31:\n        return 8\n    if n == 32:\n        return 8\n    if n == 33:\n        return 8\n    if n == 34:\n        return 8\n    if n == 35:\n        return 8\n    if n == 36:\n        return 8\n    if n == 37:\n        return 8\n    if n == 38:\n        return 8\n    if n == 39:\n        return 8\n    if n == 40:\n        return 8\n    if n == 41:\n        return 8\n    if n == 42:\n        return 8\n    if n == 43:\n        return 8\n    if n == 44:\n        return 8\n    if n == 45:\n        return 8\n    if n ==",
    "assert p > 0\n    assert n >= 0\n    if n == 0:\n        return 1\n    elif n == 1:\n        return p\n    else:\n        return modp(n - 1, p) * modp(n - 2, p)",
    "if n == 0:\n        return 1\n    else:\n        return modp(n // 2, p) * modp(n % 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return a modulo p.\n    >>> modinv(2, 3)\n    2\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    b = pow(a, p - 1, p)\n    return b\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(3)\n    False\n    >>> is_prime(1101)\n    True\n    >>> is_prime(0)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(100)\n    True\n    >>> is_prime(11)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 2:\n        return True\n    for i in range(3, n // 2 + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_mod_p(n: int, p: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime_mod_p(3, 5)\n    False\n    >>> is_prime_mod_p(1101, 101)\n    True\n    >>> is_prime_mod_p(0, 101)\n    True\n    >>> is_prime_mod_p(3, 11)\n    False\n    >>> is_prime_mod_p(100, 101)\n    True\n    \"\"\"\n    return is_prime(modp(n, p))",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    return modp(n-1, p) * modp(n-1, p) % p",
    "assert p > 0 and n >= 0\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n // 2, p)\n    return modp((2 * n) % p, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        raise ValueError(\"modp is not a valid argument for n\")\n    if n > p:\n        raise ValueError(\"modp is not a valid argument for n\")\n    if n < 1:\n        raise ValueError(\"modp is not a valid argument for n\")\n    if n == 1:\n        return 1\n    return modp(n - 1, p) * 2 % p",
    "if n == 0:\n        return 1\n    return modp(n-1, p) * 2 % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    return (modp(n-1, p) * 2) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return 2 ** n % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef is_prime(n: int, p: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(3, 5)\n    True\n    >>> is_prime(1101, 101)\n    False\n    >>> is_prime(0, 101)\n    False\n    >>> is_prime(3, 11)\n    True\n    >>> is_prime(100, 101)\n    False\n    \"\"\"\n    return n > 1 and all(modp(i, p) == 1 for i in range(2, n))",
    "assert n > 0, \"n must be a positive integer\"\n    assert p > 0, \"p must be a positive integer\"\n    assert n & p == 0, \"n and p must both be non-negative\"\n    assert n & p == p, \"n and p must both be non-negative\"\n    if n == 1:\n        return 1\n    if n == p:\n        return p\n    if n & p == p:\n        return 2\n    if n & p == p - 1:\n        return 2 ** (n - 1) % p\n    return 2 ** (n - p) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n % 2 == 0:\n        return modp(n // 2, p) * modp(n - 1, p)\n    return modp(n // 2, p) * modp(n - 1, p) * modp(n - 1, p)",
    "if n == 0:\n        return 1\n    if n < 0:\n        n = p - n\n    return modp(n, p) * modp(n - 1, p) % p",
    "assert p > 0\n    assert n > 0\n    assert n & 1 == 0\n    return 2 ** n % p",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    return modp(n - 1, p) * 2 % p\n\n\ndef is_prime(n: int, p: int) -> bool:\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(1101, 101)\n    True\n    >>> is_prime(0, 101)\n    False\n    >>> is_prime(3, 11)\n    True\n    >>> is_prime(100, 101)\n    False\n    \"\"\"\n    if n < 2 or n % 2 == 0:\n        return False\n    if n == 1 or n == 2:\n        return True\n    if n % 2 == 1 and n!= 3:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 6\n    return True\n\n\ndef is_prime_iterative(n: int, p: int) -> bool:\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime_iterative(1101, 101)\n    True\n    >>> is_prime_iterative(0, 101)\n    False\n    >>> is_prime_iterative(3, 11)\n    True\n    >>> is_prime_iterative(100, 101)\n    False\n    \"\"\"\n    if n < 2 or n % 2 == 0:\n        return False\n    if n == 1 or n == 2:\n        return True\n    if n % 2 == 1 and n!= 3:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 6\n    return True",
    "return 2 ** n % p\n\n\ndef primes(n: int) -> list:\n    \"\"\"Return a list of prime numbers less than n.\n    >>> primes(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    return [i for i in range(2, n) if modp(i, n) == 1]",
    "if n < 0:\n        n += p\n    s = 1\n    while n > 0:\n        if n % 2 == 1:\n            s = s * 2\n        n = n // 2\n    return s\n\n\ndef modinv(a: int, m: int) -> int:\n    \"\"\"Return the modular inverse of a modulo m.\n    >>> modinv(3, 5)\n    2\n    >>> modinv(1101, 101)\n    1\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if a < 0:\n        a += m\n    s = modp(a, m)\n    if s == 1:\n        return 0\n    elif s == 0:\n        return 1\n    else:\n        return modinv(s, m)\n\n\ndef modinv_modp(a: int, m: int, p: int) -> int:\n    \"\"\"Return the modular inverse of a modulo m.\n    >>> modinv_modp(3, 5, 101)\n    2\n    >>> modinv_modp(1101, 101, 101)\n    1\n    >>> modinv_modp(0, 101, 101)\n    1\n    >>> modinv_modp(3, 11, 101)\n    8\n    >>> modinv_modp(100, 101, 101)\n    1\n    \"\"\"\n    if a < 0:\n        a += m\n    s = modp(a, m)\n    if s == 1:\n        return 0\n    elif s == 0:\n        return 1\n    else:\n        return modinv_modp(s, m, p)\n\n\ndef modinv_modp_p(a: int, m: int, p: int) -> int:\n    \"\"\"Return the modular inverse of a modulo m.\n    >>> modinv_modp_p(3, 5, 101)\n    2\n    >>> modinv_modp_p(1101, 101, 101)\n    1\n    >>> modinv_modp_p(0, 101, 101)\n    1\n    >>> mod",
    "return pow(2, n, p)\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers.\n    >>> gcd(5, 3)\n    3\n    >>> gcd(4, 3)\n    4\n    >>> gcd(4, 5)\n    5\n    >>> gcd(2, 3)\n    1\n    \"\"\"\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"Return the least common multiple of two integers.\n    >>> lcm(4, 3)\n    8\n    >>> lcm(4, 5)\n    16\n    >>> lcm(4, 6)\n    24\n    \"\"\"\n    return (a * b) // gcd(a, b)\n\n\ndef modinv(a: int, m: int) -> int:\n    \"\"\"Return the modular inverse of a mod m.\n    >>> modinv(3, 5)\n    1\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    # TODO: Implement modinv\n    pass",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n % 2, p)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n - 1, p) * 2\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n < 0 or p < 0:\n        raise ValueError(\"n and p must be non-negative integers\")\n    if n == 0 or p == 0:\n        return n\n    if p == 1:\n        return 2**n\n    return modp(n // 2, p) * 2**(n % 2) % p",
    "if n == 0:\n        return p\n    return modp(n-1, p) * 2 % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n < 0:\n        n += p\n\n    return pow(2, n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n    if n == 0:\n        return 1\n    if n % p == 0:\n        return 2**n\n    return modp(n, p)\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(3)\n    True\n    >>> is_prime(1101)\n    False\n    >>> is_prime(0)\n    True\n    >>> is_prime(3)\n    False\n    >>> is_prime(100)\n    True\n    \"\"\"\n    if n == 1 or n == 2:\n        return False\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    for i in range(5, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n <= 0:\n        return 1\n    return modp(n - 1, p) * 2 % p\n\n\ndef is_prime(n: int, p: int) -> bool:\n    \"\"\"Return True if n is prime.\n    >>> is_prime(3, 5)\n    True\n    >>> is_prime(1101, 101)\n    False\n    >>> is_prime(0, 101)\n    False\n    >>> is_prime(3, 11)\n    True\n    >>> is_prime(100, 101)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True",
    "return pow(2, n, p)\n\n\ndef modinv(n: int, p: int) -> int:\n    \"\"\"Return n mod p (be aware of numerics).\n    >>> modinv(5, 101)\n    3\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    s = 1\n    t = 0\n    for i in range(n):\n        t = (t * p) % p\n        s = (s * p) % p\n    return s\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    return modp(n // 2, p) * modp(n % 2, p)",
    "if n < 0:\n        raise ValueError(f\"n should be non-negative: {n}\")\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return pow(2, n - 1, p)\n\n\ndef main():\n    n, p = map(int, input().split())\n    print(modp(n, p))\n\n\nif __name__ == \"__main__\":\n    main()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n == p - 1:\n        return p - 1\n    return modp(n - 1, p) * modp(n - 1, p) % p\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is prime.\n    >>> is_prime(5)\n    True\n    >>> is_prime(3)\n    False\n    >>> is_prime(1101)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(3)\n    True\n    >>> is_prime(100)\n    False\n    \"\"\"\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n == 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    if n % 5 == 0:\n        return False\n    return True",
    "if n == 0:\n        return 1\n    if n < 0:\n        n = -n\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n % 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        return -modp(n, p)\n    if n == 0:\n        return 1\n    return 2**n % p\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime.\n    >>> is_prime(100)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(11)\n    True\n    >>> is_prime(10001)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_list(n_list: list):\n    \"\"\"Return True if n is prime list.\n    >>> is_prime_list([3, 5, 101, 2, 0, 3, 11])\n    True\n    >>> is_prime_list([3, 11])\n    False\n    >>> is_prime_list([100, 101])\n    True\n    >>> is_prime_list([1])\n    False\n    >>> is_prime_list([3, 11])\n    False\n    >>> is_prime_list([10001])\n    False\n    \"\"\"\n    for n in n_list:\n        if is_prime(n):\n            return True\n    return False\n\n\ndef is_prime_set(n_set: set):\n    \"\"\"Return True if n is prime set.\n    >>> is_prime_set({3, 5, 101, 2, 0, 3, 11})\n    True\n    >>> is_prime_set({3, 11})\n    False\n    >>> is_prime_set({100, 101})\n    True\n    >>> is_prime_set([1])\n    False\n    >>> is_prime_set([3, 11])\n    False\n    >>> is_prime_set([10001])\n    False\n    \"\"\"\n    for n in n_set:\n        if is_prime(n):\n            return True\n    return False\n\n\ndef is_prime_dict(n_dict: dict):\n    \"\"\"Return True if n is prime dict.\n    >>> is_",
    "if n == 0:\n        return 1\n    return modp(n // 2, p) * modp(n % 2, p)\n\n\ndef main():\n    \"\"\"Run the tests.\"\"\"\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "return pow(2, n, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n < 0:\n        return modp(-n, p)\n    return modp((n + 1) // 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return (pow(2, n, p)) % p\n\n\ndef modinv(a: int, m: int):\n    \"\"\"Return the inverse of a mod m.\n    >>> modinv(4, 101)\n    8\n    >>> modinv(5, 101)\n    2\n    >>> modinv(6, 101)\n    1\n    \"\"\"\n    b = modp(a, m)\n    if b == 0:\n        return 0\n    return modinv(b, m)",
    "return pow(2, n, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n < 0 or n > p - 1:\n        raise ValueError(\"n must be between 0 and p - 1\")\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    return modp(n - 1, p) * modp(n - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    else:\n        return modp(n // 2, p) * 2 + modp(n % 2, p)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n == 0:\n        return 1\n    return modp(n // 2, p) * 2 ** (n % 2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return a modular inverse of a.\n    >>> modinv(3, 5)\n    1\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    # modinv(a, p) returns a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse of a modular\n    # inverse of a modular inverse",
    "assert n >= 0\n    assert n & 1 == 1\n    assert p > 0\n    assert n & p == 0\n    assert n & p == 1\n    assert p > 1\n    return (n ^ p) & p\n\n\ndef modp_gen(n: int, p: int, gen: int):\n    \"\"\"Generate 2^n modulo p (be aware of numerics).\n    >>> modp_gen(3, 5, 1)\n    3\n    >>> modp_gen(1101, 101, 2)\n    2\n    >>> modp_gen(0, 101, 1)\n    1\n    >>> modp_gen(3, 11, 8)\n    8\n    >>> modp_gen(100, 101, 1)\n    1\n    \"\"\"\n    assert n >= 0\n    assert n & 1 == 1\n    assert p > 0\n    assert n & p == 0\n    assert p > 1\n    assert p > 1\n    assert p & gen == 0\n    assert gen > 1\n    return (n ^ p) & gen",
    "if n <= 0:\n        raise ValueError(f\"n must be greater than or equal to 0. Got {n}\")\n    if n == 0:\n        return 1\n    if p <= 0:\n        raise ValueError(f\"p must be greater than or equal to 0. Got {p}\")\n    if n == 1:\n        return p\n    if n == p:\n        return 2\n    return modp(n - 1, p) * 2 % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0 or n > p - 1:\n        raise ValueError\n    return 2 ** (n - 1) % p",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    else:\n        return modp(n // 2, p) * modp(n % 2, p)",
    "if n < 0:\n        return -1\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n % p == 0:\n        return 2 ** n % p\n    return -1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n < 0:\n        return modp(-n, p)\n    if n % 2 == 0:\n        return modp(2**n, p)\n    else:\n        return modp((2**n) - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n < 0:\n        n = n + p\n    if n < 0 or n > p:\n        raise ValueError(\"n must be between 0 and p - 1\")\n    return pow(2, n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    return modp(n // 2, p) * modp(n - 1, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return p\n    if n == 1:\n        return p\n    if n == 2:\n        return p\n    if n == 3:\n        return p\n    if n == 4:\n        return p\n    if n == 5:\n        return p\n    if n == 6:\n        return p\n    if n == 7:\n        return p\n    if n == 8:\n        return p\n    if n == 9:\n        return p\n    if n == 10:\n        return p\n    if n == 11:\n        return p\n    if n == 12:\n        return p\n    if n == 13:\n        return p\n    if n == 14:\n        return p\n    if n == 15:\n        return p\n    if n == 16:\n        return p\n    if n == 17:\n        return p\n    if n == 18:\n        return p\n    if n == 19:\n        return p\n    if n == 20:\n        return p\n    if n == 21:\n        return p\n    if n == 22:\n        return p\n    if n == 23:\n        return p\n    if n == 24:\n        return p\n    if n == 25:\n        return p\n    if n == 26:\n        return p\n    if n == 27:\n        return p\n    if n == 28:\n        return p\n    if n == 29:\n        return p\n    if n == 30:\n        return p\n    if n == 31:\n        return p\n    if n == 32:\n        return p\n    if n == 33:\n        return p\n    if n == 34:\n        return p\n    if n == 35:\n        return p\n    if n == 36:\n        return p\n    if n == 37:\n        return p\n    if n == 38:\n        return p\n    if n == 39:\n        return p\n    if n == 40:\n        return p\n    if n == 41:\n        return p\n    if n == 42:\n        return p\n    if n == 43:\n        return p\n    if n == 44:\n        return p\n    if n == 45:\n        return p\n    if n ==",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n // 2, p) * modp(n - 1, p)\n    return modp(2 * n, p) * modp(n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers.\n    >>> gcd(3, 5)\n    3\n    >>> gcd(1101, 101)\n    2\n    >>> gcd(0, 101)\n    1\n    >>> gcd(3, 11)\n    8\n    >>> gcd(100, 101)\n    1\n    \"\"\"\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"Return the least common multiple of two integers.\n    >>> lcm(3, 5)\n    3\n    >>> lcm(1101, 101)\n    2\n    >>> lcm(0, 101)\n    1\n    >>> lcm(3, 11)\n    8\n    >>> lcm(100, 101)\n    1\n    \"\"\"\n    return (a * b) // gcd(a, b)\n\n\ndef lcm_modp(a: int, b: int, p: int) -> int:\n    \"\"\"Return the least common multiple of two integers modulo p (be aware of numerics).\n    >>> lcm_modp(3, 5, 101)\n    3\n    >>> lcm_modp(1101, 101, 101)\n    2\n    >>> lcm_modp(0, 101, 101)\n    1\n    >>> lcm_modp(3, 11, 101)\n    8\n    >>> lcm_modp(100, 101, 101)\n    1\n    \"\"\"\n    return (a * b) // gcd(lcm(a, b), p)\n\n\ndef modinv(a: int, p: int) -> int:\n    \"\"\"Return the modular inverse of a modulo p (be aware of numerics).\n    >>> modinv(3, 5)\n    3\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11, 101)\n    8\n    >>> modinv(100, 101, 101)\n    1\n    \"\"\"",
    "if n == 0:\n        return 1\n    if n < 0:\n        n += p\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n // 2, p)\n    return modp(n // 2, p) * modp(n % 2, p)\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n - 1, p)\n\n\ndef modinv(a: int, p: int) -> int:\n    \"\"\"Return the inverse of a modulo p.\n    >>> modinv(3, 5)\n    5\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if a == 0:\n        return 0\n    if a < 0:\n        a = a % p\n    if p == 2:\n        return 1\n    if p % 2 == 0:\n        return a\n    return modinv(a // p, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return (modp(n - 1, p) * 2) % p",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n // 2, p)\n    if n % 2 == 1:\n        return modp((n - 1) // 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    return modp(n - 1, p) * modp(n - 2, p) % p\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers.\n    >>> gcd(3, 5)\n    3\n    >>> gcd(1101, 101)\n    2\n    >>> gcd(0, 101)\n    1\n    >>> gcd(3, 11)\n    8\n    >>> gcd(100, 101)\n    1\n    \"\"\"\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"Return the least common multiple of two integers.\n    >>> lcm(3, 5)\n    3\n    >>> lcm(1101, 101)\n    2\n    >>> lcm(0, 101)\n    1\n    >>> lcm(3, 11)\n    8\n    >>> lcm(100, 101)\n    1\n    \"\"\"\n    return (a * b) // gcd(a, b)",
    "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return modp(n // 2, p) * modp(n - 1, p)\n    return modp(n // 2, p) * modp(n - 1, p) * modp(n, p)\n\n\ndef main():\n    n = int(input())\n    p = int(input())\n    print(modp(n, p))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()",
    "if n == 0:\n        return 1\n    return modp(n - 1, p) * 2 % p\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modinv(3, 5)\n    2\n    >>> modinv(1101, 101)\n    1\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if a == 0:\n        return 0\n    if a < 0:\n        a = a % p\n    b = modp(a, p)\n    if b == 0:\n        return 1\n    return b\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n < 0:\n        raise ValueError(f\"modp({n}) is not a valid argument for n ({n})\")\n    if n == 1:\n        return p\n    return modp(n - 1, p) * modp(n, p)\n\n\ndef modinv(a: int, p: int) -> int:\n    \"\"\"Return the inverse of a modulo p (be aware of numerics).\n    >>> modinv(3, 5)\n    3\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if a == 0:\n        return 0\n    if a < 0:\n        raise ValueError(f\"modinv({a}) is not a valid argument for a ({a})\")\n    if a == 1:\n        return p\n    if a % p == 0:\n        return a // p\n    x = modinv(a % p, p)\n    y = modp(a // p, p)\n    if y == 1:\n        return x\n    return y",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0 or n > p:\n        raise ValueError(f\"n must be between 0 and {p - 1}\")\n    if n == 0:\n        return 1\n    if n == 1:\n        return p - 1\n    if n % 2 == 1:\n        return modp(n // 2, p) * modp(n - 1, p)\n    if n % 2 == 0:\n        return modp(n // 2, p) * modp(n - 1, p) * modp(n, p)\n    raise ValueError(f\"n must be a power of 2\")\n\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of a and b.\n    >>> gcd(3, 5)\n    3\n    >>> gcd(1101, 101)\n    2\n    >>> gcd(0, 101)\n    1\n    >>> gcd(3, 11)\n    8\n    >>> gcd(100, 101)\n    1\n    \"\"\"\n    if a == 0 or b == 0:\n        raise ValueError(f\"a and b must be non-negative\")\n    if a < b:\n        a, b = b, a\n    if a % b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\n\ndef lcm(a: int, b: int) -> int:\n    \"\"\"Return the least common multiple of a and b.\n    >>> lcm(3, 5)\n    3\n    >>> lcm(1101, 101)\n    2\n    >>> lcm(0, 101)\n    1\n    >>> lcm(3, 11)\n    8\n    >>> lcm(100, 101)\n    1\n    \"\"\"\n    if a == 0 or b == 0:\n        raise ValueError(f\"a and b must be non-negative\")\n    if a < b:\n        a, b = b, a\n    if a % b == 0:\n        return a\n    else:\n        return lcm(b, a % b)\n\n\ndef lcm_mod_p(a: int, p: int) -> int:\n    \"\"\"Return the least common multiple of a and b",
    "if n == 0:\n        return 1\n    elif n < 0:\n        n = p - n\n    return modp(n // 2, p) * 2 % p",
    "if n == 0:\n        return 1\n    elif n == 1:\n        return p\n    else:\n        return modp(n - 1, p) * modp(n - 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        n += p\n    return pow(2, n, p)\n\n\ndef is_prime(n: int, p: int) -> bool:\n    \"\"\"Return True if n is prime.\n    >>> is_prime(3, 101)\n    True\n    >>> is_prime(1101, 101)\n    True\n    >>> is_prime(0, 101)\n    False\n    >>> is_prime(3, 11)\n    False\n    >>> is_prime(100, 101)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if modp(i, p)!= 1:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        return -modp(-n, p)\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n - 1, p) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "assert n < p\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    return modp(n - 1, p) * modp(n - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        n = p - n\n    return pow(2, n, p)",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return modp(n - 1, p) * modp(n - 2, p) % p\n\n\ndef is_prime(n: int):\n    \"\"\"Return True if n is prime, False otherwise.\n    >>> is_prime(1101)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(3)\n    False\n    >>> is_prime(100)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n == 3:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_congruent(a: int, b: int, p: int) -> bool:\n    \"\"\"Return True if a and b are congruent, False otherwise.\n    >>> is_congruent(1, 2, 101)\n    True\n    >>> is_congruent(2, 1, 101)\n    False\n    >>> is_congruent(1, 3, 101)\n    False\n    >>> is_congruent(3, 2, 101)\n    True\n    >>> is_congruent(3, 2, 101)\n    False\n    \"\"\"\n    if a == 0 or b == 0:\n        return False\n    if a % p == 0 or b % p == 0:\n        return False\n    return is_prime(a) and is_prime(b)\n\n\ndef mod_prime(a: int, p: int) -> int:\n    \"\"\"Return a mod p.\n    >>> mod_prime(2, 101)\n    1\n    >>> mod_prime(3, 101)\n    2\n    >>> mod_prime(3, 101)\n    8\n    >>> mod_prime(3, 101)\n    4\n    >>> mod_prime(3, 101)\n    6\n    \"\"\"\n    if a == 0:\n        return 0\n    if a % p == 0:\n        return a\n    return mod_prime(a -",
    "if n < 0:\n        n = n + p\n    if n == 0:\n        return 1\n    if n == 1:\n        return p\n    return (modp(n - 1, p) * 2) % p\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n < 0:\n        return 1 % p\n    if n % 2 == 0:\n        return modp(n // 2, p)\n    else:\n        return modp(n // 2 + 1, p)\n\n\ndef get_prime_factors(n: int) -> list[int]:\n    \"\"\"Return a list of prime factors of n.\n    >>> get_prime_factors(5)\n    [2, 3, 5]\n    >>> get_prime_factors(1101)\n    [2, 3, 5]\n    >>> get_prime_factors(0)\n    [1]\n    >>> get_prime_factors(3)\n    [1, 2]\n    >>> get_prime_factors(100)\n    [1, 2, 3]\n    \"\"\"\n    factors = []\n    while n > 1:\n        if n % 2 == 0:\n            factors.append(2)\n        n //= 2\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef get_prime_factors_modp(n: int, p: int) -> list[int]:\n    \"\"\"Return a list of prime factors of n modulo p.\n    >>> get_prime_factors_modp(3, 5)\n    [3]\n    >>> get_prime_factors_modp(1101, 101)\n    [2]\n    >>> get_prime_factors_modp(0, 101)\n    [1]\n    >>> get_prime_factors_modp(3, 11)\n    [8]\n    >>> get_prime_factors_modp(100, 101)\n    [1]\n    \"\"\"\n    factors = get_prime_factors(n)\n    factors_modp = [modp(n, p) for n in factors]\n    return factors_modp\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "assert n < p\n    return 2 ** (p - n)\n\n\ndef modinv(a: int, p: int) -> int:\n    \"\"\"Return the inverse of a modulo p (be aware of numerics).\n    >>> modinv(3, 5)\n    3\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    assert a < p\n    return a // modp(a, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n == 2:\n        return p\n    if n == 3:\n        return p - 1\n    if n == 4:\n        return p - 2\n    if n == 5:\n        return p - 3\n    if n == 6:\n        return p - 4\n    if n == 7:\n        return p - 5\n    if n == 8:\n        return p - 6\n    if n == 9:\n        return p - 7\n    if n == 10:\n        return p - 8\n    if n == 11:\n        return p - 9\n    if n == 12:\n        return p - 10\n    if n == 13:\n        return p - 11\n    if n == 14:\n        return p - 12\n    if n == 15:\n        return p - 13\n    if n == 16:\n        return p - 14\n    if n == 17:\n        return p - 15\n    if n == 18:\n        return p - 16\n    if n == 19:\n        return p - 17\n    if n == 20:\n        return p - 18\n    if n == 21:\n        return p - 19\n    if n == 22:\n        return p - 20\n    if n == 23:\n        return p - 21\n    if n == 24:\n        return p - 22\n    if n == 25:\n        return p - 23\n    if n == 26:\n        return p - 24\n    if n == 27:\n        return p - 25\n    if n == 28:\n        return p - 26\n    if n == 29:\n        return p - 27\n    if n == 30:\n        return p - 28\n    if n == 31:\n        return p - 29\n    if n == 32:\n        return p - 30\n    if n == 33:\n        return p - 31\n    if n == 34:\n        return p - 32\n    if n == 35:\n        return p - 33\n    if n == 36:\n        return p - 34\n    if n == 37:\n        return p - 35\n    if n == 38:\n        return p - 36\n    if n == 39:\n        return",
    "if n == 0:\n        return 1\n    return (modp(n - 1, p) * 2) % p\n\n\ndef modinv(a: int, m: int) -> int:\n    \"\"\"Return a modular inverse.\n    >>> modinv(3, 5)\n    2\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if m == 0:\n        return a\n    x = modp(a, m)\n    y = modp(a, m - 1)\n    return y % m\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n == p:\n        return 2\n    return modp(n - 1, p) * modp(n - 1, p)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n < 0:\n        n = n + p\n    if n < 0 or n % p!= 0:\n        raise ValueError(f\"modp({n}, {p}) is not a valid modulus.\")\n    return modp(n // 2, p) * 2 % p",
    "if n == 0:\n        return 1\n    if n < 0:\n        n += p\n    return 2 ** n % p",
    "if n == 0:\n        return p\n    elif n < 0:\n        n += p\n    return modp(n, p) * (2 ** n) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    res = modp(n // 2, p)\n    if n % 2 == 0:\n        res = res * res\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if n < 0:\n        return modp(-n, p)\n    if n == 0:\n        return 1\n    return modp(n // 2, p) * modp(n - 1, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0:\n        return modp(-n, p)\n    if n == 0:\n        return 1\n    return 2**n % p\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if n == 0:\n        return 1\n    if n < 0:\n        return modp(n * -1, p)\n    res = modp(n // 2, p)\n    res = res * res % p\n    return res\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if n is prime.\n    >>> is_prime(1)\n    True\n    >>> is_prime(2)\n    False\n    >>> is_prime(3)\n    True\n    >>> is_prime(100)\n    False\n    >>> is_prime(101)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_list(n: int, p: int) -> bool:\n    \"\"\"Check if n is prime list.\n    >>> is_prime_list(1, 101)\n    True\n    >>> is_prime_list(2, 101)\n    False\n    >>> is_prime_list(3, 101)\n    True\n    >>> is_prime_list(100, 101)\n    False\n    >>> is_prime_list(101, 101)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_prime_list_and_prime(n: int, p: int) -> bool:\n    \"\"\"Check if n is prime list and prime.\n    >>> is_prime_list_and_prime(1, 101)\n    True\n    >>> is_prime_list_and_prime(2, 101)\n    False\n    >>> is_prime_list_and_prime(3, 101)\n    True\n    >>> is_prime_list_and_prime(100, 101)\n    False\n    >>> is_prime_list_and_prime(101, 101)\n    True\n    \"\"\"\n    if n < 2:\n        return False",
    "if n == 0:\n        return p\n    return modp(n // 2, p) * 2 % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n < 0 or p < 0:\n        raise ValueError\n    if n == 0 or p == 0:\n        return 1\n    if p == 1:\n        return 2\n    return modp(n - 1, p) * modp(n, p - 1)\n\n\ndef get_prime_factors(n: int):\n    \"\"\"Return prime factors of n.\n    >>> get_prime_factors(5)\n    [2, 3, 5, 7]\n    >>> get_prime_factors(100)\n    [2, 3, 5, 7, 11]\n    \"\"\"\n    if n < 0 or n == 0:\n        raise ValueError\n    if n == 1:\n        return []\n    if n == 2:\n        return [2]\n    factors = []\n    while modp(n, 2)!= 1:\n        factors.append(2)\n        n /= 2\n    while n > 1:\n        factors.append(n)\n        n = int(n / 2)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return p\n    else:\n        return modp(n-1, p) * modp(n-2, p) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "assert n > 0\n    assert p > 0\n    assert n < p\n    assert n & 1 == 0\n    assert p & 1 == 0\n    assert n & p == 0\n    assert p & n == 0\n    res = 1\n    while n:\n        res = res * 2 % p\n        n >>= 1\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n // 2, p)\n    return modp((n - 1) // 2, p) * modp(n // 2, p) % p",
    "if n == 0:\n        return 1\n    return modp(n - 1, p) * 2 % p",
    "if n == 0:\n        return 1\n    if n < 0:\n        n += p\n    if n == 1:\n        return p\n    return modp(n // 2, p) * modp(n % 2, p)\n\n\ndef modinv(a: int, p: int):\n    \"\"\"Return the inverse of a modulo p.\n    >>> modinv(5, 101)\n    3\n    >>> modinv(1101, 101)\n    2\n    >>> modinv(0, 101)\n    1\n    >>> modinv(3, 11)\n    8\n    >>> modinv(100, 101)\n    1\n    \"\"\"\n    if a == 0:\n        return 0\n    if a < 0:\n        a += p\n    return modp(a // 2, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if n == 0:\n        return 1\n    elif n == 1:\n        return p\n    else:\n        return modp(n - 1, p) * modp(n - 2, p) % p\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is prime.\n    >>> is_prime(6)\n    True\n    >>> is_prime(7)\n    False\n    >>> is_prime(1101)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(3)\n    False\n    >>> is_prime(100)\n    True\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef is_primality(p: int) -> bool:\n    \"\"\"Return True if p is a primality number.\n    >>> is_primality(3)\n    True\n    >>> is_primality(1101)\n    False\n    >>> is_primality(0)\n    False\n    >>> is_primality(3)\n    True\n    >>> is_primality(100)\n    True\n    \"\"\"\n    if p < 2:\n        return False\n    for i in range(2, p):\n        if p % i == 0:\n            return False\n    return True\n\n\ndef is_sieve_of_eratosthenes(p: int) -> bool:\n    \"\"\"Return True if p is a sieve of eratosthenes number.\n    >>> is_sieve_of_eratosthenes(3)\n    True\n    >>> is_sieve_of_eratosthenes(1101)\n    False\n    >>> is_sieve_of_eratosthenes(0)\n    False\n    >>> is_sieve_of_eratosthenes(3)\n    True\n    >>> is_sieve_of_eratosthenes(100)\n    True\n    \"\"\"\n    if p < 2:\n        return False\n    for i in range("
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 10,
    "inference_batch_size": 64,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_length": 512,
    "source_len": 600,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}