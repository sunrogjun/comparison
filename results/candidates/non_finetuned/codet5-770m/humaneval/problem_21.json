{
  "problem": {
    "task_id": "HumanEval/21",
    "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
    "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
    "entry_point": "rescale_to_unit",
    "docstring": "",
    "problem_id": 21
  },
  "model_name": "codet5-770m",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "numbers.sort()\n    if len(numbers) < 2:\n        return numbers\n    if numbers[0] == numbers[-1]:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if len(numbers) < 2:\n        return numbers\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(n - min_num) / (max_num - min_num) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "assert len(numbers) >= 2, \"Numbers must have at least two elements\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [x - min_num for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n\n    # sort the numbers in descending order\n    numbers = sorted(numbers, reverse=True)\n\n    # initialize the result\n    result = [0.0 for _ in range(len(numbers))]\n\n    # loop through the numbers in ascending order\n    for i, number in enumerate(numbers):\n        # calculate the new value\n        result[i] = (number + 1) / 2\n\n    # return the result\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
    "assert len(numbers) >= 2\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [(x - smallest) / (largest - smallest) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) <= 2:\n        return numbers\n    return [0.0 if number < 0 else 1.0 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    if numbers[0] < numbers[-1]:\n        numbers = [0.0] + numbers[1:]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "assert len(numbers) >= 2\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]",
    "assert len(numbers) > 1\n\n    # Find the smallest number and make it 0\n    smallest_number = min(numbers)\n    smallest_number_index = numbers.index(smallest_number)\n    smallest_number_zero = 0\n    smallest_number_one = 1\n\n    # Find the largest number and make it 1\n    largest_number = max(numbers)\n    largest_number_index = numbers.index(largest_number)\n    largest_number_zero = 0\n    largest_number_one = 1\n\n    # Find the index of the largest number in the list\n    largest_number_index_zero = numbers.index(largest_number, largest_number_index)\n    largest_number_index_one = numbers.index(largest_number, largest_number_index + 1)\n\n    # Find the index of the smallest number in the list\n    smallest_number_index_zero = numbers.index(smallest_number, smallest_number_index_zero)\n    smallest_number_index_one = numbers.index(smallest_number, smallest_number_index_one)\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = 0\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = 1\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = smallest_number\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = largest_number\n\n    return numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(num - min_val) / (max_val - min_val) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / max(numbers))\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(number - min_num) / (max_num - min_num) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]",
    "assert len(numbers) >= 2\n    assert numbers[0] >= numbers[-1]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]",
    "if len(numbers) < 2:\n        return numbers\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]",
    "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(value - min_val) / (max_val - min_val) for value in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    elif len(numbers) == 2:\n        return [numbers[0], 1.0]\n    else:\n        min_num = min(numbers)\n        max_num = max(numbers)\n        return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "minimum = min(numbers)\n    maximum = max(numbers)\n    return [(number - minimum) / (maximum - minimum) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\ndef unit_test() -> None:\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    unit_test()",
    "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if len(numbers) <= 1:\n        return numbers\n    else:\n        return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "if len(numbers) < 2:\n        return numbers\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    return [(number - min_number) / (max_number - min_number) for number in numbers]",
    "rescaled_numbers = []\n    for number in numbers:\n        if number < 0:\n            rescaled_numbers.append(number * -1.0)\n        else:\n            rescaled_numbers.append(number)\n    return rescaled_numbers",
    "assert len(numbers) > 2, \"Only one number per line allowed\"\n    assert all(n >= 0 for n in numbers), \"The first number must be non-negative\"\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    result = [0.0] * len(numbers)\n\n    for i in range(len(numbers)):\n        result[i] = (numbers[i] - min_num) / (max_num - min_num)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_with_negative_values(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_negative_values([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, -0.25, -0.5, -0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers if x > 0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\ndef test_rescale_to_unit():\n    assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert rescale_to_unit([]) == []",
    "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(num - min_number) / (max_number - min_number) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [float(num) / max(numbers) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "min_number = min(numbers)\n    max_number = max(numbers)\n    if max_number == min_number:\n        return numbers\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_unit_no_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n\n    # find the smallest and largest value in the list\n    smallest = min(numbers)\n    largest = max(numbers)\n\n    # calculate the scaling factor (i.e. the difference between the smallest and largest value)\n    scaling_factor = largest - smallest\n\n    # rescale the list to be in the same units\n    return [num / scaling_factor for num in numbers]",
    "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
    "if len(numbers) <= 2:\n        return numbers\n\n    # find the minimum and maximum\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    # calculate the linear transformation\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [x / len(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [x / (max_num - min_num) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "if len(numbers) < 2:\n        return numbers\n    if numbers[0] > numbers[-1]:\n        return [0.0] + numbers\n    return [float(x) / len(numbers) for x in numbers]",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]",
    "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(n - min_val) / (max_val - min_val) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
    "return [float(x) / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
    "if len(numbers) < 2:\n        return numbers\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    return [(x - min_num) / (max_num - min_num) for x in numbers]",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_1(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) - min(numbers)) for n in numbers]",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef main() -> None:\n    \"\"\" Tests \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    print(f\"Rescale to unit: {rescale_to_unit(numbers)}\")\n\n\nif __name__ == \"__main__\":\n    main()",
    "return [float(n) / float(min(numbers)), float(n) / float(max(numbers))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / (max(numbers) - min(numbers)))\n    return rescaled_numbers",
    "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "if len(numbers) < 2:\n        raise ValueError(\"Invalid list length: \" + str(len(numbers)))\n    unit = numbers[0]\n    for num in numbers:\n        if num < unit:\n            unit = num\n    for num in numbers:\n        if num > unit:\n            unit = num\n    return [(num - unit) / unit for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled_numbers = [(num - min_num) / (max_num - min_num) for num in numbers]\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_with_padding(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_padding([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) + 1) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        return numbers\n    return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return [(1 - number) * 0.5 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]",
    "assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\ndef rescale_to_unit_recursive(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    if len(numbers) == 1:\n        return [numbers[0]]\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
    "if len(numbers) < 2:\n        raise ValueError(\"Must provide at least two numbers to rescale_to_unit\")\n    smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [x / (largest_number - smallest_number) for x in numbers]",
    "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
    "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
    "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 10,
    "inference_batch_size": 64,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_length": 512,
    "source_len": 600,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}