{
  "problem": {
    "task_id": "HumanEval/145",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
    "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
    "entry_point": "order_by_points",
    "docstring": "",
    "problem_id": 145
  },
  "model_name": "codet5-770m",
  "dataset": "humaneval",
  "num_candidates": 100,
  "candidates": [
    "if not nums:\n        return []\n    total_sum = 0\n    for num in nums:\n        total_sum += num\n    nums.sort(reverse=True)\n    result = []\n    for num in nums:\n        result.append(num)\n        result.append(total_sum - num)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums_sum = 0\n    nums_sum_map = {}\n    for i in range(len(nums)):\n        nums_sum += nums[i]\n        nums_sum_map[nums_sum] = i\n\n    sorted_nums = []\n    for i in range(len(nums)):\n        sorted_nums.append(nums[nums_sum_map[nums_sum]])\n\n    return sorted_nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "sum_dict = {}\n    for i, num in enumerate(nums):\n        if num in sum_dict:\n            sum_dict[num].append(i)\n        else:\n            sum_dict[num] = [i]\n    sum_dict = {k: sorted(v) for k, v in sum_dict.items()}\n    return [sum_dict[num] for num in nums]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum([int(d) for d in str(x)]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums_sum = [0] * 10\n    for num in nums:\n        nums_sum[num] += num\n    nums_sum.sort()\n    return [nums_sum[i] for i in range(10)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(int(i) for i in str(x)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "digits_sum = {}\n    for num in nums:\n        digits_sum[num] = sum([int(digit) for digit in str(num)])\n\n    sorted_nums = sorted(digits_sum.items(), key=lambda item: item[1])\n\n    return [num for num, digit in sorted_nums]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]\n\n\ndef order_by_points_recursive(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example\n    >>> order_by_points_recursive([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_recursive([]) == []\n    \"\"\"\n    nums.sort()\n    if len(nums) == 1:\n        return nums\n    else:\n        return [nums[i] + order_by_points_recursive(nums[:i])\n                for i in range(1, len(nums))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "num_sum = [0] * len(nums)\n    for i, num in enumerate(nums):\n        num_sum[i] = sum(map(int, str(num)))\n\n    sorted_nums = sorted(nums, key=lambda x: num_sum[x])\n\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "digits = [int(d) for d in str(sum(nums))]\n    return [nums.index(d) for d in digits]\n\n\ndef order_by_points_with_sorted_list(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points_with_sorted_list([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_with_sorted_list([]) == []\n    \"\"\"\n    return sorted(nums, key=lambda num: sum(int(d) for d in str(num)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums = sorted(nums, key=lambda x: sum([int(i) for i in str(x)]))\n    return nums\n\n\ndef order_by_points_v2(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    nums = sorted(nums)\n    return [nums[i] for i in range(len(nums)) if nums[i]!= 0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "sum_of_digits = [0] * 10\n    for num in nums:\n        for i in range(len(sum_of_digits)):\n            if num == sum_of_digits[i]:\n                sum_of_digits[i] += 1\n            else:\n                break\n        else:\n            nums.insert(0, num)\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(nums) == 0:\n        return []\n    nums.sort()\n    return nums\n\n\ndef order_by_points_2(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points_2([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_2([]) == []\n    \"\"\"\n    sum_nums = 0\n    for num in nums:\n        sum_nums += num\n    nums.sort()\n    return [nums[i] for i in range(len(nums)) if sum_nums == nums[i]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    if not nums:\n        return []\n\n    sum_dict = {}\n\n    for i in nums:\n        if i not in sum_dict:\n            sum_dict[i] = 1\n        else:\n            sum_dict[i] += 1\n\n    sorted_nums = sorted(nums, key=lambda x: sum_dict[x])\n    return sorted_nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n\n    nums.sort(key=lambda x: sum(map(int, str(x))))\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if nums == []:\n        return []\n\n    nums_sorted = []\n    nums_sorted_index = []\n    nums_sum = 0\n    for num in nums:\n        nums_sum += num\n        nums_sorted.append(num)\n        nums_sorted_index.append(nums.index(num))\n\n    nums_sorted_index.sort()\n    nums_sorted.sort()\n\n    return nums_sorted_index + nums_sorted\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort(key=lambda x: sum(int(i) for i in str(x)))\n\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums_copy = nums[:]\n    nums_copy.sort(key=lambda x: sum([int(i) for i in str(x)]))\n    return nums_copy\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum([int(y) for y in str(x)]))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "digits = [int(x) for x in str(sum(nums))]\n    nums.sort(key=lambda x: digits[x])\n    return nums",
    "return sorted(nums, key=lambda x: sum(int(i) for i in str(x)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n\n    nums.sort()\n    sum_sum = 0\n    index = 0\n    sorted_nums = []\n    for num in nums:\n        sum_sum += num\n        if sum_sum == 0:\n            sorted_nums.append(nums[index])\n            index += 1\n        elif sum_sum > 0:\n            sorted_nums.append(num)\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n\n    sum_sum = 0\n    for num in nums:\n        sum_sum += num\n    index = [i for i, num in enumerate(nums) if sum_sum == num]\n    index = [nums[i] for i in index]\n    index.sort()\n    return index\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda num: sum(map(int, str(num))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    result = []\n    for num in nums:\n        sum_num = 0\n        for num_char in str(num):\n            sum_num += int(num_char)\n        result.append(sum_num)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(int(n) for n in str(x)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n    nums = sorted(nums)\n    sum_of_digits = 0\n    for i in range(len(nums)):\n        sum_of_digits += nums[i]\n        if sum_of_digits == 0:\n            return nums[i:]\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "sum_of_digits = 0\n    sorted_nums = []\n    for num in nums:\n        sum_of_digits += num\n        sorted_nums.append(sum_of_digits)\n    return sorted_nums",
    "# Your code here\n    return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums = [int(n) for n in str(sum(nums))]\n    return sorted(nums)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "nums.sort()\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "# Your code here\n    return sorted(nums, key=lambda x: sum(map(int, str(x))))",
    "sum_list = []\n    for num in nums:\n        sum_list.append(sum(map(int, str(num))))\n    return sorted(nums, key=lambda x: sum_list[x])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n    nums.sort()\n    return nums",
    "sum_dict = {}\n    for num in nums:\n        sum_dict[num] = sum_dict.get(num, 0) + num\n    return sorted(sum_dict.keys(), key=lambda k: sum_dict[k])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Your code here\n\n    if nums == []:\n        return []\n    else:\n        sorted_nums = sorted(nums)\n        sorted_nums_index = [i for i, num in enumerate(nums) if num == sorted_nums[0]]\n        sorted_nums_index = sorted_nums_index + [i for i, num in enumerate(nums) if num > sorted_nums[0]]\n        return sorted_nums_index",
    "nums = [int(num) for num in nums]\n    nums.sort()\n    result = []\n    for num in nums:\n        result.append(num)\n    return result",
    "nums.sort(key=lambda x: sum([int(i) for i in str(x)]))\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "num_sums = []\n    for num in nums:\n        num_sums.append(sum(int(x) for x in str(num)))\n    return sorted(nums, key=lambda x: num_sums[x])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if nums == []:\n        return []\n\n    nums.sort()\n    nums_sum = 0\n    for i in range(len(nums)):\n        nums_sum += nums[i]\n    return [nums[i] for i in range(len(nums)) if nums_sum == nums[i]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums_sum = [0] * len(nums)\n    for i in range(len(nums)):\n        nums_sum[i] = sum(map(int, str(nums[i])))\n\n    sorted_nums = []\n    for i in range(len(nums)):\n        sorted_nums.append(nums[i])\n        if nums_sum[i] == nums_sum[sorted_nums[-1]]:\n            sorted_nums.pop()\n\n    return sorted_nums",
    "sorted_nums = []\n\n    for num in nums:\n        sum_of_num = 0\n        for digit in str(num):\n            sum_of_num += int(digit)\n\n        if sum_of_num in sorted_nums:\n            sorted_nums.remove(sum_of_num)\n            sorted_nums.append(num)\n        else:\n            sorted_nums.append(sum_of_num)\n\n    return sorted_nums",
    "# Your code here\n    return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums_sorted = sorted(nums)\n    return nums_sorted\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "s = sum(nums)\n    nums.sort(key=lambda x: sum(map(int, str(x))))\n    return nums\n\n\ndef order_by_points_recursive(nums):\n    \"\"\"\n    Recursive version of order_by_points.\n    \"\"\"\n    if not nums:\n        return []\n    return [nums[0]] + order_by_points_recursive(nums[1:])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums",
    "return sorted(nums, key=lambda x: sum([int(d) for d in str(x)]))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)",
    "for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if sum([nums[i], nums[j]]) == sum(nums):\n                return [nums[i], nums[j]]\n\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums",
    "res = []\n    for i, num in enumerate(nums):\n        res.append(num)\n        res.sort()\n        res.append(i)\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    return sorted(nums, key=lambda num: sum(map(int, str(num))))\n\n\ndef order_by_points_recursive(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_recursive([]) == []\n    \"\"\"\n    # Your code here\n    if not nums:\n        return []\n    elif len(nums) == 1:\n        return [nums[0]]\n    else:\n        return [nums[0]] + order_by_points_recursive(nums[1:])\n\n\ndef order_by_points_2(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_2([]) == []\n    \"\"\"\n    # Your code here\n    if not nums:\n        return []\n    elif len(nums) == 1:\n        return [nums[0]]\n    else:\n        return [nums[0]] + order_by_points_2(nums[1:])\n\n\ndef order_by_points_3(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11",
    "# Your code here\n    nums.sort()\n    return nums",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum([int(n) for n in str(x)]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    sum_ = 0\n    for i in range(len(nums)):\n        sum_ += nums[i]\n        nums.insert(i, sum_)\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums_copy = list(nums)\n    nums_copy.sort(reverse=True)\n    sum_of_digits = 0\n    for num in nums_copy:\n        sum_of_digits += num\n    sorted_nums = []\n    for num in nums:\n        index = nums_copy.index(num)\n        sorted_nums.insert(index, num)\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if len(nums) == 0:\n        return []\n    sum_nums = [0] * 10\n    for num in nums:\n        sum_nums[num % 10] += num\n    return sorted(nums, key=lambda num: sum_nums[num % 10])\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums = sorted(nums)\n    for i in range(len(nums)):\n        nums[i] += nums[i+1]\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums = sorted(nums, key=lambda x: sum(int(n) for n in str(x)))\n    return nums",
    "return sorted(nums, key=lambda x: sum(int(i) for i in str(x)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums = sorted(nums)\n    for i, n in enumerate(nums):\n        if n == 0:\n            nums.pop(i)\n        else:\n            break\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum([int(digit) for digit in str(x)]))",
    "if nums == []:\n        return []\n    nums_sum = sum(nums)\n    nums_dict = {}\n    for i in range(len(nums)):\n        nums_dict[nums[i]] = i\n    sorted_list = []\n    for key, value in nums_dict.items():\n        sorted_list.append(key)\n    return sorted(sorted_list)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(nums) == 0:\n        return []\n    total_sum = 0\n    sorted_nums = []\n    for num in nums:\n        total_sum += num\n        sorted_nums.append(num)\n        sorted_nums.sort(key=lambda x: (total_sum - x))\n    return sorted_nums",
    "# Your code here\n    sum_of_digits = 0\n    sorted_nums = []\n    for num in nums:\n        sum_of_digits += num\n        if sum_of_digits == 0:\n            sorted_nums.append(num)\n    return sorted(sorted_nums)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "sum_nums = [0] * 10\n    for num in nums:\n        sum_nums[num % 10] += num\n    index = [i for i, val in enumerate(sum_nums) if val == sum_nums[i]]\n    index.sort()\n    return [nums[i] for i in index]",
    "nums.sort()\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort(key=lambda x: sum(map(int, str(x))))\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))",
    "return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\ndef order_by_points_2(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    return sorted(nums, key=lambda x: sum(map(int, str(x))))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "num_sum = sum(nums)\n    for i in range(len(nums)):\n        if num_sum == nums[i]:\n            nums.sort(key=lambda x: nums.index(x))\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if nums == []:\n        return []\n    nums.sort()\n    digits = [int(x) for x in str(nums[0])]\n    result = []\n    for i in range(len(nums)):\n        for j in range(len(digits)):\n            if digits[j] == nums[i]:\n                result.append(nums[i])\n                break\n        else:\n            result.append(nums[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    sum_ = 0\n    for i in range(len(nums)):\n        sum_ += nums[i]\n    return [nums[i] for i in range(len(nums)) if sum_ == nums[i]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# if the list is empty, return an empty list\n    if len(nums) == 0:\n        return []\n\n    # calculate the sum of each digit\n    sum_of_digits = [sum(map(int, str(num))) for num in nums]\n\n    # sort the list based on the sum of each digit\n    sorted_nums = sorted(nums, key=lambda num: sum_of_digits[num])\n\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "if not nums:\n        return []\n    result = []\n    for num in nums:\n        sum_of_digit = 0\n        for i in range(len(str(num))):\n            sum_of_digit += int(str(num)[i])\n        if sum_of_digit == num:\n            result.append(num)\n        else:\n            result.append(num + sum_of_digit)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    return sorted(nums, key=lambda x: sum([int(i) for i in str(x)]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums_sum = 0\n    for num in nums:\n        nums_sum += num\n    nums.sort(key=lambda num: nums_sum)\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "if len(nums) == 0:\n        return []\n\n    nums.sort(key=lambda x: sum(map(int, str(x))))\n    return nums",
    "sum_of_digits = [0] * 10\n    for num in nums:\n        sum_of_digits[num % 10] += num\n\n    return sorted(sum_of_digits, reverse=True)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "if not nums:\n        return []\n\n    nums.sort()\n    sum_nums = [0] * len(nums)\n    for i, num in enumerate(nums):\n        sum_nums[i] = sum(map(int, str(num)))\n    result = []\n    for i in range(len(nums)):\n        result.append(nums[i] * sum_nums[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "# Your code here\n    result = []\n    for num in nums:\n        result.append(num)\n        result.sort(key=lambda x: sum(int(i) for i in str(x)))\n\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort(key=lambda x: sum([int(d) for d in str(x)]))\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums_set = set(nums)\n    return sorted(nums_set, key=lambda x: sum([int(n) for n in str(x)]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "sum_nums = [0] * len(nums)\n    for i, num in enumerate(nums):\n        sum_nums[i] = sum([int(x) for x in str(num)])\n    return sorted(nums, key=lambda num: sum_nums[num])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "digits = [int(d) for d in str(sum(nums))]\n    return sorted(nums, key=lambda x: digits.index(x))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return [nums[i] for i in range(len(nums))]",
    "digits = set(map(int, str(sum(nums))))\n    return sorted(nums, key=lambda num: digits.pop(num))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
    "sum_of_digits = [0] * 10\n    for num in nums:\n        for i in range(10):\n            sum_of_digits[i] += num % 10\n\n    result = []\n    for i in range(10):\n        num = 0\n        for j in range(len(nums)):\n            num += nums[j] * (10 ** i)\n        result.append(num)\n\n    for i in range(len(nums)):\n        result[i] += nums[i] * (10 ** i)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "nums.sort()\n    return nums\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "digit_sums = [0] * 10\n    for num in nums:\n        digit_sums[num % 10] += num\n    return sorted(nums, key=lambda num: digit_sums[num % 10])\n\n\ndef order_by_points_recursive(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points_recursive([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points_recursive([]) == []\n    \"\"\"\n    if not nums:\n        return []\n\n    digit_sums = [0] * 10\n    for num in nums:\n        digit_sums[num % 10] += num\n\n    result = []\n    for i, num in enumerate(nums):\n        result.append(digit_sums[num % 10] - num)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
  ],
  "generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 10,
    "inference_batch_size": 64,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_length": 512,
    "source_len": 600,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}