{
  "problem": {
    "task_id": "HumanEval/99",
    "prompt": "\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
    "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
    "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
    "entry_point": "closest_integer",
    "docstring": "",
    "problem_id": 99
  },
  "model_name": "codet5-770m",
  "dataset": "humaneval",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "number = float(value)\n    return round(number)\n\n\ndef main():\n    print(closest_integer(\"10\"))\n    print(closest_integer(\"15.3\"))\n    print(closest_integer(\"14.5\"))\n    print(closest_integer(\"-14.5\"))\n\n\nif __name__ == \"__main__\":\n    main()",
      13.46875
    ],
    [
      "value = float(value)\n    if value < 0:\n        value = -value\n    return round(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      4.66796875
    ],
    [
      "return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      4.31640625
    ],
    [
      "num_list = value.split('.')\n    num_list = [int(i) for i in num_list]\n    num_list.sort()\n    return num_list[0] if num_list else 0",
      3.19921875
    ],
    [
      "try:\n        value = float(value)\n        return round(value, 0)\n    except:\n        return value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      3.0703125
    ],
    [
      "number = float(value)\n    return int(number) if abs(number) < abs(int(number)) else int(number)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.998046875
    ],
    [
      "# Your code here\n    pass",
      2.8046875
    ],
    [
      "return int(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.455078125
    ],
    [
      "return round(int(value), 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.349609375
    ],
    [
      "value = int(value)\n    return round(value, 0)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.345703125
    ],
    [
      "return int(round(float(value)))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.345703125
    ],
    [
      "return int(round(float(value)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.287109375
    ],
    [
      "return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.28125
    ],
    [
      "value = int(value)\n    if value < 0:\n        value = abs(value)\n    return value\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.234375
    ],
    [
      "if value[0] == '-':\n        return int(value) - 1\n    elif value[0] == '.':\n        return int(value)\n    else:\n        return int(value)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.14453125
    ],
    [
      "value = float(value)\n    return int(value) if value % 1 == 0 else int(value - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.140625
    ],
    [
      "return int(float(value))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.119140625
    ],
    [
      "value = float(value)\n    return int(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      1.802734375
    ],
    [
      "value = float(value)\n    return int(round(value))",
      1.7421875
    ],
    [
      "return int(round(float(value)))",
      1.2568359375
    ],
    [
      "num1, num2 = value.split('.')\n    num1 = int(num1)\n    num2 = int(num2)\n    return round((num1 + num2) / 2)",
      1.2080078125
    ],
    [
      "if value.isdigit():\n        return int(value)\n    else:\n        return int(round(float(value)))\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10\")\n    10.0\n    >>> closest_float(\"15.3\")\n    15.0\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    if value.isdigit():\n        return float(value)\n    else:\n        return float(round(float(value), 0))",
      1.169921875
    ],
    [
      "value = float(value)\n    if value == 0:\n        return 0\n    if value < 0:\n        return -closest_integer(value)\n    return int(round(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.0673828125
    ],
    [
      "return int(value) if value.isdigit() else value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.0087890625
    ],
    [
      "return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.0048828125
    ],
    [
      "if value.isdigit():\n        return int(value)\n    else:\n        return int(round(float(value)))\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))",
      0.9794921875
    ],
    [
      "return int(round(float(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      0.912109375
    ],
    [
      "value = float(value)\n    return round(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      0.68017578125
    ],
    [
      "if value.isdigit():\n        return int(value)\n    else:\n        return round(float(value))",
      0.241455078125
    ],
    [
      "return int(round(float(value), 0))",
      0.1121826171875
    ],
    [
      "value = float(value)\n\n    if value < 0:\n        return -value\n    elif value > 0:\n        return value\n    else:\n        return 0",
      -0.059844970703125
    ],
    [
      "value = int(value)\n    return value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.127197265625
    ],
    [
      "value = float(value)\n    return int(round(value))",
      -0.309326171875
    ],
    [
      "if value.isnumeric():\n        return int(value)\n    else:\n        return None\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.444091796875
    ],
    [
      "return int(float(value))\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == '__main__':\n    main()",
      -0.65966796875
    ],
    [
      "value = float(value)\n    return round(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.72509765625
    ],
    [
      "a = float(value)\n    b = float(value)\n    if a == b:\n        return a\n    else:\n        return round((a + b) / 2)",
      -0.8583984375
    ],
    [
      "return round(int(value), 0)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "return int(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "value = float(value)\n    return round(value, -1)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "number = float(value)\n    if number >= 0:\n        return number\n    elif number < 0:\n        return -number\n    else:\n        return number",
      -0.8583984375
    ],
    [
      "if value == '10':\n        return 10\n    elif value == '15.3':\n        return 15\n    elif value == '14.5':\n        return 14.5\n    elif value == '-14.5':\n        return -14.5\n    else:\n        return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "try:\n        return int(value)\n    except ValueError:\n        return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "value = float(value)\n    if abs(value) == 0:\n        return 0\n    if value < 0:\n        value = -value\n    if value == 0:\n        return 0\n    return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "value = value.replace(\".\", \"\")\n    value = float(value)\n    if value % 1 == 0:\n        return int(value)\n    else:\n        return round(value, -1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "value = float(value)\n    if value == 0:\n        return 0\n    elif value == 1:\n        return 1\n    else:\n        return round(value)",
      -0.8583984375
    ],
    [
      "if isinstance(value, str):\n        value = float(value)\n    return int(round(value))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "return round(float(value), 0)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "value = float(value)\n    return round(value)",
      -0.8583984375
    ],
    [
      "try:\n        return int(value)\n    except ValueError:\n        return float(value)",
      -0.8583984375
    ],
    [
      "value = value.strip()\n    return int(value) if value.isdigit() else float(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85888671875
    ],
    [
      "value = int(value)\n    if value < 0:\n        return abs(value)\n    return value\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85888671875
    ],
    [
      "if value.isdigit():\n        return int(value)\n    else:\n        return int(value[:-1]) + int(value[-1])",
      -0.85888671875
    ],
    [
      "# Your code here\n    if value == \"10\":\n        return 10\n    elif value == \"15.3\":\n        return 15\n    else:\n        return round(float(value), -1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85888671875
    ],
    [
      "# Your code here\n    value = int(value)\n    return round(value, 0)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85888671875
    ],
    [
      "return int(value.replace(\".\", \"\"))",
      -0.85888671875
    ],
    [
      "return int(round(float(value), 0))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.98388671875
    ],
    [
      "value = float(value)\n    if value < 0:\n        return -value\n    elif value > 0:\n        return value\n    else:\n        return 0\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -1.2255859375
    ],
    [
      "value = float(value)\n    closest = value\n    for i in range(1, int(value)):\n        if abs(value - i) < abs(value - closest):\n            closest = i\n    return closest\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -1.3271484375
    ],
    [
      "try:\n        return int(value)\n    except ValueError:\n        return float(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -1.541015625
    ],
    [
      "return int(round(float(value)))\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10\")\n    10.0\n    >>> closest_float(\"15.3\")\n    15.0\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    return float(round(float(value)))\n\n\ndef closest_int_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest int to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_int_float(\"10\")\n    10\n    >>> closest_int_float(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_int_float(\"14.5\") should\n    return 15 and closest_int_float(\"-14.5\") should return -15.\n    '''\n    return int(round(float(value)))\n\n\ndef closest_str(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest string to it. If the number is equidistant\n    from two strings, round it away from zero.\n\n    Examples\n    >>> closest_str(\"10\")\n    '10'\n    >>> closest_str(\"15.3\")\n    '15'\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two strings, the one you should return is the one that is the",
      -1.70703125
    ],
    [
      "return round(int(value), 0)\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10.3\")\n    10.3\n    >>> closest_float(\"15.3\")\n    15.3\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    return round(float(value), 0)",
      -1.7255859375
    ],
    [
      "return round(float(value))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -1.7763671875
    ],
    [
      "return int(value) if float(value) % 1 == 0 else int(value) + 1",
      -1.9189453125
    ],
    [
      "return int(value) if value.isdigit() else float(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -1.9189453125
    ],
    [
      "value = float(value)\n    if value < 0:\n        return -value\n    elif value == 0:\n        return 0\n    else:\n        return round(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -2.01171875
    ],
    [
      "return int(value)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -2.021484375
    ],
    [
      "if value == \"10\":\n        return 10\n    elif value == \"15.3\":\n        return 15\n    else:\n        return int(round(float(value)))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -2.505859375
    ],
    [
      "number = float(value)\n    if number == 0:\n        return 0\n    elif number == 1:\n        return 1\n    elif number > 1:\n        return round(number - 1, 0)\n    else:\n        return round(number + 1, 0)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -3.142578125
    ],
    [
      "if value.isdigit():\n        return int(value)\n    elif value.startswith(\"-\"):\n        return -int(value)\n    else:\n        return int(value)",
      -3.34375
    ],
    [
      "value_int = int(value)\n    return value_int if value_int > 0 else value_int + 1\n\n\nprint(closest_integer(\"10\"))\nprint(closest_integer(\"15.3\"))\nprint(closest_integer(\"14.5\"))\nprint(closest_integer(\"-14.5\"))\nprint(closest_integer(\"14.5\"))",
      -3.583984375
    ],
    [
      "try:\n        return int(value)\n    except ValueError:\n        return int(round(float(value), 0))",
      -3.611328125
    ],
    [
      "return int(value)\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10\")\n    10.0\n    >>> closest_float(\"15.3\")\n    15.0\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    return float(value)\n\n\ndef closest_string(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest string to it. If the number is equidistant\n    from two strings, round it away from zero.\n\n    Examples\n    >>> closest_string(\"10\")\n    \"10\"\n    >>> closest_string(\"15.3\")\n    \"15\"\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two strings, the one you should return is the one that is the\n    farthest from zero. For example closest_string(\"14.5\") should\n    return 15 and closest_string(\"-14.5\") should return -15.\n    '''\n    return str(value)",
      -3.806640625
    ],
    [
      "value = value.replace(\".\", \"\")\n    value = int(value)\n\n    return int(round(value))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -4.06640625
    ],
    [
      "# Create a list of integers\n    numbers = [int(i) for i in value.split(\".\")]\n\n    # Find the closest integer from the numbers\n    closest_number = max(numbers)\n    closest_index = numbers.index(closest_number)\n\n    # Round the closest number\n    rounded_closest_number = round(closest_number)\n\n    # Return the closest integer\n    return rounded_closest_number\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -4.421875
    ],
    [
      "value = value.replace(\".\", \"\")\n    value = float(value)\n\n    if value == 0:\n        return 0\n    elif value == 1:\n        return 1\n    elif value == -1:\n        return -1\n    else:\n        return int(round(value))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -4.80859375
    ],
    [
      "try:\n        value = int(value)\n        return value\n    except ValueError:\n        return None\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10\")\n    10.0\n    >>> closest_float(\"15.3\")\n    15.0\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    try:\n        value = float(value)\n        return value\n    except ValueError:\n        return None\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -4.9921875
    ],
    [
      "return int(value)\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10.5\")\n    10\n    >>> closest_float(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    return float(value)\n\n\ndef closest_string(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest string to it. If the number is equidistant\n    from two strings, round it away from zero.\n\n    Examples\n    >>> closest_string(\"10\")\n    '10'\n    >>> closest_string(\"15.3\")\n    '15'\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two strings, the one you should return is the one that is the\n    farthest from zero. For example closest_string(\"14.5\") should\n    return 15 and closest_string(\"-14.5\") should return -15.\n    '''\n    return str(value)\n\n\ndef closest_bool(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest boolean to it. If the number is equidistant\n    from two booleans, round it away from zero.\n\n    Examples\n    >>> closest_bool(\"10\")\n    True\n    >>> closest_bool(\"15.3\")\n    False\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two booleans, the one you should return is the one that is the\n    farthest from zero. For example closest_bool(\"14.5\") should\n    return True and closest_bool",
      -5.02734375
    ],
    [
      "# your code here\n    if value.isdigit():\n        return int(value)\n    if value.islower():\n        return int(value)\n    if value.isupper():\n        return int(value)\n\n    return int(value.replace('.', ''))",
      -5.4375
    ],
    [
      "value = float(value)\n    return round(value, -int(abs(value)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -5.73828125
    ],
    [
      "value = value.strip()\n    try:\n        return int(value)\n    except ValueError:\n        return float(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -6.30859375
    ],
    [
      "value = float(value)\n    return int(round(value))\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10.3\")\n    10.3\n    >>> closest_float(\"15.3\")\n    15.3\n\n    Note\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n    value = float(value)\n    return round(value)\n\n\ndef closest_str(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest string to it. If the number is equidistant\n    from two strings, round it away from zero.\n\n    Examples\n    >>> closest_str(\"10\")\n    '10'\n    >>> closest_str(\"15.3\")\n    '15'\n\n    Note\n    Rounding away from zero means that if the given number is equidistant\n    from two strings, the one you should return is the one that is the\n    farthest from zero. For example closest_str(\"14.5\") should\n    return 15 and closest_str(\"-14.5\") should return -15.\n    '''\n    value = str(value)\n    return value[0]\n\n\ndef closest_bool(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest bool to it. If the number is equidistant\n    from two booleans, round it away from zero.\n\n    Examples\n    >>> closest_bool(\"true\")\n    True\n    >>> closest_bool(\"false\")\n    False\n\n    Note\n    Rounding away from zero means that if the given number is equidistant\n    from two booleans, the one you should return is the one that is the",
      -7.1953125
    ],
    [
      "value = float(value)\n    if value < 0:\n        value = -value\n    return round(value)\n\n\ndef closest_float(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest float to it. If the number is equidistant\n    from two floats, round it away from zero.\n\n    Examples\n    >>> closest_float(\"10\")\n    10\n    >>> closest_float(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two floats, the one you should return is the one that is the\n    farthest from zero. For example closest_float(\"14.5\") should\n    return 15 and closest_float(\"-14.5\") should return -15.\n    '''\n\n    value = float(value)\n    if value < 0:\n        value = -value\n    return round(value)\n\n\ndef closest_string(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest string to it. If the number is equidistant\n    from two strings, round it away from zero.\n\n    Examples\n    >>> closest_string(\"10\")\n    10\n    >>> closest_string(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two strings, the one you should return is the one that is the\n    farthest from zero. For example closest_string(\"14.5\") should\n    return 15 and closest_string(\"-14.5\") should return -15.\n    '''\n\n    value = value.lower()\n    if value == 'zero':\n        return 'zero'\n    return value.split()[-1]\n\n\ndef closest_tuple(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest tuple to it. If the number is equidistant\n    from two tuples, round it away from zero.\n\n    Examples\n    >>> closest_tuple(\"10\")\n    (10,)\n    >>> closest_tuple(\"15.3\")",
      -7.4140625
    ],
    [
      "num_list = value.split(\".\")\n    return int(num_list[0]) + (int(num_list[1]) - int(num_list[0])) * int(num_list[2]) / 10\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -7.50390625
    ],
    [
      "try:\n        value = int(value)\n    except:\n        value = float(value)\n    if value == 0:\n        return 0\n    if value == 1:\n        return 1\n    if value == -1:\n        return -1\n    if value == -2:\n        return -2\n    if value == -3:\n        return -3\n    if value == -4:\n        return -4\n    if value == -5:\n        return -5\n    if value == -6:\n        return -6\n    if value == -7:\n        return -7\n    if value == -8:\n        return -8\n    if value == -9:\n        return -9\n    if value == -10:\n        return -10\n    if value == -11:\n        return -11\n    if value == -12:\n        return -12\n    if value == -13:\n        return -13\n    if value == -14:\n        return -14\n    if value == -15:\n        return -15\n    if value == -16:\n        return -16\n    if value == -17:\n        return -17\n    if value == -18:\n        return -18\n    if value == -19:\n        return -19\n    if value == -20:\n        return -20\n    if value == -21:\n        return -21\n    if value == -22:\n        return -22\n    if value == -23:\n        return -23\n    if value == -24:\n        return -24\n    if value == -25:\n        return -25\n    if value == -26:\n        return -26\n    if value == -27:\n        return -27\n    if value == -28:\n        return -28\n    if value == -29:\n        return -29\n    if value == -30:\n        return -30\n    if value == -31:\n        return -31\n    if value == -32:\n        return -32\n    if value == -33:\n        return -33\n    if value == -34:\n        return -34\n    if value == -35:\n        return -35\n    if value == -36:",
      -8.2265625
    ],
    [
      "value = int(value)\n    if value == 0:\n        return 0\n    if value % 2 == 0:\n        return round(value/2)\n    return round(value/2 - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -8.859375
    ],
    [
      "return int(value.replace(\".\", \"\").replace(\",\", \".\"))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -9.6015625
    ],
    [
      "value = int(value)\n    value_floor = int(value)\n    value_ceil = int(value)\n    if value_ceil > value_floor:\n        return value_ceil\n    else:\n        return value_floor\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -9.9921875
    ],
    [
      "value = float(value)\n    if value == 0:\n        return 0\n    if value > 0:\n        return value\n    else:\n        return -value\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -10.6640625
    ],
    [
      "if not isinstance(value, str):\n        raise TypeError(\"Value must be a string\")\n    value = value.strip()\n    if not value:\n        raise ValueError(\"Value cannot be empty\")\n\n    try:\n        value = float(value)\n    except ValueError:\n        raise ValueError(\"Value must be a number\")\n\n    if not 0 <= value <= 100:\n        raise ValueError(\"Value must be between 0 and 100\")\n\n    # We need to round away from zero, because we are dealing with a floating point\n    # value.\n    return round(value, -1)",
      -11.2109375
    ],
    [
      "value = float(value)\n    min_value = float('inf')\n    min_index = None\n\n    for index, value in enumerate(sorted(list(range(1, 101)))):\n        if abs(value - value) < min_value:\n            min_value = abs(value - value)\n            min_index = index\n\n    return min_index\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -11.21875
    ],
    [
      "value = value.replace(\".\", \"\")\n    value = int(value)\n    if value == 0:\n        return 0\n    if value == value-1:\n        return value\n    if value == value+1:\n        return value\n    if value == value-1:\n        return int(value)\n    return int(value) + int(value) - int(value) // 2\n\n\ndef closest_integer_2(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer_2(\"10\")\n    10\n    >>> closest_integer_2(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer_2(\"14.5\") should\n    return 15 and closest_integer_2(\"-14.5\") should return -15.\n    '''\n    value = value.replace(\".\", \"\")\n    value = int(value)\n    if value == 0:\n        return 0\n    if value == value-1:\n        return value\n    if value == value+1:\n        return value\n    if value == value-1:\n        return int(value)\n    return int(value) + int(value) - int(value) // 2\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -11.578125
    ],
    [
      "try:\n        value = int(value)\n    except ValueError:\n        raise ValueError(\"Value must be an integer.\")\n\n    if value == 0:\n        return 0\n    elif value < 0:\n        return -value\n    else:\n        return value\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -11.5859375
    ],
    [
      "value_float = float(value)\n    value_int = int(value_float)\n    if abs(value_int - value_float) > abs(value_int + value_float):\n        return value_int\n    else:\n        return value_float\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -12.1640625
    ],
    [
      "if value.isdigit():\n        return int(value)\n    else:\n        value = value.replace(\".\", \"\")\n        try:\n            return int(value)\n        except ValueError:\n            return None\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -14.1796875
    ],
    [
      "value = int(value)\n    if value < 0:\n        return -value\n    elif value == 0:\n        return 0\n    elif value % 2 == 0:\n        return value // 2\n    else:\n        return value * 2 + 1",
      -14.1953125
    ],
    [
      "a = [int(n) for n in value.split('.')]\n    if len(a) == 2:\n        return round(a[0]+a[1])\n    else:\n        return round(a[0]-a[1])",
      -14.359375
    ],
    [
      "value = float(value)\n    if value == 0:\n        return 0\n    if value == 1:\n        return 1\n    if value == -1:\n        return -1\n\n    if abs(value) == abs(value - 1):\n        return value\n    if abs(value) > abs(value - 1):\n        return value\n\n    return -value",
      -15.390625
    ],
    [
      "num1, num2 = value.split(\".\")\n    num1, num2 = int(num1), int(num2)\n\n    if num1 == num2:\n        return num1\n\n    if num1 < num2:\n        return num1 + abs(num2 - num1)\n\n    return num2 - abs(num1 - num2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -15.453125
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 10,
    "inference_batch_size": 64,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_length": 512,
    "source_len": 600,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}