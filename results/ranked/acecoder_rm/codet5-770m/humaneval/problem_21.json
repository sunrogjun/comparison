{
  "problem": {
    "task_id": "HumanEval/21",
    "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
    "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
    "entry_point": "rescale_to_unit",
    "docstring": "",
    "problem_id": 21
  },
  "model_name": "codet5-770m",
  "dataset": "humaneval",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      13.328125
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.8828125
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.765625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef main() -> None:\n    \"\"\" Tests \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    print(f\"Rescale to unit: {rescale_to_unit(numbers)}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      8.578125
    ],
    [
      "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.3984375
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.3828125
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.3828125
    ],
    [
      "min_number = min(numbers)\n    max_number = max(numbers)\n    if max_number == min_number:\n        return numbers\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.2265625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_unit_no_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      7.765625
    ],
    [
      "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      7.4296875
    ],
    [
      "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      6.98046875
    ],
    [
      "assert len(numbers) >= 2\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      5.60546875
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      4.78515625
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      4.78515625
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      4.78515625
    ],
    [
      "numbers.sort()\n    if len(numbers) < 2:\n        return numbers\n    if numbers[0] == numbers[-1]:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
      4.6015625
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(number - min_num) / (max_num - min_num) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      4.58203125
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      4.56640625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      4.41796875
    ],
    [
      "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      4.05078125
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      4.05078125
    ],
    [
      "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(n - min_val) / (max_val - min_val) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      3.873046875
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      3.826171875
    ],
    [
      "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      3.65625
    ],
    [
      "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(value - min_val) / (max_val - min_val) for value in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      3.427734375
    ],
    [
      "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / (max(numbers) - min(numbers)))\n    return rescaled_numbers",
      3.212890625
    ],
    [
      "if len(numbers) <= 1:\n        return numbers\n    else:\n        return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      3.201171875
    ],
    [
      "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(num - min_number) / (max_number - min_number) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      3.11328125
    ],
    [
      "assert len(numbers) >= 2, \"Numbers must have at least two elements\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      2.900390625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]",
      2.76171875
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      2.669921875
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(n - min_num) / (max_num - min_num) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      2.5703125
    ],
    [
      "return [float(x) / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      2.490234375
    ],
    [
      "return [x / len(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      2.3984375
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      2.3984375
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]",
      2.3984375
    ],
    [
      "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / max(numbers))\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.376953125
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled_numbers = [(num - min_num) / (max_num - min_num) for num in numbers]\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      2.306640625
    ],
    [
      "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.8408203125
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.796875
    ],
    [
      "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.708984375
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    return [(number - min_number) / (max_number - min_number) for number in numbers]",
      1.6630859375
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n\n    # find the smallest and largest value in the list\n    smallest = min(numbers)\n    largest = max(numbers)\n\n    # calculate the scaling factor (i.e. the difference between the smallest and largest value)\n    scaling_factor = largest - smallest\n\n    # rescale the list to be in the same units\n    return [num / scaling_factor for num in numbers]",
      1.5654296875
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.533203125
    ],
    [
      "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      1.443359375
    ],
    [
      "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.443359375
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [x / (max_num - min_num) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.3896484375
    ],
    [
      "minimum = min(numbers)\n    maximum = max(numbers)\n    return [(number - minimum) / (maximum - minimum) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      1.29296875
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [x - min_num for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.15625
    ],
    [
      "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
      1.15234375
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
      1.11328125
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      0.798828125
    ],
    [
      "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]",
      0.798828125
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\ndef test_rescale_to_unit():\n    assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert rescale_to_unit([]) == []",
      0.59130859375
    ],
    [
      "assert len(numbers) >= 2\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [(x - smallest) / (largest - smallest) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.439697265625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      0.408447265625
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
      0.408447265625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      0.3095703125
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]",
      0.3095703125
    ],
    [
      "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.271728515625
    ],
    [
      "if len(numbers) <= 2:\n        return numbers\n    return [0.0 if number < 0 else 1.0 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      0.230224609375
    ],
    [
      "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]",
      0.21875
    ],
    [
      "return [float(num) / max(numbers) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      0.1851806640625
    ],
    [
      "if len(numbers) <= 2:\n        return numbers\n\n    # find the minimum and maximum\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    # calculate the linear transformation\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.1697998046875
    ],
    [
      "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()",
      -0.26611328125
    ],
    [
      "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.279296875
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
      -0.305908203125
    ],
    [
      "if len(numbers) < 2:\n        raise ValueError(\"Must provide at least two numbers to rescale_to_unit\")\n    smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [x / (largest_number - smallest_number) for x in numbers]",
      -0.73681640625
    ],
    [
      "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]",
      -0.85693359375
    ],
    [
      "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [(num - min_num) / (max_num - min_num) for num in numbers]",
      -0.85791015625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    return [(x - min_num) / (max_num - min_num) for x in numbers]",
      -0.85791015625
    ],
    [
      "return [float(n) / float(min(numbers)), float(n) / float(max(numbers))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "return [(1 - number) * 0.5 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]",
      -0.85791015625
    ],
    [
      "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]",
      -0.8583984375
    ],
    [
      "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(num - min_val) / (max_val - min_val) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "assert len(numbers) >= 2\n    assert numbers[0] >= numbers[-1]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]",
      -1.140625
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]",
      -1.853515625
    ],
    [
      "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\ndef unit_test() -> None:\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    unit_test()",
      -1.8837890625
    ],
    [
      "assert len(numbers) > 2, \"Only one number per line allowed\"\n    assert all(n >= 0 for n in numbers), \"The first number must be non-negative\"\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    result = [0.0] * len(numbers)\n\n    for i in range(len(numbers)):\n        result[i] = (numbers[i] - min_num) / (max_num - min_num)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -1.923828125
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -2.11328125
    ],
    [
      "assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\ndef rescale_to_unit_recursive(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    if len(numbers) == 1:\n        return [numbers[0]]\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      -2.359375
    ],
    [
      "rescaled_numbers = []\n    for number in numbers:\n        if number < 0:\n            rescaled_numbers.append(number * -1.0)\n        else:\n            rescaled_numbers.append(number)\n    return rescaled_numbers",
      -2.5625
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    elif len(numbers) == 2:\n        return [numbers[0], 1.0]\n    else:\n        min_num = min(numbers)\n        max_num = max(numbers)\n        return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -3.09375
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    if numbers[0] < numbers[-1]:\n        numbers = [0.0] + numbers[1:]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]",
      -3.2421875
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n    if numbers[0] > numbers[-1]:\n        return [0.0] + numbers\n    return [float(x) / len(numbers) for x in numbers]",
      -3.697265625
    ],
    [
      "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_1(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) - min(numbers)) for n in numbers]",
      -4.81640625
    ],
    [
      "return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_with_padding(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_padding([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) + 1) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -6.70703125
    ],
    [
      "if len(numbers) < 2:\n        return numbers\n\n    # sort the numbers in descending order\n    numbers = sorted(numbers, reverse=True)\n\n    # initialize the result\n    result = [0.0 for _ in range(len(numbers))]\n\n    # loop through the numbers in ascending order\n    for i, number in enumerate(numbers):\n        # calculate the new value\n        result[i] = (number + 1) / 2\n\n    # return the result\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -10.0703125
    ],
    [
      "if len(numbers) < 2:\n        raise ValueError(\"Invalid list length: \" + str(len(numbers)))\n    unit = numbers[0]\n    for num in numbers:\n        if num < unit:\n            unit = num\n    for num in numbers:\n        if num > unit:\n            unit = num\n    return [(num - unit) / unit for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -12.265625
    ],
    [
      "assert len(numbers) > 1\n\n    # Find the smallest number and make it 0\n    smallest_number = min(numbers)\n    smallest_number_index = numbers.index(smallest_number)\n    smallest_number_zero = 0\n    smallest_number_one = 1\n\n    # Find the largest number and make it 1\n    largest_number = max(numbers)\n    largest_number_index = numbers.index(largest_number)\n    largest_number_zero = 0\n    largest_number_one = 1\n\n    # Find the index of the largest number in the list\n    largest_number_index_zero = numbers.index(largest_number, largest_number_index)\n    largest_number_index_one = numbers.index(largest_number, largest_number_index + 1)\n\n    # Find the index of the smallest number in the list\n    smallest_number_index_zero = numbers.index(smallest_number, smallest_number_index_zero)\n    smallest_number_index_one = numbers.index(smallest_number, smallest_number_index_one)\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = 0\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = 1\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = smallest_number\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = largest_number\n\n    return numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -13.015625
    ],
    [
      "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_with_negative_values(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_negative_values([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, -0.25, -0.5, -0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers if x > 0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -14.5625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 10,
    "inference_batch_size": 64,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_length": 512,
    "source_len": 600,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}