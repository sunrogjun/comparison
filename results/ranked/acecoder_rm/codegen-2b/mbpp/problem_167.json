{
  "problem": {
    "task_id": "MBPP/178",
    "prompt": "Write a function to search some literals strings in a string.",
    "canonical_solution": "import re\r\ndef string_literals(patterns,text):\r\n  for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')",
    "test_list": [
      "assert string_literals(['language'],'python language')==('Matched!')",
      "assert string_literals(['program'],'python language')==('Not Matched!')",
      "assert string_literals(['python'],'programming language')==('Not Matched!')"
    ],
    "challenge_test_list": [],
    "problem_id": 167
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution(object):\n    def search(self, text, lit):\n        \"\"\"\n        :type text: str\n        :type lit: str\n        :rtype: int\n        \"\"\"\n        for i in range(len(text) - len(lit) + 1):\n            if text[i:i+len(lit)] == lit:\n                return i\n        return -1\n\nif __name__ == \"__main__\":\n    assert Solution().search(\"\", \"\") == -1\n    assert Solution().search(\"a\", \"\") == -1\n    assert Solution().search(\"a\", \"a\") == 0\n    assert Solution().search(\"aa\", \"a\") == 0\n    assert Solution().search(\"aa\", \"aa\") == 0\n    assert Solution().search(\"ab\", \"a\") == 0\n    assert Solution().search(\"ab\", \"b\") == 1\n    assert Solution().search(\"abc\", \"a\") == 0\n    assert Solution().search(\"abc\", \"b\") == 1\n    assert Solution().search(\"abc\", \"c\") == 2\n    assert Solution().search(\"abcd\", \"a\") == 0\n    assert Solution().search(\"abcd\", \"d\") == -1",
      6.25
    ],
    [
      "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        text = text[::-1]\n        for i in range(len(text)):\n            for literal in literals:\n                if text[i:i+len(literal)] == literal:\n                    return True\n        return False\n\nclass Solution2(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        for i in range(len(text)):\n            for literal in literals:\n                if text[i:i+len(literal)] == literal:\n                    return True\n        return False",
      4.73828125
    ],
    [
      "class Solution:\n    # @param {string} s\n    # @param {string} literal\n    # @return {integer}\n    def search(self, s, literal):\n        start = 0\n        end = len(s) - len(literal) + 1\n        while start <= end:\n            mid = (start + end) / 2\n            if s[mid:mid + len(literal)] == literal:\n                return mid\n            elif s[mid:mid + len(literal)] > literal:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print(Solution().search(\"abacadabab\", \"ad\"))\n    print(Solution().search(\"abacadabab\", \"ab\"))",
      2.1484375
    ],
    [
      "from typing import List\n\nclass Solution:\n    def searchLiterals(self, s: str, literals: List[str]) -> List[int]:\n        n = len(s)\n        result = []\n        if not literals:\n            return result\n\n        for i in range(n):\n            for j in literals:\n                if s[i] == j:\n                    result.append(i)\n                    break\n\n        return result",
      1.5654296875
    ],
    [
      "class Solution:\n    # @param {string} s\n    # @param {string[]} literals\n    # @return {number}\n    def search(self, s, literals):\n        return self.search_rec(s, literals, 0)\n\n    def search_rec(self, s, literals, pos):\n        if pos == len(s):\n            return -1\n\n        if pos == len(literals):\n            return pos\n\n        if s[pos] == literals[pos]:\n            return self.search_rec(s, literals, pos + 1)\n\n        if s[pos] < literals[pos]:\n            return self.search_rec(s, literals, pos + 1)\n\n        return self.search_rec(s, literals, pos)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.search(\"abcabc\", \"abc\"))\n    print(s.search(\"abc\", \"abc\"))\n    print(s.search(\"abcabc\", \"abcabc\"))",
      1.130859375
    ],
    [
      "# Definition for a literal string.\n# class LiteralString:\n#     def __init__(self, s):\n#         self.s = s\n#         self.len = len(s)\n#         self.indices = [0] * (self.len + 1)\n\nclass Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: int\n        :rtype: bool\n        \"\"\"\n        if not s or p < 0:\n            return False\n        if p == len(s):\n            return True\n        # for (i, j) in self.indices:\n        #     if s[i:j] == s[p:p+self.len]:\n        #         return True\n        #     if p == j:\n        #         return False\n        # return False\n        if s[p:p+self.len] == s[:self.len]:\n            return True\n        else:\n            return False",
      1.064453125
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def search(self, s, literals):\n        \"\"\"\n        :type s: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        def search_literals(s, literals):\n            for l in literals:\n                if l in s:\n                    return s.index(l)\n            return -1\n\n        return search_literals(s, literals)\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        s = Solution()\n        self.assertEqual(s.search('abcabcdef', ['abc', 'def']), 0)\n        self.assertEqual(s.search('abcabcdef', ['abc', 'abc']), 0)\n        self.assertEqual(s.search('abcabcdef', ['def', 'abc']), 1)\n        self.assertEqual(s.search('abcabcdef', ['abc', 'def', 'abc']), 0)\n        self.assertEqual(s.search('abcabcdef', ['abc', 'def', 'def']), 1)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      0.8017578125
    ],
    [
      "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: int\n        \"\"\"\n        return text.find(query)\n\ns = Solution()\nprint s.search('abcabcabc', 'abc')\nprint s.search('abcabcabc', 'abcabc')\nprint s.search('abcabcabc', 'ab')\nprint s.search('abcabcabc', 'abcabcabcabc')\nprint s.search('abcabcabc', 'abcabcabcabcabc')\nprint s.search('abcabcabc', 'abcabcabcabcabcabc')\nprint s.search('abcabcabc', 'abcabcabcabcabcabcabc')\nprint s.search('abcabcabc', 'abcabcabcabcabcabcabcabc')\nprint s.search('abcabcabc', 'abcabcabcabcabcabcabcabcabc')",
      0.5283203125
    ],
    [
      "class Solution(object):\n    def search(self, text, words):\n        \"\"\"\n        :type text: str\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        return any(word in text for word in words)\n\n\nif __name__ == \"__main__\":\n    assert Solution().search(\"Hello, world!\", [\"Hello\", \"world\"])",
      0.240478515625
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return False\n\n        return p.lower() in s.lower()",
      0.1416015625
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(s)):\n            if s[i] == p:\n                return True\n            if i > 0 and s[i-1] == p:\n                return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.search('aabb', 'b')\n    print s.search('aabb', 'a')\n    print s.search('aabb', 'aabb')\n    print s.search('aabb', 'aabbbb')\n    print s.search('aabb', 'aabbbbbb')\n    print s.search('aabb', 'aabbbbbbbb')\n    print s.search('aabb', 'aabbbbbbbbbb')",
      0.03448486328125
    ],
    [
      "def search_string(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: str\n    :rtype: int\n    \"\"\"\n    if not s or not literals:\n        return -1\n\n    if s[0]!= literals[0]:\n        return -1\n\n    for i in range(1, len(s)):\n        if s[i]!= literals[i]:\n            return i\n\n    return len(s)",
      -0.165771484375
    ],
    [
      "class Solution:\n    # @param s, a string\n    # @param literals, a list of string\n    # @return a boolean\n    def search(self, s, literals):\n        # Write your code here\n        return False\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = 'hello'\n    print(sol.search(s, ['a','o','lo']))",
      -0.451416015625
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        m = len(p)\n        if n < m:\n            return -1\n        dp = [[0] * (m + 1) for _ in xrange(n + 1)]\n        for i in xrange(n):\n            dp[i][0] = i\n        for j in xrange(m):\n            dp[0][j] = j\n        for i in xrange(1, n + 1):\n            for j in xrange(1, m + 1):\n                if p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j])\n        return dp[-1][-1]",
      -0.62646484375
    ],
    [
      "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: bool\n        \"\"\"\n        if not text or not target:\n            return False\n        if len(text) < len(target):\n            return False\n        left, right = 0, len(text) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if target[:mid] == text[:mid]:\n                if target[mid] == text[mid]:\n                    if target[mid + 1] == text[mid + 1]:\n                        if target[mid + 2] == text[mid + 2]:\n                            if target[mid + 3] == text[mid + 3]:\n                                return True\n                        return False\n                    return False\n                if target[mid] < text[mid]:\n                    left = mid + 1\n                elif target[mid] > text[mid]:\n                    right = mid - 1\n                else:\n                    return True\n        return False",
      -0.6865234375
    ],
    [
      "import unittest\n\n# Complete the searchLiterals function below.\ndef searchLiterals(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: List[str]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in literals:\n        if s.find(i)!= -1:\n            result.append(i)\n    return result\n\nclass Tests(unittest.TestCase):\n    def test_searchLiterals(self):\n        self.assertEqual(searchLiterals(\"Hello, World!\", [\"Hello\", \"World\"]), [\"Hello\", \"World\"])\n        self.assertEqual(searchLiterals(\"Hello, World!\", [\"Hello\", \"Hello\", \"World\"]), [])\n        self.assertEqual(searchLiterals(\"Hello, World!\", [\"Hello\", \"World\", \"World\"]), [\"Hello\", \"World\"])\n        self.assertEqual(searchLiterals(\"Hello, World!\", [\"Hello\", \"World\", \"World\", \"World\"]), [\"Hello\", \"World\"])\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -0.7314453125
    ],
    [
      "class Solution(object):\n    def search(self, text, literal):\n        \"\"\"\n        :type text: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        if len(text) == 0 or len(literal) == 0:\n            return False\n        if len(text) < len(literal):\n            return self.search(text, literal[:len(text)])\n        for i in range(len(text) - len(literal) + 1):\n            if text[i:i + len(literal)] == literal:\n                return True\n        return False",
      -0.7490234375
    ],
    [
      "import re\n\ndef search_literals(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    return [m.group() for m in re.finditer(r\"[a-zA-Z]+\", s)]\n\ndef search_literals2(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    return [m.group() for m in re.finditer(r\"([a-zA-Z]+)\", s)]\n\ndef search_literals3(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    return [m.group() for m in re.finditer(r\"([a-zA-Z]+)\", s)]\n\ndef search_literals4(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    return [m.group() for m in re.finditer(r\"([a-zA-Z]+)\", s)]\n\nif __name__ == '__main__':\n    s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    print search_literals(s)\n    print search_literals2(s)\n    print search_literals3(s)\n    print search_literals4(s)",
      -0.796875
    ],
    [
      "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: bool\n        \"\"\"\n        return text.find(query) > -1",
      -0.85693359375
    ],
    [
      "# https://www.hackerrank.com/challenges/string-searching/problem\n# Note: You may not use any built-in string library.\n\n# Complete the searchLiteral function below.\ndef searchLiteral(s, t):\n    # Write your code below\n    return 0\nif __name__ == '__main__':\n    s = input()\n    t = input()\n    print(searchLiteral(s, t))",
      -0.85791015625
    ],
    [
      "def search_literals(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: List[str]\n    :rtype: int\n    \"\"\"\n    if not literals:\n        return -1\n    \n    # convert literals to lowercase and split into list\n    literals = literals.lower().split()\n    \n    # iterate over the string and find literals\n    idx = 0\n    for i in range(len(s)):\n        if i == 0 or s[i-1]!= s[i]:\n            if s[i:i+len(literals[idx])] == literals[idx]:\n                idx += 1\n            else:\n                idx = 0\n        if idx == len(literals):\n            return i",
      -0.85791015625
    ],
    [
      "def search(target, literals):\n    for literal in literals:\n        if literal in target:\n            return literal\n\n# Your function should return the first result found.\ndef search_string(target, literals):\n    for literal in literals:\n        if literal in target:\n            return literal\n    return None",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        # naive solution\n        def search(text, target, i):\n            if i >= len(text):\n                return -1\n            if text[i] == target:\n                return i\n            else:\n                if target < text[i]:\n                    return search(text, target, i + 1)\n                else:\n                    return search(text, target, i - 1)\n        return search(text, target, 0)",
      -0.85791015625
    ],
    [
      "def search_literal(literal, str):\n    \"\"\"\n    :type literal: str\n    :type str: str\n    :rtype: int\n    \"\"\"\n    return str.find(literal)\n\n# Your SearchLiteral solution here.",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: int\n        \"\"\"\n        if len(query) == 0:\n            return 0\n        if len(text) < len(query):\n            return -1\n        text = text.lower()\n        query = query.lower()\n        i, j = 0, 0\n        while i < len(text) and j < len(query):\n            if text[i] == query[j]:\n                i += 1\n                j += 1\n            elif text[i] < query[j]:\n                i += 1\n            else:\n                j += 1\n        return i",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def isLiteral(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 1 or s[0] == '\"':\n            return False\n        if s[-1]!= '\"' and s[0]!= '\"':\n            return False\n        return True",
      -0.8583984375
    ],
    [
      "# TODO:\n# - check for multiple strings\n# - check for case sensitive\n# - check for special characters\n\nclass Solution(object):\n    def search(self, str, q):\n        \"\"\"\n        :type str: str\n        :type q: str\n        :rtype: bool\n        \"\"\"\n        if len(str) == 0:\n            return False\n\n        if len(q) == 0:\n            return True\n\n        if q == str[0]:\n            return True\n\n        if q == str[-1]:\n            return True\n\n        for i in range(1, len(str) - len(q) + 1):\n            if q in str[i:i+len(q)]:\n                return True\n\n        return False",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: int\n        \"\"\"\n        return -1\n\nif __name__ == \"__main__\":\n    assert Solution().search(\"hello\", \"world\") == -1\n    assert Solution().search(\"hello\", \"hello\") == 0\n    assert Solution().search(\"hello\", \"goodbye\") == -1\n    assert Solution().search(\"hello\", \"hello world\") == 0\n    assert Solution().search(\"hello\", \"hello world!\") == -1\n    assert Solution().search(\"hello\", \"hello world\") == 0\n    assert Solution().search(\"hello\", \"hello world\") == 0",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def search(self, literals, target):\n        \"\"\"\n        :type literals: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        return self.binary_search(literals, target)\n\n    def binary_search(self, literals, target):\n        left = 0\n        right = len(literals) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if literals[mid] == target:\n                return mid\n            elif literals[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
      -0.8583984375
    ],
    [
      "def search_literals(literal, string):\n    \"\"\"\n    :type literal: str\n    :type string: str\n    :rtype: bool\n    \"\"\"\n    return all(c in literal for c in string)\n\nprint(search_literals('a', 'aaabbbccc'))",
      -0.8583984375
    ],
    [
      "import re\n\ndef search_literals_in_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: int\n    \"\"\"\n    result = 0\n    for literal in literals:\n        result += len(re.findall(literal, string))\n    return result\n\nif __name__ == '__main__':\n    s = 'Hello, world!'\n    literals = 'Hello'\n    print(search_literals_in_string(s, literals))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        if not literals:\n            return 0\n\n        start = 0\n        end = len(text) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if text[mid] in literals:\n                start = mid + 1\n            else:\n                end = mid - 1\n        if text[start - 1] in literals:\n            return start\n        return -1",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def search(self, literals, text):\n        \"\"\"\n        :type literals: List[str]\n        :type text: str\n        :rtype: int\n        \"\"\"\n        if not literals or not text:\n            return -1\n\n        for index, literal in enumerate(literals):\n            if literal in text:\n                return index\n\n        return -1",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        p = p.lower()\n        s = s.lower()\n        if p not in s:\n            return False\n        if p == s[0]:\n            return True\n        if p == s[-1]:\n            return True\n        return self.search(s[1:], p)",
      -0.8583984375
    ],
    [
      "__author__ = 'vistasek'\n\nclass Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(s)\n        while start < end:\n            mid = (start + end) / 2\n            if p == s[mid]:\n                return mid\n            elif p < s[mid]:\n                end = mid\n            else:\n                start = mid + 1\n        return -1",
      -0.8583984375
    ],
    [
      "def search(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    if len(s) == 0:\n        return False\n    for i in range(len(s)):\n        if s[i] not in literals:\n            return False\n    return True\n\ns = 'abcdefghijklmnopqrstuvwxyz'\nliterals = 'bcde'\n\nprint(search(s, literals))",
      -0.8583984375
    ],
    [
      "import re\n\n\ndef search(literal, string):\n    \"\"\"\n    :type literal: str\n    :type string: str\n    :rtype: int\n    \"\"\"\n    # print(string)\n    # print(literal)\n    pos = string.find(literal)\n    # print(pos)\n    if pos == -1:\n        return -1\n    # print(pos)\n    return pos\n\n\nif __name__ == '__main__':\n    # string = '123456789'\n    string = 'abcd'\n    literal = 'a'\n    # print(search(literal, string))\n    print(search(literal, string))",
      -0.85888671875
    ],
    [
      "def search_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    for literal in literals:\n        if literal in string:\n            return True\n    return False\n\nif __name__ == '__main__':\n    assert search_string(\"abc\", \"abc\")\n    assert search_string(\"abc\", \"a\")\n    assert not search_string(\"abc\", \"aac\")\n    assert not search_string(\"abc\", \"\")\n    assert not search_string(\"abc\", \"ac\")\n    assert search_string(\"abc\", \"bc\")",
      -0.85888671875
    ],
    [
      "def search_literals(literal, text):\n    \"\"\"\n    :type literal: str\n    :type text: str\n    :rtype: int\n    \"\"\"\n    if len(text) == 0:\n        return 0\n    i = 0\n    while i < len(text):\n        if text[i] == literal:\n            return i\n        i += 1\n    return -1\n\nif __name__ == '__main__':\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    t = 'abcd'\n    print(search_literals('abcd', s))\n    print(search_literals('abcd', t))",
      -0.85888671875
    ],
    [
      "def search(s, literals):\n    # write your code here\n    if not s or not literals:\n        return 0\n    if not s or not literals:\n        return 0\n    if s.find(literals)!= -1:\n        return 1\n    return 0\n\nif __name__ == '__main__':\n    s = 'Hello, World!'\n    literals = 'Hello'\n    print search(s, literals)",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @return a boolean\n    def search(self, S, P):\n        if len(S) == 0:\n            return False\n        if len(P) == 0:\n            return True\n        if len(P) == 1:\n            return S[0] == P[0]\n        if len(P) == 2:\n            return S[0] == P[0] and S[1] == P[1]\n        if len(P) == 3:\n            return S[0] == P[0] and S[1] == P[1] and S[2] == P[2]\n        return False\n\n# test\nS = \"aabcccddd\"\nP = \"aabb\"\nsol = Solution()\nprint(sol.search(S, P))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: int\n        \"\"\"\n        p = p.upper()\n        n = len(s)\n        if n < p:\n            return -1\n        if p == s[n - p]:\n            return n - p\n        l, r = 0, n - 1\n        while l <= r:\n            m = (l + r) / 2\n            if p == s[m: m + p]:\n                return m\n            elif p < s[m: m + p]:\n                r = m - 1\n            else:\n                l = m + 1\n        return -1\n\n\nif __name__ == '__main__':\n    print Solution().search('abcd', 'b')",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {string} s\n    # @param {string} k\n    # @return {boolean}\n    def search(self, s, k):\n        left, right = 0, len(s) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if s[mid] == k:\n                return True\n            elif s[mid] < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False",
      -0.85888671875
    ],
    [
      "__author__ = 'Danyang'\nclass Solution(object):\n    def search(self, S, p):\n        \"\"\"\n        :param S: str\n        :param p: str\n        :return: bool\n        \"\"\"\n        p = p.lower()\n        if p in S:\n            return True\n        else:\n            return False\n\n\nif __name__==\"__main__\":\n    print Solution().search(\"hello world\", \"world\")",
      -0.85888671875
    ],
    [
      "# Definition for a literal string.\nclass Literal:\n    def __init__(self, s):\n        self.s = s\n        self.len = len(s)\n\n    def __eq__(self, other):\n        return self.s == other.s\n\nclass Solution:\n    def findLiteral(self, s: str, literals: List[Literal]) -> Optional[Literal]:\n        for literal in literals:\n            if s.startswith(literal.s):\n                return literal\n        return None\n\ns = Solution()\ns.findLiteral(\"abc\", [Literal(\"a\"), Literal(\"b\"), Literal(\"c\")])",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: int\n        \"\"\"\n        if not text or not query:\n            return -1\n        i = 0\n        while i < len(text):\n            if text[i] == query[0]:\n                if query == text[i:i+len(query)]:\n                    return i\n                i += len(query) + 1\n            i += 1\n        return -1",
      -0.86083984375
    ],
    [
      "from collections import defaultdict\n\ndef find_literals(string):\n    \"\"\"\n    Write a function to search some literals strings in a string.\n\n    Example\n    Given string = \"abcdef\", return [\"abc\", \"def\"], or return [] if string doesn't contain any literals.\n\n    Challenge\n    Write a function to search some literals strings in a string.\n\n    Challenge\n    Write a function to search some literals strings in a string.\n    \"\"\"\n    return []\n\nif __name__ == '__main__':\n    string = \"abcdef\"\n    print(find_literals(string))",
      -0.86083984375
    ],
    [
      "def search(literal, str):\n    \"\"\"\n    :type literal: str\n    :type str: str\n    :rtype: bool\n    \"\"\"\n    return str.find(literal)!= -1\n\n\nif __name__ == '__main__':\n    assert search('abcd', 'aabcdd')\n    assert search('aabcd', 'abcdd')\n    assert search('aabcdd', 'abcdd')\n    assert search('abcdd', 'aabcdd')\n    assert not search('aabcd', 'abcdd')\n    assert not search('abcdd', 'aabcdd')\n    assert not search('aabcdd', 'abcdd')\n    assert not search('abcdd', 'aabcdd')\n    assert search('abcd', 'aabcdd')\n    assert search('aabcd', 'abcdd')\n    assert search('abcdd', 'aabcdd')\n    assert not search('aabcdd', 'abcdd')",
      -0.9072265625
    ],
    [
      "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: str\n        :rtype: int\n        \"\"\"\n        if not text or not literals:\n            return -1\n        text = text.lower()\n        literals = literals.lower()\n        for i, c in enumerate(text):\n            if c not in literals:\n                continue\n            if literals.find(c) < i:\n                return -1\n            if literals.find(c) == i:\n                return i\n        return -1",
      -1.0888671875
    ],
    [
      "class Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        if not p:\n            return True\n        s = s.lower()\n        p = p.lower()\n        for i in range(len(s)):\n            if s[i] == p[0]:\n                if len(p) == 1:\n                    return True\n                return self.search(s, p[1:])\n        return False",
      -1.1044921875
    ],
    [
      "class Solution:\n    # @param haystack, a string\n    # @param needle, a string\n    # @return an integer\n    def strStr(self, haystack, needle):\n        haystack = haystack.upper()\n        needle = needle.upper()\n        length = len(needle)\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+length] == needle:\n                return i\n        return -1",
      -1.2060546875
    ],
    [
      "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: int\n        \"\"\"\n        for i in range(len(text)):\n            if query in text[i:]:\n                return i\n        return -1\n\na = Solution()\nprint(a.search('abcabcabc', 'abc'))\nprint(a.search('abcabcabc', 'cbc'))\nprint(a.search('abcabcabc', 'bac'))\nprint(a.search('abcabcabc', 'cab'))\nprint(a.search('abcabcabc', 'abcab'))\nprint(a.search('abcabcabc', 'abc'))",
      -1.2705078125
    ],
    [
      "import re\n\nclass Solution:\n    def search(self, literals: 'List[str]', s:'str') -> 'List[int]':\n        ans = []\n        for i in range(len(s)):\n            for j in literals:\n                if j == s[i]:\n                    ans.append(i)\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search(['a', 'b', 'a', 'c', 'a'], 'abc'))\n    print(sol.search(['a', 'a', 'a'], 'a'))\n    print(sol.search(['a', 'b', 'c', 'a', 'b'], 'abc'))\n    print(sol.search(['a', 'b', 'a', 'b'], 'abc'))\n    print(sol.search(['a', 'b', 'a', 'b'], 'ab'))\n    print(sol.search(['a', 'a', 'a'], 'a'))\n    print(sol.search(['a', 'a', 'a'], 'aa'))\n    print(sol.search(['a', 'b', 'a', 'b'], 'abc'))",
      -1.3427734375
    ],
    [
      "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def searchLiterals(self, literals: List[str], target: str) -> bool:\n        # type: (List[str], str) -> bool\n        if not literals:\n            return False\n\n        literals_len = len(literals)\n        target_len = len(target)\n\n        # initialize a hash table to store the last index of each character\n        # store the last index of each character and the last index of the target\n        last_index = defaultdict(int)\n        last_index[target[0]] = 0\n        for i in range(1, target_len):\n            last_index[target[i]] = last_index[target[i-1]]\n\n        # loop to search the literals\n        for i in range(literals_len):\n            # if the current character is not the target, continue to the next character\n            if target[i]!= literals[i]:\n                continue\n\n            # if the last index of the current character is not the last index of the target, continue to the next character\n            if last_index[target[i]]!= i:\n                continue\n\n            # found the target, return true\n            return True\n\n        # not found, return false\n        return False",
      -1.5087890625
    ],
    [
      "class Solution(object):\n    def isLiteral(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if s[0] == '\\\\':\n            return self.isLiteral(s[1:])\n        if s[0] == '\"':\n            return False\n        if s[0] == '\\'':\n            return True\n        return self.isLiteral(s[1:]) or self.isLiteral(s[:-1])\n\n    def isLiteralString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if s[0] == '\\\\':\n            return self.isLiteralString(s[1:])\n        if s[0] == '\"':\n            return True\n        if s[0] == '\\'':\n            return False\n        return self.isLiteralString(s[1:]) or self.isLiteralString(s[:-1])\n\n    def isLiteralString2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if s[0] == '\\\\':\n            return self.isLiteralString2(s[1:])\n        if s[0] == '\"':\n            return True\n        if s[0] == '\\'':\n            return False\n        return self.isLiteralString2(s[1:]) or self.isLiteralString2(s[:-1])\n\n    def isLiteralString3(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return True\n        if s[0] == '\\\\':\n            return self.isLiteralString3(s[1:])\n        if s[0] == '\"':\n            return True\n        if s[0] == '\\",
      -1.6748046875
    ],
    [
      "class Solution:\n    # @param {string} s\n    # @param {string[]} literals\n    # @return {integer}\n    def search(self, s, literals):\n        if len(literals) == 0:\n            return 0\n        i = 0\n        while i < len(s):\n            if s[i:i+len(literals[0])] == literals[0]:\n                j = i + len(literals[0])\n                while j < len(s):\n                    if s[j:j+len(literals[1])] == literals[1]:\n                        return j\n                    j += 1\n            i += 1\n        return -1",
      -1.771484375
    ],
    [
      "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: str\n        :rtype: int\n        \"\"\"\n        return self.search_recursive(text, literals)\n\n    def search_recursive(self, text, literals):\n        if len(text) == 0:\n            return -1\n\n        if len(literals) == 0:\n            return text.find(literals)\n\n        if text[0] == literals[0]:\n            return self.search_recursive(text[1:], literals[1:])\n        else:\n            return self.search_recursive(text, literals[1:])\n\n\ndef main():\n    solution = Solution()\n    assert solution.search('abcdefg', 'abc') == 0\n    assert solution.search('abcdefg', 'bc') == 1\n    assert solution.search('abcdefg', 'def') == 2\n    assert solution.search('abcdefg', 'abcdef') == -1\n    assert solution.search('abcdefg', 'abcdefg') == -1\n\n\nif __name__ == '__main__':\n    main()",
      -1.8935546875
    ],
    [
      "class Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: int\n        \"\"\"\n        # Time: O(m*n)\n        # Space: O(m)\n        # DP\n        n, m = len(S), len(P)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(n):\n            dp[0][i+1] = i\n        for i in range(m):\n            dp[i+1][0] = m\n        for i in range(n):\n            for j in range(m):\n                if P[j] == S[i]:\n                    dp[j+1][i+1] = dp[j][i]\n                else:\n                    dp[j+1][i+1] = min(dp[j+1][i], dp[j][i+1])\n        return dp[m][n]\n\n    # Time: O(m*n)\n    # Space: O(m)\n    # DP\n    def search2(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: int\n        \"\"\"\n        n = len(S)\n        m = len(P)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(n):\n            dp[0][i+1] = i\n        for i in range(m):\n            dp[i+1][0] = m\n        for i in range(n):\n            for j in range(m):\n                if P[j] == S[i]:\n                    dp[j+1][i+1] = dp[j][i]\n                else:\n                    dp[j+1][i+1] = min(dp[j+1][i], dp[j][i+1])\n        return dp[m][n]\n\n\nif __name__ == '__main__':\n    assert Solution().search('abc', 'b') == 1\n    assert Solution().",
      -2.029296875
    ],
    [
      "import sys\nfrom collections import Counter\n\n# @include\ndef search_literals(literal_string, text):\n    counter = Counter(text)\n    for c in literal_string:\n        if c in counter:\n            counter[c] -= 1\n    return any(counter[c] > 0 for c in literal_string)\n# @exclude\n\n\ndef main():\n    text = sys.stdin.read().strip()\n    literal_string = sys.stdin.read().strip()\n    print(search_literals(literal_string, text))\n\n\nif __name__ == '__main__':\n    main()",
      -2.302734375
    ],
    [
      "def search_literals(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: list[str]\n    :rtype: bool\n    \"\"\"\n    # write your code here\n    return True\n\nif __name__ == '__main__':\n    print(search_literals('Hello, my name is John.', ['Hello','my', 'name', 'is', 'John']))\n    print(search_literals('Hello, my name is John.', ['Hello','my', 'name', 'is', 'John', 'John', 'John']))\n    print(search_literals('Hello, my name is John.', ['Hello','my', 'name', 'is', 'John', 'John', 'John', 'John', 'John']))",
      -2.353515625
    ],
    [
      "def search_literal(str, literals):\n    \"\"\"\n    :type str: str\n    :type literals: list[str]\n    :rtype: bool\n    \"\"\"\n    if not str:\n        return False\n    for literal in literals:\n        if literal in str:\n            return True\n    return False\n\n\nclass Solution(object):\n    def search(self, str, literals):\n        \"\"\"\n        :type str: str\n        :type literals: list[str]\n        :rtype: bool\n        \"\"\"\n        if not str:\n            return False\n        for literal in literals:\n            if literal in str:\n                return True\n        return False",
      -2.48046875
    ],
    [
      "class Solution:\n    # @param {string} str\n    # @param {string} searchStr\n    # @return {integer}\n    def search(self, str, searchStr):\n        n = len(str)\n        m = len(searchStr)\n        if m == 0:\n            return 0\n        if n == 0:\n            return -1\n        if m > n:\n            return -1\n        start = 0\n        end = n - m + 1\n        while start <= end:\n            mid = start + (end - start) / 2\n            if searchStr == str[mid:mid + m]:\n                return mid\n            elif searchStr > str[mid:mid + m]:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.search(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"HIJKLM\"))",
      -2.603515625
    ],
    [
      "class Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: bool\n        \"\"\"\n        left = 0\n        right = len(S) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if S[mid] == P[0]:\n                if mid == 0:\n                    return True\n                if P[0] == P[1]:\n                    return self.search(S, P[1:])\n                elif P[0] < P[1]:\n                    return self.search(S, P[1:mid + 1])\n                else:\n                    return self.search(S, P[:mid])\n            elif S[mid] < P[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    assert solution.search(\"\", \"\") is False\n    assert solution.search(\"hello\", \"\") is False\n    assert solution.search(\"hello\", \"hello\") is True\n    assert solution.search(\"hello\", \"h\") is True\n    assert solution.search(\"hello\", \"ell\") is False\n    assert solution.search(\"hello\", \"hel\") is False\n    assert solution.search(\"hello\", \"hell\") is False\n    assert solution.search(\"hello\", \"helo\") is False\n    assert solution.search(\"hello\", \"hllo\") is True",
      -2.669921875
    ],
    [
      "import re\nimport os\nfrom collections import Counter\nfrom itertools import combinations\n\ndef count_strings(string, literals):\n    \"\"\"\n    Count the number of strings in the string that match some\n    literals.\n    \"\"\"\n    count = Counter()\n    for literal in literals:\n        count.update(re.findall(literal, string))\n    return count\n\ndef find_strings(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"\n    strings = []\n    for literal in literals:\n        strings.extend(re.findall(literal, string))\n    return strings\n\ndef find_all_strings(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"\n    strings = []\n    for literal in literals:\n        strings.extend(re.findall(literal, string))\n    return strings\n\ndef find_all_strings_with_counts(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"\n    strings = []\n    for literal in literals:\n        strings.extend(re.findall(literal, string))\n    return strings\n\ndef find_all_strings_with_counts_with_counts(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"\n    strings = []\n    for literal in literals:\n        strings.extend(re.findall(literal, string))\n    return strings\n\ndef find_all_strings_with_counts_with_counts_with_counts(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"\n    strings = []\n    for literal in literals:\n        strings.extend(re.findall(literal, string))\n    return strings\n\ndef find_all_strings_with_counts_with_counts_with_counts_with_counts(string, literals):\n    \"\"\"\n    Find all strings in the string that match some literals.\n    \"\"\"",
      -2.716796875
    ],
    [
      "def search(needle, haystack):\n    \"\"\"\n    :type needle: str\n    :type haystack: str\n    :rtype: bool\n    \"\"\"\n    haystack = haystack.lower()\n    for i in range(len(haystack)):\n        if needle in haystack[i:i+len(needle)]:\n            return True\n    return False\n\nif __name__ == '__main__':\n    assert search('abc', 'abc')\n    assert search('abc', 'abcbc')\n    assert search('abc', 'abcabc')\n    assert search('abc', 'aabc')\n    assert search('abc', 'abcabc')\n    assert search('abc', 'abcabcabc')\n    assert search('abc', 'abcabcabcabc')\n    assert search('abc', 'abcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')\n    assert search('abc', 'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
      -2.748046875
    ],
    [
      "import unittest\n\n\nclass Solution:\n    def search(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < len(t):\n            return self.search(t, s)\n\n        for i in range(len(s) - len(t) + 1):\n            if s[i:i + len(t)] == t:\n                return True\n        return False\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-in-rotated-sorted-array/solution/\n\n# DFS\n# 7ms 100%\nclass Solution {\n    public boolean search(String[] words, String word) {\n        int idx = 0;\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word)) return true;\n            if (idx < words.length - 1 && words[i].compareTo(words[i + 1]) < 0) {\n                idx++;\n            }\n        }\n        return false;\n    }\n}\n\n# BFS\n# 4ms 100%\nclass Solution {\n    public boolean search(String[] words, String word) {\n        if (words == null || words.length == 0) return false;\n        int idx = 0;\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word)) return true;\n            if (idx < words.length - 1 && words[i].compareTo(words[i + 1]) < 0) {\n                idx++;\n            }\n        }\n        return false;\n    }\n}\n'''",
      -2.8359375
    ],
    [
      "class Solution(object):\n    def isLiteral(self, s, literals):\n        \"\"\"\n        :type s: str\n        :type literals: str\n        :rtype: bool\n        \"\"\"\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = \"Hello World\"\n# param_2 = [\"Hello\", \"World\"]\n# param_3 = \"Hello\"\n# obj.isLiteral(param_1, param_2)\n# print obj.isLiteral(param_1, param_2)",
      -3.2734375
    ],
    [
      "class Solution:\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def search(self, str, literals):\n        if not str:\n            return False\n        if len(literals) == 0:\n            return False\n        for i in range(len(str)):\n            if str[i:i+len(literals[0])] == literals[0]:\n                if self.search(str[i+len(literals[0]):], literals[1:]):\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search(\"hello\", [\"he\"]))\n    print(sol.search(\"hello\", [\"ll\", \"he\"]))\n    print(sol.search(\"hello\", [\"ll\"]))\n    print(sol.search(\"hello\", [\"ll\", \"ll\", \"ll\"]))\n    print(sol.search(\"hello\", [\"ll\", \"he\"]))\n    print(sol.search(\"hello\", [\"he\"]))",
      -3.515625
    ],
    [
      "#!/usr/bin/python\n\nclass Solution(object):\n    def search(self, S, p):\n        \"\"\"\n        :type S: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        p_len = len(p)\n        i = 0\n        while i < p_len:\n            j = i + 1\n            while j < p_len:\n                if S[i:j] == p:\n                    return True\n                else:\n                    j += 1\n            i += 1\n        return False",
      -3.576171875
    ],
    [
      "class Solution(object):\n    def isLiteral(self, s, literals):\n        \"\"\"\n        :type s: str\n        :type literals: str\n        :rtype: bool\n        \"\"\"\n        for literal in literals:\n            if s.find(literal)!= -1:\n                return True\n        return False\n\n    def isLiteral_rec(self, s, literals):\n        if len(literals) == 0:\n            return True\n        if s == literals[0]:\n            return self.isLiteral_rec(s[1:], literals[1:])\n        else:\n            return self.isLiteral_rec(s[1:], literals)\n\n    def isLiteral_rec(self, s, literals):\n        if len(literals) == 0:\n            return True\n        if s == literals[0]:\n            return self.isLiteral_rec(s[1:], literals[1:])\n        else:\n            return self.isLiteral_rec(s[1:], literals)\n\n    def isLiteral(self, s, literals):\n        return self.isLiteral_rec(s, literals)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    assert sol.isLiteral('abc', 'a') == True\n    assert sol.isLiteral('abc', 'b') == True\n    assert sol.isLiteral('abc', 'abc') == True\n    assert sol.isLiteral('abc', 'abcd') == False\n    assert sol.isLiteral('abc', 'abd') == False\n    assert sol.isLiteral('abc', 'bc') == False\n    assert sol.isLiteral('abc', 'bcd') == False\n    assert sol.isLiteral('abc', 'c') == False\n    assert sol.isLiteral('abc', 'd') == False\n    assert sol.isLiteral('abc', 'ab') == False\n    assert sol.isLiteral('abc', 'abb') == False\n    assert sol.isLiteral('abc', 'abcabc",
      -3.587890625
    ],
    [
      "__author__ = 'Libao Jin'\n__date__ = 'December 12, 2015'\n\nclass Solution(object):\n    def search(self, literals, text):\n        \"\"\"\n        :type literals: str\n        :type text: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(text)):\n            for j in range(len(text) - i):\n                if text[i:j + i] == literals:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search(\"abcd\", \"abcdefg\")\n    print s.search(\"abcd\", \"abc\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abcd\", \"abc\")\n    print s.search(\"abc\", \"abc\")\n    print s.search(\"abcd\", \"abcd\")\n    print s.search(\"abcd\", \"abc\")\n    print s.search(\"abc\", \"abc\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abcd\")\n    print s.search(\"abc\", \"abc\")\n    print s.search(\"abc\", \"abc\")",
      -3.6875
    ],
    [
      "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        return self.binarySearch(text, 0, len(text) - 1, literals)\n\n    def binarySearch(self, text, start, end, literals):\n        while start < end:\n            mid = start + (end - start) // 2\n            if text[mid] in literals:\n                if mid == start:\n                    return mid\n                elif text[mid] < text[start]:\n                    end = mid\n                else:\n                    start = mid + 1\n            elif mid == start:\n                return -1\n            elif mid < start:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1",
      -3.794921875
    ],
    [
      "# Definition for a literal string.\nclass Literal:\n    def __init__(self, s):\n        self.s = s\n\n    def __str__(self):\n        return self.s\n\n    def __repr__(self):\n        return self.s\n\nclass Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: Literal\n        :rtype: bool\n        \"\"\"\n        l = len(s)\n        for i in range(l):\n            if s[i] == p.s[0]:\n                if s[i:i+p.s[1]] == p.s:\n                    return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.search('', Literal('a')) == False\n    assert s.search('', Literal('a')) == False\n    assert s.search('a', Literal('a')) == True\n    assert s.search('aaa', Literal('a')) == True\n    assert s.search('aa', Literal('a')) == False\n    assert s.search('aa', Literal('a')) == False\n    assert s.search('aaa', Literal('aa')) == True\n    assert s.search('aaa', Literal('a')) == False\n    assert s.search('a', Literal('a')) == True\n    assert s.search('a', Literal('a')) == True\n    assert s.search('aaaa', Literal('a')) == True\n    assert s.search('aaaa', Literal('a')) == True\n    assert s.search('aaaa', Literal('aa')) == True\n    assert s.search('aaaa', Literal('a')) == False\n    assert s.search('aaaa', Literal('aa')) == True\n    assert s.search('aaaa', Literal('a')) == False\n    assert s.search('a', Literal('a')) == True\n    assert s.search('a', Literal('a')) == True\n    assert s.search('aaaa', Literal('aaa')) == True\n    assert s.search",
      -3.833984375
    ],
    [
      "__author__ = 'Danyang'\n\nclass Solution(object):\n    def search(self, S, L):\n        \"\"\"\n        :type S: str\n        :type L: str\n        :rtype: bool\n        \"\"\"\n        return -1 not in S and L in S\n\n\nif __name__==\"__main__\":\n    s=Solution()\n    print s.search(\"abcd\", \"bcd\")\n    print s.search(\"abcd\", \"abc\")\n    print s.search(\"abcd\", \"c\")\n    print s.search(\"abcd\", \"d\")\n    print s.search(\"abcd\", \"e\")\n    print s.search(\"abcd\", \"f\")\n    print s.search(\"abcd\", \"g\")\n    print s.search(\"abcd\", \"h\")\n    print s.search(\"abcd\", \"j\")\n    print s.search(\"abcd\", \"k\")\n    print s.search(\"abcd\", \"l\")\n    print s.search(\"abcd\", \"m\")\n    print s.search(\"abcd\", \"n\")\n    print s.search(\"abcd\", \"o\")\n    print s.search(\"abcd\", \"p\")\n    print s.search(\"abcd\", \"q\")\n    print s.search(\"abcd\", \"r\")\n    print s.search(\"abcd\", \"s\")\n    print s.search(\"abcd\", \"t\")\n    print s.search(\"abcd\", \"u\")\n    print s.search(\"abcd\", \"v\")\n    print s.search(\"abcd\", \"w\")\n    print s.search(\"abcd\", \"x\")\n    print s.search(\"abcd\", \"y\")\n    print s.search(\"abcd\", \"z\")\n\n    print s.search(\"abcd\", \"a\")\n    print s.search(\"abcd\", \"b\")\n    print s.search(\"abcd\", \"c\")\n    print s.search(\"abcd\", \"d\")\n    print s.search(\"abcd\", \"e\")\n    print s.search(\"abcd\", \"f\")\n    print s.search(\"abcd\", \"g\")\n    print s.search(\"abcd\",",
      -3.986328125
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :param S: str\n        :param P: str\n        :return: bool\n        \"\"\"\n        def check(i, j):\n            if i > 0 and S[i-1] == P[j-1]:\n                return check(i-1, j-1)\n            elif i == 0:\n                return j == 0 or P[j-1]!= S[i-1]\n            elif j == 0 or P[j-1]!= S[i-1]:\n                return False\n            else:\n                return check(i-1, j-1)\n\n        return check(len(S)-1, len(P)-1)\n\n\nif __name__ == \"__main__\":\n    print(Solution().search(\"banana\", \"anana\"))",
      -4.265625
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        return any(text.find(l) >= 0 for l in literals)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-a-2d-matrix/solution/\n\n# 12ms 98.47%\nclass Solution {\n    public boolean search(String text, String[] literals) {\n        if (text == null || literals == null || text.length() == 0 || literals.length == 0) return false;\n        return search(text, 0, text.length() - 1, literals, 0, literals.length - 1);\n    }\n\n    private boolean search(String text, int left, int right, String[] literals, int literalsLeft, int literalsRight) {\n        if (left > right || text.length() < literalsLeft || text.length() < literalsRight) return false;\n        if (left == right) return text.charAt(left) == literals[literalsLeft] || text.charAt(left) == literals[literalsRight];\n        if (text.charAt(left) == literals[literalsLeft] || text.charAt(right) == literals[literalsRight]) return true;\n        return search(text, left + 1, right - 1, literals, literalsLeft, literalsRight) ||\n               search(text, left, right - 1, literals, literalsLeft, literalsRight);\n    }\n}\n'''",
      -4.33203125
    ],
    [
      "from string import ascii_lowercase\n\n\ndef search(target, literals):\n    \"\"\"\n    :type target: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    for s in literals:\n        if target.find(s) >= 0:\n            return True\n    return False\n\n\nif __name__ == '__main__':\n    assert search('Hello', 'Hello')\n    assert search('Hello', 'He')\n    assert search('Hello', 'll')\n    assert search('Hello', 'll')\n    assert search('Hello', 'llll')\n    assert search('Hello', 'llllll')\n    assert search('Hello', 'llllllll')\n    assert search('Hello', 'llllllllll')\n    assert search('Hello', 'llllllllllll')\n    assert search('Hello', 'llllllllllllllll')\n    assert search('Hello', 'llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll",
      -4.6171875
    ],
    [
      "class Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: int\n        \"\"\"\n        if not P or not S:\n            return -1\n        S_len = len(S)\n        P_len = len(P)\n        if P_len == 0:\n            return 0\n        if P_len == 1:\n            if S_len == 0:\n                return -1\n            if S[0]!= P[0]:\n                return -1\n            return 0\n        if P_len > S_len:\n            return -1\n        if P_len == S_len:\n            if S[0]!= P[0]:\n                return -1\n            return 0\n        if P_len > 1:\n            if S[0]!= P[0]:\n                return -1\n            if S[1]!= P[1]:\n                return -1\n            return 0\n        if P[0] == S[0]:\n            return 0\n        if P[0] == S[1]:\n            return 1\n        return -1\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.search(\"abcd\", \"bcd\")\n    print sol.search(\"abcd\", \"ab\")\n    print sol.search(\"abcd\", \"z\")\n    print sol.search(\"abcd\", \"b\")\n    print sol.search(\"abcd\", \"abc\")\n    print sol.search(\"abcd\", \"abcde\")\n    print sol.search(\"abcd\", \"abcd\")\n    print sol.search(\"abcd\", \"abc\")\n    print sol.search(\"abcd\", \"abcdef\")\n    print sol.search(\"abcd\", \"abcdefg\")\n    print sol.search(\"abcd\", \"abcdefgh\")\n    print sol.search(\"abcd\", \"abcdefghi\")\n    print sol.search(\"abcd\", \"abcdefghij\")",
      -5.00390625
    ],
    [
      "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        if not text or not target:\n            return -1\n\n        text = text.lower()\n        target = target.lower()\n        for i in range(len(text)):\n            if text[i] == target[0]:\n                if target == text[i:]:\n                    return i\n                elif i == 0:\n                    return -1\n                else:\n                    return self.search(text[i+1:], target)\n        return -1",
      -5.015625
    ],
    [
      "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        # base case\n        if not text:\n            return -1\n        # start from the end\n        start = len(text) - 1\n        end = 0\n        while start >= 0 and end < len(text):\n            # find the first character\n            # note: for a string with length n,\n            #       the first character is n - 1\n            #       the last character is n - 1\n            #       the length of the first character is 1\n            #       the length of the last character is 1\n            #       the length of the middle character is 2\n            #       the length of the middle character is 2\n            #       the length of the middle character is 3\n            #       the length of the middle character is 3\n            #       the length of the middle character is 4\n            #       the length of the middle character is 4\n            #       the length of the middle character is 5\n            #       the length of the middle character is 5\n            #       the length of the middle character is 6\n            #       the length of the middle character is 6\n            #       the length of the middle character is 7\n            #       the length of the middle character is 7\n            #       the length of the middle character is 8\n            #       the length of the middle character is 8\n            #       the length of the middle character is 9\n            #       the length of the middle character is 9\n            #       the length of the middle character is 10\n            #       the length of the middle character is 10\n            #       the length of the middle character is 11\n            #       the length of the middle character is 11\n            #       the length of the middle character is 12\n            #       the length of the middle character is 12\n            #       the length of the middle character is 13\n            #       the length of the middle character is 13\n            #       the length of the middle character is 14\n            #       the length of the middle character is 14\n            #       the length of the middle character is 15\n            #       the length of the middle character is 15\n            #       the length of the middle character is 16\n            #",
      -5.5234375
    ],
    [
      "class Solution(object):\n    def search(self, literals, target):\n        \"\"\"\n        :type literals: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        if not literals:\n            return -1\n        for i, c in enumerate(literals):\n            if target == c:\n                return i\n        for i, c in enumerate(literals):\n            if c in target:\n                return i\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search(\"\", \"\"))\n    print(sol.search(\"hello\", \"ll\"))\n    print(sol.search(\"hello\", \"h\"))\n    print(sol.search(\"hello\", \"ll\"))\n    print(sol.search(\"hello\", \"ell\"))",
      -5.71484375
    ],
    [
      "def search(literal, string):\n    # write your code here\n    # print(string)\n    if string == '':\n        return False\n    if len(string) == 0:\n        return False\n    if string[0] == '#':\n        return False\n    if literal == '':\n        return True\n    if literal[0] == '#':\n        return False\n    if len(literal) == 0:\n        return False\n    if literal[0] == string[0]:\n        return True\n    if literal[0] < string[0]:\n        return False\n    if literal[0] > string[0]:\n        return True\n    return search(literal[1:], string[1:])\n\nif __name__ == '__main__':\n    string = '#aabbcc#'\n    literal = 'abb'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = '#aabbcc#'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = '#aabbcc#'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = 'abbcc'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = 'abbcc#'\n    print(search(literal, string))\n    string = 'aabbcc#'\n    literal = 'abbcc#'\n    print(search(literal, string))\n    string = 'aabbcc#'\n    literal = 'abbcc#'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = 'abbcc'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = 'abbcc#'\n    print(search(literal, string))\n    string = 'aabbcc#'\n    literal = 'abbcc#'\n    print(search(literal, string))\n    string = 'aabbcc'\n    literal = 'abbcc#'\n    print(search(literal",
      -5.92578125
    ],
    [
      "class Solution(object):\n    def search(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: str\n        :rtype: bool\n        \"\"\"\n        start = 0\n        end = len(s)\n        while start < end:\n            mid = (start + end) / 2\n            if s[mid] == k:\n                return True\n            if s[mid] < k:\n                start = mid + 1\n            else:\n                end = mid\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.search(\"hello\", \"ll\"))",
      -5.9453125
    ],
    [
      "from collections import defaultdict\nfrom string import printable\n\n# @include\ndef search_literals_in_string(s, literals):\n    # Build a mapping from each character to its index in literals.\n    mapping = defaultdict(int)\n    for char, index in zip(literals, range(len(literals))):\n        mapping[char] = index\n    # Find the first index in literals which is not in s.\n    return next((index for index, char in enumerate(s) if char not in literals), -1)\n# @exclude\n\n\ndef main():\n    s = \"Hello world!\"\n    literals = 'he' + printable[:7] + 'o' + printable[:6] + 'r' + printable[:6] +'world!'\n    # The mapping from each character to its index in literals.\n    mapping = defaultdict(int)\n    for char, index in zip(literals, range(len(literals))):\n        mapping[char] = index\n    # Find the first index in literals which is not in s.\n    print(search_literals_in_string(s, literals))\n    print(search_literals_in_string(s, 'heo'))\n    print(search_literals_in_string(s, 'heo' + 'o' + 'world'))\n    print(search_literals_in_string(s, 'he' + 'o' + 'world'))\n    print(search_literals_in_string(s, 'he' + 'o' + 'world' + '!'))\n    print(search_literals_in_string(s, 'he' + 'o' + 'world' + '!' + '!'))\n    print(search_literals_in_string(s, 'he' + 'o' + 'world' + '!' + '!' + '!'))\n    print(search_literals_in_string(s, 'he' + 'o' + 'world' + '!' + '!' + '!' + '!'))\n    print(search_literals_in_string(s, 'he' + 'o'",
      -6.046875
    ],
    [
      "class Solution(object):\n    def search(self, text, queries):\n        \"\"\"\n        :type text: str\n        :type queries: List[str]\n        :rtype: int\n        \"\"\"\n        result = -1\n        for i in xrange(0, len(text)):\n            if text[i] in queries:\n                result = i\n                break\n        return result\n\n\nif __name__ == '__main__':\n    assert Solution().search('abc', 'a') == 0\n    assert Solution().search('abc', 'abc') == 0\n    assert Solution().search('abc', 'bb') == 1\n    assert Solution().search('abc', 'b') == 1\n    assert Solution().search('abc', 'bac') == 2\n    assert Solution().search('abc', 'cba') == -1\n    assert Solution().search('abc', '') == 0\n    assert Solution().search('abc', 'abc') == 0\n    assert Solution().search('', '') == 0",
      -6.4375
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n\n    def search(self, text, keyword):\n        \"\"\"\n        :type text: str\n        :type keyword: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(text) - len(keyword) + 1):\n            if text.find(keyword, i) == i:\n                return True\n        return False\n\n    def search2(self, text, keyword):\n        \"\"\"\n        :type text: str\n        :type keyword: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(text) - len(keyword) + 1):\n            if text[i:i + len(keyword)] == keyword:\n                return True\n        return False\n\n    def search3(self, text, keyword):\n        \"\"\"\n        :type text: str\n        :type keyword: str\n        :rtype: bool\n        \"\"\"\n        return text.find(keyword)!= -1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-a-2d-matrix/solution/\n\n# 12ms 95.68%\nclass Solution {\n    public boolean search(String text, String keyword) {\n        if (text.length() < keyword.length()) return false;\n        int len = text.length();\n        for (int i = 0; i < len; i++) {\n            if (text.charAt(i) == keyword.charAt(i)) {\n                if (i + 1 == len) {\n                    return true;\n                }\n                if (text.charAt(i + 1) == keyword.charAt(i + 1)) {\n                    return true;\n                }\n                if (text.charAt(i + 1) == keyword.charAt(i)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n# 9ms 100%\nclass Solution {",
      -6.47265625
    ],
    [
      "import unittest\n\nclass Solution:\n    def search(self, text: str, literals: List[str]) -> int:\n        res = 0\n        for i in range(len(text)):\n            if text[i] in literals:\n                res += 1\n            elif res > 0:\n                res -= 1\n        return res\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test('abcd', ['a', 'b', 'c', 'd'], 1)\n        self._test('abc', ['a', 'b', 'c', 'd'], 0)\n        self._test('abcabc', ['a', 'b', 'c', 'd'], 2)\n        self._test('abcd', ['a', 'b', 'c', 'd', 'e'], -1)\n        self._test('abc', ['a', 'b', 'c', 'd', 'e'], -1)\n        self._test('', [], -1)\n        self._test('a', [], -1)\n        self._test('', [''], -1)\n        self._test('abc', [''], -1)\n\n    def _test(self, text, literals, expected):\n        actual = Solution().search(text, literals)\n        self.assertEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -6.54296875
    ],
    [
      "# TODO\n# - implement a recursive function for the first part\n# - implement a recursive function for the second part\n\ndef search_literals_string(string, literals):\n    \"\"\"\n    Given a string and a list of literals, return a boolean value\n    indicating whether any of the literals was found.\n    \"\"\"\n    if not string or not literals:\n        return False\n    if string.startswith(literals[0]):\n        return search_literals_string(string[len(literals[0]):], literals[1:])\n    return False\n\n\n# Your searchLiteralsString function should return the same boolean\n# value as the one below.\ndef searchLiteralsString(string, literals):\n    \"\"\"\n    Given a string and a list of literals, return a boolean value\n    indicating whether any of the literals was found.\n    \"\"\"\n    if not string or not literals:\n        return False\n    if string.startswith(literals[0]):\n        return searchLiteralsString(string[len(literals[0]):], literals[1:])\n    return False\n\n\n# Your searchLiteralsString function should return the same boolean\n# value as the one below.\ndef searchLiteralsString2(string, literals):\n    \"\"\"\n    Given a string and a list of literals, return a boolean value\n    indicating whether any of the literals was found.\n    \"\"\"\n    if not string or not literals:\n        return False\n    if string.startswith(literals[0]):\n        return searchLiteralsString2(string[len(literals[0]):], literals[1:])\n    return False\n\n\n# Your searchLiteralsString function should return the same boolean\n# value as the one below.\ndef searchLiteralsString3(string, literals):\n    \"\"\"\n    Given a string and a list of literals, return a boolean value\n    indicating whether any of the literals was found.\n    \"\"\"\n    if not string or not literals:\n        return False\n    if string.startswith(literals[0]):\n        return searchLiteralsString3(string[len(literals[0]):], liter",
      -6.6015625
    ],
    [
      "import unittest\n\n# Definition for a Literal.\nclass Literal:\n    def __init__(self, s):\n        self.value = s\n        self.next = None\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, literal):\n        self.literal = literal\n        self.next = None\n\nclass Solution(object):\n    def findLiteral(self, root, literal):\n        \"\"\"\n        :type root: Node\n        :type literal: Literal\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n\n        if root.literal.value!= literal.value:\n            return False\n\n        if root.next:\n            return self.findLiteral(root.next, literal)\n\n        return True\n\n    def findLiteral2(self, root, literal):\n        \"\"\"\n        :type root: Node\n        :type literal: Literal\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n\n        if root.literal.value!= literal.value:\n            return False\n\n        if root.next:\n            if not self.findLiteral2(root.next, literal):\n                return False\n\n        return True\n\n    def findLiteral3(self, root, literal):\n        \"\"\"\n        :type root: Node\n        :type literal: Literal\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n\n        if root.literal.value!= literal.value:\n            return False\n\n        if root.next:\n            if not self.findLiteral3(root.next, literal):\n                return False\n\n        return True\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-a-literal/solution/\n\n# 1ms 100%\nclass Solution {\n    public boolean findLiteral(Node root, Literal literal) {\n        if (root",
      -7.57421875
    ],
    [
      "import collections\n\nclass Solution:\n    # @return a boolean\n    def search(self, S: str, P: str) -> bool:\n        return self.searchHelper(S, P, 0, len(S), 0, len(P))\n\n    def searchHelper(self, S, P, start, end, pos, lenP):\n        if pos == lenP:\n            return True\n        if start == end:\n            if S[pos] == P[pos]:\n                return True\n            return False\n        if S[pos] < P[pos]:\n            return self.searchHelper(S, P, start, end, pos + 1, lenP)\n        else:\n            return self.searchHelper(S, P, start, end, pos + 1, lenP)\n\n\nif __name__ == '__main__':\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"he\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"hello\")\n    assert Solution().search(\"hello\", \"",
      -7.62109375
    ],
    [
      "# Definition for a string\nclass String:\n    def __init__(self, s):\n        self.data = s\n\n    def __str__(self):\n        return self.data\n\n\nclass Solution:\n    def search(self, s, q):\n        \"\"\"\n        :type s: String\n        :type q: String\n        :rtype: bool\n        \"\"\"\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            m = (i + j) // 2\n            if q == s[m]:\n                return True\n            elif q < s[m]:\n                j = m - 1\n            else:\n                i = m + 1\n        return False\n\n\nif __name__ == \"__main__\":\n    s = \"abcdefg\"\n    q = \"abc\"\n    solution = Solution()\n    print(solution.search(s, q))",
      -8.0859375
    ],
    [
      "from collections import defaultdict\n\nclass Solution:\n    def searchLiterals(self, s: str, literals: List[str]) -> int:\n        \"\"\"\n        :type s: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        literal_map = defaultdict(set)\n        for literal in literals:\n            literal_map[literal].add(s)\n        return self.search(literal_map, s)\n\n    def search(self, literal_map, s):\n        n = len(s)\n        for i in range(n):\n            if s[i] in literal_map and literal_map[s[i]]:\n                if i + len(literal_map[s[i]]) > n:\n                    return i + len(literal_map[s[i]])\n                else:\n                    return self.search(literal_map, s[i+1:])\n        return -1\n\nif __name__ == '__main__':\n    assert Solution().searchLiterals('abcdef', ['a', 'b', 'c', 'd', 'e']) == 0\n    assert Solution().searchLiterals('abcdef', ['a', 'b', 'c', 'd', 'e', 'f']) == -1\n    assert Solution().searchLiterals('abcdef', ['a', 'b', 'c', 'd', 'e', 'f', 'g']) == -1\n    assert Solution().searchLiterals('abcdef', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == -1",
      -8.28125
    ],
    [
      "import unittest\n\n\n# Your Codec class should be named Codec and it should have the following\n# member variables:\n# - literals: a set of literals (strings) that the function returns\n#   when given a string and a literal\n# - decode: function that takes in a string and returns the decoded string\n#   or None if the string could not be decoded\n# - encode: function that takes in a decoded string and returns the string\n#   that it encodes to or None if the string could not be encoded\nclass Codec:\n    def __init__(self, literals):\n        \"\"\"\n        Initialize your data structure here.\n        :type literals: List[str]\n        \"\"\"\n        self.literals = literals\n        self.decode = {}\n        self.encode = {}\n        for literal in literals:\n            self.decode[literal] = literal\n            self.encode[literal] = literal\n\n    # @return {boolean}\n    def decode(self, s):\n        \"\"\"\n        Returns if the given string can be decoded.\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in self.decode\n\n    # @return {boolean}\n    def encode(self, s):\n        \"\"\"\n        Returns if the given string can be encoded.\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in self.encode\n\n\nclass TestMethods(unittest.TestCase):\n    def test_search(self):\n        \"\"\"\n        Test your Codec search implementation.\n        :type codec: Codec\n        :rtype: void\n        \"\"\"\n        codec = Codec({'a', 'b', 'c', 'd'})\n        self.assertEqual(codec.search('a', 'a'), True)\n        self.assertEqual(codec.search('a', 'b'), False)\n        self.assertEqual(codec.search('b', 'a'), False)\n        self.assertEqual(codec.search('b', 'b'), True)\n        self.assertEqual(codec.search('b', 'c'), False)\n        self.assertEqual(",
      -8.4765625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, S, p):\n        \"\"\"\n        :type S: str\n        :type p: str\n        :rtype: int\n        \"\"\"\n        return -1\n\n\nif __name__ == \"__main__\":\n    import sys\n    # process command line arguments\n    sys.setrecursionlimit(1500)\n    sol = Solution()\n    solution = sol.search\n    startTime = time.clock()\n    S = \"hello world hello\"\n    # S = \"hello world\"\n    # S = \"hello\"\n    # S = \"hello world\"\n    # S = \"hello world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world world\"\n    # S = \"hello world world",
      -8.5
    ],
    [
      "class Solution:\n    # @param haystack, a string\n    # @param needle, a string\n    # @return an integer\n    def strStr(self, haystack, needle):\n        if not haystack:\n            return 0\n        l = len(haystack)\n        if not needle:\n            return l\n        i = 0\n        j = l - 1\n        while i <= j:\n            k = i + 1\n            while k <= j and haystack[k]!= needle[k]:\n                k += 1\n            if k > j:\n                return -1\n            i = k + 1\n            j = i - 1\n        return i\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.strStr(\"hello\", \"e\"))\n    print(sol.strStr(\"hello\", \"h\"))\n    print(sol.strStr(\"hello\", \"ll\"))\n    print(sol.strStr(\"hello\", \"ll\"))\n    print(sol.strStr(\"hello\", \"l\"))\n    print(sol.strStr(\"hello\", \"\"))\n    print(sol.strStr(\"hello\", \"hello\"))\n    print(sol.strStr(\"hello\", \"he\"))\n    print(sol.strStr(\"hello\", \"hel\"))\n    print(sol.strStr(\"hello\", \"hell\"))\n    print(sol.strStr(\"hello\", \"helloo\"))",
      -8.5703125
    ],
    [
      "def search_in_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    # This implementation is based on a recursive algorithm.\n    # We could also use a binary search instead.\n    # We could also use a trie.\n    if not string:\n        return False\n    if string[0] not in literals:\n        return False\n    if string[0] == literals[0]:\n        return search_in_string(string[1:], literals[1:])\n    return search_in_string(string[1:], literals[1:]) or search_in_string(string, literals[1:])\n\nif __name__ == \"__main__\":\n    assert not search_in_string(\"abc\", \"a\"), \"a not in abc\"\n    assert not search_in_string(\"abc\", \"b\"), \"b not in abc\"\n    assert search_in_string(\"abc\", \"c\"), \"c in abc\"\n    assert not search_in_string(\"abc\", \"d\"), \"d not in abc\"\n    assert not search_in_string(\"abc\", \"ab\"), \"ab not in abc\"\n    assert search_in_string(\"abc\", \"abc\"), \"abc in abc\"\n    assert search_in_string(\"abc\", \"abcd\"), \"abcd not in abc\"\n    assert search_in_string(\"abc\", \"abcde\"), \"abcde not in abc\"\n    assert not search_in_string(\"abc\", \"abcde\"), \"abcde in abc\"",
      -8.96875
    ],
    [
      "class Solution:\n    \"\"\"\n    @param A : A string includes upper/lower-case letters.\n    @param B : A string includes upper/lower-case letters.\n    @return : a boolean\n    \"\"\"\n    def isMatch(self, A, B):\n        if len(A)!= len(B):\n            return False\n\n        table = [[False for i in xrange(len(A))] for j in xrange(len(B))]\n\n        for i in xrange(len(A)):\n            for j in xrange(len(B)):\n                if A[i] == B[j]:\n                    table[i][j] = True\n\n        for i in xrange(len(A)):\n            if table[i][0]:\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    A = \"a\"\n    B = \"a\"\n    assert Solution().isMatch(A, B) == False\n    A = \"a\"\n    B = \"b\"\n    assert Solution().isMatch(A, B) == False\n    A = \"a\"\n    B = \"aa\"\n    assert Solution().isMatch(A, B) == True\n    A = \"a\"\n    B = \"ab\"\n    assert Solution().isMatch(A, B) == True\n    A = \"aa\"\n    B = \"ab\"\n    assert Solution().isMatch(A, B) == True\n    A = \"abb\"\n    B = \"bba\"\n    assert Solution().isMatch(A, B) == True\n    A = \"abb\"\n    B = \"abb\"\n    assert Solution().isMatch(A, B) == True\n    A = \"abbb\"\n    B = \"bbbb\"\n    assert Solution().isMatch(A, B) == False\n    A = \"abbbb\"\n    B = \"abbbb\"\n    assert Solution().isMatch(A, B) == True\n    A = \"abbbb\"\n    B = \"abbbbbbbb\"\n    assert Solution().isMatch(A, B) == False\n    A = \"abbbbb\"\n    B = \"abbbbbbbb\"\n    assert Solution().isMatch(A",
      -9.40625
    ],
    [
      "import sys\n\nclass Solution:\n    \"\"\"\n    @param s: A string\n    @param literals: A set of strings\n    @return: A list of indices of literals in s\n    \"\"\"\n    def searchLiterals(self, s, literals):\n        if not literals:\n            return []\n\n        s = s[::-1]\n        res = []\n        for i, c in enumerate(s):\n            if c in literals:\n                res.append(i)\n            else:\n                break\n\n        return res[::-1]\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.searchLiterals('aaabbb', ['a', 'b', 'aa', 'bb']))\n    print(s.searchLiterals('aaabbb', ['aa', 'bb', 'aabbb']))\n    print(s.searchLiterals('aaabbb', ['aaabbb']))\n    print(s.searchLiterals('aabbb', ['aabbb', 'a', 'aabbb', 'b']))\n    print(s.searchLiterals('', []))\n    print(s.searchLiterals('', ['a']))\n    print(s.searchLiterals('', ['a', 'b']))\n    print(s.searchLiterals('abc', []))\n    print(s.searchLiterals('abc', ['a']))\n    print(s.searchLiterals('abc', ['b']))\n    print(s.searchLiterals('abc', ['b', 'a']))\n    print(s.searchLiterals('abc', ['a', 'b', 'c']))\n    print(s.searchLiterals('abc', ['a', 'b', 'c', 'd']))\n    print(s.searchLiterals('abc', ['a', 'b', 'c', 'd', 'e']))\n    print(s.searchLiterals('abc', ['a', 'b', 'c', 'd', 'e', 'f']))\n    print(s.searchLiterals('abc', ['a', 'b', 'c', 'd', 'e', 'f', 'g']))\n    print(s.searchLiter",
      -10.265625
    ],
    [
      "class Solution:\n    \"\"\"\n    @param s: A string\n    @param literals: A list of string\n    @return: An integer\n    \"\"\"\n    def search(self, s, literals):\n        \"\"\"\n        :type s: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        cnt = 0\n        for i in range(n):\n            for j in range(len(literals)):\n                if s[i:j] == literals[j]:\n                    cnt += 1\n                    if cnt == n - i:\n                        return j\n        return -1",
      -10.3671875
    ],
    [
      "class Solution:\n    # @param {string} haystack\n    # @param {string[]} needles\n    # @return {number}\n    def numSubstrings(self, haystack, needles):\n        n = len(needles)\n        if n == 0:\n            return 0\n        nums = [0] * (n + 1)\n        nums[0] = 1\n        for i in range(1, n + 1):\n            nums[i] = nums[i - 1] + nums[i - 2]\n        for i in range(len(haystack)):\n            for j in range(n):\n                if haystack[i + j] in needles:\n                    nums[j] += 1\n        return nums[-1]\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.numSubstrings(\"aabbcc\", [\"a\", \"b\", \"c\"])",
      -13.3671875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}