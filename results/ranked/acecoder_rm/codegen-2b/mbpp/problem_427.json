{
  "problem": {
    "task_id": "MBPP/438",
    "prompt": "Write a function to count bidirectional tuple pairs.",
    "canonical_solution": "def count_bidirectional(test_list):\r\n  res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res)) ",
    "test_list": [
      "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '3'",
      "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '2'",
      "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == '4'"
    ],
    "challenge_test_list": [],
    "problem_id": 427
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(nums[i]!= nums[j] for i in range(len(nums)) for j in range(i+1, len(nums)))",
      3.927734375
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([1 for n1, n2 in zip(nums, nums[1:]) if n1 < n2])",
      2.455078125
    ],
    [
      "class Solution:\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        \n        nums.sort()\n        \n        return sum(1 for x,y in zip(nums[1:], nums[:-1]) if x == y)",
      2.451171875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def numBidirTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        pairs = 0\n        stack = []\n        stack.append(root)\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            if node.left and node.right:\n                pairs += 1\n        return pairs",
      1.7333984375
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalTuplePairs(self, nums):\n        ans = 0\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] == nums[j]:\n                    ans += 1\n        return ans",
      0.97998046875
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __repr__(self):\n        return str(self.x) + \",\" + str(self.y)\n\n\nclass Solution:\n    def countBip(self, t1, t2):\n        \"\"\"\n        :type t1: Tuple\n        :type t2: Tuple\n        :rtype: int\n        \"\"\"\n        if t1.x == t2.x:\n            return t1.y\n        elif t1.x > t2.x:\n            return self.countBip(t2, t1)\n        else:\n            return self.countBip(t1, t2)\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBip(t1,t2)",
      0.2408447265625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution(object):\n    def countBidirectionalPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if not tuples:\n            return 0\n\n        return sum([1 if (t1 == t2) else 0 for t1, t2 in zip(tuples[:-1], tuples[1:])])",
      0.1873779296875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        dp = [[0 for j in range(n)] for i in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n            for j in range(i):\n                if j > i:\n                    break\n                dp[i][j] += dp[i-1][j]\n        return sum(dp[n-1])",
      -0.034576416015625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidir(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        d = {}\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    d[(i, j)] = d.get((i, j), 0) + 1\n                    d[(j, i)] = d.get((j, i), 0) + 1\n\n        return sum(d.values())\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    nums = []\n    for line in f:\n        nums.append(int(line))\n    print solution.countBidir(nums)",
      -0.2364501953125
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j] and i!= j:\n                    count += 1\n        \n        return count\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.numBidirectionalPairs([1,2,2,3,3,3,4,4,4,4])",
      -0.42529296875
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if not words:\n            return 0\n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n        return count",
      -0.65185546875
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if len(words) < 2:\n            return 0\n        \n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n                    \n        return count",
      -0.68505859375
    ],
    [
      "class Solution:\n    # @param {List<List<Integer>>} grid\n    # @return {integer}\n    def numBidirectionalTuple(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        ret = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i < m-1:\n                        if grid[i+1][j] == 1:\n                            ret += 1\n                    if j < n-1:\n                        if grid[i][j+1] == 1:\n                            ret += 1\n        return ret",
      -0.6865234375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for _ in words)\n        \n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBidirectional(words)",
      -0.7763671875
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n        return count\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.countBidirectionalPairs(['a','b','c'])\n    print s.countBidirectionalPairs(['a','b','c','d'])",
      -0.84716796875
    ],
    [
      "from collections import defaultdict\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        # TODO\n        return 0\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.countBidirectionalPairs([\"hello\", \"world\"])",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] < nums[i+1]:\n                count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.countBidirectional([1,2,3,4,5])",
      -0.85693359375
    ],
    [
      "import collections\n\n\nclass BidirectionalTuple(collections.namedtuple('BidirectionalTuple', ['first','second'])):\n    pass\n\n\ndef count_bidirectional_tuples(tuples):\n    \"\"\"\n    :type tuples: List[BidirectionalTuple]\n    :rtype: int\n    \"\"\"\n    # O(n^2)\n    count = 0\n    for tup in tuples:\n        if tup.first < tup.second:\n            count += 1\n    return count\n\n\ndef count_bidirectional_tuples2(tuples):\n    \"\"\"\n    :type tuples: List[BidirectionalTuple]\n    :rtype: int\n    \"\"\"\n    # O(n^2)\n    count = 0\n    for tup in tuples:\n        if tup.first < tup.second:\n            count += 1\n        elif tup.first > tup.second:\n            count += 1\n    return count",
      -0.85693359375
    ],
    [
      "from collections import namedtuple\n\nPair = namedtuple('Pair', 'a b')\n\ndef count(seq):\n    count = 0\n    for i in range(len(seq)):\n        for j in range(i):\n            count += seq[i] == seq[j]\n    return count\n\nif __name__ == '__main__':\n    assert count((1, 2)) == 2\n    assert count((1, 2, 3)) == 3\n    assert count((1, 2, 3, 4)) == 4",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        n = len(words)\n        m = {}\n        for w in words:\n            if w in m:\n                m[w] += 1\n            else:\n                m[w] = 1\n\n        return sum(m[a]*m[b] for a, b in m.items() if a!= b)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def numBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if not words:\n            return 0\n        return sum(1 for _ in words) // 2",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectional(self, nums):\n        return sum(1 for t1, t2 in zip(nums, nums[1:]))",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        return sum(sum(i < j for i in nums) for j in nums)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        pairs = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i][::-1] == words[j][::-1]:\n                    pairs += 1\n        return pairs",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countBipartitie(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for _ in range(len(nums)) if nums[-1] < nums[-2])",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for (i, j) in zip(nums, nums[1:] + nums[:1]))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([1 for i in range(len(nums)) if nums[i] == nums[i + 1]])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for word in words if word[::-1] == word[1:])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for i, j in zip(nums[::-1], nums[1::-1]) if i == j)",
      -0.85791015625
    ],
    [
      "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for word in words if word[::-1] == word[1::-1])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    words = [\"a\", \"a\", \"b\", \"ab\", \"ba\", \"b\", \"c\", \"cb\", \"cd\", \"cd\", \"da\", \"da\", \"dc\", \"dc\", \"d\", \"e\", \"ea\", \"eb\", \"ec\", \"ed\", \"e\"]\n    print s.countBidirectionalPairs(words)",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\n\nclass Solution:\n    def countBidirectionalPairs(self, words: 'List[str]') -> 'int':\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(int)\n        for word in words:\n            for i in range(len(word)):\n                for j in range(i + 1, len(word)):\n                    d[(word[i], word[j])] += 1\n        return sum(d.values())\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countBidirectionalPairs([\"abc\", \"de\", \"fgh\", \"ijk\", \"klm\"]))",
      -0.8583984375
    ],
    [
      "def count_bidi_tuple_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    return sum(1 for t1, t2 in combinations(tuples, 2))\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (2, 3), (1, 3), (1, 4), (2, 4), (3, 4)]\n    print(count_bidi_tuple_pairs(tuples))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] == words[j]:\n                    cnt += 1\n        return cnt",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        if n <= 1:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i-1] + dp[i-1]\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i] += dp[j]\n        return dp[n-1]",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i+1]:\n                count += 1\n        return count",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\n\ndef count_bidirectional_tuples(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    t = defaultdict(int)\n    for tup in tuples:\n        t[tup] += 1\n        if tup[0]!= tup[1]:\n            t[tup[1]][tup[0]] += 1\n    return sum(t.values())\n\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4)]\n    print(count_bidirectional_tuples(tuples))",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(list)\n        for word in words:\n            d[word].append('<')\n            d[word].append('>')\n        return sum(d[word] for word in words)",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\nclass Solution:\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(int)\n        for word in words:\n            for i in range(len(word)):\n                d[word[:i]] += 1\n                d[word[i+1:]] += 1\n        return sum(d.values())",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution:\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and nums[i] < nums[j]:\n                    result += 1\n        return result",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBip(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.bip(nums, 0, len(nums))\n\n    def bip(self, nums, start, end):\n        if start == end:\n            return 1\n        if start == end - 1:\n            return 2\n        if start == end - 2:\n            return 3\n        if start == end - 3:\n            return 4\n        return self.bip(nums, start + 1, end - 1) + self.bip(nums, start + 2, end - 2) + self.bip(nums, start + 3, end - 3) + self.bip(nums, start + 4, end - 4)",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\ndef bidir_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # store count of each pair\n    count = defaultdict(int)\n    for t1, t2 in tuples:\n        count[t1, t2] += 1\n        count[t2, t1] += 1\n    return sum(count.values())\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# BFS\n# 1. Traverse each tuple pair, find each pair and update count\n# 2. return sum of each pair\n# 3. each pair is a tuple pair\n# 4. sum of each pair\nclass Solution(object):\n    def bidirPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return bidir_pairs(tuples)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n * (n + 1))\n        for i in range(n):\n            dp[i * (i + 1) // 2] += nums[i]\n\n        return sum(dp[j] for j in range(n + 1))",
      -0.86083984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        return sum(1 for i in range(len(nums)) if i > 0 and nums[i] < nums[i - 1])",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] < nums[j]:\n                    cnt += 1\n        return cnt",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in xrange(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return i + 1\n        return 0",
      -0.86083984375
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(list)\n        for word in words:\n            for i in range(len(word)):\n                d[word[:i]].append(word[i:])\n        return sum(len(v) for v in d.values())\n\n\nif __name__ == \"__main__\":\n    words = [\"ab\", \"de\", \"cd\", \"d\", \"e\"]\n    print Solution().countBidirectionalPairs(words)",
      -0.88330078125
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for t in tuples:\n            if t.y is None:\n                res += 1\n            else:\n                res += 2\n        return res",
      -0.8994140625
    ],
    [
      "# https://oj.leetcode.com/problems/count-pairs/\n# tags: medium, array, bidirectional, hash\n\n\"\"\"\nGiven an array of integers, return the number of\ntuple pairs (a,b) such that a < b and a + b > 0.\n\"\"\"\n\n# O(n^2) solution\ndef count_pairs(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_2(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_3(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_4(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_5(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_6(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_7(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_8(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_9(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_10(nums):\n    return sum(i * (j - 1) for i, j in",
      -0.939453125
    ],
    [
      "from collections import namedtuple\n\n\ndef count_bidirectional(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    t = namedtuple('t', 'x y')\n    result = 0\n    for tup in tuples:\n        x, y = t(*tup)\n        if x!= y:\n            result += 1\n    return result\n\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 1),\n        (1, 2),\n        (1, 3),\n        (2, 1),\n        (2, 2),\n        (2, 3),\n        (3, 1),\n        (3, 2),\n        (3, 3),\n    ]\n    print(count_bidirectional(tuples))",
      -1.05078125
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * (n * (n - 1))\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[(i * (n - 1)) + j] = dp[(i * (n - 1)) + j - 1] + 1\n                if i == j - 1:\n                    dp[(i * (n - 1)) + j] += 1\n        return sum(dp)",
      -1.0966796875
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def countBip(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum(tup.y for tup in tuples)",
      -1.09765625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n*(n-1))\n        for i in range(n):\n            for j in range(i+1, n):\n                dp[i*n+j] = dp[j*n+i] + 1\n        return sum(dp[i*n+j-1] for i in range(1, n))",
      -1.3046875
    ],
    [
      "def count_bidi(tup):\n    \"\"\"\n    :type tup: tuple\n    :rtype: int\n    \"\"\"\n    if len(tup) < 2:\n        return 0\n    cnt = 0\n    for i in range(len(tup) - 1):\n        if tup[i] == tup[i + 1]:\n            cnt += 1\n    return cnt\n\n\ndef count_bidi2(tup):\n    \"\"\"\n    :type tup: tuple\n    :rtype: int\n    \"\"\"\n    if len(tup) < 2:\n        return 0\n    cnt = 0\n    for i in range(len(tup) - 1):\n        if tup[i] == tup[i + 1]:\n            cnt += 1\n            i += 1\n    return cnt\n\n\nif __name__ == '__main__':\n    tup = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
      -1.54296875
    ],
    [
      "class Tuple:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __eq__(self, other):\n        return self.first == other.first and self.second == other.second\n\ndef count(tup1, tup2):\n    return tup1.first == tup2.second and tup1.second == tup2.first\n\nif __name__ == '__main__':\n    tups = [Tuple(1, 2), Tuple(2, 1), Tuple(1, 3), Tuple(3, 1), Tuple(1, 4), Tuple(4, 1)]\n    print(count(tups[0], tups[2]))",
      -1.5615234375
    ],
    [
      "class Solution(object):\n    def numBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = {}\n        for w in words:\n            d[w] = d.get(w, 0) + 1\n        for w in d:\n            d[w] = d[w] - 1\n        return sum(d.values())\n\nif __name__ == \"__main__\":\n    words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"abcdcdcdc\"]\n    sol = Solution()\n    print(sol.numBidirectionalPairs(words))",
      -1.7900390625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[j][i] = 1\n        return sum(dp[0])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numBidirectionalPairs([1, 1, 1]))",
      -1.8154296875
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    count += 1\n                if nums[i] > nums[j]:\n                    count += 1\n        return count\n\nnums = [1, 2, 3, 3, 4, 5, 6, 7, 8, 8]\nprint(Solution().countBidirectionalPairs(nums))",
      -1.8818359375
    ],
    [
      "class TuplePairs:\n\n    def __init__(self, num_pairs):\n        self.num_pairs = num_pairs\n        self.count = 0\n\n    def count_pairs(self, tup1, tup2):\n        self.count += 1\n\n    def solve(self):\n        return self.count\n\nif __name__ == '__main__':\n    tup1, tup2 = (1, 2), (2, 1)\n    tup_pairs = TuplePairs(2)\n    tup_pairs.count_pairs(tup1, tup2)\n    print tup_pairs.solve()",
      -2.005859375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    res += 1\n                    if i > j:\n                        res += 1\n\n        return res",
      -2.060546875
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def numBip(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for n in nums:\n            if n > 0:\n                count += 1\n        return count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, -1, 1, -1, 1, -1]\n    print s.numBip(nums)",
      -2.12109375
    ],
    [
      "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        return sum(1 for i in range(n - 1) if nums[i] > nums[i + 1])\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countBidirectionalPairs([1, 2, 3, 3, 1]))\n    print(sol.countBidirectionalPairs([1, 2, 3, 2, 1]))\n    print(sol.countBidirectionalPairs([1, 1, 2, 3]))\n    print(sol.countBidirectionalPairs([1, 1, 2, 2]))\n    print(sol.countBidirectionalPairs([1, 2, 3, 4, 5]))",
      -2.123046875
    ],
    [
      "from collections import defaultdict\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second step is\n# the same as the first step.\n# A more efficient solution is:\n# def count_bidirectional_pairs(tuples):\n#     return sum(count_pairs(tuples))\n\ndef count_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second step is\n# the same as the first step.\n# A more efficient solution is:\n# def count_bidirectional_pairs(tuples):\n#     return sum(count_pairs(tuples))\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second",
      -2.46484375
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution:\n    def countBidir(self, t: List[Tuple]) -> int:\n        if not t:\n            return 0\n        num = 0\n        for i in range(len(t)):\n            for j in range(i+1, len(t)):\n                if t[i].x == t[j].x:\n                    num += 1\n        return num",
      -2.755859375
    ],
    [
      "class TuplePairs:\n    def __init__(self, tup):\n        self.tup = tup\n        self.count = 0\n\n    def __iter__(self):\n        for i in range(len(self.tup) - 1):\n            for j in range(i + 1, len(self.tup)):\n                if (self.tup[i] == self.tup[j] and\n                    self.tup[i]!= self.tup[j]):\n                    self.count += 1\n                    yield (self.tup[i], self.tup[j])\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        tup = tuple(nums)\n        return sum(1 for _ in TuplePairs(tup))\n\n\nif __name__ == '__main__':\n    assert Solution().countBidirectionalPairs([1, 1]) == 2\n    assert Solution().countBidirectionalPairs([2, 2]) == 0",
      -2.931640625
    ],
    [
      "class TuplePair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\ndef count_bidir_tuples(tuples):\n    \"\"\"\n    :type tuples: List[TuplePair]\n    :rtype: int\n    \"\"\"\n    return sum(1 for t in tuples if t.a == t.b)\n\nif __name__ == '__main__':\n    tuples = [TuplePair(1, 2), TuplePair(2, 1), TuplePair(2, 3), TuplePair(3, 2), TuplePair(3, 4)]\n    print(count_bidir_tuples(tuples))",
      -2.9453125
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = [0] * (n + 1)\n        for i in range(1, n + 1):\n            m[i] = m[i - 1] + (nums[i - 1] < nums[i] and 1 or 0)\n        return m[n]",
      -3.07421875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n\n        n = len(nums)\n        if n == 1:\n            return 1\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    count += 1\n\n        return count\n\n\nif __name__ == '__main__':\n    print Solution().numBidirectionalPairs([1, 1])",
      -3.642578125
    ],
    [
      "from collections import defaultdict\n\ndef count_bidirectional_tuple_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # key: (a, b) -> val = 1\n    # value: (b, a) -> val = 1\n    d = defaultdict(int)\n    for a, b in tuples:\n        d[(b, a)] += 1\n        d[(a, b)] += 1\n    return sum(d.values())\n\ndef main():\n    \"\"\"\n    Example:\n        >>> tuple_pairs = [(1, 2), (2, 1), (3, 4)]\n        >>> print(count_bidirectional_tuple_pairs(tuple_pairs))\n        2\n    \"\"\"\n    tuples = [(1, 2), (2, 1), (3, 4)]\n    print(count_bidirectional_tuple_pairs(tuples))\n\nif __name__ == '__main__':\n    main()",
      -3.701171875
    ],
    [
      "import collections\n\nclass Solution:\n    # @return an integer\n    def numBidirectionalPairs(self, words):\n        if not words:\n            return 0\n        word_set = collections.defaultdict(int)\n        for w in words:\n            word_set[w] += 1\n        word_set = {k: v for k, v in word_set.items() if v > 1}\n        result = 0\n        for word, count in word_set.items():\n            for i in range(count):\n                for j in range(i + 1, count):\n                    result += 1\n        return result",
      -3.71875
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        dic = {}\n        for word in words:\n            for i in range(len(word)):\n                j = i + 1\n                if j < len(word):\n                    if word[i] == word[j]:\n                        dic[word[i]] += 1\n        return sum(dic.values())\n\n\nif __name__ == \"__main__\":\n    words = [\"hello\", \"leetcode\"]\n    print Solution().countBidirectional(words)",
      -3.740234375
    ],
    [
      "from collections import Counter\n\n# Forbid duplicates\ndef count_pairs(l):\n    c = Counter(l)\n    return sum(c.values())\n\nif __name__ == '__main__':\n    assert count_pairs([1, 2, 3, 4, 5, 6]) == 0\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 7]) == 6\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8]) == 15\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 6, 7, 8, 8, 8, 9]) == 23",
      -3.91796875
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A integer\n    \"\"\"\n    def numBidirTuple(self, nums):\n        \"\"\"\n        @param nums: A list of integers\n        @return: A integer\n        \"\"\"\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] == nums[j] and i!= j:\n                    dp[i] += dp[j]\n        return dp[-1]",
      -4.0546875
    ],
    [
      "class Solution:\n    # @param {List<List<Integer>>} grid\n    # @return {integer}\n    def numBidirectionalTuple(self, grid):\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        if m == 1:\n            return 0\n\n        grid = [[int(i) for i in str(grid[0][i])] for i in range(n)]\n        pairs = 0\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    pairs += 1\n                    grid[i][j] = '0'\n                    pairs += 1\n                    grid[i][j] = '1'\n        return pairs\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    grid = [['1', '1', '0', '1', '1'],\n            ['0', '0', '0', '0', '0'],\n            ['1', '0', '1', '1', '0']]\n    print(sol.numBidirectionalTuple(grid))\n    grid = [['1', '1', '1', '0', '0'],\n            ['0', '1', '0', '1', '1'],\n            ['1', '0', '0', '0', '0']]\n    print(sol.numBidirectionalTuple(grid))\n    grid = [['1', '1', '1', '1', '0'],\n            ['0', '1', '0', '1', '0'],\n            ['1', '0', '0', '0', '0']]\n    print(sol.numBidirectionalTuple(grid))",
      -4.19140625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidir(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return sum(1 for i, j in zip(nums, nums[1:]) if i > j)\n\n    def countBidir_1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for i in nums if i > nums[i])\n\n\nif __name__==\"__main__\":\n    print(Solution().countBidir([3,3,1,2,2,3]))\n    print(Solution().countBidir_1([3,3,1,2,2,3]))",
      -4.2734375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer\n    \"\"\"\n    def countBidirectionalPairs(self, nums):\n        return self.count_pairs(nums, 0, len(nums) - 1)\n        \n    def count_pairs(self, nums, start, end):\n        if start == end:\n            return 1\n        count = 0\n        while start < end:\n            if nums[start] == nums[end]:\n                count += 1\n                start += 1\n                end -= 1\n            else:\n                start += 1\n        return count",
      -4.453125
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return str(self.x) +'' + str(self.y)\n\n\nclass Solution:\n    # @param {Tuple[]} tuples\n    # @return {int}\n    def countBidirectional(self, tuples):\n        count = 0\n        for i in range(len(tuples)):\n            for j in range(i):\n                if tuples[i] == tuples[j]:\n                    count += 1\n        return count\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.countBidirectional([(1, 2), (2, 3), (3, 1), (4, 5)])",
      -4.75
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\nclass Solution(object):\n    def countBidir(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for t1, t2 in tuples:\n            if t1.y == t2.y:\n                count += 1\n            else:\n                count += 1\n                if t1.y!= None:\n                    count -= 1\n                if t2.y!= None:\n                    count -= 1\n        return count",
      -4.96875
    ],
    [
      "class TuplePairCounter:\n    def __init__(self):\n        self.pair_counts = {}\n\n    def count_pairs(self, t1, t2):\n        if t1 not in self.pair_counts:\n            self.pair_counts[t1] = {}\n        if t2 not in self.pair_counts[t1]:\n            self.pair_counts[t1][t2] = 0\n        self.pair_counts[t1][t2] += 1\n\n    def get_pairs(self, t1):\n        if t1 not in self.pair_counts:\n            return []\n        return self.pair_counts[t1].keys()\n\n    def get_count(self, t1, t2):\n        return self.pair_counts[t1][t2]\n\n\ndef main():\n    tuple_counter = TuplePairCounter()\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    tuple_counter.count_pairs(t1, t2)\n    print tuple_counter.get_pairs(t1)\n    print tuple_counter.get_pairs(t2)\n    print tuple_counter.get_count(t1, t2)\n\nif __name__ == '__main__':\n    main()",
      -4.97265625
    ],
    [
      "class Solution(object):\n    def countBipartitngPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_i = n - 1\n        sum = 0\n        for i in range(max_i):\n            sum += nums[i]\n            for j in range(i + 1, max_i):\n                sum += nums[j]\n                if i!= j and sum >= nums[i] + nums[j]:\n                    return sum - nums[i] - nums[j]\n        \n        return 0",
      -5.23828125
    ],
    [
      "from collections import defaultdict\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for tup in tuples:\n        for i in range(len(tup)):\n            for j in range(i+1, len(tup)):\n                if tup[i] == tup[j]:\n                    count[tup[i]] += 1\n    return sum(count.values())\n\nif __name__ == '__main__':\n    tuples = [\n        [1, 2, 3, 4],\n        [1, 2, 4, 5],\n        [2, 3, 4, 5],\n        [1, 3, 4, 5],\n        [1, 4, 4, 5],\n        [4, 4, 4, 5],\n        [3, 4, 4, 5],\n    ]\n    print(count_bidirectional_pairs(tuples))",
      -5.59765625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __str__(self):\n        return str(self.x) + ',' + str(self.y)\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum([1 for t1 in tuples if t1[0] == t1[1]])",
      -5.703125
    ],
    [
      "def count_bidirectional_tuple(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    result = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                result += 1\n\n    return result\n\n\nif __name__ == '__main__':\n    tuples = [\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab',",
      -5.73828125
    ],
    [
      "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for word in words:\n            word_list = list(word)\n            for i in range(len(word_list) - 1):\n                if word_list[i] == word_list[i+1]:\n                    count += 1\n            for i in range(1, len(word_list)):\n                if word_list[i-1] == word_list[i]:\n                    count += 1\n        return count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssdd\"]\n    print s.countBidirectional(words)",
      -6.375
    ],
    [
      "def count_bidir_tuples(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not tuple_list:\n        return 0\n    result = 0\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i][0] < tuple_list[j][0]:\n                result += 1\n            elif tuple_list[i][0] > tuple_list[j][0]:\n                result += 1\n    return result\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 4), (2, 1)]\n    print(count_bidir_tuples(tuple_list))",
      -6.76171875
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n# https://leetcode.com/problems/count-bidirectional-tuple-pairs/solution/\n# https://leetcode.com/problems/count-bidirectional-tuple-pairs/\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] < nums[j]:\n                    if nums[i] == nums[j] + 1:\n                        count += 2\n                    elif nums[i] == nums[j] - 1:\n                        count += 2\n                else:\n                    if nums[i] == nums[j] - 1:\n                        count += 2\n                    elif nums[i] == nums[j] + 1:\n                        count += 2\n        \n        return count",
      -7.0
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/discuss/182637/Java-Python-Python-tuple-pair-count\n\nclass Solution:\n    # @param {List[Tuple[int]]} tuples\n    # @return {integer}\n    def countBidirectionalPairs(self, tuples):\n        return sum(1 for t in tuples if t[0] == t[1] and t[0] == t[2])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.countBidirectionalPairs([(1,2),(2,3),(1,3),(1,2)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,2),(1,3),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3),(1,3),(1,2),(2",
      -8.015625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return '({0}, {1})'.format(self.x, self.y)\n\nclass Solution(object):\n    def countBip(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for t1 in tuples:\n            for t2 in tuples:\n                if t1 == t2:\n                    continue\n                if t1.__eq__(t2):\n                    count += 1\n        return count\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBip(tuples)",
      -8.8359375
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBipartitionPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return i+1\n        return 0\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.numBipartitionPairs([1,1,1])\n    print sol.numBipartitionPairs([1,2,3])\n    print sol.numBipartitionPairs([1,2,3,2])\n    print sol.numBipartitionPairs([1,2,3,4,5,6,7])",
      -9.2890625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        DP\n        :param nums: list\n        :return: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n + 1)\n        for i in xrange(1, n + 1):\n            for j in xrange(i):\n                if i == j:\n                    dp[i] += 1\n                elif j == nums[i - 1]:\n                    dp[i] += 1\n                elif j == nums[i]:\n                    dp[i] += 1\n                else:\n                    dp[i] += dp[j]\n\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.countBidirectionalPairs([1,2,2,3,1,4])\n    print sol.countBidirectionalPairs([1,2,3])\n    print sol.countBidirectionalPairs([1,2,3,4,5])",
      -9.2890625
    ],
    [
      "# Definition for a bidirectional tuple.\nclass Tuple:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution:\n    def countBidirectional(self, tuples: List[Tuple]) -> int:\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum(1 for t in tuples for _ in t)\n\n# TESTS\nfor tuples, expected in [\n    ([(1, 2), (3, 4)], 2),\n    ([(1, 2), (3, 4, 5)], 3),\n    ([(1, 2), (3, 4), (5, 6)], 3),\n    ([(1, 2, 3), (4, 5, 6)], 3),\n    ([], 0),\n    ([(1, 2), (3, 4, 5)], 3),\n    ([(1, 2), (3, 4, 5), (6, 7, 8)], 3),\n    ([(1, 2, 3), (4, 5, 6)], 3),\n    ([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 3),\n    ([(1, 2), (3, 4, 5)], 3),\n]:\n    sol = Solution()\n    actual = sol.countBidirectional(tuples)\n    print(\"The count of bidirectional tuple pairs is\", actual)\n    assert actual == expected",
      -9.765625
    ],
    [
      "from collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\n\ndef count_pairs(points):\n    \"\"\"\n    :type points: List[Point]\n    :rtype: int\n    \"\"\"\n    if not points:\n        return 0\n\n    def has_same_y(p1, p2):\n        return p1.y == p2.y\n\n    def has_same_x(p1, p2):\n        return p1.x == p2.x\n\n    def is_same_point(p1, p2):\n        return has_same_y(p1, p2) and has_same_x(p1, p2)\n\n    def get_same_point_count(points):\n        return sum(1 for p1 in points if is_same_point(p1, p2) for p2 in points if is_same_point(p1, p2))\n\n    return get_same_point_count(points)",
      -10.359375
    ],
    [
      "# Definition for a bidirectional tuple.\nclass Tuple(object):\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __lt__(self, other):\n        return self.first < other.first\n\n    def __gt__(self, other):\n        return self.first > other.first\n\n    def __le__(self, other):\n        return self.first <= other.first\n\n    def __ge__(self, other):\n        return self.first >= other.first\n\n    def __eq__(self, other):\n        return self.first == other.first\n\n    def __ne__(self, other):\n        return self.first!= other.first\n\n    def __str__(self):\n        return str(self.first) + \":\" + str(self.second)\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for first, second in tuples:\n            first_ok = second_ok = False\n            for first_ok, second_ok in [(first < second, second > first),\n                                        (second < first, first > second)]:\n                if first_ok and second_ok:\n                    result += 2\n                elif first_ok:\n                    result += 1\n                elif second_ok:\n                    result += 2\n        return result",
      -10.5234375
    ],
    [
      "# https://oj.leetcode.com/problems/count-bidirectional-tuple-pairs/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            if node is None:\n                return 0\n            res = 0\n            if node.left is not None:\n                res += dfs(node.left)\n            if node.right is not None:\n                res += dfs(node.right)\n            return res + 1\n\n        return dfs(root)\n\n\nif __name__ == \"__main__\":\n    print(Solution().countBidirectionalTuplePairs(None))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1)))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1, TreeNode(2), TreeNode(3))))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1, TreeNode(2), TreeNode(3), TreeNode(4))))",
      -11.15625
    ],
    [
      "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/discuss/703514/Python-Cython-solution-with-recursion-and-iteration\n\nclass Solution:\n    # @return an integer\n    def countBidirectionalTuplePairs(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not edges:\n            return 0\n        \n        # count the number of bidirectional tuple pairs\n        return self.countBidirectionalTuplePairs_rec(edges, 0, edges[0], 1)\n    \n    # recursion\n    def countBidirectionalTuplePairs_rec(self, edges, i, start, direction):\n        # base case\n        if i == len(edges):\n            return 1\n        \n        # get the next edge\n        end = edges[i][direction]\n        \n        # recursion\n        return self.countBidirectionalTuplePairs_rec(edges, i+1, end, direction^1) + self.countBidirectionalTuplePairs_rec(edges, i+1, start, direction^1)\n        \n    # iterative\n    def countBidirectionalTuplePairs_iter(self, edges):\n        # base case\n        if not edges:\n            return 0\n        \n        # iterate over all edges\n        count = 0\n        for i in range(len(edges)):\n            # get the next edge\n            end = edges[i][1]\n            \n            # iterate over all edges\n            for j in range(i+1, len(edges)):\n                # get the next edge\n                start = edges[j][0]\n                \n                # iterate over all edges\n                for k in range(j+1, len(edges)):\n                    # get the next edge\n                    start = edges[k][0]\n                    \n                    # iterate over all edges\n                    for l in range(k+1, len(edges)):\n                        # get the next edge\n                        end = edges[l][1]",
      -11.5
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return str(self.x) + str(self.y)\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        cnt = 0\n        for i in range(1, len(nums)):\n            if nums[i-1].y == nums[i].y:\n                cnt += 1\n            elif nums[i-1].y > nums[i].y:\n                cnt += (nums[i-1].x - nums[i].x + 1) * (nums[i-1].y - nums[i].y + 1)\n        return cnt",
      -12.0234375
    ],
    [
      "# https://oj.leetcode.com/problems/count-bidirectional-tuple-pairs/\n# Write an efficient algorithm that counts the number of bi-directional tuple\n# pairs.\n# The tuple (x, y) is bidirectional if y < x and x < y.\n# Example 1:\n# Input:\n# (2,1), (1,2)\n# Output: 1\n# Example 2:\n# Input:\n# (0, 1), (1, 2), (2, 3), (3, 4), (4, 5)\n# Output: 2\n# Example 3:\n# Input:\n# (0, 1), (2, 3), (4, 5)\n# Output: 0\n# Note:\n# The pairs (x, y) and (y, x) count as the same pair.\n# The input is always valid, each tuple is a valid pair of integers.\n# The input is sorted.\n#\n# Companies\n# Microsoft\n# Related Topics\n# Two Pointers\n# Similar Questions\n# Sort Two Pointers\n#\nimport unittest\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                count += 1\n        return count\n\nclass Solution2(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                count += 1\n        return count\n\nclass Solution3(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i",
      -12.765625
    ],
    [
      "# https://oj.leetcode.com/problems/count-and-say/\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        count = 0\n        stack = []\n        stack.append((root, 1))\n        while stack:\n            node, times = stack.pop()\n            if node.left is not None:\n                stack.append((node.left, times + 1))\n            if node.right is not None:\n                stack.append((node.right, times + 1))\n            if times == 1:\n                count += 1\n        return count\n\n# Note:\n# 1. the tree is assumed to be a binary tree\n# 2. the root is the left-most node of the tree",
      -13.2265625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution(object):\n    def countBipartite(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        d = dict()\n        for x in nums:\n            d[x] = d.get(x, 0) + 1\n\n        dp = [0 for i in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                if (d[nums[i]] == 1 and d[nums[j]] == 1):\n                    dp[i] = dp[i] + dp[j]\n                    dp[j] = dp[i]\n        return dp[0]",
      -13.265625
    ],
    [
      "class Solution(object):\n    def countBipartite(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        count = 0\n        self.dfs(root, 0, 0, count)\n        return count\n\n    def dfs(self, root, depth, num, count):\n        if not root:\n            return\n        if depth == 2:\n            num += 1\n        if depth % 2:\n            self.dfs(root.left, depth + 1, num, count)\n        else:\n            self.dfs(root.right, depth + 1, num, count)\n        count += 1\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().countBipartite(root)",
      -14.7421875
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __str__(self):\n        return str(self.x) +'' + str(self.y)\n\n\nclass Solution(object):\n    def countBipartite(self, root):\n        \"\"\"\n        :type root: Tuple\n        :rtype: int\n        \"\"\"\n        return self.countBipartite_rec(root, [])\n\n    def countBipartite_rec(self, root, counts):\n        if not root:\n            return 0\n        if not counts:\n            counts.append(0)\n        if root.x!= root.y:\n            counts[0] += 1\n            counts[1] += 1\n        else:\n            counts[0] += 1\n        counts[0] += self.countBipartite_rec(root.y, counts)\n        counts[1] += self.countBipartite_rec(root.x, counts)\n        return counts[0] + counts[1]\n\nif __name__ == '__main__':\n    root = Tuple(1, 2)\n    root.x = Tuple(2, 1)\n    root.y = Tuple(1, 2)\n    root.x.y = Tuple(2, 1)\n    root.y.x = Tuple(1, 2)\n    s = Solution()\n    print s.countBipartite(root)",
      -15.4375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}