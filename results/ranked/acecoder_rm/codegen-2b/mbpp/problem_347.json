{
  "problem": {
    "task_id": "MBPP/358",
    "prompt": "Write a function to find modulo division of two lists using map and lambda function.",
    "canonical_solution": "def moddiv_list(nums1,nums2):\r\n  result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)",
    "test_list": [
      "assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]",
      "assert moddiv_list([3,2],[1,4])==[0, 2]",
      "assert moddiv_list([90,120],[50,70])==[40, 50]"
    ],
    "challenge_test_list": [],
    "problem_id": 347
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "# https://www.hackerrank.com/challenges/modular-division-with-lambda/problem\n\n# This is the basic idea of the solution.\n# The input is a list of integers and the output is a list of integers.\n# The output list is in the same order as the input list.\n# We use a lambda function to get the remainder of each element in the input list.\n# Then, we can just use the map function to get the remainder of each element in the output list.\n\ndef mod_division(lst1, lst2):\n    result = []\n    for i in range(0, len(lst1)):\n        result.append(lst1[i] % lst2[i])\n    return result\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [2, 3, 4, 5, 6]\n    print(mod_division(lst1, lst2))",
      7.71875
    ],
    [
      "def mod_division(lst1, lst2):\n    \"\"\"\n    >>> mod_division([3, 2, 4], [5, 4, 1])\n    (3, 4)\n    \"\"\"\n    if len(lst1) == 0 or len(lst2) == 0:\n        return (0, 0)\n    else:\n        return (lst1[0] % lst2[0], lst2[-1] % lst1[-1])\n\ndef mod_division_2(lst1, lst2):\n    \"\"\"\n    >>> mod_division_2([3, 2, 4], [5, 4, 1])\n    (3, 4)\n    \"\"\"\n    if len(lst1) == 0 or len(lst2) == 0:\n        return (0, 0)\n    else:\n        return (lst1[0] % lst2[0], lst2[-1] % lst1[-1])\n\ndef mod_division_3(lst1, lst2):\n    \"\"\"\n    >>> mod_division_3([3, 2, 4], [5, 4, 1])\n    (3, 4)\n    \"\"\"\n    if len(lst1) == 0 or len(lst2) == 0:\n        return (0, 0)\n    else:\n        return (lst1[0] % lst2[0], lst2[-1] % lst1[-1])\n\ndef mod_division_4(lst1, lst2):\n    \"\"\"\n    >>> mod_division_4([3, 2, 4], [5, 4, 1])\n    (3, 4)\n    \"\"\"\n    if len(lst1) == 0 or len(lst2) == 0:\n        return (0, 0)\n    else:\n        return (lst1[0] % lst2[0], lst2[-1] % lst1[-1])\n\ndef mod_division_5(lst1, lst2):\n    \"\"\"\n    >>> mod_division_5([3, 2, 4], [5, 4, 1])\n    (3, 4)",
      6.23828125
    ],
    [
      "def mod(lst1,lst2):\n    return [i % j for i,j in zip(lst1,lst2)]\n\ndef mod2(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod3(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod4(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod5(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod6(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod7(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod8(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\ndef mod9(lst1,lst2):\n    return [i%j for i,j in zip(lst1,lst2)]\n\n\n\nlst1 = [1,2,3,4,5]\nlst2 = [2,3,4,5,6]\n\nlst3 = mod(lst1,lst2)\n\nprint(lst3)",
      5.18359375
    ],
    [
      "def mod_div(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef test_mod_div():\n    assert mod_div([3, 4, 5], [2, 5, 10]) == [1, 0, 3]\n    assert mod_div([3, 4, 5], [3, 5, 10]) == [0, 1, 1]\n    assert mod_div([3, 4, 5], [2, 6, 10]) == [1, 0, 3]\n    assert mod_div([3, 4, 5], [2, 7, 10]) == [1, 0, 3]\n    assert mod_div([3, 4, 5], [2, 8, 10]) == [1, 1, 1]\n    assert mod_div([3, 4, 5], [2, 9, 10]) == [1, 1, 1]\n    assert mod_div([3, 4, 5], [2, 10, 10]) == [1, 1, 1]\n\ndef test_mod_div_2():\n    assert mod_div([1, 2, 3], [1, 2, 3]) == [0, 0, 0]\n    assert mod_div([1, 2, 3], [2, 4, 6]) == [1, 0, 1]\n    assert mod_div([1, 2, 3], [2, 5, 6]) == [1, 1, 0]\n\nif __name__ == '__main__':\n    test_mod_div()\n    test_mod_div_2()",
      4.93359375
    ],
    [
      "# T:O(N), S:O(N), 3 ms\ndef mod(l, r):\n    return [i % r for i in l]\n\ndef findMod(l, r):\n    return [i % r for i in l]\n\ndef main():\n    l1 = [2, 3, 5, 7]\n    r1 = [3, 2, 1, 4]\n    l2 = [1, 2, 3, 4]\n    r2 = [2, 1, 3, 4]\n    assert findMod(l1, r1) == mod(l1, r1)\n    assert findMod(l2, r2) == mod(l2, r2)\n\nif __name__ == '__main__':\n    main()",
      4.29296875
    ],
    [
      "def mod(lst1, lst2):\n    \"\"\"\n    Modulo division of two lists\n    \"\"\"\n    def mod_list(lst, mod):\n        \"\"\"\n        Modulo division of list\n        \"\"\"\n        return [lst[i] % mod for i in range(len(lst))]\n\n    return mod_list(lst1, mod) + mod_list(lst2, mod)\n\n\ndef main():\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [1, 2, 3, 4, 5]\n    print(mod(lst1, lst2))\n\n\nif __name__ == '__main__':\n    main()",
      3.2109375
    ],
    [
      "def mod_div_2(lst1, lst2):\n    return map(lambda x: x % 2, lst1)\n\ndef mod_div_1(lst1, lst2):\n    return list(map(lambda x: x % 2, lst1))\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [6, 7, 8, 9, 10]\n\n    print(mod_div_1(lst1, lst2))\n    print(mod_div_2(lst1, lst2))",
      1.568359375
    ],
    [
      "def mod_division(l1, l2):\n    return sum([x % y for x, y in zip(l1, l2)])\n\n\nif __name__ == '__main__':\n    l1 = [2, 4, 6, 8, 1, 3]\n    l2 = [1, 2, 3, 4, 5, 6]\n    print(mod_division(l1, l2))",
      1.537109375
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-multiplication-division\n\ndef modDiv(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef main():\n    l1 = [7, 3, 3, 3, 4]\n    l2 = [4, 1, 2, 1, 1]\n    print(modDiv(l1, l2))\n\nif __name__ == '__main__':\n    main()",
      0.888671875
    ],
    [
      "def mod(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod2(l1, l2):\n    m = [0] * len(l1)\n    for i in range(len(l1)):\n        m[i] = (l1[i] % l2[i] + l2[i]) % l2[i]\n    return m\n\ndef mod3(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod4(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod5(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod6(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod7(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod8(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\ndef mod9(l1, l2):\n    return [l1[i] % l2[i] for i in range(len(l1))]\n\nif __name__ == \"__main__\":\n    assert mod([3, 2, 1], [2, 3, 1]) == [0, 1, 0]\n    assert mod2([3, 2, 1], [2, 3, 1]) == [0, 1, 1]\n    assert mod3([3, 2, 1], [2, 3, 1]) == [0, 1, 1]\n    assert mod4([3, 2, 1], [2, 3, 1]) == [0, 1, 1]\n    assert mod5([3, 2, 1], [2, 3, 1",
      0.81201171875
    ],
    [
      "def mod(x, y):\n    return x % y\n\ndef mod_lambda(x, y):\n    return lambda x, y: x % y\n\ndef mod_map(x, y):\n    return map(lambda x: x % y, x)\n\ndef mod_lambda_map(x, y):\n    return map(lambda x: x % y, x)\n\ndef mod_lambda_map_lambda(x, y):\n    return map(lambda x, y: x % y, x, y)\n\ndef mod_map_lambda(x, y):\n    return map(lambda x: x % y, x)\n\ndef mod_map_lambda_lambda(x, y):\n    return map(lambda x, y: x % y, x, y)\n\ndef mod_lambda_map_lambda_lambda(x, y):\n    return map(lambda x, y: x % y, x, y)\n\nif __name__ == \"__main__\":\n    print(mod([1, 2, 3], [4, 5, 6]))\n    print(mod_lambda([1, 2, 3], [4, 5, 6]))\n    print(mod_map([1, 2, 3], [4, 5, 6]))\n    print(mod_lambda_map([1, 2, 3], [4, 5, 6]))\n    print(mod_lambda_map_lambda([1, 2, 3], [4, 5, 6]))\n    print(mod_map_lambda([1, 2, 3], [4, 5, 6]))\n    print(mod_map_lambda_lambda([1, 2, 3], [4, 5, 6]))\n    print(mod_lambda_map_lambda_lambda([1, 2, 3], [4, 5, 6]))",
      0.1552734375
    ],
    [
      "def modulo(a, b):\n    return a % b\n\n\ndef main():\n    a = [1,2,3,4,5,6,7,8,9]\n    b = [1,3,5,7,9]\n    print(modulo(a, b))\n\nif __name__ == '__main__':\n    main()",
      0.138916015625
    ],
    [
      "def find_mod(l1, l2):\n    return reduce(lambda x,y: x % y, map(lambda x: x % y, l1) + map(lambda x: x % y, l2))\n\ndef test_find_mod():\n    assert find_mod([1, 2, 3, 4], [1, 2, 3, 5]) == 3\n    assert find_mod([1, 2, 3, 4], [1, 2, 3, 4]) == 0\n    assert find_mod([1, 2, 3, 4], [1, 2, 3, 5, 6]) == 2",
      0.0875244140625
    ],
    [
      "# https://www.youtube.com/watch?v=jVlKrZlYl2s\n\ndef mod_division(x, y):\n    return [x[i] % y[i] for i in range(len(x))]\n\ndef mod_division_lambda(x, y):\n    return [lambda i: x[i] % y[i] for i in range(len(x))]\n\ndef mod_division_lambda_map(x, y):\n    return [lambda i: x[i] % y[i] for i in range(len(x))]\n\n\n\n# x = [1,2,3,4,5]\n# y = [2,3,4,5,6]\n\n# print(mod_division(x, y))\n# print(mod_division_lambda(x, y))\n# print(mod_division_lambda_map(x, y))",
      -0.041015625
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division-theory/problem\n\ndef modDiv(lst1, lst2):\n    \"\"\"\n    :type lst1: List[int]\n    :type lst2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [int(x) % int(y) for x, y in zip(lst1, lst2)]\n\nif __name__ == '__main__':\n    lst1 = [2, 4, 6, 8, 10]\n    lst2 = [3, 5, 7, 9]\n    print(modDiv(lst1, lst2))",
      -0.1402587890625
    ],
    [
      "def find_mod(a, b):\n    if len(a) == 0:\n        return 0\n    else:\n        return 1\n\n\na = [2, 3, 4, 5]\nb = [2, 3, 4, 5]\n\nprint(find_mod(a, b))",
      -0.190673828125
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division-list/problem\n# https://www.hackerrank.com/challenges/modular-division-list/submissions/code/18042951\n\ndef mod(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [i % j for i, j in zip(nums1, nums2)]\n\ndef mod_lambda(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [lambda i, j: i % j for i, j in zip(nums1, nums2)]\n\nif __name__ == '__main__':\n    nums1 = [1, 3, 4, 6, 7, 9]\n    nums2 = [2, 5, 9, 13, 16]\n    print(mod(nums1, nums2))\n    print(mod_lambda(nums1, nums2))",
      -0.2001953125
    ],
    [
      "# https://www.hackerrank.com/challenges/mod-division/problem\n# https://www.hackerrank.com/challenges/mod-division-lambda/problem\n# https://www.hackerrank.com/challenges/mod-division-map/problem\n\ndef mod_division(a, b):\n    \"\"\"\n    Returns the modulo division of two lists a and b.\n\n    >>> mod_division([1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\n    [1, 3, 5, 7, 9]\n    \"\"\"\n    return [lambda x, y: x % y for x, y in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    print(mod_division(a, b))",
      -0.38818359375
    ],
    [
      "def mod_div(x, y):\n    return [x[i] % y[i] for i in range(len(x))]\n\n\ndef mod_div_lambda(x, y):\n    return [lambda i: x[i] % y[i] for i in range(len(x))]\n\n\ndef mod_div_map(x, y):\n    return [x[i] % y[i] for i in range(len(x))]\n\n\ndef mod_div_map_lambda(x, y):\n    return [lambda i: x[i] % y[i] for i in range(len(x))]\n\n\ndef main():\n    x = [1, 2, 3, 4, 5]\n    y = [2, 4, 6, 8, 10]\n    print(mod_div(x, y))\n    print(mod_div_lambda(x, y))\n    print(mod_div_map(x, y))\n    print(mod_div_map_lambda(x, y))\n\n\nif __name__ == '__main__':\n    main()",
      -0.54052734375
    ],
    [
      "def modulo_division(lst1, lst2):\n    # Complete this function\n    return map(lambda x: x % lst2[0], lst1)\n\nif __name__ == '__main__':\n    lst1 = [2, 3, 5]\n    lst2 = [4, 7]\n    print(modulo_division(lst1, lst2))",
      -0.61962890625
    ],
    [
      "from functools import reduce\n\n\ndef find_mod(a, b):\n    return reduce(lambda x, y: x + y, (a[i] % b[i] for i in range(len(a))))\n\n\ndef mod_division(a, b):\n    return [find_mod(a, b), find_mod(b, a)]\n\n\ndef mod_division_lambda(a, b):\n    return [(lambda x, y: x - y, lambda x, y: x + y)\n            (find_mod(a, b), find_mod(b, a))]\n\n\ndef mod_division_map(a, b):\n    return [(lambda x: x % b, lambda x: x + b)\n            (find_mod(a, b), find_mod(b, a))]\n\n\ndef main():\n    a = [1, 2, 3, 4]\n    b = [4, 3, 2, 1]\n    print(mod_division(a, b))\n    print(mod_division_lambda(a, b))\n    print(mod_division_map(a, b))\n\n\nif __name__ == '__main__':\n    main()",
      -0.65234375
    ],
    [
      "def mod_division(lst1, lst2):\n    \"\"\"\n    :type lst1: List[int]\n    :type lst2: List[int]\n    :rtype: int\n    \"\"\"\n    map_func = lambda x, y: x % y\n    return reduce(lambda x, y: x * y % mod, map(map_func, lst1, lst2), 1)\n\n# Your ModDivision function should return the same output as the following.\n# def mod_division(lst1, lst2):\n#     return sum(map(lambda x, y: x % y, lst1, lst2)) % mod",
      -0.658203125
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division-ii/problem\n\ndef modDiv(first, second):\n    def modDivider(l):\n        for i in range(len(l)):\n            if l[i] == 0:\n                return i\n        return len(l)\n\n    first = [int(x) for x in first]\n    second = [int(x) for x in second]\n    res = []\n    for i in range(len(first)):\n        res.append(first[i] % second[i])\n    return res\n\nif __name__ == \"__main__\":\n    first = [int(x) for x in input().split()]\n    second = [int(x) for x in input().split()]\n    res = modDiv(first, second)\n    print(res)",
      -0.75048828125
    ],
    [
      "def modulo_division(lst1, lst2):\n    return [sum(map(lambda x: x % lst2[i], lst1[i])) for i in range(len(lst1))]\n\nif __name__ == \"__main__\":\n    lst1 = [2, 4, 3, 7, 10]\n    lst2 = [3, 5, 6, 1, 8]\n    result = modulo_division(lst1, lst2)\n    print(result)",
      -0.8251953125
    ],
    [
      "def mod_division(a, b):\n    \"\"\"\n    :param a: A list\n    :param b: A list\n    :return: A list\n    \"\"\"\n    return [x % y for x, y in zip(a, b)]\n\ndef mod_division_lambda(a, b):\n    \"\"\"\n    :param a: A list\n    :param b: A list\n    :return: A list\n    \"\"\"\n    return [lambda x: x % y for x, y in zip(a, b)]\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5]\n    b = [6, 7, 8, 9, 10]\n    print(mod_division(a, b))\n    print(mod_division_lambda(a, b))",
      -0.8525390625
    ],
    [
      "def modulo_division(first_list, second_list):\n    \"\"\"\n    :type first_list: List[int]\n    :type second_list: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return map(lambda x: x % (second_list[x]), first_list)",
      -0.85595703125
    ],
    [
      "def mod_division(lst1, lst2):\n    mod = 0\n    for i in lst1:\n        mod = mod + i % (lst2[i-1] % 100)\n    return mod\n\nif __name__ == \"__main__\":\n    lst1 = [2, 3, 5, 7, 11]\n    lst2 = [2, 3, 5, 7, 11]\n    print(mod_division(lst1, lst2))",
      -0.85693359375
    ],
    [
      "# https://www.hackerrank.com/challenges/modulo-division-2/problem\n\ndef modulo_division(x, y):\n    \"\"\"\n    :param x: A list of integers\n    :param y: A list of integers\n    :return: The modulo division of x and y\n    \"\"\"\n    result = 0\n    for i in range(0, len(x)):\n        result = (x[i] % y[i]) + result * (y[i] - x[i])\n    return result\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    print(modulo_division(x, y))",
      -0.85693359375
    ],
    [
      "def mod_division(l1, l2):\n    \"\"\"\n    :type l1: List[int]\n    :type l2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    m = map(lambda x: x % 10, l1)\n    return filter(lambda x: x!= 0, map(lambda x: x % 10, l2))",
      -0.85693359375
    ],
    [
      "from itertools import *\n\ndef find_mod(lst1, lst2):\n    lst1 = map(lambda x: x % lst2[0], lst1)\n    lst2 = map(lambda x: x % lst2[1], lst2)\n    return lst1, lst2\n\n\ndef test_case():\n    assert find_mod([3, 2, 1, 4], [7, 6, 5, 3]) == (1, [7, 3, 5])\n\n\nif __name__ == \"__main__\":\n    test_case()",
      -0.85693359375
    ],
    [
      "# Approach 1: Use map\ndef mod_division(a, b):\n    return map(lambda x: x % (b + 1), a)\n\n\n# Approach 2: Use lambda function\ndef mod_division(a, b):\n    return [x % (b + 1) for x in a]",
      -0.85693359375
    ],
    [
      "def mod_div(l1, l2):\n    def f(i):\n        return l1[i] % l2[i]\n    return [f(i) for i in range(len(l1))]",
      -0.85693359375
    ],
    [
      "def find_mod(a, b):\n    return a % b\n\ndef test():\n    assert find_mod([2, 3, 5], [5, 2, 4]) == 1\n    assert find_mod([1, 2, 4], [5, 3, 5]) == 2\n\nif __name__ == \"__main__\":\n    test()",
      -0.85693359375
    ],
    [
      "def mod_division(lst1, lst2):\n    \"\"\"\n    :type lst1: List[int]\n    :type lst2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    lst1 = map(lambda x: x % 10, lst1)\n    lst2 = map(lambda x: x % 10, lst2)\n    return list(map(lambda x: x % 10, lst1 + lst2))\n\nif __name__ == \"__main__\":\n    lst1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    lst2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(mod_division(lst1, lst2))",
      -0.85693359375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def modDivide(self, l1, l2):\n        if not l1 or not l2:\n            return 0\n        p = Map(lambda x: x % 10, l1)\n        q = Map(lambda x: x % 10, l2)\n        return sum(p[i] * q[i] for i in range(len(l1) + len(l2) - 1)) % 10\n\n\nclass Map:\n    def __init__(self, f, lst):\n        self.lst = lst\n        self.f = f\n        self.size = len(self.lst)\n\n    def __getitem__(self, i):\n        return self.f(self.lst[i])\n\n    def __iter__(self):\n        return iter(self.lst)\n\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\ndef Map(f, lst):\n    return Map(lambda x: f(x), lst)\n\n\ndef Sum(lst):\n    return sum(lst)\n\ndef Sum(lst):\n    return sum(lst)",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/modulo-division-of-two-lists\n\ndef modulo_division(lst1, lst2):\n    \"\"\"\n    Modulo division of two lists using map and lambda function.\n    Input:\n    lst1 = [1,2,3,4,5], lst2 = [2,3,4,5,6]\n    Output:\n    1\n    2\n    3\n    4\n    \"\"\"\n    lst1_copy = lst1[:]\n    lst2_copy = lst2[:]\n\n    lst1_copy.sort()\n    lst2_copy.sort()\n\n    for i in range(len(lst1)):\n        lst1[i] = lst1[i] % lst2_copy[i]\n\n    return lst1[0]\n\nif __name__ == \"__main__\":\n    lst1 = [1,2,3,4,5]\n    lst2 = [2,3,4,5,6]\n\n    print modulo_division(lst1, lst2)",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division-problem\n# https://www.hackerrank.com/challenges/modular-division-problem/submissions/code/300732\n# https://www.hackerrank.com/challenges/modular-division-problem/submissions/code/100913\n\ndef mod_division(x,y):\n    return x % y\n\nif __name__ == \"__main__\":\n    x = [i for i in range(1,100)]\n    y = [i for i in range(1,100)]\n    x.append(0)\n    y.append(0)\n    print(mod_division(x,y))",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division/problem\n\nimport math\n\n\ndef modular_division(lst1, lst2):\n    \"\"\"\n    :param lst1: List\n    :param lst2: List\n    :return: List\n    \"\"\"\n    return [math.fmod(i, j) for i, j in zip(lst1, lst2)]\n\n\nif __name__ == \"__main__\":\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [6, 7, 8, 9, 10]\n    print(modular_division(lst1, lst2))",
      -0.85791015625
    ],
    [
      "def find_modulo(lst1, lst2):\n    \"\"\"\n    :param lst1: List of integers\n    :param lst2: List of integers\n    :return: List of integers\n    \"\"\"\n    return [x % y for x, y in zip(lst1, lst2)]\n\ndef main():\n    print(find_modulo([2, 4, 6, 8], [1, 3, 5, 7]))\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "def find_modulo(l1, l2):\n\treturn sum(map(lambda x: x % l2, l1)) % l2\n\nif __name__ == '__main__':\n\tl1 = [1, 2, 3, 4]\n\tl2 = [2, 4, 6, 8]\n\tprint find_modulo(l1, l2)",
      -0.85791015625
    ],
    [
      "import random\n\ndef mod_division(lst1, lst2):\n    \"\"\"\n    Input: list 1 and list 2\n    Output: modulo division of list 1 and list 2\n    \"\"\"\n    mod = 0\n    for i in range(len(lst1)):\n        mod = mod + (lst1[i] * lst2[i]) % 10\n    return mod\n\ndef main():\n    #Test\n    lst1 = [1, 2, 3, 4]\n    lst2 = [5, 6, 7, 8]\n    print(mod_division(lst1, lst2))\n    print(mod_division(lst2, lst1))\n    print(mod_division([1, 2], [3, 4]))\n    print(mod_division([3, 4], [1, 2]))\n    print(mod_division([3, 4], [1, 2, 3]))\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "# Your function should return a list of lists.\n# Input:\n# [1, 2, 3, 4] and [5, 6, 7, 8]\n# Output: [[2, 4], [1, 2], [1, 2], [1, 2]]\n\ndef mod_division(lst1, lst2):\n    return map(lambda x, y: x % y, lst1, lst2)\n\n# your code here",
      -0.8583984375
    ],
    [
      "def mod_division(lst1, lst2):\n    return map(lambda x: x % lst2[0], lst1)\n\nif __name__ == '__main__':\n    lst1 = [2, 3, 5, 7]\n    lst2 = [2, 3, 5, 7, 11]\n    print mod_division(lst1, lst2)",
      -0.8583984375
    ],
    [
      "def mod_div(l1, l2):\n\treturn [x % y for x, y in zip(l1, l2)]\n\ndef test_mod_div():\n\tassert mod_div([1, 2, 3], [2, 4, 6]) == [1, 2, 1]\n\nif __name__ == \"__main__\":\n\ttest_mod_div()",
      -0.8583984375
    ],
    [
      "def mod_div(lst1, lst2):\n\t\"\"\"\n\t@param lst1 list of integers\n\t@param lst2 list of integers\n\t@return list of integers\n\t\"\"\"\n\t# map to get the modulo of each number\n\tmod_list = map(lambda x: x % lst2[0], lst1)\n\n\t# lambda function to get the modulo of each number\n\treturn reduce(lambda x, y: x + y, mod_list)\n\n\nif __name__ == '__main__':\n\tlst1 = [1, 2, 3]\n\tlst2 = [4, 5, 6]\n\tprint mod_div(lst1, lst2)",
      -0.8583984375
    ],
    [
      "def find_modulo_division(a, b):\n    \"\"\"\n    :type a: List[int]\n    :type b: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return map(lambda x: x % a[x], b)\n\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 4]\n    b = [1, 3, 5, 7]\n    print find_modulo_division(a, b)",
      -0.8583984375
    ],
    [
      "def mod(lst1, lst2):\n    return reduce(lambda x, y: x % y, map(lambda x: x % y, lst1) + map(lambda x: x % y, lst2))\n\ndef test_mod():\n    assert mod([1,2,3], [4,5,6]) == 1\n    assert mod([1,2,3], [4,5,7]) == 2\n    assert mod([1,2,3], [4,5,8]) == 3\n\nif __name__ == '__main__':\n    test_mod()",
      -0.85888671875
    ],
    [
      "def mod(a, b):\n    return a % b\n\ndef modulo_division(lst1, lst2):\n    mod_list = []\n    for i in range(0, len(lst1)):\n        mod_list.append(mod(lst1[i], lst2[i]))\n    return mod_list\n\ndef main():\n    lst1 = [1,2,3,4]\n    lst2 = [4,5,6,7]\n    print(modulo_division(lst1, lst2))\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "def mod_division(lst1, lst2):\n    return map(lambda x: x % 10, zip(lst1, lst2))\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4]\n    lst2 = [3, 4, 5, 6]\n    print(mod_division(lst1, lst2))",
      -0.85888671875
    ],
    [
      "def mod_div(lst1, lst2):\n    \"\"\"\n    >>> mod_div([1, 2, 3, 4, 5], [1, 2, 3])\n    [1, 2]\n    >>> mod_div([1, 2, 3, 4, 5], [1, 2, 3, 5])\n    [1, 2, 3, 5]\n    >>> mod_div([1, 2, 3, 4, 5], [1, 2, 3, 5, 7])\n    [1, 2, 3, 5]\n    \"\"\"\n    return list(map(lambda i, j: i % j, lst1, lst2))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.85888671875
    ],
    [
      "# https://www.hackerrank.com/challenges/mod-div-list/problem\n\ndef mod_div_list(arr1, arr2):\n    arr1 = list(map(lambda x: x % 10, arr1))\n    arr2 = list(map(lambda x: x % 10, arr2))\n\n    return [sum(arr1), sum(arr2)]\n\nif __name__ == \"__main__\":\n    arr1 = [10, 9, 2, 5, 3]\n    arr2 = [8, 7, 6, 4, 5]\n    arr1 = list(map(lambda x: x % 10, arr1))\n    arr2 = list(map(lambda x: x % 10, arr2))\n\n    print(mod_div_list(arr1, arr2))",
      -0.85888671875
    ],
    [
      "def mod_div(l1,l2):\n    #TODO: write your code here\n    return [map(lambda x: x % 10, l1), map(lambda x: x % 10, l2)]\n\nif __name__ == '__main__':\n    l1 = [1,2,3,4,5]\n    l2 = [6,7,8,9,10]\n    print mod_div(l1,l2)",
      -0.9208984375
    ],
    [
      "def mod_div(l1, l2):\n    \"\"\"\n    Args:\n        l1 (list): list 1\n        l2 (list): list 2\n\n    Returns:\n        list: list of modulo division of l1 and l2\n    \"\"\"\n    return [lambda x: x % l2[i] for i, x in enumerate(l1)]\n\nif __name__ == \"__main__\":\n    assert mod_div([2, 4, 6, 8], [3, 2, 4, 3]) == [lambda x: x % 3, lambda x: x % 2, lambda x: x % 4, lambda x: x % 3]\n    assert mod_div([2, 4, 6, 8], [3, 2, 4, 3, 5]) == [lambda x: x % 3, lambda x: x % 2, lambda x: x % 4, lambda x: x % 3, lambda x: x % 5]\n    assert mod_div([2, 4, 6, 8], [3, 2, 4, 3, 5, 7]) == [lambda x: x % 3, lambda x: x % 2, lambda x: x % 4, lambda x: x % 3, lambda x: x % 5, lambda x: x % 7]",
      -0.9375
    ],
    [
      "# https://www.geeksforgeeks.org/modular-division-in-python/\n\ndef mod_division(lst1, lst2):\n    m = max(len(lst1), len(lst2))\n    ret = [0] * (m + 1)\n    for i in range(m):\n        for j in range(m):\n            ret[i + j] = (lst1[i] * lst2[j]) % m\n    return ret\n\n\ndef main():\n    lst1 = [1, 3, 7]\n    lst2 = [2, 4, 5]\n    result = mod_division(lst1, lst2)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()",
      -1.1201171875
    ],
    [
      "# +++your code here+++\n# Write tests with different inputs\n\ndef mod_div_list(l1, l2):\n    return [i % j for i, j in zip(l1, l2)]\n\ndef mod_div_list_lambda(l1, l2):\n    return [lambda i, j: i % j for i, j in zip(l1, l2)]\n\nif __name__ == '__main__':\n    assert(mod_div_list([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 1, 2, 3])\n    assert(mod_div_list_lambda([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 1, 2, 3])",
      -1.47265625
    ],
    [
      "def mod(x, y):\n    return x % y\n\n\ndef mod_lambda(x, y):\n    return lambda x: x % y\n\n\ndef main():\n    print(mod([1, 2, 3], [4, 5, 6]))\n    print(mod([1, 2, 3], [4, 5, 6], lambda x: x + 1))\n\n\nif __name__ == '__main__':\n    main()",
      -1.9423828125
    ],
    [
      "from collections import defaultdict\n\n\ndef find_mod(arr1, arr2):\n    \"\"\"\n    Given two lists arr1 and arr2, find the modulo of arr1 and arr2.\n    :param arr1:\n    :param arr2:\n    :return:\n    \"\"\"\n    result = defaultdict(int)\n    for i in range(len(arr1)):\n        result[arr1[i]] += 1\n    for i in range(len(arr2)):\n        result[arr2[i]] -= 1\n    return list(result.items())\n\n\nif __name__ == '__main__':\n    arr1 = [1, 2, 3, 4, 5]\n    arr2 = [2, 3, 4, 5, 6]\n    result = find_mod(arr1, arr2)\n    print result",
      -2.0859375
    ],
    [
      "# https://www.hackerrank.com/challenges/mod-division-by-two-lists/problem\n\ndef mod_div(l1, l2):\n    \"\"\"\n    Modulo division of two lists.\n    :param l1: List\n    :param l2: List\n    :return: Modulo division of two lists.\n    \"\"\"\n\n    # Calculate the modulo of each element\n    m1 = lambda x: x % l1[i]\n    m2 = lambda x: x % l2[i]\n\n    # Calculate the modulo of the sum of elements\n    total = 0\n    for i in range(len(l1)):\n        total = total + m1(l1[i]) + m2(l2[i])\n    return total % l1[i]\n\nif __name__ == '__main__':\n    l1 = [2, 3, 5, 7]\n    l2 = [3, 4, 6, 8]\n\n    print(mod_div(l1, l2))",
      -2.16796875
    ],
    [
      "def mod_div(lst1, lst2):\n    \"\"\"\n    lst1 and lst2 are lists of integers\n    \"\"\"\n    result = 0\n    for x in lst1:\n        result = (result + lst2[0]) % x\n        lst2 = lst2[1:]\n    return result\n\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [2, 3, 4, 5]\n    print(mod_div(lst1, lst2))\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [6, 7, 8, 9, 10]\n    print(mod_div(lst1, lst2))",
      -2.169921875
    ],
    [
      "# https://www.hackerrank.com/challenges/modulo-division-lambda-function\n\ndef modDiv(l1, l2):\n    n1 = len(l1)\n    n2 = len(l2)\n    result = [0] * (n1 + n2)\n    for i in range(n1):\n        for j in range(n2):\n            result[i + j] += l1[i] * l2[j]\n    return result\n\ndef modDiv_recursive(l1, l2):\n    if len(l1) == 0:\n        return l2\n    if len(l2) == 0:\n        return l1\n    if l1[-1] % l2[-1] == 0:\n        return modDiv_recursive(l1[:-1], l2[:-1]) + l1[-1:0:-1]\n    return modDiv_recursive(l1[:-1], l2) + l1[-1:0:-1]\n\nif __name__ == \"__main__\":\n    l1 = [3, 8, 2, 9]\n    l2 = [3, 4, 2, 1]\n    result = modDiv(l1, l2)\n    print(result)",
      -2.298828125
    ],
    [
      "def mod_div(l1, l2):\n    return list(map(lambda x: x % l1, l2))\n\nif __name__ == '__main__':\n    assert mod_div([1, 2, 3], [4, 5, 6]) == [1, 2, 1]\n    assert mod_div([1, 2, 3], [1, 2, 3]) == [0, 1, 0]\n    assert mod_div([1, 2, 3], [1, 2, 3, 4]) == [0, 1, 1, 0]",
      -2.31640625
    ],
    [
      "def mod_division(l1, l2):\n    m1 = map(lambda x: x % 10, l1)\n    m2 = map(lambda x: x % 10, l2)\n    return reduce(lambda x, y: x*10 + y, m1) % 10\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4, 5]\n    l2 = [6, 7, 8, 9]\n    print mod_division(l1, l2)",
      -2.62890625
    ],
    [
      "# https://www.hackerrank.com/challenges/mod-div-two-lists/problem\n\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul Div\n\n# Modul Div\n# map()\n# lambda function\n# Modul",
      -2.677734375
    ],
    [
      "from functools import reduce\n\ndef mod_divide(lst1, lst2):\n    return reduce(lambda x,y: x * y % 10, lst1, lst2)\n\nif __name__ == '__main__':\n    lst1 = [1,2,3,4]\n    lst2 = [2,3]\n    print(mod_divide(lst1, lst2))",
      -2.833984375
    ],
    [
      "def mod_div(a, b):\n    \"\"\"\n    :type a: List[int]\n    :type b: List[int]\n    :rtype: List[int]\n    \"\"\"\n    def f(x, y):\n        return x % y\n\n    return reduce(f, map(f, a, b))\n\n\ndef mod_div2(a, b):\n    \"\"\"\n    :type a: List[int]\n    :type b: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return reduce(lambda x, y: x % y, a, b)\n\n\nif __name__ == '__main__':\n    print mod_div([2, 3, 5, 7], [3, 2, 4])\n    print mod_div2([2, 3, 5, 7], [3, 2, 4])",
      -2.84765625
    ],
    [
      "from collections import namedtuple\n\ndef modulo_div(l1, l2):\n    \"\"\"\n    :param l1: List\n    :param l2: List\n    :return: List\n    \"\"\"\n    return map(lambda x: x % len(l1), l1) + map(lambda x: x % len(l2), l2)\n\nif __name__ == \"__main__\":\n    l1 = [1, 2, 3, 4]\n    l2 = [5, 6, 7, 8]\n    print(modulo_div(l1, l2))",
      -2.92578125
    ],
    [
      "import collections\n\n# Your code here\n\ndef mod_div(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div2(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div3(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div4(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div5(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div6(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div7(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div8(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div9(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div10(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div11(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div12(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div13(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div14(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div15(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div16(a, b):\n    return [i % x for i, x in zip(a, b)]\n\ndef mod_div17(a, b):\n    return map(lambda x: a % x, b)\n\ndef mod_div18(a, b):\n    return [i % x for i, x in zip(a, b)]",
      -3.044921875
    ],
    [
      "import unittest\n\ndef mod(l1, l2):\n    '''\n    Modulo division of two lists\n    '''\n    return sum([a for a in l1 if a % l2[i] == 0])\n\nclass TestMod(unittest.TestCase):\n    def test_mod(self):\n        self.assertEqual(mod([1, 2, 3], [4, 4, 4]), 0)\n        self.assertEqual(mod([1, 2, 3], [4, 5, 6]), 2)\n        self.assertEqual(mod([4, 5, 6], [1, 2, 3]), 2)\n        self.assertEqual(mod([4, 5, 6], [7, 8, 9]), 0)\n        self.assertEqual(mod([4, 5, 6], [7, 8, 9, 10]), 2)\n        self.assertEqual(mod([7, 8, 9], [4, 5, 6]), 2)\n        self.assertEqual(mod([7, 8, 9], [4, 5, 6, 7]), 2)\n\nif __name__ == '__main__':\n    unittest.main()",
      -3.12109375
    ],
    [
      "# Write your code below.\n#\n# Sample Inputs:\n# [[1,2,3],[4,5,6]]\n# [[1,2,3],[4,5,6]]\n# Sample Outputs:\n# [[2,4],[2,3]]\n# [[1,2],[1,2]]\n\ndef modulo_div(l1, l2):\n    \"\"\"\n    Modulo division using map and lambda function.\n    :param l1: List of integers\n    :param l2: List of integers\n    :return: List of integers\n    \"\"\"\n    return [map(lambda x: x % l2[i], l1[i]) for i in range(len(l1))]\n\nif __name__ == '__main__':\n    l1 = [[1, 2, 3], [4, 5, 6]]\n    l2 = [[1, 2, 3], [4, 5, 6]]\n    print(modulo_div(l1, l2))",
      -3.3828125
    ],
    [
      "# https://www.geeksforgeeks.org/modular-division-in-python/\ndef mod_div(lst1, lst2):\n    # if lst1 is empty then return lst2\n    if len(lst1) == 0:\n        return lst2\n    # if lst2 is empty then return lst1\n    if len(lst2) == 0:\n        return lst1\n    # if lst1 is a subset of lst2 then return lst2\n    if lst1[:len(lst2)] == lst2:\n        return lst2\n    # if lst2 is a subset of lst1 then return lst1\n    if lst2[:len(lst1)] == lst1:\n        return lst1\n    # if lst1 is a subset of lst2 then return lst2\n    if lst1[:len(lst2)] == lst2:\n        return lst2\n    # if lst2 is a subset of lst1 then return lst1\n    if lst2[:len(lst1)] == lst1:\n        return lst1\n    # else find out the modulo of lst1 and lst2 and return\n    # lst1 = lst1[:len(lst2)]\n    # lst2 = lst2[:len(lst1)]\n    # mod = lst1[0] * 10 + lst2[0]\n    # for i in range(1, len(lst1)):\n    #     mod = mod % 10\n    #     mod = mod * 10 + lst1[i]\n    #     mod = mod % 10\n    #     mod = mod * 10 + lst2[i]\n    # return [mod]\n    return [i % j for i, j in zip(lst1, lst2)]\n\n\n# Test cases\nlst1 = [1, 3, 5]\nlst2 = [2, 4, 6]\nprint(mod_div(lst1, lst2))\nlst1 = [1, 2, 3, 4]\nlst2 = [2",
      -3.48046875
    ],
    [
      "def mod(a, b):\n    return a % b\n\n\ndef mod_list(lst):\n    return [mod(x, len(lst)) for x in lst]\n\n\ndef mod_list_lambda(lst):\n    return [lambda x: mod(x, len(lst)) for x in lst]\n\n\nif __name__ == \"__main__\":\n    assert mod_list([0, 1, 2, 3]) == [0, 1, 2, 3]\n    assert mod_list_lambda([0, 1, 2, 3]) == [0, 1, 2, 3]\n\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list_lambda([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert mod_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert mod_list_lambda([1,",
      -3.85546875
    ],
    [
      "#!/bin/python\n\ndef mod(a, b):\n    return a % b\n\ndef mod_lambda(a, b):\n    return lambda x: x % b\n\ndef mod_map(a, b):\n    return list(map(lambda x: x % b, a))\n\ndef mod_lambda_map(a, b):\n    return list(map(lambda x: x % b, a))\n\nif __name__ == \"__main__\":\n    test_list = [3, 1, 4, 5]\n    test_list_lambda = [3, 1, 4, 5]\n    test_list_lambda_map = [3, 1, 4, 5]\n    test_list_lambda_map = [3, 1, 4, 5]\n    print(mod(test_list, test_list_lambda))\n    print(mod_lambda(test_list, test_list_lambda))\n    print(mod_map(test_list, test_list_lambda))\n    print(mod_lambda_map(test_list, test_list_lambda))",
      -3.919921875
    ],
    [
      "# Your code here!\ndef mod_div(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda2(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda3(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda4(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda5(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda6(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda7(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda8(a, b):\n\t\"\"\"\n\ta: list\n\tb: list\n\treturn: list\n\t\"\"\"\n\treturn [lambda x: x % y for x, y in zip(a, b)]\n\ndef mod_div_lambda9(",
      -4.23046875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getMod(self, mod, x, y):\n        if x == 0:\n            return y % mod\n        if y == 0:\n            return x % mod\n        return self.getMod(mod, x, y % mod) + self.getMod(mod, y, x % mod)\n\n    def modDiv(self, l1, l2):\n        if len(l1)!= len(l2):\n            return None\n        mod = len(l1)\n        res = [0 for i in range(mod)]\n        for i in range(mod):\n            res[i] = self.getMod(mod, l1[i], l2[i])\n        return res\n\n\nif __name__ == \"__main__\":\n    l1 = ListNode(1)\n    l1.next = ListNode(2)\n    l1.next.next = ListNode(3)\n    l2 = ListNode(1)\n    l2.next = ListNode(2)\n    l2.next.next = ListNode(3)\n    l2.next.next.next = ListNode(4)\n    l2.next.next.next.next = ListNode(5)\n    l2.next.next.next.next.next = ListNode(6)\n\n    sol = Solution()\n    print(sol.modDiv(l1, l2))",
      -4.35546875
    ],
    [
      "# map and lambda\n# https://stackoverflow.com/questions/377986/how-can-you-use-lambda-to-create-a-function-that-takes-a-list-and-returns-an-integer\n# https://stackoverflow.com/questions/20351494/lambda-function-that-takes-a-list-and-returns-an-integer\n# https://stackoverflow.com/questions/26453071/how-can-you-use-lambda-to-create-a-function-that-takes-a-list-and-returns-an-integer\n# https://stackoverflow.com/questions/33881269/why-does-lambda-not-work-with-a-list-of-integers\n# https://stackoverflow.com/questions/33881269/why-does-lambda-not-work-with-a-list-of-integers\n\n# map\n# list of integers\ndef mod_list(list_of_integers):\n    list_of_integers = list(list_of_integers)\n    return reduce(lambda x, y: x % y, list_of_integers)\n\n# lambda\n# list of integers\ndef mod_list_lambda(list_of_integers):\n    return reduce(lambda x, y: x % y, list_of_integers)\n\n# list of integers\ndef mod_list_lambda_2(list_of_integers):\n    return list_of_integers[0] % list_of_integers[1]\n\n# list of integers\ndef mod_list_lambda_3(list_of_integers):\n    return reduce(lambda x, y: x % y, list_of_integers)\n\n\n# list of integers\ndef mod_list_lambda_4(list_of_integers):\n    return list_of_integers[0] % list_of_integers[1] % list_of_integers[2] % list_of_integers[3] % list_of_integers[4]\n\n# list of integers\ndef mod_list_lambda_5(list",
      -4.46875
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-division-1\n\ndef modular_division(lst1, lst2):\n    return [i % (lst2[i] * lst1[i]) for i in range(len(lst1))]\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [2, 3, 4, 5, 6]\n    print(modular_division(lst1, lst2))",
      -4.64453125
    ],
    [
      "# Write a function that takes two lists of integers and returns the list of integers\n# in which the integers are interleaved.\n\n# Note:\n# For example, the list [1,2,3] is interleaved with [2,3,1] -> [1,2,3,1,2,3].\n\n# Example:\n# input: [1,2,3,4], [3,4,5,6]\n# output: [1,3,2,4,5,6]\n\n# Example:\n# input: [1,2,3], [4,5,6]\n# output: [1,4,2,5,3,6]\n\ndef interleave(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return [nums1[i] for i in range(0, len(nums1) + len(nums2) - 1, len(nums1))]\n\n\nif __name__ == '__main__':\n    nums1 = [1, 2, 3, 4]\n    nums2 = [3, 4, 5, 6]\n    print interleave(nums1, nums2)\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    print interleave(nums1, nums2)",
      -4.69140625
    ],
    [
      "# I/O\n\n# Test Cases\n\ndef test_modulo_division():\n    assert (modulo_division([1,2,3], [4,5,6]) == [1,2,1])\n    assert (modulo_division([1,2,3], [4,5,6], lambda x,y: x % y) == [1,2,1])\n    assert (modulo_division([1,2,3], [4,5,6], lambda x,y: x % y, lambda x,y: x % y) == [1,2,1])\n    assert (modulo_division([1,2,3], [4,5,6], lambda x,y: x % y, lambda x,y: x % y, lambda x,y: x % y) == [1,2,1])\n\n# Your Code\n\ndef modulo_division(lst1, lst2, f1, f2):\n    return map(lambda x,y: f1(x,y), lst1, lst2)",
      -4.7734375
    ],
    [
      "from collections import defaultdict\nfrom functools import reduce\nfrom itertools import combinations\n\ndef mod_division(list1, list2):\n    return map(lambda x: reduce(lambda a, b: a % b, x), list2)\n\nif __name__ == \"__main__\":\n    list1 = [1, 2, 3, 4, 5, 6]\n    list2 = [7, 8, 9]\n\n    print(mod_division(list1, list2))",
      -4.91015625
    ],
    [
      "def mod_div(l1, l2):\n    return map(lambda x: x % l2, l1)\n\ndef mod_div_test():\n    l1 = [1, 2, 3, 4, 5, 6, 7]\n    l2 = [2, 4, 6, 8, 10, 12, 14]\n    l3 = mod_div(l1, l2)\n    assert l3 == [1, 3, 5, 7, 9, 11, 13]\n\nif __name__ == \"__main__\":\n    mod_div_test()",
      -5.26953125
    ],
    [
      "def mod_division(x, y):\n    return [i % (x[i] - y[i]) for i in range(len(x))]\n\ndef mod_division_lambda(x, y):\n    return [lambda i: i % (x[i] - y[i]) for i in range(len(x))]\n\ndef mod_division_map(x, y):\n    return map(lambda i: i % (x[i] - y[i]), range(len(x)))\n\ndef mod_division_lambda_map(x, y):\n    return map(lambda i: lambda i: i % (x[i] - y[i]), range(len(x)))\n\ndef test():\n    assert(mod_division(range(5), range(3, 7)) == [0, 2, 1])\n    assert(mod_division_lambda(range(5), range(3, 7)) == [0, 2, 1])\n    assert(mod_division_map(range(5), range(3, 7)) == [0, 2, 1])\n    assert(mod_division_lambda_map(range(5), range(3, 7)) == [0, 2, 1])\n\nif __name__ == '__main__':\n    test()",
      -5.34765625
    ],
    [
      "# Modulo division\ndef modulo_division(a, b):\n    def modulo(x, y):\n        return (x % y) if x % y < 0 else (x % y + y)\n    return [modulo(a[i], b[i]) for i in range(len(a))]\n\n# Modulo division using lambda\ndef modulo_division_lambda(a, b):\n    return [lambda x, y: (x % y) if x % y < 0 else (x % y + y) for x, y in zip(a, b)]\n\n# Modulo division using map\ndef modulo_division_map(a, b):\n    return [map(lambda x: x % y, a, b) for y in range(1, 10)]\n\n# Modulo division using reduce\ndef modulo_division_reduce(a, b):\n    return reduce(lambda x, y: x % y, a, b)\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 4]\n    b = [2, 4, 6, 8]\n    print(modulo_division(a, b))\n    print(modulo_division_lambda(a, b))\n    print(modulo_division_map(a, b))\n    print(modulo_division_reduce(a, b))",
      -5.48828125
    ],
    [
      "# Your function should return a list of lists.\n\n# Example 1:\n# Input: [[1,2,3], [4,5,6], [7,8,9]]\n# Output: [[1,1,1], [1,1,1], [1,1,1]]\n# Explanation:\n# The first list [1,1,1] is obtained by adding together the elements of the second list (as a lambda function)\n# and the first list (which is [1,1,1])\n# The second list [1,1,1] is obtained by adding together the elements of the first list (as a lambda function)\n# and the first list (which is [1,1,1])\n# The third list [1,1,1] is obtained by adding together the elements of the first list (as a lambda function)\n# and the second list (which is [1,1,1])\n\n# Example 2:\n# Input: [[1,2,3], [4,5,6], [7,8,9]]\n# Output: [[3,2,1], [6,5,4], [9,8,7]]\n# Explanation:\n# The first list [3,2,1] is obtained by adding together the elements of the second list (as a lambda function)\n# and the first list (which is [3,2,1])\n# The second list [6,5,4] is obtained by adding together the elements of the first list (as a lambda function)\n# and the first list (which is [3,2,1])\n# The third list [9,8,7] is obtained by adding together the elements of the first list (as a lambda function)\n# and the second list (which is [6,5,4])\n\n# Note:\n# The size of the input lists won't exceed 100.\n\n# Follow up:\n# What if the given list is already sorted? How would you optimize your algorithm?\n\n# Related problem:\n# https://leetcode.com/problems/number-of-1s-in-binary-search-tree/\n# https://leetcode.com/problems/number-of-1s-in-binary-search-tree-ii/\n# https",
      -5.671875
    ],
    [
      "#!/usr/bin/env python\n\ndef mod_division(a, b):\n    return map(lambda x: (x % a), b)\n\ndef test_mod_division():\n    assert mod_division([1, 2, 3, 4, 5], [6, 7, 8, 9]) == [1, 2, 1, 2, 1]\n    assert mod_division([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == [1, 2, 1, 2, 1]\n    assert mod_division([1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]) == [1, 2, 1, 2, 1]\n\nif __name__ == \"__main__\":\n    test_mod_division()",
      -5.84765625
    ],
    [
      "import sys\n\ndef mod_div(list1, list2):\n    \"\"\"\n    Find modulo division of two lists.\n\n    :param list1: First list.\n    :param list2: Second list.\n    :return: The modulo of the two lists.\n    \"\"\"\n    return sum(map(lambda x: x % list1[i], list2)) % list1[-1]\n\nif __name__ == '__main__':\n    list1 = [2, 3, 4, 5, 6, 7]\n    list2 = [1, 2, 3, 4, 5, 6]\n    print(mod_div(list1, list2))",
      -6.07421875
    ],
    [
      "# https://www.hackerrank.com/challenges/quicksort2/problem\n\nimport time\nstart_time = time.time()\n\ndef quicksort(a, l, r):\n    if l < r:\n        m = (l+r)//2\n        quicksort(a, l, m)\n        quicksort(a, m+1, r)\n        for i in range(l, r+1):\n            a[i] = a[m+1+i]\n\ndef mod(a, b, c):\n    return ((a % b) + b) % c\n\ndef map_lambda(a, b):\n    return [a[i] for i in range(len(a)) if a[i] <= b]\n\na = [1,2,3,4,5,6,7,8,9]\nl = len(a)\n\nprint(\"Sorted list:\", map_lambda(a, l))\nprint(\"Mod:\", mod(a, l, 10))\n\nquicksort(a, 0, l-1)\nprint(\"Sorted list:\", map_lambda(a, l))\nprint(\"Mod:\", mod(a, l, 10))\n\nprint(\"Time elapsed:\", time.time() - start_time)",
      -6.57421875
    ],
    [
      "import random\n\ndef mod_div(lst1, lst2):\n    mod = 1\n    for i in range(len(lst1)):\n        mod = (lst1[i] % mod + mod) % mod\n        if mod == 0:\n            return 0\n    for i in range(len(lst2)):\n        if lst2[i] % mod == 0:\n            return 0\n    return 1\n\nprint(mod_div([1, 2, 3, 4], [5, 6]))\nprint(mod_div([1, 2, 3], [5, 6]))\nprint(mod_div([1, 2, 3], [5, 6, 7]))\nprint(mod_div([1, 2, 3, 4, 5], [6, 7]))\nprint(mod_div([1, 2, 3, 4, 5, 6], [7, 8]))\n\nprint(mod_div([1, 2, 3, 4, 5], [6, 7, 8]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6], [7, 8, 9]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14]))\n\nprint(mod_div([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14, 15]))\n\nprint(mod_div([",
      -6.79296875
    ],
    [
      "import collections\n\n# Returns the modulo of two numbers\ndef mod_division(a, b):\n    return a % b\n\ndef main():\n    # Test case 1\n    a = [1, 2, 3, 4]\n    b = [2, 3, 4, 5]\n    print(mod_division(a, b))\n\n    # Test case 2\n    a = [1, 2, 3, 4]\n    b = [2, 3, 4, 5, 6]\n    print(mod_division(a, b))\n\n    # Test case 3\n    a = [1, 2, 3, 4]\n    b = [1, 2, 3, 4, 5]\n    print(mod_division(a, b))\n\n    # Test case 4\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\n    print(mod_division(a, b))\n\n    # Test case 5\n    a = [1, 2, 3, 4, 5]\n    b = [1, 2, 3, 4, 5, 6]\n    print(mod_division(a, b))\n\n    # Test case 6\n    a = [1, 2, 3, 4, 5, 6]\n    b = [2, 3, 4, 5, 6]\n    print(mod_division(a, b))\n\n    # Test case 7\n    a = [1, 2, 3, 4, 5, 6]\n    b = [2, 3, 4, 5, 6, 7]\n    print(mod_division(a, b))\n\n    # Test case 8\n    a = [1, 2, 3, 4, 5, 6]\n    b = [1, 2, 3, 4, 5, 6, 7]\n    print(mod_division(a, b))\n\n    # Test case 9\n    a = [1, 2, 3, 4, 5, 6]\n    b = [1, 2, 3, 4, 5, 6, 7]\n    print(mod_division(a, b))\n\n    # Test case 10\n    a = [1, 2, 3, 4, 5, 6]\n    b = [1, 2, 3,",
      -7.16796875
    ],
    [
      "def mod(a, b):\n    return a % b\n\n\ndef mod_lambda(a, b):\n    return lambda x: a % x(b)\n\n\ndef mod_map(a, b):\n    return lambda x: a % x(b)\n\n\ndef mod_lambda_map(a, b):\n    return lambda x: a % x(b)\n\n\ndef mod_map_lambda(a, b):\n    return lambda x: a % x(b)\n\n\ndef mod_lambda_map_lambda(a, b):\n    return lambda x: a % x(b)\n\n\nif __name__ == \"__main__\":\n    print(mod([1, 2, 3], [4, 5, 6]))\n    print(mod_lambda([1, 2, 3], [4, 5, 6]))\n    print(mod_map(1, [4, 5, 6]))\n    print(mod_lambda_map(1, [4, 5, 6]))\n    print(mod_map_lambda(1, [4, 5, 6]))\n    print(mod_lambda_map_lambda(1, [4, 5, 6]))",
      -7.6171875
    ],
    [
      "def mod_div(l1, l2):\n    return list(map(lambda x: x % (l2[x] % l1[x]), range(len(l1))))\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4]\n    l2 = [5, 6, 7]\n\n    print(mod_div(l1, l2))",
      -8.3671875
    ],
    [
      "def mod(x, y):\n    return x % y\n\ndef mod_lambda(x, y):\n    return lambda i, j: x[i] % y[j]\n\n\ndef mod_map(x, y):\n    return map(lambda i, j: x[i] % y[j], xrange(len(x)), yrange(len(y)))\n\n\nif __name__ == '__main__':\n    test_cases = [\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4], [5, 6, 7, 8] ],\n        [ [1, 2, 3, 4",
      -9.40625
    ],
    [
      "import random\n\ndef mod_div(lst1, lst2):\n    \"\"\"\n    >>> mod_div([1,2,3,4], [1,2,3,5])\n    [0, 1, 0, 1]\n    >>> mod_div([1,2,3,4], [5,6,7,8])\n    [0, 1, 0, 1]\n    >>> mod_div([1,2,3,4], [1,2,3,4])\n    [0, 0, 0, 1]\n    >>> mod_div([1,2,3,4], [1,2,3,5])\n    [0, 1, 0, 1]\n    >>> mod_div([1,2,3,4], [5,6,7,8])\n    [0, 1, 0, 1]\n    \"\"\"\n    lst1 = list(map(lambda x: x % (lst2[x]), lst1))\n    lst2 = list(map(lambda x: x % (lst1[x]), lst2))\n    return lst1, lst2\n\ndef main():\n    lst1 = [random.randint(0, 100) for i in range(10)]\n    lst2 = [random.randint(0, 100) for i in range(10)]\n    print(mod_div(lst1, lst2))\n\nif __name__ == '__main__':\n    main()",
      -12.0625
    ],
    [
      "def mod(a, b):\n    return a % b\n\ndef mod_lambda(a, b):\n    return lambda x: x % b\n\ndef mod_map(a, b):\n    return map(lambda x: x % b, a)\n\ndef mod_lambda_map(a, b):\n    return map(lambda x: lambda y: x % y, a)\n\ndef mod_lambda_map_2(a, b):\n    return map(lambda x: lambda y: lambda z: x % y % z, a)\n\ndef mod_lambda_map_3(a, b):\n    return map(lambda x, y, z: lambda w: lambda u: lambda v: x % y % z % w % v, a, b, c)\n\ndef mod_lambda_map_4(a, b):\n    return map(lambda x, y, z, w: lambda u: lambda v: lambda t: lambda s: lambda p: lambda q: lambda r: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i: lambda h: lambda g: lambda f: lambda e: lambda d: lambda c: lambda b: lambda a: lambda o: lambda n: lambda m: lambda l: lambda k: lambda j: lambda i",
      -12.96875
    ],
    [
      "# https://www.hackerrank.com/challenges/modulo-division-with-lambda\n\ndef mod_div(lst1, lst2):\n    if len(lst1)!= len(lst2):\n        raise ValueError(\"Lists are of different length\")\n    result = [0] * (len(lst1) + 1)\n    for i in range(len(lst1)):\n        result[i + 1] = result[i] + (lst2[i] - lst1[i]) % (lst1[i] + 1)\n    return result\n\nif __name__ == \"__main__\":\n    lst1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    lst2 = [2, 4, 6, 8, 10, 12, 14, 16, 18]\n    print(mod_div(lst1, lst2))",
      -13.1015625
    ],
    [
      "import random\n\ndef modulo_division(l1, l2):\n    # list of integers, l1 and l2\n    l1 = list(map(int, l1))\n    l2 = list(map(int, l2))\n    # list of integers, result\n    result = []\n    # sum of the elements in l1\n    sum1 = sum(l1)\n    # sum of the elements in l2\n    sum2 = sum(l2)\n    # list of integers, remainder\n    remainder = []\n    # iterate through l1\n    for i in l1:\n        # if sum1 is divisible by sum2 then\n        # add to result\n        if sum1 % sum2 == 0:\n            result.append(i)\n            sum1 = sum1 / sum2\n        else:\n            remainder.append(i)\n    # iterate through remainder\n    for i in remainder:\n        # if sum1 is divisible by sum2 then\n        # add to result\n        if sum1 % sum2 == 0:\n            result.append(i)\n            sum1 = sum1 / sum2\n    return result\n\n\nif __name__ == '__main__':\n    l1 = [1, 2, 3, 4, 5]\n    l2 = [3, 4, 5, 6, 7]\n    l3 = modulo_division(l1, l2)\n    print(l3)",
      -13.375
    ],
    [
      "from collections import defaultdict\n\ndef modulo_division(lst1, lst2):\n    \"\"\"\n    Input:\n    lst1: list of integers\n    lst2: list of integers\n\n    Output:\n    A list of integers\n    \"\"\"\n    return [lambda x, y: x % y for x, y in zip(lst1, lst2)]\n\n\ndef modulo_division_lambda(lst1, lst2):\n    \"\"\"\n    Input:\n    lst1: list of integers\n    lst2: list of integers\n\n    Output:\n    A list of integers\n    \"\"\"\n    return [lambda x, y: x % y for x, y in zip(lst1, lst2)]\n\n\ndef modulo_division_map(lst1, lst2):\n    \"\"\"\n    Input:\n    lst1: list of integers\n    lst2: list of integers\n\n    Output:\n    A list of integers\n    \"\"\"\n    result = defaultdict(int)\n    for i, j in zip(lst1, lst2):\n        result[i % j] += 1\n    return [result[i] for i in lst1]\n\n\ndef modulo_division_map_lambda(lst1, lst2):\n    \"\"\"\n    Input:\n    lst1: list of integers\n    lst2: list of integers\n\n    Output:\n    A list of integers\n    \"\"\"\n    result = defaultdict(int)\n    for i, j in zip(lst1, lst2):\n        result[i % j] += 1\n    return [result[i] for i in lst1]\n\n\nif __name__ == '__main__':\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [6, 7, 8, 9, 10]\n    result = modulo_division(lst1, lst2)\n    print(result)\n    print(result == [1, 2, 3, 6, 5])\n\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [6, 7, 8, 9, 10]\n    result = modulo_",
      -13.5546875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def __init__(self):\n        self.res = None\n\n    def getMod(self, mod, l, r):\n        if l == r:\n            return l\n        return self.getMod(mod, l, (l + r) / 2) + (r - l + 1) * (r - l + 1) % mod\n\n    def getModDiv(self, l, r):\n        mod = 1\n        while l % mod == 0 and r % mod == 0:\n            mod = self.getMod(mod, l, r)\n        return mod\n\n    def getModDiv2(self, l, r):\n        mod = 1\n        while l % mod == 0 and r % mod == 0:\n            mod = self.getMod(mod, l, r)\n        return l % mod\n\n    def divide(self, l, r):\n        if l == r:\n            return l\n        if l > r:\n            return self.divide(r, l)\n        if l == 0 or r == 0:\n            return 0\n        if l % r == 0:\n            return self.getModDiv(l, r)\n        return self.getModDiv2(l, r)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    l = ListNode(1)\n    r = ListNode(3)\n    l.next = r\n    print(sol.divide(l, r))\n    l = ListNode(2)\n    r = ListNode(3)\n    l.next = r\n    print(sol.divide(l, r))\n    l = ListNode(3)\n    r = ListNode(1)\n    l.next = r\n    print(sol.divide(l, r))\n    l = ListNode(1)\n    r = ListNode(3)\n    l.next = r\n    print(sol.divide(l, r))\n    l = ListNode(1)\n    r = ListNode",
      -13.8828125
    ],
    [
      "import sys\nimport collections\n\ndef mod_div(lst1, lst2):\n    \"\"\"\n    Modular division.\n\n    Input:\n        lst1: List of integers\n        lst2: List of integers\n    Output:\n        List of integers\n    \"\"\"\n\n    # convert to list of tuples\n    lst1 = collections.defaultdict(list)\n    lst2 = collections.defaultdict(list)\n    for i, v in enumerate(lst1):\n        lst1[v].append(i)\n    for i, v in enumerate(lst2):\n        lst2[v].append(i)\n\n    # build the dictionary\n    d = collections.defaultdict(list)\n    for i, v in enumerate(lst1):\n        d[v].append(i)\n\n    # find the divisor\n    res = []\n    for i, v in enumerate(lst2):\n        div = 1\n        for j, w in enumerate(v):\n            div *= d[w][-1]\n        res.append(div)\n\n    # find the modulo\n    res.sort()\n    res = [res[i] % len(lst1) for i in range(len(res))]\n\n    return res\n\n\nif __name__ == '__main__':\n    # sample input\n    # [1, 2, 3, 4, 5]\n    # [2, 3, 4, 5, 6]\n    lst1 = [1, 2, 3, 4, 5]\n    lst2 = [2, 3, 4, 5, 6]\n    print mod_div(lst1, lst2)\n    # expected output\n    # [1, 2, 3, 4, 5]",
      -15.0859375
    ],
    [
      "# Approach:\n# 1) Create a new list of elements.\n# 2) Create a new list of modulo values.\n# 3) Map each element in the first list to the modulo of each element in the second list.\n# 4) Return the modulo of the new list.\n\n# Time complexity: O(n*m)\n# Space complexity: O(n)\n\ndef mod(lst, mod):\n    new_lst = []\n    for i in lst:\n        new_lst.append(i % mod)\n\n    return new_lst\n\n\ndef mod_lambda(lst, mod):\n    new_lst = []\n    for i in lst:\n        new_lst.append(lambda x: x % mod)\n\n    return new_lst\n\n\ndef mod_map(lst, mod):\n    new_lst = []\n    for i in lst:\n        new_lst.append(map(lambda x: x % mod, i))\n\n    return new_lst\n\n\ndef mod_reduce(lst, mod):\n    new_lst = []\n    for i in lst:\n        new_lst.append(reduce(lambda x, y: x % mod + y, i))\n\n    return new_lst\n\n\ndef mod_recursive(lst, mod):\n    if len(lst) == 0:\n        return []\n\n    new_lst = lst[0]\n    for i in range(1, len(lst)):\n        new_lst = new_lst + [new_lst[i] % mod]\n\n    return new_lst\n\n\nif __name__ == \"__main__\":\n    print mod([1, 2, 3], 4)\n    print mod_lambda([1, 2, 3], 4)\n    print mod_map([1, 2, 3], 4)\n    print mod_reduce([1, 2, 3], 4)\n    print mod_recursive([1, 2, 3], 4)",
      -15.5625
    ],
    [
      "def mod_division(l1, l2):\n    l1 = map(lambda x: x % 10, l1)\n    l2 = map(lambda x: x % 10, l2)\n    return reduce(lambda x, y: x * 10 + y, l1, 0) % 10 * 10 + reduce(lambda x, y: x * 10 + y, l2, 0) % 10\n\nprint(mod_division([2, 3, 4, 5], [1, 2, 3, 4]))",
      -16.28125
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}