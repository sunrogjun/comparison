{
  "problem": {
    "task_id": "MBPP/424",
    "prompt": "Write a function to extract only the rear index element of each string in the given tuple.",
    "canonical_solution": "def extract_rear(test_tuple):\r\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res) ",
    "test_list": [
      "assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']",
      "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']",
      "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"
    ],
    "challenge_test_list": [],
    "problem_id": 413
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution(object):\n    def extractRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        nums = sorted(nums)\n        ret = []\n        for i in xrange(len(nums)):\n            if i == 0:\n                ret.append(0)\n            elif i == len(nums) - 1:\n                ret.append(len(nums) - 1)\n            else:\n                ret.append(nums[i - 1])\n        return ret\n\n    def extractRear1(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(n) - 1 for n in nums]\n\n    def extractRear2(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for n in nums:\n            ret.append(len(n) - 1)\n        return ret\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.extractRear([\"abc\", \"cde\", \"def\"])\n    print s.extractRear([\"a\", \"bb\", \"c\"])\n    print s.extractRear([\"a\", \"bb\", \"c\", \"dd\"])\n    print s.extractRear([\"a\", \"bb\", \"c\", \"dd\", \"ee\"])\n    print s.extractRear([\"a\", \"bb\", \"c\", \"dd\", \"ee\", \"fff\"])",
      5.234375
    ],
    [
      "class Solution:\n    # @param strs a tuple of strings\n    # @return a list of integers\n    def findRearElements(self, strs):\n        if not strs:\n            return []\n        s = [0] * len(strs[0])\n        for i in range(len(strs)):\n            for j in range(len(strs[i])):\n                s[j] = s[j] + (strs[i][j] - 'a')\n        return s",
      2.923828125
    ],
    [
      "class Solution(object):\n    def findRearView(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not strings:\n            return []\n\n        return [i for i, s in enumerate(strings) if s[0] == strings[i][-1]]",
      0.98095703125
    ],
    [
      "class Solution:\n    # @param {string[]} strs\n    # @return {string[]}\n    def reverseStr(self, strs):\n        return map(lambda x: x[::-1], strs)",
      0.9091796875
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in xrange(len(nums)):\n            res.append(nums[-i-1])\n\n        return res\n\n\nif __name__ == \"__main__\":\n    Solution().getRear([])",
      0.65478515625
    ],
    [
      "class Solution:\n    # @param {List[str]} strs\n    # @return {List[int]}\n    def findRearElements(self, strs):\n        return [s[-1] for s in strs]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))\n    print s.findRearElements(('abbcc', 'bbccc', 'ccc', 'cc'))",
      0.1766357421875
    ],
    [
      "def rear_index(tuple_of_strings):\n    \"\"\"\n    :type tuple_of_strings: List[str]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(len(tuple_of_strings)):\n        result.append(tuple_of_strings[i].index(tuple_of_strings[i][-1]))\n    return result\n\n\nif __name__ == '__main__':\n    strings = [\n        \"Hello\",\n        \"Hello World\",\n        \"World\",\n        \"Hello World\"\n    ]\n    result = rear_index(strings)\n    print(result)",
      0.155029296875
    ],
    [
      "class Solution(object):\n    def _extractRear(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: List[int]\n        \"\"\"\n        rear = []\n        for i in range(len(s)):\n            if s[i][0] == '*':\n                rear.append(i)\n        return rear\n\n    def extractRear(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return self._extractRear(s)\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.extractRear([\"*a*b*c*\", \"*d*e*f*\", \"*g*h*i*\"]))\n    print(sol.extractRear([\"*a*b*c*\", \"*d*e*f*\", \"*g*h*i*\", \"*j*k*l*\"]))\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\"]))",
      0.09881591796875
    ],
    [
      "def extract_rear_index(strings_list):\n    result = []\n    for index, string in enumerate(strings_list):\n        result.append(string[-1])\n    return result\n\n# Test Cases\nprint(extract_rear_index(('abc', 'bcd', 'cde', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'wxyz')))",
      -0.0792236328125
    ],
    [
      "class Solution(object):\n    def getRear(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [int(A[i].split(' ')[-1]) for i in range(len(A))]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.getRear([\"hello world\", \"this is a test\"]))\n    print(s.getRear([\"hello world\", \"this is a test\", \"the best\"]))",
      -0.1796875
    ],
    [
      "class Solution(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type s: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            s[i] = s[i][k:] + s[i][:k]\n            res.append(s[i])\n        return res",
      -0.211181640625
    ],
    [
      "from collections import namedtuple\n\nRear = namedtuple(\"Rear\", \"rear\")\n\nclass Solution:\n    def rear_index(self, strings: 'List[str]') -> 'Rear':\n        return Rear(*map(lambda s: int(s.rstrip()), strings))",
      -0.2159423828125
    ],
    [
      "class Solution(object):\n    def extractRear(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for i in range(len(strs)):\n            ret.append(len(strs[i]))\n        return ret\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\"]))\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\", \"e\"]))\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]))\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]))\n    print(sol.extractRear([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]))",
      -0.449951171875
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def _rearrange(self, strs):\n        \"\"\"\n        :param strs: list of strings\n        :return: list of strings\n        \"\"\"\n        n = len(strs)\n        return [strs[i] for i in reversed(range(n))]\n\n    def rearrange_strings(self, strs):\n        \"\"\"\n        :param strs: list of strings\n        :return: list of strings\n        \"\"\"\n        return self._rearrange(strs)\n\n\nif __name__ == \"__main__\":\n    assert Solution().rearrange_strings([\"abc\", \"de\", \"fgh\"]) == [\"fgh\", \"de\", \"abc\"]\n    assert Solution().rearrange_strings([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == [\"e\", \"f\", \"g\", \"d\", \"c\", \"b\", \"a\"]\n    assert Solution().rearrange_strings([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) == [\"e\", \"f\", \"g\", \"d\", \"c\", \"b\", \"a\"]",
      -0.57373046875
    ],
    [
      "# https://leetcode.com/problems/rear-index-of-the-substring/description/\n\nclass Solution:\n    def findRear(self, words: List[str], k: int) -> int:\n        dic = {}\n        for word in words:\n            if word in dic:\n                dic[word] += 1\n            else:\n                dic[word] = 1\n\n        def check(word):\n            if word in dic:\n                return dic[word]\n            else:\n                return 0\n\n        return max(dic, key=lambda x: check(x))",
      -0.8193359375
    ],
    [
      "class Solution:\n    # @param {string[]} strs\n    # @return {string[]}\n    def reverseStr(self, strs):\n        if not strs:\n            return []\n        \n        rear_index_list = []\n        for i in range(len(strs)):\n            rear_index_list.append(strs[-i-1])\n        return rear_index_list",
      -0.82958984375
    ],
    [
      "def rear_index_element(tuple_str):\n    # write your code here\n    return tuple_str[-1]\n\nif __name__ == \"__main__\":\n    tuple_str = (\"Hello\", \"World\", \"This\", \"is\", \"a\", \"test\", \"string\")\n    print rear_index_element(tuple_str)",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def _reverse(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return nums\n        return [nums[-1]] + self._reverse(nums[:-1])\n    \n    def reverseOnlyDigits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums = list(map(int, nums))\n        return self._reverse(nums)",
      -0.85595703125
    ],
    [
      "class Solution:\n    # @param A: a tuple of strings\n    # @return a list of strings\n    def getRear(self, A):\n        return [A[i][::-1] for i in range(len(A))]",
      -0.85595703125
    ],
    [
      "# Definition for a string.\nclass String:\n    def __init__(self, s):\n        self.s = s\n\n    def __str__(self):\n        return self.s\n\nclass Solution:\n    def extractRear(self, strs):\n        \"\"\"\n        :type strs: List[String]\n        :rtype: List[String]\n        \"\"\"\n        return [strs[i][::-1] for i in range(len(strs))]",
      -0.85693359375
    ],
    [
      "import sys\n\n__author__ = 'Daniel'\n\n\nclass Solution:\n    def rear_index(self, words: 'List[str]') -> 'List[int]':\n        result = []\n        for word in words:\n            result.append(word.rfind(' '))\n        return result\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    words = ['Hello World', 'The quick brown fox jumps over the lazy dog.']\n    print(solution.rear_index(words))",
      -0.85693359375
    ],
    [
      "# https://leetcode.com/problems/extract-the-rear-index-element-of-a-string/\n\nclass Solution:\n    def extractRear(self, strs: 'List[str]') -> 'List[str]':\n        rear = 0\n        return [strs[i][rear] for i in range(len(strs))]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.extractRear([\"Hello\", \"World\"]))\n    print(s.extractRear([\"Hello\", \"World\", \"My\", \"Dog\", \"is\", \"a\", \"little\", \"red\"]))",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def getRearrIndex(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not strs:\n            return []\n        rear = 0\n        for i in range(len(strs)):\n            if strs[i] == strs[rear]:\n                rear += 1\n            else:\n                return [rear]\n        return []\n\n\nif __name__ == \"__main__\":\n    assert Solution().getRearrIndex([\"a\", \"b\", \"c\", \"d\", \"e\"]) == [3, 2, 1]",
      -0.85693359375
    ],
    [
      "from collections import namedtuple\n\ndef extract_rear(tuple_of_strs):\n    \"\"\"\n    :type tuple_of_strs: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple_of_strs[-1]\n\ndef extract_rear_list(tuple_of_strs):\n    \"\"\"\n    :type tuple_of_strs: list\n    :rtype: list\n    \"\"\"\n    return tuple_of_strs[-1]\n\nif __name__ == '__main__':\n    tuple_of_strs = (('a', 'b', 'c'), ('d', 'e', 'f'))\n    extract_rear_list(tuple_of_strs)\n    extract_rear(tuple_of_strs)",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {string[]} strs\n    # @return {string[]}\n    def getRear(self, strs):\n        if not strs:\n            return []\n        rear = [strs[0]]\n        for s in strs[1:]:\n            rear.append(s[len(rear[-1]) + 1:])\n        return rear\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.getRear([\"abc\", \"de\", \"fgh\"])",
      -0.85693359375
    ],
    [
      "from collections import defaultdict\n\n\ndef rear_index_extractor(tuple_of_strings):\n    \"\"\"\n    :type tuple_of_strings: tuple\n    :rtype: list\n    \"\"\"\n    result = defaultdict(list)\n    for s in tuple_of_strings:\n        result[len(s)].append(s)\n    return list(result.values())\n\n\nif __name__ == '__main__':\n    s = \"aabcccccaaa\"\n    t = (\"a\", \"b\", \"c\", \"a\")\n    print rear_index_extractor(t)",
      -0.85693359375
    ],
    [
      "def rear_index(tuple):\n    \"\"\"\n    :type tuple: List[str]\n    :rtype: List[int]\n    \"\"\"\n    return [len(s) - 1 for s in tuple]",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def getRearrIndex(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(x) - 1 for x in strings]",
      -0.85693359375
    ],
    [
      "class Solution:\n    def getRearIndex(self, strings: 'List[str]') -> 'List[int]':\n        return [len(strs)-1 if len(strs) > 1 else 0 for strs in strings]\n\nclass Solution2:\n    def getRearIndex(self, strings: 'List[str]') -> 'List[int]':\n        return [len(strs)-1 if len(strs) > 1 else 0 for strs in strings]\n\n\n# TESTS\nfor s, expected in [\n    (\"aba\", [0, 1, 2, 3]),\n    (\"abc\", [0, 1, 2, 3]),\n    (\"\", []),\n    (\"a\", [0]),\n]:\n    sol = Solution()\n    actual = sol.getRearIndex(s)\n    print(\"Rear index of\", s, \"->\", actual)\n    assert actual == expected",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def getRear(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(A[i]) - 1 for i in range(len(A))]",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def reverse(self, nums):\n        if not nums:\n            return nums\n        n = len(nums)\n        if n == 1:\n            return nums\n        nums.reverse()\n        return nums\n\nif __name__ == \"__main__\":\n    assert Solution().reverse([1,2,3]) == [3,2,1]",
      -0.85791015625
    ],
    [
      "class Solution:\n    def rearIndex(self, s: List[str]) -> int:\n        \"\"\"\n        :type s: List[str]\n        :rtype: int\n        \"\"\"\n        # for each string in s\n        # for each index i in range(0, len(s) - 1)\n        #   if s[i]!= s[i + 1]\n        #   return i\n        # return len(s) - 1\n\n        return sum(1 for _ in range(len(s) - 1) if s[i]!= s[i + 1])",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param {List<String>} words\n    # @return {List<Integer>}\n    def reverseVowels(self, words):\n        rear_index = []\n        for word in words:\n            if word[0] == 'a' or word[0] == 'e' or word[0] == 'i' or word[0] == 'o' or word[0] == 'u':\n                rear_index.append(len(word) - 1)\n            else:\n                rear_index.append(0)\n        return rear_index",
      -0.85791015625
    ],
    [
      "import os\n\ndef extract_rear(t):\n    \"\"\"\n    :type t: List[str]\n    :rtype: List[int]\n    \"\"\"\n    return [i for i, x in enumerate(t) if x[0]!= 'a']\n\ndef main():\n    t = (\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"g\",\n        \"h\",\n        \"i\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \"m\",\n        \"n\",\n        \"o\",\n        \"p\",\n        \"q\",\n        \"r\",\n        \"s\",\n        \"t\",\n        \"u\",\n        \"v\",\n        \"w\",\n        \"x\",\n        \"y\",\n        \"z\"\n    )\n    print extract_rear(t)\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "def rear_index_extractor(tuple_string):\n    return tuple_string[0], tuple_string[-1]",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def extractRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        nums = map(str, nums)\n        return [n[-1] for n in nums]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [\"abc\", \"bcd\", \"cde\", \"def\"]\n    print s.extractRear(nums)",
      -0.8583984375
    ],
    [
      "def rear_index(t):\n    for i in range(len(t)):\n        if t[i] == t[i + 1]:\n            return i\n\nprint rear_index((\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"))\n\nclass Solution(object):\n    def rearIndex(self, t):\n        \"\"\"\n        :type t: List[str]\n        :rtype: int\n        \"\"\"\n        return rear_index(t)",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param strings, a list of strings\n    # @return a list of integers\n    def findRearK(self, strings: List[str]) -> List[int]:\n        if not strings:\n            return []\n        k = len(strings)\n        output = []\n        for i in range(k):\n            for j in range(i+1, k):\n                if strings[i] < strings[j]:\n                    output.append(j)\n        return output",
      -0.8583984375
    ],
    [
      "def rear_index(str_tuple):\n    \"\"\"\n    :type str_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    rear_index = lambda s: s[-1]\n    return tuple([rear_index(s) for s in str_tuple])",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/extract-from-sorted-and-reverse-sorted-array/discuss/140168/Python-solution-with-explaination\n# https://leetcode.com/problems/extract-from-sorted-and-reverse-sorted-array/discuss/140169/Python-solution-with-explaination\n# https://leetcode.com/problems/extract-from-sorted-and-reverse-sorted-array/discuss/140168/Python-solution-with-explaination\n\nclass Solution(object):\n    def extractRear(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        return nums[-1:]\n\ns = Solution()\nprint s.extractRear([1,2,3])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return [s[::-1] for s in strs]",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def getRearrIndex(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: int\n        \"\"\"\n        for i, word in enumerate(s):\n            if i > 0 and s[i - 1] == word:\n                return i - 1\n        return 0\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.getRearrIndex(\"abcabc\")\n    print s.getRearrIndex(\"abc\")\n    print s.getRearrIndex(\"cba\")\n    print s.getRearrIndex(\"cb\")\n    print s.getRearrIndex(\"cba\")",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def extractRear(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for s in strs:\n            res.append(s[-1])\n        return res\n\nif __name__ == \"__main__\":\n    assert Solution().extractRear([]) == []\n    assert Solution().extractRear([\"a\", \"b\"]) == [\"b\"]\n    assert Solution().extractRear([\"a\", \"b\", \"c\"]) == [\"b\", \"c\"]",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def getRearrIndex(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not strs:\n            return []\n\n        res = [0] * len(strs)\n        for i in xrange(1, len(strs)):\n            if strs[i] == strs[i - 1]:\n                res[i] = res[i - 1]\n            else:\n                res[i] = i\n        return res",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        rear = []\n        for i, v in enumerate(nums):\n            if i > 0:\n                rear.append(i)\n        return rear\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.getRear([\n        \"abc\",\n        \"de\",\n        \"fgh\"\n    ])",
      -0.85888671875
    ],
    [
      "# Definition for a string.\nclass String:\n    def __init__(self, s: str) -> None:\n        self.s = s\n\n    def __str__(self) -> str:\n        return self.s\n\nclass Solution:\n    def extractRear(self, strings: List[str]) -> List[int]:\n        # return [0 for _ in range(len(strings))]\n        return [max(strings) for _ in range(len(strings))]\n\nclass Solution2:\n    def extractRear(self, strings: List[str]) -> List[int]:\n        # return [0 for _ in range(len(strings))]\n        return [max(strings) for _ in range(len(strings))]",
      -0.85888671875
    ],
    [
      "def extract_rear_element(tuple_of_strings):\n    \"\"\"\n    :param tuple_of_strings: A tuple of strings\n    :return: A tuple of strings\n    \"\"\"\n\n    return tuple([tuple_of_strings[-1]] + tuple(tuple_of_strings[:-1]))",
      -0.873046875
    ],
    [
      "class Solution(object):\n    def findReversedElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        nums.reverse()\n        for i in range(n-1, -1, -1):\n            if nums[i]!= nums[i-1]:\n                return i\n        return -1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n    print solution.findReversedElement(nums)",
      -0.91064453125
    ],
    [
      "def rear_index(t):\n    \"\"\"\n    :type t: List[str]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i, s in enumerate(t):\n        if i < len(t) - 1:\n            result.append(i)\n    return result",
      -1.0810546875
    ],
    [
      "def extract_rear_element(t):\n    return t[-1]\n\nif __name__ == '__main__':\n    print extract_rear_element([1,2,3,4])\n    print extract_rear_element(('abc', 'def'))",
      -1.138671875
    ],
    [
      "class Solution:\n    # @param {List[str]} words\n    # @return {List[str]}\n    def reverseWords(self, words):\n        # Write your code here\n        return map(lambda x: x[::-1], words)",
      -1.138671875
    ],
    [
      "class Solution(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return [strs[i][::-1] for i in range(len(strs))]\n\nif __name__ == '__main__':\n    s = Solution()\n    strs = [\"a\", \"b\", \"c\", \"d\"]\n    print(s.rearrangeString(strs))\n    strs = [\"a\", \"b\", \"c\", \"d\"]\n    print(s.rearrangeString(strs))\n    strs = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n    print(s.rearrangeString(strs))\n    strs = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]\n    print(s.rearrangeString(strs))",
      -1.154296875
    ],
    [
      "class Solution(object):\n    def findRearElem(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [i for i, s in enumerate(strs) if s[-1] == ']']",
      -1.291015625
    ],
    [
      "def rear_index(s, l):\n    return s[l - 1]\n\nif __name__ == '__main__':\n    s = 'ABCD'\n    print rear_index(s, 3)\n    print rear_index(s, 4)",
      -1.3310546875
    ],
    [
      "class Solution(object):\n    def extractRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [int(n[-1]) for n in nums]",
      -1.3310546875
    ],
    [
      "class Solution(object):\n    def findRearView(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        for i, s in enumerate(strings):\n            if s[-1] == s[0]:\n                ans.append(s[-1])\n        return ans",
      -1.4384765625
    ],
    [
      "class Solution(object):\n    def findRearView(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(s)-1 for s in strs]\n\nclass Solution2(object):\n    def findRearView(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(s)-1 for s in strs]",
      -1.453125
    ],
    [
      "# TODO:\n# - if a string is empty, return 0\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if a string is empty, return -1\n# - if",
      -1.453125
    ],
    [
      "class Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            res.append(nums[i].rfind('1'))\n        return res",
      -2.013671875
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def findSubstring(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [self.extract(word, k) for word in words]\n\n    def extract(self, word, k):\n        return word[k-1]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-all-substrings/solution/\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> findSubstring(String[] words, int k) {\n        List<Integer> ret = new ArrayList<Integer>();\n        for (String word: words) {\n            for (int i = 0; i < word.length() - k + 1; i++) {\n                ret.add(word.charAt(i) - 'a');\n            }\n        }\n        return ret;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> findSubstring(String[] words, int k) {\n        List<Integer> ret = new ArrayList<Integer>();\n        if (words == null || words.length == 0) return ret;\n        HashMap<String, List<Integer>> map = new HashMap<String, List<Integer>>();\n        for (String word: words) {\n            if (map.containsKey(word)) {\n                map.get(word).add(k - 1);\n            } else {\n                List<Integer> list = new ArrayList<Integer>();\n                list.add(k - 1);\n                map.put(word, list);\n            }\n        }\n        for (String word: map.keySet()) {\n            for (int i = 0; i < word.length() - k + 1; i++) {\n                ret.add(word.charAt(i) - '",
      -2.158203125
    ],
    [
      "class Solution:\n    # @param {List<String>} words\n    # @return {List<Integer>}\n    def extractRear(self, words):\n        ret = []\n        for i in range(len(words)):\n            ret.append(words[i].rfind(\",\"))\n        return ret\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.extractRear([])\n    print solution.extractRear([\"a,b,c\", \"d,e,f\", \"g,h,i\"])",
      -2.44140625
    ],
    [
      "class Solution(object):\n    def getRear(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(nums) - 1 - i for i, n in enumerate(nums)]\n\n\nif __name__ == \"__main__\":\n    assert Solution().getRear(['abcd', 'dcba']) == [3, 0]",
      -2.552734375
    ],
    [
      "def extract_rear_element(tuple_of_strings):\n    \"\"\"\n    :type tuple_of_strings: List[str]\n    :rtype: List[str]\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]\n\nif __name__ == \"__main__\":\n    strings = (\"abc\", \"bcd\", \"cde\")\n    assert extract_rear_element(strings) == [\"cde\"]\n    assert extract_rear_element((1, 2, 3)) == [3]\n    assert extract_rear_element((1, 2, 3, 4, 5, 6)) == [6]",
      -2.60546875
    ],
    [
      "class Solution(object):\n    def findRearView(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                return nums[i-1]\n        return nums[-1]",
      -2.6875
    ],
    [
      "class Solution:\n    def findRearElement(self, nums: List[str]) -> List[int]:\n        nums = sorted(nums)\n        result = []\n        for i in range(len(nums)):\n            result.append(nums[i].index(nums[i][-1]))\n        return result\n\n# test\ntest = Solution()\nprint(test.findRearElement([\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"a\"]))\nprint(test.findRearElement([\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"a\", \"b\"]))\nprint(test.findRearElement([\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"a\", \"b\", \"a\"]))\nprint(test.findRearElement([\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"a\", \"b\", \"a\", \"a\"]))\nprint(test.findRearElement([\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"a\", \"b\", \"a\", \"a\", \"a\"]))",
      -2.76171875
    ],
    [
      "class Solution:\n    # @param strings a tuple of strings\n    # @return a tuple of strings\n    def getIntersection(self, strings):\n        rear = []\n        for i in range(0, len(strings)):\n            rear.append(i)\n        for i in range(len(strings)):\n            for j in range(i+1, len(strings)):\n                if strings[i] == strings[j]:\n                    rear[i] = j\n        return tuple(rear)\n\n    # @param strings a tuple of strings\n    # @return a tuple of strings\n    def getIntersection2(self, strings):\n        rear = []\n        for i in range(0, len(strings)):\n            rear.append(i)\n        for i in range(len(strings)):\n            for j in range(i+1, len(strings)):\n                if strings[i] == strings[j]:\n                    rear[i] = j\n        return tuple(rear)\n\n\nif __name__ == '__main__':\n    strings = (\"Panthera leo\", \"Panthera pardus\", \"Panthera pardus\")\n    print(Solution().getIntersection(strings))",
      -3.37890625
    ],
    [
      "def extract_rear(t):\n    return [t[i] for i in range(len(t)) if i == len(t)-1]\n\n# TEST CASES\n\nprint extract_rear((1,2,3,4))\nprint extract_rear((1,2,3,4,5))\nprint extract_rear((1,2,3,4,5,6,7))\nprint extract_rear((1,2,3,4,5,6,7,8))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19))\nprint extract_rear((1,2,3,4,5,6,7,8,9,10,11,12,13,14",
      -3.435546875
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def rearIndex(self, strings):\n        \"\"\"\n        Greedy\n        :param strings: a list of strings\n        :return: a list of lists of integers\n        \"\"\"\n        if not strings:\n            return []\n\n        ans = []\n        for s in strings:\n            i = 0\n            while i < len(s):\n                ans.append(s[-i:])\n                i += 1\n        return ans\n\n    def rearIndex_1(self, strings):\n        \"\"\"\n        Brute Force\n        :param strings: a list of strings\n        :return: a list of lists of integers\n        \"\"\"\n        if not strings:\n            return []\n\n        ans = []\n        for s in strings:\n            i = 0\n            while i < len(s):\n                ans.append(s[-i:])\n                i += 1\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().rearIndex([\"a\", \"b\", \"c\"]) == [[0, 1, 2], [2, 1, 0]]\n    assert Solution().rearIndex([\"a\", \"b\", \"c\"]) == [[0, 1, 2], [2, 1, 0]]\n    assert Solution().rearIndex([\"a\", \"b\", \"c\"]) == [[0, 1, 2], [2, 1, 0]]\n    assert Solution().rearIndex([\"a\", \"b\", \"c\"]) == [[0, 1, 2], [2, 1, 0]]\n    assert Solution().rearIndex([\"a\", \"b\", \"c\"]) == [[0, 1, 2], [2, 1, 0]]",
      -3.478515625
    ],
    [
      "from collections import namedtuple\n\n_RearIndexElement = namedtuple('RearIndexElement', ['rear_index', 'index'])\n\n\ndef rear_index_element(input_tuple):\n    \"\"\"\n    :type input_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    return _RearIndexElement(index=input_tuple[-1], rear_index=input_tuple[-2])\n\n\nif __name__ == '__main__':\n    tuple_input = (1, 2, 3, 4)\n    print(rear_index_element(tuple_input))\n    print(rear_index_element((1, 2, 3, 4)))",
      -3.51953125
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def _extract(self, s, i, j):\n        return s[i:j]\n\n    def _extract_1(self, s, i, j):\n        return s[i + 1:j]\n\n    def _extract_2(self, s, i, j):\n        return s[i:j + 1]\n\n    def _extract_3(self, s, i, j):\n        return s[i + 1:j - 1]\n\n    def _extract_4(self, s, i, j):\n        return s[i + 2:j - 1]\n\n    def _extract_5(self, s, i, j):\n        return s[i + 2:j + 1]\n\n    def extract(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return [self._extract(s, i, j) for i, j in zip(range(len(s)), range(len(s)))]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.extract([])\n    print s.extract(['abc', 'abc'])\n    print s.extract(['abc', 'bcd'])\n    print s.extract(['abc', 'cde'])\n    print s.extract(['abc', 'cde'])\n    print s.extract(['abc', 'abc'])",
      -3.705078125
    ],
    [
      "import re\n\ndef get_rear_index(s):\n    return s.rindex(',')\n\ndef get_front_index(s):\n    return s.index(',')\n\ndef get_index_list(s):\n    return s.split(',')\n\ndef get_rear_index_list(s):\n    return [get_rear_index(s) for s in get_index_list(s)]\n\ndef get_front_index_list(s):\n    return [get_front_index(s) for s in get_index_list(s)]\n\nif __name__ == '__main__':\n    test_cases = [('1,2,3,4,5,6,7,8,9', '1,2,3,4,5,6,7,8,9'),\n                  ('1,2,3,4,5,6,7,8,9,10,11,12', '1,2,3,4,5,6,7,8,9'),\n                  ('1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21')]\n    for case in test_cases:\n        print get_rear_index(case[0])\n        print get_front_index(case[0])\n        print get_rear_index_list(case[0])\n        print get_front_index_list(case[0])",
      -4.04296875
    ],
    [
      "import sys\n\ndef extract_rear_index(t):\n    \"\"\"\n    Extracts the rear index of each string in the given tuple.\n    :param t: A tuple of strings.\n    :return: A tuple of strings.\n    \"\"\"\n    return tuple([t[i][::-1] for i in range(len(t))])\n\nif __name__ == \"__main__\":\n    t = (sys.argv[1], sys.argv[2], sys.argv[3])\n    print extract_rear_index(t)",
      -4.86328125
    ],
    [
      "class Solution:\n    # @param strs, a list of strings\n    # @return a list of strings\n    def reverseStr(self, strs):\n        return [strs[-1]] + strs[:-1]\n    \n    def reverseStr2(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]]\n    \n    def reverseStr3(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]]\n    \n    def reverseStr4(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] + [strs[2]]\n    \n    def reverseStr5(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] + [strs[2]] + [strs[3]]\n    \n    def reverseStr6(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] + [strs[2]] + [strs[3]] + [strs[4]]\n    \n    def reverseStr7(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] + [strs[2]] + [strs[3]] + [strs[4]] + [strs[5]]\n    \n    def reverseStr8(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] + [strs[2]] + [strs[3]] + [strs[4]] + [strs[5]] + [strs[6]]\n    \n    def reverseStr9(self, strs):\n        return [strs[-1]] + strs[:-1] + [strs[0]] + [strs[1]] +",
      -4.99609375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def rearrangeString(self, s, n):\n        \"\"\"\n        :type s: str\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        # return [s[:i]+s[i+1:] for i in range(n-1)]\n        return [s[i:i+n] for i in range(len(s))]\n\n    def rearrangeString2(self, s, n):\n        \"\"\"\n        :type s: str\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        return [s[i:i+n] for i in range(len(s))]\n\n\nif __name__ == \"__main__\":\n    print(Solution().rearrangeString(\"abc\", 3))\n    print(Solution().rearrangeString(\"abcdef\", 3))\n    print(Solution().rearrangeString(\"abcdefghij\", 3))",
      -5.19140625
    ],
    [
      "class Solution:\n    # @return a tuple of lists\n    def getRearElements(self, strs: List[str]) -> List[List[int]]:\n        if not strs:\n            return []\n        \n        rear_indexes = [0] * len(strs[0])\n        for i, s in enumerate(strs):\n            for j, c in enumerate(s):\n                if c == strs[i][-1]:\n                    rear_indexes[j] = i\n        return rear_indexes",
      -5.36328125
    ],
    [
      "class Solution:\n    # @param {List<String>} nums\n    # @return {List<String>}\n    def reverseOnlyDigits(self, nums):\n        if not nums:\n            return nums\n        res = []\n        for num in nums:\n            res.append(str(int(num)))\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.reverseOnlyDigits((\"123\", \"456\", \"789\")))",
      -5.44140625
    ],
    [
      "# https://www.hackerrank.com/challenges/extract-rear-index-element/problem\n\ndef extract_rear_index_element(arr):\n    \"\"\"\n    :type arr: List[str]\n    :rtype: List[int]\n    \"\"\"\n    rear_index_element = []\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[i] == arr[j]:\n                rear_index_element.append(j)\n    return rear_index_element\n\n\nif __name__ == '__main__':\n    arr = [\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n        'J',\n        'K',\n        'L',\n        'M',\n        'N',\n        'O',\n        'P',\n        'Q',\n        'R',\n        'S',\n        'T',\n        'U',\n        'V',\n        'W',\n        'X',\n        'Y',\n        'Z',\n    ]\n    print(extract_rear_index_element(arr))",
      -5.59765625
    ],
    [
      "def rear_index(strings):\n    return [i for i, s in enumerate(strings) if s[-1] == ']']\n\nif __name__ == '__main__':\n    strings = [\n        \"a\",\n        \"[a\",\n        \"b]\",\n        \"c\",\n        \"[[a\",\n        \"d\",\n        \"[[[[a\",\n        \"e\",\n        \"[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[",
      -5.921875
    ],
    [
      "#!/usr/bin/env python\n\nfrom collections import namedtuple\n\n_tuple = namedtuple('_tuple','s1 s2 s3 s4 s5 s6 s7 s8')\n\ndef get_rear_index(s1, s2, s3, s4, s5, s6, s7, s8):\n    return max(s1.rfind('('), max(s2.rfind('('), max(s3.rfind('('), max(s4.rfind('('), max(s5.rfind('('), max(s6.rfind('('), max(s7.rfind('('), max(s8.rfind('('))))\n\ndef main():\n    t1 = ('(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(",
      -6.80078125
    ],
    [
      "import unittest\nfrom collections import namedtuple\n\nclass Solution:\n    def extractRear(self, strs: list) -> str:\n        return ''.join(strs[::-1])\n\n    def extractRear_no_change(self, strs: list) -> str:\n        rear = strs[-1]\n        return rear\n\n    def extractRear_no_change_reverse(self, strs: list) -> str:\n        return strs[0]\n\n    def test(self):\n        s = Solution()\n        s_no_change = Solution()\n        s_no_change.extractRear_no_change = s.extractRear_no_change\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_change.extractRear_no_change_reverse = s.extractRear_no_change_reverse\n        s_no_",
      -6.92578125
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def _reverse(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        return ''.join(reversed(s))\n\n    def _reverse_recursion(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        if not s:\n            return ''\n\n        return ''.join([self._reverse_recursion(s[1:])] + [self._reverse(s[0])])\n\n    def _reverse_iter(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        if not s:\n            return ''\n\n        return ''.join(reversed([s[1]] + [s[0]]))\n\n    def _reverse_recursion_iter(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        if not s:\n            return ''\n\n        return ''.join([self._reverse_recursion_iter(s[1:])] + [self._reverse_recursion_iter(s[0])])\n\n    def reverse_string(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        return self._reverse_iter(s)\n\n    def reverse_string2(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        return self._reverse_recursion(s)\n\n    def reverse_string3(self, s):\n        \"\"\"\n        :param s: str\n        :return: str\n        \"\"\"\n        return self._reverse_recursion_iter(s)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.reverse_string(\"aab\"))\n    print(s.reverse_string2(\"aab\"))\n    print(s.reverse_string3(\"aab\"))",
      -7.04296875
    ],
    [
      "class Solution(object):\n    def getRear(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: int\n        \"\"\"\n        if not s:\n            return -1\n        rear = 0\n        for i in range(len(s)):\n            if i == len(s) - 1:\n                return -1\n            if s[i] == s[i + 1]:\n                rear = i\n            else:\n                return -1\n        return rear",
      -7.08984375
    ],
    [
      "import unittest\n\nclass Solution:\n    # @param a, a string\n    # @param b, a tuple of string\n    # @return a tuple of string\n    def reverseV2(self, a, b):\n        if not a or not b:\n            return a, b\n        return b[0], tuple(reversed(b[1:]))\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/reverse-v2/solution/\n\n# DFS\n# 3ms 99.88%\nclass Solution {\n    public List<String> reverseV2(String[] a, String[] b) {\n        List<String> res = new ArrayList<>();\n        int len = a.length;\n        for (int i = 0; i < len; i++) {\n            res.add(new StringBuilder(a[i]).reverse().toString());\n        }\n        for (int i = 0; i < len; i++) {\n            res.add(b[i]);\n        }\n        return res;\n    }\n}\n\n# DP\n# 1ms 100%\nclass Solution {\n    public List<String> reverseV2(String[] a, String[] b) {\n        int len = a.length;\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < len; i++) {\n            res.add(new StringBuilder(a[i]).reverse().toString());\n        }\n        for (int i = 0; i < len; i++) {\n            res.add(b[i]);\n        }\n        return res;\n    }\n}\n'''",
      -7.2109375
    ],
    [
      "def get_rear_index(t):\n    for i in range(0, len(t)):\n        if i == 0:\n            return t[i]\n        else:\n            return t[i] + t[i - 1]\n\ndef main():\n    t = (\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\")\n    print(get_rear_index(t))\n\nif __name__ == \"__main__\":\n    main()",
      -7.265625
    ],
    [
      "# https://leetcode.com/problems/rearrange-strings-ii/discuss/132563/Java-O(n)-time-and-O(1)-space-solution\n\nclass Solution(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not strs:\n            return []\n\n        ret = []\n        for i in range(len(strs)):\n            ret.append(''.join(sorted(strs[i])))\n\n        return ret\n\nclass Solution2(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not strs:\n            return []\n\n        ret = []\n        for i in range(len(strs)):\n            ret.append(''.join(sorted(strs[i])))\n\n        return ret\n\nclass Solution3(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not strs:\n            return []\n\n        ret = []\n        for i in range(len(strs)):\n            if i == len(strs) - 1:\n                ret.append(strs[i])\n            else:\n                ret.append(strs[i] + strs[i+1])\n        return ret\n\nclass Solution4(object):\n    def rearrangeString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not strs:\n            return []\n\n        ret = []\n        for i in range(len(strs)):\n            if i == len(strs) - 1:\n                ret.append(strs[i])\n            else:\n                ret.append(strs[i] + strs[i+1])\n        return ret\n\nclass Solution5(object):\n    def rearrangeString(self,",
      -7.58203125
    ],
    [
      "import unittest\nfrom collections import namedtuple\n\nfrom Common.string_to_integer import string_to_integer\n\n\nclass TestStringToInteger(unittest.TestCase):\n\n    def test_string_to_integer(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)\n\n    def test_string_to_integer_with_error(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)\n\n    def test_string_to_integer_with_empty_input(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)\n\n    def test_string_to_integer_with_empty_input_with_error(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)\n\n    def test_string_to_integer_with_negative_input(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,-3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)\n\n    def test_string_to_integer_with_negative_input_with_error(self):\n        t = namedtuple('t', 'a,b,c')\n        input = t(1,2,-3)\n        output = t(1,2,3)\n\n        self.assertEqual(string_to_integer(input), output)",
      -7.60546875
    ],
    [
      "class Solution(object):\n    def getRear(self, s, t):\n        \"\"\"\n        :type s: List[str]\n        :type t: List[str]\n        :rtype: List[int]\n        \"\"\"\n        return [len(s[i]) for i in range(len(t))]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.getRear([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"d\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\", \"d\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\", \"e\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]))\n    print(sol.getRear([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]))",
      -7.91015625
    ],
    [
      "class Solution(object):\n    def reverseOnlyLetters(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not nums:\n            return []\n        result = []\n        for i in range(len(nums)):\n            result.append(self.reverseLetters(nums[i]))\n        return result\n\n    def reverseLetters(self, str):\n        if not str:\n            return str\n        result = []\n        for i in range(len(str)):\n            if str[i] in 'abcdefghijklmnopqrstuvwxyz':\n                result.append(str[i])\n        return ''.join(result)\n\na = Solution()\nprint a.reverseOnlyLetters([\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrstuvwxyz',\n    'abcdefghijklmnopqrst",
      -8.0078125
    ],
    [
      "def extractRear(strings):\n    \n    def isRear(string):\n        return string[-1] == string[0]\n    \n    return [x for x in strings if isRear(x)]\n\nif __name__ == \"__main__\":\n    strings = (\n        \"hello world\",\n        \"hello world\",\n        \"hello world\",\n        \"hello world\",\n        \"hello world\"\n    )\n    \n    print extractRear(strings)",
      -8.5859375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def reverse(self, nums):\n        if not nums:\n            return []\n        nums.sort(reverse=True)\n        return nums\n\n    def reverse(self, nums):\n        if not nums:\n            return []\n        return [nums[-1]] + nums[:-1]\n\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def reverse(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        return nums",
      -9.1953125
    ],
    [
      "class Solution(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type s: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        return self.rearrange_str(s, k)\n\n    def rearrange_str(self, s, k):\n        if k == 0:\n            return s\n\n        res = []\n        for i in range(len(s)):\n            if i % k == 0:\n                res.append(s[i])\n            else:\n                res.append(s[i])\n        return res",
      -9.5859375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def _extract_rear(self, s):\n        \"\"\"\n        use a stack\n        :param s: a string\n        :return: a list of strings\n        \"\"\"\n        res = []\n        stack = []\n        for i in range(len(s)):\n            if i < len(s) - 1 and s[i] == s[i + 1]:\n                stack.append(s[i])\n            else:\n                if stack:\n                    res.append(''.join(stack))\n                stack = []\n                stack.append(s[i])\n        if stack:\n            res.append(''.join(stack))\n        return res\n\n    def _extract_rear2(self, s):\n        \"\"\"\n        use a stack\n        :param s: a string\n        :return: a list of strings\n        \"\"\"\n        res = []\n        stack = []\n        for i in range(len(s)):\n            if i < len(s) - 1 and s[i] == s[i + 1]:\n                stack.append(s[i])\n            else:\n                if stack:\n                    res.append(''.join(stack))\n                stack = []\n                stack.append(s[i])\n        if stack:\n            res.append(''.join(stack))\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution()._extract_rear(\"bbb\") == [\"bbb\"]\n    assert Solution()._extract_rear(\"bbbbbbbb\") == [\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
      -10.296875
    ],
    [
      "import re\n\ndef extract_rear_index_string(strings):\n    \"\"\"\n    :type strings: List[str]\n    :rtype: List[int]\n    \"\"\"\n    return [re.search(r'\\[(\\d+)\\]', s).group(1) for s in strings]\n\nif __name__ == '__main__':\n    assert extract_rear_index_string([u'a', u'b', u'c', u'd', u'e']) == [2, 3, 4, 5, 6]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg']) == [2, 3, 4, 5, 6]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg', u'hij']) == [2, 3, 4, 5, 6, 7]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg', u'hij', u'jkl']) == [2, 3, 4, 5, 6, 7, 8]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg', u'hij', u'jkl', u'klm']) == [2, 3, 4, 5, 6, 7, 8, 9]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg', u'hij', u'jkl', u'klm', u'mno']) == [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert extract_rear_index_string([u'abc', u'bcd', u'cde', u'def', u'efg', u'hij', u'jkl', u'klm', u'mno', u'pqr']) == [2, 3, 4, 5, 6, 7, 8",
      -10.546875
    ],
    [
      "from collections import namedtuple\n\nRearIndex = namedtuple('RearIndex','rear_index')\n\n\ndef get_rear_index(string_list):\n    \"\"\"\n    :type string_list: List[str]\n    :rtype: List[RearIndex]\n    \"\"\"\n    rear_index = [0] * len(string_list)\n    for i in range(len(string_list)):\n        rear_index[i] = rear_index[i - 1] + len(string_list[i - 1])\n\n    return rear_index\n\n\nif __name__ == '__main__':\n    string_list = [\"Hello\", \"World\", \"How are you\", \"?\"]\n    rear_index = get_rear_index(string_list)\n    print(rear_index)\n    print(rear_index[0])\n    print(rear_index[1])\n    print(rear_index[2])\n    print(rear_index[3])",
      -10.8671875
    ],
    [
      "class Solution:\n    # @param {List<String>} strs\n    # @return {List<Integer>}\n    def reverseOnlyRearElements(self, strs):\n        res = []\n        for i in range(len(strs)):\n            res.append(strs[-i-1].count('a'))\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    strs = [\n        'bab',\n        'bda',\n        'cba',\n        'abc',\n        'adb',\n        'cbd',\n        'bac',\n        'acd',\n        'adb'\n    ]\n    print(sol.reverseOnlyRearElements(strs))",
      -11.421875
    ],
    [
      "import collections\nimport itertools\n\ndef extract_rear_index(strings):\n    \"\"\"\n    :type strings: List[str]\n    :rtype: List[int]\n    \"\"\"\n    rear_index_map = collections.defaultdict(list)\n    for i, s in enumerate(strings):\n        rear_index_map[s[::-1]].append(i)\n    return [len(rear_index_map[s[::-1]]) for s in rear_index_map]\n\ndef test():\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\"]) == [1, 1, 1, 0]\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\"]) == [1, 1, 1, 1, 1, 0]\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\", \"a\"]) == [1, 1, 1, 1, 1, 1, 0]\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\", \"a\", \"a\"]) == [1, 1, 1, 1, 1, 1, 1, 0]\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == [1, 1, 1, 1, 1, 1, 1, 1, 0]\n    assert extract_rear_index([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 0]\n\nif __name__ == '__main__':\n    test()",
      -11.9296875
    ],
    [
      "class Solution:\n    # @param {string[]} strs\n    # @return {string[]}\n    def reverseOnlyRearElements(self, strs):\n        strs = list(strs)\n        # write your code here\n        result = []\n        for i in range(len(strs)):\n            if strs[i] == strs[-1]:\n                result.append(strs[-1])\n                strs[-1] = strs[-2]\n                strs.pop()\n            else:\n                strs[i] = strs[-1]\n                strs[-1] = strs[-2]\n                strs.pop()\n        return result",
      -12.0
    ],
    [
      "class Solution(object):\n    def findRearView(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[int]\n        \"\"\"\n        rear_indexes = []\n        for i in range(len(strings)):\n            if strings[i] == '':\n                rear_indexes.append(i)\n            elif strings[i]!= '':\n                break\n        for i in range(len(strings) - 1, -1, -1):\n            if strings[i] == '':\n                rear_indexes.append(i)\n            elif strings[i]!= '':\n                break\n        return rear_indexes\n\n\nif __name__ == \"__main__\":\n    assert Solution().findRearView((\"a\", \"b\", \"c\")) == [2, 3]\n    assert Solution().findRearView((\"a\", \"b\", \"\", \"c\")) == [2, 3, 0]",
      -12.109375
    ],
    [
      "class Solution(object):\n    def getRearr(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(strs)):\n            if i == 0:\n                res.append(i)\n            else:\n                res.append(res[i - 1] + len(strs[i - 1]))\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    strs = ['abc', 'abcd', 'dcba']\n    print(sol.getRearr(strs))",
      -12.265625
    ],
    [
      "import string\n\ndef extract_rear_index(t):\n    for i in range(len(t)):\n        if len(t[i]) == 0:\n            continue\n        if t[i][0] in string.lowercase:\n            return i\n    return -1\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert extract_rear_index((\"\", \"\", \"\", \"\", \"\", \"\")), 0\n    assert extract_rear_index((\"\", \"a\", \"\", \"\", \"\", \"\")), 1\n    assert extract_rear_index((\"\", \"a\", \"\", \"\", \"\", \"a\")), 2\n    assert extract_rear_index((\"\", \"aa\", \"\", \"\", \"\", \"aa\")), 3\n    assert extract_rear_index((\"\", \"aa\", \"\", \"\", \"\", \"aaa\")), 4\n    assert extract_rear_index((\"\", \"aaa\", \"\", \"\", \"\", \"aaa\")), 4\n    assert extract_rear_index((\"\", \"ab\", \"\", \"\", \"\", \"ba\")), 2\n    assert extract_rear_index((\"\", \"ab\", \"\", \"\", \"\", \"bb\")), 3\n    assert extract_rear_index((\"\", \"ab\", \"\", \"\", \"\", \"bbb\")), 4\n    assert extract_rear_index((\"\", \"abb\", \"\", \"\", \"\", \"bbb\")), 4\n    assert extract_rear_index((\"\", \"abb\", \"\", \"\", \"\", \"bbbb\")), 4\n    assert extract_rear_index((\"\", \"abbb\", \"\", \"\", \"\", \"bbbb\")), 4\n    assert extract_rear_index((\"\", \"abbbb\", \"\", \"\", \"\", \"bbbbb\")), 4\n    assert extract_rear_index((\"\", \"abbbbb\", \"\", \"\", \"\", \"bbbbbb\")), 4\n    assert extract_rear_index((\"\", \"abbbbbb\", \"\", \"\", \"\", \"bbbbbbb\")), 4\n    assert extract_rear_index",
      -13.0234375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}