{
  "problem": {
    "task_id": "MBPP/348",
    "prompt": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.",
    "canonical_solution": "def bin_coff(n, r): \r\n\tval = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b) ",
    "test_list": [
      "assert find_ways(4) == 2",
      "assert find_ways(6) == 5",
      "assert find_ways(8) == 14"
    ],
    "challenge_test_list": [],
    "problem_id": 337
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    def numSequences(self, s, n):\n        \"\"\"\n        :type s: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        if n == 0:\n            return 1\n        for i in range(1, n):\n            if s[i] == 0 and s[i-1] == 0:\n                result += 1\n        return result",
      1.56640625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        dynamic programming\n\n        :param n: integer\n        :param k: integer\n        :return: a list of integer\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n + 1):\n            dp[i] = 0\n            for j in xrange(1, i):\n                if i - j >= 0:\n                    dp[i] += dp[i - j] * dp[j]\n\n        return dp[n]\n\n    def numSequences_DP(self, n, k):\n        \"\"\"\n        dynamic programming\n\n        :param n: integer\n        :param k: integer\n        :return: a list of integer\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in xrange(1, n + 1):\n            dp[i] = 0\n            for j in xrange(1, i):\n                if i - j >= 0:\n                    dp[i] += dp[i - j] * dp[j]\n\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    print Solution().numSequences(2, 1)",
      1.06640625
    ],
    [
      "# https://leetcode.com/problems/count-and-say/\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return str(1)\n        seq = str(1)\n        for i in xrange(2, n+1):\n            seq = str(i)\n            for j in xrange(1, len(seq)):\n                if seq[j-1] < seq[j]:\n                    seq = seq[:j] + str(seq[j]) + seq[j+1:]\n            print seq\n        return seq\n\na = Solution()\nprint a.countAndSay(1)\nprint a.countAndSay(2)\nprint a.countAndSay(3)\nprint a.countAndSay(4)\nprint a.countAndSay(5)\nprint a.countAndSay(6)",
      -0.1304931640625
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.helper(n, k, [])\n\n    def helper(self, n, k, res):\n        if k == 0:\n            return 1\n        if k == 1:\n            return (n >= 1 and n <= 1) or (n == 0)\n        if k == 2:\n            return (n >= 1 and n <= 2) or (n == 0 or n == 1)\n        if k == 3:\n            return (n >= 1 and n <= 3) or (n == 0 or n == 1 or n == 2)\n        if k == 4:\n            return (n >= 1 and n <= 4) or (n == 0 or n == 1 or n == 2 or n == 3)\n        if k == 5:\n            return (n >= 1 and n <= 5) or (n == 0 or n == 1 or n == 2 or n == 3 or n == 4)\n        if k == 6:\n            return (n >= 1 and n <= 6) or (n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5)\n        if k == 7:\n            return (n >= 1 and n <= 7) or (n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5 or n == 6)\n        if k == 8:\n            return (n >= 1 and n <= 8) or (n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5 or n == 6 or n == 7)\n        if k == 9:\n            return (n >= 1 and n <= 9) or (n == 0 or n == 1 or n == 2 or n == 3 or n == 4 or n == 5 or n == 6 or n == 7 or n == 8)\n        res += self.helper(n - 1, k - 1, res)\n        return res",
      -0.29150390625
    ],
    [
      "import collections\n\nclass Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 1\n        if k == 1:\n            return A[0]\n        if n == 0:\n            return 0\n        if k > n:\n            return 0\n        if n == 1:\n            return 1\n        if k > n - 1:\n            return 0\n        if k == n:\n            return 1\n        total = 0\n        for i in range(1, k + 1):\n            for j in range(1, n + 1):\n                if j - i >= 0:\n                    total += A[j - i] * self.numSequences(n - 1, k - i, A)\n        return total\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences(4, 3, [1, 2, 3]) == 4\n    assert Solution().numSequences(4, 1, [1, 2, 3]) == 1",
      -0.328857421875
    ],
    [
      "# https://leetcode.com/problems/count-and-say/\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        str_n = \"1\"\n        for i in range(2, n + 1):\n            str_n = self.countAndSay_helper(str_n, i)\n        return str_n\n\n    def countAndSay_helper(self, str_n, i):\n        if i == 1:\n            return str_n\n        str_n = str_n + str(i)\n        for j in range(2, i + 1):\n            str_n = self.countAndSay_helper(str_n, j)\n        return str_n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.countAndSay(4))",
      -0.487060546875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def numSequences(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.numSequences(root.right, k)\n        if root.right is None:\n            return self.numSequences(root.left, k)\n        return self.numSequences(root.left, k) + self.numSequences(root.right, k)",
      -0.6171875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/number-of-sequences-with-non-negative-prefix-sum/discuss/103910/Java-O(N^2)-Solver-with-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268/Java-O(N)-Space-Time\n        # https://leetcode.com/problems/number-of-sequences/discuss/121268",
      -0.6923828125
    ],
    [
      "# https://www.hackerrank.com/challenges/nonnegative-prefix-sum-sequences\n\n# from CommonClasses import *\n# import unittest\n\n\nclass Solution:\n    def nonNegativePrefixSum(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(len(A)):\n            res += A[i]\n            if res < 0:\n                res = 0\n            if res >= K:\n                return i\n        return -1\n\n\nclass TestFunction(unittest.TestCase):\n    def test(self):\n        solution = Solution()\n        self.assertEqual(solution.nonNegativePrefixSum([1, 2, 3], 3), 0)\n        self.assertEqual(solution.nonNegativePrefixSum([1, 2, 3, 4], 3), 1)\n        self.assertEqual(solution.nonNegativePrefixSum([1, 2, 3, 4, 5], 3), 2)\n        self.assertEqual(solution.nonNegativePrefixSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3), 3)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -0.80712890625
    ],
    [
      "class Solution(object):\n    def numSequences(self, s, n):\n        \"\"\"\n        :type s: str\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if len(s) < n:\n            return 0\n        dp = [0 for _ in xrange(n+1)]\n        dp[0] = 1\n        for i in xrange(1, n+1):\n            for j in xrange(i-1, 0, -1):\n                dp[i] += dp[j]\n        return dp[n]",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def numDistinct(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        res = 1\n        for i in range(len(S)):\n            res *= (len(S) - i)\n            res /= (len(T) - i)\n            res /= (S[i] - i)\n        return res\n\n\nif __name__ == \"__main__\":\n    print(Solution().numDistinct([-1, 0, 1], [1, 2, 3]))",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return a list of integer\n    def numSequences(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not num or not k:\n            return []\n\n        n = len(num)\n        if n == 1:\n            return [1]\n\n        ans = []\n        for i in range(1, n + 1):\n            pre_sum = 0\n            for j in range(0, i):\n                pre_sum += num[j]\n                if pre_sum < 0:\n                    ans.append(i)\n                    break\n        return ans",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for i in range(1, k+1):\n            cur_sum = 0\n            for j in range(1, k+1):\n                if i == j:\n                    continue\n                cur_sum += i - j\n                if cur_sum == n:\n                    ans += 1\n        return ans",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        n = len(S)\n        ans = 0\n        for i in range(1, n+1):\n            for j in range(i):\n                if S[i] == S[j]:\n                    continue\n                if i + L - 1 >= n:\n                    ans += 1\n                else:\n                    k = i + L - 1\n                    while k < n:\n                        if S[k] == S[j]:\n                            break\n                        k += 1\n                    else:\n                        ans += 1\n        return ans",
      -0.85693359375
    ],
    [
      "from collections import Counter\n\n# https://leetcode.com/problems/count-and-say/\n\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = ''\n        s = ''\n        for i in range(n):\n            if s!= '':\n                s = self.next(s)\n            else:\n                s = str(i + 1)\n        return s\n\n    def next(self, s):\n        counter = Counter(s)\n        if counter[s[0]] == 0:\n            return s[0]\n        else:\n            return self.next(s[1:]) + str(counter[s[0]])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.countAndSay(5) == '1 2 3 4 5'",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i][k] is the number of sequences from A[:i] having length k\n        # dp[i][0] is the number of sequences from A[:i]\n        dp = [[0 for _ in xrange(k+1)] for _ in xrange(n+1)]\n        for i in xrange(1, n+1):\n            for k in xrange(1, k+1):\n                dp[i][k] = dp[i-1][k] + (i-1)*A[i-1]\n        return dp[n][k]",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for i in range(len(A)):\n            if B[i] == 0:\n                continue\n            if A[i] == 0:\n                ans += 1\n            else:\n                for j in range(i + 1, len(A)):\n                    if A[j] > 0 and A[j] == A[j - 1] + B[j - 1]:\n                        ans += 1\n        return ans",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        return 0",
      -0.85791015625
    ],
    [
      "def solution(values, target):\n    dp = [[0] * (target + 1) for _ in range(len(values) + 1)]\n    for i in range(len(dp)):\n        dp[i][0] = 1\n    for i in range(1, len(dp)):\n        for j in range(1, len(dp[i])):\n            if i - j >= 0:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 0\n    return dp[-1][-1]\n\nvalues = [1, 2, 3, 4, 5]\ntarget = 5\nprint solution(values, target)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numDistinct(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        return len(self.get_prefix_sums(S, L))\n\n    def get_prefix_sums(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: List[int]\n        \"\"\"\n        if L == 0:\n            return [0]\n        ret = []\n        for i in range(L):\n            ret.append(self.get_prefix_sums(S, i) + self.get_prefix_sums(S, L - i - 1))\n        return ret",
      -0.85791015625
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def numDistinct(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(S, T, n, result):\n            if n == 0:\n                result[n] += 1\n                return\n            for i in xrange(len(S)):\n                if T[i] < S[i]:\n                    result[n] += 1\n                    dfs(S[:i+1], T[:i+1], n-1, result)\n                    result[n] -= 1\n                    dfs(S[i+1:], T, n-1, result)\n        result = defaultdict(int)\n        dfs(S, T, len(T), result)\n        return result[len(T)]\n\n\nif __name__ == \"__main__\":\n    print Solution().numDistinct([2, 3, 4, 5], [2, 3, 4, 5])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numDistinct(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(prefix, l):\n            if len(prefix) == l:\n                return 1\n            else:\n                ret = 0\n                for i in range(len(prefix)):\n                    if prefix[i] < T[i]:\n                        ret += dfs(prefix + [T[i]], l)\n                return ret\n        return dfs(S, len(T))\n\n\nif __name__ == \"__main__\":\n    print Solution().numDistinct([2, 3, 1, 4, 2], [1, 3, 5, 7, 8])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(len(S) - L + 1):\n            subsum = 0\n            for j in range(L):\n                subsum += S[i + j]\n            if subsum < 0:\n                res += 1\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().numSequences([1, 2, 3], 1) == 2\n    assert Solution().numSequences([1, 2, 3, 4], 3) == 2\n    assert Solution().numSequences([1, 2, 3, 4, 5], 4) == 1\n    assert Solution().numSequences([-1, -2, -3, -4, -5], 5) == 1",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, s, t):\n        \"\"\"\n        :type s: List[int]\n        :type t: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(s, t, i, j):\n            if i == len(t) or s[i]!= t[j]:\n                return 0\n            if j == len(t):\n                return 1\n            return 1 + dfs(s, t, i + 1, j) + dfs(s, t, i, j + 1)\n\n        return dfs(s, t, 0, 0)\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences([1, 2, 3], [1, 1, 1]) == 3\n    assert Solution().numSequences([1, 1, 1], [1, 1, 1]) == 1",
      -0.85791015625
    ],
    [
      "from collections import Counter\n\nclass Solution(object):\n    def numSequences(self, n, k, arr):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n        res = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] + arr[j] < k:\n                    continue\n                if arr[i] + arr[j] == k:\n                    res += 1\n                    continue\n                res += self.numSequences(n, k, arr[i:j+1])\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.numSequences(10, 6, [1, 2, 3, 4, 5, 6]))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        return self.numSeq(A, B, 0)\n\n    def numSeq(self, A, B, i):\n        if i == len(A):\n            return 1\n        j = i + 1\n        while j < len(A):\n            if A[i] + B[j] > A[j]:\n                return self.numSeq(A, B, j)\n            j += 1\n        return self.numSeq(A, B, j)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[0] * len(B) for _ in range(len(A))]\n        dp[0][0] = 1\n        for i in range(1, len(A)):\n            dp[i][0] = 1\n            for j in range(1, len(B)):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]",
      -0.8583984375
    ],
    [
      "__author__ = 'Danyang'\nclass Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (L+1)\n        dp[0] = 1\n        for i in range(1, L+1):\n            dp[i] = 0\n            for j in range(i):\n                dp[i] += dp[j] * (j-i+1)\n\n        for i in range(1, L+1):\n            for j in range(i, L+1):\n                dp[j] += dp[j-i]\n\n        return dp[L]\n\n\nif __name__==\"__main__\":\n    print Solution().numSequences([1,2,3,4], 3)",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @param sum, an integer\n    # @param length, an integer\n    # @return an integer\n    def numSequences(self, root, sum, length):\n        ret = 0\n        if root is None:\n            return ret\n        ret += self.numSequences(root.left, sum, length)\n        ret += self.numSequences(root.right, sum, length)\n        if root.left is None and root.right is None:\n            if root.val == sum:\n                ret += 1\n        return ret\n\n# Note:\n# 1. the input tree is a binary tree\n# 2. the sum of all nodes is an integer\n# 3. the length of a sequence is an integer\n# 4. the sum of the nodes in a sequence is positive",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < 1 or k < 0:\n            return 0\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, k + 1):\n            dp[i] = 0\n            for j in range(i):\n                dp[i] += dp[j] * (n - j)\n            dp[i] %= n\n        return dp[k]\n\n\nif __name__ == '__main__':\n    assert Solution().numSequences(3, 2) == 2\n    assert Solution().numSequences(4, 3) == 5\n    assert Solution().numSequences(6, 3) == 10",
      -0.8583984375
    ],
    [
      "import math\nfrom collections import defaultdict\n\nclass Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        dp = defaultdict(int)\n        for i in xrange(1, n + 1):\n            for j in xrange(1, k + 1):\n                dp[i] += j\n            if dp[i] > n:\n                result += 1\n            else:\n                for j in xrange(1, min(k, dp[i])):\n                    dp[i] -= j\n                    if dp[i] < 0:\n                        break\n        return result",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return an integer\n    def numSequences(self, num, k):\n        if not num or not k:\n            return 0\n        n = len(num)\n        res = [0] * k\n        res[0] = 1\n        for i in range(1, k):\n            res[i] = res[i-1] + num[i-1]\n        count = 0\n        for i in range(k):\n            count += res[i] * (res[i] - 1) / 2\n        return count",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/count-and-say/\n\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return \"1\"\n        count = 1\n        seq = \"1\"\n        for i in range(1, n):\n            count, seq = self.countAndSay(count)\n            seq = str(int(seq) + 1)\n        return seq\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.countAndSay(3)",
      -0.8583984375
    ],
    [
      "from collections import Counter\n\ndef count_sequences(n, values):\n    c = Counter()\n    for i in range(len(values)):\n        for j in range(n):\n            if values[i] + j >= 0:\n                c[values[i] + j] += 1\n    return c.most_common()\n\nif __name__ == '__main__':\n    n = 5\n    values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    c = count_sequences(n, values)\n    print(c)",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, arr):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(n-k+1):\n            for j in range(i+1, n-k+1):\n                prefix = arr[i:j]\n                if sum(prefix) == k:\n                    res += 1\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().numSequences(4, 2, [1, 2, 3, 4, 5]) == 4\n    assert Solution().numSequences(4, 3, [1, 2, 3, 4, 5]) == 4\n    assert Solution().numSequences(4, 4, [1, 2, 3, 4, 5]) == 1",
      -0.85888671875
    ],
    [
      "from collections import Counter\n\n\ndef num_non_negative_sequences(length, values):\n    \"\"\"\n    :type length: int\n    :type values: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(values)\n    return sum(1 for i in range(length) if values[i] >= 0 and values[i] < n)\n\n\ndef num_non_negative_sequences2(length, values):\n    \"\"\"\n    :type length: int\n    :type values: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(values)\n    return sum(1 for i in range(length) if values[i] >= 0 and values[i] < n)\n\n\nif __name__ == '__main__':\n    assert num_non_negative_sequences(3, [1, 2, 3, 4]) == 5\n    assert num_non_negative_sequences(5, [1, 2, 3, 4, 5]) == 10\n    assert num_non_negative_sequences(6, [1, 2, 3, 4, 5, 6]) == 15",
      -0.85888671875
    ],
    [
      "import math\n\nclass Solution(object):\n    def numSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(1, len(A)):\n            for j in range(i, len(A)):\n                k = 0\n                while A[i - k - 1] >= A[j - k]:\n                    k += 1\n                res += math.factorial(k)\n        return res",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def numSequences(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            j = i\n            while j < len(nums) and nums[j] == nums[j-1]:\n                j += 1\n            if j < len(nums):\n                n = j - i\n                if n == target:\n                    ans += 1\n                elif n > target:\n                    break\n                else:\n                    ans += self.numSequences(nums[i:j], target - n)\n        return ans\n\n\nif __name__ == \"__main__\":\n    print Solution().numSequences([1,2,3], 4)",
      -0.85888671875
    ],
    [
      "# https://oj.leetcode.com/problems/prefix-sum/discuss/766/Python-DP-with-explaination\n\nclass Solution(object):\n    def numSequences(self, s, t):\n        \"\"\"\n        :type s: int\n        :type t: int\n        :rtype: int\n        \"\"\"\n        if s < 0:\n            return 0\n        dp = [0] * (t+1)\n        dp[0] = 1\n        for i in range(1, t+1):\n            dp[i] = dp[i-1]\n            for j in range(s, i+1):\n                dp[i] += dp[j-s]\n        return dp[t]",
      -0.85888671875
    ],
    [
      "# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Easy-to-understand-and-Complete-Solution-with-Python-and-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/12472/Java-O(n)-and-O(n^2)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17061/Java-O(n^2)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/12472/Java-O(n^2)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/18273/Java-O(n^2)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/18269/Java-O(n^2)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17063/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17063/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Java-O(n)-Solution-with-Java\n# https://oj.leetcode.com/problems/prefix-sum/discuss/17062/Java-O(n)-Solution-with-Java",
      -1.65234375
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(A, B, i, j, k):\n            if k == 0:\n                return 1\n            if i == len(A) or j == len(B):\n                return 0\n            if A[i] < B[j]:\n                return 0\n            if A[i] == B[j]:\n                return dfs(A, B, i + 1, j + 1, k - 1) + dfs(A, B, i + 1, j, k - 1)\n            return dfs(A, B, i + 1, j + 1, k)\n        return dfs(A, B, 0, 0, len(A))\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences([1, 2, 3, 4], [1, 2, 3, 4]) == 0\n    assert Solution().numSequences([1, 2, 3, 4], [1, 3, 4, 5]) == 3\n    assert Solution().numSequences([1, 2, 3, 4], [1, 2, 3, 4]) == 1",
      -2.01171875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        self.A = A\n        self.n = n\n        self.k = k\n        self.ans = 0\n        self.dfs()\n        return self.ans\n\n    def dfs(self):\n        if self.k == 0:\n            self.ans += 1\n            return\n        for i in range(self.n):\n            if self.A[i] > self.n - i:\n                break\n            self.dfs(i, self.k - 1, self.A[i:])",
      -2.193359375
    ],
    [
      "def count_sequences(n, arr):\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return 1\n    elif len(arr) == 2:\n        return arr[0] + arr[1]\n    else:\n        ret = 0\n        for i in range(2, n+1):\n            ret += arr[i-2] + arr[i-1]\n        return ret\n\nif __name__ == '__main__':\n    print(count_sequences(3, [1, 2, 3, 4]))\n    print(count_sequences(3, [1, 2, 3, 4, 5]))\n    print(count_sequences(3, [1, 2, 3, 4, 5, 6]))\n    print(count_sequences(3, [1, 2, 3, 4, 5, 6, 7]))\n    print(count_sequences(3, [1, 2, 3, 4, 5, 6, 7, 8]))\n    print(count_sequences(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]))",
      -2.361328125
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) == 0:\n            return 0\n        dp = [0 for i in range(len(B) + 1)]\n        dp[0] = 1\n        for i in range(1, len(B) + 1):\n            dp[i] = 0\n            for j in range(len(A)):\n                if B[i - 1] - A[j] >= 0:\n                    dp[i] += dp[i - 1]\n        return dp[-1]",
      -2.52734375
    ],
    [
      "import os\nimport unittest\n\nfrom utils import *\n\nclass Test(unittest.TestCase):\n    def test_count_sequences_1(self):\n        self.assertEqual(count_sequences(2, [2, 1, 3, 1, 2, 1, 1, 2, 1, 2, 2, 3, 1, 3, 2, 1, 1, 2, 1, 3, 1, 1, 3, 1, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 3, 1, 3, 1, 3, 1, 1, 2, 1, 1, 3, 1, 1, 1, 2, 1, 3, 1, 2, 1, 1, 1, 3, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
      -2.7265625
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        if not L:\n            return 1\n        if not S:\n            return 0\n        if len(S) < L:\n            return 0\n        n = len(S)\n        s = [0] * (L + 1)\n        for i in range(1, n + 1):\n            s[0] += S[i - 1]\n        s[0] += S[0]\n        for i in range(1, L + 1):\n            s[i] += s[i - 1]\n        return s[L]",
      -2.939453125
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, a):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [1] * n\n        for i in range(k):\n            dp[i] = 0\n            for j in range(i + 1, n + 1):\n                dp[j] += dp[j - i - 1]\n        return dp[n - 1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences(3, 1, [1, 2, 3]) == 1\n    assert Solution().numSequences(2, 1, [1, 2, 3]) == 1\n    assert Solution().numSequences(5, 1, [1, 2, 3, 4, 5]) == 2\n    assert Solution().numSequences(5, 2, [1, 2, 3, 4, 5]) == 3",
      -3.421875
    ],
    [
      "# Definition for a prefix sum.\nclass PrefixSum(object):\n    def __init__(self, s):\n        \"\"\"\n        :type s: List[int]\n        \"\"\"\n        self.sum = 0\n        self.prefix_sum = [0]\n        self.length = len(s)\n        self.prefix_sum.extend([s[0]] * (self.length + 1))\n        for i in xrange(1, self.length):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + s[i - 1]\n        for i in xrange(2, self.length + 1):\n            self.prefix_sum[i] += self.prefix_sum[i - 1]\n        self.prefix_sum = [0] + self.prefix_sum[self.length:]\n        self.sum = self.prefix_sum[0]\n        for i in xrange(1, len(self.prefix_sum)):\n            self.sum += self.prefix_sum[i]\n        return\n\n    def update(self, s):\n        \"\"\"\n        :type s: int\n        \"\"\"\n        self.sum = self.prefix_sum[0]\n        for i in xrange(1, len(self.prefix_sum)):\n            self.sum += self.prefix_sum[i]\n        return\n\n\nclass Solution(object):\n    def numSequences(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        return self.count_seq(S, T)\n\n    def count_seq(self, S, T):\n        if len(S) == 0 or len(T) == 0:\n            return 0\n        if len(S) == 1:\n            return 1\n        if S[0] > T[0]:\n            return 0\n        if S[0] == T[0]:\n            return self.count_seq(S[1:], T[1:])\n        else:\n            return self.count_seq(S[1:], T[1:]) + self.count_seq(S[:-1",
      -3.587890625
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return an integer\n    def numSequences(self, num, k):\n        if k == 0:\n            return 1\n        if len(num) == 0:\n            return 0\n        m = len(num)\n        res = 1\n        for i in xrange(1, k+1):\n            res *= i\n            if i <= m:\n                res /= i\n                res *= (m - i + 1)\n        return res\n\nif __name__ == '__main__':\n    print Solution().numSequences([1,2,3], 3)\n    print Solution().numSequences([1,2,3,4,5], 3)\n    print Solution().numSequences([1,2,3,4,5,6], 3)\n    print Solution().numSequences([1,2,3,4,5,6,7], 3)",
      -3.658203125
    ],
    [
      "class Solution(object):\n    def numSequences(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        if s == t:\n            return 0\n\n        n = len(s)\n        m = len(t)\n        res = 0\n\n        for i in range(m + 1):\n            if i == 0 or i == m:\n                res += 1\n\n        for i in range(m + 1):\n            if i == 0 or i == m:\n                res += 1\n\n        for i in range(1, n + 1):\n            if i == 1 or i == n:\n                res += 1\n\n            for j in range(1, m + 1):\n                if i - j >= 0 and s[i - j] == t[j - 1]:\n                    res += 1\n\n        return res",
      -3.759765625
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, s):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        return self.gen(n, k, s, 0, 1)\n\n    def gen(self, n, k, s, start, count):\n        if start == n:\n            return 1\n        if start + k > n:\n            return 0\n        if count >= k:\n            return self.gen(n, k, s, start+1, count+1)\n        else:\n            return self.gen(n, k, s, start+1, count) + self.gen(n, k, s, start+1, count+1)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.numSequences(10, 5, [1,2,3,4,5]))\n    print(sol.numSequences(10, 3, [1,2,3,4,5]))\n    print(sol.numSequences(10, 5, [1,2,3,4,5]))",
      -3.7734375
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        if len(S) < L:\n            return 0\n        n = len(S)\n        dp = [0] * (L + 1)\n        for i in range(1, L + 1):\n            dp[i] = dp[i - 1] + (S[i - 1] - S[0])\n        return dp[L]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/number-of-sequences/solution/\n#\nApproach #1: Dynamic Programming [Accepted]\nComplexity Analysis\nTime Complexity: O(2^n), where n is the length of the longest prefix sum.\nSpace Complexity: O(2^n)\n\n# 7ms 100%\nclass Solution {\n    public int numSequences(int[] S, int L) {\n        if (S == null || S.length == 0 || L <= 0) return 0;\n        int n = S.length;\n        int[] dp = new int[L + 1];\n        dp[0] = 1;\n        for (int i = 1; i < L + 1; i++) {\n            dp[i] = dp[i - 1] + (S[i - 1] - S[0]);\n        }\n        return dp[L];\n    }\n}\n\n# 9ms 100%\nclass Solution {\n    public int numSequences(int[] S, int L) {\n        if (S == null || S.length == 0 || L <= 0) return 0;\n        int n = S.length;\n        int[] dp = new int[L + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;",
      -3.869140625
    ],
    [
      "import collections\n\nclass Solution:\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n        dp = collections.defaultdict(int)\n        for i in xrange(n):\n            dp[i] = 1\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                dp[j] += dp[j - 1]\n        return dp[n - 1]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numSequences([1,2,3], [1,2,3])\n    print s.numSequences([1,2,3], [3,4,5])\n    print s.numSequences([1,2,3], [1,2,3,4])\n    print s.numSequences([1,2,3], [2,3,4,5])",
      -3.947265625
    ],
    [
      "# https://leetcode.com/problems/count-and-say/\n\n\nclass Solution(object):\n    def countSequences(self, n, k, nums):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        ans = []\n        self.count(n, k, nums, 0, ans)\n        return ans\n\n    def count(self, n, k, nums, start, ans):\n        if n == 1:\n            ans.append(1)\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > n:\n                break\n            self.count(n-1, k, nums, i+1, ans)\n            self.count(n-1, k, nums, i+1, ans)",
      -4.13671875
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i == len(A):\n                return 1\n            if j == len(B):\n                return 0\n            if A[i] + B[j] < A[i]:\n                return 0\n            if A[i] + B[j] > A[i]:\n                return 1\n            return dfs(i, j + 1) + dfs(i + 1, j)\n\n        return dfs(0, 0)\n\n\nif __name__ == '__main__':\n    A = [1, 2, 3, 4]\n    B = [3, 4, 5, 6]\n    sol = Solution()\n    print(sol.numSequences(A, B))",
      -4.24609375
    ],
    [
      "#!/bin/python\n\nclass Solution:\n    def numSequences(self, n: int, k: int, a: int) -> int:\n        # DP\n        # dp[i] = number of sequences of length i\n        # dp[i] = dp[i-1] + dp[i-1]\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + dp[i - 1]\n        return dp[n - 1]\n\n    def numSequences_fast(self, n: int, k: int, a: int) -> int:\n        # DP\n        # dp[i] = dp[i-1] + dp[i-1]\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + dp[i - 1]\n        return dp[n - 1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences(1, 2, 1) == 2\n    assert Solution().numSequences(1, 2, 2) == 3\n    assert Solution().numSequences(5, 5, 5) == 5\n    assert Solution().numSequences(5, 5, 0) == 0\n    assert Solution().numSequences(5, 5, 1) == 3\n    assert Solution().numSequences(5, 5, 2) == 6\n    assert Solution().numSequences(5, 5, 3) == 10\n    assert Solution().numSequences(5, 5, 4) == 15\n    assert Solution().numSequences(5, 5, 5) == 20\n    assert Solution().numSequences(5, 5, 6) == 25\n    assert Solution().numSequences(5, 5, 7) == 35\n    assert Solution().numSequences(5, 5, 8) == 50\n    assert Solution().numSequences(5, 5, 9) == 65",
      -4.28515625
    ],
    [
      "def num_sequences(n, values):\n\t\"\"\"\n\t:type n: int\n\t:type values: List[int]\n\t:rtype: int\n\t\"\"\"\n\t# This method is to solve the problem of finding the number of sequences of given length having non-negative prefix sum.\n\t# The idea is to do the following:\n\t# 1. Create a list of all possible sequences with length n,\n\t# 2. For each sequence, calculate the prefix sum and check whether the sum is greater than 0.\n\t# 3. If the sum is greater than 0, then there is a sequence with the given prefix sum.\n\t# 4. The number of sequences with the given prefix sum is the number of ways to create the given sequence.\n\t# 5. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 6. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 7. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 8. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 9. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 10. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 11. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 12. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 13. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 14. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 15. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 16. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 17. The number of sequences with the given prefix sum is the number of all possible sequences with length n.\n\t# 18. The number of sequences with the given prefix sum is the number of all possible sequences",
      -4.44921875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if n == 0 or k == 0 or k > n:\n            return 0\n        return self.dfs(n, k, A, [])\n\n    def dfs(self, n, k, A, ans):\n        if k == 0:\n            ans.append(1)\n        else:\n            for i in range(n):\n                if i + k - 1 >= n:\n                    break\n                self.dfs(n - i - 1, k - 1, A, ans)\n                self.dfs(n - i - 1, k, A, ans)\n        return ans\n\n\nif __name__ == \"__main__\":\n    print Solution().numSequences(3, 2, [1, 2, 3])",
      -4.453125
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def numSequences(self, k, n):\n        \"\"\"\n        dp\n        :param k: the length of the subsequence\n        :param n: the number of values\n        :return: the number of subsequences\n        \"\"\"\n        res = 0\n        for i in xrange(1, k+1):\n            if i < k:\n                res += self.num_subseq(k, i, n)\n            if i == k:\n                res += self.num_subseq(k, i, n)\n\n        return res\n\n    def num_subseq(self, k, i, n):\n        \"\"\"\n        dp\n        :param k: the length of the subsequence\n        :param i: the number of elements in the subsequence\n        :param n: the number of values\n        :return: the number of subsequences\n        \"\"\"\n        if i == 0:\n            return 1\n\n        if n <= k:\n            return 0\n\n        if i == k:\n            return self.num_subseq(k-1, i, n) + self.num_subseq(k, i, n-k)\n\n        return self.num_subseq(k, i-1, n) * self.num_subseq(k-1, i, n-k)\n\n\nif __name__ == \"__main__\":\n    k = 2\n    n = 4\n    s = Solution()\n    print s.numSequences(k, n)\n\n    k = 3\n    n = 5\n    s = Solution()\n    print s.numSequences(k, n)",
      -4.5546875
    ],
    [
      "class Solution(object):\n    def numSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        def helper(length, A):\n            if length == 0:\n                return 1\n            if length == 1:\n                return A[0]\n            return sum(helper(length-1, A[1:]) for _ in range(A[0]))\n\n        return helper(len(B), A)\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences([0,1], [0,2,3]) == 1\n    assert Solution().numSequences([0,1], [0,1,2]) == 1\n    assert Solution().numSequences([0,1], [0,1,1]) == 1\n    assert Solution().numSequences([0,1], [0,1,0]) == 1\n    assert Solution().numSequences([0,1], [0,2,1]) == 2\n    assert Solution().numSequences([0,1], [0,2,2]) == 2\n    assert Solution().numSequences([0,1], [0,2,3]) == 2\n    assert Solution().numSequences([0,1], [0,1,2]) == 2\n    assert Solution().numSequences([0,1], [0,2,2]) == 2\n    assert Solution().numSequences([0,1], [0,2,3]) == 2\n    assert Solution().numSequences([0,1], [0,1,1]) == 2\n    assert Solution().numSequences([0,1], [0,1,2]) == 2\n    assert Solution().numSequences([0,1], [0,2,2]) == 3\n    assert Solution().numSequences([0,1], [0,2,3]) == 3\n    assert Solution().numSequences([0,1], [0,1,2]) == 3\n    assert Solution().numSequences([0,1], [0,2,2]) == 3\n    assert Solution().numSequences([0,1], [0,2,3]) == 3",
      -4.5703125
    ],
    [
      "class Solution:\n    def numSequences(self, s, e, k):\n        \"\"\"\n        :type s: int\n        :type e: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if s > e:\n            return 0\n        if e - s < k:\n            return 0\n        if e - s == k:\n            return 1\n        if s == 0 or e == 0:\n            return 0\n        if s == 1 or e == 1:\n            return 1\n        if k == 1:\n            return 2\n        if k == 2:\n            return 2 + self.numSequences(s - 1, e, 1)\n        if k == 3:\n            return 2 + self.numSequences(s - 1, e, 1) + self.numSequences(s - 2, e, 2)\n        if k == 4:\n            return 2 + self.numSequences(s - 1, e, 1) + self.numSequences(s - 2, e, 2) + self.numSequences(s - 3, e, 3)\n        if k == 5:\n            return 2 + self.numSequences(s - 1, e, 1) + self.numSequences(s - 2, e, 2) + self.numSequences(s - 3, e, 3) + self.numSequences(s - 4, e, 4)\n        return 2 + self.numSequences(s - 1, e, 1) + self.numSequences(s - 2, e, 2) + self.numSequences(s - 3, e, 3) + self.numSequences(s - 4, e, 4) + self.numSequences(s - 5, e, 5)",
      -4.5703125
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        if not S:\n            return 0\n        n = len(S)\n        dp = [[0] * (n + 1) for _ in range(len(T) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(T) + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j]\n                for k in range(1, j):\n                    if S[k - 1] + T[i - 1] == S[j - k]:\n                        dp[i][j] += dp[i - 1][j - k]\n        return dp[len(T)][n]\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences([1, 2, 3], [1, 2, 3]) == 0\n    assert Solution().numSequences([1, 2, 3], [1, 2, 3, 4]) == 1\n    assert Solution().numSequences([1, 2, 3], [1, 2, 3, 4, 5]) == 2\n    assert Solution().numSequences([1, 2, 3, 4, 5], [1, 2, 3, 4]) == 3\n    assert Solution().numSequences([1, 2, 3], [4, 5, 6]) == 0",
      -4.76953125
    ],
    [
      "# Definition for a prefix sum.\nclass PrefixSum:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.prefix = 0\n        self.count = 0\n        self.sums = [0] * len(self.nums)\n\n    def update(self, prefix):\n        \"\"\"\n        :type prefix: int\n        \"\"\"\n        self.prefix += prefix\n        self.sums[prefix] += 1\n        self.count += 1\n\n    def solve(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.prefix = 0\n        self.count = 0\n        self.sums = [0] * len(self.nums)\n        for i in range(len(self.nums)):\n            self.update(i)\n\n        for i in range(len(self.nums) - 1):\n            self.update(i)\n\n        return self.count\n\n\n# Your PrefixSum object will be instantiated and called as such:\n# obj = PrefixSum(nums)\n# param_1 = obj.solve()",
      -4.94921875
    ],
    [
      "# T:O(N^2), S:O(N^2), 2ms\nclass Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [[0] * n for _ in xrange(n)]\n        dp[0][0] = 1\n        for i in xrange(1, n):\n            for j in xrange(1, i):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        for j in xrange(k - 1, n):\n            for i in xrange(n):\n                dp[i][j] += dp[i][j - 1]\n        return dp[n - 1][k - 1]",
      -5.04296875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, s):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        # http://www.geeksforgeeks.org/count-number-of-sequences-with-non-negative-prefix-sums/\n        # https://leetcode.com/problems/count-subsequences-with-sum-of-k-given-values/discuss/172592/Solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # http://www.geeksforgeeks.org/count-subsequences-with-sum-of-k-given-values/\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation\n        # https://discuss.leetcode.com/topic/61173/java-solution-using-recursion-and-bit-manipulation",
      -5.17578125
    ],
    [
      "#!/bin/python\n\n# https://www.hackerrank.com/challenges/sudoku-solver\n\nimport sys\n\ndef sudokuSolver(n):\n    # Input\n    n = int(sys.stdin.readline())\n    \n    # Output\n    print(sudokuSolverHelper(n))\n\ndef sudokuSolverHelper(n):\n    # Create a list to store the sudoku values\n    sudokuValues = []\n    \n    # For every digit value, add it to the list\n    for x in range(1,n+1):\n        sudokuValues.append(x)\n    \n    # Sort the list in ascending order\n    sudokuValues.sort()\n    \n    # For every digit value, check if the current digit value is the same as the last digit\n    # If it is, then the current digit value is a sudoku value\n    # If it is not, then the current digit value is a number from 1 to 9\n    # So, for every digit value, check if the current digit value is the same as the previous digit value\n    # If it is, then the current digit value is a sudoku value\n    # If it is not, then the current digit value is a number from 1 to 9\n    for i in range(len(sudokuValues)-1):\n        if sudokuValues[i] == sudokuValues[i+1]:\n            sudokuValues[i] = sudokuValues[i+1]\n        else:\n            sudokuValues[i] = int(sudokuValues[i])\n    \n    # Count the number of sudoku values\n    count = 0\n    \n    # For every digit value, check if the current digit value is a sudoku value\n    for x in sudokuValues:\n        if x > 0 and x <= n:\n            count += 1\n    \n    # Return the number of sudoku values\n    return count\n\nif __name__ == \"__main__\":\n    sudokuSolver(int(sys.stdin.readline()))",
      -5.21484375
    ],
    [
      "import sys\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def numSequences(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # dp\n        # https://leetcode.com/problems/count-of-sequences-with-non-negative-prefix-sum/discuss/91833/Solution-using-dp\n        dp = [[0] * (target + 1) for _ in range(len(nums))]\n        dp[0][0] = 1\n        for i in range(1, len(nums) + 1):\n            for j in range(i):\n                dp[j][i] = dp[j][i - 1]\n            dp[i][i] = 1\n        for i in range(1, len(nums) + 1):\n            for j in range(i):\n                dp[j][i] = dp[j][i - 1] + dp[j + 1][i]\n        return dp[-1][-1]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.numSequences([1, 2, 3, 4], 3)\n    print s.numSequences([1, 2, 3, 4], 5)\n    print s.numSequences([], 1)\n    print s.numSequences([1, 2, 3, 4], -1)\n    print s.numSequences([], -1)\n    print s.numSequences([], -2)",
      -5.23046875
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def countSequences(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i][j] is the number of subsequences of A[:i] + B[:j] that can be generated\n        # by the sequence of A[:i] + B[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        for i in range(len(A) + 1):\n            for j in range(len(B) + 1):\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[len(A)][len(B)]\n\n\nif __name__ == \"__main__\":\n    assert Solution().countSequences([1, 2, 3], [1, 2]) == 3\n    assert Solution().countSequences([1, 2, 3], [2, 3]) == 2\n    assert Solution().countSequences([1, 2, 3], [1, 2, 3]) == 3",
      -5.38671875
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n < k:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) / 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) / 6\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) / 24\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) / 120\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) / 720\n        if k == 7:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) / 5040\n        if k == 8:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) / 362880\n        if k == 9:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) / 39916800\n        if k == 10:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) / 69984000\n        if k == 11:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n",
      -5.3984375
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def countSequences(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 1:\n            return sum(nums)\n        if k > n:\n            return 0\n        return self.countSequences_recur(nums, k, 0)\n\n    def countSequences_recur(self, nums, k, start):\n        res = 0\n        end = start\n        while end < len(nums):\n            if nums[end] > nums[end-1]:\n                res += self.countSequences_recur(nums, k-1, end)\n                end += k\n            else:\n                res += self.countSequences_recur(nums, k, end+1)\n                end += k-1\n        return res\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = int(input())\n# param_2 = int(input())\n# obj.countSequences(param_1, param_2)",
      -5.41796875
    ],
    [
      "class Solution(object):\n    def countSequences(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return self.countSequences_v1(nums, k)\n\n    def countSequences_v1(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or not k:\n            return []\n\n        length = len(nums)\n        total = 0\n        res = []\n        for i in xrange(length - k + 1):\n            total += nums[i]\n            if total == k:\n                res.append(i + 1)\n                total -= nums[i]\n\n        return res\n\n# Note:\n# 1. if the input nums is a list of integers, each element in the input list is an integer\n# 2. if the input nums is a list of strings, each element in the input list is a string\n# 3. if the input nums is a list of integers and strings, the input nums is a list of lists,\n#    each element in the input list is a list of integers or a list of strings\n\ns = Solution()\n\nnums = [1,2,3]\nk = 3\n\nprint s.countSequences(nums, k)",
      -5.625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def numSequences(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        if not S or not T:\n            return 0\n        N = len(S)\n        M = len(T)\n        if N < M:\n            return 0\n        dp = [0] * (M+1)\n        dp[0] = 1\n        for i in xrange(1, M+1):\n            dp[i] = dp[i-1] + S[i-1]\n        num = 0\n        for i in xrange(M, N+1):\n            num += dp[M-i]\n        return num\n\n\nif __name__ == \"__main__\":\n    print Solution().numSequences([1,2,3], [3,4,5])",
      -5.72265625
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def countSequences(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if root is None:\n            return []\n        # if k == 0:\n        #     return [root.val]\n        # else:\n        #     return self.countSequences(root.left, k - 1) + self.countSequences(root.right, k - 1)\n\n        res = []\n        self.countSequencesRec(root, k, res)\n        return res\n\n    def countSequencesRec(self, root, k, res):\n        if root is None:\n            return\n        if k == 0:\n            res.append(root.val)\n        else:\n            self.countSequencesRec(root.left, k - 1, res)\n            self.countSequencesRec(root.right, k - 1, res)\n\n\nif __name__ == '__main__':\n    root = TreeNode(5)\n    root.left = TreeNode(2)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(6)\n    root.right.left = TreeNode(7)\n    res = Solution().countSequences(root, 5)\n    print(res)",
      -5.875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} targetLength\n    # @param {integer[]} nums\n    # @return {integer}\n    def numSequences(self, nums, targetLength):\n        nums.sort()\n        ans = 0\n        i = 0\n        while i < len(nums):\n            if targetLength - i >= len(nums):\n                ans += 1\n                i += len(nums)\n                continue\n            # print i, targetLength\n            j = i + targetLength - 1\n            while j < len(nums) and nums[i] == nums[j]:\n                j += 1\n            ans += j - i\n            i = j + 1\n        return ans\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5,6]\n    targetLength = 6\n    print Solution().numSequences(nums, targetLength)",
      -6.02734375
    ],
    [
      "# https://leetcode.com/problems/count-and-say/discuss/137743/Easy-to-understand-Python-Code-with-explanation\n# https://www.youtube.com/watch?v=2Z1dY-Kvn6E\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 0:\n            return ''\n\n        m = [1]\n        for i in range(1, n+1):\n            m.append(m[i-1] + m[i-2])\n        return ''.join(str(i) for i in m)\n\n\nif __name__ == '__main__':\n    print(Solution().countAndSay(3))\n    print(Solution().countAndSay(1))\n    print(Solution().countAndSay(4))\n    print(Solution().countAndSay(5))",
      -6.16015625
    ],
    [
      "# Definition for a prefix sum.\nclass PrefixSum(object):\n    def __init__(self, pre, s):\n        \"\"\"\n        :type pre: List[int]\n        :type s: List[int]\n        \"\"\"\n        self.pre = pre\n        self.s = s\n        \n    def update(self, x):\n        \"\"\"\n        :type x: int\n        \"\"\"\n        self.s[0] += x\n        self.pre[0] += x\n        for i in range(1, len(self.s)):\n            self.s[i] += self.s[i-1]\n            self.pre[i] += self.pre[i-1]\n        \n    def __str__(self):\n        return str(self.s)\n\nclass Solution(object):\n    def countSequences(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        prefix = [0] * (k + 1)\n        prefix[0] = 1\n        res = []\n        for i in range(1, len(nums) + 1):\n            for j in range(0, i):\n                if prefix[j] > nums[i-j-1]:\n                    prefix[i] = prefix[j]\n                else:\n                    break\n            res.append(prefix)\n            prefix[i] = 1\n            \n        return res",
      -6.328125
    ],
    [
      "# I/O\n# - N is the number of test cases\n# - A is the list of values\n# - L is the length of the sequence\n# - S is the prefix sum of the sequence\n# - P is the prefix sum of the given values\n# - P is the prefix sum of the given values\n# - T is the maximum number of test cases\n# - M is the maximum value of the given values\n# - V is the maximum value of the given values\n# - D is the maximum value of the given values\n# - O is the maximum value of the given values\n# - X is the maximum value of the given values\n# - Y is the maximum value of the given values\n# - E is the maximum value of the given values\n# - W is the maximum value of the given values\n# - Z is the maximum value of the given values\n# - S is the prefix sum of the given values\n# - T is the maximum number of test cases\n# - M is the maximum value of the given values\n# - V is the maximum value of the given values\n# - D is the maximum value of the given values\n# - O is the maximum value of the given values\n# - X is the maximum value of the given values\n# - Y is the maximum value of the given values\n# - E is the maximum value of the given values\n# - W is the maximum value of the given values\n# - Z is the maximum value of the given values\n# - S is the prefix sum of the given values\n\n# Test cases\n# - 1\n# - 2\n# - 3\n# - 4\n# - 5\n# - 6\n# - 7\n# - 8\n# - 9\n# - 10\n# - 11\n# - 12\n# - 13\n# - 14\n# - 15\n# - 16\n# - 17\n# - 18\n# - 19\n# - 20\n# - 21\n# - 22\n# - 23\n# - 24\n# - 25\n# - 26\n# - 27\n# - 28\n# - 29\n# - 30\n# - 31\n# - 32\n# - 33\n# - 34\n# - 35\n# - 36\n# - 37\n# - 38\n# - 39\n# - 40\n# - 41\n# - 42\n# - 43\n# - 44",
      -6.48046875
    ],
    [
      "class Solution(object):\n    def numSequences(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if k > n:\n            return 0\n        sums = [0] * (n + 1)\n        for i in xrange(n):\n            sums[i] = sums[i+1] + nums[i]\n        res = 0\n        for i in xrange(n-k+1, n+1):\n            if sums[i] >= 0:\n                res += 1\n        return res\n\n\nif __name__ == '__main__':\n    nums = [2,3,1,2]\n    k = 2\n    sol = Solution()\n    print sol.numSequences(nums, k)\n    nums = [1,2,3,4]\n    k = 3\n    sol = Solution()\n    print sol.numSequences(nums, k)\n    nums = [1,2,3,4,5]\n    k = 3\n    sol = Solution()\n    print sol.numSequences(nums, k)",
      -6.50390625
    ],
    [
      "__author__ = 'Daniel'\n\nclass Solution(object):\n    def numDistinct(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[0] * (len(T) + 1) for _ in xrange(len(S) + 1)]\n        dp[0][0] = 1\n        for i in xrange(1, len(S) + 1):\n            for j in xrange(len(T) + 1):\n                if j == 0:\n                    dp[i][j] = 1\n                elif j == 1:\n                    dp[i][j] = S[i - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().numDistinct([1, 2, 3, 4], [4, 3, 2, 1]) == 4\n    assert Solution().numDistinct([1, 2, 3], [4, 3, 2, 1]) == 3\n    assert Solution().numDistinct([1, 2, 3, 4], []) == 1\n    assert Solution().numDistinct([1, 2, 3], []) == 1\n    assert Solution().numDistinct([1], [1]) == 1",
      -7.2109375
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, L):\n        \"\"\"\n        :type S: List[int]\n        :type L: int\n        :rtype: int\n        \"\"\"\n        # http://www.programcreek.com/2012/12/leetcode-num-sequences/\n        if L == 1:\n            return len(S)\n        if len(S) < L:\n            return 0\n        if L == 2:\n            return sum(S) == 0 or sum(S) == 1\n        if L == 3:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2\n        if L == 4:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3\n        if L == 5:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3 or sum(S) == 4\n        if L == 6:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3 or sum(S) == 4 or sum(S) == 5\n        if L == 7:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3 or sum(S) == 4 or sum(S) == 5 or sum(S) == 6\n        if L == 8:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3 or sum(S) == 4 or sum(S) == 5 or sum(S) == 6 or sum(S) == 7\n        if L == 9:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) == 2 or sum(S) == 3 or sum(S) == 4 or sum(S) == 5 or sum(S) == 6 or sum(S) == 7 or sum(S) == 8\n        if L == 10:\n            return sum(S) == 0 or sum(S) == 1 or sum(S) ==",
      -7.71875
    ],
    [
      "class Solution(object):\n    def numSequences(self, k, a):\n        \"\"\"\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        if len(a) < k:\n            return 0\n        for i in range(k):\n            a_len = len(a) - i\n            for j in range(a_len):\n                a_sum = 0\n                for x in a[j:a_len]:\n                    a_sum += x\n                if a_sum == 0:\n                    res += 1\n        return res\n\n    def numSequences_1(self, k, a):\n        \"\"\"\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        if len(a) < k:\n            return 0\n        for i in range(k):\n            a_len = len(a) - i\n            for j in range(a_len):\n                a_sum = 0\n                for x in a[j:a_len]:\n                    a_sum += x\n                if a_sum == 0:\n                    res += 1\n        return res\n\n    def numSequences_2(self, k, a):\n        \"\"\"\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        if len(a) < k:\n            return 0\n        for i in range(k):\n            a_len = len(a) - i\n            for j in range(a_len):\n                a_sum = 0\n                for x in a[j:a_len]:\n                    a_sum += x\n                if a_sum == 0:\n                    res += 1\n        return res\n\n    def numSequences_3(self, k, a):\n        \"\"\"\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        if len(a) < k:\n            return 0\n        for i in range(k):\n            a_len = len(a) - i",
      -8.1171875
    ],
    [
      "import math\nimport unittest\n\n\ndef find_sequences(n, values):\n    sums = []\n    for i in range(0, len(values)):\n        sums.append(values[i])\n    sums.append(0)\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        sums[i] = max(sums[i], sums[i+1])\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0, n-1):\n        if sums[i] > 0:\n            sums[i] = max(sums[i], sums[i+1])\n        else:\n            break\n\n    # get the first N-1 elements of the sequence\n    for i in range(0",
      -8.5234375
    ],
    [
      "from collections import Counter\n\nclass Solution(object):\n    def numSequences(self, n, k, a):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type a: List[int]\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for i in range(k):\n            sums = Counter(a)\n            for j in range(n - k + 1):\n                sums[j] += sums[j + k]\n            ans += sum(sums.values())\n        return ans\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences(3, 3, [1, 2, 3]) == 3\n    assert Solution().numSequences(3, 3, [1, 1, 2, 2, 3, 4]) == 5\n    assert Solution().numSequences(3, 3, [1, 1, 1, 2, 2, 3]) == 4",
      -8.6015625
    ],
    [
      "# https://oj.leetcode.com/problems/prefix-sum-ii/\n# Given an array A of integers, return the number of subsequences of A such that the prefix sum is s.\n\n# Example 1:\n# Input:\n# A = [2, 1, 3, 5, -1]\n# s = 4\n# Output: 3\n# Explanation:\n# The subsequences are [1, 2], [2, 1], [3, 2], [5, 3].\n\n# Example 2:\n# Input:\n# A = [1, 2, 3], s = 4\n# Output: 0\n# Explanation:\n# There are no subsequences that satisfy the requirement.\n\n# Note:\n# - A will have length in range [1, 100].\n# - Each element of A will be an integer in range [-1e7, 1e7].\n# - The sum of A will be in range [1, 1e9].\n\n# Related Topics\n# Math\n# Similar Questions\n# Prefix Sum Sum I\n#\n\n# Definition for a  function\nclass Solution(object):\n    def numPrefixSubseq(self, A, s):\n        \"\"\"\n        :type A: List[int]\n        :type s: int\n        :rtype: int\n        \"\"\"\n        # TLE\n        # DP\n        # 1d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP\n        # 2d DP",
      -8.7109375
    ],
    [
      "class Solution:\n    # @param {integer} numCases\n    # @param {integer} numValues\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def solve(self, numCases, numValues, nums):\n        self.result = []\n        self.result.append([0] * numValues)\n        for i in xrange(numCases):\n            self.helper(i, numValues, nums)\n\n        return self.result\n\n    def helper(self, index, numValues, nums):\n        if index >= len(nums):\n            return\n        for i in xrange(numValues):\n            self.result[index][i] += self.result[index - 1][i]\n            if self.result[index][i] >= nums[index]:\n                self.result[index][i] -= nums[index]\n                self.helper(index + 1, numValues, nums)",
      -8.828125
    ],
    [
      "import unittest\n\nclass Solution:\n    def numSequences(self, n, k, s):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - s[i - 1]]\n            res = max(res, dp[i][k])\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-and-say/solution/\n\n# Approach #1: Recursion\n# Complexity Analysis\n# Time Complexity: O(k^n) where n is the length of the prefix sum.\n# Space Complexity: O(k) for dp.\n#\n# The space complexity is O(k), since we need to maintain a copy of the prefix sum for each sequence.\n#\n# For each sequence, we need to copy the prefix sum, so we need to keep track of it.\n#\n# Approach #2: DP\n# Complexity Analysis\n# Time Complexity: O(k^n) where n is the length of the prefix sum.\n# Space Complexity: O(k) for dp.\n#\n# For each sequence, we need to copy the prefix sum, so we need to keep track of it.\n#\n# Approach #3: DP + DP\n# Complexity Analysis\n# Time Complexity: O(k^n) where n is the length of the prefix sum.\n# Space Complexity: O(k) for dp.\n#\n# For each sequence, we need to copy the prefix sum, so we need to keep",
      -9.0703125
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return 1\n        if len(A) < k:\n            return 0\n        if n == 1:\n            return 1\n        count = 0\n        for i in xrange(n):\n            count += self.numSequences(n - 1, k - 1, A)\n        return count\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/number-of-sequences-with-given-length-having-non-negative-prefix-sums/solution/\n\n# Approach 1: Binary Search\n# Complexity Analysis\n# Time Complexity: O(k log(n))\n# Space Complexity: O(k)\n# We can use the following formula to calculate the number of sequences with k elements:\n# numSequences(n, k, A) = 1 + sum(numSequences(n - 1, k - 1, A))\n# The problem is that we can only calculate the sum of subsequences, and not the number of subsequences.\n# We can use the following formula to calculate the number of subsequences:\n# numSubsequences(n, k, A) = 1 + sum(numSubsequences(n - 1, k - 1, A) * numSubsequences(n - 1, k - 2, A))\n# We can calculate the number of subsequences by using the following formula:\n# numSubsequences(n, k, A) = 1 + sum(numSubsequences(n - 1, k - 1, A) * numSubsequences(n - 1, k - 2, A))\n# Note that the subsequences of the given number can be generated by the given number, so we can calculate the number of subsequences by using the formula",
      -9.4765625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def numDecodings(self, nums, target):\n        # base case\n        if target == 0:\n            return 1\n        \n        # base case\n        if target < 0:\n            return 0\n        \n        # base case\n        if target == 1:\n            return len(nums)\n        \n        # base case\n        if target == 2:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 3:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 4:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 5:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 6:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 7:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 8:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 9:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 10:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 11:\n            return len(nums) if len(nums) == 0 else len(nums) + 1\n        \n        # base case\n        if target == 12:\n            return len(nums) if len(nums) ==",
      -9.8203125
    ],
    [
      "class Solution(object):\n    def numSequences(self, s, e, nums):\n        \"\"\"\n        :type s: int\n        :type e: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n\n        ret = 0\n        for i in xrange(s, e + 1):\n            ret += sum(nums[i - j] for j in xrange(i, e + 1))\n        return ret\n\n\nif __name__ == \"__main__\":\n    print Solution().numSequences(1, 5, [1, 2, 3, 4, 5])\n    print Solution().numSequences(1, 5, [1, 2, 3, 4, 5, 6])\n    print Solution().numSequences(1, 5, [1, 2, 3, 4, 5, 6, 7])",
      -10.3671875
    ],
    [
      "# https://oj.leetcode.com/problems/prefix-sum/discuss/1639/Java-with-explanation-solution-with-explanations\n\nclass Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        ans = 0\n        if k == 0:\n            return 1\n        if k == 1:\n            for i in range(len(A)):\n                if A[i] == 0:\n                    ans += 1\n            return ans\n        if k > 1:\n            ans += self.numSequences(n, k - 1, A)\n        for i in range(len(A) - k + 1):\n            if A[i] == 0 and A[i + k - 1] == 0:\n                ans += 1\n        return ans\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numSequences(3, 3, [0, 0, 0])\n    print s.numSequences(3, 2, [0, 1])\n    print s.numSequences(3, 2, [0, 1, 0])\n    print s.numSequences(3, 1, [0, 1, 0])\n    print s.numSequences(3, 1, [0, 1, 0, 0])\n    print s.numSequences(3, 1, [0, 1, 0, 1])\n    print s.numSequences(3, 1, [0, 1, 1])\n    print s.numSequences(3, 1, [0, 1, 1, 1])\n    print s.numSequences(3, 1, [0, 1, 1, 1, 0])\n    print s.numSequences(3, 1, [0, 1, 1, 1, 1])\n    print s.numSequences(3, 1, [0, 1, 1, 1, 1, 1])\n    print s.numSequences(3, 1, [0, 1, 1, 1, 1, 1, 1])\n    print",
      -11.8984375
    ],
    [
      "def count_sequences(n, vals):\n    \"\"\"\n    :type n: int\n    :type vals: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(len(vals)):\n        sums = [0] * n\n        for j in range(i):\n            sums[j] = vals[j] + sums[j+1]\n        for j in range(i+1, n):\n            sums[j] = vals[i] + sums[j]\n        result.append(sums[i])\n    return result\n\nif __name__ == \"__main__\":\n    assert count_sequences(4, [1, 2, 3]) == [1, 1, 1, 2]\n    assert count_sequences(4, [1, 2, 3, 3]) == [1, 1, 1, 1, 2]\n    assert count_sequences(4, [1, 2, 3, 4]) == [1, 1, 1, 1, 2, 2]\n    assert count_sequences(4, [1, 2, 3, 4, 4]) == [1, 1, 1, 1, 1, 1, 2]\n    assert count_sequences(4, [1, 2, 3, 4, 5]) == [1, 1, 1, 1, 1, 1, 1, 1, 2]",
      -11.984375
    ],
    [
      "class Solution(object):\n    def numSequences(self, S, T):\n        \"\"\"\n        :type S: List[int]\n        :type T: List[int]\n        :rtype: int\n        \"\"\"\n        S.sort()\n        T.sort()\n        return self.count(S, T)\n\n    def count(self, S, T):\n        if len(S) == 0 or len(T) == 0:\n            return 0\n        if len(S) == 1:\n            return T.count(S[0])\n        if len(S) == 2:\n            return (T.count(S[0]) + T.count(S[1])) % 2\n        count = 0\n        for i in range(len(S) - 1):\n            if S[i] == T[0]:\n                count += self.count(S[i:], T[1:])\n                break\n        return count\n\n\nif __name__ == '__main__':\n    S = [1, 2, 3]\n    T = [1, 2, 3, 4]\n    print Solution().numSequences(S, T)",
      -12.2109375
    ],
    [
      "import unittest\n\n\n# @include\n# Given a sequence of integers S, a sequence of integers T, and a length L,\n# return the number of sequences of length L that can be formed from S and T.\n# Note that the same sequence can be formed from S and T in any order.\n# @exclude\n\nclass Solution:\n    def numSequences(self, S, T, L):\n        # Apply the following formula to find the number of subsequences\n        # of length L that can be formed from S and T.\n        # (len(S) - 1) * (len(T) - 1)\n        return (L * (len(T) - 1)) // (len(S) - 1)\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([-2, 0, 1, 3, 4], [1, 3, 4], 3)\n\n    def _test(self, S, T, L):\n        actual = Solution().numSequences(S, T, L)\n        self.assertEqual(actual, expected)\n\n    def setUp(self):\n        self.expected = 1\n\nif __name__ == '__main__':\n    unittest.main()",
      -12.4921875
    ],
    [
      "class Solution(object):\n    def numSequences(self, s, t):\n        \"\"\"\n        :type s: List[int]\n        :type t: List[int]\n        :rtype: int\n        \"\"\"\n        if len(s) == 0 or len(t) == 0:\n            return 0\n\n        def dfs(s, t, n, d, sum_s, sum_t):\n            if n == 0:\n                return 1\n\n            if sum_s == sum_t:\n                return 0\n\n            if d == len(s) and sum_s == sum_t:\n                return 1\n\n            for i in xrange(len(s)):\n                if s[i] == t[i]:\n                    continue\n                else:\n                    sum_s += s[i]\n                    sum_t += t[i]\n                    new_sum_s = sum_s\n                    new_sum_t = sum_t\n                    new_n = n - 1\n                    new_d = i + 1\n                    new_seq = dfs(s[i+1:], t[i+1:], new_n, new_d, new_sum_s, new_sum_t) + \\\n                              dfs(s[:i], t[:i], new_n, new_d, new_sum_s, new_sum_t)\n                    if new_seq > 0:\n                        return new_seq\n\n            return 0\n\n        return dfs(s, t, len(s), 0, 0, 0)\n\n\nif __name__ == \"__main__\":\n    assert Solution().numSequences([2,3,2,7,3,2,1], [2,7,1,2,3,2]) == 3\n    assert Solution().numSequences([2,3,2,7,3,2,1], [2,7,2,2,3,2]) == 0\n    assert Solution().numSequences([2,3,2,7,3,2,1], [2,7,2,2,3,2,2]) == 3",
      -12.5
    ],
    [
      "from collections import Counter\nfrom math import log\n\n\ndef prefix_sum_count(n, values):\n    \"\"\"\n    :type n: int\n    :type values: List[int]\n    :rtype: int\n    \"\"\"\n    # build prefix sum list\n    prefix_sum = [0] * (n + 1)\n    for v in values:\n        prefix_sum[v] += 1\n    # traverse\n    counter = Counter(prefix_sum)\n    for k in counter:\n        if k > 0 and k <= n:\n            yield k\n    return\n\n\nif __name__ == '__main__':\n    print(prefix_sum_count(2, [3, 5, 1, 2]))\n    print(prefix_sum_count(3, [3, 5, 1, 2]))\n    print(prefix_sum_count(4, [3, 5, 1, 2]))\n    print(prefix_sum_count(5, [3, 5, 1, 2]))\n    print(prefix_sum_count(6, [3, 5, 1, 2]))\n    print(prefix_sum_count(7, [3, 5, 1, 2]))\n    print(prefix_sum_count(8, [3, 5, 1, 2]))\n    print(prefix_sum_count(9, [3, 5, 1, 2]))\n    print(prefix_sum_count(10, [3, 5, 1, 2]))",
      -12.8671875
    ],
    [
      "class Solution(object):\n    def numDecodings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        res = 0\n        # check if k is too large\n        if k > n:\n            return 0\n        # check if k is too small\n        if k < 0 or k > n:\n            return 0\n        # check if k is zero\n        if k == 0:\n            return 1\n        # check if k is one\n        if k == 1:\n            return s[0] == '0' and 1 or 0\n        # check if k is two\n        if k == 2:\n            return self.two_ways(s, 0, 1) + self.two_ways(s, 1, 0) + self.two_ways(s, 1, 1)\n        # check if k is three\n        if k == 3:\n            return self.three_ways(s, 0, 1) + self.three_ways(s, 1, 0) + self.three_ways(s, 1, 1) + self.three_ways(s, 2, 0) + self.three_ways(s, 2, 1)\n        # check if k is four\n        if k == 4:\n            return self.four_ways(s, 0, 1) + self.four_ways(s, 1, 0) + self.four_ways(s, 1, 1) + self.four_ways(s, 2, 0) + self.four_ways(s, 2, 1) + self.four_ways(s, 3, 0) + self.four_ways(s, 3, 1)\n        # check if k is five\n        if k == 5:\n            return self.five_ways(s, 0, 1) + self.five_ways(s, 1, 0) + self.five_ways(s, 1, 1) + self.five_ways(s, 2, 0) + self.five_ways(s, 2, 1) + self.five_ways(s, 3, 0) + self.five_ways(s, 3, 1) + self.five_",
      -12.9921875
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param root, a tree node\n\t# @param sum, an integer\n\t# @return a list of lists of integer\n\tdef generateTrees(self, root, sum):\n\t\t# base case\n\t\tif root is None:\n\t\t\treturn [[]]\n\t\t# recursive case\n\t\tif root.left is None and root.right is None:\n\t\t\tif sum == 0:\n\t\t\t\treturn [[root]]\n\t\t\telse:\n\t\t\t\treturn []\n\t\t# recursive case\n\t\tres = []\n\t\tres.append(self.generateTrees(root.left, sum - root.val))\n\t\tres.append(self.generateTrees(root.right, sum - root.val))\n\t\treturn res\n\nroot = TreeNode(0)\nroot.left = TreeNode(1)\nroot.right = TreeNode(2)\nroot.left.left = TreeNode(3)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(5)\nroot.right.right = TreeNode(6)\nprint(Solution().generateTrees(root, 6))",
      -14.1015625
    ],
    [
      "class Solution(object):\n    def numSequences(self, n, k, A):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if not A:\n            return 0\n        if n == 0:\n            return 1\n        ans = 0\n        for i in xrange(k):\n            sum_ = 0\n            for j in xrange(i):\n                sum_ += A[j]\n            for j in xrange(i+1, n):\n                sum_ += A[j]\n            ans += self.num_seq(n, i, sum_, A)\n        return ans\n\n    def num_seq(self, n, i, sum_, A):\n        if sum_ == 0:\n            return 1\n        if sum_ < 0:\n            return 0\n        if sum_ == n:\n            return 1\n        if sum_ == 0:\n            return 1\n        if sum_ > n:\n            return 0\n        if sum_ % n!= 0:\n            return 0\n        if sum_ < n:\n            return self.num_seq(n, i+1, sum_, A)\n        return self.num_seq(n-sum_, i+1, sum_, A)\n\n\nif __name__ == '__main__':\n    assert Solution().numSequences(2, 3, [1,2,3]) == 1\n    assert Solution().numSequences(1, 2, [1,2]) == 1\n    assert Solution().numSequences(2, 2, [1,1]) == 2\n    assert Solution().numSequences(2, 3, [1,2,3]) == 3\n    assert Solution().numSequences(3, 3, [1,2,3]) == 6\n    assert Solution().numSequences(4, 2, [1,2]) == 6\n    assert Solution().numSequences(5, 2, [1,2,3]) == 20\n    assert Solution().numSequences(5, 3, [1,2,3]) == 20\n    assert Solution().numSequences(6, 2, [1,2]) == 20",
      -15.140625
    ],
    [
      "# https://leetcode.com/problems/count-and-say/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 0:\n            return \"1\"\n        if n == 1:\n            return \"1\"\n        ret = \"1\"\n        for i in range(2, n+1):\n            ret = self.get(ret, i)\n        return ret\n\n    def get(self, ret, n):\n        if n == 1:\n            return ret\n        if n == 2:\n            return \"\".join(ret, ret[0])\n        ret1 = self.get(ret, n - 1)\n        ret2 = self.get(ret, n - 2)\n        return \"\".join(ret1, ret2[0])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.countAndSay(1))\n    print(s.countAndSay(2))\n    print(s.countAndSay(3))\n    print(s.countAndSay(4))\n    print(s.countAndSay(5))\n    print(s.countAndSay(6))\n    print(s.countAndSay(7))\n    print(s.countAndSay(8))\n    print(s.countAndSay(9))",
      -15.5078125
    ],
    [
      "from collections import defaultdict\n\n\nclass Solution(object):\n    def numDistinct(self, s, nums):\n        \"\"\"\n        :type s: str\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 1\n        if len(nums) == 1:\n            return sum(nums)\n        sums = defaultdict(int)\n        for n in nums:\n            sums[n] += 1\n        res = 0\n        for i in range(len(s)):\n            res += sum(nums[:i]) * sums[nums[i]]\n        return res\n\n\nif __name__ == '__main__':\n    assert Solution().numDistinct('123', [1, 2, 3]) == 6\n    assert Solution().numDistinct('123', [1, 2, 3, 4]) == 12\n    assert Solution().numDistinct('123', [1, 2, 3, 4, 5]) == 15",
      -15.671875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}