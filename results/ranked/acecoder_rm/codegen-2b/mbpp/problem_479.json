{
  "problem": {
    "task_id": "MBPP/490",
    "prompt": "Write a function to extract all the pairs which are symmetric in the given tuple list.",
    "canonical_solution": "def extract_symmetric(test_list):\r\n  temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res) ",
    "test_list": [
      "assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}",
      "assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}",
      "assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}"
    ],
    "challenge_test_list": [],
    "problem_id": 479
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "import itertools\nimport collections\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = sorted(nums)\n        n = len(nums)\n        if n <= 1:\n            return []\n        pairs = [[] for _ in range(n)]\n        for i in range(n-1):\n            for j in range(i+1, n):\n                pairs[i].append((nums[i], nums[j]))\n                pairs[j].append((nums[j], nums[i]))\n        return pairs\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]\n    nums = [1, 2, 3, 4, 5, 6]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sol.symmetricPairs(nums))",
      1.443359375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if len(tuple_list) <= 1:\n        return tuple_list\n    i = 0\n    j = len(tuple_list) - 1\n    while i < j:\n        if tuple_list[i] == tuple_list[j]:\n            yield tuple_list[i], tuple_list[j]\n            i += 1\n            j -= 1\n        elif tuple_list[i] < tuple_list[j]:\n            i += 1\n        else:\n            j -= 1",
      0.98388671875
    ],
    [
      "# https://leetcode.com/problems/symmetric-pairs-ii/discuss/253057/Python-O(n^2)-Time-O(n)-Space-Solution-with-hint\n# A simple way is to use the following code:\n# return [x for x in xrange(len(list)) if list[x] == list[x + 1]]\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution(object):\n    def symmetricPairs(self, list):\n        \"\"\"\n        :type list: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i, j in enumerate(list):\n            for k in range(i, len(list)):\n                if list[i] == list[k]:\n                    result.append([i, k])\n        return result",
      0.14990234375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    pairs = []\n    for i in range(len(tuple_list) - 1):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                pairs.append((i, j))\n    return pairs",
      0.096435546875
    ],
    [
      "from collections import defaultdict\n\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        dic = defaultdict(list)\n        for i, n in enumerate(nums):\n            dic[n].append(i)\n        return [i for i in dic if len(dic[i]) == 2]",
      -0.85791015625
    ],
    [
      "def symmetric_pairs(tuple_list):\n    # write your code here\n    return [i for i in tuple_list if i[0] == i[1]]\n\nif __name__ == \"__main__\":\n    tuple_list = [(\"a\", \"b\"), (\"b\", \"a\")]\n    print symmetric_pairs(tuple_list)",
      -0.85791015625
    ],
    [
      "def symmetricPairs(tuples):\n    result = []\n    for t in tuples:\n        if t[0] == t[1]:\n            result.append((t[0], t[1]))\n    return result\n\ndef main():\n    tuples = [(1,2),(1,3),(2,3),(3,1),(3,2),(3,4)]\n    pairs = symmetricPairs(tuples)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        nums.sort()\n        result = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    result.append([nums[i], nums[j]])\n        return result",
      -0.85791015625
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    return [x for x in tuple_list if symmetric_pairs(tuple_list, x)]\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n    print(symmetric_pairs(tuple_list))",
      -0.85791015625
    ],
    [
      "def get_symmetric_pairs(tuple_list):\n    symmetric_pairs = []\n    for i in range(len(tuple_list) - 1):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                symmetric_pairs.append((tuple_list[i], tuple_list[j]))\n    return symmetric_pairs\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (2, 3), (1, 3)]\n    print(get_symmetric_pairs(tuple_list))",
      -0.85791015625
    ],
    [
      "def symmetric_pairs(list):\n    pairs = []\n    for i in range(len(list) - 1):\n        for j in range(i+1, len(list)):\n            if list[i] == list[j]:\n                pairs.append((list[i], list[j]))\n    return pairs\n\nif __name__ == '__main__':\n    list = [1, 2, 3, 4]\n    pairs = symmetric_pairs(list)\n    for pair in pairs:\n        print pair",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param nums a list of integers\n    # @return a list of integer\n    def symmetricPairs(self, nums):\n        if not nums:\n            return []\n        if len(nums) == 1:\n            return [tuple(nums)]\n        l = len(nums)\n        pairs = []\n        for i in range(l):\n            for j in range(i+1, l):\n                pairs.append((nums[i], nums[j]))\n        return pairs",
      -0.85791015625
    ],
    [
      "from collections import defaultdict\nfrom itertools import combinations\nimport operator\n\ndef symmetric_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    return [(x, y) for x, y in combinations(tuples, 2) if x == y]\n\nclass Solution:\n    def symmetricPairs(self, tuples: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        :type tuples: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        pairs = symmetric_pairs(tuples)\n        pairs_symmetric = []\n        for p1, p2 in pairs:\n            if p1!= p2:\n                pairs_symmetric.append(p1)\n                pairs_symmetric.append(p2)\n        return pairs_symmetric",
      -0.85791015625
    ],
    [
      "def symmetric_pairs(tuples):\n    pairs = []\n    for i in range(0, len(tuples)):\n        for j in range(i, len(tuples)):\n            if tuples[i] == tuples[j]:\n                pairs.append((i,j))\n    return pairs\n\n\nif __name__ == \"__main__\":\n    tuples = [(1,2), (1,3), (2,3), (2,4), (3,5), (3,6), (4,5), (4,6), (5,6)]\n    print symmetric_pairs(tuples)",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def symmetricPairs(self, head):\n        if not head or not head.next:\n            return head\n        pairs = []\n        prev = head\n        current = head.next\n        while current:\n            next = current.next\n            if prev.val == current.val:\n                pairs.append(prev)\n                pairs.append(current)\n                prev = current\n            prev = current\n            current = next\n        return pairs\n\n\nif __name__ == '__main__':\n    s = Solution()\n    pairs = s.symmetricPairs([1,2,3])\n    for pair in pairs:\n        print pair.val\n    print pairs.next.val",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\ndef symmetric_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    pairs = defaultdict(list)\n    for i, t in enumerate(tuples):\n        for j, e in enumerate(t):\n            pairs[(t[j], t[i])].append((i, j))\n\n    return [p for p in pairs.items() if len(p[1]) == 2]\n\nif __name__ == '__main__':\n    tuples = [(1,2),(3,4),(5,6),(7,8)]\n    print(symmetric_pairs(tuples))",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\ndef symmetric_pairs(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = defaultdict(list)\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            res[nums[i]].append((nums[j], i, j))\n    return list(res.values())",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\nimport unittest\n\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        symmetric_pairs = defaultdict(set)\n        for num in nums:\n            symmetric_pairs[num].add(num)\n\n        return [list(pair) for pair in symmetric_pairs.items()]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3], [3, 1, 2])\n\n    def _test(self, nums, expected):\n        actual = Solution().symmetricPairs(nums)\n        self.assertEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -0.8583984375
    ],
    [
      "import collections\nimport operator\n\n# Definition for a pair.\nclass Pair(object):\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    def __repr__(self):\n        return \"({}, {})\".format(self.a, self.b)\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[Pair]\n        \"\"\"\n        symmetric_pairs = collections.defaultdict(list)\n        for pair in self.symmetric_pairs(nums):\n            symmetric_pairs[pair].append(pair)\n        return symmetric_pairs.values()\n\n    def symmetric_pairs(self, nums):\n        nums_copy = nums[:]\n        nums_copy.sort()\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i+1]:\n                nums_copy[i] = nums_copy[i+1]\n        return nums_copy\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print Solution().symmetricPairs(nums)",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    return list(symmetric_pairs_recursive(tuple_list, []))\n\ndef symmetric_pairs_recursive(tuple_list, result):\n    if len(tuple_list) < 2:\n        return result\n\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                result.append((i, j))\n\n    return symmetric_pairs_recursive(tuple_list[1:], result)\n\nif __name__ == '__main__':\n    tuple_list = [(1,2),(2,3),(3,1),(1,3),(2,1)]\n    result = symmetric_pairs(tuple_list)\n    print(result)",
      -0.8583984375
    ],
    [
      "class Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    ret.append([nums[i], nums[j]])\n        return ret",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuples):\n    \"\"\"\n    Input:\n        tuples: a list of tuples.\n\n    Output:\n        A list of pairs (a, b) where a is a tuple and b is a tuple.\n    \"\"\"\n    pairs = []\n    for i in range(len(tuples) - 1):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                pairs.append((tuples[i], tuples[j]))\n    return pairs\n\ndef main():\n    tuples = [(1, 2), (2, 3), (1, 3), (4, 5)]\n    pairs = symmetric_pairs(tuples)\n    print pairs\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "# Definition for a pair of integers.\nclass Pair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    def __repr__(self):\n        return '({}, {})'.format(self.a, self.b)\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[Pair]\n        \"\"\"\n        if not nums:\n            return []\n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    res.append(Pair(nums[i], nums[j]))\n        return res",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(data):\n    pairs = []\n    for i in range(len(data)):\n        for j in range(i+1, len(data)):\n            if data[i] == data[j] and data[i]!= i+1:\n                pairs.append((i,j))\n    return pairs\n\nif __name__ == \"__main__\":\n    pairs = symmetric_pairs([1,2,3,4,5,6])\n    print(pairs)",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuples):\n    return [x for x in tuples if len(x) == 2 and x[0] == x[1]]\n\nif __name__ == \"__main__\":\n    assert symmetric_pairs([(1, 2), (2, 1), (2, 3), (3, 2)]) == [(1, 2), (2, 3)]\n    assert symmetric_pairs([(1, 2), (2, 3), (3, 2)]) == []",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\n\n\ndef find_symmetric(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # Create a dictionary mapping each pair of elements to the number of times they appear in the list\n    d = defaultdict(int)\n    for i in tuple_list:\n        for j in i:\n            d[(i[j], i[-j-1])] += 1\n\n    # Find pairs that are symmetric in the given list\n    symmetric_pairs = []\n    for i in d:\n        if d[i] == 2:\n            symmetric_pairs.append(i)\n\n    return symmetric_pairs",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return [pair for pair in itertools.combinations(tuple_list, 2)]\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (2, 3), (1, 3), (2, 1)]\n    print(symmetric_pairs(tuple_list))",
      -0.8583984375
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __eq__(self, other):\n        return self.x == other.x\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        return self.symmetric_pairs(nums)\n\n    def symmetric_pairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0], nums[1]]\n        ret = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    ret.append((nums[i], nums[j]))\n        return ret\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [Tuple(1), Tuple(2), Tuple(3)]\n    print(sol.symmetric_pairs(nums))",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(arr):\n    \"\"\"\n    :type arr: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # Write your code here\n    return []",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuples):\n    pairs = []\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i+1, len(t)):\n                if t[i] == t[j]:\n                    pairs.append((t[i], t[j]))\n    return pairs\n\nif __name__ == '__main__':\n    t = [1, 2, 3, 4, 5]\n    pairs = symmetric_pairs(t)\n    print pairs",
      -0.8583984375
    ],
    [
      "import collections\n\ndef symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    symmetric_pairs = collections.defaultdict(list)\n    for a, b in enumerate(tuple_list):\n        for c, d in enumerate(tuple_list):\n            if a!= c:\n                if b[0] == d[0]:\n                    symmetric_pairs[a].append(c)\n                elif b[1] == d[1]:\n                    symmetric_pairs[a].append(c)\n    return symmetric_pairs\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n    print(symmetric_pairs(tuple_list))",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    return [(i,j) for i,j in tuple_list if i == j]\n\ndef main():\n    tuple_list = [(1,2),(2,3),(3,4),(4,1)]\n    print symmetric_pairs(tuple_list)\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    return [p for p in pairwise(tuple_list) if p[0] == p[1]]\n\ndef pairwise(iterable):\n    \"s -> (s0,s1), (s1,s2), (s2, s3),...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)",
      -0.8583984375
    ],
    [
      "from collections import defaultdict\nimport operator\n\n\ndef symmetric_pairs(tuple_list):\n    return defaultdict(int)\n\n\ndef test_symmetric_pairs():\n    assert symmetric_pairs(['a', 'b', 'c']) == {'a': 'c', 'b': 'c'}\n    assert symmetric_pairs(['a', 'b', 'c', 'd']) == {'a': 'd', 'b': 'd'}\n    assert symmetric_pairs(['a', 'b', 'c', 'd', 'e']) == {'a': 'd', 'b': 'd', 'c': 'e', 'd': 'e'}\n\n\nif __name__ == '__main__':\n    test_symmetric_pairs()",
      -0.85888671875
    ],
    [
      "def symmetric_pairs(tupleList):\n    # write your code here\n    return\n\ntupleList = [1, 2, 3, 4, 5, 6, 7, 8]\nsymmetric_pairs(tupleList)",
      -0.85888671875
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    result = []\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                result.append((i, j))\n    return result\n\ndef main():\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5)]\n    print(symmetric_pairs(tuple_list))\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "def symmetric_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            if tuples[i][j] == tuples[j][i]:\n                res.append([tuples[i][j], tuples[j][i]])\n    return res\n\n# Your SymmetricPairs object will be instantiated and called as such:\n# obj = SymmetricPairs(tuples)\n# param_1 = obj.symmetric_pairs(tuples)",
      -0.85888671875
    ],
    [
      "import collections\n\ndef symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    result = collections.defaultdict(list)\n    for i, t in enumerate(tuple_list):\n        for j, s in enumerate(tuple_list[i:]):\n            if t == s:\n                result[tuple_list[i]].append(tuple_list[j])\n    return result.values()\n\nif __name__ == '__main__':\n    tuple_list = [('a', 'b'), ('c', 'd'), ('e', 'f'), ('g', 'h'), ('i', 'j'), ('k', 'l'), ('m', 'n'), ('o', 'p')]\n    print(symmetric_pairs(tuple_list))",
      -0.85888671875
    ],
    [
      "from collections import defaultdict\nfrom functools import reduce\n\ndef symmetric_pairs(tuple_list):\n    pairs = []\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                pairs.append((tuple_list[i], tuple_list[j]))\n    return pairs\n\nif __name__ == \"__main__\":\n    tuple_list = (1,2,3,4,5,6)\n    pairs = symmetric_pairs(tuple_list)\n    print(pairs)\n    assert(len(pairs) == 2)\n    assert(pairs == [(1,2), (3,4), (5,6)])",
      -0.85888671875
    ],
    [
      "import collections\n\ndef symmetric_pairs(list):\n    \"\"\"\n    :type list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if len(list) <= 1:\n        return list\n    res = collections.defaultdict(set)\n    for i in range(len(list)):\n        for j in range(i+1, len(list)):\n            if list[i][j] == list[j][i]:\n                res[list[i][j]].add(list[i][j])\n    return list[:]",
      -0.85888671875
    ],
    [
      "import unittest\nfrom collections import defaultdict\n\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = sorted(nums)\n        result = defaultdict(list)\n        for i in range(len(nums)):\n            result[nums[i]].append(nums[(i + 1) % len(nums)])\n        return [x for x in result.items() if len(x[1]) == len(x[0])]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4], [1, 3, 4, 2])\n\n    def _test(self, nums, expected):\n        actual = Solution().symmetricPairs(nums)\n        self.assertCountEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -0.85888671875
    ],
    [
      "def symmetric_pairs(tuple_list):\n\t# sort the list, to make it easier to process the list\n\ttuple_list.sort()\n\t# create a set of all the symmetric pairs\n\tsymmetric_pairs = set()\n\tfor i in range(len(tuple_list) - 1):\n\t\tfor j in range(i + 1, len(tuple_list)):\n\t\t\tif tuple_list[i] == tuple_list[j]:\n\t\t\t\tsymmetric_pairs.add((i, j))\n\treturn symmetric_pairs\n\ntuple_list = [\n\t(1, 2),\n\t(1, 3),\n\t(2, 3),\n\t(1, 4),\n\t(2, 4),\n\t(3, 4),\n\t(1, 5),\n\t(2, 5),\n\t(3, 5),\n\t(4, 5),\n\t(1, 6),\n\t(2, 6),\n\t(3, 6),\n\t(4, 6),\n\t(5, 6)\n]\n\nprint(symmetric_pairs(tuple_list))",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param nums a list of integers\n    # @return a list of pairs of integers\n    def symmetricPairs(self, nums):\n        ret = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    ret.append((i, j))\n        return ret\n\ns = Solution()\nprint s.symmetricPairs([1, 2, 3, 4, 5])",
      -0.86083984375
    ],
    [
      "from collections import defaultdict\n\ndef symmetric_pairs(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    symmetric_pairs = defaultdict(list)\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            symmetric_pairs[lst[i]].append(lst[j])\n    return symmetric_pairs.values()\n\nif __name__ == '__main__':\n    print(symmetric_pairs([1, 2, 3, 4]))\n    print(symmetric_pairs([2, 3, 4, 1]))\n    print(symmetric_pairs([1, 2, 3, 4, 5, 6]))\n    print(symmetric_pairs([1, 2, 3, 4, 5]))",
      -0.92333984375
    ],
    [
      "from collections import defaultdict\n\ndef symmetricPairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    result = defaultdict(list)\n    for t in tuples:\n        for i in range(len(t)):\n            result[t[i]].append(t[(i + 1) % len(t)])\n    return [result[i] for i in sorted(result.keys())]\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (2, 1), (1, 3), (3, 1), (2, 4), (4, 2), (3, 5), (5, 3)]\n    print(symmetricPairs(tuples))",
      -0.96923828125
    ],
    [
      "from collections import defaultdict\n\n\nclass SymmetricPairs(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.dict = defaultdict(list)\n\n    def findSymmetric(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.dict.clear()\n        for i in range(len(nums)):\n            self.dict[nums[i]].append(nums[i+1])\n        return list(self.dict.keys())\n\n\n# Your SymmetricPairs object will be instantiated and called as such:\n# obj = SymmetricPairs()\n# param_1 = obj.findSymmetric(nums)",
      -1.1689453125
    ],
    [
      "# https://www.hackerrank.com/challenges/symmetric-pairs/problem\n\nimport unittest\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        symmetric_pairs = []\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    symmetric_pairs.append([nums[i], nums[j]])\n        return symmetric_pairs\n\n\nclass TestCode(unittest.TestCase):\n    def test_symmetricPairs(self):\n        self.assertEqual(Solution().symmetricPairs([1, 2, 3]), [[1, 3], [2, 3]])\n        self.assertEqual(Solution().symmetricPairs([1, 1]), [])\n        self.assertEqual(Solution().symmetricPairs([-1, 1]), [[-1, 1]])\n\nif __name__ == \"__main__\":\n    unittest.main()",
      -1.3369140625
    ],
    [
      "import unittest\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass SymmetricTreePairs:\n    def __init__(self):\n        self.symmetric_pairs = []\n\n    def add_pair(self, left, right):\n        self.symmetric_pairs.append((left, right))\n\n    def is_symmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            return self.is_symmetric(root.left) and self.is_symmetric(root.right)\n        return False\n\n    def is_symmetric_recursive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is not None and root.right is not None:\n            if not self.is_symmetric_recursive(root.left) or not self.is_symmetric_recursive(root.right):\n                return False\n        return self.is_symmetric_recursive(root.left) and self.is_symmetric_recursive(root.right)\n\n\nclass TestSymmetricTreePairs(unittest.TestCase):\n    def test_symmetric_tree_pairs(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(2)\n        root.left.left = TreeNode(3)\n        root.left.right = TreeNode(3)\n        root.right.left = TreeNode(3)\n        root.",
      -1.3408203125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def symmetricPairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.helper(root)\n\n    def helper(self, root):\n        if root is None:\n            return []\n        pairs = []\n        self.helper(root.left)\n        self.helper(root.right)\n        for i in range(len(pairs)):\n            pairs[i] = pairs[i][::-1]\n        return pairs",
      -1.4638671875
    ],
    [
      "import unittest\n\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) <= 1:\n            return [[nums[0]]]\n\n        res = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    res.append([nums[i], nums[j]])\n        return res\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4], [[1, 2], [1, 4], [2, 1], [2, 4], [3, 1], [3, 4], [4, 1], [4, 2]])\n\n    def _test(self, nums, expected):\n        actual = Solution().symmetricPairs(nums)\n        self.assertCountEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -1.470703125
    ],
    [
      "import timeit\n\nstart_time = timeit.default_timer()\n\n\ndef symmetric_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    return [t for t in tuples if t[0] == t[1]]\n\n\n\nprint(\"--- test 1 ---\")\nprint(\"--- test 1 (python) ---\")\n\npairs = symmetric_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\nprint(pairs)\n\nprint(\"--- test 2 ---\")\nprint(\"--- test 2 (python) ---\")\n\npairs = symmetric_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\nprint(pairs)\n\nprint(\"--- test 3 ---\")\nprint(\"--- test 3 (python) ---\")\n\npairs = symmetric_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\nprint(pairs)\n\nprint(\"--- test 4 ---\")\nprint(\"--- test 4 (python) ---\")\n\npairs = symmetric_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\nprint(pairs)\n\nprint(\"--- test 5 ---\")\nprint(\"--- test 5 (python) ---\")\n\npairs = symmetric_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\nprint(pairs)\n\nprint(\"--- test 6 ---\")",
      -1.4794921875
    ],
    [
      "def symmetric_pairs(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    pairs = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j]:\n                pairs.append((i, j))\n    return pairs\n\nif __name__ == \"__main__\":\n    assert symmetric_pairs([1, 2, 3]) == [(0, 1), (0, 2), (1, 2)]\n    assert symmetric_pairs([1, 2, 3, 4]) == [(0, 1), (1, 2), (2, 3), (0, 3)]\n    assert symmetric_pairs([1, 2, 3, 4, 5]) == [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4)]",
      -1.7265625
    ],
    [
      "class Solution:\n    # @param {List[List[int]]} nums\n    # @return {List[List[int]]}\n    def symmetricPairs(self, nums):\n        n = len(nums)\n        if n < 2:\n            return []\n\n        pairs = []\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if nums[i][j] == nums[j][i]:\n                    pairs.append([i, j])\n        return pairs\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.symmetricPairs([[1, 2], [1, 3], [2, 3], [1, 1], [3, 3]])",
      -1.7353515625
    ],
    [
      "#!/bin/python\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # return [[i, j] for i in range(len(nums)) for j in range(i)]\n        res = []\n        for i in range(len(nums)):\n            for j in range(i):\n                res.append([nums[i], nums[j]])\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    # print(sol.symmetricPairs([1, 2, 2, 3, 3, 4]))\n    # print(sol.symmetricPairs([2, 2]))\n    print(sol.symmetricPairs([1, 2, 3, 4]))",
      -2.087890625
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        nums.sort()\n        pairs = [[n, n] for n in nums]\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    pairs[i].append(nums[j])\n        return pairs\n\n\nif __name__ == \"__main__\":\n    print Solution().symmetricPairs([1, 1, 2])",
      -2.224609375
    ],
    [
      "# https://leetcode.com/problems/symmetric-pairs/\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        pairs = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    pairs.append([nums[i], nums[j]])\n        return pairs",
      -2.41796875
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if len(tuple_list) == 0:\n        return []\n    \n    return [(t, t[::-1]) for t in tuple_list]\n\nif __name__ == '__main__':\n    tuple_list = [('a', 'b'), ('b', 'a'), ('a', 'c'), ('c', 'a'), ('c', 'b'), ('b', 'c')]\n    print(symmetric_pairs(tuple_list))",
      -2.638671875
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    res.append([nums[i], nums[j]])\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n\n# 7ms 100%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] == nums[j]) {\n                    res.add(Arrays.asList(nums[i], nums[j]));\n                }\n            }\n        }\n        return res;\n    }\n}\n\n# 6ms 100%\npublic class Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] == nums[j]) {\n                    res.add(Arrays.asList(nums[i], nums[j]));\n                }\n            }\n        }\n        return res;\n    }\n}\n\n# 6ms 100%\npublic class Solution {",
      -2.79296875
    ],
    [
      "import collections\n\ndef symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    symmetric_pairs = []\n    pairs = collections.defaultdict(list)\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            pairs[tuple_list[i]].append(tuple_list[j])\n            pairs[tuple_list[j]].append(tuple_list[i])\n    for key in pairs:\n        if len(pairs[key]) == 2:\n            symmetric_pairs.append(key)\n    return symmetric_pairs\n\n\nif __name__ == '__main__':\n    tuple_list = [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e')]\n    symmetric_pairs = symmetric_pairs(tuple_list)\n    print(symmetric_pairs)\n    symmetric_pairs = symmetric_pairs\n    print(symmetric_pairs)",
      -2.833984375
    ],
    [
      "# T = (1,2,3,4,5,6,7,8,9)\n# A = [(1,2),(3,4),(5,6),(7,8),(9,1)]\n# B = [(2,4),(6,8),(1,7),(3,5),(5,9)]\n# C = [(4,8),(8,1),(9,3),(7,5),(5,9)]\n# D = [(1,3),(3,5),(5,7),(7,9),(9,1)]\n# E = [(2,6),(6,8),(8,1),(9,3),(7,5)]\n# F = [(2,3),(4,5),(6,8),(7,9),(8,1)]\n# G = [(3,5),(4,6),(5,7),(7,9),(8,1)]\n# H = [(4,8),(5,9),(6,7),(7,1),(8,3)]\n# I = [(5,9),(7,1),(8,3),(9,4),(1,2)]\n# J = [(7,1),(8,3),(9,4),(1,2),(3,5)]\n# K = [(9,1),(7,3),(8,4),(1,2),(3,5)]\n# L = [(9,1),(7,3),(8,4),(1,2),(5,6)]\n# M = [(9,1),(7,3),(8,4),(1,2),(6,8)]\n# N = [(9,1),(7,3),(8,4),(1,2),(6,7)]\n# O = [(9,1),(7,3),(8,4),(1,2),(6,8),(5,6)]\n# P = [(9,1),(7,3),(8,4),(1,2),(6,7),(5,8)]\n# Q = [(9,1),(7,3),(8",
      -2.96484375
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    # write your code here\n    if not tuple_list:\n        return []\n\n    result = []\n    for i in range(len(tuple_list) - 1):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                result.append((tuple_list[i], tuple_list[j]))\n\n    return result\n\n\n# Your Solution\n# @return a list of tuples\ndef symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    result = []\n    for i in range(len(tuple_list) - 1):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                result.append((tuple_list[i], tuple_list[j]))\n\n    return result\n\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (2, 1), (3, 4)]\n    print(symmetric_pairs(tuple_list))\n\n    tuple_list = [(1, 2), (2, 1), (3, 4)]\n    print(symmetric_pairs(tuple_list))",
      -3.0078125
    ],
    [
      "import unittest\n\n# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if not nums:\n            return []\n        return [(nums[i], nums[j]) for i in range(len(nums)) for j in range(i+1, len(nums)) if nums[i].x == nums[j].x and nums[i].y == nums[j].y]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n\nApproach 1: Brute Force\nComplexity Analysis\nTime Complexity: O(n^2), where n is the length of the list.\nSpace Complexity: O(n^2)\n\n# 72ms 99.54%\nclass Solution {\n    public List<Tuple> symmetricPairs(List<Tuple> nums) {\n        if (nums.size() == 0) return new ArrayList<>();\n        List<Tuple> res = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums.get(i).x == nums.get(j).x && nums.get(i).y == nums.get(j).y) {\n                    res.add(nums.get(i));\n                    res.add(nums.get(j));\n                }\n            }\n        }\n        return res;\n    }\n}\n\nApproach 2: HashMap\nComplexity Analysis\nTime Complexity",
      -3.0625
    ],
    [
      "# https://www.hackerrank.com/challenges/symmetric-pairs/problem\n# In the worst case, the output can be a list of pairs which are not symmetric in the given list.\n# If there are no symmetric pairs, the output should be empty.\n\n# NOTE: There is a faster way to do this.\n# Instead of sorting the list, we can do a binary search.\n\n# The input is a tuple list.\n# The output is a list of pairs which are symmetric in the given list.\n\ndef symmetricPairs(tupleList):\n    # Create a list of all pairs in the tuple list.\n    pairs = []\n    for i in range(len(tupleList) - 1):\n        for j in range(i + 1, len(tupleList)):\n            pairs.append((tupleList[i], tupleList[j]))\n\n    # Sort the pairs.\n    pairs.sort()\n\n    # Create a list of the symmetric pairs.\n    symmetricPairs = []\n    i = 0\n    while i < len(pairs):\n        j = i + 1\n        while j < len(pairs):\n            if pairs[i] == pairs[j]:\n                symmetricPairs.append(pairs[i])\n                i = j\n            else:\n                j += 1\n    return symmetricPairs",
      -3.076171875
    ],
    [
      "class Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # using a dict to store the pairs\n        # if a pair has the same value, it means they are symmetric\n        # if a pair has different value, it means they are not symmetric\n        pairs = {}\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                pairs[(nums[i], nums[j])] = pairs.get((nums[j], nums[i]), 0) + 1\n\n        return pairs.keys()\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.symmetricPairs([1,2,2,3,3,3,4]))",
      -3.10546875
    ],
    [
      "def symmetric_pairs(list):\n    \"\"\"\n    :type list: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    symmetric_pairs = []\n    for i in range(len(list)-1):\n        for j in range(i+1, len(list)):\n            if list[i] == list[j]:\n                symmetric_pairs.append([list[i], list[j]])\n\n    return symmetric_pairs\n\nif __name__ == \"__main__\":\n    assert symmetric_pairs(list(range(10))) == [[0, 1], [1, 0], [0, 9], [9, 0], [1, 9], [9, 1]]\n    assert symmetric_pairs(list(range(10))) == [[0, 1], [1, 0], [0, 9], [9, 0], [1, 9], [9, 1]]",
      -3.345703125
    ],
    [
      "import unittest\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import OrderedDict\n\nclass Solution(object):\n    def symmetricDifference(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        counter = Counter(A)\n        counter.update(B)\n        counter = OrderedDict(sorted(counter.items(), key=lambda x: x[1], reverse=True))\n        return [i for i in A if i not in counter or i not in B]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-difference-ii/solution/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }",
      -3.96875
    ],
    [
      "def symmetric_pairs(tuple_list):\n    return [tuple(i) for i in zip(*tuple_list)]\n\nif __name__ == '__main__':\n    print symmetric_pairs([1, 2, 3, 4])\n    print symmetric_pairs([2, 3, 4, 1])\n    print symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213",
      -4.33984375
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # https://www.geeksforgeeks.org/dynamic-programming-set-1-symmetric-pairs/\n        result = [[0] * len(nums) for _ in range(len(nums))]\n        for i in range(1, len(nums)):\n            for j in range(i, len(nums)):\n                result[i][j] = result[j][i]\n                result[i][j] += result[i][j - 1]\n        return result\n\ns = Solution()\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(s.symmetricPairs(nums))",
      -4.48046875
    ],
    [
      "import unittest\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = list(sorted(nums))\n        pairs = [[nums[0], nums[i]] for i in range(len(nums))]\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    pairs.append([nums[i], nums[j]])\n        return pairs\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4], [[1, 2], [2, 4], [4, 1], [1, 3], [3, 1]])\n\n    def _test(self, nums, expected):\n        actual = Solution().symmetricPairs(nums)\n        self.assertEqual(expected, actual)\n\nif __name__ == '__main__':\n    unittest.main()",
      -4.62109375
    ],
    [
      "def symmetricPairs(tupleList):\n    # write your code here\n    if len(tupleList) == 0:\n        return []\n    pairs = []\n    for i in range(len(tupleList)-1):\n        for j in range(i+1, len(tupleList)):\n            if tupleList[i] == tupleList[j]:\n                pairs.append([tupleList[i], tupleList[j]])\n    return pairs\n\ntupleList = [('a', 'b'), ('b', 'a'), ('a', 'c'), ('c', 'a'), ('c', 'b'), ('b', 'c')]\nprint(symmetricPairs(tupleList))",
      -4.91796875
    ],
    [
      "# https://leetcode.com/problems/symmetric-pairs/\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport collections\nclass Solution:\n    def symmetricPairs(self, root: TreeNode) -> List[List[int]]:\n        symmetric_pairs = collections.defaultdict(list)\n        self.symmetric_pairs(root, symmetric_pairs)\n        return symmetric_pairs.values()\n\n    def symmetric_pairs(self, root, symmetric_pairs):\n        if not root:\n            return\n\n        self.symmetric_pairs(root.left, symmetric_pairs)\n        self.symmetric_pairs(root.right, symmetric_pairs)\n\n        if root.left and root.right:\n            symmetric_pairs[root.val].append(root.left.val)\n            symmetric_pairs[root.val].append(root.right.val)\n\n    def symmetricPairs(self, root: TreeNode) -> List[List[int]]:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        result = []\n        self.symmetric_pairs(root, result)\n        return result",
      -4.93359375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        two pointers\n        :param nums: a list of integers\n        :return: a list of tuples of integers\n        \"\"\"\n        # two pointers\n        n = len(nums)\n        if n < 2:\n            return nums\n\n        p1, p2 = 0, 0\n        while p1 < n and p2 < n:\n            if nums[p1] == nums[p2]:\n                p1 += 1\n                p2 += 1\n            else:\n                if p1 < p2:\n                    yield (nums[p1], nums[p2])\n                p1 += 1\n                p2 += 1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 1, 1, 1]\n    print(sol.symmetricPairs(nums))\n    nums = [1, 1, 1]\n    print(sol.symmetricPairs(nums))",
      -4.953125
    ],
    [
      "import collections\n\n\ndef symmetric_pairs(pairs):\n    return list(map(lambda t: [t[0], t[1]], collections.Counter(pairs).most_common()))\n\n\nif __name__ == \"__main__\":\n    pairs = [(1, 2), (1, 2), (1, 3), (2, 4), (2, 4), (2, 5), (3, 4), (3, 4), (3, 5)]\n    print(symmetric_pairs(pairs))",
      -4.96875
    ],
    [
      "# Definition for a pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[Pair]\n        \"\"\"\n        # The idea is to keep track of the pairs that are not symmetric.\n        # if a pair is symmetric, then the left and right side should be equal.\n        # if a pair is not symmetric, then the left and right side should not be equal.\n        # The idea is to keep track of the pairs that are symmetric.\n        # If a pair is symmetric, then the left and right side should be equal.\n        # If a pair is not symmetric, then the left and right side should not be equal.\n        # So the result will be a list of pairs that are symmetric.\n        result = []\n        for pair in nums:\n            # check if pair is symmetric\n            if (pair.x, pair.y)!= (pair.y, pair.x):\n                result.append(pair)\n        return result",
      -5.4296875
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # the idea is to use the symmetry as the key\n        # so the output is ordered by the symmetry\n        # but the output is not guaranteed to be ordered\n\n        # store pairs as list\n        # [list1, list2, list3]\n        symmetric_pairs = []\n        for i in xrange(len(nums)):\n            for j in xrange(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    symmetric_pairs.append([nums[i], nums[j]])\n\n        return symmetric_pairs\n\n\nif __name__ == \"__main__\":\n    print Solution().symmetricPairs([1, 2, 2, 2, 3, 1])",
      -5.8125
    ],
    [
      "def pairs(tuple_list):\n    if len(tuple_list) == 1:\n        return [(tuple_list[0], tuple_list[0])]\n    pairs = []\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            if i == j:\n                continue\n            if tuple_list[i] == tuple_list[j]:\n                pairs.append((tuple_list[i], tuple_list[j]))\n    return pairs\n\nif __name__ == \"__main__\":\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n    print pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])",
      -5.99609375
    ],
    [
      "from collections import defaultdict\n\n\ndef symmetric_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    return [\n        (a, b)\n        for a, b in tuples\n        if (a, b)!= (b, a)\n    ]\n\n\ndef main():\n    tuples = [(1, 2), (1, 3), (2, 3), (3, 1), (3, 2)]\n    print(symmetric_pairs(tuples))\n\n\nif __name__ == '__main__':\n    main()",
      -6.1796875
    ],
    [
      "import collections\n\ndef symmetric_pairs(tuple_list):\n    pairs = collections.defaultdict(list)\n    for pair in tuple_list:\n        pairs[pair].append(pair)\n    return pairs\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4), (1, 5), (2, 5), (3, 5)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 11)]\n    print(symmetric_pairs(tuple_list))\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6",
      -6.34765625
    ],
    [
      "import collections\n\ndef symmetric_pairs(items):\n    pairs = []\n    for i in range(len(items)):\n        for j in range(i+1, len(items)):\n            if items[i] == items[j]:\n                pairs.append((items[i], items[j]))\n    return pairs\n\nif __name__ == '__main__':\n    items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208",
      -6.53515625
    ],
    [
      "# TODO:\n# 1. Implement a solution using the list comprehension\n# 2. Implement a solution using the dictionary comprehension\n# 3. Implement a solution using the recursion\n\n# Example\n# For input [[1, 2], [2, 3], [1, 1], [1, 3], [3, 3], [2, 2]]\n# [[1, 2], [2, 3], [1, 1], [1, 3], [3, 3], [2, 2]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1, 1], [1, 3], [3, 3]]\n# [[1, 2], [2, 3], [3, 3], [1,",
      -6.546875
    ],
    [
      "from collections import defaultdict\nfrom functools import reduce\n\n# https://www.youtube.com/watch?v=X_qd4K9U2s0\n\n# pair = (a, b)\n# sym = (a, b)\n# sym2 = (b, a)\n# sym3 = (a, b, c)\n# sym4 = (a, b, c, d)\n# sym5 = (a, b, c, d, e)\n\n\ndef symmetries(arr):\n    \"\"\"\n    :param arr: list\n    :return: list of pairs\n    \"\"\"\n    pairs = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                pairs.append((arr[i], arr[j]))\n    return pairs\n\n\ndef symmetries2(arr):\n    \"\"\"\n    :param arr: list\n    :return: list of pairs\n    \"\"\"\n    pairs = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                pairs.append((arr[i], arr[j]))\n    return pairs\n\n\ndef symmetries3(arr):\n    \"\"\"\n    :param arr: list\n    :return: list of pairs\n    \"\"\"\n    pairs = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                pairs.append((arr[i], arr[j]))\n    return pairs\n\n\ndef symmetries4(arr):\n    \"\"\"\n    :param arr: list\n    :return: list of pairs\n    \"\"\"\n    pairs = []\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                pairs.append((arr[i], arr[j]))\n    return pairs\n\n\ndef symmetries5",
      -6.625
    ],
    [
      "from collections import defaultdict\n\ndef symmetric_pairs(items):\n    \"\"\"\n    :type items: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    pairs = defaultdict(set)\n    for i, j in items:\n        pairs[(i, j)].add((j, i))\n    return [x for x in pairs.keys() if len(pairs[x]) == 2]\n\nif __name__ == \"__main__\":\n    assert symmetric_pairs([(1, 2), (2, 1), (2, 3), (3, 2), (4, 2), (4, 3), (1, 4), (3, 1), (1, 3), (4, 1), (4, 3), (4, 4)]) == [\n        (2, 1),\n        (1, 2),\n        (3, 1),\n        (4, 1),\n        (4, 3),\n        (4, 4),\n    ]\n    assert symmetric_pairs([(1, 2), (2, 1), (2, 3), (3, 2), (4, 2), (4, 3), (1, 4), (3, 1), (1, 3), (4, 1), (4, 3), (4, 4)]) == []",
      -6.95703125
    ],
    [
      "# Your function should return a list of all symmetric pairs.\n# e.g. [[1, 2], [1, 3], [2, 3]] -> [[1, 3], [2, 3]]\n#      [[1, 2], [2, 1]] -> [[1, 2]]\n#      [[1, 2], [3, 1]] -> [[1, 3], [2, 3]]\n\ndef symmetric_pairs(arr):\n    arr_len = len(arr)\n    pairs = []\n    for i in range(arr_len):\n        for j in range(i+1, arr_len):\n            if arr[i] == arr[j]:\n                pairs.append([arr[i], arr[j]])\n    return pairs\n\nif __name__ == '__main__':\n    arr = [1, 2, 3]\n    pairs = symmetric_pairs(arr)\n    print(pairs)",
      -7.0859375
    ],
    [
      "class Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return [nums[i:j] for i, j in zip(nums, nums[1:]) if j == i]\n\n\ndef main():\n    nums = [1, 2, 3, 1, 2, 3]\n    print(Solution().symmetricPairs(nums))\n    nums = [1, 2, 2, 2]\n    print(Solution().symmetricPairs(nums))\n    nums = [1, 1, 2, 2]\n    print(Solution().symmetricPairs(nums))\n    nums = [1, 1, 1, 1]\n    print(Solution().symmetricPairs(nums))\n    nums = [1, 2, 2, 3, 3, 3, 3, 3, 3]\n    print(Solution().symmetricPairs(nums))\n    nums = [1, 2, 3, 3, 2, 1, 2, 3, 3]\n    print(Solution().symmetricPairs(nums))\n\nif __name__ == '__main__':\n    main()",
      -7.95703125
    ],
    [
      "import unittest\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.symmetricPairs_dp(nums)\n\n    def symmetricPairs_dp(self, nums):\n        n = len(nums)\n        ret = []\n        if n < 2:\n            return ret\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    ret.append([nums[i], nums[j]])\n        return ret\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pair-in-sorted-array/solution/\n\n# 7ms 97.63%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n        if (nums.length < 2) {\n            return ret;\n        }\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] == nums[j]) {\n                    ret.add(Arrays.asList(nums[i], nums[j]));\n                }\n            }\n        }\n        return ret;\n    }\n}\n\n# 8ms 75.97%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n        if (nums.length < 2) {\n            return ret;\n        }\n        for (int i = 0; i < nums.length;",
      -8.46875
    ],
    [
      "# https://www.hackerrank.com/challenges/symmetric-pairs/problem\n\n# Returns a list of tuples where each tuple is a pair of elements\ndef symmetric_pairs(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_2(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_3(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_4(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_5(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_6(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_7(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_8(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_list_9(pairs):\n    return [(i,j) for i in pairs for j in pairs if i!=j]\n\n# Returns a list of symmetric pairs\ndef symmetric_pairs_",
      -8.796875
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # naive solution\n        return self.symmetricPairs_naive(nums)\n\n    def symmetricPairs_naive(self, nums):\n        # return [list(i) for i in zip(*[i]*2 for i in nums)]\n        pairs = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    pairs.append([nums[i], nums[j]])\n        return pairs\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n#\n# Approach #1: Sort\n# Complexity Analysis\n# Time Complexity: O(n^2), where n is the length of the input array.\n# Space Complexity: O(n^2) for the output array.\n#\n# Approach #2: Sort and Reverse\n# Complexity Analysis\n# Time Complexity: O(n^2), where n is the length of the input array.\n# Space Complexity: O(1) for the output array.\n#\n# Approach #3: Sort and Reverse in-place\n# Complexity Analysis\n# Time Complexity: O(n^2), where n is the length of the input array.\n# Space Complexity: O(1) for the output array.\n\n# 7ms 99.29%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < nums.length; i",
      -9.265625
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        symmetric = []\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    symmetric.append([nums[i], nums[j]])\n        return symmetric\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n\n# Approach 1: Brute Force\n# Complexity Analysis\n# Time Complexity: O(n^2) where n is the size of the list\n# Space Complexity: O(n)\n#\n# Solution 1: Iterate over the list and if the value is found in the symmetric pair list, we can get the index of the pair.\n# Time Complexity: O(n^2)\n# Space Complexity: O(n)\n#\n# Approach 2: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(n^2) where n is the size of the list\n# Space Complexity: O(n)\n#\n# Solution 2: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(n^2) where n is the size of the list\n# Space Complexity: O(n)\n#\n# Approach 3: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(n^2) where n is the size of the list\n# Space Complexity: O(n)\n#\n# Solution 3: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(n^2) where n is the size of the list\n# Space Complexity: O(n)\n#\n# Approach 4: Two Pointers\n# Complexity Analysis\n# Time Complexity: O(n^2",
      -9.4453125
    ],
    [
      "def symmetric_pairs(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    pairs = []\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i] == tuple_list[j]:\n                pairs.append((tuple_list[i], tuple_list[j]))\n\n    return pairs\n\n\nif __name__ == \"__main__\":\n    tuple_list = [(1,2), (2,3), (3,4)]\n    assert symmetric_pairs(tuple_list) == [(1, 2), (2, 3), (3, 4)]\n    tuple_list = [(1,2), (2,3), (1,3)]\n    assert symmetric_pairs(tuple_list) == [(1, 2), (2, 3)]\n    tuple_list = [(1,2), (2,3), (3,4), (3,5), (5,6)]\n    assert symmetric_pairs(tuple_list) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]",
      -9.5859375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def symmetricPairs(self, root: TreeNode) -> List[List[int]]:\n        return self.symmetricPairsHelper(root, [])\n\n    def symmetricPairsHelper(self, root, p):\n        if root is None:\n            return []\n        left, right = self.symmetricPairsHelper(root.left, p)\n        p.append(root.val)\n        if root.left is None and root.right is None:\n            if len(p) > 1:\n                return [[root.val] + list(p), [[root.val] + list(p)]]\n            else:\n                return [[root.val]]\n        left, right = self.symmetricPairsHelper(root.right, p)\n        p.pop()\n        return left + right + [[root.val] + list(p)]",
      -9.59375
    ],
    [
      "def symmetricPairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if not tuples: return []\n    \n    result = []\n    for i in range(len(tuples)):\n        for j in range(len(tuples)):\n            if i == j: continue\n            if tuple(tuples[i]) == tuple(tuples[j]):\n                result.append([tuples[i], tuples[j]])\n    return result\n\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    print(symmetricPairs(tuples))\n\n    tuples = [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    print(symmetricPairs(tuples))",
      -9.640625
    ],
    [
      "def symmetric_pairs(a_list):\n    \"\"\"\n    :type a_list: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    def get_symmetric_pairs(a_list):\n        # write your code here\n        # sort the list\n        a_list = sorted(a_list)\n\n        # make a map which maps the index of the list to the index of the next list\n        map_index = {}\n        for i, x in enumerate(a_list):\n            map_index[i] = i+1\n\n        # get the length of the list\n        length = len(a_list)\n\n        # the symmetric pairs are the pairs whose indices are in the map_index\n        # we start with the first pair\n        symmetric_pairs = [(i, map_index[j]) for i in range(length) for j in range(i+1, length)]\n        return symmetric_pairs\n\n    return get_symmetric_pairs(a_list)\n\n\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\n# print(symmetric_pairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\n# print(symmetric_pairs([1, 2, 3, 4, 5,",
      -9.6796875
    ],
    [
      "import unittest\n\nclass Solution:\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        ret = []\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    ret.append([nums[i], nums[j]])\n                    break\n        return ret\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n\n# 20ms 99.36%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (nums == null || nums.length == 0) return ans;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] == nums[j]) {\n                    ans.add(Arrays.asList(nums[i], nums[j]));\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (nums == null || nums.length == 0) return ans;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if",
      -9.8125
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    result.append([nums[i], nums[j]])\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/symmetric-pairs/solution/\n#\nApproach #1: Sort [2,2,3,1,4,2,5,4]\nComplexity Analysis\nTime Complexity: O(n log n), where n is the length of the given list.\nSpace Complexity: O(1)\n\n# 4ms 100%\nclass Solution {\n    public List<List<Integer>> symmetricPairs(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < nums.length-1; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if (nums[i] == nums[j]) {\n                    result.add(Arrays.asList(nums[i], nums[j]));\n                }\n            }\n        }\n        return result;\n    }\n}\n\n# Approach #2: Sort [2,2,3,1,4,2,5,4]\n# Complexity Analysis\nTime Complexity: O(n log n), where n is the length of the given list.\nSpace Complexity: O(1)\n\n# 4ms 100%\nclass Solution {\n    public List<List<Integer",
      -9.8984375
    ],
    [
      "# TLE\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        pairs = []\n        for i in xrange(len(nums)):\n            for j in xrange(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    pairs.append([nums[i], nums[j]])\n        return pairs\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.symmetricPairs([1, 2, 2, 3, 3, 4, 4, 4, 4, 5])\n    print sol.symmetricPairs([1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,",
      -10.7109375
    ],
    [
      "from collections import defaultdict\nfrom itertools import combinations\n\ndef symmetric_pairs(tuples):\n    \"\"\"\n    Returns a list of pairs.\n    \"\"\"\n    pairs = []\n    for t in tuples:\n        for t2 in combinations(t, 2):\n            if t[0] == t2[0] and t[1] == t2[1]:\n                pairs.append(tuple(t2))\n    return pairs\n\nif __name__ == \"__main__\":\n    tuples = [\n        (1, 2, 3),\n        (1, 2, 4),\n        (2, 3, 1),\n        (2, 3, 4),\n        (3, 1, 2),\n        (3, 1, 4),\n        (3, 2, 1),\n        (3, 2, 4),\n        (4, 1, 2),\n        (4, 1, 3),\n        (4, 2, 1),\n        (4, 2, 3)\n    ]\n    print(symmetric_pairs(tuples))",
      -10.734375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def symmetricPairs(self, root: TreeNode, pairs: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Dijkstra's algorithm\n        :param root:\n        :param pairs:\n        :return:\n        \"\"\"\n        queue = collections.deque()\n        queue.append(root)\n        pairs.append([root.val, root.val])\n\n        while queue:\n            node = queue.popleft()\n            if node.left is None and node.right is None:\n                continue\n            if node.left is not None:\n                queue.append(node.left)\n                pairs.append([node.left.val, node.val])\n            if node.right is not None:\n                queue.append(node.right)\n                pairs.append([node.val, node.right.val])\n\n        return pairs\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.right.right.left = TreeNode(10)\n    root.right.right.right = TreeNode(11)\n    print(sol.symmetricPairs(root, []))",
      -12.59375
    ],
    [
      "# Definition for a pair.\n# class Pair(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[Pair]\n        \"\"\"\n        nums = sorted(nums)\n        i = 0\n        j = len(nums) - 1\n        res = []\n        while i < j:\n            if nums[i] == nums[j]:\n                res.append(Pair(nums[i], nums[j]))\n                i += 1\n                j -= 1\n            else:\n                if i!= j:\n                    j -= 1\n                i += 1\n        return res\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1]\n    print(Solution().symmetricPairs(nums))",
      -13.390625
    ],
    [
      "import collections\nimport unittest\n\n\nclass Solution:\n    def symmetric_pairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        pairs = collections.defaultdict(set)\n        for i, num in enumerate(nums):\n            pairs[(i + 1, num)] = pairs[(num, i + 1)] = {(i, j) for j in range(i + 1, len(nums)) if nums[i]!= nums[j]}\n        return pairs.values()\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4], [[1, 2], [3, 4]])\n        self._test([1, 2, 3, 4], [[2, 1], [4, 3]])\n        self._test([1, 2, 3, 4], [[3, 1], [4, 2]])\n        self._test([1, 2, 3, 4], [[4, 1], [3, 2]])\n        self._test([1, 2, 3, 4], [[1, 4], [2, 3]])\n        self._test([1, 2, 3, 4], [[2, 3], [3, 1]])\n        self._test([1, 2, 3, 4], [[3, 2], [2, 1]])\n        self._test([1, 2, 3, 4], [[4, 3], [3, 1]])\n        self._test([1, 2, 3, 4], [[1, 3], [3, 2]])\n        self._test([1, 2, 3, 4], [[3, 1], [1, 4]])\n        self._test([1, 2, 3, 4], [[4, 1], [1, 2]])\n        self._test([1, 2, 3, 4], [[1, 4], [4, 2]])\n        self._test([1, 2, 3, 4], [[1, 3], [3, 2]])\n        self._test([1, 2, 3, 4], [[2, 3], [3, 1]])",
      -13.8359375
    ],
    [
      "class Solution(object):\n    def symmetricPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.symmetricPairs_rec(nums, [], [])\n\n    def symmetricPairs_rec(self, nums, left, right):\n        if len(left) == len(nums):\n            return left + right\n        if len(left) == 0:\n            return [x + y for x in right for y in nums]\n        if len(right) == 0:\n            return [x + y for x in left for y in nums]\n        for i in range(len(left)):\n            if left[i] == right[i]:\n                self.symmetricPairs_rec(nums, left[:i] + left[i + 1 :] + left[i + 1 :] + left[:i], right[:i] + right[i + 1 :] + right[i + 1 :] + right[:i])\n        return []\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8]\n    print(sol.symmetricPairs(nums))",
      -18.375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}