{
  "problem": {
    "task_id": "MBPP/462",
    "prompt": "Write a function to find all possible combinations of the elements of a given list.",
    "canonical_solution": "def combinations_list(list1):\r\n    if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result",
    "test_list": [
      "assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]",
      "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]",
      "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"
    ],
    "challenge_test_list": [],
    "problem_id": 451
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def combine(n, k):\n    if n == 1:\n        return [[]]\n    if n == 2:\n        return [[1, 2]]\n    res = []\n    for i in range(1, k+1):\n        res += combine(n-1, i)\n    return res\n\ndef solve(n, k):\n    return combine(n, k)\n\nif __name__ == '__main__':\n    print(solve(4, 3))",
      3.2109375
    ],
    [
      "# https://www.codewars.com/kata/51477d7bd9c3d8a8a0000/train/python\n\ndef combinations(items, n):\n    if n == 0:\n        yield []\n    else:\n        for i in range(len(items)):\n            for xs in combinations(items[i+1:], n-1):\n                for x in xs:\n                    yield [items[i]] + x\n\nif __name__ == '__main__':\n    items = ['a', 'b', 'c']\n    print(combinations(items, 2))\n    print(combinations(items, 3))\n    print(combinations(items, 4))\n    print(combinations(items, 5))\n    print(combinations(items, 6))\n    print(combinations(items, 7))",
      1.7138671875
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combinationSum(self, nums, target):\n        res = []\n        if not nums:\n            return res\n        if len(nums) == 1:\n            if nums[0] == target:\n                res.append([nums[0]])\n                return res\n            return []\n\n        for i in range(1, len(nums)+1):\n            res_new = self.combinationSum(nums[i:], target-nums[i-1])\n            for r in res_new:\n                r.insert(0, nums[i-1])\n            res.extend(res_new)\n\n        return res\n\nif __name__ == \"__main__\":\n    nums = [2,3,6,7]\n    target = 8\n    print Solution().combinationSum(nums, target)",
      1.0654296875
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a list of ListNode\n    def generate(self, head):\n        if head is None:\n            return []\n        if head.next is None:\n            return [head]\n        \n        if head.next.next is None:\n            return [head]\n        \n        # first, generate all possible combinations for the first half\n        res = self.generate(head.next)\n        \n        # second, generate all possible combinations for the second half\n        res2 = self.generate(head.next.next)\n        \n        # merge them\n        res = res + res2\n        \n        # add head\n        res = [head] + res\n        return res",
      1.0634765625
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param root, a tree node\n\t# @return a list of lists of integer\n\tdef generateTrees(self, root):\n\t\tif root == None:\n\t\t\treturn [[]]\n\t\telse:\n\t\t\tresult = []\n\t\t\tself.helper(root, result)\n\t\t\treturn result\n\t\n\tdef helper(self, root, result):\n\t\tif root.left == None and root.right == None:\n\t\t\tresult.append(root.val)\n\t\t\treturn\n\t\telse:\n\t\t\tif root.left!= None:\n\t\t\t\tself.helper(root.left, result)\n\t\t\tif root.right!= None:\n\t\t\t\tself.helper(root.right, result)\n\nif __name__ == \"__main__\":\n\tsolution = Solution()\n\tprint solution.generateTrees([1,2,3,4])",
      0.9091796875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def generate(self, numNodes):\n        \"\"\"\n        :type numNodes: int\n        :rtype: List[ListNode]\n        \"\"\"\n        if numNodes <= 0:\n            return []\n        if numNodes == 1:\n            return [[self.node]]\n        res = []\n        cur = self.node\n        for i in xrange(2, numNodes+1):\n            res.append([cur])\n            cur = cur.next\n        return res\n\n\nnode = ListNode(1)\nnode.next = ListNode(2)\nnode.next.next = ListNode(3)\nnode.next.next.next = ListNode(4)\n\ns = Solution()\nprint s.generate(2)",
      0.59521484375
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/description/\n\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        if len(candidates) == 1:\n            if candidates[0] == target:\n                return [[candidates[0]]]\n            return []\n        \n        res = []\n        for i in range(len(candidates)):\n            if candidates[i] <= target:\n                for j in self.combinationSum2(candidates[:i] + candidates[i + 1:], target - candidates[i]):\n                    res.append(list(j) + [candidates[i]])\n        return res\n    \n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        if len(candidates) == 1:\n            if candidates[0] == target:\n                return [[candidates[0]]]\n            return []\n        \n        res = []\n        for i in range(len(candidates)):\n            if candidates[i] <= target:\n                for j in self.combinationSum2(candidates[:i] + candidates[i + 1:], target - candidates[i]):\n                    res.append(list(j) + [candidates[i]])\n        return res",
      0.4052734375
    ],
    [
      "#!/usr/bin/env python\n\ndef combination(arr, n):\n    if n == 0:\n        yield arr\n    else:\n        for i in range(len(arr)):\n            for c in combination(arr[:i] + arr[i+1:], n-1):\n                yield c\n\ndef main():\n    arr = [1, 2, 3]\n    print(list(combination(arr, 3)))\n\nif __name__ == \"__main__\":\n    main()",
      0.39990234375
    ],
    [
      "def combination(list, n):\n    if n == 0:\n        return [list]\n    else:\n        result = []\n        for i in range(0, len(list)):\n            result += combination(list[:i] + list[i+1:], n - 1)\n        return result\n\n# Your code here\nlist = [1,2,3]\nresult = combination(list, 3)\nprint(result)",
      0.036865234375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getCombinations(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: List[ListNode]\n        \"\"\"\n        if not head: return []\n        if not head.next: return [head]\n        res = []\n        cur = head\n        while cur:\n            res.append(cur)\n            cur = cur.next\n        res.reverse()\n        return self.recursion(head, res)\n\n    def recursion(self, head, res):\n        if not head: return []\n        if not head.next: return [head]\n        if head.next.next:\n            for i in range(len(res)):\n                tmp = res[i].next\n                res[i].next = res[i].next.next\n                res[i].next.next = tmp\n        return self.recursion(head.next, res)",
      -0.370849609375
    ],
    [
      "def combination(arr, n):\n    result = []\n    if n == 1:\n        for i in arr:\n            result.append([i])\n    else:\n        for i in arr:\n            result += combination(arr[:i] + arr[i + 1:], n - 1)\n    return result\n\ndef main():\n    arr = [1, 2, 3]\n    print(combination(arr, 3))\n\nif __name__ == '__main__':\n    main()",
      -0.414306640625
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/discuss/84929/C++-Python-DP-solution-with-explanation\n\nimport collections\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n\n    def dfs(self, candidates, target, index, path, res):\n        if target == 0:\n            res.append(path)\n        else:\n            for i in range(index, len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)",
      -0.57763671875
    ],
    [
      "def get_combinations(arr):\n    if not arr:\n        return []\n    else:\n        return get_combinations(arr[1:]) + [arr]\n\ndef get_all_combinations(arr):\n    return [get_combinations(arr)]\n\ndef print_combinations(arr):\n    if not arr:\n        return\n    else:\n        for i in get_all_combinations(arr):\n            print_combinations(i)\n\nprint(get_all_combinations([1,2,3]))",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        if not target:\n            return [[]]\n        if target < 0:\n            return []\n\n        # get possible combinations\n        combination_sets = self.combinationSum(candidates[1:], target - candidates[0])\n        # filter out duplicate combinations\n        combination_sets = [x for x in combination_sets if len(x) > 1]\n        # combine the combinations\n        combinations = []\n        for combination in combination_sets:\n            new_combination = combination[:]\n            for i, element in enumerate(combination):\n                new_combination[i] += candidates[0]\n            combinations.append(new_combination)\n        return combinations",
      -0.85693359375
    ],
    [
      "def combine(n, k, result):\n    if n == 0 or k == 0:\n        return result\n    for i in xrange(k):\n        combine(n-1, i, result)\n        combine(n-1, k-i-1, result)\n        \n        \n\n#combine(3, 3, [[1,2,3]])\n#combine(3, 2, [[1,2], [1,3], [2,3]])\ncombine(3, 2, [[1,2], [1,3], [2,3]])",
      -0.85693359375
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/\n\nclass Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        ret = []\n        self.helper(candidates, target, 0, ret)\n        return ret\n\n    def helper(self, candidates, target, start, ret):\n        if start == target:\n            ret.append(list(candidates[:start]))\n            return\n        if target < 0:\n            return\n        for i in range(start, len(candidates)):\n            self.helper(candidates, target - candidates[i], i+1, ret)",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combine(self, num):\n        if not num:\n            return [[]]\n        elif len(num) == 1:\n            return [[num]]\n        else:\n            return self.combine(num[1:]) + self.combine([num[0]])",
      -0.85693359375
    ],
    [
      "# https://www.geeksforgeeks.org/write-a-function-that-finds-all-possible-combinations-of-a-given-list/\n\ndef combination(items, result):\n    if len(items) == 0:\n        return result\n    else:\n        return combination(items[1:], [items[0]] + result)\n\ndef main():\n    items = [1,2,3]\n    combination(items, [])\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/combinations/problem\n\ndef combination(l, n):\n    # This is a recursive function.\n    # It can be done without using recursion.\n    # It is possible to write this function using only one stack.\n    if n == 0:\n        yield []\n    else:\n        for i in range(len(l)):\n            for res in combination(l[i+1:], n-1):\n                yield [l[i]] + res\n\nif __name__ == \"__main__\":\n    l = [1, 2, 3]\n    print(list(combination(l, 3)))",
      -0.85791015625
    ],
    [
      "def combinationSum(self, candidates, target):\n    # write your code here\n    res = []\n    self.candidates = candidates\n    self.target = target\n    self.dfs(res, [], 0, 0)\n    return res\n\ndef dfs(res, path, start, currSum):\n    if currSum == target:\n        res.append(path)\n    else:\n        for i in xrange(start, len(self.candidates)):\n            if currSum + self.candidates[i] > target:\n                break\n            else:\n                path.append(self.candidates[i])\n                dfs(res, path, i + 1, currSum + self.candidates[i])\n                path.pop()",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        if len(candidates) == 1:\n            if candidates[0] < target:\n                return [[candidates[0]]]\n            else:\n                return []\n        if target == 0:\n            return [[]]\n        return self.combinationSum(candidates[1:], target-candidates[0]) + self.combinationSum(candidates, target)\n\ndef main():\n    solution = Solution()\n    print(solution.combinationSum([1,2,3], 4))\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "def get_all_combinations(elements):\n    combinations = []\n    combinations.append(elements)\n    if len(elements) > 1:\n        for i in range(len(elements) - 1):\n            combinations.append(elements[:i] + elements[i + 1:])\n    return combinations\n\n\nif __name__ == '__main__':\n    elements = [1, 2, 3, 4]\n    print(get_all_combinations(elements))\n    # print(get_all_combinations([]))",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def combine(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not num:\n            return []\n        res = []\n        self.rec(num, 0, res)\n        return res\n\n    def rec(self, num, start, res):\n        if start == len(num):\n            res.append(num[:])\n            return\n        for i in range(start, len(num)):\n            self.rec(num, i + 1, res)\n            res.append(num[start:i + 1])",
      -0.8583984375
    ],
    [
      "def combinationSum(self, candidates, target):\n    \"\"\"\n    :type candidates: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n    return self.helper(candidates, target, [], [])\n\ndef helper(candidates, target, cur, result):\n    if target == 0:\n        result.append(cur)\n        return\n    for i in range(len(candidates)):\n        if target < candidates[i]:\n            return\n        else:\n            cur.append(candidates[i])\n            helper(candidates, target - candidates[i], cur, result)\n            cur.pop()\n\nif __name__ == '__main__':\n    print(combinationSum([1,2,3], 4))\n    print(combinationSum([1,2,3], 1))",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def getCombination(self, num):\n        return self.getCombinationRec(num)\n\n    def getCombinationRec(self, num):\n        if not num:\n            return []\n        if len(num) == 1:\n            return [num]\n        return self.getCombinationRec(num[1:]) + self.getCombinationRec(num[0:1])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.getCombinationRec([1, 2, 3]))\n    print(s.getCombinationRec([2, 3, 4]))\n    print(s.getCombinationRec([3, 4, 5]))",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/description/\n\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(candidates, target, result):\n            if target == 0:\n                result.append(list(candidates))\n                return\n            for i in range(len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                else:\n                    dfs(candidates[i+1:], target - candidates[i], result)\n        \n        result = []\n        dfs(candidates, target, result)\n        return result",
      -0.8583984375
    ],
    [
      "def get_all_combinations(list):\n    combinations = []\n    for i in range(0, len(list)):\n        for combination in combinations:\n            combination.append(list[i])\n        combinations.append(list[i:])\n    return combinations\n\nprint get_all_combinations(range(1, 10))",
      -0.85888671875
    ],
    [
      "#!/usr/bin/env python\n\ndef all_possible_combinations(arr):\n    res = []\n    if len(arr) == 1:\n        res.append(arr)\n    else:\n        for i in range(len(arr)):\n            if i == len(arr) - 1:\n                res.append(arr[:])\n            else:\n                res.append(arr[:i] + arr[i+1:])\n    return res\n\ndef test():\n    arr = [1,2,3]\n    res = all_possible_combinations(arr)\n    assert res == [[1,2,3]]\n\nif __name__ == '__main__':\n    test()",
      -0.85888671875
    ],
    [
      "def combination(elements, k):\n    \"\"\"\n    :type elements: List[int]\n    :type k: int\n    :rtype: List[List[int]]\n    \"\"\"\n    result = []\n    combination_recursive(elements, k, 0, result)\n    return result\n\ndef combination_recursive(elements, k, index, result):\n    if k == 0:\n        result.append(elements[:])\n        return\n    \n    for i in range(index, len(elements)):\n        combination_recursive(elements, k-1, i+1, result)\n        combination_recursive(elements, k-1, i, result)\n\nif __name__ == \"__main__\":\n    elements = [1, 2, 3, 4, 5]\n    print(combination(elements, 5))",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combination(self, num):\n        if not num:\n            return []\n        res = [list()]\n        for i in range(len(num)):\n            res = [list(itertools.chain(*res)) + [num[i]]]\n        return res\n\nif __name__ == \"__main__\":\n    print Solution().combination([1,2,3])",
      -0.85888671875
    ],
    [
      "def combination_sum(arr):\n    res = []\n    for i in range(len(arr)):\n        comb_list = []\n        for j in range(len(arr)):\n            if j > i:\n                comb_list.append(arr[i] + arr[j])\n        res.append(comb_list)\n    return res\n\ndef main():\n    arr = [1,2,3]\n    print combination_sum(arr)\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        self.dfs(candidates, target, 0, ans)\n        return ans\n\n    def dfs(self, candidates, target, cur, ans):\n        if cur == target:\n            ans.append(list(candidates))\n            return\n        for i in xrange(cur, len(candidates)):\n            self.dfs(candidates, target, cur+candidates[i], ans)",
      -0.85888671875
    ],
    [
      "def get_combination(n, k):\n    if k == 0:\n        return 1\n    else:\n        return get_combination(n-1, k-1) * get_combination(n-1, k)\n\nprint(get_combination(5, 3))",
      -0.86083984375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def getCombination(self, num):\n        if not num:\n            return []\n\n        res = []\n        self.getCombination(num, [], res)\n        return res\n\n    def getCombination(self, num, cur, res):\n        if len(num) == len(cur):\n            res.append(cur)\n            return\n\n        for i in range(len(num)):\n            self.getCombination(num, cur + [num[i]], res)",
      -0.86083984375
    ],
    [
      "def combinations(elements, n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [[elements[0]]]\n    if n == 2:\n        return [[elements[0], elements[1]], [elements[0], elements[2]], [elements[1], elements[2]]]\n    return combinations(elements, n - 1) + combinations(elements, n - 2)\n\nif __name__ == '__main__':\n    elements = [1, 2, 3]\n    print(combinations(elements, 3))",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k == 0:\n            return [[]]\n        if n == 0:\n            return [[]]\n        if k == 1:\n            return [[x] for x in range(n)]\n        if k == 2:\n            return [[x, x + 1] for x in range(n)]\n        comb = []\n        for i in range(n):\n            comb += [[x, x + 1] for x in range(n - i)]\n            comb += [[x, x + 1] for x in range(i + 1, n - i)]\n            comb += [[x, x + 1] for x in range(i + 1, n + 1)]\n        return comb\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.combine(1, 1)",
      -0.947265625
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def combine(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # if num is empty\n        if not num:\n            return [[]]\n\n        # if num is one element\n        if len(num) == 1:\n            # return [[num[0]]]\n            return [[num[0]]]\n\n        # if num is two elements\n        if len(num) == 2:\n            # return [[num[0], num[1]]]\n            return [[num[0], num[1]]]\n\n        # if num is more than two elements\n        # return all possible combinations of the first two elements\n        return self.combine([num[0]] + num[1:])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    num = [1, 2, 3]\n    print(s.combine(num))",
      -0.96923828125
    ],
    [
      "def combine(arr, n):\n    if n == 1:\n        yield arr\n    else:\n        for i in range(n):\n            for x in combine(arr[:i] + arr[i + 1:], n - 1):\n                yield x\n\n# test cases\nprint(list(combine([1,2,3], 3)))\nprint(list(combine([1,2,3], 4)))",
      -1.33984375
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.helper(res, [], candidates, target, 0)\n        return res\n\n    def helper(self, res, cur, candidates, target, pos):\n        if len(cur) == target:\n            res.append(cur)\n            return\n        for i in range(pos, len(candidates)):\n            if target - candidates[i] >= 0:\n                cur.append(candidates[i])\n                self.helper(res, cur, candidates, target, i)\n                cur.pop()",
      -1.416015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def combinationSum(self, nums):\n        res = []\n        self.combinationSum(res, nums, [])\n        return res\n    \n    def combinationSum(self, res, nums, cur):\n        if len(cur) == len(nums):\n            res.append(cur)\n            return\n        for i in range(len(nums)):\n            if nums[i] > cur[-1]:\n                continue\n            cur.append(nums[i])\n            self.combinationSum(res, nums, cur)\n            cur.pop()\n\nif __name__ == '__main__':\n    res = Solution().combinationSum([2,3,6,7], [2,3,7])\n    print(res)",
      -1.4365234375
    ],
    [
      "def get_combinations(lst):\n    return [comb for comb in itertools.combinations(lst, r) for r in range(1, len(lst) + 1)]\n\nif __name__ == '__main__':\n    print(get_combinations([1, 2, 3, 4]))\n    print(get_combinations([1, 2, 3]))\n    print(get_combinations([1, 2, 3, 4, 5, 6]))\n    print(get_combinations([1, 2, 3, 4, 5]))\n    print(get_combinations([1, 2, 3, 4, 5, 6, 7]))",
      -1.75
    ],
    [
      "# https://leetcode.com/problems/combination-sum/\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        if len(candidates) == 1:\n            if candidates[0] == target:\n                return [[candidates[0]]]\n            else:\n                return []\n        res = []\n        for i in range(len(candidates)):\n            res += self.combinationSum(candidates[i + 1:], target - candidates[i])\n        return res",
      -1.8505859375
    ],
    [
      "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        res = []\n        self.backtrack(nums, 0, res, [])\n        return res\n\n    def backtrack(self, nums, index, res, path):\n        if index == len(nums):\n            res.append(path)\n            return\n        for i in xrange(index, len(nums)):\n            self.backtrack(nums, index + 1, res, path + [nums[i]])\n\nif __name__ == '__main__':\n    nums = [1, 2]\n    print Solution().permute(nums)",
      -2.01953125
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        res = []\n        self.backtracking(res, [], candidates, target, 0)\n        return res\n\n    def backtracking(self, res, path, candidates, target, start):\n        if target == 0:\n            res.append(path)\n            return\n\n        for i in range(start, len(candidates)):\n            if target < candidates[i]:\n                break\n            self.backtracking(res, path + [candidates[i]], candidates, target - candidates[i], i)\n\nif __name__ == \"__main__\":\n    candidates = [1, 2, 3, 4]\n    target = 6\n    print Solution().combinationSum(candidates, target)",
      -2.296875
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n\n        if target == 0:\n            return [[]]\n\n        res = []\n        for i in range(1, target + 1):\n            if i == target:\n                res.append([])\n            else:\n                for j in self.combine(candidates[:i], target - i):\n                    res.append([candidates[i - 1]] + j)\n        return res\n\n    def combine1(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n\n        res = []\n        if target == 0:\n            return [[]]\n\n        for i in range(1, target + 1):\n            if i == target:\n                res.append([])\n            else:\n                for j in self.combine1(candidates[:i], target - i):\n                    res.append([candidates[i - 1]] + j)\n        return res\n\n    def combine2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n\n        res = []\n        if target == 0:\n            return [[]]\n\n        for i in range(1, target + 1):\n            if i == target:\n                res.append([])\n            else:\n                for j in self.combine2(candidates[:i], target - i):\n                    res.append([candidates[i - 1]] + j)\n        return res\n\ns = Solution()\nprint(s.combine(range(1, 10), 10))\nprint(s.combine1(range(1, 10), 10))\nprint(s.combine2(range(1, 10), 10",
      -2.6640625
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combine(self, num):\n        # write your code here\n        res = []\n        if len(num) == 0:\n            return res\n        self.helper(res, [], num, 0)\n        return res\n\n    def helper(self, res, temp, num, start):\n        if start == len(num):\n            res.append(temp)\n            return\n        for i in xrange(start, len(num)):\n            temp.append(num[i])\n            self.helper(res, temp, num, i+1)\n            temp.pop()",
      -2.896484375
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/description/\n\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # sort candidate\n        candidates.sort()\n\n        # result list\n        result = []\n\n        # iterate over candidates\n        for i in xrange(len(candidates)):\n            # iterate over candidates\n            for j in xrange(i+1, len(candidates)):\n                # if current candidate is greater than target, skip\n                if candidates[i] + candidates[j] > target:\n                    break\n                # if current candidate is less than target, add to result list\n                elif candidates[i] + candidates[j] == target:\n                    result.append([candidates[i], candidates[j]])\n\n        return result",
      -2.908203125
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result=[]):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type result: List[List[int]]\n        \"\"\"\n        if target == 0:\n            result.append(candidates[:])\n            return result\n        if target < 0:\n            return []\n        if len(candidates) == 0:\n            return []\n        for i in range(0, len(candidates)):\n            self.combine(candidates[:i] + candidates[i+1:], target-candidates[i], result+[[candidates[i]]])\n        return result",
      -2.9140625
    ],
    [
      "# https://leetcode.com/problems/combination-sum/\n\n\nclass Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combinationSum(self, num, target):\n        return self.combinationSum2(num, target, [])\n\n    def combinationSum2(self, num, target, result):\n        if len(num) == 0:\n            if target == 0:\n                return [[]]\n            else:\n                return []\n\n        for i in range(len(num)):\n            for j in range(i+1, len(num)):\n                if num[i] + num[j] < target:\n                    result.append([num[i], num[j]])\n                    self.combinationSum2(num[:i] + num[j+1:], target - num[i] - num[j], result)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.combinationSum([2, 7, 11], 15))",
      -3.013671875
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return [[]]\n        if target < 0:\n            return []\n        if target == 0:\n            return [[]]\n        if target == 1:\n            return [[candidates[0]]]\n        if target == len(candidates):\n            return [[candidates[i] for i in range(len(candidates))]]\n        if target % len(candidates) == 0:\n            return [self.combine(candidates[:target/len(candidates)], target/len(candidates)) + [[candidates[i]] for i in range(target/len(candidates))] + self.combine(candidates[target/len(candidates):], target%len(candidates))]\n        return [self.combine(candidates[:target/len(candidates)], target/len(candidates)) + [[candidates[i]] for i in range(target/len(candidates))] + self.combine(candidates[target/len(candidates):], target%len(candidates))]\n\nif __name__ == '__main__':\n    print Solution().combine([2,3,6,7], 8)",
      -3.103515625
    ],
    [
      "# https://www.hackerrank.com/challenges/combinations/problem\n\nimport itertools\n\ndef combinations(lst):\n    for i in range(len(lst)):\n        yield itertools.combinations(lst[:i] + lst[i+1:], r=1)\n\ndef combinations_without_rep(lst):\n    for i in range(len(lst)):\n        yield itertools.combinations(lst, r=i+1)\n\ndef combinations_with_replacement(lst):\n    for i in range(len(lst)):\n        yield itertools.combinations_with_replacement(lst, r=i+1)\n\ndef main():\n    lst = [1, 2, 3]\n    #lst = [1, 1, 1]\n    print(list(combinations(lst)))\n    #print(list(combinations_without_rep(lst)))\n    #print(list(combinations_with_replacement(lst)))\n\nif __name__ == \"__main__\":\n    main()",
      -3.478515625
    ],
    [
      "# https://oj.leetcode.com/problems/combination-sum/\n\n# The solution is based on dynamic programming\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def combinationSum2(self, nums):\n        if not nums:\n            return []\n\n        if len(nums) == 1:\n            return [[nums]]\n\n        dp = [[0] * len(nums)]\n        for i in xrange(len(nums)):\n            dp[0][i] = 1\n\n        for i in xrange(1, len(nums)):\n            for j in xrange(i, len(nums)):\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n\n        res = []\n        for i in xrange(len(nums)):\n            res.append(dp[len(nums) - 1][i])\n\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.combinationSum2([1,2,3])\n    print s.combinationSum2([1,2])\n    print s.combinationSum2([1,2,3])",
      -3.666015625
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result, index):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type result: List[List[int]]\n        :type index: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if index >= len(candidates) or candidates[index] > target:\n            return result\n        \n        if candidates[index] == target:\n            result.append(list(candidates[:index+1]))\n        \n        if index+1 < len(candidates) and candidates[index+1] < candidates[index]:\n            self.combine(candidates, target, result, index+1)\n        \n        return result",
      -3.6875
    ],
    [
      "# https://leetcode.com/problems/combination-sum/description/\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n\n        candidates.sort()\n        res = []\n        self.combinationSum(candidates, target, res, [], 0)\n        return res\n\n    def combinationSum(self, candidates, target, res, cur, start):\n        if target == 0:\n            res.append(cur)\n            return\n        for i in range(start, len(candidates)):\n            if target < candidates[i]:\n                return\n            else:\n                self.combinationSum(candidates, target - candidates[i], res, cur + [candidates[i]], i)",
      -3.744140625
    ],
    [
      "def getCombinations(list):\n    combinations = []\n    if not list:\n        return combinations\n    \n    for i in range(len(list)):\n        for combination in getCombinations(list[:i] + list[i+1:]):\n            combinations.append(list[:i] + combination + list[i+1:])\n    return combinations\n\ndef getCombinations2(list):\n    combinations = []\n    if not list:\n        return combinations\n\n    for i in range(len(list)):\n        for combination in getCombinations2(list[:i] + list[i+1:]):\n            combinations.append(list[:i] + combination + list[i+1:])\n    return combinations\n\nif __name__ == \"__main__\":\n    print getCombinations([1, 2, 3])\n    print getCombinations2([1, 2, 3])",
      -3.859375
    ],
    [
      "# https://leetcode.com/problems/combination-sum-ii/description/\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def generate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[ListNode]\n        \"\"\"\n        if not nums:\n            return []\n        n = len(nums)\n        ret = []\n        if n == 1:\n            ret.append(ListNode(nums[0]))\n            return ret\n        \n        ret.append(ListNode(0))\n        ret.append(ListNode(0))\n        for i in xrange(2, n):\n            ret.append(ListNode(0))\n        \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2, n):\n            cur.next = ListNode(0)\n            cur = cur.next\n            \n        cur = ret[1]\n        for i in xrange(2,",
      -3.91796875
    ],
    [
      "def combination(list_of_numbers, number_of_combination_to_find):\n    \"\"\"\n    Input:\n        list_of_numbers: list of elements to find combinations for\n        number_of_combination_to_find: number of combinations to find\n\n    Output:\n        list of combinations\n    \"\"\"\n    result = []\n\n    for i in range(len(list_of_numbers)):\n        for j in range(number_of_combination_to_find):\n            result.append(list_of_numbers[i])\n\n    return result\n\n# Test Cases\n\n# Test Case 1\ntest_case_1 = [1, 2, 3]\ntest_case_1_combinations = [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n]\n\nassert combination(test_case_1, 3) == test_case_1_combinations\n\n# Test Case 2\ntest_case_2 = [1, 2, 3]\ntest_case_2_combinations = [\n    [1, 2, 3]\n]\n\nassert combination(test_case_2, 3) == test_case_2_combinations",
      -3.919921875
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        candidates.sort()\n        ret = []\n        self.dfs(candidates, target, [], ret)\n        return ret\n\n    def dfs(self, candidates, target, path, ret):\n        if target == 0:\n            ret.append(path[:])\n            return\n        for i in range(len(candidates)):\n            if target - candidates[i] >= 0:\n                path.append(candidates[i])\n                self.dfs(candidates, target - candidates[i], path, ret)\n                path.pop()",
      -4.34375
    ],
    [
      "#!/usr/bin/env python\n\nimport os\nimport sys\nimport time\nimport random\n\nsys.path.append(os.path.join(os.path.dirname(__file__), '..'))\n\nfrom solution import Solution\n\n# solution = Solution()\n# result = solution.combinationSum2([2,3,6,7], 7)\n# for r in result:\n#     print r\n\nclass TestSolution(unittest.TestCase):\n    def test_combinationSum2(self):\n        solution = Solution()\n        result = solution.combinationSum2([2,3,6,7], 7)\n        self.assertEqual(result, [\n            [[2, 3], [2, 6], [2, 7], [3, 6], [3, 7], [6, 7]],\n            [[2, 3], [3, 6], [3, 7], [6, 7]],\n            [[2, 3], [2, 6], [6, 7]],\n            [[2, 3], [3, 6]],\n            [[2, 3], [2, 6], [6]],\n            [[2, 3], [3, 6], [6]]\n        ])\n\nif __name__ == '__main__':\n    unittest.main()",
      -4.51953125
    ],
    [
      "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k == 0:\n            return [[]]\n        res = []\n        self.combine(n - 1, k - 1, res, [])\n        return res\n\n    def combine(self, n, k, res, cur):\n        if k == 0:\n            res.append(cur[:])\n            return\n        for i in range(n):\n            self.combine(n - 1, k - 1, res, cur + [i])",
      -4.83203125
    ],
    [
      "def combination(list, n):\n    if n == 0:\n        return [[]]\n    elif n == 1:\n        return [[list[0]]]\n    else:\n        result = []\n        for i in range(n-1):\n            result += combination(list, n-1)\n        for i in range(len(list)):\n            for j in range(n-1):\n                result.append([list[i]+list[j]])\n        return result\n\nif __name__ == \"__main__\":\n    list = [1, 2, 3]\n    print(combination(list, 3))",
      -5.01171875
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if n == 0:\n            return []\n        if k == 0:\n            return [[]]\n        if k == 1:\n            return [list(range(n))]\n        \n        res = []\n        for i in range(1, k+1):\n            res.append([])\n            for j in range(n-i+1):\n                cur = []\n                for l in range(i):\n                    cur.append(j+l)\n                res[i-1].append(cur)\n                \n        return res\n\ndef main():\n    sol = Solution()\n    print sol.combine(3, 2)\n\nif __name__ == '__main__':\n    main()",
      -5.05859375
    ],
    [
      "import collections\n\ndef combinations(elements, n):\n    # combinations with a seed of 0 is defined as 1\n    if n == 0:\n        yield []\n    # for the rest, we have to consider the possibility\n    # of having a single element or a combination\n    else:\n        for combination in combinations(elements[1:], n-1):\n            yield [elements[0]] + combination\n            yield [elements[0]] + combination + [elements[1]]\n\ndef main():\n    # elements = [1,2,3,4]\n    # n = 4\n    #\n    # for combination in combinations(elements, n):\n    #     print(combination)\n    #\n    # print(combinations([1,2,3,4], 4))\n    # print(combinations([1,2,3,4], 3))\n    # print(combinations([1,2,3,4], 2))\n    # print(combinations([1,2,3,4], 1))\n    # print(combinations([1,2,3,4], 0))\n    # print(combinations([1,2,3,4], 5))\n\n    elements = [1,2,3,4]\n    n = 4\n    for combination in combinations(elements, n):\n        print(combination)\n\nif __name__ == '__main__':\n    main()",
      -5.09375
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type result: List[List[int]]\n        \"\"\"\n        if target == 0:\n            result.append(list(candidates))\n            return\n\n        if len(candidates) == 1:\n            result.append(list(candidates))\n            return\n\n        for i in range(len(candidates)):\n            self.combine(candidates[:i] + candidates[i+1:], target-candidates[i], result)\n\n    def combine_all(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        self.combine(candidates, target, result)\n        return result\n\n\nsolution = Solution()\nprint(solution.combine_all([1, 2, 3], 3))\nprint(solution.combine_all([1, 2, 3], 4))\nprint(solution.combine_all([1, 2, 3], 7))",
      -5.26953125
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates or len(candidates) == 1:\n            return [[candidates[0]]]\n\n        result = []\n        self.findCombination(candidates, target, [], result)\n        return result\n\n    def findCombination(self, candidates, target, path, result):\n        if target == 0:\n            result.append(path)\n            return\n\n        for i in range(len(candidates)):\n            if target >= candidates[i]:\n                path.append(candidates[i])\n                self.findCombination(candidates, target - candidates[i], path, result)\n                path.pop()",
      -5.44140625
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type result: List[List[int]]\n        \"\"\"\n        def rec(i, j, ans):\n            if j == len(candidates):\n                if i == len(candidates) - 1:\n                    result.append(ans)\n            else:\n                if candidates[i] < target:\n                    rec(i, j + 1, ans + [candidates[i]])\n                else:\n                    rec(i + 1, j, ans + [candidates[i]])\n        rec(0, 0, [])",
      -5.4609375
    ],
    [
      "from collections import defaultdict\n\ndef generate_combination(elements, combination_length):\n    if combination_length == 0:\n        return [[]]\n    elif combination_length == 1:\n        return [[elements[0]]]\n    else:\n        combinations = []\n        for index in range(len(elements)):\n            for combination in generate_combination(elements, combination_length - 1):\n                combination.append(elements[index])\n                combinations.append(combination)\n        return combinations\n\ndef generate_combinations(elements, combination_length):\n    if combination_length == 0:\n        return []\n    elif combination_length == 1:\n        return [[elements[0]]]\n    else:\n        combinations = []\n        for index in range(len(elements)):\n            for combination in generate_combinations(elements, combination_length - 1):\n                combination.append(elements[index])\n                combinations.append(combination)\n        return combinations\n\ndef get_combination_length(elements, combination_length):\n    if combination_length == 0:\n        return 0\n    elif combination_length == 1:\n        return 1\n    else:\n        return len(elements) - combination_length + 1\n\ndef generate_combinations_from_list(elements):\n    combinations = []\n    for combination_length in range(1, len(elements) + 1):\n        combinations.extend(generate_combinations(elements, combination_length))\n    return combinations\n\ndef generate_combinations_from_set(elements):\n    combinations = []\n    for combination_length in range(1, len(elements) + 1):\n        combinations.extend(get_combination_length(elements, combination_length))\n    return combinations\n\ndef generate_combinations_from_dict(elements):\n    combinations = []\n    for combination_length in range(1, len(elements) + 1):\n        combinations.extend(get_combination_length_from_dict(elements, combination_length))\n    return combinations\n\ndef get_combination_length_from",
      -5.56640625
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        if len(candidates) == 1:\n            if candidates[0] == target:\n                return [[candidates[0]]]\n            else:\n                return []\n\n        res = []\n        for i in range(len(candidates)):\n            for j in range(i+1, len(candidates)):\n                if candidates[i] + candidates[j] > target:\n                    break\n                else:\n                    if candidates[i] + candidates[j] == target:\n                        res.append([candidates[i], candidates[j]])\n        return res\n\nif __name__ == \"__main__\":\n    candidates = [1, 2, 3]\n    target = 6\n    print Solution().combine(candidates, target)",
      -5.59765625
    ],
    [
      "# https://www.hackerrank.com/challenges/combination/problem\n\ndef combination(n, k):\n    # write your code here\n    # if n == 0 and k == 0:\n    #     return []\n    if k == 0:\n        return [1]\n    if n == 0:\n        return []\n\n    result = []\n    for i in range(1, k+1):\n        result += combination(n-1, i-1)\n    return result\n\nif __name__ == '__main__':\n    print(combination(3, 2))",
      -5.953125
    ],
    [
      "# https://leetcode.com/problems/combination-sum/discuss/2076/C++-Python-C#4.1.4\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(candidates) == 0:\n            return []\n        self.candidates = candidates\n        self.target = target\n        self.result = []\n\n        def dfs(candidates, target):\n            if target == 0:\n                result.append(list(candidates))\n                return\n            for i in range(len(candidates)):\n                if target - candidates[i] >= 0:\n                    candidates[i] -= 1\n                    dfs(candidates, target - candidates[i])\n                    candidates[i] += 1\n\n        dfs(self.candidates, self.target)\n        return self.result\n\n\nif __name__ == '__main__':\n    assert Solution().combinationSum([10,1,2,7,6,1,5], 8) == [[1,7,6,5], [1,2,1,5], [1,2,7,1]]\n    assert Solution().combinationSum([1,2,3,4,5], 10) == [[1,2,3,4,5]]\n    assert Solution().combinationSum([2,2], 5) == [[2]]\n    assert Solution().combinationSum([1,2,2], 3) == [[1,2]]",
      -6.81640625
    ],
    [
      "import unittest\nimport collections\nimport random\n\nclass Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates or target == 0:\n            return []\n        if target < 0:\n            return []\n        if target == 1:\n            return [self.nums]\n        candidates.sort()\n        result = []\n        self.helper(candidates, target, 0, [], result)\n        return result\n\n    def helper(self, candidates, target, curr_sum, result, curr_list):\n        if curr_sum == target:\n            result.append(curr_list)\n            return\n        for i in range(len(candidates)):\n            if curr_sum + candidates[i] > target:\n                break\n            curr_list.append(candidates[i])\n            self.helper(candidates, target, curr_sum + candidates[i], curr_list, result)\n            curr_list.pop()\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/combination-sum/solution/\n\nApproach #1: Backtracking [Accepted]\nComplexity Analysis\nTime Complexity: O(n!*k), where k is the number of candidates.\nSpace Complexity: O(n^2).\n\n# 16ms 97.57%\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (candidates == null || candidates.length == 0) return result;\n        Arrays.sort",
      -7.171875
    ],
    [
      "def get_combinations(arr):\n    if len(arr) == 0:\n        return []\n    result = []\n    for i in range(len(arr)):\n        if i == 0:\n            result.append(arr)\n        else:\n            for j in range(len(arr)):\n                if j == 0:\n                    result.append([arr[i]])\n                else:\n                    result.append(result[j - 1] + [arr[i]])\n    return result\n\n# print(get_combinations(['a', 'b', 'c']))\n# print(get_combinations(['a', 'b', 'c', 'd']))\nprint(get_combinations(['a', 'b', 'c', 'd', 'e']))",
      -7.5703125
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        self.backtrack(candidates, target, result, [])\n        return result\n\n    def backtrack(self, candidates, target, result, path):\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n        else:\n            for i in range(len(candidates)):\n                if candidates[i] < target:\n                    self.backtrack(candidates, target - candidates[i], result, path + [candidates[i]])\n                if candidates[i] == target:\n                    self.backtrack(candidates, target - candidates[i], result, path + [candidates[i]])\n                if candidates[i] > target:\n                    return",
      -7.66015625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def combinationSum(self, root: ListNode, sum: int) -> List[ListNode]:\n        \"\"\"\n        recursive\n        \"\"\"\n        if not root:\n            return []\n        res = []\n        self.helper(root, sum, res)\n        return res\n\n    def helper(self, root, sum, res):\n        if root.val > sum:\n            return\n        if root.val == sum:\n            res.append(root)\n        else:\n            for i in range(1, root.val + 1):\n                self.helper(root.next, sum - root.val, res)",
      -7.66796875
    ],
    [
      "def allCombinations(list):\n\tif not list:\n\t\treturn []\n\telse:\n\t\tif len(list) == 1:\n\t\t\treturn [[list[0]]]\n\t\telse:\n\t\t\tcombinations = []\n\t\t\tfor i in range(len(list)):\n\t\t\t\tfor j in range(len(list) - i):\n\t\t\t\t\tcombinations.append(list[i:len(list)])\n\t\t\treturn combinations\n\ndef printCombinations(list):\n\tif not list:\n\t\treturn\n\telse:\n\t\tfor combination in allCombinations(list):\n\t\t\tprint(combination)\n\nprint(\"=====================\")\nprintCombinations([1,2,3])\nprint(\"=====================\")\nprintCombinations([1,2,3,4])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9,10])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9,10,11])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9,10,11,12])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9,10,11,12,13])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,8,9,10,11,12,13,14])\nprint(\"=====================\")\nprintCombinations([1,2,3,4,5,6,7,",
      -8.125
    ],
    [
      "def combination(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:\n        yield [n]\n    else:\n        for i in combination(n - 1, k - 1):\n            for j in combination(n - 1, k - 1):\n                yield [n] + i + j\n\ndef combination2(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:\n        yield [n]\n    else:\n        for i in combination2(n - 1, k - 1):\n            for j in combination2(n - 1, k - 1):\n                yield [n] + i + j\n\ndef combination3(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:\n        yield [n]\n    else:\n        for i in combination3(n - 1, k - 1):\n            for j in combination3(n - 1, k - 1):\n                yield [n] + i + j\n\ndef combination4(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:\n        yield [n]\n    else:\n        for i in combination4(n - 1, k - 1):\n            for j in combination4(n - 1, k - 1):\n                yield [n] + i + j\n\ndef combination5(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:\n        yield [n]\n    else:\n        for i in combination5(n - 1, k - 1):\n            for j in combination5(n - 1, k - 1):\n                yield [n] + i + j\n\ndef combination6(n, k):\n    if n == 1:\n        yield []\n    if k == 0:\n        yield []\n    if k == 1:",
      -8.2265625
    ],
    [
      "# https://oj.leetcode.com/problems/combination-sum-iii/\n# Given a set of candidate numbers (C) (without duplicates)\n# and a target number T, find all possible combinations of size (N)\n# where each combination's sum equals target.\n#\n# The combinations are represented as a string.\n#\n# Example 1:\n# Input: candidates = [2,3,6,7], target = 7,\n# A solution set is:\n# [\n#   [\"7\"],\n#   [\"2\",\"6\"],\n#   [\"3\",\"6\"],\n#   [\"2\",\"3\",\"6\"]\n# ]\n#\n# Example 2:\n# Input: candidates = [4,1,2,3,5], target = 9,\n# A solution set is:\n# [\n#   [\"4\",\"1\",\"2\",\"3\",\"5\"],\n#   [\"4\",\"1\"],\n#   [\"4\",\"1\",\"2\"],\n#   [\"4\",\"1\",\"2\",\"3\"],\n#   [\"4\",\"1\",\"2\",\"5\"],\n#   [\"4\",\"1\",\"3\",\"5\"],\n#   [\"4\",\"1\",\"5\",\"3\"],\n#   [\"4\",\"2\",\"3\",\"5\"],\n#   [\"4\",\"2\",\"5\",\"3\"],\n#   [\"4\",\"3\",\"5\",\"3\"],\n#   [\"4\",\"3\"],\n#   [\"4\"],\n#   [\"5\",\"3\"],\n#   [\"5\"],\n#   [\"1\",\"3\"],\n#   [\"2\",\"3\"],\n#   [\"2\",\"5\"],\n#   [\"3\",\"5\"]\n# ]\n#\n# Note:\n#\n# 1 <= C.length <= 10000\n# 1 <= T <= 10000\n# All elements of candidates are distinct.\n#\n# Author:\n# - liuhb(Maintainers)\n\nclass Solution:\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum3(self, candidates, target):\n        # write your code here\n        candidates.sort()\n        res = []\n        self.helper(candidates, 0, target, res)\n        return res\n\n    def helper(self, candidates, start",
      -8.328125
    ],
    [
      "# https://leetcode.com/problems/combination-sum/discuss/273624/Java-Solution-using-recursion\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(candidates, target, res):\n            if not candidates:\n                return\n            if target < 0:\n                return\n            if target == 0:\n                res.append(list(candidates))\n            else:\n                for i in range(len(candidates)):\n                    if candidates[i] < target:\n                        dfs(candidates[:i] + candidates[i+1:], target - candidates[i], res)\n        res = []\n        dfs(candidates, target, res)\n        return res\n\nif __name__ == '__main__':\n    candidates = [1, 2, 3]\n    target = 6\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      -8.578125
    ],
    [
      "import collections\n\ndef combinationSum(self, target, candidates):\n    \"\"\"\n    :type target: int\n    :type candidates: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    combos = []\n    if not candidates:\n        return combos\n    if len(candidates) == 1:\n        if candidates[0] < target:\n            combos.append([candidates[0]])\n        return combos\n    # sort candidates in decreasing order\n    candidates = sorted(candidates, reverse=True)\n    # get all possible combinations of candidates\n    for i in range(len(candidates)):\n        for j in range(i+1, len(candidates)):\n            temp = candidates[i] + candidates[j]\n            if temp < target:\n                combos += self.combinationSum(target-temp, candidates[:j]+candidates[i+1:])\n    return combos\n\ndef test():\n    assert combinationSum([1,2,3], [1,2,3]) == [[1,2,3]]\n    assert combinationSum([1,2,3], [1,2]) == [[1,2],[1,3]]\n    assert combinationSum([1,2,3], [1]) == [[1],[2],[3]]\n    assert combinationSum([1,2,3], [2]) == [[1,2],[1,3]]\n    assert combinationSum([1,2,3], [3]) == [[1,2],[1,3]]\n    assert combinationSum([1,2,3], [4]) == []\n\nif __name__ == '__main__':\n    test()",
      -8.8125
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result=[], nums=[]):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type result: List[List[int]]\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return result\n        if not target:\n            return [result]\n        if target < 0:\n            return []\n        if target > len(candidates):\n            return []\n        if target == len(candidates):\n            result.append(list(nums))\n            return result\n        for i in range(target):\n            self.combine(candidates[i:], target-i, result, nums+[candidates[i]])\n            self.combine(candidates[:i], target-i, result, nums)\n        return result\n        \n        \n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = 9\n# param_3 = []\n# param_4 = [1,2,3]\n# param_5 = []\n# param_6 = [1,2,3,4]\n# obj.combine(param_1,param_2,param_3,param_4,param_5,param_6)",
      -9.203125
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combine(self, num):\n        if len(num) == 0:\n            return []\n        combine = [[num[0]]]\n        for i in range(1, len(num)):\n            for comb in combine:\n                comb.append(num[i])\n                comb = [list(set(comb))]\n        return combine\n\n    def combine2(self, num):\n        if len(num) == 0:\n            return []\n        combine = [[num[0]]]\n        for i in range(1, len(num)):\n            for comb in combine:\n                comb.append(num[i])\n                comb = [list(set(comb))]\n        return combine",
      -9.328125
    ],
    [
      "from collections import Counter\n\ndef combinations(lst, n):\n    \"\"\"\n    :type lst: List[int]\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for i in range(len(lst)):\n        if i == 0:\n            res.append([])\n        else:\n            res[i] = res[i-1]\n            for j in range(n-i):\n                res[i].append(lst[i])\n    return res\n\ndef combinations_with_replacement(lst, n):\n    \"\"\"\n    :type lst: List[int]\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for i in range(len(lst)):\n        if i == 0:\n            res.append([])\n        else:\n            res[i] = res[i-1]\n            for j in range(n-i):\n                res[i].append(lst[i])\n    return res\n\ndef combinations_with_replacement2(lst, n):\n    \"\"\"\n    :type lst: List[int]\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    res.append([])\n    for i in range(len(lst)):\n        if i == 0:\n            res.append([])\n        else:\n            res[i] = res[i-1]\n            for j in range(n-i):\n                res[i].append(lst[i])\n    return res\n\ndef combinations_with_replacement3(lst, n):\n    \"\"\"\n    :type lst: List[int]\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for i in range(len(lst)):\n        if i == 0:\n            res.append([])\n        else:\n            res[i] = res[i-1]\n            for j in range(n-i):\n                res[i].append(l",
      -9.890625
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a list of lists of integer\n    def combine(self, num):\n        if not num:\n            return []\n        res = []\n        self.combine_rec(res, [], num)\n        return res\n\n    def combine_rec(self, res, cur, num):\n        if not num:\n            res.append(cur)\n            return\n        for i in range(len(cur)):\n            self.combine_rec(res, cur[:i] + cur[i + 1:], num[:i])\n            self.combine_rec(res, cur[:i] + [cur[i]], num[i:])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.combine([1, 2, 3])",
      -10.015625
    ],
    [
      "# https://leetcode.com/problems/combination-sum/\n\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, res)\n        return res\n\n    def dfs(self, candidates, target, cur, res):\n        if cur > target:\n            return\n        if cur == len(candidates):\n            res.append(list(candidates[:cur]))\n            return\n        for i in range(cur, len(candidates)):\n            if candidates[i] > target:\n                continue\n            self.dfs(candidates, target, cur + 1, res)\n            self.dfs(candidates, target - candidates[i], cur + 1, res)",
      -10.7578125
    ],
    [
      "#!/usr/bin/python\n\n# https://oj.leetcode.com/problems/combination-sum/\n# Given a list of non-negative integers,\n# and a target integer, find all unique combinations of the elements in the list\n# that sum to the target.\n#\n# The solution set must not contain duplicate combinations.\n#\n# For example, given the following list:\n# [2, 3, 1]\n# and target = 5,\n#\n# A solution set is:\n# [\n#   [1, 2, 3],\n#   [1, 3, 1]\n# ]\n#\n# Note:\n# The solution set must not contain duplicate combinations.\n# The solution set must not contain any elements that is equal to the target.\n#\n# click to show follow up.\n#\n# Follow up:\n# Could you do it without extra space and in O(n) time?\n#\n# Companies\n# LinkedIn\n# Related Topics\n# Hash Table\n# Similar Questions\n# Combination Sum II\n#\nimport unittest\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution(object):\n    def combinationSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        nums.sort()\n        res = []\n        self.helper(nums, 0, target, res)\n        return res\n\n    def helper(self, nums, start, target, res):\n        if target == 0:\n            res.append(nums[start:])\n            return\n\n        for i in xrange(start, len(nums)):\n            if nums[i] > target:\n                break\n            self.helper(nums, i+1, target-nums[i], res)\n\nclass Solution2(object):\n    def combinationSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :",
      -10.7890625
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target, result=None):\n        if result is None:\n            result = [[]]\n        for index, value in enumerate(candidates):\n            if result[index-1]:\n                for x in self.combine(candidates[index+1:], target-value, result):\n                    result[index-1].append(x)\n            else:\n                result[index-1].append([value])\n        return result\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = self.combine(candidates, target, [[]])\n        return result",
      -11.5703125
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        combos = []\n        self.combine(combos, [], candidates, target, 0)\n        return combos\n\n    def combine(self, combos, cur, candidates, target, i):\n        if i == len(candidates):\n            if target == 0:\n                combos.append(cur)\n            return\n        for j in range(i, len(candidates)):\n            if target == 0:\n                combos.append(cur + [candidates[j]])\n                self.combine(combos, cur + [candidates[j]], candidates, target - candidates[j], j)\n            else:\n                self.combine(combos, cur + [candidates[j]], candidates, target, j)\n\n\nif __name__ == \"__main__\":\n    candidates = [2, 3, 6, 7]\n    target = 9\n    print Solution().combine(candidates, target)",
      -12.0
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a list of ListNode\n\tdef generate(self, head):\n\t\tif not head: return []\n\t\tif not head.next: return [head]\n\t\t\n\t\tif not head.next.next:\n\t\t\treturn [head] + self.generate(head.next)\n\t\telse:\n\t\t\tlst = []\n\t\t\tfor node in self.generate(head.next):\n\t\t\t\tlst.append(node)\n\t\t\t\tlst.append(head)\n\t\t\treturn lst + self.generate(head.next.next)\n\nif __name__ == '__main__':\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\tprint Solution().generate(head)",
      -12.7109375
    ],
    [
      "# https://leetcode.com/problems/combination-sum/description/\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # http://www.programcreek.com/2012/12/leetcode-combination-sum/\n        dp = [ [0] * (len(candidates)+1) ]\n        for i in range(1, len(candidates)+1):\n            dp[0][i] = 1\n        for i in range(1, len(dp)):\n            for j in range(1, i+1):\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        ans = []\n        for i in range(len(candidates), -1, -1):\n            if target - candidates[i-1] > 0:\n                ans.append(candidates[i-1:])\n                target -= candidates[i-1]\n            else:\n                break\n        return ans\n\nif __name__ == '__main__':\n    candidates = [1,2,3]\n    target = 4\n    print Solution().combinationSum(candidates, target)",
      -12.78125
    ],
    [
      "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        if target == 0:\n            result.append([])\n            return result\n        if not candidates:\n            return result\n        i = 0\n        while i < len(candidates):\n            if target < candidates[i]:\n                return []\n            if target == candidates[i]:\n                result.append([candidates[i]])\n                i += 1\n                while i < len(candidates) and target - candidates[i] >= 0:\n                    result[-1].append(candidates[i])\n                    i += 1\n            else:\n                while i < len(candidates) and target - candidates[i] >= 0:\n                    result.append([])\n                    result[-1].append(candidates[i])\n                    i += 1\n        return result\n\nclass Solution2(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        if target == 0:\n            result.append([])\n            return result\n        if not candidates:\n            return result\n        i = 0\n        while i < len(candidates):\n            if target < candidates[i]:\n                return []\n            if target == candidates[i]:\n                result.append([candidates[i]])\n                i += 1\n                while i < len(candidates) and target - candidates[i] >= 0:\n                    result[-1].append(candidates[i])\n                    i += 1\n            else:\n                while i < len(candidates) and target - candidates[i] >= 0:\n                    result.append([])\n                    result[-1].append(candidates[i])\n                    i += 1\n        return result\n\n\nif __name__ == '__main__':\n    candidates = [1, 2, 3]\n    target =",
      -12.8359375
    ],
    [
      "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # base case: no combination\n        if not candidates or target == 0:\n            return []\n\n        # base case: only one candidate\n        if target == 1:\n            return [[candidates[0]]]\n\n        # base case: only one number\n        if len(candidates) == 1:\n            return [[candidates[0]]]\n\n        # base case: only one number\n        if len(candidates) == 2:\n            return [[candidates[0], candidates[1]], [candidates[0], 0], [0, candidates[1]], [0, candidates[0]]]\n\n        # base case: no number\n        if len(candidates) == 3:\n            return [[], [0, candidates[0]], [0, candidates[0], candidates[1]], [0, candidates[0], 0], [0, candidates[1], candidates[2]],\n                    [0, candidates[1], 0], [0, candidates[2], candidates[0]], [0, candidates[2], 0], [0, 0, candidates[0]],\n                    [0, 0, candidates[0], candidates[1]], [0, 0, candidates[0], 0], [0, 0, candidates[1], candidates[2]],\n                    [0, 0, candidates[1], 0], [0, 0, candidates[2], candidates[0]], [0, 0, candidates[2], 0], [0, 0, 0, candidates[0]],\n                    [0, 0, 0, candidates[0], candidates[1]], [0, 0, 0, candidates[0], 0], [0, 0, 0, candidates[1], candidates[2]],\n                    [0, 0, 0, candidates[1], 0], [0, 0, 0, candidates[2], candidates[0]], [0, 0, 0, candidates[2], 0]]\n\n        # recursive case: combinations\n        combinations = self.combinationSum(candidates[1:], target-candidates[0])\n        for",
      -13.8984375
    ],
    [
      "class Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.result = []\n\n    def backtracking(self, cur_index, res):\n        if cur_index >= len(self.nums):\n            self.result.append(res)\n            return\n        for i in range(cur_index, len(self.nums)):\n            res.append(self.nums[cur_index])\n            self.backtracking(i, res)\n            res.pop()\n\n    def combinationSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.result = []\n        self.backtracking(0, [])\n        return self.result\n\n    def combinationSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.result = []\n        self.backtracking(0, [])\n        return self.result\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.combinationSum(nums,target)\n# param_2 = obj.combinationSum2(nums,target)",
      -13.9140625
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def generateTrees(self, root):\n        if not root:\n            return []\n        self.res = []\n        self.helper(root)\n        return self.res\n\n    def helper(self, root):\n        if not root:\n            return\n        self.helper(root.left)\n        self.helper(root.right)\n        curr = [root]\n        while curr:\n            res = []\n            for i in range(len(curr)):\n                curr[i].left = None if curr[i].left is None else curr[i].left.val + curr[i].val\n                curr[i].right = None if curr[i].right is None else curr[i].right.val + curr[i].val\n                res.append(curr[i])\n            self.res.append(res)\n            curr = res[::-1]\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().generateTrees(root)",
      -14.03125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def combine(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[ListNode]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [[nums[0]]]\n        res = []\n        for i in range(1, k+1):\n            if k == 0:\n                break\n            res_tmp = []\n            for node in res:\n                curr_node = ListNode(0)\n                curr_node.next = node\n                res_tmp.append(curr_node)\n            res = res_tmp\n            for j in range(len(nums)):\n                curr_node = res[j]\n                curr_node.val += nums[j]\n                if curr_node.val == nums[j]:\n                    curr_node.next = res[j+1]\n                    res[j+1] = curr_node\n                    k -= 1\n                    break\n        return res\n\n    def combine_2(self, nums, k):\n        res = []\n        for i in range(1, k+1):\n            if k == 0:\n                break\n            res_tmp = []\n            for j in range(len(nums)):\n                curr_node = ListNode(0)\n                curr_node.next = res_tmp\n                res_tmp.append(curr_node)\n            res.extend(res_tmp)\n            for j in range(len(nums)):\n                curr_node = res[j]\n                curr_node.val += nums[j]\n                if curr_node.val == nums[j]:\n                    curr_node.next = res[j+1]\n                    res[j+1] = curr_node\n                    k -= 1\n                    break\n        return res",
      -14.1171875
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integer\n    def generateTrees(self, root):\n        if not root:\n            return [[]]\n        res = []\n        self.helper(root, res)\n        return res\n\n    def helper(self, root, res):\n        if root.left and root.right:\n            if root.left.val == root.right.val:\n                res.append([root])\n            else:\n                res.append([root, root.right])\n                self.helper(root.left, res)\n                self.helper(root.right, res)\n        elif root.left:\n            res.append([root, root.left])\n            self.helper(root.left, res)\n        elif root.right:\n            res.append([root, root.right])\n            self.helper(root.right, res)\n\nif __name__ == '__main__':\n    t = TreeNode(1)\n    t.left = TreeNode(2)\n    t.right = TreeNode(3)\n    t.left.left = TreeNode(4)\n    t.left.right = TreeNode(5)\n    t.right.left = TreeNode(6)\n    t.right.right = TreeNode(7)\n    print(Solution().generateTrees(t))",
      -14.21875
    ],
    [
      "class Solution(object):\n    def combine(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        self.helper(candidates, target, result, [])\n        return result\n\n    def helper(self, candidates, target, result, path):\n        if len(candidates) == 0:\n            if target == 0:\n                result.append(path[:])\n            return\n        for i in range(target):\n            self.helper(candidates[:], target - i, result, path + [i])\n\ns = Solution()\ns.combine([1, 2, 3], 4)\nprint s.combine([1, 2, 3], 4)",
      -14.484375
    ],
    [
      "# https://www.youtube.com/watch?v=Q-Q_cFdHx7E\n# https://www.youtube.com/watch?v=KzE3s_ZhxWc\n# https://www.youtube.com/watch?v=4pQ_cFdHx7E\n\ndef combinations(arr, n):\n    if n == 0:\n        return [[]]\n    elif n == 1:\n        return [[0]]\n    else:\n        result = []\n        for i in range(n):\n            result.append(combinations(arr, n - 1))\n        result.append(arr)\n        return result\n\ndef getCombinations(arr):\n    result = []\n    for i in range(len(arr)):\n        for j in combinations(arr, i):\n            result.append(j)\n    return result\n\ndef getCombinations2(arr):\n    result = []\n    for i in range(len(arr)):\n        for j in combinations(arr, i):\n            result.append(j)\n    return result\n\ndef getCombinations3(arr):\n    result = []\n    for i in range(len(arr)):\n        for j in combinations(arr, i):\n            result.append(j)\n    return result\n\ndef getCombinations4(arr):\n    result = []\n    for i in range(len(arr)):\n        for j in combinations(arr, i):\n            result.append(j)\n    return result\n\n# print(getCombinations(arr))\n# print(getCombinations2(arr))\n# print(getCombinations3(arr))\n# print(getCombinations4(arr))\n\nprint(getCombinations(arr))\nprint(getCombinations2(arr))\nprint(getCombinations3(arr))\nprint(getCombinations4(arr))",
      -14.796875
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# https://leetcode.com/problems/combination-sum/\n\nimport itertools\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        return self.combinationSumUtil(candidates, target, [])\n\n    def combinationSumUtil(self, candidates, target, result):\n        if len(candidates) == 0:\n            return [[]]\n\n        if target < 0:\n            return []\n\n        for i in range(0, len(candidates)):\n            if candidates[i] > target:\n                break\n            if target == 0:\n                result.append(list(candidates[:i+1]))\n            else:\n                for j in range(i+1, len(candidates)):\n                    if candidates[j] > target:\n                        break\n                    else:\n                        result.append(list(candidates[:i+1]))\n                        result += self.combinationSumUtil(candidates[j+1:], target-candidates[j], result)\n        return result\n\nclass Solution2(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        self.combinationSumUtil(candidates, target, result)\n        return result\n\n    def combinationSumUtil(self, candidates, target, result):\n        if len(candidates) == 0:\n            return []\n\n        if target < 0:\n            return []\n\n        for i in range(0, len(candidates)):\n            if candidates[i] > target:\n                break\n            else:\n                self.combinationSumUtil(candidates[i+1:], target-candidates[i], result)\n        return result\n\n\nif __name__ == '__",
      -14.96875
    ],
    [
      "def get_combinations(list_of_elements):\n    \"\"\"\n    Return a list of lists, where each list contains all possible combinations of the elements of list_of_elements.\n\n    For example, given the list [1,2,3],\n    the function should return\n    [[1,2,3],[1,3],[2,3],[1,2],[3,3],[1,1,2,3],[1,2,3],[1,3,3],[2,3,3]]\n    \"\"\"\n    return [combinations(list_of_elements, i) for i in range(1, len(list_of_elements) + 1)]\n\n\ndef combinations(list_of_elements, num_elements):\n    \"\"\"\n    Return a list of lists, where each list contains all possible combinations of the elements of list_of_elements.\n\n    For example, given the list [1,2,3],\n    the function should return\n    [[1,2,3],[1,3],[2,3],[1,2],[3,3],[1,1,2,3],[1,2,3],[1,3,3],[2,3,3]]\n    \"\"\"\n    if num_elements == 0:\n        return [[]]\n\n    return [combinations(list_of_elements, i) for i in range(1, num_elements + 1)]\n\n\ndef get_combinations_2(list_of_elements):\n    \"\"\"\n    Return a list of lists, where each list contains all possible combinations of the elements of list_of_elements.\n\n    For example, given the list [1,2,3],\n    the function should return\n    [[1,2,3],[1,3],[2,3],[1,2],[3,3],[1,1,2,3],[1,2,3],[1,3,3],[2,3,3]]\n    \"\"\"\n    return [[] for _ in range(len(list_of_elements))]\n\n\ndef combinations_2(list_of_elements, num_elements):\n    \"\"\"\n    Return a list of lists, where each list contains all possible combinations of the elements of list_of_elements.\n\n    For example",
      -15.3359375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a list of ListNode\n    def generate(self, head):\n        res = []\n        self.dfs(res, head, [])\n        return res\n\n    def dfs(self, res, head, path):\n        if head is None:\n            return\n        if len(path) == len(head.val):\n            res.append(path)\n            return\n        path.append(head)\n        self.dfs(res, head.next, path)\n        path.pop()\n\n\nif __name__ == '__main__':\n    res = Solution().generate([1, 2, 3])\n    print(res)",
      -16.046875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}