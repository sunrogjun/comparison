{
  "problem": {
    "task_id": "MBPP/19",
    "prompt": "Write a function to find whether a given array of integers contains any duplicate element.",
    "canonical_solution": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ",
    "test_list": [
      "assert test_duplicate(([1,2,3,4,5]))==False",
      "assert test_duplicate(([1,2,3,4, 4]))==True",
      "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
    ],
    "challenge_test_list": [],
    "problem_id": 8
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        # use set to record duplicates\n        set_nums = set(nums)\n        # check if duplicates exist\n        if len(set_nums)!= len(nums):\n            return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.containsDuplicate([1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4])\n    print s.containsDuplicate([1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10])\n    print s.containsDuplicate([1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 6, 7, 7, 8, 9, 9, 10, 10, 10])",
      4.14453125
    ],
    [
      "class Solution:\n    # @param num, a list of integers\n    # @return a boolean\n    def containsDuplicate(self, num):\n        if not num:\n            return False\n        hashset = set()\n        for e in num:\n            if e in hashset:\n                return True\n            hashset.add(e)\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.containsDuplicate([1,1,2,2,3,4,5,5,6])\n    print s.containsDuplicate([1,1,1,2,2,3,3,3,3,4,5,6])\n    print s.containsDuplicate([1,2,3,4,5,6])\n    print s.containsDuplicate([1,1,2,2,3,3,3,3,4,5,6,6])\n    print s.containsDuplicate([1,2,3,4,5,6,6,7,7,7,7,7,7,7,7])",
      4.1015625
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return False\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False",
      3.8359375
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        n = len(nums)\n        d = [1] * n\n        for i in xrange(n):\n            if i > 0 and nums[i] == nums[i-1]:\n                d[i] = d[i-1] + 1\n        for i in xrange(n-k+1, n):\n            if d[i] > k:\n                d[i] = 1\n        for i in xrange(n-k+1, n):\n            if nums[i] == nums[i-1]:\n                d[i] = d[i-1] + 1\n        return any(d[i] == k for i in xrange(n-k+1, n))",
      3.701171875
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return False\n        m = {}\n        for i in nums:\n            if i in m:\n                return True\n            else:\n                m[i] = i\n        return False\n\n\"\"\"\n    solution:\n    1. sort the input array, then find the first number that is not in the sorted array.\n    2. if the first number is not in the sorted array, then return True.\n    3. if the first number is in the sorted array, then return False.\n\"\"\"",
      3.18359375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: An integer array\n    @return: A boolean\n    \"\"\"\n    def containsDuplicate(self, nums):\n        # write your code here\n        # dp[i] = 0 means there is no duplicate at index i\n        # dp[i] = 1 means there is a duplicate at index i\n        # dp[i] = 2 means there are two duplicate at index i\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    dp[i] = 2\n                    dp[j] = 2\n                    break\n            else:\n                dp[i] = 1\n        return dp[len(nums) - 1] == 2\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 2, 3, 1]\n    print(s.containsDuplicate(nums))",
      1.8701171875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        if not nums:\n            return False\n        dic = {}\n        for i in nums:\n            if i in dic:\n                return True\n            dic[i] = 1\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.containsDuplicate([1, 1, 2])\n    print s.containsDuplicate([1, 2, 2])\n    print s.containsDuplicate([2, 2])\n    print s.containsDuplicate([3, 3, 3])",
      1.466796875
    ],
    [
      "# https://oj.leetcode.com/problems/contains-duplicate/discuss/83639/Java-O(N)-Time-and-O(1)-Space-Solution\n\n# def contains_duplicate(nums):\n#     for i in range(1, len(nums)):\n#         if nums[i] == nums[i-1]:\n#             return True\n#     return False\n\ndef contains_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    # https://leetcode.com/problems/contains-duplicate/discuss/63888/Java-O(N)-Time-and-O(1)-Space-Solution\n    if len(nums) == 0:\n        return False\n\n    # for i in range(len(nums)):\n    #     if nums[i] == nums[i-1]:\n    #         return True\n\n    # return False\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False",
      1.2490234375
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a boolean\n    def containsDuplicate(self, intervals):\n        # write your code here\n        if not intervals:\n            return False\n\n        n = len(intervals)\n        dic = {}\n        for i in range(n):\n            if intervals[i].start in dic:\n                return True\n            dic[intervals[i].start] = i\n            if intervals[i].end in dic:\n                return True\n            dic[intervals[i].end] = i\n\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.containsDuplicate([Interval(1, 2), Interval(1, 3), Interval(2, 3)])\n    print s.containsDuplicate([Interval(1, 2), Interval(1, 3), Interval(1, 4), Interval(2, 3)])\n    print s.containsDuplicate([Interval(1, 2), Interval(1, 3), Interval(2, 3), Interval(2, 4), Interval(3, 4)])\n    print s.containsDuplicate([Interval(1, 2), Interval(1, 3), Interval(2, 3), Interval(2, 4), Interval(3, 4), Interval(4, 5)])",
      1.1611328125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3]",
      0.88037109375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return self.check(nums, 0, nums.__len__()-1)\n\n    def check(self, nums, start, end):\n        if start == end:\n            return False\n        if nums[start] == nums[end]:\n            return True\n        mid = (start + end) / 2\n        if self.check(nums, start, mid) or self.check(nums, mid+1, end):\n            return True\n        return False\n\nif __name__ == '__main__':\n    print Solution().containsDuplicate([1,1,2,3,3])\n    print Solution().containsDuplicate([1,1,2,2,3])\n    print Solution().containsDuplicate([1,2,2,3,3,3])",
      0.80908203125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        \n        for i in xrange(len(nums)):\n            if i!= 0 and nums[i] == nums[i-1]:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().containsDuplicate([1, 1, 1, 2, 2, 3])",
      0.79541015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums: return False\n        if len(nums) == 1: return False\n        # map to set\n        map = {}\n        for num in nums:\n            if num not in map: map[num] = 1\n            else: map[num] += 1\n        # find all duplicates\n        for num, times in map.items():\n            if times > 1: return True\n        return False\n\n# Test\ns = Solution()\nprint(s.containsDuplicate([1, 1, 2, 2, 3, 3]))\nprint(s.containsDuplicate([1, 1, 1]))\nprint(s.containsDuplicate([1, 1, 1, 1]))\nprint(s.containsDuplicate([1, 2, 3, 4, 5, 6]))\nprint(s.containsDuplicate([1, 2, 3, 4, 5, 6, 7]))",
      0.7880859375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n\n        return False\n\nif __name__ == \"__main__\":\n    assert Solution().containsDuplicate([1, 1, 2, 3, 2, 2]) == True\n    assert Solution().containsDuplicate([1, 2, 3, 1, 2, 3]) == False\n    assert Solution().containsDuplicate([1, 2, 2, 3, 3, 3]) == True",
      0.68505859375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # use map to check if any two elements are duplicated\n        mapper = {i: i for i in range(len(nums))}\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    if mapper[i] == mapper[j]:\n                        return True\n        return False\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.containsDuplicate([1, 1, 1]))\n    print(sol.containsDuplicate([1, 2, 3]))\n    print(sol.containsDuplicate([1, 2, 2]))\n    print(sol.containsDuplicate([1, 1, 2, 2, 2]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6, 7]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(sol.containsDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))",
      0.2578125
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return a boolean\n    def containsDuplicate(self, num):\n        # write your code here\n        # use a set to record duplicate values\n        # return whether any duplicate value is found\n        if len(num) < 2:\n            return False\n        dup_set = set()\n        for i in range(len(num)):\n            if num[i] in dup_set:\n                return True\n            dup_set.add(num[i])\n        return False\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.containsDuplicate([1,2,3,4])",
      0.12384033203125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        m = {}\n        for n in nums:\n            if n in m:\n                return True\n            m[n] = True\n        return False\n\n# test\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [1, 1, 2, 2, 3, 4, 5, 6, 7]\n    print s.containsDuplicate(nums)",
      0.09857177734375
    ],
    [
      "# https://leetcode.com/problems/contains-duplicate/discuss/91322/Java-O(NlogN)-solution-in-O(N)-time-and-space\n\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/discuss/91322/Java-O(NlogN)-solution-in-O(N)-time-and-space\n        # Using two hashmap to store the two different indexes of the array.\n        # Hashmap<Integer, Integer> map1 = new HashMap<Integer, Integer>();\n        # HashMap<Integer, Integer> map2 = new HashMap<Integer, Integer>();\n        # for(int i=0; i<nums.length; i++){\n        #     if(map1.containsKey(nums[i])){\n        #         return true;\n        #     }else{\n        #         map1.put(nums[i], i);\n        #     }\n        # }\n        # for(int i=0; i<nums.length; i++){\n        #     if(map2.containsKey(nums[i])){\n        #         return true;\n        #     }else{\n        #         map2.put(nums[i], i);\n        #     }\n        # }\n        # return map1.containsKey(nums[0]) || map2.containsKey(nums[0]);\n        return False\n        \n        # https://discuss.leetcode.com/topic/70984/java-o-n-log-n-solution-in-o-n-time-and-space-and-java-8-solution-in-java-8-solution-in-o-n-time-and-space-and-java-8-solution-in-o-n-time-and-space-and-java-8-solution-in-o-n-time-and-space\n        # Using two hashmap to store",
      -0.232666015625
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n        \n    def __repr__(self):\n        return str(self.start) + \" \" + str(self.end)\n        \nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a boolean\n    def containsDuplicate(self, intervals):\n        # write your code here\n        if len(intervals) == 0:\n            return False\n        \n        intervals.sort()\n        \n        flag = False\n        for i in range(len(intervals) - 1):\n            if intervals[i].end == intervals[i + 1].start:\n                flag = True\n                break\n            \n        if flag:\n            return True\n        \n        return False",
      -0.24609375
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < k:\n            return False\n        k -= 1\n        nums.sort()\n        # find the first k elements\n        for i in range(len(nums) - k):\n            if nums[i] == nums[i + k]:\n                return True\n        return False",
      -0.297119140625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return False\n        if n == 1:\n            return False\n        if n == 2:\n            return nums[0] == nums[1]\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = True\n                    dp[j][i] = True\n        for i in range(n):\n            if dp[i][i]:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().containsDuplicate([1, 1, 2, 2, 3])",
      -0.37646484375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a boolean\n    def hasDuplicate(self, intervals):\n        intervals.sort()\n        return self.find_duplicate(intervals)\n    def find_duplicate(self, intervals):\n        if len(intervals) == 0:\n            return False\n        for i in range(1, len(intervals)):\n            if intervals[i].end < intervals[i-1].end:\n                return True\n        return False",
      -0.52783203125
    ],
    [
      "def contains_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    \n    if len(nums) == 0:\n        return False\n\n    num_set = set(nums)\n    \n    return len(num_set)!= len(nums)",
      -0.7021484375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        count = {}\n        for i in nums:\n            if i in count:\n                return True\n            else:\n                count[i] = 1\n        return False",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        \n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n        return False",
      -0.85595703125
    ],
    [
      "# https://leetcode.com/problems/contains-duplicate/discuss/281811/C%2B%2B-Java-DP-solution\n\n# https://leetcode.com/problems/contains-duplicate/discuss/281811/Java-DP-solution\nclass Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums) - k):\n            if nums[i] == nums[i + k]:\n                return True\n        return False",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n\n        num_set = set(nums)\n        for i in range(1, len(nums)):\n            if nums[i] in num_set:\n                return True\n            num_set.add(nums[i])\n        return False",
      -0.85693359375
    ],
    [
      "def contains_duplicate(arr):\n    # write your code here\n    if len(arr) == 0:\n        return False\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            return True\n    return False\n\ndef main():\n    print(contains_duplicate([1, 1, 2, 2, 3, 3, 3]))\n    print(contains_duplicate([1, 2, 3, 4, 5]))\n    print(contains_duplicate([1, 2, 3, 4, 5, 5]))\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        count = collections.Counter(nums)\n        for i in range(len(nums)):\n            if count[nums[i]] > 1:\n                return True\n        return False",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n        return False",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        if not nums:\n            return False\n        if not nums[0]:\n            return False\n        n = len(nums)\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.containsDuplicate([1, 1, 2, 3, 2, 2])",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        d = {}\n        for i in range(len(nums)):\n            if i - k in d:\n                return True\n            d[i] = nums[i]\n        return False",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        hash_table = {}\n        for num in nums:\n            if num in hash_table:\n                return True\n            hash_table[num] = 1\n        return False",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param nums: an integer array\n    # @return a boolean\n    def containsDuplicate(self, nums):\n        if not nums:\n            return False\n        for i in xrange(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    print Solution().containsDuplicate([1, 1, 2, 3])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n        return False",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.containsDuplicate([1,1,1])\n    print s.containsDuplicate([1,2,3])\n    print s.containsDuplicate([1,2,3,3])\n    print s.containsDuplicate([1,2,2,3,3])\n    print s.containsDuplicate([1,2,3,4,5])",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return False\n        count = {}\n        for num in nums:\n            if num in count:\n                return True\n            else:\n                count[num] = count.get(num, 0) + 1\n        return False",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        # write your code here\n        if not nums:\n            return False\n        \n        if len(nums) == 1:\n            return False\n        \n        n = len(nums)\n        \n        for i in range(n-1):\n            if nums[i] == nums[i+1]:\n                return True\n        \n        return False",
      -0.85791015625
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @return {boolean}\n    def containsDuplicate(self, intervals):\n        if not intervals:\n            return False\n        d = collections.defaultdict(list)\n        for i in intervals:\n            d[i.start].append(i)\n        for i in intervals:\n            d[i.end].append(i)\n        for i in intervals:\n            if len(d[i.end]) > 1:\n                return True\n        return False",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def containsDuplicate(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        intervals.sort(key=lambda x: x.start)\n        last = intervals[0].start\n        for i in xrange(1, len(intervals)):\n            if intervals[i].start <= last:\n                return True\n            last = intervals[i].end\n        return False",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if k > len(intervals):\n            return False\n        intervals.sort()\n        ans = False\n        for i in range(len(intervals) - k + 1):\n            if i + k > len(intervals):\n                break\n            if intervals[i].end < intervals[i + k].start:\n                continue\n            if intervals[i].start < intervals[i + k].end:\n                ans = True\n                break\n        return ans",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    print(Solution().containsDuplicate([2,2,3,3]))\n    print(Solution().containsDuplicate([1,1,1,2]))\n    print(Solution().containsDuplicate([1,2,3,3,3,5]))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        for i in xrange(len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().containsDuplicate([1,1,1,2,2,3])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return False\n        for i in range(n):\n            j = i + 1\n            while j < n:\n                if nums[i] == nums[j]:\n                    return True\n                j += 1\n        return False",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        # write your code here\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return False\n        # check if there is duplicated element\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n\nif __name__ == '__main__':\n    print Solution().containsDuplicate([1,1,1,2,2,3,3,4,4])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # dp\n        # time: O(n)\n        # space: O(n)\n        nums.sort()\n        for i in xrange(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False",
      -0.8583984375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A boolean\n    \"\"\"\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return self.check(nums, 0, len(nums))\n    \n    def check(self, nums, start, end):\n        if start == end:\n            return False\n        \n        if start == end - 1:\n            return nums[start] == nums[end - 1]\n        \n        mid = (start + end) / 2\n        \n        if nums[start] == nums[mid]:\n            return self.check(nums, mid + 1, end)\n        else:\n            return self.check(nums, start, mid)",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {Interval[]} intervals\n    # @return {boolean}\n    def hasDuplicate(self, intervals):\n        if not intervals:\n            return False\n        intervals.sort()\n        prev = intervals[0].start\n        for i in range(1, len(intervals)):\n            if prev == intervals[i].start:\n                return True\n            prev = intervals[i].start\n        return False",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n\n        nums.sort()\n        for i in xrange(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # time complexity: O(n)\n        # space complexity: O(1)\n        n = len(nums)\n        if n <= 1:\n            return False\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                return True\n        return False",
      -0.8583984375
    ],
    [
      "class Solution:\n\t# @return a boolean\n\tdef containsDuplicate(self, nums):\n\t\tif len(nums) < 2:\n\t\t\treturn False\n\t\treturn self.findDuplicate(nums)!= -1\n\t\n\tdef findDuplicate(self, nums):\n\t\tfor i in xrange(1, len(nums)):\n\t\t\tif nums[i] == nums[i-1]:\n\t\t\t\treturn i\n\t\treturn -1\n\nif __name__ == \"__main__\":\n\ts = Solution()\n\tprint s.findDuplicate([1,2,3,4,4])\n\tprint s.findDuplicate([1,1,1,1,1,1,1])\n\tprint s.findDuplicate([1,2,3,4,5])\n\tprint s.findDuplicate([1,1,1,1,1,1,1,1])",
      -0.8583984375
    ],
    [
      "def contains_duplicates(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    # https://leetcode.com/problems/contains-duplicate-ii/discuss/251344/C++-DP-solution-with-O(n)-time-and-O(1)-space\n    dp = [False for _ in range(len(nums))]\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                dp[i] = True\n                dp[j] = True\n                break\n    return any(dp)\n\n\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return len(nums) > 1 and contains_duplicates(nums)",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if k <= 0:\n            return False\n        if len(nums) <= 1:\n            return False\n        if len(nums) <= k:\n            return True\n        if k == 1:\n            return nums[0] == nums[1]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                if i == k:\n                    return True\n                else:\n                    return False\n        return False",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param nums, a list of integers\n    # @return a boolean\n    def containsDuplicate(self, nums):\n        # write your code here\n        return self.check(nums)\n\n    def check(self, nums):\n        # write your code here\n        if len(nums) == 1:\n            return False\n        else:\n            return self.check(nums[1:]) or nums[0] == nums[1]",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] == nums[j]:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.containsDuplicate([1,1,2,2,3])\n    print sol.containsDuplicate([1,1,2,3,3])\n    print sol.containsDuplicate([1,2,2,3,3,3,4])\n    print sol.containsDuplicate([1,1,1,2,2,2,3,3,3,3])\n    print sol.containsDuplicate([2,3,4,5,6])",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def dfs(i, j):\n            if i == j:\n                return False\n            if i == len(nums)-1:\n                return True\n            if nums[i] == nums[j]:\n                return dfs(i+1, j+1)\n            else:\n                return dfs(i+1, j)\n        return dfs(0, 0)",
      -0.85888671875
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsDuplicate(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: bool\n        \"\"\"\n        sorted_intervals = sorted(intervals, key=lambda x: x.start)\n        for i in range(1, len(intervals)):\n            if sorted_intervals[i].start - sorted_intervals[i-1].end > 0:\n                return True\n        return False",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums: return False\n        if len(nums) == 1: return False\n\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param num, a list of integers\n    # @return a boolean\n    def containsDuplicate(self, num):\n        return self.findDuplicate(num)\n\n    def findDuplicate(self, num):\n        if len(num) == 0:\n            return False\n\n        for i in range(len(num) - 1):\n            if num[i] == num[i + 1]:\n                return True\n        return False",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        hashset = set()\n        for num in nums:\n            if num in hashset:\n                return True\n            hashset.add(num)\n        return False",
      -0.86083984375
    ],
    [
      "# https://leetcode.com/problems/contains-duplicate/discuss/332413/Java-O(n)-solution-using-hash-set-and-hash-map\n\n# Note: This is a copy of the question, with the same solution\n# from leetcode.com/problems/contains-duplicate/discuss/332413/Java-O(n)-solution-using-hash-set-and-hash-map\n\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n#         self.start_inc = e - s\n#         self.end_inc = 0\n#\n#     def __repr__(self):\n#         return str(self.start) + \" \" + str(self.end)\n\nclass Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        hash = {}\n        for num in nums:\n            if num in hash:\n                return True\n            hash[num] = True\n        return False\n\n# Note: This is a copy of the question, with the same solution\n# from leetcode.com/problems/contains-duplicate/discuss/332413/Java-O(n)-solution-using-hash-set-and-hash-map\n\n# Note: This is a copy of the question, with the same solution\n# from leetcode.com/problems/contains-duplicate/discuss/332413/Java-O(n)-solution-using-hash-set-and-hash-map\n\nclass Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        hash = {}\n        for num in nums:\n            if num in hash:\n                return",
      -1.1171875
    ],
    [
      "class Solution:\n    # @param A, a list of integer\n    # @return a boolean\n\n    def containsDuplicate(self, A):\n        # Write your code here\n        if len(A) == 0:\n            return False\n        if len(A) == 1:\n            return False\n        for i in range(len(A)-1):\n            if A[i] == A[i+1]:\n                return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.containsDuplicate([1,1,1])\n    print s.containsDuplicate([1,2,3])\n    print s.containsDuplicate([1,1,2,2,3])",
      -1.1943359375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def containsDuplicate(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/contains-duplicate/discuss/140716/My-O(n^2)-solution\n        # O(n^2) time and space\n        if not intervals:\n            return False\n\n        # sort the intervals by start\n        intervals = sorted(intervals, key=lambda x: x.start)\n\n        # O(n^2) time and space\n        for i in range(len(intervals) - 1):\n            if intervals[i].start == intervals[i + 1].start:\n                return True\n\n        return False",
      -1.1962890625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return self.containsDuplicate_dp(nums)\n\n    def containsDuplicate_dp(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n\n        m = len(nums)\n        n = len(nums[0])\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = False\n                else:\n                    if dp[i - 1][j - 1]:\n                        dp[i][j] = True\n                    else:\n                        dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        return any(dp[-1][-1])",
      -1.3876953125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                return True\n        return False\n\nif __name__ == '__main__':\n    print Solution().containsDuplicate([1,1,1,2,3])\n    print Solution().containsDuplicate([1,2,2])",
      -1.392578125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/details/22738039\n        # http://blog.csdn.net/lzjy/article/",
      -1.5615234375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/contains-duplicate/discuss/160900/Python-Solution-using-set-and-hash\n        # https://discuss.leetcode.com/topic/1568/java-solution-using-set-and-hash-hashmap\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # http://blog.csdn.net/linhuanmars/article/details/18263084\n        # https://discuss.leetcode.com/topic/14053/java-solution-using-set-and-hash-hashmap\n        # https://discuss.leetcode.com/topic/19154/java-solution-using-set-and-hash-hashmap\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/17590/java-solution-with-explanation\n        # https://discuss.leetcode",
      -1.587890625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if len(nums) % 2 == 0:\n            return self.containsDuplicate(nums[:len(nums)//2]) or self.containsDuplicate(nums[len(nums)//2:])\n        else:\n            return self.containsDuplicate(nums[1:])",
      -1.8681640625
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # http://www.cnblogs.com/grandyang/p/3770380.html\n        # http://www.cnblogs.com/grandyang/p/3770381.html\n        # http://blog.csdn.net/wangjianping/article/details/7779086\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuanjinwang/article/details/8024141\n        # http://blog.csdn.net/yuan",
      -1.9052734375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param: A list of integers\n    @return: True if the array contains any duplicate, False if not\n    \"\"\"\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return self.findDuplicate(nums, 0, len(nums) - 1)\n\n    def findDuplicate(self, nums, left, right):\n        if left > right:\n            return False\n\n        mid = (left + right) / 2\n        if nums[mid] == nums[right]:\n            return True\n        elif nums[mid] < nums[right]:\n            return self.findDuplicate(nums, mid + 1, right)\n        elif nums[mid] > nums[right]:\n            return self.findDuplicate(nums, left, mid - 1)\n        else:\n            return False\n\ns = Solution()\nprint s.containsDuplicate([1, 2, 2, 3, 3])\nprint s.containsDuplicate([1, 1, 2, 2, 3, 3, 4, 4])\nprint s.containsDuplicate([1, 2, 2, 3, 3])",
      -2.052734375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        if k < 1:\n            return False\n        if k > len(nums):\n            return False\n\n        # count duplicate\n        duplicate_count = 0\n        for i in range(len(nums)):\n            if i < k:\n                continue\n            if nums[i - k] == nums[i]:\n                duplicate_count += 1\n            else:\n                duplicate_count = 0\n            if duplicate_count > 1:\n                return True\n        return False",
      -3.791015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        # write your code here\n        if len(nums) < 2:\n            return False\n\n        n = len(nums)\n        for i in range(n):\n            if nums[i] == nums[n-1-i]:\n                return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.containsDuplicate([1,1,2,2,3])\n    print s.containsDuplicate([1,1])\n    print s.containsDuplicate([-1,-1,-2,-2,-3])",
      -4.0234375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        # count the number of elements\n        count = len(nums)\n        # iterate the nums\n        for i in range(count):\n            # check if the current element is already in the list\n            if i > 0 and nums[i] == nums[i - 1]:\n                return True\n            # if the current element is not in the list\n            elif i > 0 and nums[i]!= nums[i - 1]:\n                # iterate the next elements\n                for j in range(i + 1, count):\n                    # check if the current element is already in the list\n                    if j > 0 and nums[j] == nums[j - 1]:\n                        return True\n                    # if the current element is not in the list\n                    elif j > 0 and nums[j]!= nums[j - 1]:\n                        break\n        # if the list is not empty\n        return False\n\nif __name__ == '__main__':\n    print Solution().containsDuplicate([1, 1, 1])",
      -4.2109375
    ],
    [
      "# https://www.hackerrank.com/challenges/find-duplicates/problem\n\nimport math\n\n\ndef is_duplicate(arr):\n    # if arr is empty, return false\n    if len(arr) == 0:\n        return False\n\n    # if arr is a single element, return false\n    if len(arr) == 1:\n        return False\n\n    # if arr is only one element, return false\n    if len(arr) == 2:\n        return False\n\n    # calculate the median of the array\n    median = arr[int((len(arr) - 1) / 2)]\n\n    # check all the elements in the array\n    for i in range(0, len(arr) - 1):\n        if arr[i] == median:\n            return True\n\n    return False\n\n\ndef main():\n    # input\n    arr = list(map(int, input().split()))\n\n    # output\n    print(is_duplicate(arr))\n\nif __name__ == '__main__':\n    main()",
      -4.28515625
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # https://discuss.leetcode.com/topic/13658/share-my-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/20897/java-python-solution-with-explanation\n        # https://discuss.le",
      -4.328125
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2:\n            return False\n        # dp[i] stores whether nums[i] has any duplicates with nums[i-k] and nums[i+k]\n        dp = [False] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i-k, i+k+1):\n                if dp[j] and nums[j] == nums[i]:\n                    return True\n                if not dp[j] and j > i:\n                    dp[j] = True\n        return False\n\n# Note:\n# The problem is to find the k closest elements,\n# but not necessarily the closest ones,\n# because we can find them with a binary search.",
      -4.5078125
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # check the kth element\n        if k == 0:\n            return False\n        # if nums[i] == nums[i+k-1], then we will find a duplicate\n        for i in range(k-1):\n            if nums[i] == nums[i+k-1]:\n                return True\n        return False\n\nif __name__ == '__main__':\n    print Solution().containsNearbyDuplicate([1, 2, 2, 3, 3, 3], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2)\n    print Solution().containsNearbyDuplicate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2)",
      -4.68359375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # sort the list\n        nums = sorted(nums)\n        # find the duplicates\n        for i in range(len(nums) - k + 1):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            j = i + 1\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            if j - i > k:\n                return True\n        return False",
      -4.69140625
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # find the kth smallest number\n        min_val = min(nums)\n        nums.sort()\n        for i in range(k, len(nums)):\n            if nums[i] == min_val:\n                return True\n            elif nums[i] < min_val:\n                return False\n        return False",
      -4.8359375
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if k < 2:\n            return False\n\n        nums.sort()\n        # for each number, compare with previous and next number\n        for i in range(len(nums) - k + 1):\n            if i == 0 or nums[i]!= nums[i - 1]:\n                # if the current number is different from the previous one, then skip\n                continue\n\n            j = i + k - 1\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n\n            if j == len(nums) or nums[i]!= nums[j]:\n                return True\n\n        return False\n\n\nif __name__ == \"__main__\":\n    assert Solution().containsNearbyDuplicate([1, 1, 2], 2) == True\n    assert Solution().containsNearbyDuplicate([1, 1, 2], 1) == False\n    assert Solution().containsNearbyDuplicate([1, 1, 1], 1) == False",
      -4.91015625
    ],
    [
      "def contains_duplicate(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    # https://leetcode.com/problems/find-duplicates-in-sorted-array/discuss/185886/Python-DP-Solution-with-O(n)-Time-and-O(1)-Space-\n    # 1. dp\n    # 2. O(n)\n    # 3. O(1)\n    # 4. O(n)\n    # 5. O(n)\n    # 6. O(n)\n    # 7. O(n)\n    # 8. O(1)\n    # 9. O(n)\n    # 10. O(1)\n    # 11. O(1)\n    # 12. O(1)\n    # 13. O(n)\n    # 14. O(n)\n    # 15. O(n)\n    # 16. O(1)\n    # 17. O(n)\n    # 18. O(1)\n    # 19. O(n)\n    # 20. O(n)\n    # 21. O(n)\n    # 22. O(1)\n    # 23. O(n)\n    # 24. O(n)\n    # 25. O(1)\n    # 26. O(n)\n    # 27. O(n)\n    # 28. O(1)\n    # 29. O(n)\n    # 30. O(n)\n    # 31. O(1)\n    # 32. O(n)\n    # 33. O(1)\n    # 34. O(n)\n    # 35. O(1)\n    # 36. O(n)\n    # 37. O(1)\n    # 38. O(n)\n    # 39. O(1)\n    # 40. O(n)\n    # 41. O(1)\n    # 42. O(1)\n    # 43. O(1)\n    # 44. O(1)\n    # 45. O(1)\n    # 46. O(n)\n    # 47. O(",
      -4.9921875
    ],
    [
      "# https://leetcode.com/problems/contains-duplicate/discuss/105414/Java-and-Python-Implementation-using-Python-Set-and-Python-List-\n# https://leetcode.com/problems/contains-duplicate/discuss/113655/Java-and-Python-Implementation-using-Python-Set-and-Python-List\n\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # The idea is to use a hash table to store the hash value of each element.\n        # If a hash table is used, the hash value is stored in a map, and the map is\n        # used to check the duplicate.\n\n        # This is not the most efficient solution, but it is easy to understand.\n\n        # If we only use a list, we can use a hash table to store the hash value,\n        # and use the hash table to check the duplicate.\n\n        # If we use a map, we need to store the hash value in a map, and we can\n        # check the duplicate by the hash value.\n\n        # We can use a set to check the duplicate, but it is a little bit\n        # inefficient.\n\n        # If we use a list, we can use a hash table to store the hash value, and\n        # use the hash table to check the duplicate.\n\n        # If we use a map, we need to store the hash value in a map, and we can\n        # check the duplicate by the hash value.\n\n        # If we use a set, we can use a hash table to store the hash value, and\n        # use the hash table to check the duplicate.\n\n        # If we use a hash table, we can use the hash table to check the duplicate.\n\n        # If we use a map, we need to store the hash value in a map, and we can\n        # check the duplicate by the hash value.\n\n        # If we use a set, we can use a hash table to store the hash value, and\n        # use the hash table to check the duplicate.\n        # In this case, we need to check the hash value of each element, and",
      -5.015625
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def containsNearbyDuplicate(self, intervals: List[Interval], k: int) -> bool:\n        # sort intervals\n        intervals = sorted(intervals, key=lambda x: (x.start, x.end))\n        # add all intervals to a set\n        set_intervals = set()\n        for interval in intervals:\n            set_intervals.add(interval)\n        # remove duplicates\n        intervals = [x for x in intervals if x.start!= x.end and x not in set_intervals]\n        # check if any k-1 intervals are duplicates\n        for i in range(k - 1):\n            if len(intervals) == 0:\n                return False\n            if intervals[0].start == intervals[1].start:\n                intervals = [x for x in intervals if x.end!= intervals[0].end]\n                continue\n            if intervals[0].end == intervals[1].end:\n                intervals = [x for x in intervals if x.start!= intervals[0].start]\n                continue\n            intervals = [x for x in intervals if x.start!= x.end]\n        return len(intervals) == 0",
      -5.2734375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # two pointers, one for a max and one for a min\n        i, j = 0, 0\n        while i < len(nums):\n            if j < i and nums[i] == nums[j]:\n                return True\n            if j < len(nums) and nums[j] < nums[i]:\n                j += 1\n            i += 1\n        return False\n\n\nif __name__ == \"__main__\":\n    print(Solution().containsDuplicate([1, 1, 2]))\n    print(Solution().containsDuplicate([1, 1, 2, 2]))\n    print(Solution().containsDuplicate([1, 2, 3, 3]))\n    print(Solution().containsDuplicate([1, 2, 3, 4, 4, 5]))\n    print(Solution().containsDuplicate([1, 2, 3, 4, 5, 6]))\n    print(Solution().containsDuplicate([1, 1, 1, 1]))\n    print(Solution().containsDuplicate([1, 1, 2, 3, 4, 4, 5, 5, 6]))",
      -5.33984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return False\n        if k == 0:\n            return False\n        if k > n:\n            return False\n        if k == 1:\n            return nums[0] == nums[1]\n        if t == 0:\n            return False\n        if t > k:\n            return False\n        if t == 1:\n            return nums[0] == nums[1]\n        if k == 1:\n            return nums[0] == nums[1]\n        if k == 2:\n            return nums[0] == nums[1]\n        if k == 3:\n            return nums[0] == nums[1]\n        if k == 4:\n            return nums[0] == nums[1]\n        if k == 5:\n            return nums[0] == nums[1]\n        if k == 6:\n            return nums[0] == nums[1]\n        if k == 7:\n            return nums[0] == nums[1]\n        if k == 8:\n            return nums[0] == nums[1]\n        if k == 9:\n            return nums[0] == nums[1]\n        if k == 10:\n            return nums[0] == nums[1]\n        if k == 11:\n            return nums[0] == nums[1]\n        if k == 12:\n            return nums[0] == nums[1]\n        if k == 13:\n            return nums[0] == nums[1]\n        if k == 14:\n            return nums[0] == nums[1]",
      -5.57421875
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n#         self.diff = e-s\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @return {boolean}\n    def hasDuplicate(self, intervals):\n        if len(intervals) == 0:\n            return False\n        elif len(intervals) == 1:\n            return False\n        elif len(intervals) == 2:\n            return intervals[0].diff == 0\n        elif len(intervals) == 3:\n            if intervals[0].end == intervals[1].start:\n                return False\n            if intervals[0].start == intervals[2].end:\n                return False\n            if intervals[0].end == intervals[1].end:\n                return False\n            return True\n        elif len(intervals) > 3:\n            if intervals[0].end == intervals[1].start:\n                return False\n            if intervals[0].start == intervals[2].end:\n                return False\n            if intervals[0].end == intervals[1].end:\n                return False\n            if intervals[0].start == intervals[2].start:\n                return False\n            if intervals[0].start == intervals[1].start:\n                return False\n            if intervals[0].end == intervals[2].end:\n                return False\n            if intervals[0].end == intervals[1].start:\n                return False\n            if intervals[0].end == intervals[2].start:\n                return False\n            if intervals[0].start == intervals[2].end:\n                return False\n            return True\n\ns = Solution()\n\nprint(s.hasDuplicate([1,2,2,3,3,3,4,4,4]))",
      -5.58203125
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # Use HashSet to store the duplicated elements\n        # 1. HashSet.add(x) means that the x has not been inserted\n        # 2. HashSet.contains(x) means that the x has been inserted\n        # 3. HashSet.contains(x) can be used to check if the x has been inserted\n        # 4. HashSet.contains(x) can be used to check if the x has been inserted\n        # 5. HashSet.add(x) can be used to insert x\n        # 6. HashSet.contains(x) can be used to check if x has already been inserted\n        # 7. HashSet.contains(x) can be used to check if x has already been inserted\n        # 8. HashSet.contains(x) can be used to check if x has already been inserted\n        # 9. HashSet.contains(x) can be used to check if x has already been inserted\n        # 10. HashSet.contains(x) can be used to check if x has already been inserted\n        # 11. HashSet.contains(x) can be used to check if x has already been inserted\n        # 12. HashSet.contains(x) can be used to check if x has already been inserted\n        # 13. HashSet.contains(x) can be used to check if x has already been inserted\n        # 14. HashSet.contains(x) can be used to check if x has already been inserted\n        # 15. HashSet.contains(x) can be used to check if x has already been inserted\n        # 16. HashSet.contains(x) can be used to check if x has already been inserted\n        # 17. HashSet.contains(x) can be used to check if x has already been inserted\n        # 18. HashSet.contains(x) can be used to check if x has already been inserted\n        # 19. HashSet.contains(x) can be used to check if x has already been inserted\n        # 20",
      -5.6015625
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < k:\n            return False\n\n        sorted_nums = sorted(nums)\n        if k < 1:\n            return False\n\n        interval_count = 0\n        for i in xrange(1, len(sorted_nums)):\n            if sorted_nums[i] == sorted_nums[i - 1]:\n                interval_count += 1\n                if interval_count >= k:\n                    return True\n\n        return False",
      -5.921875
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/contains-duplicate/#/description\n        # dp[i] = 1 if nums[i] == nums[i-1] and nums[i-1] == nums[i-2] else 0\n        # dp[i] = 1 if nums[i] == nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 0 if nums[i]!= nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 1 if nums[i] == nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 0 if nums[i]!= nums[i-1] and nums[i-1] == nums[i-2] else 0\n        # dp[i] = 1 if nums[i] == nums[i-1] and nums[i-1] == nums[i-2] else 0\n        # dp[i] = 0 if nums[i]!= nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 0 if nums[i]!= nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 0 if nums[i]!= nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 1 if nums[i] == nums[i-1] and nums[i-1]!= nums[i-2] else 0\n        # dp[i] = 0 if nums[i",
      -6.10546875
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        # http://www.cnblogs.com/zuoyuan/p/3793753.html\n        if len(nums) < 2 or k <= 0:\n            return False\n        # [x for x in nums if x < k]\n        # [x for x in nums if x > k]\n        # [x for x in nums if x > k and x < k + 1]\n        # [x for x in nums if x > k + 1 and x < k + 2]\n        # [x for x in nums if x > k and x < k + 1 and x < k + 2]\n        # [x for x in nums if x > k + 1 and x < k + 2 and x < k + 3]\n        # [x for x in nums if x > k + 2 and x < k + 3 and x < k + 4]\n        # [x for x in nums if x > k + 3 and x < k + 4 and x < k + 5]\n        # [x for x in nums if x > k + 4 and x < k + 5 and x < k + 6]\n        # [x for x in nums if x > k + 5 and x < k + 6 and x < k + 7]\n        # [x for x in nums if x > k + 6 and x < k + 7 and x < k + 8]\n        # [x for x in nums if x > k + 7 and x < k + 8 and x < k + 9]\n        # [x for x in nums if x > k + 8 and x < k + 9 and x < k + 10]\n        # [x for x in nums if x > k + 9 and x < k + 10 and x < k + 11]\n        # [x for x in nums if x > k + 10 and x < k + 11 and x < k + 12]\n        # [x for x in nums if x > k + 11 and x < k + 12 and x <",
      -6.37109375
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        n = len(nums)\n        # for i in range(n-k+1, n+1):\n        #     for j in range(i-k+1, i+1):\n        #         if nums[i] == nums[j]:\n        #             return True\n        # return False\n        # k-1\n        # for i in range(n-k+1, n+1):\n        #     for j in range(i-k+1, i+1):\n        #         if nums[i] == nums[j]:\n        #             return True\n        # return False\n        # k+1\n        for i in range(n-k+1, n+1):\n            if nums[i] == nums[i-k]:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().containsNearbyDuplicate([3,3,3,4,4,5,6], 2)\n    print Solution().containsNearbyDuplicate([1,2,3,3,4,5,6,6], 2)\n    print Solution().containsNearbyDuplicate([1,2,3,4,5,6,7,8,9,10], 2)\n    print Solution().containsNearbyDuplicate([], 2)\n    print Solution().containsNearbyDuplicate([1,2,3,3,4,5,6], 3)",
      -6.3984375
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # return False\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j]:\n        #             return True\n        # return False\n        # if len(nums) <= 1:\n        #     return False\n        # for i in range(len(nums)):\n        #     if nums[i] < nums[i-1]:\n        #         return True\n        # return False\n        # for i in range(len(nums)-1):\n        #     if nums[i] == nums[i+1]:\n        #         return True\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return False\n        # return",
      -6.42578125
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def containsNearbyDuplicate(self, intervals: List[Interval], k: int) -> bool:\n        # TLE\n        dp = [False for _ in range(len(intervals))]\n        for i in range(len(intervals)):\n            for j in range(i+1, len(intervals)):\n                if intervals[i].start <= intervals[j].start and intervals[j].end <= intervals[i].end:\n                    dp[i] = True\n                    break\n            if dp[i]:\n                break\n        for i in range(len(intervals)):\n            if dp[i]:\n                for j in range(i+1, len(intervals)):\n                    if intervals[j].start <= intervals[i].start and intervals[j].end <= intervals[i].end:\n                        dp[j] = True\n                        break\n        return any(dp)\n\n\nif __name__ == '__main__':\n    print(Solution().containsNearbyDuplicate([Interval(0, 4), Interval(0, 2), Interval(1, 3), Interval(1, 1), Interval(2, 3)], 3))",
      -7.0703125
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\n# class Solution(object):\n#     def containsNearbyAlmostDuplicate(self, intervals, k, t):\n#         \"\"\"\n#         :type intervals: List[Interval]\n#         :type k: int\n#         :type t: int\n#         :rtype: bool\n#         \"\"\"\n#         # sort intervals\n#         intervals.sort(key=lambda x: x.start)\n#         # store interval start and end to indicate whether they appear in any duplicated interval\n#         duplicated_intervals = []\n#         for i in range(len(intervals)):\n#             # check if the interval start is in duplicated intervals\n#             for j in range(i - k + 1, i + 1):\n#                 # check if the start of the current interval is greater than or equal to the end of the previous interval\n#                 if intervals[j].start >= intervals[i].end:\n#                     # update the duplicated intervals\n#                     duplicated_intervals.append((intervals[j].start, intervals[i].end))\n#                     # update the duplicated intervals\n#                     duplicated_intervals.append((intervals[i].start, intervals[j].end))\n#             # update the duplicated intervals\n#             duplicated_intervals.append(intervals[i].start)\n#             duplicated_intervals.append(intervals[i].end)\n#             # check if the interval end is in duplicated intervals\n#             for j in range(i - k + 1, i + 1):\n#                 # check if the end of the current interval is greater than or equal to the start of the previous interval\n#                 if intervals[j].end >= intervals[i].start:\n#                     # update the duplicated intervals\n#                     duplicated_intervals.append((intervals[j].start, intervals[i].end))\n#                     # update the duplicated intervals\n#                     duplicated_intervals.append((intervals[i].start, intervals[j",
      -7.125
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        l = len(nums)\n        if l < k:\n            return False\n        if l <= k + 1:\n            return True\n        start = 0\n        end = l - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if mid == 0 or mid == l - 1:\n                return False\n            if nums[mid - 1] == nums[mid] and nums[mid] < nums[mid + 1]:\n                return True\n            if nums[mid] == nums[mid - 1]:\n                start = mid + 1\n            else:\n                end = mid\n        return False\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3, 1]\n    k = 2\n    t = 3\n    assert sol.containsNearbyAlmostDuplicate(nums, k, t)",
      -7.60546875
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 2 or k < 1:\n            return False\n        \n        # map of (i, j, val)\n        map = {}\n        \n        # for each num\n        for i, num in enumerate(nums):\n            # if not in map, add it\n            if num not in map:\n                map[(i, i, num)] = Interval(num, num)\n            \n            # for each j, check if map[i] overlaps with map[j]\n            for j, val in map.iteritems():\n                # if val overlaps with map[i], add j to result\n                if Interval(val.start, val.end).overlap(Interval(i, i)):\n                    map[(j, i, num)] = Interval(val.start, val.end)\n        \n        # check if map[i] overlaps with map[j] for any j\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if Interval(map[(i, i, nums[i])].start, map[(i, i, nums[i])].end).overlap(Interval(map[(j, i, nums[j])].start, map[(j, i, nums[j])].end)):\n                    return True\n        \n        return False",
      -9.8828125
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a boolean\n    def containsDuplicate(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n\n        # get all the start intervals\n        # for i in range(len(intervals)):\n        #     if i == 0:\n        #         continue\n        #     if intervals[i].start < intervals[i-1].start:\n        #         return True\n\n        # get all the end intervals\n        # for i in range(len(intervals)):\n        #     if i == len(intervals) - 1:\n        #         continue\n        #     if intervals[i].end < intervals[i+1].end:\n        #         return True\n\n        # get all the intervals that are adjacent\n        # for i in range(len(intervals)):\n        #     if i == 0:\n        #         continue\n        #     if intervals[i].start > intervals[i-1].end:\n        #         return True\n        #     if intervals[i].end < intervals[i+1].start:\n        #         return True\n\n        # get all the intervals that are adjacent\n        # for i in range(len(intervals)):\n        #     if i == len(intervals) - 1:\n        #         continue\n        #     if intervals[i].start > intervals[i+1].end:\n        #         return True\n        #     if intervals[i].end < intervals[i+1].start:\n        #         return True\n        # return False\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().containsDuplicate([Interval(1, 2), Interval(3, 4), Interval(5, 6), Interval(7, 8), Interval(1, 2)])\n    print Solution().containsDuplicate([Interval(1, 2",
      -10.28125
    ],
    [
      "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/discuss/76637/dp-solution-with-detailed-explanation\n        # dp[i] is the number of times that nums[i] appears in nums[:i]\n        dp = [1 for i in range(len(nums))]\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    dp[i] += dp[j]\n        return any(dp)",
      -10.8515625
    ],
    [
      "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return nums[0] == nums[0]\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if len(nums) == 3:\n            if nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]:\n                return True\n            elif nums[0] == nums[1] and nums[0] == nums[2]:\n                return True\n            elif nums[0] == nums[1] and nums[1] == nums[2]:\n                return True\n            else:\n                return False\n        if len(nums) == 4:\n            if nums[0] == nums[1] and nums[0] == nums[2] and nums[0] == nums[3] or nums[1] == nums[2] and nums[1] == nums[3] and nums[1] == nums[2]:\n                return True\n            elif nums[0] == nums[1] and nums[0] == nums[2] and nums[1] == nums[3] or nums[1] == nums[2] and nums[0] == nums[3] and nums[0] == nums[1]:\n                return True\n            elif nums[0] == nums[1] and nums[0] == nums[2] and nums[2] == nums[3] or nums[1] == nums[2] and nums[0] == nums[3] and nums[1] == nums[2]:\n                return True\n            else:\n                return False\n        if len(nums) == 5:\n            if num",
      -11.34375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        # sort the nums\n        nums = sorted(nums)\n\n        # the max distance between the last element and the first element\n        max_dist = (len(nums) - 1) * t\n\n        # the last element of nums\n        last_element = nums[len(nums) - 1]\n\n        # the first element of nums\n        first_element = nums[0]\n\n        # the last element of nums\n        last_element_pos = len(nums) - 1\n\n        # the first element of nums\n        first_element_pos = 0\n\n        # the max distance between the last element and the first element\n        max_dist_pos = (len(nums) - 1) * t\n\n        # check the first element\n        if nums[0] == first_element:\n            return True\n\n        # check the last element\n        if nums[last_element_pos] == last_element:\n            return True\n\n        # check the first element\n        if nums[first_element_pos] == first_element:\n            return True\n\n        # check the last element\n        if nums[last_element_pos] == last_element:\n            return True\n\n        # check the first element\n        if nums[first_element_pos] == first_element:\n            return True\n\n        # check the last element\n        if nums[last_element_pos] == last_element:\n            return True\n\n        # check the first element\n        if nums[first_element_pos] == first_element:\n            return True\n\n        # check the last element\n        if nums[last_element_pos] == last_element:\n            return True\n\n        # check the first element\n        if num",
      -12.2421875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}