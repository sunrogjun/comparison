{
  "problem": {
    "task_id": "MBPP/149",
    "prompt": "Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.",
    "canonical_solution": "def longest_subseq_with_diff_one(arr, n): \r\n\tdp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result",
    "test_list": [
      "assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6",
      "assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3",
      "assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7"
    ],
    "challenge_test_list": [],
    "problem_id": 138
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    def longestPalindrome(self, s: List[str]) -> int:\n        n = len(s)\n        if n < 2:\n            return 0\n\n        max_len = 0\n        max_len_p = 0\n\n        for i in range(n):\n            for j in range(i):\n                if s[i] == s[j] and (i - j) % 2 == 1:\n                    max_len_p = max(max_len_p, max_len)\n                    max_len = max(max_len, j - i + 1)\n\n        return max_len_p\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.longestPalindrome([\"abc\", \"cbbd\", \"d\", \"e\", \"f\"]))",
      2.216796875
    ],
    [
      "class Solution(object):\n    def longestOne(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(len(nums)):\n            for j in xrange(i + 1, len(nums)):\n                if nums[i]!= nums[j]:\n                    break\n                res = max(res, j - i)\n        return res",
      1.6865234375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestSubsequence(self, nums):\n        if len(nums) == 0:\n            return 0\n        \n        nums.sort()\n        \n        max_length = 1\n        length = 1\n        for i in xrange(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                length += 1\n            else:\n                length = 1\n                max_length = max(max_length, length)\n                length = 1\n            \n        return max_length",
      1.1572265625
    ],
    [
      "def find_longest_subsequence(arr):\n    n = len(arr)\n    if n == 1:\n        return 1\n    if n == 2:\n        return max(arr)\n    if arr[0]!= arr[1]:\n        return 1\n    \n    # find the longest subsequence\n    longest_subsequence = 1\n    max_len = 1\n    \n    for i in range(2, n):\n        max_len = max(max_len, longest_subsequence)\n        subsequence_len = 1\n        \n        for j in range(i - 1, 0, -1):\n            if arr[j] == arr[j + 1]:\n                subsequence_len += 1\n                \n            if subsequence_len > longest_subsequence:\n                longest_subsequence = subsequence_len\n        \n        max_len = max(max_len, longest_subsequence)\n    \n    return max_len\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    print find_longest_subsequence(arr)",
      1.12109375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def longestPalindrome(self, num):\n        res = 0\n        for i in xrange(len(num)):\n            for j in xrange(len(num)):\n                if i == j:\n                    continue\n                diff = num[i] - num[j]\n                if diff == 1:\n                    if res < j - i + 1:\n                        res = j - i + 1\n        return res",
      1.08984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestSubsequence(self, nums):\n        if len(nums) == 0: return 0\n        nums.sort()\n        maxLen = 0\n        idx = 0\n        for i in xrange(len(nums)):\n            if idx == 0 and nums[i] == nums[i-1]:\n                continue\n            while i+1 < len(nums) and nums[i] == nums[i+1]:\n                i += 1\n            if i+1 == len(nums):\n                idx = 0\n            else:\n                idx = i+1\n            maxLen = max(maxLen, i-idx+1)\n        return maxLen\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.longestSubsequence([1,1,2,3,3,3,3])",
      0.79541015625
    ],
    [
      "# https://discuss.leetcode.com/topic/19363/java-solution-using-bfs\n\nclass Solution:\n    def longestSubsequence(self, s: List[int], target: int) -> int:\n        if not s:\n            return 0\n        max_len = 1\n        visited = set()\n        for i in range(len(s)):\n            if s[i] == target:\n                visited.add(i)\n            else:\n                if i in visited:\n                    max_len = max(max_len, len(visited))\n                visited.add(i)\n        return max_len",
      0.775390625
    ],
    [
      "def longest_subsequence(arr):\n    length = len(arr)\n    if length == 0:\n        return []\n    if length == 1:\n        return [0]\n    longest = 0\n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[i]!= arr[j]:\n                break\n            else:\n                longest = max(longest, 1 + arr[i])\n    return [i for i in range(length) if i < length-1 and arr[i] == arr[i+1]]",
      0.7158203125
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution:\n    # @param nums: A list of integers\n    # @return: The length of the longest subsequence\n    def longestSubsequence(self, nums):\n        if not nums: return 0\n        n = len(nums)\n        dp = [[0] * (n + 1) for i in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n        for j in range(1, n + 1):\n            for i in range(1, n + 1):\n                if i > 1 and nums[i - 2] == nums[i - 1]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n - 1][n]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestSubsequence([1, 2, 2, 3, 4])",
      0.440185546875
    ],
    [
      "class Solution(object):\n    def findLHS(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        max_len = 1\n        max_idx = 0\n        for i in range(1, len(arr)):\n            if arr[i] == arr[i-1]:\n                max_len += 1\n            else:\n                max_len = max(max_len, 1)\n                max_idx = i\n        return max_len\n\n    def findLHS2(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        max_len = 1\n        max_idx = 0\n        for i in range(1, len(arr)):\n            if arr[i] == arr[i-1]:\n                max_len += 1\n            else:\n                max_len = max(max_len, 1)\n                max_idx = i\n        return max_len",
      0.2529296875
    ],
    [
      "class Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # http://www.cnblogs.com/zuoyuan/p/3788213.html\n        # http://www.cnblogs.com/zuoyuan/p/3788217.html\n        nums.sort()\n        max_len = 0\n        for i in xrange(len(nums)):\n            for j in xrange(i, len(nums)):\n                if nums[i]!= nums[j] and nums[i] - nums[j] == 1:\n                    # print i, j\n                    max_len = max(max_len, j - i + 1)\n        return max_len\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestSubarray([1,2,3])\n    print s.longestSubarray([1,2,3,1])\n    print s.longestSubarray([1,2,3,4,5,6])",
      0.0086212158203125
    ],
    [
      "class Solution(object):\n    def longestOneBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        length = len(nums)\n        # Find the longest subsequence\n        for i in range(length - 1):\n            if nums[i] < nums[i + 1]:\n                return nums[i]\n        return nums[length - 1]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestOneBST([1, 2, 3, 4, 5, 6, 7])\n    print s.longestOneBST([1, 2, 3, 4, 5])\n    print s.longestOneBST([1, 2, 3, 4])\n    print s.longestOneBST([1, 2])\n    print s.longestOneBST([1])\n    print s.longestOneBST([1, 2, 3])",
      -0.460205078125
    ],
    [
      "class Solution(object):\n    def longestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        dp = [1] * len(s)\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[j] == s[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        for i in range(len(s)):\n            if dp[i] > max_len:\n                max_len = dp[i]\n        return max_len\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestSubstring(\"ABAB\")\n    print s.longestSubstring(\"AAAA\")\n    print s.longestSubstring(\"ABABA\")\n    print s.longestSubstring(\"ABAAB\")",
      -0.654296875
    ],
    [
      "from itertools import combinations\nfrom collections import defaultdict\n\nclass Solution(object):\n    def findMaxLengthSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] == 1:\n                    dp[i+1] = max(dp[i+1], dp[j]+1)\n        return dp[-1]\n\nif __name__ == \"__main__\":\n    print Solution().findMaxLengthSubsequence([1,2,3,4,5])",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        l = 0\n        r = len(s) - 1\n        while l < r:\n            l += 1\n            r -= 1\n            while l < r and s[l] == s[r]:\n                l += 1\n                r -= 1\n            if l == r:\n                return l - 1",
      -0.85693359375
    ],
    [
      "def find_longest_subsequence_one(arr):\n\t\"\"\"\n\t:type arr: List[int]\n\t:rtype: int\n\t\"\"\"\n\t# Sort the input array\n\tarr.sort()\n\n\t# Find the length of the longest subsequence\n\tlength = 0\n\tfor i in range(len(arr) - 1):\n\t\tif arr[i + 1] - arr[i] == 1:\n\t\t\tlength = max(length, 1 + find_longest_subsequence_one(arr[i + 1 : len(arr) : 1]))\n\n\t# Return the length of the longest subsequence\n\treturn length\n\nif __name__ == '__main__':\n\tarr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\tprint find_longest_subsequence_one(arr)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in xrange(1, n):\n            for j in xrange(i):\n                if nums[i] - nums[j] == 1:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]\n\n\nif __name__ == \"__main__\":\n    print Solution().longestSubsequence([1, 2, 3, 4, 5])",
      -0.85791015625
    ],
    [
      "def find_max_subseq(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    \n    length = len(arr)\n    max_length = 0\n    \n    for i in range(length):\n        for j in range(i+1, length):\n            if arr[i] == arr[j] + 1:\n                if max_length < j - i + 1:\n                    max_length = j - i + 1\n                \n    return max_length",
      -0.85791015625
    ],
    [
      "def max_subsequence(array):\n    length = len(array)\n    if length < 2:\n        return 0\n    max_length = 0\n    max_start = 0\n    max_end = 0\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            if array[i] == array[j] and abs(i - j) == 1:\n                max_length = max(max_length, j - i + 1)\n                max_start = i\n                max_end = j\n                if max_length > 1:\n                    return max_length, max_start, max_end\n    return 0",
      -0.85791015625
    ],
    [
      "import sys\n\ndef solution(arr):\n    if len(arr) < 2:\n        return 0\n\n    max_len = 1\n    for i in range(1, len(arr)):\n        if arr[i - 1] == arr[i]:\n            max_len += 1\n        else:\n            max_len = max(max_len, i - max_len)\n\n    return max_len\n\nif __name__ == \"__main__\":\n    arr = [1, 1, 2, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9]\n    print solution(arr)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def findLonelyDigit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[j] == nums[i]:\n                    dp[i] += dp[j]\n        return dp[-1]",
      -0.85791015625
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(nums, curr, max_so_far, max_so_far_index):\n            if len(nums) == 1:\n                return max_so_far\n            for i in xrange(len(nums) - 2, -1, -1):\n                if curr[i] == nums[i]:\n                    max_so_far_index = i\n                    max_so_far = max(max_so_far, curr[i])\n                    curr[i] = -1\n                    dfs(nums, curr, max_so_far, max_so_far_index)\n                    curr[i] = nums[i]\n            return max_so_far\n        return dfs(nums, [0] * len(nums), 0, -1)",
      -0.85791015625
    ],
    [
      "class Solution:\n    def longestOneSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 1:\n            return len(nums)\n\n        nums.sort()\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] == nums[r]:\n                r = mid\n            else:\n                l = mid + 1\n\n        return r - l",
      -0.85791015625
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n# \n# class Solution:\n#     def longestSubsequence(self, intervals):\n#         \"\"\"\n#         :type intervals: List[Interval]\n#         :rtype: List[str]\n#         \"\"\"\n#         result = []\n#         for i in xrange(len(intervals)):\n#             if i > 0 and intervals[i].end - intervals[i - 1].start > 0:\n#                 result.append(str(intervals[i - 1].start) + \"->\" + str(intervals[i].end))\n#         return result",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def longestSubseq(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(nums, i):\n            if i == len(nums):\n                return 1\n            left = 0\n            for j in range(i):\n                left += 1\n                if nums[i]!= nums[j]:\n                    left = max(left, dfs(nums, j+1))\n            return left\n\n        return dfs(nums, 0)\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 2, 2, 2, 3, 3, 3]\n    print Solution().longestSubseq(nums)",
      -0.85791015625
    ],
    [
      "import sys\n\nclass Solution(object):\n    def longestSubsequence(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        # dp[i][j] is the length of the longest subsequence of A[0:i] and A[j+1:n]\n        dp = [ [ 0 for _ in xrange(n+1) ] for _ in xrange(n+1) ]\n        for i in xrange(n):\n            for j in xrange(i+1, n+1):\n                if A[i] == A[j]:\n                    dp[i][j] = dp[i+1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return max(dp[0][n-1], dp[n-1][n-1])\n\nif __name__ == '__main__':\n    s = Solution()\n    A = [1,2,3,4]\n    print s.longestSubsequence(A)\n    A = [1,2,3,4,5,6,7,8]\n    print s.longestSubsequence(A)",
      -0.8583984375
    ],
    [
      "def find_longest_subsequence(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    longest_subsequence = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(nums[i] - nums[j])\n            if diff == 1:\n                longest_subsequence = max(longest_subsequence, j - i + 1)\n\n    return longest_subsequence\n\ndef test_find_longest_subsequence():\n    assert find_longest_subsequence([2, 3, 1, 4, 5]) == 4\n    assert find_longest_subsequence([1, 2, 3, 4, 5]) == 5\n    assert find_longest_subsequence([3, 1, 2, 4, 5]) == 5\n    assert find_longest_subsequence([3, 1, 2, 4, 5, 1]) == 6\n    assert find_longest_subsequence([3, 1, 2, 4, 5, 2, 3]) == 6\n\nif __name__ == \"__main__\":\n    test_find_longest_subsequence()",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        d = {}\n        max_length = 0\n        for i in range(len(s)):\n            if s[i] not in d:\n                d[s[i]] = i\n            else:\n                d[s[i]] = max(d[s[i]], i)\n        for i in range(len(s)):\n            if i + 1 < len(s) and s[i]!= s[i + 1]:\n                length = d[s[i + 1]] - d[s[i]]\n                if length > max_length:\n                    max_length = length\n        return max_length\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestSubstring(\"aabcccccaaa\")\n    print s.longestSubstring(\"aabbbcccccbbb\")\n    print s.longestSubstring(\"aaabbbcccbbb\")",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/longest-subsequence-with-one-edit-distance/\n\nclass Solution(object):\n    def longestSubseqWithOneEdit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_len = 0\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            j = i\n            while j < len(nums) - 1 and nums[j + 1] == nums[j]:\n                j += 1\n            max_len = max(max_len, j - i)\n        return max_len\n\n\nif __name__ == \"__main__\":\n    print Solution().longestSubseqWithOneEdit([3, 3, 2, 2, 3])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        max_diff = 0\n        max_idx = 0\n        for i in range(1, n):\n            j = i - 1\n            while j >= 0:\n                if nums[i] - nums[j] == 1:\n                    break\n                j -= 1\n            else:\n                max_diff = max(max_diff, i - max_idx)\n                max_idx = i\n        return max_diff + 1",
      -0.8583984375
    ],
    [
      "def get_max_subsequence(arr):\n    # base case\n    if len(arr) <= 1:\n        return len(arr)\n\n    # recursive case\n    max_len = 1\n    for i in range(len(arr)):\n        if arr[i] == arr[i + 1]:\n            continue\n        else:\n            max_len = max(max_len, get_max_subsequence(arr[i + 1:]) + 1)\n\n    return max_len\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(get_max_subsequence(arr))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0] * n for _ in xrange(n)]\n        for i in xrange(n):\n            dp[i][i] = 1\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[i+1][j-1] + 1\n        return dp[0][n-1]",
      -0.8583984375
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n     def __init__(self, x):\n         self.val = x\n         self.left = None\n         self.right = None\n\nclass Solution:\n    def longestOneSubsequence(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        \n        max_len = 1\n        \n        queue = [root]\n        while queue:\n            curr = queue.pop(0)\n            if curr.left is None and curr.right is None:\n                max_len = max(max_len, len(str(curr.val)))\n            else:\n                queue.append(curr.left)\n                queue.append(curr.right)\n        return max_len",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of integers\n    def findLonelyInterval(self, intervals):\n        interval_map = {}\n        for i in intervals:\n            if i.start not in interval_map:\n                interval_map[i.start] = [i.end]\n            else:\n                interval_map[i.start].append(i.end)\n        \n        interval_list = []\n        for start, end in interval_map.items():\n            if len(end) == 1:\n                interval_list.append(end[0] - start)\n        return interval_list",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findLongestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        max_len = 0\n        max_len_idx = 0\n        for i in xrange(n):\n            for j in xrange(i + 1, n):\n                if nums[i] + nums[j] == nums[i + 1] + nums[j + 1]:\n                    max_len = max(max_len, j - i + 1)\n                    max_len_idx = max(max_len_idx, i)\n                    break\n        return max_len",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # https://discuss.leetcode.com/topic/15862/java-o-n-dp-solution\n        n = len(nums)\n        dp = [[0] * n for i in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        return max(dp[-1])",
      -0.8583984375
    ],
    [
      "def longest_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    dp = [0 for _ in range(n)]\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n):\n        for j in range(i):\n            if arr[j] - arr[i] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[-1]\n\n\nif __name__ == '__main__':\n    arr = [3, 4, 1, 2, 5, 7, 0, 0, 1]\n    print(longest_subsequence(arr))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.longestSubsequence(nums, 0, len(nums) - 1)\n\n    def longestSubsequence(self, nums, start, end):\n        if start == end:\n            return 1\n        if start + 1 == end:\n            return 1 + max(self.longestSubsequence(nums, start, end - 1), self.longestSubsequence(nums, start, end + 1))\n        max_len = 0\n        for i in range(start, end + 1):\n            if nums[i] - nums[start] == nums[end] - nums[i]:\n                max_len = max(max_len, self.longestSubsequence(nums, start, i - 1) + self.longestSubsequence(nums, i + 1, end))\n        return max_len",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/longest-increasing-subsequence-ii/discuss/113770/Python-Implementation-with-Explanation-and-Notes\n\nclass Solution(object):\n    def longestIncreasingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        max_dp = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[j] + 1, dp[i])\n            max_dp = max(max_dp, dp[i])\n        return max_dp\n\n\nif __name__ == \"__main__\":\n    nums = [3, 1, 2, 2, 3]\n    print(Solution().longestIncreasingSubsequence(nums))",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param num, a list of integers\n    # @return a list of integers\n    def longestPalindrome(self, num):\n        # write your code here\n        res = []\n        length = len(num)\n        if length == 0:\n            return res\n        \n        for i in xrange(length):\n            if num[i] == num[length-1-i]:\n                res.append(num[i])\n            else:\n                break\n            \n        for i in xrange(length-2, -1, -1):\n            if num[i] == num[length-1-i]:\n                res.append(num[i])\n            else:\n                break\n        return res\n\nif __name__ == '__main__':\n    print Solution().longestPalindrome([3,2,1,4,5,6])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] - nums[j] == 1:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n# Note:\n# https://leetcode.com/problems/longest-subsequence-of-one-differences/discuss/106488/Python-solution-using-memoization-with-recursion",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def longestSubseq(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if nums[i] == nums[j] + 1:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 2, 3, 4]\n    print(s.longestSubseq(nums))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n        n = len(arr)\n        if n == 1:\n            return 1\n        m = len(arr[0])\n        max_len = 0\n        for i in xrange(1, n):\n            for j in xrange(m):\n                if arr[i][j] == arr[i-1][j]:\n                    continue\n                else:\n                    break\n            max_len = max(max_len, i - j + 1)\n        return max_len",
      -0.85888671875
    ],
    [
      "def longest_subsequence_one(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_length = 0\n    for i in range(len(arr)):\n        j = i\n        while j < len(arr) and arr[j] == arr[j - 1]:\n            j += 1\n        max_length = max(max_length, j - i)\n    return max_length\n\n# Your code here",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        for i in range(len(nums)):\n            if i > 0 and nums[i] - nums[i-1] == 1:\n                max_len = max(max_len, len(str(nums[i-1])) + len(str(nums[i])))\n        return max_len",
      -0.85888671875
    ],
    [
      "import sys\n\ndef main():\n    s = sys.stdin.readline()\n    for line in s.splitlines():\n        n = int(line)\n        print(longest_subsequence_with_one_difference(n))\n\ndef longest_subsequence_with_one_difference(n):\n    max_len = 0\n    max_subseq = []\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(i - j)\n            if diff == 1:\n                max_subseq.append(i)\n                max_subseq.append(j)\n                max_len = max(max_len, len(max_subseq))\n    return max_len\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def longestSubsequence(self, num):\n        if len(num) == 0:\n            return 0\n        max_length = 0\n        i = 0\n        while i < len(num) - 1:\n            j = i + 1\n            while j < len(num) - 1:\n                if num[i] + num[j]!= num[j + 1]:\n                    max_length = max(max_length, j - i)\n                    i = j\n                j += 1\n            i = j\n        return max_length\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestSubsequence([1, 2, 3]))",
      -0.85888671875
    ],
    [
      "def longest_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 1:\n        return 1\n    max_len = 0\n    for i in range(len(arr)-1):\n        if arr[i]!= arr[i+1]:\n            for j in range(i+1, len(arr)-1):\n                if arr[i] == arr[j]:\n                    max_len = max(max_len, j-i+1)\n    return max_len",
      -0.85888671875
    ],
    [
      "def longest_subsequence(arr):\n    if len(arr) < 2:\n        return len(arr)\n\n    max_length = 0\n    max_length_index = 0\n    max_length_length = 0\n\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                length = i - j\n                if length > max_length:\n                    max_length = length\n                    max_length_index = i\n                    max_length_length = j - i\n\n    return max_length\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 2, 3, 4, 4, 5, 6, 6]\n    print(longest_subsequence(arr))",
      -0.85888671875
    ],
    [
      "from collections import Counter\nfrom typing import List\n\n\nclass Solution:\n    def longestSubsequence(self, nums: List[int]) -> int:\n        # Count the number of elements\n        num_elements = Counter(nums)\n        # Initialize the max_count\n        max_count = 0\n        # Initialize the max_count\n        max_count_index = 0\n        # Find the maximum count\n        for index, count in num_elements.items():\n            if max_count < count:\n                max_count = count\n                max_count_index = index\n        # Find the max_count\n        max_count_length = 0\n        for index, count in num_elements.items():\n            if index == max_count_index:\n                max_count_length = max(max_count_length, count)\n            else:\n                max_count_length = max(max_count_length, count)\n        # Return the max_count_length\n        return max_count_length\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestSubsequence([1, 1, 1, 2, 2, 3, 3]) == 3",
      -0.9052734375
    ],
    [
      "from __future__ import annotations\n\n\nclass Solution:\n    def longestSubsequence(self, A: List[int]) -> int:\n        if not A:\n            return 0\n\n        def longest_subsequence(A, prev):\n            if not A:\n                return 0\n\n            n = len(A)\n            ans = 1\n\n            for i in range(1, n):\n                if A[i]!= A[i - 1]:\n                    ans = max(ans, prev + 1)\n                    prev = prev + 1\n                else:\n                    prev = longest_subsequence(A[i + 1:], prev)\n\n            return ans\n\n        return longest_subsequence(A, 0)",
      -0.9189453125
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nfrom collections import deque\n\n\nclass Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        queue = deque()\n        queue.append(nums[0])\n        ans = 1\n        for i in range(1, len(nums)):\n            if queue[-1] == nums[i] - 1:\n                queue.append(nums[i])\n                ans = max(ans, len(queue))\n            elif queue[-1] == nums[i] + 1:\n                queue.append(nums[i])\n            else:\n                queue.popleft()\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestConsecutive(nums=[2, 3, 1, 4, 5, 2, 3, 1, 6, 2]) == 6",
      -1.021484375
    ],
    [
      "import math\n\n# https://leetcode.com/problems/longest-subsequence-of-one-differences/discuss/109867/Python-Solution\n# https://leetcode.com/problems/longest-subsequence-of-one-differences/discuss/114400/Python-Solution-Java-dp-solution\n# https://leetcode.com/problems/longest-subsequence-of-one-differences/discuss/114400/Python-Solution-Java-dp-solution\n# https://leetcode.com/problems/longest-subsequence-of-one-differences/discuss/114400/Java-DP-solution-1-solution\n\nclass Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i == j:\n                return 1\n            if i > j:\n                return 0\n            mid = (i + j) / 2\n            res = 0\n            for k in xrange(i, mid + 1):\n                res = max(res, dfs(k, mid) + 1)\n            return res\n\n        if not nums:\n            return 0\n        res = 0\n        for i in xrange(len(nums)):\n            res = max(res, dfs(i, len(nums) - 1))\n        return res\n\n\nif __name__ == '__main__':\n    print(Solution().longestSubsequence([1, 2, 3, 4, 5]))",
      -1.435546875
    ],
    [
      "def longest_subsequence(arr):\n    longest = [0] * len(arr)\n    if len(arr) == 1:\n        return arr\n    for i in range(len(arr) - 2):\n        if arr[i + 1] - arr[i] == 1:\n            for j in range(i + 1, len(arr)):\n                if arr[j] - arr[i] == 1:\n                    if arr[j] > arr[j + 1]:\n                        longest[j] = max(longest[j], arr[j] - arr[i])\n                    else:\n                        longest[j] = max(longest[j], arr[j + 1] - arr[i])\n    return longest\n\ndef test():\n    assert longest_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert longest_subsequence([2, 2, 3, 4, 5]) == [2, 3, 4, 5]\n    assert longest_subsequence([3, 2, 2, 3, 4, 5]) == [3, 2, 3, 4, 5]\n    assert longest_subsequence([3, 4, 5, 4, 3]) == [3, 4, 5, 4, 3]\n\nif __name__ == \"__main__\":\n    test()",
      -1.9599609375
    ],
    [
      "from collections import defaultdict\nfrom functools import lru_cache\n\nclass Solution:\n    def longestSubsequence(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        if n == 2:\n            return max(abs(nums[0] - nums[1]), abs(nums[1] - nums[0]))\n        max_len = 1\n        max_len_subseq = 0\n        max_len_subseq_i = 0\n        max_len_subseq_j = 0\n        max_len_subseq_k = 0\n        for i in range(n - 2):\n            if nums[i] == nums[i + 1]:\n                if nums[i + 2] == nums[i + 3]:\n                    max_len_subseq_i += 1\n                else:\n                    max_len_subseq_i += 1\n                    max_len_subseq_j += 1\n            else:\n                max_len_subseq_i = 0\n                max_len_subseq_j = 0\n            if max_len_subseq_i > max_len_subseq:\n                max_len_subseq = max_len_subseq_i\n                max_len_subseq_k = max_len_subseq_j\n                max_len_subseq_i = 0\n                max_len_subseq_j = 0\n        return max(max_len_subseq_k, max_len)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestSubsequence([1, 2, 3, 4]))",
      -2.517578125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        result = 0\n        self.helper(root, result)\n        return result\n\n    def helper(self, root, result):\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        if root.left and root.right:\n            return max(self.helper(root.left, result), self.helper(root.right, result)) + 1\n        if root.left:\n            return max(self.helper(root.left, result), self.helper(root, result)) + 1\n        return max(self.helper(root.right, result), self.helper(root, result)) + 1\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print(Solution().longestConsecutive(root))\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.left = TreeNode(10)\n    root.left.right.right = TreeNode(11)\n    root.right.left.left = TreeNode(12)\n    root.right.left.right = TreeNode(13)",
      -2.681640625
    ],
    [
      "class Solution(object):\n    def longestSubsequence1(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        maxLen = 0\n        currLen = 1\n        res = []\n        for i in range(len(arr)):\n            if arr[i] == arr[i+1]:\n                currLen += 1\n            else:\n                if currLen > maxLen:\n                    maxLen = currLen\n                    res = [arr[i-1]]\n                currLen = 1\n        if currLen > maxLen:\n            maxLen = currLen\n            res = [arr[i-1]]\n        return maxLen\n\n    def longestSubsequence2(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        maxLen = 0\n        currLen = 1\n        res = []\n        for i in range(len(arr)):\n            if arr[i] == arr[i+1]:\n                currLen += 1\n            else:\n                if currLen > maxLen:\n                    maxLen = currLen\n                    res = [arr[i-1]]\n                currLen = 1\n        if currLen > maxLen:\n            maxLen = currLen\n            res = [arr[i-1]]\n        return maxLen\n\n    def longestSubsequence3(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        maxLen = 0\n        currLen = 1\n        res = []\n        for i in range(len(arr)):\n            if arr[i] == arr[i+1]:\n                currLen += 1\n            else:\n                if currLen > maxLen:\n                    maxLen = currLen\n                    res = [arr[i-1]]\n                currLen = 1\n        if currLen > maxLen:\n            maxLen = currLen\n            res = [arr[i-1]]\n        return maxLen\n\n    def longestSubsequence4(self, arr):\n        \"\"\"\n        :type arr: List[int]",
      -2.76953125
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        max_len = 1\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[j] - nums[i] == 1:\n                    if max_len < j + 1:\n                        max_len = j + 1\n        return max_len\n\n\nif __name__ == \"__main__\":\n    print Solution().longestSubsequence([1, 2, 3, 4])\n    print Solution().longestSubsequence([1, 2, 2, 3, 4, 4])\n    print Solution().longestSubsequence([1, 2, 3, 3, 4, 4])\n    print Solution().longestSubsequence([1, 2, 2, 2, 3, 4, 4])",
      -2.9765625
    ],
    [
      "# Approach 1: Brute Force\ndef findLongestSubsequence(nums):\n    length = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                length = max(length, j - i + 1)\n    return length\n\n# Approach 2: Find and Save Max Difference\ndef findLongestSubsequence2(nums):\n    max_diff = 0\n    length = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                length = max(length, j - i + 1)\n                if length > max_diff:\n                    max_diff = length\n    return max_diff\n\n# Approach 3: Recursive\ndef findLongestSubsequence3(nums):\n    length = 0\n    max_diff = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                length = max(length, j - i + 1)\n                if length > max_diff:\n                    max_diff = length\n    return max_diff\n\n# Approach 4: DP\ndef findLongestSubsequence4(nums):\n    length = 0\n    max_diff = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                length = max(length, j - i + 1)\n                if length > max_diff:\n                    max_diff = length\n    return max_diff\n\n# Approach 5: DP\ndef findLongestSubsequence5(nums):\n    length = 0\n    max_diff = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                length = max(length, j - i + 1",
      -3.28515625
    ],
    [
      "# https://www.hackerrank.com/challenges/longest-substring-with-one-character-difference/problem\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestSubstring(self, nums):\n        if not nums:\n            return 0\n\n        n = len(nums)\n        max_len = 0\n        max_diff = 0\n        max_pos = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i]!= nums[j]:\n                    diff = nums[i] - nums[j]\n                    if diff == 1:\n                        if max_len < j - i + 1:\n                            max_len = j - i + 1\n                            max_pos = i\n                            max_diff = diff\n                    elif diff == -1:\n                        if max_len < j - i:\n                            max_len = j - i\n                            max_pos = i\n                            max_diff = diff\n        return max_len\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
      -3.453125
    ],
    [
      "import math\n\ndef get_max_sum_subseq(arr):\n    result = 0\n    max_sum_subseq = [0] * len(arr)\n    max_sum_subseq[0] = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == 1:\n            max_sum_subseq[i] = max(max_sum_subseq[i - 1], arr[i] + max_sum_subseq[i - 1])\n        else:\n            max_sum_subseq[i] = max(max_sum_subseq[i - 1], arr[i] + max_sum_subseq[i - 1])\n            result = max(result, max_sum_subseq[i])\n\n    return result\n\ndef main():\n    arr = [1, 2, 3, 4, 5]\n    print(get_max_sum_subseq(arr))\n\nif __name__ == '__main__':\n    main()",
      -3.86328125
    ],
    [
      "#!/usr/bin/env python\n\nfrom collections import Counter\n\ndef longest_subsequence(arr):\n    \"\"\"\n    Find the longest subsequence such that the difference between adjacent elements is 1\n    :param arr: an array of integers\n    :return: a tuple of the longest subsequence and its length\n    \"\"\"\n    \n    if len(arr) == 1:\n        return arr, 1\n    \n    # find the smallest length of subsequences such that all the elements are adjacent\n    s, l = 0, 0\n    for i in range(len(arr) - 1):\n        if arr[i] + arr[i + 1] == arr[i + 2]:\n            l += 1\n            s = max(s, l)\n    \n    # find the largest subsequence\n    s, l = 0, 0\n    for i in range(len(arr) - 1):\n        if arr[i] - arr[i + 1] == arr[i + 2]:\n            l += 1\n            s = max(s, l)\n    \n    return arr[:s + 1], s + 1\n\ndef main():\n    arr = [1, 2, 3, 1, 2, 3, 4]\n    print(longest_subsequence(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(longest_subsequence(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(longest_subsequence(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(longest_subsequence(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(longest_subsequence(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(longest_subsequence(arr))\n\nif __name__ == '__main__':\n    main()",
      -4.078125
    ],
    [
      "def longest_subsequence_one(arr):\n    if not arr:\n        return 0\n\n    n = len(arr)\n    dp = [1] * n\n    dp[0] = 1\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] - arr[i] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[n - 1]\n\n\n\n# Test Cases\n\ntest_case_1 = [1, 1, 1]\ntest_case_2 = [1, 2, 3]\ntest_case_3 = [1, 2, 3, 4]\ntest_case_4 = [1, 2, 3, 4, 5]\ntest_case_5 = [1, 2, 3, 4, 5, 6]\ntest_case_6 = [1, 2, 3, 4, 5, 6, 7]\n\nprint(\"Length 1: \" + str(longest_subsequence_one(test_case_1)))\nprint(\"Length 2: \" + str(longest_subsequence_one(test_case_2)))\nprint(\"Length 3: \" + str(longest_subsequence_one(test_case_3)))\nprint(\"Length 4: \" + str(longest_subsequence_one(test_case_4)))\nprint(\"Length 5: \" + str(longest_subsequence_one(test_case_5)))\nprint(\"Length 6: \" + str(longest_subsequence_one(test_case_6)))",
      -4.12890625
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(nums, i, j):\n            if i == j:\n                return 1\n            if i + 1 == j:\n                return 2\n            if nums[i]!= nums[j]:\n                return 1\n            return max(dfs(nums, i + 1, j - 1), dfs(nums, i + 1, j))\n\n        return dfs(nums, 0, len(nums) - 1)",
      -4.23046875
    ],
    [
      "import collections\n\ndef find_max_subseq(arr):\n    if not arr:\n        return 1\n    arr_length = len(arr)\n    max_length = 1\n    subseq = collections.deque()\n    for i in range(arr_length):\n        if arr[i] == 1:\n            if len(subseq) == 0:\n                max_length = 1\n            else:\n                max_length = max(max_length, len(subseq))\n            subseq.append(i)\n        else:\n            if len(subseq) > 0:\n                max_length = max(max_length, len(subseq))\n            subseq.popleft()\n    return max_length\n\ndef find_max_subseq_recur(arr):\n    if not arr:\n        return 1\n    arr_length = len(arr)\n    max_length = 1\n    subseq = []\n    for i in range(arr_length):\n        if arr[i] == 1:\n            if len(subseq) == 0:\n                max_length = 1\n            else:\n                max_length = max(max_length, len(subseq))\n            subseq.append(i)\n        else:\n            if len(subseq) > 0:\n                max_length = max(max_length, len(subseq))\n            subseq = subseq[1:] + [i]\n    return max_length\n\nprint find_max_subseq( [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",
      -4.4375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findLonely(self, A):\n        \"\"\"\n        :param A: a list of integers\n        :return: a list of length n\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return []\n\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]  # dp[i][j] means dp[i-1][j-1]\n\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                if A[i] == A[j]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n        return [list(x) for x in dp]\n\n\nif __name__ == \"__main__\":\n    so = Solution()\n    print so.findLonely([1, 2, 3, 4, 5])\n    print so.findLonely([1, 1, 1, 1, 1, 1])\n    print so.findLonely([1, 2, 3])\n    print so.findLonely([1, 2, 3, 3, 3])\n    print so.findLonely([1, 2, 3, 3, 3, 3])",
      -4.44921875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestSubsequence(self, nums):\n        if not nums:\n            return 0\n\n        n = len(nums)\n        max_length = 0\n        max_length_array = [0] * n\n        max_length_array[0] = 0\n\n        for i in range(1, n):\n            max_length_array[i] = max(max_length_array[i - 1], 1 + max(nums[i - 1] - nums[i - 2], nums[i] - nums[i - 1]))\n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] == 1:\n                    max_length_array[i] = max(max_length_array[i], max_length_array[j] + 1)\n\n        return max_length_array[-1]\n\n\nif __name__ == \"__main__\":\n    print Solution().longestSubsequence([1, 2, 3, 4, 5])",
      -4.5859375
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # max_length = 1\n        # max_length_sub = 1\n        # max_length_sub_len = 1\n        # max_length_sub_len_sub = 1\n        # max_length_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub = 1\n        # max_length_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len = 1\n        # max_length_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_len_sub_",
      -4.640625
    ],
    [
      "__author__ = 'Danyang'\n# https://leetcode-cn.com/problems/longest-subsequence-of-one-in-a-matrix/\n# https://www.youtube.com/watch?v=r4j9D1nHxZ4\nclass Solution:\n    def longestOneSubsequence(self, nums):\n        \"\"\"\n        dp\n        :param nums: list of integers\n        :return: the length of longest subsequence\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0 for j in range(n)] for i in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] == 1:\n                    dp[i][j] = dp[j][i] + 1\n                else:\n                    dp[i][j] = max(dp[j][i], dp[j][j])\n\n        max_len = 0\n        for i in range(n):\n            max_len = max(max_len, dp[i][i])\n        return max_len",
      -5.15234375
    ],
    [
      "# https://oj.leetcode.com/problems/maximum-subarray-sum/\n# A maximum subsequence is a subsequence of the array which has the highest sum.\n# Given a sorted array of integers, find the length of the longest subsequence which has the same sum as the given array.\n# \n# Example 1:\n# Input: [2,3,1,2]\n# Output: 2\n# Explanation: The longest subsequence is [1,2] with sum = 2.\n# Example 2:\n# Input: [1,2,3,4,5]\n# Output: 3\n# Explanation: The longest subsequence is [1,2,3] with sum = 3.\n# Example 3:\n# Input: [2,2,2,2,2]\n# Output: 3\n# Explanation: The longest subsequence is [2,2] with sum = 2.\n# Example 4:\n# Input: [2,3,2,3,2]\n# Output: 1\n# Explanation: The longest subsequence is [2,3] with sum = 3.\n# \n# Note:\n# The length of the array won't exceed 1000.\n# The sum of all elements in the array won't exceed 1000.\n# \n\nclass Solution(object):\n    def findLongestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # \u4ece\u540e\u5f80\u524d\u627e\u8ddd\u79bb1\u7684\u8ddd\u79bb\n        dp = [0 for i in range(len(nums))]\n        # \u5b58\u50a8\u6bcf\u4e2a\u5143\u7d20\u5bf9\u5e94\u7684\u6700\u5927\u8ddd\u79bb\n        max_dp = 0\n        for i in range(len(nums) - 1):\n            # \u5982\u679c\u662f\u540c\u4e00\u4e2a\u6570\uff0c\u76f4\u63a5\u653e\u5165dp\n            if nums[i] == nums[i + 1]:\n                dp[i + 1] = dp[i] + 1\n            # \u8ba1\u7b97\u6700\u5927dp\n            else:",
      -5.25
    ],
    [
      "def longestSubseq(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] - nums[j] == 1:\n                dp[i][j + 1] = dp[i - 1][j] + 1\n            else:\n                dp[i][j + 1] = max(dp[i - 1][j], dp[i][j])\n    \n    return dp[-1][-1]\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4]\n    print(longestSubseq(nums))",
      -5.28515625
    ],
    [
      "import sys\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestPalindromeSubseq(self, nums):\n        if len(nums) <= 1:\n            return 0\n        l = 0\n        r = len(nums) - 1\n        while l < r:\n            m = l + (r - l) // 2\n            if nums[m] == nums[l] + nums[m + 1]:\n                l = m + 1\n            elif nums[m] == nums[r] - nums[m]:\n                r = m\n            else:\n                return m - l + 2\n        return l\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.longestPalindromeSubseq([1, 2, 3]))\n    print(sol.longestPalindromeSubseq([1, 2, 2, 3, 4, 3, 2, 1]))",
      -5.5234375
    ],
    [
      "class Solution(object):\n    def longestOneSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        max_len = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j], dp[i][j - 1])\n                if dp[i][j] > max_len:\n                    max_len = dp[i][j]\n\n        return max_len\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestOneSubsequence([1, 3, 4, 2, 5]))",
      -5.73046875
    ],
    [
      "import time\n\nclass Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in xrange(n)]\n        for i in xrange(1, n):\n            for j in xrange(i):\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + 1\n        return dp[n-1][n-1]\n        \n\nif __name__ == \"__main__\":\n    start_time = time.time()\n    print Solution().longestSubsequence([1, 2, 2, 3, 1, 1, 4, 3, 3, 4, 2, 2])\n    print \"elapsed time: %s\" % (time.time() - start_time)",
      -5.9375
    ],
    [
      "def longest_subsequence(arr):\n    # Write your code here\n    if not arr:\n        return []\n\n    sub_lengths = [1]\n    max_length = 1\n    for i in range(1, len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j] and (sub_lengths[i] == 0 or sub_lengths[i] < sub_lengths[j] + 1):\n                sub_lengths[i] = sub_lengths[j] + 1\n                if sub_lengths[i] > max_length:\n                    max_length = sub_lengths[i]\n    return max_length\n\n\n# arr = [1, 1, 1, 2, 2, 2]\n# print(longest_subsequence(arr))\n# arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n# print(longest_subsequence(arr))\n# arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n# print(longest_subsequence(arr))\narr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
      -6.31640625
    ],
    [
      "import timeit\nimport sys\n\n# Time limit exceeded\nsys.stdout = open('./a.out', 'w')\nstart_time = timeit.default_timer()\n\n# @include\ndef longest_subsequence(a):\n    # The length of longest subsequence is the number of subsequences that\n    # are subsequences of the longest subsequence.\n    max_subseq_len = 0\n    max_subseq = []\n\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if a[i] == a[j]:\n                # If the current subsequence is a subsequence of the longest\n                # subsequence, update the maximum length of the longest\n                # subsequence.\n                if max_subseq_len < len(max_subseq):\n                    max_subseq_len = len(max_subseq)\n                    max_subseq = [a[i]]\n                # Otherwise, if the current subsequence is not a subsequence of\n                # the longest subsequence, append the current subsequence to\n                # the longest subsequence.\n                else:\n                    max_subseq.append(a[i])\n                # If the current subsequence is not a subsequence of the\n                # longest subsequence, append the current subsequence to the\n                # longest subsequence.\n                if max_subseq_len < len(max_subseq):\n                    max_subseq_len = len(max_subseq)\n                    max_subseq = [a[i]]\n    return max_subseq_len\n# @exclude\n\n\ndef main():\n    a = [1, 2, 3, 1]\n    # The expected output is 3.\n    # The longest subsequence of the given array is [1, 2, 3].\n    # The length of the longest subsequence is 3.\n    print(longest_subsequence(a))\n\n    a = [1, 2, 3, 2]\n    # The expected output is 2.\n    # The longest subsequence of the given array is [1, 2, 3].\n    # The length of the longest subsequence is 3.\n    print(longest_subsequence(a))\n\n    a =",
      -6.6953125
    ],
    [
      "class Solution(object):\n    def findSubsequences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        n = len(nums)\n        dp = [ [0] * n for _ in xrange(n)]\n        dp[0][0] = 1\n        for i in xrange(1, n):\n            for j in xrange(i):\n                if nums[j] == nums[i]:\n                    dp[i][j] = dp[j][i] + 1\n        ret = []\n        for i in xrange(n):\n            max_count = 0\n            for j in xrange(n):\n                if dp[i][j] > max_count:\n                    max_count = dp[i][j]\n                    ret.append(str(nums[i] - nums[j]))\n        return ret",
      -6.703125
    ],
    [
      "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Apr  8 15:21:35 2016\n\n@author: chengxin\n\"\"\"\n\nclass Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        dp = [[1] * (n - 1) for _ in range(n)]\n        max_len = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = 1 + max(dp[i - 1][j], dp[i][j - 1])\n                max_len = max(max_len, dp[i][j])\n        return max_len\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.longestSubsequence([3, 1, 4, 2, 1, 3])\n    print s.longestSubsequence([1, 2, 3, 4])\n    print s.longestSubsequence([1, 2, 3])\n    print s.longestSubsequence([1, 2, 3, 4, 5, 6, 7, 8])\n    print s.longestSubsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,",
      -6.7734375
    ],
    [
      "import sys\nsys.path.append('..')\nimport numpy as np\n\nfrom linalg.matrix import Matrix\nfrom linalg.vector import Vector\nfrom linalg.util import norm\n\n\ndef longest_subsequence(array):\n    \"\"\"\n    :param array:\n    :return:\n    \"\"\"\n    # TODO: use this function\n    n = len(array)\n    m = len(array[0])\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == 1:\n        return 1\n\n    # use this function\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference/\n    # http://www.cs.ubc.ca/~murphyk/courses/cs341/lec06/subseq.py\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference-using-dp/\n    # https://www.geeksforgeeks.org/longest-subsequence-using-dp-with-one-difference/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/find-longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/find-longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference-using-dp/\n    # https://www.geeksforgeeks.org/find-longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference-using-dp/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-difference/\n    # https://www.geeksforgeeks.org/longest-subsequence-with-one-",
      -6.7734375
    ],
    [
      "# https://oj.leetcode.com/problems/longest-increasing-subsequence/\n# Given an unsorted array of integers, find the length of the longest increasing subsequence.\n# Example 1:\n# Input: [10, 9, 2, 5, 3, 7, 101, 18]\n# Output: 4\n# Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n# Example 2:\n# Input: [10, 9, 2, 5, 3, 7, 101, 18]\n# Output: 1\n# Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 1.\n# Note:\n# The length of the array will not exceed 10,000.\n# The integers in the array will not exceed 1,000,000.\n# You can assume that there are no duplicate elements in the array.\n# Follow up:\n# Could you solve it using only one pass?\n# Related Topics\n# Dynamic Programming\n# Similar Questions\n# Longest Increasing Subsequence\n#\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def longestIncreasingSubsequence(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n        length = 1\n        previous = nums[0]\n        for i in xrange(1, len(nums)):\n            if nums[i] > previous:\n                length += 1\n            else:\n                length = max(length, i - previous)\n            previous = nums[i]\n        return length\n\ns = Solution()\nprint s.longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18])\nprint s.longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18, 3])",
      -7.109375
    ],
    [
      "#\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def longestSubseq(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        max_length = 0\n        for i in range(len(nums)):\n            pre = nums[i - 1] if i > 0 else None\n            cur = nums[i]\n            next = nums[i + 1] if i < len(nums) - 1 else None\n\n            if pre is not None and cur == pre + 1:\n                max_length = max(max_length, i + 1)\n            elif cur == pre + 2:\n                max_length = max(max_length, i + 2)\n\n        return max_length\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.longestSubseq([1, 2, 1, 3, 4, 2, 3, 4, 3])",
      -7.35546875
    ],
    [
      "class Solution(object):\n    def findLRS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n <= 2:\n            return [1] if n == 1 else [1, n]\n        dp = [1] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] + 1, dp[i - 2] + 1)\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1] + 1, dp[i - 2] + 1, dp[i - 3] + 1)\n        for i in range(n - 3, -1, -1):\n            dp[i] = max(dp[i + 1] + 1, dp[i + 2] + 1, dp[i + 3] + 1)\n        return [dp[-1]] if dp[-1] == 1 else dp[-1:]",
      -7.84375
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def longestSubsequence(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: (x.end, x.start))\n        max_len = 0\n        cur_len = 0\n        for i in xrange(1, len(intervals)):\n            if cur_len == 0:\n                cur_len = 1\n            else:\n                cur_len += 1\n            if intervals[i].end - intervals[i-1].end > 1:\n                cur_len = 0\n            max_len = max(max_len, cur_len)\n        return max_len\n\nif __name__ == \"__main__\":\n    print Solution().longestSubsequence([Interval(0, 1), Interval(1, 2), Interval(1, 3), Interval(1, 4), Interval(2, 4), Interval(3, 4), Interval(3, 5), Interval(4, 5), Interval(4, 6), Interval(5, 6), Interval(6, 7), Interval(7, 8), Interval(8, 9), Interval(9, 10)])",
      -7.9609375
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(A, left, right):\n            if left == right:\n                return 0\n            mid = (left + right) / 2\n            if A[mid] == 0:\n                return 1\n            if A[mid] == 1:\n                return 1 + dfs(A, left, mid)\n            return 1 + dfs(A, mid + 1, right)\n        return dfs(A, 0, len(A) - 1)\n\n\nif __name__ == '__main__':\n    A = [0, 1, 0]\n    assert Solution().longestSubsequence(A) == 1\n    A = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,",
      -8.3828125
    ],
    [
      "# https://www.hackerrank.com/challenges/longest-subsequence-one-difference\n# https://www.hackerrank.com/challenges/longest-subsequence-two-differences\n# https://www.hackerrank.com/challenges/longest-subsequence-three-differences\n\ndef longest_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n\n    # https://www.hackerrank.com/challenges/longest-subsequence-one-difference/submissions/code/7176537\n    # https://www.hackerrank.com/challenges/longest-subsequence-two-differences/submissions/code/7176657\n    # https://www.hackerrank.com/challenges/longest-subsequence-three-differences/submissions/code/7176667\n\n    # https://www.hackerrank.com/challenges/longest-subsequence-one-difference/submissions/code/7176537\n    # https://www.hackerrank.com/challenges/longest-subsequence-two-differences/submissions/code/7176657\n    # https://www.hackerrank.com/challenges/longest-subsequence-three-differences/submissions/code/7176667\n\n    # https://www.hackerrank.com/challenges/longest-subsequence-one-difference/submissions/code/7176537\n    # https://www.hackerrank.com/challenges/longest-subsequence-two-differences/submissions/code/7176657\n    # https://www.hackerrank.com/challenges/longest-subsequence-three-differences/submissions/code/7176667\n\n    max_len = 0\n    curr_max_len = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j] + 1:\n                curr_max_len = max(curr_max_len, j -",
      -8.4375
    ],
    [
      "# A basic approach to find the longest subsequence\n# The idea is to find the longest subsequence by counting the number of elements in the subsequence\n# Once we have the number of elements in the subsequence, we can keep track of the largest element in the subsequence\n# If the number of elements in the subsequence is equal to the number of elements in the sequence, then we can say the\n# subsequence is the longest subsequence\n\n# Approach 2:\n# This approach is to count the number of elements in the subsequence, and then find the number of elements in the sequence\n# This approach is more efficient than the approach 1\n\n# Approach 3:\n# The idea is to find the subsequence of the array, and then find the longest subsequence of the subsequence.\n# This is done by comparing the difference between adjacent elements, and then comparing the length of the subsequence\n# If the difference between adjacent elements is equal to 1, then we know that the longest subsequence is that of the subsequence\n\ndef longest_subsequence(arr):\n    # If the length of the array is 1, then the longest subsequence is the array itself\n    if len(arr) == 1:\n        return arr\n\n    # If the length of the array is 2, then the longest subsequence is the array itself\n    if len(arr) == 2:\n        return arr\n\n    # Initialize the largest value to zero\n    largest_value = 0\n\n    # Initialize the current index to zero\n    current_index = 0\n\n    # Initialize the current largest value to zero\n    current_largest_value = 0\n\n    # Iterate through the array, and keep track of the largest value and the current index\n    for i in range(0, len(arr) - 1):\n        # Get the difference between adjacent elements\n        difference = arr[i + 1] - arr[i]\n\n        # If the difference between adjacent elements is one, then the current subsequence is the array itself\n        if difference == 1:\n            # Keep track of the largest value in the current subsequence\n            current_largest_value = max(current_largest_value, arr[i])\n\n        # If the difference between adjacent elements is greater than one, then we need to compare the current\n        # subsequence with the previous subsequence\n        else:",
      -10.0078125
    ],
    [
      "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return n\n        dp = [[0] * n for _ in range(n)]\n        for i in range(1, n):\n            dp[0][i] = 1\n            for j in range(i):\n                if j > 0 and nums[j] == nums[j - 1]:\n                    dp[j][i] = 1\n                else:\n                    dp[j][i] = max(dp[j][i], dp[j - 1][i] + 1)\n        return max(dp[-1][-1], n)\n\n\nif __name__ == \"__main__\":\n    assert Solution().longestConsecutive([1, 2, 3, 3, 3, 4]) == 3\n    assert Solution().longestConsecutive([1, 2, 3, 3, 3, 4, 5]) == 5",
      -10.0546875
    ],
    [
      "class Solution(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 1:\n            return len(nums)\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + 1\n                if nums[i] == nums[j]:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1])\n        return max(dp[0][-1], dp[-1][0])\n\nclass Solution2(object):\n    def longestSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 1:\n            return len(nums)\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + 1\n                if nums[i] == nums[j]:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1])\n        return max(dp[0][-1], dp[-1][0])",
      -10.1328125
    ],
    [
      "# TLE\ndef find_longest_subsequence(arr):\n    if len(arr) < 2:\n        return len(arr)\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] == arr[j]:\n                continue\n            else:\n                return len(arr[i:j+1])\n    return n\n\ndef test_find_longest_subsequence():\n    assert(find_longest_subsequence([0, 1, 1, 2, 2, 2, 3, 4]) == 4)\n    assert(find_longest_subsequence([1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1)\n    assert(find_longest_subsequence([1, 2, 2, 2, 3, 4, 4, 4, 4, 4]) == 4)\n\nif __name__ == '__main__':\n    test_find_longest_subsequence()",
      -10.609375
    ],
    [
      "# https://www.geeksforgeeks.org/find-the-longest-subsequence-of-one-differences-for-given-array/\n\nclass Solution(object):\n    def longestSubsequenceOneDiff(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        # if the difference is greater than two, return the length of the longest subsequence\n        if len(arr) < 3:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0]!= arr[1] and arr[0]!= arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0] == arr[1] and arr[1]!= arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0] == arr[2] and arr[1]!= arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0]!= arr[2] and arr[1] == arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0]!= arr[1] and arr[1] == arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0] == arr[1] and arr[0] == arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0] == arr[2] and arr[1] == arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the length of the longest subsequence\n        if arr[0] == arr[1] and arr[0] == arr[2]:\n            return len(arr)\n\n        # if the difference is less than 2, return the",
      -10.859375
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n\n    def longestOne(self, nums):\n        # Write your code here\n        if nums is None or len(nums) == 0:\n            return 0\n        max_len = 0\n        for i in range(len(nums)):\n            cur_len = 1\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    cur_len += 1\n                else:\n                    break\n            max_len = max(max_len, cur_len)\n        return max_len\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.longestOne([0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])",
      -10.9609375
    ],
    [
      "# https://leetcode.com/problems/longest-increasing-subsequence/\n# Given an unsorted array of integers, find the length of the longest consecutive elements increasing subsequence.\n# For example, [4, 5, 7, 0, 1, 9] is one increasing subsequence.\n#\n# 4, 5, 7, 0, 1, 9\n#\n# 4 5 7 0 1 9\n#\n# 4, 5, 7, 0, 1, 9\n#\n# Return 3, which is the length of the longest consecutive elements increasing subsequence.\n#\n# Note:\n# The length of the given array is positive and will not exceed 10,000.\n# The length of all increasing subsequence's elements will be in the range of [1, 10,000].\n#\n#\n#\n#\n# Example 1:\n#\n# Input: [4, 5, 7, 0, 1, 9]\n# Output: 3\n# Example 2:\n#\n# Input: [1, 2, 3, 4]\n# Output: 1\n# Example 3:\n#\n# Input: [1, 2, 3, 3, 4, 4, 5]\n# Output: 3\n# Example 4:\n#\n# Input: [2, 2, 2, 2, 2, 2, 2]\n# Output: 2\n# Example 5:\n#\n# Input: [2, 2, 2, 2, 2, 2, 2, 3]\n# Output: 2\n#\n#\n#\n# Constraints:\n#\n# 1 <= The length of the given array is in the range of [1, 10,000].\n# 1 <= Each element of the given array will be in the range of [0, 10,000].\n#\n\nclass Solution(object):\n    def longestIncreasingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def longest(left, right):\n            if left == right:\n                return 1\n            if nums[left] < nums[right]:\n                return longest(left+1, right)\n            else:\n                return longest(left, right+1)\n        return longest(0, len(nums)-1)",
      -11.609375
    ],
    [
      "import math\nimport collections\n\n# The solution is still a bit tricky. The idea is to find the longest subsequence\n# that is made by the adjacent numbers.\n# For example, for array [1, 2, 3, 4], the longest subsequence is [1, 2, 3], and the subsequence length is 3.\n# For array [1, 2, 3, 5], the longest subsequence is [1, 2, 3, 5], and the subsequence length is 4.\n# For array [1, 2, 3, 4, 5], the longest subsequence is [1, 2, 3, 5], and the subsequence length is 5.\n# In this case, the subsequence is [1, 2, 3, 5], and the subsequence length is 5.\n# The only way to make this work is to find the longest subsequence of the array, and then\n# find the subsequence length of the longest subsequence.\n\n# TODO:\n# The only way to solve this problem is to keep track of the longest subsequence of the array,\n# and the subsequence length of the longest subsequence.\n\ndef longest_subsequence(arr):\n    if len(arr) == 0:\n        return []\n    # TODO: Make sure this is correct.\n    subseq_len = 1\n    max_subseq = [arr[0]]\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]:\n            subseq_len += 1\n        else:\n            subseq_len = 1\n            max_subseq.append(arr[i])\n    return max_subseq\n\n# TODO:\n# Create a function that finds the longest subsequence of a given array.\n# The function should take in an array of integers, and return the length of the longest subsequence.\n# The subsequence should be represented as a list.\n# The subsequence is the longest subsequence of the given array.\n# The subsequence is the longest subsequence of the given array, and the subsequence length is the length of the longest subsequence.\n# The subsequence is [1, 2, 3, 5], and the subsequence length is 4.\n# The subsequence is [1, 2, 3, 5], and the subsequence",
      -11.7109375
    ],
    [
      "import numpy as np\nfrom collections import defaultdict\n\n\ndef find_longest_subsequence_one_diff(arr):\n    \"\"\"\n    :param arr: The array to be searched\n    :return: The longest subsequence with 1 difference\n    \"\"\"\n    lengths = defaultdict(int)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            lengths[(arr[i], arr[j])] += 1\n\n    # print(lengths)\n    max_length = 0\n    max_key = None\n    for key, value in lengths.items():\n        if value == 1:\n            if value > max_length:\n                max_length = value\n                max_key = key\n    return max_key\n\n\ndef find_longest_subsequence_two_diff(arr):\n    \"\"\"\n    :param arr: The array to be searched\n    :return: The longest subsequence with 2 differences\n    \"\"\"\n    lengths = defaultdict(int)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                lengths[(arr[i], arr[j])] += 1\n            else:\n                lengths[(arr[i], arr[j])] += 2\n    max_length = 0\n    max_key = None\n    for key, value in lengths.items():\n        if value > max_length:\n            max_length = value\n            max_key = key\n    return max_key\n\n\ndef find_longest_subsequence(arr):\n    \"\"\"\n    :param arr: The array to be searched\n    :return: The longest subsequence\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    if arr[0] == arr[1]:\n        return find_longest_subsequence_one_diff(arr)\n    else:\n        return find_longest_subsequence_two_diff(arr)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(",
      -12.0703125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestSubsequence(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        maxLen = 0\n        queue = [(root, 0)]\n        while queue:\n            node, len = queue.pop()\n            if node.left:\n                queue.append((node.left, len + 1))\n            if node.right:\n                queue.append((node.right, len + 1))\n            if len > maxLen:\n                maxLen = len\n        return maxLen\n\n\n# TESTS\nfor n, m, expected in [\n    ([], [], 0),\n    ([1], [], 1),\n    ([1, 2, 3, 4, 5], [2, 4, 6, 8, 10], 5),\n    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 5, 6, 7], 6),\n    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 8, 10], 6),\n    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 7, 8, 10], 6),\n    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 9, 10], 6),\n    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 8, 10], 6),\n]:\n    sol = Solution()\n    actual = sol.longestSubsequence(TreeNode(*n))\n    print(\"The longest subsequence is\", expected, \"and its length is\", actual)\n    assert actual == expected",
      -12.359375
    ],
    [
      "from collections import defaultdict\n\n\nclass Solution:\n    def longestSubsequence(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        max_len_pos = 0\n        max_len_pos_list = []\n\n        for i in range(len(A)):\n            max_len = max(max_len, 1)\n            max_len_pos = max(max_len_pos, i)\n            max_len_pos_list.append(max_len_pos)\n            max_len_pos += 1\n\n        max_len = max(max_len, 1)\n        max_len_pos = max(max_len_pos, i)\n        max_len_pos_list.append(max_len_pos)\n\n        for i in range(len(A) - 1):\n            for j in range(i + 1, len(A)):\n                if A[i] == A[j]:\n                    if A[i] == A[i + 1]:\n                        max_len = max(max_len, 2)\n                        max_len_pos = max(max_len_pos, i + 2)\n                        max_len_pos_list.append(max_len_pos)\n                        max_len_pos += 2\n                    else:\n                        max_len = max(max_len, 1)\n                        max_len_pos = max(max_len_pos, i + 1)\n                        max_len_pos_list.append(max_len_pos)\n                        max_len_pos += 1\n                else:\n                    max_len = max(max_len, 1)\n                    max_len_pos = max(max_len_pos, i)\n                    max_len_pos_list.append(max_len_pos)\n                    max_len_pos += 1\n\n        return max(max_len_pos_list)\n\n\nif __name__ == '__main__':\n    A = [1, 2, 1]\n    print(Solution().longestSubsequence(A))",
      -13.953125
    ],
    [
      "# https://leetcode.com/problems/longest-subsequence-with-one-difference/discuss/126463/Python-Solution\n# https://leetcode.com/problems/longest-subsequence-with-one-difference/discuss/126463/python-implementation\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestSubsequence(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        res = []\n        self.longestSubsequenceHelper(root, res)\n        return len(res)\n\n    def longestSubsequenceHelper(self, root, res):\n        if not root:\n            return 0\n\n        if not root.left and not root.right:\n            res.append(root.val)\n            return 1\n\n        if root.left:\n            self.longestSubsequenceHelper(root.left, res)\n\n        if root.right:\n            self.longestSubsequenceHelper(root.right, res)\n\n        if len(res) < len(res) + 1:\n            res.append(root.val)\n\n# Note:\n# Use a dictionary to store the max length of the longest subsequence.\n# Use a list to store the maximum value in the longest subsequence.",
      -14.0546875
    ],
    [
      "# https://leetcode.com/problems/longest-subsequence-of-one-1s/discuss/293735/C++-Python-and-C#2\n# https://leetcode.com/problems/longest-subsequence-of-one-1s/discuss/293735/Java-Python-and-C#2\n# https://leetcode.com/problems/longest-subsequence-of-one-1s/discuss/293735/C++-Python-and-C#2\n\nfrom common.array_helper import *\nfrom common.interval_helper import *\n\ndef find_max_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    interval_set = IntervalSet(arr[0], arr[-1])\n    res = []\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if interval_set.contain(arr[j]):\n                if res[-1] > arr[j]:\n                    res.append(arr[j])\n                else:\n                    res[-1] = max(res[-1], arr[j])\n            else:\n                res.append(arr[j])\n                interval_set.add(arr[j])\n                interval_set.add(arr[j-1])\n    return res\n\n\ndef find_max_subsequence_v1(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    res = []\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[j] == 1:\n                if res[-1] > arr[j]:\n                    res.append(arr[j])\n                else:\n                    res[-1] = max(res[-1], arr[j])\n            else:\n                res.append(arr[j])",
      -14.2109375
    ],
    [
      "# https://leetcode.com/problems/longest-subsequence-of-one-bits/\n\nclass Solution(object):\n    def longestSubsequenceOneBits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        # 1. find max length of a subsequence\n        maxLen = 0\n        maxLenIdx = 0\n        for i in range(n):\n            if nums[i] == 0:\n                maxLenIdx = i\n                maxLen = 1\n            else:\n                maxLenIdx = i\n                maxLen = max(maxLen, i - nums[i-1])\n\n        # 2. find the longest subsequence of length 1\n        maxLenOneSubseq = 0\n        maxLenOneSubseqIdx = 0\n        for i in range(n):\n            if nums[i] == 0:\n                if i - maxLenOneSubseqIdx > 1:\n                    maxLenOneSubseq = max(maxLenOneSubseq, i - maxLenOneSubseqIdx)\n                maxLenOneSubseqIdx = i\n            else:\n                if i - nums[i-1] > 1:\n                    maxLenOneSubseq = max(maxLenOneSubseq, i - nums[i-1])\n\n        # 3. find the longest subsequence of length 2\n        maxLenTwoSubseq = 0\n        maxLenTwoSubseqIdx = 0\n        for i in range(n):\n            if nums[i] == 0:\n                if i - nums[i-1] > 2:\n                    maxLenTwoSubseq = max(maxLenTwoSubseq, i - nums[i-1])\n                maxLenTwoSubseqIdx = i\n            else:\n                if i - nums[i-1] > 2:\n                    maxLenTwoSubseq = max(maxLenTwoSubseq, i - nums[i-1])\n\n        return max(maxLenOneSubseq, maxLenTwoSubseq)\n\n\nif __name__ == \"__main__\":\n    nums",
      -15.1796875
    ],
    [
      "# Example 1:\n# Input: [1,2,3,4,5,6,7]\n# Output: 2\n# Explanation: [1,2,3,4,5,6,7] is the longest subsequence with difference between adjacent elements being one.\n# Example 2:\n# Input: [1,2,3,4,5,6,7,8]\n# Output: 3\n# Explanation: [1,2,3,4,5,6,7,8] is the longest subsequence with difference between adjacent elements being one.\n# Example 3:\n# Input: [1,2,3,4,5,6,7,8,9]\n# Output: 1\n# Explanation: [1,2,3,4,5,6,7,8,9] is the longest subsequence with difference between adjacent elements being one.\n# Example 4:\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: 5\n# Explanation: [1,2,3,4,5,6,7,8,9,10] is the longest subsequence with difference between adjacent elements being one.\n# Note:\n# The length of the array won't exceed 10,000.\n# The length of the given array is at most 1,000.\n# The value of each element in the given array is at most 100.\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums.sort()\n        max_sum = nums[0]\n        max_sum_idx = 0\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                continue\n            max_sum = max(max_sum, nums[i])\n            max_sum_idx = i\n        return max(max_sum, nums[max_sum_idx])",
      -17.015625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}