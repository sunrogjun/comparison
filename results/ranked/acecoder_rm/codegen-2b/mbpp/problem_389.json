{
  "problem": {
    "task_id": "MBPP/400",
    "prompt": "Write a function to extract the frequency of unique tuples in the given list order irrespective.",
    "canonical_solution": "def extract_freq(test_list):\r\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)",
    "test_list": [
      "assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3",
      "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4",
      "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"
    ],
    "challenge_test_list": [],
    "problem_id": 389
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "# https://www.hackerrank.com/challenges/extract-frequency\n\n# Note:\n# We could have used the built-in list function to create a sorted list. But we need to sort the list.\n\n# Example:\n# Input:\n# [1,2,2,3,3,3,3,4,4,4,4,4]\n# Output:\n# [1,2,3,4]\n\ndef extract_frequency(l):\n    \"\"\"\n    Returns a list of unique values in the given list.\n\n    Example:\n    Input:\n    [1,2,2,3,3,3,3,4,4,4,4,4]\n    Output:\n    [1,2,3,4]\n    \"\"\"\n\n    # Use a set to store unique values in the given list\n    unique_values = set()\n\n    # Iterate over the list and add each unique value to unique_values\n    for v in l:\n        if v not in unique_values:\n            unique_values.add(v)\n\n    # Convert unique_values into a list\n    unique_values = list(unique_values)\n\n    # Sort the list\n    unique_values.sort()\n\n    # Return the sorted list\n    return unique_values",
      11.671875
    ],
    [
      "def findFrequency(list):\n    # write your code here\n    if not list:\n        return 0\n    # Initialize a dictionary to store frequency of each item\n    d = {}\n    # Loop through the list and store the frequency of each item in dictionary\n    for i in list:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n    # Return the number of times the item appears in the list\n    return len(d)\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert findFrequency([]) == 0, \"empty list\"\n    assert findFrequency([1]) == 1, \"single number list\"\n    assert findFrequency([1, 1, 1]) == 3, \"all equal numbers list\"\n    assert findFrequency([2, 2, 1, 2]) == 5, \"duplicate numbers list\"\n    assert findFrequency([1, 1, 3]) == 3, \"all unique numbers list\"",
      0.97802734375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __cmp__(self, other):\n        return cmp(self.x, other.x)\n\nclass Solution(object):\n    def uniqueTupleFrequencies(self, A):\n        \"\"\"\n        :type A: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for t in A:\n            if t not in d:\n                d[t] = 1\n            else:\n                d[t] += 1\n        return sorted([(d[t], t) for t in d], key=lambda x: x[0], reverse=True)",
      0.43994140625
    ],
    [
      "class Solution(object):\n    def findFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        freq = {}\n        for num in nums:\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        return sorted(list(freq.values()), reverse=True)\n\n\nif __name__ == '__main__':\n    print Solution().findFrequent([1,1,1,2,2,3,3,4,4,4,4,4,4,4,4,4,5], 3)",
      0.33642578125
    ],
    [
      "from collections import defaultdict\nimport operator\n\ndef unique_tuples(A):\n    # write your code here\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n# END OMIT\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n# END OMIT\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n# END OMIT\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n# END OMIT\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items() if value == 1]\n    return unique_tuples\n# END OMIT\n\n# BEGIN OMIT\ndef unique_tuples(A):\n    count = defaultdict(int)\n    for item in A:\n        count[item] += 1\n    unique_tuples = [key for key,value in count.items",
      0.298583984375
    ],
    [
      "# https://www.geeksforgeeks.org/frequency-of-unique-tuples-in-the-given-list-order-irrespective/\n# https://www.geeksforgeeks.org/frequency-of-unique-tuples-in-the-given-list-order-irrespective/\n\n# https://www.geeksforgeeks.org/frequency-of-unique-tuples-in-the-given-list-order-irrespective/\n\ndef frequency(list):\n    # If there are only 2 items in the list then there is only one unique tuple\n    # So frequency would be 1\n    # If there are more than 2 items in the list then there are more than one unique tuple\n    # So frequency would be 2\n    if len(list) == 2:\n        return 1\n    else:\n        return len(list)\n\ndef main():\n    list = [1, 2, 3, 2, 1, 3, 2, 3, 1, 4]\n    print(frequency(list))\n\nif __name__ == '__main__':\n    main()",
      0.09991455078125
    ],
    [
      "# https://www.hackerrank.com/challenges/extract-frequencies\ndef extractFrequency(list):\n    \"\"\"\n    :type list: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    count = {}\n\n    for item in list:\n        if item not in count:\n            count[item] = 1\n        else:\n            count[item] += 1\n\n    for key in count:\n        if key not in result:\n            result.append(key)\n\n    return result",
      -0.85595703125
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples/problem\n\nimport collections\nimport heapq\n\ndef unique_tuples(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    unique_tuples = collections.Counter(numbers)\n    return sum(unique_tuples.values())\n\nif __name__ == \"__main__\":\n    numbers = [1,2,2,2,3,3,3,4,4,4,4]\n    print(unique_tuples(numbers))",
      -0.85595703125
    ],
    [
      "import collections\n\ndef unique_tuples(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    # The following code is written to be python 2 compatible\n    # For python 3, the following code is equivalent to the above\n    # collections.Counter(list_of_tuples).most_common()\n    # return collections.Counter(list_of_tuples).most_common(1)[0][0]\n    counter = collections.Counter(list_of_tuples)\n    return counter.most_common(1)[0][0]",
      -0.85595703125
    ],
    [
      "def unique_tuples_frequency(arr):\n    return dict(map(lambda x: (x[0], 1), filter(lambda x: x[1] == 1, zip(arr, arr))))\n\ndef unique_tuples_frequency_2(arr):\n    return dict(map(lambda x: (x[0], 1), filter(lambda x: x[1] == 1, zip(arr, arr))))\n\ndef unique_tuples_frequency_3(arr):\n    return dict(map(lambda x: (x[0], 1), filter(lambda x: x[1] == 1, zip(arr, arr))))",
      -0.85595703125
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple-frequency\n# Time Complexity: O(n^2)\n# Space Complexity: O(n)\n\ndef unique_tuple_frequency(list_of_tuples):\n    unique_tuples = []\n    for t in list_of_tuples:\n        if t not in unique_tuples:\n            unique_tuples.append(t)\n    return len(unique_tuples)\n\n\nif __name__ == \"__main__\":\n    print(unique_tuple_frequency([(1, 2), (1, 2), (1, 2), (2, 1), (1, 2), (2, 1)]))",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param nums a list of integers\n    # @return an integer\n    def uniqueMulitple(self, nums):\n        if not nums:\n            return 0\n        nums.sort()\n        ret = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                ret += 1\n        return ret\n\nif __name__ == \"__main__\":\n    assert Solution().uniqueMulitple([1, 1, 2, 2, 3, 3, 4, 5, 6, 6]) == 3",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def uniqueFrequency(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        freq = {}\n        for i in A:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n        return sorted(freq.items(), key=lambda x: x[1])",
      -0.85693359375
    ],
    [
      "#!/bin/python\n\n# https://www.hackerrank.com/challenges/unique-tuples/problem\n\n# Time Complexity: O(n^2)\n# Space Complexity: O(n)\n\ndef uniqueTuples(A):\n    if not A:\n        return []\n    n = len(A)\n    res = [0] * (n+1)\n    res[0] = 1\n    for i in range(1, n+1):\n        for j in range(0, i):\n            if A[i] == A[j]:\n                res[i] += res[j]\n    return res",
      -0.85693359375
    ],
    [
      "def unique_tuples_frequency(l):\n    \"\"\"\n    :type l: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # O(n^2) time and O(n) space\n    # i, j are indexes of the current tuple\n    # frequency is the number of unique tuples that have the same value of i and j\n    frequency = collections.defaultdict(int)\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] == l[j]:\n                frequency[i] += 1\n                frequency[j] += 1\n    return sum(frequency.values())",
      -0.85693359375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __hash__(self):\n        return hash(self.x)\n    def __eq__(self, other):\n        return self.x == other.x\n\n\nclass Solution(object):\n    def uniqueTupleFrequencies(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        if not tuples:\n            return []\n        m = {}\n        for t in tuples:\n            if t not in m:\n                m[t] = 1\n            else:\n                m[t] += 1\n        return [m[t] for t in m]\n\n# Note:\n# Hash is not good.",
      -0.85791015625
    ],
    [
      "def frequency(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    freq = {}\n    for e in l:\n        if e not in freq:\n            freq[e] = 1\n        else:\n            freq[e] += 1\n    return [freq[e] for e in freq]\n\n\nif __name__ == \"__main__\":\n    l = [1, 2, 3, 1, 2, 2, 3, 1, 2, 3, 1, 1, 2]\n    print(frequency(l))",
      -0.85791015625
    ],
    [
      "from collections import Counter\n\ndef extract_frequency(tuples):\n    \"\"\"\n    Extract the frequency of unique tuples in the given list order.\n    :param tuples: List of tuples\n    :return: List of tuples, with the frequency of unique tuples.\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(Counter(t).most_common(1)[0][0])\n    return result",
      -0.85791015625
    ],
    [
      "#!/usr/bin/python\n\ndef unique_tuples(arr):\n    # Complete this function\n    set_tuples = set()\n    for i in arr:\n        set_tuples.add(tuple(i))\n    return len(set_tuples)\n\n# https://www.hackerrank.com/challenges/find-the-frequency-of-the-unique-tuples/problem",
      -0.85791015625
    ],
    [
      "# write your code here\ndef unique_tuples(seq):\n    seen = set()\n    seen_add = seen.add\n    result = []\n    for item in seq:\n        if item not in seen:\n            seen_add(item)\n            result.append(item)\n    return result\n\n\nif __name__ == '__main__':\n    print(unique_tuples([1,2,3,1,2,3]))\n    print(unique_tuples([1,1,1,2,3,3,3]))\n    print(unique_tuples([1,2,2,3,4,3,1]))\n    print(unique_tuples([1,2,2,3,4,3,1,3,2]))\n    print(unique_tuples([1,2,2,3,4,3,1,3,2,1]))\n    print(unique_tuples([1,1,1,2,3,3,3,4,5,6,7,1]))",
      -0.85791015625
    ],
    [
      "import collections\n\nclass Solution:\n    def uniqueTupleFrequencies(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(tuple(nums))\n        res = []\n        for t, v in counts.items():\n            if v == 1:\n                res.append(t)\n        return res\n\nif __name__ == '__main__':\n    assert Solution().uniqueTupleFrequencies([1,1,1,2,3]) == [1, 2, 3]",
      -0.85791015625
    ],
    [
      "import collections\n\n\ndef find_unique_tuples(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # Create a map of the unique elements\n    unique_elements = collections.Counter(list_of_tuples)\n    # Create a list of unique elements\n    unique_elements = list(unique_elements.keys())\n    # Find the frequency of each unique element\n    frequency = {}\n    for element in unique_elements:\n        frequency[element] = unique_elements[element]\n    return sorted(frequency.values(), reverse=True)\n\n\nif __name__ == '__main__':\n    list_of_tuples = [[1, 2, 3], [1, 3], [1, 2, 1], [1, 2, 2], [1, 1]]\n    print(find_unique_tuples(list_of_tuples))",
      -0.85791015625
    ],
    [
      "import collections\nimport math\nimport itertools\nimport operator\n\n# Complete the uniqueTuples function below.\n#\n# The function is expected to return an INTEGER.\n# The function accepts INTEGER list as parameter.\ndef uniqueTuples(A):\n    res = collections.defaultdict(list)\n    for t in A:\n        res[t].append(t)\n    return len(res)\n\nif __name__ == \"__main__\":\n    A = [1, 1, 2, 2, 3, 3, 4, 4, 4]\n    assert uniqueTuples(A) == 1",
      -0.85791015625
    ],
    [
      "import collections\n\ndef get_frequency(t):\n    \"\"\"\n    :type t: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    result = collections.Counter()\n    for tup in t:\n        result[tup] += 1\n    return result.most_common()[0][1]\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert get_frequency([(1, 2), (2, 3), (1, 1), (1, 3), (3, 4)]) == 3, \"Only 1\"\n    assert get_frequency([(1, 2), (2, 3), (1, 1), (1, 3), (3, 4), (2, 1)]) == 2, \"Only 2\"\n    assert get_frequency([(1, 2), (2, 3), (1, 1), (1, 3), (3, 4)]) == 3, \"All\"",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def frequencyOfUniqueTuples(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dic = {}\n        for n in nums:\n            if n not in dic:\n                dic[n] = 1\n            else:\n                dic[n] += 1\n        freq = []\n        for k, v in dic.items():\n            freq.append(v)\n        freq.sort()\n        return freq",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple-frequency/problem\n# https://www.hackerrank.com/challenges/unique-tuple-frequency/submissions/code/20295749\n\ndef unique_tuple_frequency(numbers):\n    return {k: v for k, v in collections.Counter(numbers).items() if v == 1}\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 2, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6]\n    print(unique_tuple_frequency(numbers))",
      -0.8583984375
    ],
    [
      "def unique_tuples(arr):\n    # Write your code here\n    res = []\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i!= j:\n                if arr[i] == arr[j]:\n                    res.append(arr[i])\n    return res\n\ndef main():\n    print unique_tuples([1,2,1,3,4,1])\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __hash__(self):\n        return hash(self.x)\n\n\ndef unique_tuples(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    result = 0\n    for t in tuples:\n        if t in tuples:\n            result += 1\n    return result\n\nif __name__ == \"__main__\":\n    t = [Tuple(1), Tuple(2), Tuple(2), Tuple(1), Tuple(1), Tuple(2)]\n    print unique_tuples(t)",
      -0.8583984375
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/unique-tuples/problem\n\nimport sys\nimport math\nimport timeit\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n\n    if len(sys.argv)!= 2:\n        sys.exit(\"Please enter a list\")\n\n    list_of_tuples = sys.argv[1]\n\n    print \"List length: {}\".format(len(list_of_tuples))\n\n    list_of_tuples.sort()\n\n    # print list_of_tuples\n\n    counter = 1\n\n    for i in range(0, len(list_of_tuples) - 1):\n        if list_of_tuples[i] == list_of_tuples[i + 1]:\n            counter += 1\n        else:\n            print \"Unique tuple: {}\".format(counter)\n            counter = 1\n            # print list_of_tuples\n\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "import collections\n\ndef extractFrequencies(listOfTuples):\n    \"\"\"\n    :type listOfTuples: List[Tuple[int, int]]\n    :rtype: List[int]\n    \"\"\"\n    freqDict = collections.defaultdict(lambda: 0)\n    for t in listOfTuples:\n        freqDict[t] += 1\n    return [freqDict[t] for t in freqDict]",
      -0.8583984375
    ],
    [
      "import collections\n\n\ndef get_frequency(unique_list):\n    \"\"\"\n    :type unique_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    # unique_list = [('a', 1), ('b', 2), ('c', 3), ('a', 1), ('b', 2), ('b', 3)]\n    # unique_list = [('a', 1), ('b', 2), ('b', 3)]\n    freq = collections.Counter(unique_list)\n    return list(freq.values())\n\n\n# TESTS\nfor input_list, expected in [\n    ([], []),\n    ([1], [1]),\n    ([1, 2], [2]),\n    ([1, 1, 2, 2], [2]),\n]:\n    actual = get_frequency(input_list)\n    print(\"get_frequency({}) = {}, expected = {}\".format(input_list, actual, expected))\n    assert actual == expected",
      -0.8583984375
    ],
    [
      "def unique_tuples_frequency(list_of_tuples):\n    \"\"\"\n    Write a function to extract the frequency of unique tuples in the given list order\n    :param list_of_tuples: list of tuples\n    :return: dictionary of unique_tuples and their frequency\n    \"\"\"\n    unique_tuples = {}\n    for i in list_of_tuples:\n        if i not in unique_tuples:\n            unique_tuples[i] = 1\n        else:\n            unique_tuples[i] += 1\n    return unique_tuples",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/find-the-frequency-of-tuples/problem\n\ndef find_frequency(list_of_tuples):\n    count = 0\n    for i in range(len(list_of_tuples)):\n        for j in range(i+1, len(list_of_tuples)):\n            if list_of_tuples[i] == list_of_tuples[j]:\n                count += 1\n    return count\n\n\nif __name__ == '__main__':\n    list_of_tuples = [1, 2, 1, 3, 4, 2, 2, 1]\n    print(find_frequency(list_of_tuples))",
      -0.8583984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def frequencySort(self, head: ListNode) -> ListNode:\n        \"\"\"\n        O(n)\n        O(n)\n        O(n)\n        \"\"\"\n        \n        frequency = defaultdict(int)\n        result = ListNode(0)\n        curr = result\n        \n        while head:\n            frequency[head.val] += 1\n            head = head.next\n        \n        for val in frequency:\n            curr.next = ListNode(val)\n            curr = curr.next\n            \n        return result.next",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples/problem\n# https://www.hackerrank.com/challenges/unique-tuples/examples/python/\n# https://www.hackerrank.com/challenges/unique-tuples/examples/python/\n# https://www.hackerrank.com/challenges/unique-tuples/examples/python/\n\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\nfrom collections import Counter\n\ndef unique_tuples(nums):\n    c = Counter(nums)\n    return [tup for tup, count in c.items() if count == 1]\n\nif __name__ == '__main__':\n    nums = [1, 1, 2, 2, 2, 3, 4, 5]\n    print(unique_tuples(nums))",
      -0.85888671875
    ],
    [
      "import unittest\n\n\ndef unique_tuples(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n\n    n = len(arr)\n    freq = {}\n\n    for i in range(n):\n        t = arr[i]\n        if t in freq:\n            freq[t] += 1\n        else:\n            freq[t] = 1\n\n    return len(freq)\n\n\nclass TestUniqueTuples(unittest.TestCase):\n    def test_unique_tuples(self):\n        self.assertEqual(unique_tuples([1, 1, 2, 2, 2, 3, 3, 3, 4, 5]), 3)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -0.85888671875
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple/problem\n\ndef uniqueTuple(a):\n    \"\"\"\n    :type a: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not a:\n        return []\n\n    tuple_dict = {}\n    for i in a:\n        if i in tuple_dict:\n            tuple_dict[i] += 1\n        else:\n            tuple_dict[i] = 1\n\n    return sorted(list(tuple_dict.items()), key=lambda t: t[1], reverse=True)\n\nif __name__ == \"__main__\":\n    input_ = [1, 2, 3, 4, 1, 2, 3, 4, 5]\n    print(uniqueTuple(input_))",
      -0.85888671875
    ],
    [
      "import collections\n\ndef unique_tuples(seq):\n    \"\"\"\n    :type seq: List[int]\n    :rtype: int\n    \"\"\"\n    # Store a set of unique tuples\n    unique_tuples = collections.defaultdict(set)\n\n    # Store a count of unique tuples\n    unique_count = 0\n\n    # Iterate over the given list\n    for item in seq:\n        # Store the current tuple\n        current_tuple = (item, item)\n\n        # Store the current tuple in the set\n        unique_tuples[current_tuple].add(item)\n\n        # Increment the unique count\n        unique_count += 1\n\n    # Return the count of unique tuples\n    return unique_count\n\n\n# Test Cases\nprint(unique_tuples([1, 2, 1, 2, 3]))\nprint(unique_tuples([1, 2, 3, 2, 4]))\nprint(unique_tuples([1, 2, 3, 4, 1]))",
      -0.85888671875
    ],
    [
      "import collections\n\n\nclass Solution:\n    def uniqueTupleFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = collections.Counter(tuple(nums))\n        return [res[t] for t in res.keys()]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 2, 1]\n    print(sol.uniqueTupleFrequency(nums))",
      -0.85888671875
    ],
    [
      "# https://www.hackerrank.com/challenges/extract-frequency-unique-tuples/problem\n\ndef extract_frequency_unique_tuples(list_of_tuples):\n    # Complete this function\n    freq = {}\n    for t in list_of_tuples:\n        if t in freq:\n            freq[t] += 1\n        else:\n            freq[t] = 1\n    return list(freq.items())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        list_of_tuples = list(map(int, input().split()))\n        print(extract_frequency_unique_tuples(list_of_tuples))",
      -0.85888671875
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples/problem\ndef unique_tuples(arr):\n    \"\"\"\n    :type arr: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # If there are no elements in the list, return 0\n    if not arr:\n        return 0\n\n    # Initialize a list to keep track of the unique elements\n    unique_list = []\n\n    # Iterate through the list and append the elements to the unique list\n    for i in range(0, len(arr)):\n        # Append each element in the list to the unique list\n        unique_list.append(arr[i])\n\n    # Go through the unique list and count the number of unique elements\n    # The unique elements are sorted by the first element\n    unique_list = sorted(unique_list)\n    return len(unique_list)",
      -0.85888671875
    ],
    [
      "def unique_tuples(list_order):\n    \"\"\"\n    :type list_order: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    \n    if not list_order:\n        return []\n    \n    freq_list = []\n    for t in list_order:\n        freq_list.append(t.count(t[0]))\n    \n    freq_list.sort()\n    \n    freq_list.reverse()\n    \n    return [x for x in freq_list if x > 0]\n\n# Your CodecademySolution object will be instantiated and called as such:\n# obj = CodecademySolution(input_list)\n# param_1 = obj.unique_tuples(input_list)",
      -0.85888671875
    ],
    [
      "# https://www.youtube.com/watch?v=z6xZ0uK7iK4\n\n# Write your code here\n\ndef find_frequency(lst):\n    # Write your code here\n    if lst == []:\n        return 0\n    freq = {}\n    for x in lst:\n        if x in freq:\n            freq[x] += 1\n        else:\n            freq[x] = 1\n    return freq\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 1, 3, 2, 4, 2, 1, 1]\n    print(find_frequency(lst))\n    lst = [1, 2, 1, 3, 2, 4, 2, 1, 1, 2, 2, 1]\n    print(find_frequency(lst))",
      -0.85888671875
    ],
    [
      "def frequency(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    count = collections.Counter(l)\n    return list(count.most_common())",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def extractCommonNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if not fast or not slow:\n                break\n\n        # Check for loop\n        if slow == fast:\n            return None\n\n        # Find common node\n        while slow and fast and slow.val == fast.val:\n            slow = slow.next\n            fast = fast.next\n\n        if slow:\n            slow = slow.next\n            fast = fast.next\n\n        # Remove common node\n        slow.next = None\n        fast.next = None\n\n        # Return the common node\n        return slow\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2, head)\n    head.next.next = ListNode(3, head.next)\n    head.next.next.next = ListNode(4, head.next.next)\n    head.next.next.next.next = ListNode(5, head.next.next.next)\n    print Solution().extractCommonNode(head)",
      -0.85888671875
    ],
    [
      "# https://www.hackerrank.com/challenges/travelling-tour-in-a-city\n\n\ndef frequency(arr):\n    # Write your code here\n    unique = []\n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            unique.append(i)\n            count[i] = 1\n    return unique, count\n\n\n# arr = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n# unique, count = frequency(arr)\n# print(unique)\n# print(count)\n\narr = [1, 1, 1, 1, 1, 1, 1, 1, 1]\nunique, count = frequency(arr)\nprint(unique)\nprint(count)",
      -0.85888671875
    ],
    [
      "# https://www.hackerearth.com/problem/algorithm/unique-tuples-in-a-list/\n\ndef unique_tuples_in_order(list_of_tuples):\n    \"\"\"\n    :param list_of_tuples: List of tuples\n    :return: List of unique tuples\n    \"\"\"\n    # Unique tuples\n    unique_tuples = []\n    # Loop over all tuples\n    for t in list_of_tuples:\n        # Loop over all unique tuples\n        for u in unique_tuples:\n            # If tuple is not unique\n            if t[0] == u[0] and t[1] == u[1]:\n                # Add tuple to list of unique tuples\n                unique_tuples.append(t)\n    return unique_tuples\n\n# Test cases\nprint(unique_tuples_in_order([(1, 1), (1, 2), (2, 1), (1, 1), (1, 2)]))",
      -1.078125
    ],
    [
      "# Approach 1:\n# 1. Iterate through list and store all unique items in a set\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 2:\n# 1. Create a dictionary and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 3:\n# 1. Create a dictionary and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 4:\n# 1. Create a dictionary and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 5:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 6:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 7:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 8:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 9:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 10:\n# 1. Create a list of tuples and populate it with the tuple keys\n# 2. Iterate through list and keep track of the frequency of unique items\n# 3. Calculate the frequency of unique items\n\n# Approach 11:\n# 1. Create a list",
      -1.478515625
    ],
    [
      "def frequency_of_unique_tuples(list_order):\n    # write your code here\n    # check whether the list is sorted\n    # if not, sort it\n    # if not, then calculate frequency of each unique tuple\n    # if yes, then just calculate frequency of each unique tuple\n\n    # if not sorted, then sort it\n    # if not sorted, then calculate frequency of each unique tuple\n\n    # if sorted, then just calculate frequency of each unique tuple\n\n    # if sorted, then calculate frequency of each unique tuple\n    pass\n\n# test case\nlist_order = [\n    (1, 2),\n    (2, 3),\n    (3, 4),\n    (1, 3),\n    (1, 4),\n    (2, 4),\n    (2, 3),\n    (3, 4)\n]\n\nfrequency_of_unique_tuples(list_order)",
      -1.6923828125
    ],
    [
      "# Definition for a tuple\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {integer}\n    def uniqueMoves(self, head):\n        # write your code here\n        if not head:\n            return 0\n        moves = 0\n        cur = head\n        while cur:\n            if cur.next:\n                cur = cur.next\n                while cur.next and cur.next.val == cur.val:\n                    cur = cur.next\n            else:\n                break\n            if cur.val!= cur.next.val:\n                moves += 1\n        return moves",
      -1.9580078125
    ],
    [
      "from collections import defaultdict\n\ndef get_frequency(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[i] += 1\n    return frequency\n\n\ndef find_frequency(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[i] += 1\n    return frequency\n\ndef find_frequency2(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency3(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency4(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency5(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[i] += 1\n    return frequency\n\ndef find_frequency6(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency7(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency8(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency9(list_of_tuples):\n    frequency = defaultdict(int)\n    for i in list_of_tuples:\n        frequency[tuple(i)] += 1\n    return frequency\n\ndef find_frequency10",
      -2.03125
    ],
    [
      "from collections import defaultdict\nfrom operator import itemgetter\n\ndef unique_tuples(list_of_tuples):\n    \"\"\"\n    Write a function to extract the frequency of unique tuples in the given list order irrespective.\n\n    Input\n    ----\n    list_of_tuples: list of tuples.\n\n    Output\n    ----\n    frequency: number of unique tuples in the given list.\n    \"\"\"\n    unique_tuples_dict = defaultdict(int)\n    for tup in list_of_tuples:\n        unique_tuples_dict[tup] += 1\n    return sum(unique_tuples_dict.values())\n\ndef main():\n    \"\"\"\n    Write a function to extract the frequency of unique tuples in the given list order irrespective.\n    \"\"\"\n    test_list = [\n        (1, 2),\n        (1, 3),\n        (2, 3),\n        (1, 4),\n        (2, 4),\n        (3, 4),\n        (1, 5),\n        (2, 5),\n        (3, 5),\n        (1, 6),\n        (2, 6),\n        (3, 6),\n        (1, 7),\n        (2, 7),\n        (3, 7),\n        (1, 8),\n        (2, 8),\n        (3, 8),\n        (1, 9),\n        (2, 9),\n        (3, 9),\n        (1, 10),\n        (2, 10),\n        (3, 10),\n        (1, 11),\n        (2, 11),\n        (3, 11),\n        (1, 12),\n        (2, 12),\n        (3, 12),\n        (1, 13),\n        (2, 13),\n        (3, 13),\n        (1, 14),\n        (2, 14),\n        (3, 14),\n        (1, 15),\n        (2, 15),\n        (3, 15),\n        (1, 16),\n        (2, 16),\n        (3, 16),\n        (1, 17),\n        (2, 17),\n        (3, 17),\n        (1, 18),\n        (",
      -2.046875
    ],
    [
      "from collections import Counter\n\nclass Solution:\n    \"\"\"\n    @param: nums: The integer array\n    @param: k: The kth smallest value\n    @return: The kth smallest frequency\n    \"\"\"\n    def findKFrequent(self, nums, k):\n        # write your code here\n        if len(nums) < k:\n            return 0\n\n        cnt = Counter(nums)\n        freq = {}\n        for v, c in cnt.items():\n            if v not in freq:\n                freq[v] = 1\n            else:\n                freq[v] += 1\n\n        return freq[min(freq)]\n\n\nif __name__ == \"__main__\":\n    print Solution().findKFrequent([1,1,1,2,2,3], 2)",
      -2.05078125
    ],
    [
      "import math\nimport random\n\ndef unique_tuples_frequency(list_order):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list order.\n    :param list_order: list of tuples\n    :return: frequency of unique tuples\n    \"\"\"\n    unique_tuples = set()\n    for t in list_order:\n        unique_tuples.add(t)\n\n    return len(unique_tuples)\n\ndef main():\n    \"\"\"\n    Main function\n    :return:\n    \"\"\"\n    list_order = [\n        (1, 2, 3),\n        (1, 2, 4),\n        (1, 2, 5),\n        (1, 3, 2),\n        (1, 3, 3),\n        (1, 3, 4),\n        (2, 3, 1),\n        (2, 3, 2),\n        (2, 3, 3),\n        (2, 3, 4),\n        (2, 3, 5),\n        (3, 2, 1),\n        (3, 2, 2),\n        (3, 2, 3),\n        (3, 2, 4),\n        (3, 2, 5),\n        (3, 3, 1),\n        (3, 3, 2),\n        (3, 3, 3),\n        (3, 3, 4),\n        (3, 3, 5),\n        (4, 3, 1),\n        (4, 3, 2),\n        (4, 3, 3),\n        (4, 3, 4),\n        (4, 3, 5),\n        (4, 4, 1),\n        (4, 4, 2),\n        (4, 4, 3),\n        (4, 4, 4),\n        (4, 4, 5)\n    ]\n\n    print(unique_tuples_frequency(list_order))\n\n    print(\"Time Complexity:\", math.factorial(len(list_order)))\n\nif __name__ == \"__main__\":\n    main()",
      -2.095703125
    ],
    [
      "def unique_tuples(list_of_tuples):\n    # Complete this function\n    return 0\n\n\nif __name__ == '__main__':\n    list_of_tuples = [\n        (1, 1),\n        (1, 2),\n        (1, 3),\n        (2, 1),\n        (2, 2),\n        (2, 3),\n        (3, 1),\n        (3, 2),\n        (3, 3)\n    ]\n    print unique_tuples(list_of_tuples)",
      -2.10546875
    ],
    [
      "def get_frequency(input_list):\n    \"\"\"\n    For each input_list element, compute the frequency of it, and return the list of tuples with the frequency.\n    :param input_list: the input list\n    :return: the list of tuples\n    \"\"\"\n    freq_tuple = []\n    for i in range(len(input_list)):\n        if i > 0:\n            if input_list[i]!= input_list[i - 1]:\n                freq_tuple.append((input_list[i], input_list[i - 1]))\n    return freq_tuple\n\ndef main():\n    \"\"\"\n    Test cases\n    \"\"\"\n    # Test 1\n    input_list = [1, 1, 2, 2, 3, 3]\n    expected_output = [(1, 2), (2, 3)]\n    actual_output = get_frequency(input_list)\n    assert expected_output == actual_output, \"Error: \" + str(expected_output) + \"!= \" + str(actual_output)\n    print(\"Test 1: Success!\")\n\n    # Test 2\n    input_list = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\n    expected_output = [(1, 2), (2, 3), (4, 5)]\n    actual_output = get_frequency(input_list)\n    assert expected_output == actual_output, \"Error: \" + str(expected_output) + \"!= \" + str(actual_output)\n    print(\"Test 2: Success!\")\n\n    # Test 3\n    input_list = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]\n    expected_output = [(1, 2), (2, 3), (4, 5), (6, 7)]\n    actual_output = get_frequency(input_list)\n    assert expected_output == actual_output, \"Error: \" + str(expected_output) + \"!= \" + str(actual_output)\n    print(\"Test 3: Success!\")\n\n    # Test 4\n    input_list = [1, 1, 2, 2, 3, 3",
      -2.232421875
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution:\n    def uniqueTupleFrequencies(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        freq = {}\n        for t in tuples:\n            if t not in freq:\n                freq[t] = 1\n            else:\n                freq[t] += 1\n        return [freq[t] for t in sorted(freq, key=freq.get)]",
      -2.271484375
    ],
    [
      "def unique_tuples(numbers):\n    unique_tuples = []\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i] == numbers[j]:\n                unique_tuples.append(numbers[i])\n    return unique_tuples\n\ndef main():\n    numbers = [1, 1, 2, 3, 2, 4, 3, 5, 1, 1, 1, 3, 2, 4, 1, 2, 4, 2, 1]\n    print unique_tuples(numbers)\n\nif __name__ == '__main__':\n    main()",
      -2.6875
    ],
    [
      "def unique_tuples(tuples):\n    \"\"\"\n    :param tuples: List of tuples\n    :return: List of unique tuples\n    \"\"\"\n    return list(set(tuples))\n\nif __name__ == '__main__':\n    tuples = [('a', 1), ('b', 1), ('c', 1), ('b', 2), ('b', 3), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4), ('c', 4), ('c', 4), ('c', 4)]\n    print unique_tuples(tuples)\n    tuples = [('a', 1), ('a', 1), ('b', 1), ('b', 2), ('b', 3), ('c', 4), ('c', 4), ('c', 4), ('c',",
      -2.861328125
    ],
    [
      "def unique_frequency(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: int\n    \"\"\"\n    dic = {}\n    for i in lst:\n        if i not in dic:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n    return len(dic)\n\n\nif __name__ == '__main__':\n    print(unique_frequency([1, 2, 3, 1, 2, 3, 3, 4]))",
      -2.884765625
    ],
    [
      "# This is the input for the problem.\n# There are 5 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 6 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 5 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 4 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 3 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 3 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 2 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 2 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 2 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 2 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 1 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 1 unique tuples in the given list.\n\n# [[0, 1], [1, 2], [2, 3], [0, 4], [0, 5]]\n# There are 0 unique tuples in the",
      -2.904296875
    ],
    [
      "def unique_tuples(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, return the frequency of unique tuples.\n    \"\"\"\n    # Create a set of unique tuples.\n    unique_tuples = set()\n\n    # For each tuple in the list of tuples, add it to the set if it is unique.\n    for tuple in list_of_tuples:\n        if tuple not in unique_tuples:\n            unique_tuples.add(tuple)\n\n    # Return the frequency of unique tuples.\n    return len(unique_tuples)\n\n\ndef unique_tuples2(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, return the frequency of unique tuples.\n    \"\"\"\n    # Create a set of unique tuples.\n    unique_tuples = set()\n\n    # For each tuple in the list of tuples, add it to the set if it is unique.\n    for tuple in list_of_tuples:\n        if tuple not in unique_tuples:\n            unique_tuples.add(tuple)\n\n    # Return the frequency of unique tuples.\n    return len(unique_tuples)",
      -3.23828125
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples-frequency-1\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-2\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-3\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-4\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-5\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-6\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-7\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-8\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-9\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-10\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-11\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-12\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-13\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-14\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-15\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-16\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-17\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-18\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-19\n# https://www.hackerrank.com/challenges/unique-tuples-frequency-20\n\ndef unique_tuples_frequency(list_of_tuples):\n    \"\"\"\n    Write a function to extract the frequency of unique tuples in the given list order irrespective.\n    \"\"\"\n\n    # Assume that the list is",
      -3.755859375
    ],
    [
      "# A solution\n# https://leetcode.com/problems/frequency-of-unique-tuples/discuss/115929/C%2B%2B-Python-Solution-O(n)\n# Time complexity: O(n)\n# Space complexity: O(n)\n# Runtime: 10 ms, faster than 90.76% of Python online submissions for Frequency of Unique Tuples.\n\n# Definition for a tuple of two integers.\n# class Pair(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n#         self.x, self.y = int(self.x), int(self.y)\n#\n# class Solution(object):\n#     def countPairs(self, nums):\n#         \"\"\"\n#         :type nums: List[int]\n#         :rtype: int\n#         \"\"\"\n#         nums.sort()\n#         return sum(1 for pair in map(lambda x: (x[0] - x[1]),\n#                                      zip(nums[:-1], nums[1:])\n#                                      if pair[0]!= pair[1])\n#                      if pair[0]!= pair[1])\n\n# Another solution\n# https://leetcode.com/problems/frequency-of-unique-tuples/discuss/115929/C%2B%2B-Python-Solution-O(n)\n# Time complexity: O(n)\n# Space complexity: O(n)\n# Runtime: 10 ms, faster than 90.76% of Python online submissions for Frequency of Unique Tuples.\n\n# Definition for a tuple of two integers.\n# class Pair(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n#         self.x, self.y = int(self.x), int(self.y)\n\nclass Solution(object):\n    def countPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return sum(",
      -3.80859375
    ],
    [
      "# Example\n# For input [1,2,3,1,2,3,3,2,1,2,3,3,3,3,2,2,1,2,2,2,3,2,2,3,3,3,3,3,3,3,2,1,2,2,3,3,2,2,3,3,2,3,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1,1,2,1,2,2,2,2,2,1,1,1,1,1,1,1,2,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",
      -3.859375
    ],
    [
      "def unique_tuples(nums):\n    # write your code here\n    if nums is None:\n        return 0\n    else:\n        return len(set(tuple(nums)))\n\nif __name__ == '__main__':\n    print(unique_tuples([1, 1, 1, 2, 2, 2, 3, 4, 4, 4]))\n    print(unique_tuples([1, 1, 1, 2, 2, 3, 4, 4, 4, 4]))\n    print(unique_tuples([1, 1, 1, 2, 2, 3, 4, 4, 4, 4]))\n    print(unique_tuples([1, 1, 1, 2, 2, 3, 4, 4, 4, 4]))",
      -3.86328125
    ],
    [
      "import collections\n\n# The function is to extract the frequency of unique tuples in the given list order.\n# It should return a dictionary with the unique tuples and its frequency.\n# The frequency is represented by a list of the same length.\n\n# Example 1:\n# Input: [1,1,2,2,3]\n# Output: {1: 2, 2: 2, 3: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Example 2:\n# Input: [1,1,1,2,3]\n# Output: {1: 3, 2: 2, 3: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Example 3:\n# Input: [1,1,2,3,3,4,5]\n# Output: {1: 5, 2: 3, 3: 3, 4: 1, 5: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Example 4:\n# Input: [1,1,1,1,2,3,4]\n# Output: {1: 4, 2: 3, 3: 3, 4: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Example 5:\n# Input: [1,2,3,4,5,6,7,8,9]\n# Output: {1: 9, 2: 8, 3: 7, 4: 6, 5: 5, 6: 4, 7: 3, 8: 2, 9: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Example 6:\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: {1: 9, 2: 8, 3: 7, 4: 6, 5: 5, 6: 4, 7: 3, 8: 2, 9: 1, 10: 1}\n# Explanation: 1 is the first number and 2 and 3 are the second numbers.\n# Note:\n# 1 <= nums.length <= 10000\n# 1 <= nums[i] <= 10000\n# All elements of nums are",
      -3.955078125
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple-frequency\n\ndef unique_tuples(A):\n    \"\"\"\n    :type A: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Find the number of unique tuples\n    unique_tuples = 0\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if A[i] == A[j]:\n                unique_tuples += 1\n    return unique_tuples\n\n# Test Cases\n\n# A = [1, 1, 2, 2, 2, 3]\n# B = [1, 2, 3]\n# C = [1, 2, 3, 3, 3, 3]\n# A = [1, 2, 3]\n# B = [1, 2, 3]\n# C = [1, 2, 3, 3, 3, 3]\n\nA = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nB = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nC = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(unique_tuples(A))\n#>>> 3\n\nprint(unique_tuples(B))\n#>>> 3\n\nprint(unique_tuples(C))\n#>>> 4",
      -4.30859375
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport collections\n\nclass Solution:\n    # @param nums: a list of integer\n    # @return: an integer\n    def uniqueTupleFrequencies(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        t = collections.defaultdict(int)\n        for n in nums:\n            t[n] += 1\n\n        return sorted(t.items(), key=lambda x: x[1], reverse=True)\n\n\nif __name__ == '__main__':\n    so = Solution()\n    nums = [1,2,3,1,2,3,3,2,2,2]\n    print so.uniqueTupleFrequencies(nums)",
      -4.42578125
    ],
    [
      "#!/usr/bin/env python\n\ndef unique_tuples(nums):\n    # write your code here\n    d = dict()\n    for i in nums:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n    return dict(d)\n\nif __name__ == \"__main__\":\n    nums = [1,1,2,2,2,3,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7",
      -4.48046875
    ],
    [
      "def extract_frequency(numbers):\n    '''\n    numbers = [1,2,1,3,3,2,1,4,1,3,2,4,4,3,4,2,3,4,1,2,1,3,2,1,1,1,3,1,2,3,1,2,4,2,1,2,2,1,3,2,3,4,2,3,2,2,2,1,1,3,2,1,3,1,1,2,3,1,1,2,2,2,2,2,3,4,1,1,1,1,2,1,2,1,2,1,3,1,3,1,2,3,2,1,2,3,1,2,3,2,3,2,2,1,2,1,1,2,2,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",
      -4.890625
    ],
    [
      "from collections import defaultdict\n\ndef unique_tuples(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    unique_tuples = defaultdict(int)\n    for number in numbers:\n        unique_tuples[number] += 1\n    return [number for number, count in unique_tuples.items() if count == 1]\n\nclass Solution:\n    \"\"\"\n    @param: numbers: an array of integers\n    @return: an array of integers\n    \"\"\"\n    def uniqueTuple(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [t for t in unique_tuples(nums)]\n\nif __name__ == \"__main__\":\n    assert Solution().uniqueTuple([1, 2, 3, 4, 4]) == [1, 2, 3, 4]\n    assert Solution().uniqueTuple([1, 2, 2, 3]) == [1, 2, 3]\n    assert Solution().uniqueTuple([1, 1, 2, 2, 3, 3, 3, 4]) == [1, 2, 3, 4]",
      -5.21875
    ],
    [
      "def extract_frequency(my_list):\n    # write your code here\n    f_dict = {}\n    for x in my_list:\n        if x not in f_dict:\n            f_dict[x] = 1\n        else:\n            f_dict[x] += 1\n    return f_dict.values()\n\nif __name__ == \"__main__\":\n    assert(extract_frequency([1,1,2,3,4,5,6,7,1,2,3,1,1]) == [1, 2, 3, 1, 1, 1, 1, 1])\n    assert(extract_frequency([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,",
      -5.26953125
    ],
    [
      "import numpy as np\n\n\ndef unique_tuples(inp):\n    \"\"\"\n    Input:\n    inp (list) - input list\n    Output:\n    freq (numpy array) - frequency of unique tuples\n    \"\"\"\n    freq = np.zeros(len(inp))\n    for i in range(len(inp)):\n        freq[i] = np.sum(inp[0:i] == inp[i:])\n    return freq\n\n\ndef unique_tuples_2(inp):\n    \"\"\"\n    Input:\n    inp (list) - input list\n    Output:\n    freq (numpy array) - frequency of unique tuples\n    \"\"\"\n    freq = np.zeros(len(inp))\n    for i in range(len(inp)):\n        freq[i] = np.sum(inp[0:i] == inp[i:])\n    return freq\n\n\nif __name__ == \"__main__\":\n    inp = [1, 1, 1, 2, 2, 3, 4, 4, 5, 6, 7, 8]\n    print(unique_tuples(inp))\n    print(unique_tuples_2(inp))",
      -5.5390625
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple-frequency/problem\n\ndef unique_tuple_frequency(arr):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list order\n    :type arr: List[List[int]]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in arr:\n        count += len(set(i))\n    return count\n\n\nif __name__ == '__main__':\n    arr = [ [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 6], [1, 3, 4], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [1, 5, 6], [2, 3, 4], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6], [2, 5, 6], [3, 4, 5], [3, 4, 6], [3, 5, 6], [4, 5, 6] ]\n    print(unique_tuple_frequency(arr))",
      -5.6484375
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple-frequency\n\nimport collections\nimport sys\n\n\ndef unique_tuple_frequency(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    uniq_tuples = collections.defaultdict(int)\n    for t in lst:\n        uniq_tuples[t] += 1\n\n    return uniq_tuples.items()\n\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5, 1, 2, 3]\n    lst = [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,",
      -6.05078125
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuple/problem\n\ndef find_frequency(lst, i, j):\n    if i >= j:\n        return 0\n    count = 0\n    for index in range(i, j):\n        if lst[index] == lst[i]:\n            count += 1\n    return count\n\ndef unique_tuple(lst):\n    count = 0\n    for i in range(1, len(lst)):\n        count += find_frequency(lst, i, len(lst) - 1)\n    return count\n\nif __name__ == \"__main__\":\n    lst = [1, 1, 1, 2, 2, 3]\n    print(unique_tuple(lst))",
      -6.07421875
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples/problem\n\ndef unique_tuples(arr):\n    if not arr:\n        return 0\n    unique = []\n    for i in arr:\n        if i not in unique:\n            unique.append(i)\n    return len(unique)\n\n# This solution has a bug in it where if you have a list of integers\n# in the form (1,2,3), then the function will return 3.\n# I'm not sure if this is the correct solution, but I'm sure it's wrong.\n# If you have a list of integers in the form (1,2,3,4), then the function\n# will return 4.\n# So, the correct solution is to take the list and sort it, then take the\n# unique elements, then return the number of unique elements.\n\ndef unique_tuples2(arr):\n    if not arr:\n        return 0\n    unique = []\n    for i in arr:\n        if i not in unique:\n            unique.append(i)\n    return len(unique)\n\ndef main():\n    t = int(input())\n    arr = []\n    for i in range(t):\n        arr.append(input())\n    print(unique_tuples(arr))\n    print(unique_tuples2(arr))\n\nif __name__ == \"__main__\":\n    main()",
      -6.140625
    ],
    [
      "# https://leetcode.com/problems/unique-tuples/\n\n\n# https://leetcode.com/problems/unique-tuples/discuss/106578/Java-Python-Solution\nclass Solution(object):\n    def uniqueTuple(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        i = 0\n        result = 1\n        while i < len(nums):\n            if nums[i] == nums[i+1]:\n                i += 1\n            else:\n                result += 1\n        return result\n\n\n# https://leetcode.com/problems/unique-tuples/discuss/106578/Java-Python-Solution\nclass Solution2(object):\n    def uniqueTuple(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        result = 1\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i+1]:\n                continue\n            else:\n                result += 1\n        return result\n\n\nif __name__ == \"__main__\":\n    assert Solution().uniqueTuple([1, 1, 1]) == 3\n    assert Solution().uniqueTuple([1, 2, 3]) == 3\n    assert Solution().uniqueTuple([1, 2, 3, 1]) == 4\n    assert Solution().uniqueTuple([1, 2, 3, 1, 2]) == 5\n    assert Solution().uniqueTuple([1, 2, 3, 4, 5]) == 6\n    assert Solution().uniqueTuple([1, 1, 1, 1, 1]) == 2\n    assert Solution().uniqueTuple([1, 2, 3, 4, 5, 6]) == 7\n    assert Solution().uniqueTuple([1, 1, 1, 1, 1, 1]) == 2",
      -6.20703125
    ],
    [
      "# -*- coding: utf-8 -*-\n\n\"\"\"\nCopyright 2016 Walter Doekes, w.doekes@rwth-aachen.de\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\"\"\"\n\n\ndef unique_tuples(lst):\n    \"\"\"\n    Returns a list of unique tuples from a list.\n    \"\"\"\n    return sorted(set(lst))\n\n\ndef find_frequency(lst):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list order.\n    \"\"\"\n    return len(unique_tuples(lst))\n\n\ndef find_frequency_2(lst):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list order.\n    \"\"\"\n    return sum(1 for _ in lst)\n\n\ndef main():\n    \"\"\"\n    Test cases:\n        [1, 2, 2, 3, 4, 5, 6, 7, 7, 8, 8, 8, 9]\n        [1, 2, 2, 3, 4, 5, 6, 7, 7, 8, 9, 9]\n        [1, 2, 2, 3, 4, 5, 6, 7, 7, 8, 9, 9]\n        [1, 2, 3, 3, 4, 5, 6, 7, 7, 8, 9, 9]\n        [1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9]\n        [1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 9,",
      -6.265625
    ],
    [
      "def frequency_of_unique_tuples(list_order):\n\t\"\"\"\n\tInput: A list of integers.\n\tOutput: A list of frequencies of unique tuples.\n\t\"\"\"\n\t\n\tfreq_list = []\n\tfor i in range(len(list_order)):\n\t\tfreq_list.append(1)\n\t\n\tfor i in range(len(list_order)):\n\t\tfor j in range(i+1, len(list_order)):\n\t\t\tif list_order[i] == list_order[j]:\n\t\t\t\tfreq_list[i] += 1\n\treturn freq_list\n\t\n\ndef test_frequency_of_unique_tuples():\n\tassert frequency_of_unique_tuples([1,2,1,3,2,3,2,2]) == [1,3,2]\n\nif __name__ == \"__main__\":\n\ttest_frequency_of_unique_tuples()",
      -6.37109375
    ],
    [
      "def unique_tuples(nums):\n    # Write your code here\n    lst = sorted(nums)\n    dic = {}\n    for i in lst:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    return len(dic.keys())\n\n\n# https://www.hackerrank.com/challenges/unique-tuples/problem\n# Python 3.5\n# Time:  O(nlogn)\n# Space: O(n)\n# Hash table, DP\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash table\n# Hash",
      -6.39453125
    ],
    [
      "# Example 1:\n# Input: [1,2,3,1,2,3,3,2,3,4,1,2,3]\n# Output: [1,3,3,2,2,2,1,1,4]\n# Note:\n# The order of input list is unique.\n\n# Example 2:\n# Input: [1,2,1,1,2,2,1,1]\n# Output: [1,1,1,2,2,2]\n# Note:\n# The order of input list is not unique.\n\n# Example 3:\n# Input: [1,2,3,4,1,2,3,4]\n# Output: [1,1,1,1,2,2,2,2]\n\n\nclass Solution(object):\n    def uniqueMorseRepresentations(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not words:\n            return []\n        result = []\n        for word in words:\n            result.append(self.uniqueMorse(word))\n        return result\n\n    def uniqueMorse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: str\n        \"\"\"\n        morse = \"\"\n        for c in word:\n            morse += \".\" + c\n        morse = morse[1:]\n        morse = morse.upper()\n        if len(morse) == 1:\n            return morse\n        if len(morse) == 2:\n            return \"\".join([\".\" + c for c in morse])\n        result = \"\"\n        for i in range(len(morse)):\n            result += \".\" + morse[i]\n        return result",
      -6.9296875
    ],
    [
      "import math\n\ndef find_frequency(list_of_tuples):\n    \"\"\"\n    Input: list of tuples\n    Output: a list of tuples\n    \"\"\"\n    freq = {}\n    for t in list_of_tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n    return freq\n\n\ndef find_frequency_recursive(list_of_tuples):\n    \"\"\"\n    Input: list of tuples\n    Output: a list of tuples\n    \"\"\"\n    freq = {}\n    for t in list_of_tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n        freq = find_frequency_recursive(freq)\n    return freq\n\n\ndef find_frequency_iterative(list_of_tuples):\n    \"\"\"\n    Input: list of tuples\n    Output: a list of tuples\n    \"\"\"\n    freq = {}\n    for t in list_of_tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n    return find_frequency_iterative(freq)\n\n\ndef find_frequency_recursive_iterative(list_of_tuples):\n    \"\"\"\n    Input: list of tuples\n    Output: a list of tuples\n    \"\"\"\n    freq = {}\n    for t in list_of_tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n        freq = find_frequency_recursive_iterative(freq)\n    return freq\n\n\ndef find_frequency_recursive_iterative_2(list_of_tuples):\n    \"\"\"\n    Input: list of tuples\n    Output: a list of tuples\n    \"\"\"\n    freq = {}\n    for t in list_of_tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t]",
      -7.09375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __eq__(self, other):\n        return self.x == other.x\n\nclass Solution(object):\n    def uniqueTupleFrequencies(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        # sort by the frequency\n        nums.sort(key=lambda x: x[1], reverse=True)\n\n        # store the frequency of each tuple\n        freq = [0] * len(nums)\n        freq[0] = nums[0][1]\n        for i in range(1, len(nums)):\n            if nums[i][0]!= nums[i - 1][0]:\n                freq[i] = nums[i][1]\n                freq[i - 1] = nums[i - 1][1]\n        # return the frequency of each tuple\n        return [nums[i] for i in range(len(nums)) if freq[i] == freq[i - 1]]\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def uniqueTupleFrequencies(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        # sort by the frequency\n        nums.sort(key=lambda x: x[1], reverse=True)\n\n        # store the frequency of each tuple\n        freq = [0] * len(nums)\n        freq[0] = nums[0][1]\n        for i in range(1, len(nums)):\n            if nums[i][0]!= nums[i - 1][0]:\n                freq[i] = nums[i][1]\n                freq[i - 1] = nums[i - 1][1]\n        # return the frequency of each tuple\n        return [nums[i] for i in range(len(nums",
      -7.27734375
    ],
    [
      "# https://www.hackerrank.com/challenges/unique-tuples/problem\n\nfrom collections import Counter\n\ndef unique_tuples(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    \n    # find the frequency of each element in the list\n    freq = Counter(arr)\n    \n    # find the number of unique elements\n    num_unique = 0\n    for key in freq.keys():\n        if freq[key] == 1:\n            num_unique += 1\n    \n    return num_unique\n\nif __name__ == \"__main__\":\n    arr = [1, 1, 1, 2, 2, 2, 3, 3]\n    print unique_tuples(arr)",
      -7.55078125
    ],
    [
      "# TODO\n# Given a list of unique tuples, you can extract the frequency of unique tuples.\n# Example\n# Given [1,2,3], return {1:3, 2:2, 3:1}\n# Solution\n# HashMap\n# O(n) time\n# O(1) space\n\n# Your output should be sorted by frequency of tuples.\n# Example\n# Given [1,2,3,3,2,1], return {1:3, 2:5, 3:2}\n# Solution\n# HashMap\n# O(n) time\n# O(1) space\n\n# The idea is to keep a hashmap which contains the frequency of each unique tuple.\n# Then we can get the frequency of a tuple by looking up the tuple in the hashmap.\n# If the tuple is not found in the hashmap, then we can add it to the hashmap and get the frequency.\n# If the tuple is found in the hashmap, then we can get the frequency by looking up the tuple in the hashmap.\n\nclass Solution(object):\n    def uniqueTuple(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: HashMap[List[int], int]\n        \"\"\"\n        if not nums:\n            return {}\n        ret = {}\n        for i in xrange(len(nums)):\n            if nums[i] not in ret:\n                ret[nums[i]] = 1\n            else:\n                ret[nums[i]] += 1\n        return ret\n\n\n# Test\n# nums = [1,2,3]\n# nums = [1,3,2]\n# nums = [1,2,1]\n# nums = [1,1]\n# nums = []\n# nums = [1]\n# nums = [1,3]\n# nums = [1,2,3,3,2,1]\n# nums = [1,2,3,3,2,1,1]\n# nums = [1,2,3,3,2,1,1,1]\n# nums = [1,2,3,3,2,1,1",
      -7.6328125
    ],
    [
      "import collections\nimport heapq\n\n\ndef unique_tuples(list_order):\n    \"\"\"\n    :type list_order: List[int]\n    :rtype: int\n    \"\"\"\n    unique_tuples = collections.defaultdict(int)\n    for i in range(len(list_order)):\n        unique_tuples[list_order[i]] += 1\n    return sum(unique_tuples.values())\n\n\ndef unique_tuples_heap(list_order):\n    \"\"\"\n    :type list_order: List[int]\n    :rtype: int\n    \"\"\"\n    # Create a priority queue with the largest element first\n    # Since heapq is a minimum heap, we can add a -1 value for the largest element\n    # and then add all the remaining elements in order to get the priority queue\n    # If we don't do this, then the largest element will be popped first\n    # and then the smallest element will be popped.\n    # The minimum heap is an array of length n+1 where the first element is the largest element\n    # and the last element is the smallest element\n    # The other elements are the smaller elements and the larger elements are the larger elements\n    # The index of the smallest element is n-1\n    # The index of the largest element is n\n    # The index of the smallest element is 0\n    # The index of the largest element is n-1\n    # So the priority queue is sorted in descending order of the largest element\n    # If we don't do this, the largest element will be popped first and then the smallest element will\n    # be popped.\n    # The minimum heap is a heap with n+1 elements where the first element is the largest element\n    # and the last element is the smallest element\n    # The other elements are the smaller elements and the larger elements are the larger elements\n    # The index of the smallest element is n-1\n    # The index of the largest element is n\n    # The index of the smallest element is 0\n    # The index of the largest element is n-1\n    # So the priority queue is sorted in ascending order of the largest element\n    # So the minimum heap is a heap with n elements where the first element is the smallest element\n    # and the last element is the largest element",
      -8.5
    ],
    [
      "# https://www.hackerearth.com/code-monk-solutions/algorithm/unique-tuples-in-a-list/\n# https://www.hackerearth.com/problem/algorithm/unique-tuples-in-a-list/\n\n# Example\n# [[1, 2, 3], [4, 5, 6], [3, 4, 5], [1, 2, 3], [4, 5, 6], [1, 2, 3]]\n\n# Input:\n# [[1, 2, 3], [4, 5, 6], [3, 4, 5], [1, 2, 3], [4, 5, 6], [1, 2, 3]]\n# Output:\n# [1, 3, 3, 2, 5, 2]\n# [1, 2, 3, 4, 5, 6, 3, 4, 5]\n# [1, 2, 3, 4, 5, 6]\n\n# Output\n# [1, 3, 3, 2, 5, 2]\n# [1, 2, 3, 4, 5, 6, 3, 4, 5]\n# [1, 2, 3, 4, 5, 6]\n\n\n# Example\n# Input:\n# [[1, 2, 3], [4, 5, 6], [3, 4, 5], [1, 2, 3], [4, 5, 6], [1, 2, 3]]\n# Output:\n# [1, 3, 3, 2, 5, 2]\n# [1, 2, 3, 4, 5, 6, 3, 4, 5]\n# [1, 2, 3, 4, 5, 6]\n\n# Output\n# [1, 3, 3, 2, 5, 2]\n# [1, 2, 3, 4, 5, 6, 3, 4, 5]\n# [1, 2, 3, 4, 5, 6]\n\n# Note\n# You are given an array of unique elements.\n# Input:\n# [[1, 2, 3], [4, 5, 6], [3, 4, 5], [1, 2, 3], [4, 5, 6], [1, 2, 3]]\n# Output:\n# [1, 3, 3, 2",
      -8.6328125
    ],
    [
      "import collections\nimport collections.abc\nimport math\n\ndef extract_frequency(list_order):\n    \"\"\"\n    :type list_order: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # count the frequency\n    frequency = collections.Counter(list_order)\n\n    # get the frequency of all unique tuples\n    return [frequency[i] for i in sorted(frequency.keys())]\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert extract_frequency([1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1]) == [1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1], \"1st example\"\n    assert extract_frequency([1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \"2nd example\"\n    assert extract_frequency([1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2",
      -8.875
    ],
    [
      "def unique_tuples(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    return len(tuples)\n\ndef unique_tuples_2(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    return 1 if len(tuples) == 1 else 0\n\ndef unique_tuples_3(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    return 1 if len(tuples) == 1 else 0 if len(tuples) == 2 else 1\n\n# time limit exceeded\ndef unique_tuples_4(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(tuples) == 1:\n        return 1\n    return 0 if len(tuples) == 2 else 1 if len(tuples) == 3 else 2\n\n# time limit exceeded\ndef unique_tuples_5(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(tuples) == 1:\n        return 1\n    return 0 if len(tuples) == 2 else 1 if len(tuples) == 3 else 2",
      -9.1796875
    ],
    [
      "# https://leetcode.com/problems/frequency-of-unique-tuples/discuss/161561/Java-Python-Dynamic-Programming-with-Python-Solution-1\n\n# https://leetcode.com/problems/frequency-of-unique-tuples/discuss/282956/Java-Python-Dynamic-Programming-with-Python-Solution-2\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __repr__(self):\n        return str(self.x)\n\n# DP\n# time: O(n^2)\n# space: O(n)\n# score: 40.10\nclass Solution(object):\n    def uniqueTuple(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n        return dp[0][n - 1]",
      -10.359375
    ],
    [
      "def unique_frequency(items):\n    \"\"\"\n    :type items: List[List[int]]\n    :rtype: int\n    \"\"\"\n    items = sorted(items, key=lambda x: x[0])\n    count = 1\n    for i in range(1, len(items)):\n        if items[i][0] == items[i - 1][0]:\n            count += 1\n        else:\n            count = 1\n    return count\n\n# Test Cases\n\ncases = [\n    ([[1, 1, 2, 3], [1, 2, 3, 4], [2, 4, 1, 3], [4, 3, 1, 2], [2, 1, 3, 4], [3, 2, 4, 1]], 2),\n    ([[1, 1, 2, 3], [1, 2, 3, 4], [2, 4, 1, 3], [4, 3, 1, 2], [2, 1, 3, 4], [3, 2, 4, 1]], 3),\n    ([[1, 1, 2, 3], [1, 2, 3, 4], [2, 4, 1, 3], [4, 3, 1, 2], [2, 1, 3, 4], [3, 2, 4, 1]], 1),\n    ([[1, 1, 2, 3], [1, 2, 3, 4], [2, 4, 1, 3], [4, 3, 1, 2], [2, 1, 3, 4], [3, 2, 4, 1]], 0),\n    ([[1, 1, 2, 3], [1, 2, 3, 4], [2, 4, 1, 3], [4, 3, 1, 2], [2, 1, 3, 4], [3, 2, 4, 1]], None),\n]\n\nfor case in cases:\n    actual = unique_frequency(case[0])\n    print(\"The frequency of unique tuples in the list is\", actual)\n    if actual == case[1]:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")",
      -11.7265625
    ],
    [
      "import collections\nimport unittest\n\n\nclass Solution(object):\n    def uniqueLetterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n        freqs = collections.Counter(digits)\n        res = []\n        for i in xrange(len(digits)):\n            for j in xrange(i + 1, len(digits)):\n                if freqs[digits[i]] == freqs[digits[j]]:\n                    res.append(''.join(digits[:i] + digits[j:]))\n                    freqs[digits[i]] -= freqs[digits[j]]\n                    freqs[digits[j]] = 0\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/unique-letter-combinations/solution/\n#\nApproach #1: Sort [2, 3, 2]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of digits\nSpace Complexity: O(n)\n\n# 2ms 96.98%\nclass Solution {\n    public List<String> uniqueLetterCombinations(String digits) {\n        if (digits == null || digits.length() == 0) return Collections.emptyList();\n        List<String> res = new ArrayList<>();\n        Arrays.sort(digits.toCharArray());\n        char[] temp = new char[digits.length()];\n        int[] freq = new int[26];\n        for (int i = 0; i < digits.length(); i++) {\n            temp[i] = digits.charAt(i);\n            freq[temp[i] - '0']++;\n        }\n        dfs(res, temp, freq, 0);\n        return res;\n    }\n\n    private void dfs(List<String> res, char[] temp,",
      -11.7578125
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n\n    def uniqueLetterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        return self.letterCombinations(digits, 0)\n\n    def letterCombinations(self, digits, index):\n        if index == len(digits):\n            return [''.join(map(str, i)) for i in self.letterCombinations(digits, 0)]\n\n        if index >= len(digits):\n            return []\n\n        return self.letterCombinations(digits, index + 1) + self.letterCombinations(digits, index + 1)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/unique-letter-combinations/solution/\n\nApproach #1: Brute Force [Accepted]\nComplexity Analysis\nTime Complexity: O(n * l * m), where n is the number of digits, l is the length of the digits, and m is the number of combinations.\nSpace Complexity: O(l * m)\n\n# 12ms 100%\nclass Solution {\n    public List<String> letterCombinations(String digits, int index) {\n        List<String> res = new ArrayList<String>();\n        if (digits == null || digits.length() == 0 || index >= digits.length()) return res;\n        if (index >= digits.length()) return res;\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = index; i < digits.length(); i++) {\n            sb.append(digits.charAt(i));\n            res.addAll(letterCombinations(digits, i + 1));\n        }\n        res.add(sb.toString());\n        return res;\n    }\n}\n\n# 12ms 100%\nclass Solution {\n    public List<String> letterCombinations(String digits, int index) {\n        List<String> res = new",
      -12.4296875
    ],
    [
      "from collections import Counter\n\ndef unique_tuples(lst):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list.\n    \"\"\"\n    # Create a dictionary to store the frequency of unique tuples.\n    unique_tuples_dict = {}\n\n    # Iterate through each item in the list.\n    for i in lst:\n        # Iterate through each item in the dictionary to check if it is already there.\n        for j in unique_tuples_dict:\n            # If the current item is already in the dictionary, then increment the frequency.\n            if i == j:\n                unique_tuples_dict[j] += 1\n            # If the current item is not in the dictionary, then add it to the dictionary.\n            else:\n                unique_tuples_dict[i] = 1\n\n    # Return the dictionary.\n    return unique_tuples_dict\n\n\ndef unique_tuples_1(lst):\n    \"\"\"\n    Returns the frequency of unique tuples in the given list.\n    \"\"\"\n    # Create a list to store the frequency of unique tuples.\n    unique_tuples_list = []\n\n    # Iterate through each item in the list.\n    for i in lst:\n        # Iterate through each item in the list to check if it is already there.\n        for j in unique_tuples_list:\n            # If the current item is already in the list, then increment the frequency.\n            if i == j:\n                unique_tuples_list[j] += 1\n            # If the current item is not in the list, then add it to the list.\n            else:\n                unique_tuples_list.append(i)\n\n    # Return the list.\n    return unique_tuples_list",
      -13.6328125
    ],
    [
      "def unique_tuples(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    num_unique = 1\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                num_unique += 1\n    return num_unique\n\n\ndef unique_tuples2(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    num_unique = 1\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                num_unique += 1\n                break\n    return num_unique\n\n\ndef unique_tuples3(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    num_unique = 1\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                num_unique += 1\n                break\n            elif tuples[i] > tuples[j]:\n                break\n    return num_unique\n\n\ndef unique_tuples4(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not tuples:\n        return 0\n\n    num_unique = 1\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                num_unique += 1\n                break\n            elif tuples[i] > tuples[j]:\n                break\n            elif tuples[j] > tuples[i]:\n                break\n    return num_",
      -13.890625
    ],
    [
      "# Example 1\n# Input: [1, 1, 2, 2, 2, 3]\n# Output: [1, 2, 3]\n\n# Example 2\n# Input: [1, 1, 2, 2, 2, 3, 3, 3]\n# Output: [1, 2, 3]\n\n# Example 3\n# Input: [1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5]\n# Output: [1, 2, 3, 4, 5]\n\n# Note:\n# The input list is a string containing only digits.\n# The length of the input list is in range [1, 500].\n# The length of each element in the input list is in range [1, 15].\n\n# Follow up:\n# What if the input list is sorted in ascending order?\n# What if the input list is sorted in descending order?\n# What if the input list is unsorted?\n\nimport collections\n\n\nclass Solution(object):\n    def extractUniq(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not A:\n            return []\n\n        # sort\n        A = sorted(A)\n\n        # count\n        cnt = collections.defaultdict(int)\n        for elem in A:\n            cnt[elem] += 1\n\n        # extract\n        ans = []\n        for i in range(len(A)):\n            if cnt[A[i]] == 1:\n                ans.append(A[i])\n\n        return ans\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.extractUniq([1, 1, 2, 2, 2, 3])\n    print s.extractUniq([1, 1, 2, 2, 2, 3, 3, 3])\n    print s.extractUniq([1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5])",
      -15.625
    ],
    [
      "# https://leetcode.com/problems/unique-tuples/\n# Given a sorted array, return the number of unique tuples.\n# For example,\n# Given [1, 1, 2], return 2.\n# The solution is very straight forward.\n\n\n# DP solution\ndef unique_tuples(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 0:\n        return 0\n    nums.sort()\n    dp = [0] * (len(nums) + 1)\n    for i in range(1, len(nums) + 1):\n        dp[i] = dp[i - 1] + nums[i - 1]\n    return dp[-1]\n\n\n# Recursive solution\ndef unique_tuples_rec(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 0:\n        return 0\n    return unique_tuples_rec(nums[1:], nums[0:]) + nums[0]\n\n# Recursive solution\ndef unique_tuples_rec(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 0:\n        return 0\n    return unique_tuples_rec(nums[1:], nums[0:]) + nums[0]\n\n\n# Iterative solution\ndef unique_tuples_iter(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    if n <= 1:\n        return n\n    # dp[i][0] = 0, dp[i][i] = 1\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + nums[i - 1]\n    return dp[-1]\n\n\n# Recursive solution",
      -15.8984375
    ],
    [
      "# Example\n# In [1]: import time\n# In [2]: data = [('a', 1), ('b', 2), ('c', 3), ('b', 2), ('b', 4), ('c', 3), ('a', 1), ('b', 4)]\n# In [3]: f = unique_frequency(data)\n# Out[3]: {'a': 1, 'b': 2, 'c': 3}\n# In [4]: time.sleep(1)\n# In [5]: f = unique_frequency(data)\n# Out[5]: {'a': 1, 'b': 4, 'c': 3}\n# In [6]: time.sleep(1)\n# In [7]: f = unique_frequency(data)\n# Out[7]: {'a': 1, 'b': 4, 'c': 3}\n\n# Credit: https://leetcode.com/problems/unique-frequency-in-an-unsorted-array/discuss/91486/Python-Code-Recursive-Solution-(Python-3.4-3)-10-lines\nclass Solution(object):\n    def uniqueFrequencies(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Map[str, int]\n        \"\"\"\n        nums.sort()\n        return self.uniqueFrequenciesRecursive(nums, 0, len(nums))\n\n    def uniqueFrequenciesRecursive(self, nums, start, end):\n        if start == end:\n            return {nums[start]: 1}\n        mid = (start + end) / 2\n        left, right = self.uniqueFrequenciesRecursive(nums, start, mid), self.uniqueFrequenciesRecursive(nums, mid + 1, end)\n        return {key: value for key, value in left.items() if value not in right.values()}\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3]\n    print(sol.uniqueFrequencies(nums))",
      -17.625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}