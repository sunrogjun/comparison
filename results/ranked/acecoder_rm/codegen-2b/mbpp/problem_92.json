{
  "problem": {
    "task_id": "MBPP/103",
    "prompt": "Write a function to find eulerian number a(n, m).",
    "canonical_solution": "def eulerian_num(n, m): \r\n\tif (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
    "test_list": [
      "assert eulerian_num(3, 1) == 4",
      "assert eulerian_num(4, 1) == 11",
      "assert eulerian_num(5, 3) == 26"
    ],
    "challenge_test_list": [],
    "problem_id": 92
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def eulerian_number(n, m):\n    if n == 1 or m == 1:\n        return 1\n    if n == m:\n        return 0\n    for i in range(2, n):\n        if n % i == 0 and m % i == 0:\n            return eulerian_number(i, n//i) + eulerian_number(m//i, n//i) + eulerian_number(n//i, m//i)\n\nprint(eulerian_number(6, 9))",
      1.5625
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    Write a function to find eulerian number a(n, m).\n    \"\"\"\n    # DP solution\n    if m > n:\n        return 0\n    dp = [1] * (m + 1)\n    for i in range(n, m + 1):\n        dp[i] = 0\n        for j in range(i - 1, 0, -1):\n            if dp[j] == 1:\n                dp[i] += 1\n                break\n    return dp[m]\n\n\nclass Solution(object):\n    def eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        dp = [1] * (m + 1)\n        for i in range(n, m + 1):\n            dp[i] = 0\n            for j in range(i - 1, 0, -1):\n                if dp[j] == 1:\n                    dp[i] += 1\n                    break\n        return dp[m]",
      0.90869140625
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    For n points, m lines, and a total of n*m edges, if\n    there are no paths between any two points, there is a\n    path from the first point to the last point.\n    Return the number of paths that exist.\n    \"\"\"\n    if n == 0 or m == 0:\n        return 0\n    return n*(n-1)//2 + m*(m-1)//2",
      0.74560546875
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    For a given n and m, calculate the eulerian number.\n    The eulerian number is the number of triangles that can be formed\n    from n vertices.\n    \"\"\"\n    if n == 1:\n        return 1\n    elif m == 1:\n        return n\n    elif n < m:\n        return eulerian_number(n, m - 1)\n    else:\n        return eulerian_number(n - 1, m) + eulerian_number(n, m - 1)\n\nif __name__ == \"__main__\":\n    print(eulerian_number(7, 3))\n    print(eulerian_number(7, 5))\n    print(eulerian_number(7, 7))",
      0.51708984375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 1:\n        return m\n    elif m == 1:\n        return n\n    else:\n        return eulerian_number(n-1, m-1) + eulerian_number(n-1, m)\n\nif __name__ == '__main__':\n    print eulerian_number(1, 2)\n    print eulerian_number(3, 4)",
      -0.74951171875
    ],
    [
      "import collections\nimport itertools\n\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    paths = collections.Counter()\n    for i in range(n):\n        paths[(i, m)] = 0\n    for i in range(2, n):\n        for j in range(m):\n            if not i % (j + 1):\n                paths[(i, j)] += paths[(i - 1, j)]\n    return sum(paths.values())\n\n# TESTS\nfor n, m, expected in [\n    (5, 5, 11),\n    (5, 6, 12),\n    (5, 7, 15),\n]:\n    assert eulerian(n, m) == expected",
      -0.78173828125
    ],
    [
      "# https://www.youtube.com/watch?v=ZdvKWwM4L4Y\ndef eulerian(n, m):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return eulerian(n - 1, m) + eulerian(n - 1, m - 1)\n\nprint(eulerian(7, 4))",
      -0.85595703125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n < m:\n        return 0\n    if n == m:\n        return 1\n    return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nif __name__ == '__main__':\n    print(eulerian_number(4, 3))",
      -0.85595703125
    ],
    [
      "from eulerian_number import is_eulerian\n\ndef eulerian_number(n, m):\n    \"\"\"\n    Find eulerian number a(n, m)\n\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if not is_eulerian(n, m):\n        return 0\n    return sum([max(m - 1, n - 1), min(m, n)])\n\nif __name__ == \"__main__\":\n    print(eulerian_number(3, 4))",
      -0.85595703125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0 and m == 0:\n        return 1\n    if n == 0 or m == 0:\n        return 0\n    return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)",
      -0.85693359375
    ],
    [
      "def eulerian_number(n, m):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == m:\n        return 1\n    else:\n        return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nif __name__ == '__main__':\n    print eulerian_number(5, 2)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def eulerianPath(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return m\n        if m == 1:\n            return n\n        if n == m:\n            return 2\n        for i in range(1, n):\n            if i == n - 1:\n                if n % i!= 0:\n                    continue\n            if m == n - i:\n                return i\n            if m % n!= 0:\n                continue\n            if m == n - i and i == 1:\n                return n\n            if n % i!= 0:\n                continue\n            if n % i == 0:\n                return i\n        return n\n\nif __name__ == \"__main__\":\n    print Solution().eulerianPath(4, 2)",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def eulerianPath(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # write your code here\n        dp = [0] * (m+1)\n        dp[0] = 1\n        for i in xrange(1, m+1):\n            dp[i] = 1\n            for j in xrange(1, n+1):\n                if i+j < m+1:\n                    dp[i+j] = dp[i] + dp[i+j-1]\n                else:\n                    dp[i+j] = dp[i]\n        return dp[m]\n\ns = Solution()\nprint s.eulerianPath(3, 5)",
      -0.85791015625
    ],
    [
      "def euler_number(n, m):\n    # Write your code here\n    a = 0\n    for i in range(n):\n        if i > m:\n            break\n        a += 1\n        for j in range(i):\n            if i + j >= m:\n                break\n            a += 1\n    return a\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    print(euler_number(n, m))",
      -0.85791015625
    ],
    [
      "def euler_number(n, m):\n    \"\"\"\n    n is the number of vertices, and m is the number of edges.\n\n    The eulerian number is the number of connected components in a graph.\n    A graph is connected if and only if every vertex is reachable by at least\n    one edge.\n    \"\"\"\n    if m == 0:\n        return n\n    if n == 1:\n        return 0\n    return sum(euler_number(n - 1, m) + euler_number(n - 1, m - 1))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    m = int(input())\n    print(euler_number(n, m))",
      -0.85791015625
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return sum(1 for _ in range(n) if not m or not m % (n - 1))\n\n\ndef test_eulerian_number():\n    assert eulerian_number(3, 7) == 0\n    assert eulerian_number(10, 13) == 1\n    assert eulerian_number(9, 10) == 0\n    assert eulerian_number(100, 13) == 1\n    assert eulerian_number(100, 100) == 2\n    assert eulerian_number(100, 1000) == 0\n\n\nif __name__ == '__main__':\n    test_eulerian_number()",
      -0.85791015625
    ],
    [
      "def eulerian_number(n, m):\n    if n == 1:\n        return 1\n    if n == 2:\n        return m == 1 and 1 or m == 2 and 2\n    for i in range(2, n):\n        if not i % 2:\n            if m == 1:\n                return 2\n            elif m == 2:\n                return 3\n        else:\n            if m == 1:\n                return 4\n            elif m == 2:\n                return 5\n            else:\n                return 6\n\nprint eulerian_number(7, 4)",
      -0.85791015625
    ],
    [
      "from collections import defaultdict\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    The number of connected components in the given graph.\n\n    :param n: number of vertices\n    :param m: number of edges\n    :return: number of connected components in the given graph\n    \"\"\"\n    if m == 0:\n        return 1\n    elif m == 1:\n        return n\n    elif m == 2:\n        return n * (n - 1) / 2\n    else:\n        # Initialize a dictionary to keep track of connected components\n        graph = defaultdict(int)\n        graph[(0, 0)] = 1\n        for i in range(1, n):\n            for j in range(1, m):\n                graph[(i, j)] = graph[(i - 1, j)] + graph[(i, j - 1)]\n        return sum(graph.values())",
      -0.85791015625
    ],
    [
      "import collections\nimport itertools\n\nclass Solution:\n    def eulerianPath(self, n: int, m: int) -> int:\n        def dfs(v, m, path, visited):\n            if v == m:\n                return path\n            for w in itertools.combinations(range(v, m), r):\n                if w not in visited:\n                    visited.add(w)\n                    path.append(w)\n                    dfs(w, m, path, visited)\n                    visited.remove(w)\n        visited = set()\n        path = []\n        res = 0\n        for v in range(1, n+1):\n            if v not in visited:\n                dfs(v, m, path, visited)\n        return len(path)",
      -0.8583984375
    ],
    [
      "def eulerian(n, m):\n    return sum(1 for i in range(1, n+1) if i%(m+1)==0 and i%(n-m+1)==0)\n\nprint(eulerian(8, 6))",
      -0.8583984375
    ],
    [
      "import math\n\ndef eulerian_number(n, m):\n    return (n*m)/math.sqrt(n*m)\n\nif __name__ == '__main__':\n    print eulerian_number(4, 4)",
      -0.8583984375
    ],
    [
      "from math import sqrt\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 0:\n        return 1 if n == 1 else 0\n    elif m == 1:\n        return n if n % 2 == 0 else 0\n    else:\n        return sum(eulerian_number(n, x) for x in range(2, m))\n\nif __name__ == '__main__':\n    assert eulerian_number(1, 2) == 1\n    assert eulerian_number(2, 1) == 1\n    assert eulerian_number(2, 2) == 2\n    assert eulerian_number(3, 2) == 4\n    assert eulerian_number(3, 3) == 6\n    assert eulerian_number(4, 2) == 8\n    assert eulerian_number(5, 3) == 15\n    assert eulerian_number(6, 3) == 24\n    assert eulerian_number(7, 3) == 42",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n    if n == 0 or m == 0 or n % 2 == 0 or m % 2 == 0:\n        return 0\n\n    if m == 1:\n        return n\n\n    res = 0\n    for i in range(1, m):\n        res += eulerian_number(n, i) * eulerian_number(n, m - i)\n    return res\n\ndef test_eulerian_number():\n    assert eulerian_number(3, 1) == 0\n    assert eulerian_number(4, 2) == 1\n    assert eulerian_number(4, 3) == 2\n    assert eulerian_number(4, 4) == 3\n    assert eulerian_number(4, 5) == 5\n    assert eulerian_number(5, 4) == 8\n    assert eulerian_number(7, 3) == 30\n    assert eulerian_number(10, 3) == 36\n\nif __name__ == '__main__':\n    test_eulerian_number()",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    Input: n = length of a string, m = length of another string\n    Output: eulerian number\n    \"\"\"\n    if n > m:\n        return 0\n    if n == 0 or m == 0:\n        return 1\n    if n == 1 or m == 1:\n        return 0\n    if n == 2 or m == 2:\n        return 1\n    return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nprint(eulerian_number(10, 10))",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n    if m == 1:\n        return 1\n    elif m == 2:\n        return n\n    elif n == 1 or m == 2:\n        return 0\n    else:\n        return eulerian_number(n-1, m-1) + eulerian_number(n-1, m) - eulerian_number(n-2, m-1)\n\nif __name__ == '__main__':\n    assert(eulerian_number(4, 2) == 1)\n    assert(eulerian_number(4, 3) == 0)\n    assert(eulerian_number(4, 4) == 1)\n    assert(eulerian_number(4, 5) == 1)\n    assert(eulerian_number(4, 6) == 1)\n    assert(eulerian_number(4, 7) == 1)\n    assert(eulerian_number(4, 8) == 2)\n    assert(eulerian_number(4, 9) == 1)\n    assert(eulerian_number(4, 10) == 2)",
      -0.8583984375
    ],
    [
      "def eulerian(n, m):\n    if n == 1 or m == 1:\n        return 1\n    elif n == m:\n        return 0\n    elif n == m + 1:\n        return 1\n    elif n == m - 1:\n        return 1\n    elif n > m:\n        return eulerian(n - 1, m) + eulerian(n - 1, m - 1)\n    else:\n        return eulerian(n, m - 1) + eulerian(n - 1, m)\n\n#print eulerian(3, 2)\n#print eulerian(5, 3)\nprint eulerian(6, 4)",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n  if m == 0 or n == m:\n    return 1\n  else:\n    return eulerian_number(n, m - 1) + eulerian_number(n - 1, m)\n\nprint eulerian_number(1, 1)",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return sum(1 for i in range(1, n+1) if i % (n-m+1) == 0)",
      -0.8583984375
    ],
    [
      "def eulerian(n, m):\n    if n == 1 or m == 1:\n        return 1\n    elif n == 2:\n        return n\n    elif m == 2:\n        return n\n    elif n > m:\n        return eulerian(n - 1, m) + eulerian(n - 1, m - 1)\n    else:\n        return eulerian(n - 1, m) + eulerian(n - 1, m - 1)\n\n\nprint eulerian(7, 2)",
      -0.8583984375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    Write a function to find eulerian number a(n, m).\n    \"\"\"\n    return 0 if n == m == 1 else 1 + eulerian_number(n-1, m-1)\n\nif __name__ == '__main__':\n    n = int(input())\n    m = int(input())\n    print(eulerian_number(n, m))",
      -0.8583984375
    ],
    [
      "from math import ceil\n\n\ndef eulerian_number(n, m):\n    if n < m:\n        return 0\n    elif n == m:\n        return 1\n    elif n > m:\n        return 0\n    else:\n        return 1 + eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nif __name__ == \"__main__\":\n    print(eulerian_number(100, 100))",
      -0.8583984375
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    n is the number of vertices in a triangle, and m is the number of edges.\n\n    The eulerian number is the number of triangles that can be formed from a\n    triangle with all three vertices on one side.\n    \"\"\"\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == 0:\n        return 1\n    if n == 2 or m == 0:\n        return 2\n    if n == 3 or m == 0:\n        return 3\n    else:\n        return sum(eulerian(n-1, m-1) + eulerian(n-1, m) + eulerian(n-1, m+1))\n\nif __name__ == \"__main__\":\n    print(eulerian(4, 3))",
      -0.8583984375
    ],
    [
      "import sys\n\ndef eulerian(n, m):\n    if n < m:\n        return 0\n    elif n == m:\n        return 1\n    elif n > m:\n        return 0\n    elif n % m == 0:\n        return 1\n    else:\n        return eulerian(n, m - 1) + eulerian(n - m, m - 1)\n\nif __name__ == \"__main__\":\n    n = int(sys.argv[1])\n    m = int(sys.argv[2])\n    eulerian(n, m)",
      -0.85888671875
    ],
    [
      "# Definition for a directed graph.\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\ndef eulerian_path(G, u, v):\n    if u == v:\n        return True\n    if u in G.edges[v]:\n        return False\n    for w in G.edges[u]:\n        if eulerian_path(G, w, v):\n            return True\n    return False\n\ndef eulerian_number(n, m):\n    G = Graph(n)\n    for i in range(n):\n        for j in range(m):\n            G.add_edge(i, (i + 1) % n)\n    return len(set([eulerian_path(G, i, (i + 1) % n) for i in range(n)]))\n\n# v2\ndef eulerian_number_v2(n, m):\n    G = Graph(n)\n    for i in range(n):\n        for j in range(m):\n            G.add_edge(i, (i + 1) % n)\n    return len(set([eulerian_path(G, i, (i + 1) % n) for i in range(n)]))\n\nif __name__ == '__main__':\n    print eulerian_number_v2(4, 3)\n    print eulerian_number(4, 3)",
      -0.85888671875
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return sum(1 for i in range(1, n) if i not in range(m, n))\n\nif __name__ == '__main__':\n    assert eulerian(4, 4) == 0\n    assert eulerian(4, 6) == 2\n    assert eulerian(4, 7) == 3\n    assert eulerian(4, 8) == 4",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def eulerianPath(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        dp = [[0] * m for _ in range(n)]\n        for i in range(1, n):\n            for j in range(1, m):\n                if (i + j) % 2 == 0:\n                    dp[i][j] = dp[i - 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n - 1][m - 1]",
      -0.85888671875
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return sum(1 for _ in range(n) if is_eulerian(n, m))\n\ndef is_eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: bool\n    \"\"\"\n    return n == m or n == m + 1 and m == n + 1",
      -0.85888671875
    ],
    [
      "# Definition for an edge\nclass Edge:\n    def __init__(self, u, v, w):\n        self.u = u\n        self.v = v\n        self.w = w\n\nclass Solution(object):\n    def findEulerianPath(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if m < 3 or n < 3:\n            return False\n        res = 0\n        for i in xrange(m):\n            for j in xrange(n):\n                if not (i == j and (i == 0 or j == 0 or i == m-1 or j == n-1)):\n                    edge = Edge(i, j, 1)\n                    if not self.hasEdge(edge):\n                        self.addEdge(edge)\n                        res += 1\n        return res == m*n\n    \n    def hasEdge(self, edge):\n        for e in self.edges:\n            if e == edge:\n                return True\n        return False\n    \n    def addEdge(self, edge):\n        self.edges.append(edge)\n        \n    def hasCycle(self, vertex):\n        if vertex == 0:\n            return True\n        for e in self.edges:\n            if e.u == vertex and e.v == self.edges[-1].v:\n                return True\n            if e.v == vertex and e.u == self.edges[-1].u:\n                return True\n        return False",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def eulerianPath(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n <= 1 or m <= 1:\n            return 0\n        path = [[] for _ in range(m)]\n        for i in range(n-1):\n            if i % 2 == 0:\n                for j in range(m-1):\n                    path[j].append(i+1)\n            else:\n                for j in range(m):\n                    path[j].append(i+1)\n                for j in range(m-1):\n                    path[j].append(n-i-1)\n        return sum(1 for i in range(m) if path[i])\n\n\nif __name__ == '__main__':\n    print Solution().eulerianPath(3, 2)",
      -0.85888671875
    ],
    [
      "import math\ndef euler(n, m):\n    return math.factorial(n) / math.factorial(n - m)\n\nif __name__ == \"__main__\":\n    for n in range(1, int(math.sqrt(100)) + 1):\n        for m in range(2, int(math.sqrt(100)) + 1):\n            if euler(n, m) % 2 == 0:\n                print(n, m, euler(n, m))",
      -0.85888671875
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    else:\n        return eulerian_number(n - 1, m - 1) + eulerian_number(n - 1, m)\n\n\n# Your EulerianNumber object will be instantiated and called as such:\n# obj = EulerianNumber(n, m)\n# param_1 = obj.eulerian_number(n, m)",
      -0.85888671875
    ],
    [
      "def eulerian_number(n, m):\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == 1:\n        return 1\n    for i in range(1, n):\n        for j in range(1, m):\n            if n-i == m-j:\n                return 0\n    return 1\n\nprint eulerian_number(5, 4)",
      -0.85888671875
    ],
    [
      "import collections\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    Write a function to find eulerian number a(n, m).\n    :param n:\n    :param m:\n    :return:\n    \"\"\"\n    t = collections.defaultdict(int)\n    t[1] = 1\n    t[2] = 1\n    for i in range(3, n + 1):\n        for j in range(3, m + 1):\n            if i * j == n * m:\n                t[i * j] = t[i] + t[j]\n    return t[n * m]\n\n\nif __name__ == '__main__':\n    print(eulerian_number(3, 4))",
      -0.86669921875
    ],
    [
      "import itertools\nimport collections\n\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    elif n == m:\n        return 0\n    elif n > m:\n        return sum(eulerian(n - 1, m) for i in range(1, n))\n    else:\n        return sum(eulerian(n, m - 1) for i in range(1, m))\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    print(eulerian(n, m))",
      -0.990234375
    ],
    [
      "def eulerian(n, m):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if m == 0:\n        return 0\n    if m == 1:\n        return 1\n    if m == 2:\n        return 2\n    return eulerian(n - 1, m - 1) + eulerian(n - 1, m)\n\ndef test_eulerian():\n    assert eulerian(5, 0) == 1\n    assert eulerian(5, 1) == 2\n    assert eulerian(5, 2) == 4\n    assert eulerian(5, 3) == 8\n    assert eulerian(5, 4) == 16\n    assert eulerian(5, 5) == 32\n\nif __name__ == \"__main__\":\n    test_eulerian()",
      -1.2783203125
    ],
    [
      "class Solution(object):\n    def is_eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        # DP\n        # time: O(n*m)\n        # space: O(n)\n        if n < 2 or m < 2:\n            return False\n        dp = [False for i in range(n)]\n        dp[0] = True\n        for i in range(1, n):\n            for j in range(1, m):\n                if dp[i - 1] and dp[j]:\n                    dp[i] = True\n                    break\n        return all(dp)\n\n\nif __name__ == '__main__':\n    assert Solution().is_eulerian(3, 2) == True\n    assert Solution().is_eulerian(4, 2) == True\n    assert Solution().is_eulerian(5, 2) == False",
      -1.6142578125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 1:\n        return 1 if n == 1 else 0\n    if m == 2:\n        return 1 if n % 2 == 0 else 0\n    if n <= 1:\n        return 0\n    if m == 3:\n        return 1 if n % 3 == 0 else 0\n    if n <= 2:\n        return 0\n    if m == 4:\n        return 1 if n % 4 == 0 else 0\n    if n <= 3:\n        return 0\n    if m == 5:\n        return 1 if n % 5 == 0 else 0\n    if n <= 4:\n        return 0\n    if m == 6:\n        return 1 if n % 6 == 0 else 0\n    if n <= 5:\n        return 0\n    if m == 7:\n        return 1 if n % 7 == 0 else 0\n    if n <= 6:\n        return 0\n    if m == 8:\n        return 1 if n % 8 == 0 else 0\n    if n <= 7:\n        return 0\n    if m == 9:\n        return 1 if n % 9 == 0 else 0\n    if n <= 8:\n        return 0\n    if m == 10:\n        return 1 if n % 10 == 0 else 0\n    if n <= 9:\n        return 0\n    if m == 11:\n        return 1 if n % 11 == 0 else 0\n    if n <= 10:\n        return 0\n    if m == 12:\n        return 1 if n % 12 == 0 else 0\n    if n <= 11:\n        return 0\n    if m == 13:\n        return 1 if n % 13 == 0 else 0\n    if n <= 12:\n        return 0\n    if m == 14:\n        return 1 if n % 14 == 0 else 0\n    if n <= 13:\n        return 0\n    if m == 15:\n        return 1 if n % 15 == 0 else 0\n    if n <= 14:\n        return 0\n    if m == 16:\n        return 1 if n % 16 == 0 else 0\n    if n <= 15:\n        return 0\n    if m == 17",
      -1.9482421875
    ],
    [
      "from collections import Counter\nfrom itertools import product\nfrom operator import add\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n < m:\n        return 0\n    # if n == 1 or m == 1:\n    #     return 1\n    # if n == 2 or m == 2:\n    #     return 2\n    # if n == 3 or m == 3:\n    #     return 4\n    # if n == 4 or m == 4:\n    #     return 8\n    if n == m:\n        return 1\n    if n == 1:\n        return 0\n    if m == 1:\n        return 1\n    if n == m:\n        return 2\n    return eulerian_number(n - 1, m) + eulerian_number(n, m - 1)\n\n\ndef main():\n    \"\"\"\n    Use the eulerian number to count the number of paths of length m\n    from a starting point of n,\n    the number of paths of length m + 1 from a starting point of n + 1\n    and so on.\n    \"\"\"\n    n, m = map(int, input().split())\n    count = Counter()\n    for i in range(n, m + 1):\n        count[i] += eulerian_number(n, i)\n    print(sum(count.values()))\n\n\nif __name__ == '__main__':\n    main()",
      -1.9765625
    ],
    [
      "from collections import Counter\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    # http://en.wikipedia.org/wiki/Eulerian_path\n    if n > m:\n        return 0\n    elif n == m:\n        return 1\n    elif m == 0:\n        return n\n    elif n == 1:\n        return 1\n    else:\n        return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nif __name__ == '__main__':\n    assert eulerian_number(2, 3) == 3\n    assert eulerian_number(3, 3) == 4\n    assert eulerian_number(4, 3) == 6\n    assert eulerian_number(5, 3) == 10\n    assert eulerian_number(6, 3) == 12\n    assert eulerian_number(7, 3) == 15\n    assert eulerian_number(8, 3) == 18\n    assert eulerian_number(9, 3) == 21\n    assert eulerian_number(10, 3) == 24\n    assert eulerian_number(11, 3) == 27\n    assert eulerian_number(12, 3) == 30\n    assert eulerian_number(13, 3) == 33\n    assert eulerian_number(14, 3) == 36\n    assert eulerian_number(15, 3) == 39\n    assert eulerian_number(16, 3) == 42\n    assert eulerian_number(17, 3) == 45\n    assert eulerian_number(18, 3) == 48\n    assert eulerian_number(19, 3) == 51\n    assert eulerian_number(20, 3) == 54\n    assert eulerian_number(21, 3) == 57\n    assert eulerian_number(22, 3) == 60\n    assert eulerian_number(23, 3) == 63\n    assert eulerian_number(24, 3) == 66\n    assert eulerian_number(25,",
      -2.076171875
    ],
    [
      "import unittest\nimport math\n\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 0:\n        return 1\n    if m == 1:\n        return n\n    if n < m:\n        return 0\n    if n % m == 0:\n        return eulerian(n / m, m - 1)\n    else:\n        return eulerian(n, m - 1)\n\nclass Test(unittest.TestCase):\n    def test_eulerian(self):\n        self.assertEqual(eulerian(5, 2), 2)\n        self.assertEqual(eulerian(5, 3), 4)\n        self.assertEqual(eulerian(5, 4), 4)\n        self.assertEqual(eulerian(5, 5), 5)\n\nif __name__ == '__main__':\n    unittest.main()",
      -2.22265625
    ],
    [
      "class Solution:\n    # @param n, m, a list of integers\n    # @return an integer\n    def eulerianPath(self, n, m):\n        # write your code here\n        if n == 1:\n            return 1\n        if m == 0:\n            return 0\n        if n == m:\n            return 1\n        elif n == m + 1:\n            return 2\n        else:\n            return self.eulerianPath(n-1, m) + self.eulerianPath(n, m-1) + self.eulerianPath(n-1, m-1)",
      -2.248046875
    ],
    [
      "def is_eulerian(n, m):\n    \"\"\"\n    check if a n-edge cut is eulerian\n    \"\"\"\n    if m == 0:\n        return True\n    return sum(1 for i in range(1, n) if is_eulerian(i, m-1)) == m\n\ndef eulerian_number(n, m):\n    \"\"\"\n    return the eulerian number\n    \"\"\"\n    if m == 0:\n        return n\n    return sum(eulerian_number(i, m-1) for i in range(1, n))\n\nif __name__ == '__main__':\n    assert is_eulerian(4, 3) == True\n    assert is_eulerian(4, 4) == False\n    assert eulerian_number(4, 3) == 3",
      -2.509765625
    ],
    [
      "class Solution(object):\n    def is_eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n == 0:\n            return True\n        if n == 1:\n            return m == 1\n        if m == 1:\n            return True\n        if n == m:\n            return False\n        if n > m:\n            return self.is_eulerian(n-1, m) and self.is_eulerian(n-1, m-1)\n        else:\n            return self.is_eulerian(n, m-1) and self.is_eulerian(n-1, m)",
      -2.787109375
    ],
    [
      "def eulerian_number(n, m):\n    if m == 0:\n        return n\n    else:\n        return eulerian_number(n, m-1) + eulerian_number(n-1, m-1)\n\nif __name__ == \"__main__\":\n    assert eulerian_number(1,0) == 1\n    assert eulerian_number(1,1) == 1\n    assert eulerian_number(1,2) == 1\n    assert eulerian_number(2,0) == 2\n    assert eulerian_number(2,1) == 2\n    assert eulerian_number(2,2) == 2\n    assert eulerian_number(3,0) == 3\n    assert eulerian_number(3,1) == 3\n    assert eulerian_number(3,2) == 3\n    assert eulerian_number(4,0) == 4\n    assert eulerian_number(4,1) == 4\n    assert eulerian_number(4,2) == 4\n    assert eulerian_number(5,0) == 5\n    assert eulerian_number(5,1) == 5\n    assert eulerian_number(5,2) == 5\n    assert eulerian_number(6,0) == 6\n    assert eulerian_number(6,1) == 6\n    assert eulerian_number(6,2) == 6\n    assert eulerian_number(7,0) == 7\n    assert eulerian_number(7,1) == 7\n    assert eulerian_number(7,2) == 7\n    assert eulerian_number(8,0) == 8\n    assert eulerian_number(8,1) == 8\n    assert eulerian_number(8,2) == 8",
      -2.8515625
    ],
    [
      "class Solution:\n    # @return a boolean\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n < 2 or m < 2:\n            return False\n        elif n == 2:\n            return True\n        elif m == 2:\n            return True\n        else:\n            if n == m:\n                return True\n            elif n == m + 1:\n                return True\n            elif n - m == 1:\n                return True\n            else:\n                return False\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.isEulerian(4, 2))\n    print(sol.isEulerian(4, 3))\n    print(sol.isEulerian(6, 4))\n    print(sol.isEulerian(6, 5))\n    print(sol.isEulerian(6, 6))\n    print(sol.isEulerian(6, 7))",
      -2.861328125
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        if m == 1:\n            return 1\n        elif m == 2:\n            return 2\n        else:\n            if m == n % 2:\n                return 1\n            else:\n                return eulerian(n - 1, m) + eulerian(n - 1, m - 2)\n\nif __name__ == \"__main__\":\n    assert eulerian(3, 1) == 1\n    assert eulerian(3, 2) == 2\n    assert eulerian(3, 3) == 4\n    assert eulerian(4, 1) == 2\n    assert eulerian(4, 2) == 4\n    assert eulerian(4, 3) == 8\n    assert eulerian(4, 4) == 16\n    assert eulerian(5, 1) == 2\n    assert eulerian(5, 2) == 4\n    assert eulerian(5, 3) == 8\n    assert eulerian(5, 4) == 16\n    assert eulerian(5, 5) == 32",
      -3.033203125
    ],
    [
      "def eulerian(n, m):\n    if n == 0 and m == 0:\n        return 1\n    if n == 1 or m == 1:\n        return 0\n    if m == 0:\n        return eulerian(n - 1, 1)\n    if n == 1:\n        return eulerian(n - 1, 1)\n    if m == n - 1:\n        return eulerian(n - 2, 1)\n    return eulerian(n - 1, m - 1) + eulerian(n - 1, m) + eulerian(n - 1, m + 1)\n\nif __name__ == \"__main__\":\n    print eulerian(2, 3)\n    print eulerian(3, 2)\n    print eulerian(4, 3)\n    print eulerian(4, 4)\n    print eulerian(4, 5)\n    print eulerian(4, 6)\n    print eulerian(4, 7)\n    print eulerian(4, 8)\n    print eulerian(4, 9)",
      -3.1171875
    ],
    [
      "def eulerian_number(n, m):\n  \"\"\"\n  n: an integer\n  m: an integer\n  \"\"\"\n\n  if m == 0:\n    return 1\n  elif m == 1:\n    return n\n  elif m == 2:\n    return n % 2 == 0\n  elif m == 3:\n    return n % 3 == 0\n  elif m == 4:\n    return n % 4 == 0 and n % 12 == 0\n  elif m == 5:\n    return n % 5 == 0 and n % 10 == 0\n  elif m == 6:\n    return n % 6 == 0 and n % 3 == 0\n  elif m == 7:\n    return n % 7 == 0 and n % 4 == 0\n  elif m == 8:\n    return n % 8 == 0 and n % 5 == 0\n  elif m == 9:\n    return n % 9 == 0 and n % 7 == 0\n  elif m == 10:\n    return n % 10 == 0 and n % 6 == 0\n  elif m == 11:\n    return n % 11 == 0 and n % 8 == 0\n  else:\n    return False\n\nif __name__ == '__main__':\n  print(eulerian_number(3, 2))",
      -3.255859375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return n * (m - 1) / 2 + m * (m - 1) / 2 + n - m\n\nif __name__ == '__main__':\n    print(eulerian_number(1, 1))\n    print(eulerian_number(1, 2))\n    print(eulerian_number(2, 1))\n    print(eulerian_number(2, 2))\n    print(eulerian_number(3, 1))\n    print(eulerian_number(3, 2))\n    print(eulerian_number(4, 1))\n    print(eulerian_number(4, 2))\n    print(eulerian_number(5, 1))\n    print(eulerian_number(5, 2))\n    print(eulerian_number(6, 1))\n    print(eulerian_number(6, 2))\n    print(eulerian_number(7, 1))\n    print(eulerian_number(7, 2))\n    print(eulerian_number(8, 1))\n    print(eulerian_number(8, 2))\n    print(eulerian_number(9, 1))\n    print(eulerian_number(9, 2))\n    print(eulerian_number(10, 1))\n    print(eulerian_number(10, 2))\n    print(eulerian_number(100, 1))\n    print(eulerian_number(100, 2))\n    print(eulerian_number(1000, 1))\n    print(eulerian_number(1000, 2))\n    print(eulerian_number(10000, 1))\n    print(eulerian_number(10000, 2))\n    print(eulerian_number(100000, 1))\n    print(eulerian_number(100000, 2))\n    print(eulerian_number(1000000, 1))\n    print(eulerian_number(1000000, 2))\n    print(eulerian_number(1",
      -3.3203125
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0 and m == 0:\n        return 1\n    elif n == 0 or m == 0:\n        return 0\n    else:\n        return eulerian(n-1, m) + eulerian(n, m-1)\n\nclass Solution:\n    # @param {integer} n\n    # @param {integer} m\n    # @return {integer}\n    def eulerian(self, n, m):\n        # write your code here\n        if n == 0 or m == 0:\n            return 0\n        elif n == 1 and m == 1:\n            return 1\n        elif n == 1:\n            return m\n        elif m == 1:\n            return n\n        else:\n            return self.eulerian(n-1, m) + self.eulerian(n, m-1)\n\nif __name__ == '__main__':\n    n = int(input())\n    m = int(input())\n    print(Solution().eulerian(n, m))",
      -3.380859375
    ],
    [
      "def eulerian_number(n, m):\n    if n == 1 or m == 1:\n        return 1\n    if n % 2 == 0 and m % 2 == 0:\n        return eulerian_number(n / 2, m / 2) + 1\n    if n % 2 == 0 and m % 3 == 0:\n        return eulerian_number(n / 2, m / 3) + 1\n    if n % 3 == 0 and m % 2 == 0:\n        return eulerian_number(n / 3, m / 2) + 1\n    if n % 3 == 0 and m % 3 == 0:\n        return eulerian_number(n / 3, m / 3) + 1\n    if n % 2 == 0 and m % 5 == 0:\n        return eulerian_number(n / 2, m / 5) + 1\n    if n % 5 == 0 and m % 2 == 0:\n        return eulerian_number(n / 5, m / 2) + 1\n    if n % 5 == 0 and m % 3 == 0:\n        return eulerian_number(n / 5, m / 3) + 1\n    if n % 5 == 0 and m % 5 == 0:\n        return eulerian_number(n / 5, m / 5) + 1\n    return 0\n\n\n\nprint eulerian_number(1, 1)",
      -3.67578125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if m == 0:\n        return 0\n    if m == 1:\n        return 1\n    if m == 2:\n        return 2\n    if m == 3:\n        return 4\n    if m == 4:\n        return 8\n    if m == 5:\n        return 16\n    if m == 6:\n        return 32\n    if m == 7:\n        return 64\n    if m == 8:\n        return 128\n    if m == 9:\n        return 256\n    if m == 10:\n        return 512\n    if m == 11:\n        return 1024\n    if m == 12:\n        return 2048\n    if m == 13:\n        return 4096\n    if m == 14:\n        return 8192\n    if m == 15:\n        return 16384\n    if m == 16:\n        return 32768\n    if m == 17:\n        return 65536\n    if m == 18:\n        return 131072\n    if m == 19:\n        return 262144\n    if m == 20:\n        return 524288\n    if m == 21:\n        return 1048576\n    if m == 22:\n        return 2097152\n    if m == 23:\n        return 4194304\n    if m == 24:\n        return 8388608\n    if m == 25:\n        return 16777216\n    if m == 26:\n        return 33554432\n    if m == 27:\n        return 67108864\n    if m == 28:\n        return 134217728\n    if m == 29:\n        return 268435456\n    if m == 30:\n        return 536870912\n    if m == 31:\n        return 1073741824\n    if m == 32:\n        return 2147483648\n    if m == 33:\n        return 4294967296\n    if m == 34:\n        return 8589934592\n    if m == 35:\n        return 17179869184",
      -3.779296875
    ],
    [
      "def eulerian_number(n, m):\n    if n == 0:\n        return 1\n    if n == 1 or m == 0:\n        return 0\n    if n == m:\n        return 1\n    eul = 0\n    for i in range(1, m + 1):\n        eul += eulerian_number(n - 1, i)\n    return eul\n\nprint eulerian_number(3, 1)\nprint eulerian_number(3, 2)\nprint eulerian_number(3, 3)\nprint eulerian_number(3, 4)\nprint eulerian_number(3, 5)\nprint eulerian_number(3, 6)\nprint eulerian_number(3, 7)\nprint eulerian_number(3, 8)\nprint eulerian_number(3, 9)\nprint eulerian_number(3, 10)\nprint eulerian_number(3, 11)\nprint eulerian_number(3, 12)\nprint eulerian_number(3, 13)\nprint eulerian_number(3, 14)\nprint eulerian_number(3, 15)\nprint eulerian_number(3, 16)\nprint eulerian_number(3, 17)\nprint eulerian_number(3, 18)\nprint eulerian_number(3, 19)\nprint eulerian_number(3, 20)\nprint eulerian_number(3, 21)\nprint eulerian_number(3, 22)\nprint eulerian_number(3, 23)\nprint eulerian_number(3, 24)\nprint eulerian_number(3, 25)\nprint eulerian_number(3, 26)\nprint eulerian_number(3, 27)\nprint eulerian_number(3, 28)\nprint eulerian_number(3, 29)\nprint eulerian_number(3, 30)\nprint eulerian_number(3, 31)\nprint eulerian_number(3, 32)\nprint eulerian_number(3, 33)\nprint eulerian_number(3, 34)\nprint eulerian_number(3, 35)",
      -3.796875
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    # Complete this function\n    # n is the number of vertices, m is the number of edges\n    # We can assume that all edges are self-loops\n    # We can assume that the graph is connected\n    # We can assume that the graph is not a tree\n    # We can assume that the graph is not a forest\n    # We can assume that the graph is not a spanning tree\n    # We can assume that the graph is not a spanning forest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph is not a polytree\n    # We can assume that the graph is not a polyforest\n    # We can assume that the graph",
      -3.994140625
    ],
    [
      "import sys\n\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n < 2:\n        return 0\n    if m > n:\n        return 0\n    if n % 2 == 0:\n        return 0\n    if m == 1:\n        return 1\n    if n == 1:\n        return 1\n    if n == m:\n        return 2\n    if n < m:\n        return 0\n    return eulerian(n-1, m) + eulerian(n-1, m-1)\n\n# test cases\nfor n, m in [\n    (3, 1),\n    (3, 2),\n    (3, 3),\n    (4, 1),\n    (4, 2),\n    (4, 3),\n    (4, 4),\n    (5, 1),\n    (5, 2),\n    (5, 3),\n    (5, 4),\n    (5, 5),\n    (5, 6),\n    (6, 1),\n    (6, 2),\n    (6, 3),\n    (6, 4),\n    (6, 5),\n    (6, 6),\n    (7, 1),\n    (7, 2),\n    (7, 3),\n    (7, 4),\n    (7, 5),\n    (7, 6),\n    (7, 7),\n    (7, 8),\n    (7, 9),\n    (7, 10),\n    (8, 1),\n    (8, 2),\n    (8, 3),\n    (8, 4),\n    (8, 5),\n    (8, 6),\n    (8, 7),\n    (8, 8),\n    (8, 9),\n    (8, 10),\n    (9, 1),\n    (9, 2),\n    (9, 3),\n    (9, 4),\n    (9, 5),\n    (9, 6),\n    (9, 7),\n    (9, 8),\n    (9, 9),\n    (9, 10),\n    (10, 1),\n    (10,",
      -4.1171875
    ],
    [
      "class Solution:\n    # @param n, m: positive integer\n    # @return: a positive integer\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n < m:\n            return False\n        if n == m:\n            return True\n        if n == 1:\n            return False\n        if m == 1:\n            return True\n        if n % 2 == 0 and m % 2 == 0:\n            return self.isEulerian(n/2, m/2)\n        if n % 2 == 0 and m % 2 == 1:\n            return self.isEulerian(n/2, m/2+1)\n        if n % 2 == 1 and m % 2 == 0:\n            return self.isEulerian(n/2+1, m/2)\n        if n % 2 == 1 and m % 2 == 1:\n            return self.isEulerian(n/2+1, m/2+1)\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().isEulerian(7, 1)\n    print Solution().isEulerian(7, 2)\n    print Solution().isEulerian(7, 3)\n    print Solution().isEulerian(7, 4)\n    print Solution().isEulerian(7, 5)\n    print Solution().isEulerian(7, 6)\n    print Solution().isEulerian(7, 7)\n    print Solution().isEulerian(7, 8)\n    print Solution().isEulerian(7, 9)\n    print Solution().isEulerian(7, 10)",
      -4.1796875
    ],
    [
      "class Solution(object):\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n < 2 or m < 2:\n            return False\n        if n == 2 and m == 2:\n            return True\n        for i in range(1, n-1):\n            for j in range(1, m-1):\n                if self.isEulerian(n-i, m-j) and self.isEulerian(n-i, m-j+1):\n                    return True\n        return False\n\n# test\ns = Solution()\nprint s.isEulerian(5, 2)\nprint s.isEulerian(5, 3)\nprint s.isEulerian(5, 4)\nprint s.isEulerian(5, 5)\nprint s.isEulerian(5, 6)\nprint s.isEulerian(5, 7)\nprint s.isEulerian(5, 8)\nprint s.isEulerian(5, 9)\nprint s.isEulerian(5, 10)",
      -4.234375
    ],
    [
      "import collections\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 1:\n        return n\n    if m == 2:\n        return n % 2\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n % 2 == 0:\n        return eulerian_number(n//2, m//2)\n    else:\n        return eulerian_number(n-1, m) + eulerian_number(n-1, m-1)\n\n\nclass Solution:\n    def eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n % 2 == 0:\n            return self.eulerian(n//2, m//2)\n        else:\n            return self.eulerian(n-1, m) + self.eulerian(n-1, m-1)\n\n\nif __name__ == '__main__':\n    print(Solution().eulerian(n=2, m=2))\n    print(Solution().eulerian(n=2, m=3))\n    print(Solution().eulerian(n=2, m=4))",
      -4.3828125
    ],
    [
      "def eulerian_number(n, m):\n    if m == 0:\n        return n\n    else:\n        return eulerian_number(n, m - 1) + eulerian_number(n - 1, m)\n\ndef test():\n    assert eulerian_number(3, 3) == 2\n    assert eulerian_number(2, 4) == 2\n    assert eulerian_number(2, 0) == 1\n    assert eulerian_number(3, 0) == 1\n\nif __name__ == '__main__':\n    test()",
      -4.453125
    ],
    [
      "from collections import deque\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    paths = [set() for i in range(n)]\n    for i in range(n):\n        paths[i] = deque()\n\n    for i in range(m):\n        if len(paths) == n:\n            break\n        for j in range(n):\n            if i!= j and paths[j].count(i) == 0:\n                paths[i].append(j)\n\n    return sum(1 for _ in range(n))\n\n\nif __name__ == '__main__':\n    assert eulerian_number(4, 3) == 1\n    assert eulerian_number(4, 4) == 0\n    assert eulerian_number(3, 3) == 1\n    assert eulerian_number(5, 5) == 1\n    assert eulerian_number(2, 1) == 1",
      -4.57421875
    ],
    [
      "class Solution(object):\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n < 1 or m < 1 or n!= m:\n            return False\n\n        if n == 1:\n            return True\n\n        if n % 2 == 0:\n            return self.isEulerian(n / 2, m) and self.isEulerian(n / 2, m - 1)\n        else:\n            return not self.isEulerian(n - 1, m)\n\n\nif __name__ == '__main__':\n    assert Solution().isEulerian(6, 4)\n    assert Solution().isEulerian(6, 5)",
      -4.61328125
    ],
    [
      "class Solution(object):\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n == 1 or m == 1:\n            return True\n        if n == 2 or m == 2:\n            return True\n        if n == 3 or m == 3:\n            return True\n        if n <= 3 and m <= 3:\n            return True\n        if n > 3 and m > 3:\n            return False\n        if n % 2 == 0 and m % 2 == 0:\n            return self.isEulerian(n / 2, m / 2) and self.isEulerian(n / 2, m / 2 + 1)\n        if n % 2 == 0 and m % 2 == 1:\n            return self.isEulerian(n / 2, m / 2) and self.isEulerian(n / 2, m / 2 + 1)\n        if n % 2 == 1 and m % 2 == 0:\n            return self.isEulerian(n / 2 + 1, m / 2) and self.isEulerian(n / 2 + 1, m / 2 + 1)\n        if n % 2 == 1 and m % 2 == 1:\n            return self.isEulerian(n / 2 + 1, m / 2) and self.isEulerian(n / 2 + 1, m / 2 + 1)\n        return False\n\ns = Solution()\n\nprint s.isEulerian(8, 6)",
      -5.05859375
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if m == 0:\n        return 1\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if m == 1:\n        return 2\n    if n == 3:\n        return 6\n    if m == 2:\n        return 6\n    if n == 4:\n        return 24\n    if m == 3:\n        return 24\n    if n == 5:\n        return 120\n    if m == 4:\n        return 120\n    if n == 6:\n        return 720\n    if m == 5:\n        return 720\n    if n == 7:\n        return 5040\n    if m == 6:\n        return 5040\n    if n == 8:\n        return 40320\n    if m == 7:\n        return 40320\n    if n == 9:\n        return 362880\n    if m == 8:\n        return 362880\n    if n == 10:\n        return 3628800\n    if m == 9:\n        return 39916800\n    if n == 11:\n        return 479001600\n    if m == 10:\n        return 479001600\n    if n == 12:\n        return 6227020800\n    if m == 11:\n        return 6227020800\n    if n == 13:\n        return 87178291200\n    if m == 12:\n        return 87178291200\n    if n == 14:\n        return 1307674368000\n    if m == 13:\n        return 1307674368000\n    if n == 15:\n        return 18014398509120\n    if m == 14:\n        return 18014398509120\n    if n == 16:\n        return 36028797018963968\n    if m == 15:\n        return 36028797018963968\n    if n == 17:\n        return 72057594037927936\n    if m == 16:\n        return 72057594037927936\n    if n == 18:\n        return 144115188075855872\n    if m == 17:",
      -5.3984375
    ],
    [
      "def euler_number(n, m):\n    if n < m:\n        return 0\n    elif m == 1:\n        return 1\n    elif m == 2:\n        return n\n    elif m == 3:\n        return n * (n - 1) / 2\n    elif m == 4:\n        return n * (n - 1) * (n - 2) / 6\n    else:\n        return euler_number(n - 1, m - 1) + euler_number(n - 1, m)\n\ndef main():\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert euler_number(2, 1) == 1, \"2 is an eulerian number\"\n    assert euler_number(4, 1) == 1, \"4 is an eulerian number\"\n    assert euler_number(3, 2) == 3, \"3 is an eulerian number\"\n    assert euler_number(3, 3) == 2, \"3 is an eulerian number\"\n    assert euler_number(5, 4) == 8, \"5 is an eulerian number\"\n    assert euler_number(6, 3) == 12, \"6 is an eulerian number\"\n\nif __name__ == \"__main__\":\n    main()",
      -5.69921875
    ],
    [
      "import math\n\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    return math.factorial(m) / math.factorial(n)\n\nif __name__ == '__main__':\n    assert eulerian(1, 1) == 1\n    assert eulerian(1, 2) == 2\n    assert eulerian(1, 3) == 2\n    assert eulerian(2, 2) == 2\n    assert eulerian(2, 3) == 4\n    assert eulerian(3, 2) == 4\n    assert eulerian(3, 3) == 6\n    assert eulerian(4, 2) == 8\n    assert eulerian(4, 3) == 12\n    assert eulerian(5, 2) == 20\n    assert eulerian(5, 3) == 30\n    assert eulerian(6, 2) == 40\n    assert eulerian(6, 3) == 60\n    assert eulerian(7, 2) == 80\n    assert eulerian(7, 3) == 120\n    assert eulerian(8, 2) == 160\n    assert eulerian(8, 3) == 240\n    assert eulerian(9, 2) == 320\n    assert eulerian(9, 3) == 480\n    assert eulerian(10, 2) == 640\n    assert eulerian(10, 3) == 960\n    assert eulerian(11, 2) == 1280\n    assert eulerian(11, 3) == 1920\n    assert eulerian(12, 2) == 2560\n    assert eulerian(12, 3) == 4096\n    assert eulerian(13, 2) == 6144\n    assert eulerian(13, 3) == 12288\n    assert eulerian(14, 2) == 16384\n    assert eulerian(14, 3) == 24576\n    assert eulerian(15, 2) == 32768\n    assert eulerian(15, 3) == 49152\n    assert eulerian(16, 2) == 65536\n    assert eulerian(16, 3) == 98304\n    assert",
      -6.20703125
    ],
    [
      "def eulerian_number(n, m):\n    if m == 1:\n        return 0\n    elif m == 2:\n        return n\n    else:\n        return eulerian_number(n, m - 1) + eulerian_number(n, m - 2)\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert eulerian_number(1, 1) == 1, \"1st example\"\n    assert eulerian_number(2, 1) == 2, \"2nd example\"\n    assert eulerian_number(3, 1) == 3, \"3rd example\"\n    assert eulerian_number(3, 2) == 4, \"4th example\"\n    assert eulerian_number(4, 2) == 6, \"5th example\"\n    assert eulerian_number(5, 2) == 8, \"6th example\"\n    assert eulerian_number(6, 2) == 12, \"7th example\"\n    assert eulerian_number(7, 2) == 14, \"8th example\"\n    assert eulerian_number(8, 2) == 20, \"9th example\"\n    assert eulerian_number(9, 2) == 24, \"10th example\"\n    assert eulerian_number(10, 2) == 28, \"11th example\"\n    assert eulerian_number(11, 2) == 36, \"12th example\"\n    assert eulerian_number(12, 2) == 40, \"13th example\"\n    assert eulerian_number(13, 2) == 44, \"14th example\"\n    assert eulerian_number(14, 2) == 48, \"15th example\"\n    assert eulerian_number(15, 2) == 52, \"16th example\"\n    assert eulerian_number(16, 2) == 56, \"17th example\"\n    assert eulerian_number(17, 2) == 60, \"18th example\"\n    assert eulerian_number(18, 2) == 64, \"19th example\"\n    assert eulerian_number(19, 2)",
      -6.2890625
    ],
    [
      "class Solution:\n    # @param n, m, a list of integers\n    # @return an integer\n    def eulerian(self, n, m):\n        if n == 1:\n            return 1\n        if n == 2:\n            return m == 1 or m == 2\n        if m == 1:\n            return n == 1 or n == 2\n        if m == 2:\n            return n == 1 or n == 2 or n == 3\n        return self.eulerian(n-1, m-1) + self.eulerian(n-1, m) + self.eulerian(n-1, m-1)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.eulerian(4, 1)\n    print s.eulerian(4, 2)\n    print s.eulerian(4, 3)\n    print s.eulerian(4, 4)\n    print s.eulerian(4, 5)\n    print s.eulerian(4, 6)\n    print s.eulerian(4, 7)\n    print s.eulerian(4, 8)\n    print s.eulerian(4, 9)\n    print s.eulerian(4, 10)\n    print s.eulerian(4, 11)\n    print s.eulerian(4, 12)\n    print s.eulerian(4, 13)\n    print s.eulerian(4, 14)",
      -6.47265625
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n < 1 or m < 1:\n        return 0\n    if n == 1 or m == 1:\n        return 1\n    if n == m:\n        return 2\n    if n == 1:\n        return 1\n    if m == 1:\n        return 2\n    if n == m + 1:\n        return 2\n    if n == m - 1:\n        return 4\n    if m == n - 1:\n        return 4\n    if n == m + 2:\n        return 8\n    if m == n - 2:\n        return 8\n    if n == m - 2:\n        return 16\n    if m == n - 3:\n        return 16\n    if n == m - 3:\n        return 32\n    if m == n - 4:\n        return 64\n    if n == m - 4:\n        return 128\n    if m == n - 5:\n        return 256\n    if n == m - 5:\n        return 512\n    if n == m - 6:\n        return 1024\n    if m == n - 7:\n        return 2048\n    if m == n - 8:\n        return 4096\n    if m == n - 9:\n        return 8192\n    if m == n - 10:\n        return 16384\n    if n == m - 11:\n        return 32768\n    if m == n - 12:\n        return 65536\n    if n == m - 13:\n        return 131072\n    if m == n - 14:\n        return 262144\n    if n == m - 15:\n        return 524288\n    if m == n - 16:\n        return 1048576\n    if n == m - 17:\n        return 2097152\n    if m == n - 18:\n        return 4194304\n    if n == m - 19:\n        return 8388608\n    if m == n - 20:\n        return 16777216\n    if n == m - 21:\n        return 33554432\n    if m == n - 22:\n        return 67108864\n    if n == m -",
      -6.48828125
    ],
    [
      "def euler_number(n, m):\n    if n == m:\n        return 1\n    if n == 1:\n        return 0\n    if m == 1:\n        return 1\n    for i in range(1, min(n, m) + 1):\n        if i not in [n, m]:\n            if n % i == 0 and m % i == 0:\n                return euler_number(n / i, m / i) + 1\n    return 0\n\nif __name__ == '__main__':\n    print euler_number(20, 20)",
      -6.640625
    ],
    [
      "class Solution(object):\n    def eulerianPath(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n < 0 or m < 0 or n == 0 or m == 0:\n            return 0\n        if n == 1 or m == 1:\n            return 1\n        if n == m:\n            return m\n        if n == m+1:\n            return m\n        if n == m+2:\n            return m\n        if n == m+3:\n            return m\n        if n == m+4:\n            return m\n        if n == m+5:\n            return m\n        return 0\n\nif __name__ == \"__main__\":\n    assert Solution().eulerianPath(1, 1) == 1\n    assert Solution().eulerianPath(1, 2) == 2\n    assert Solution().eulerianPath(1, 3) == 3\n    assert Solution().eulerianPath(1, 4) == 4\n    assert Solution().eulerianPath(1, 5) == 5\n    assert Solution().eulerianPath(1, 6) == 6\n    assert Solution().eulerianPath(1, 7) == 7\n    assert Solution().eulerianPath(2, 1) == 1\n    assert Solution().eulerianPath(2, 2) == 2\n    assert Solution().eulerianPath(2, 3) == 3\n    assert Solution().eulerianPath(2, 4) == 4\n    assert Solution().eulerianPath(2, 5) == 5\n    assert Solution().eulerianPath(2, 6) == 6\n    assert Solution().eulerianPath(2, 7) == 7\n    assert Solution().eulerianPath(3, 1) == 1\n    assert Solution().eulerianPath(3, 2) == 2\n    assert Solution().eulerianPath(3, 3) == 3\n    assert Solution().eulerianPath(3, 4) == 4\n    assert Solution().eulerianPath(3, 5) == 5\n    assert Solution().eulerianPath(3, 6) == 6\n    assert Solution().eulerianPath(3, 7) ==",
      -6.70703125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 0\n    if m == 0:\n        return 1\n    if n == 1:\n        return 1\n    if m == 1:\n        return 0\n    if n % 2 == 0:\n        return eulerian_number(n - 1, m) + eulerian_number(n - 2, m)\n    else:\n        return eulerian_number(n - 1, m) + eulerian_number(n - 1, m - 1)\n\nif __name__ == '__main__':\n    print eulerian_number(3, 2)\n    print eulerian_number(5, 3)\n    print eulerian_number(5, 4)\n    print eulerian_number(5, 5)\n    print eulerian_number(5, 6)\n    print eulerian_number(5, 7)\n    print eulerian_number(5, 8)\n    print eulerian_number(5, 9)\n    print eulerian_number(5, 10)\n    print eulerian_number(5, 11)\n    print eulerian_number(5, 12)\n    print eulerian_number(5, 13)\n    print eulerian_number(5, 14)",
      -6.74609375
    ],
    [
      "import collections\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    # https://en.wikipedia.org/wiki/Eulerian_path\n    # https://stackoverflow.com/a/39243569/36984\n    if n <= 0 or m <= 0:\n        return 0\n    if n == m:\n        return 1\n    # find all the numbers that are a path from 1 to n\n    paths = collections.defaultdict(list)\n    for i in range(1, n+1):\n        paths[i].append(i)\n    for i in range(1, m+1):\n        paths[i].append(i)\n    # find the number of paths that are a path from 1 to n\n    for i in range(1, n+1):\n        if len(paths[i]) == 1:\n            return 1\n    # find the number of paths that are a path from 1 to m\n    for i in range(1, m+1):\n        if len(paths[i]) == 1:\n            return 1\n    # find the number of paths that are a path from 1 to n and a path from 1 to m\n    for i in range(1, n+1):\n        if len(paths[i]) == 2:\n            return 2\n    for i in range(1, m+1):\n        if len(paths[i]) == 2:\n            return 2\n    return 0\n\nif __name__ == '__main__':\n    print(eulerian_number(100, 100))\n    print(eulerian_number(20, 10))\n    print(eulerian_number(50, 25))",
      -6.9921875
    ],
    [
      "class Solution:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.ans = 0\n        self.n, self.m = 0, 0\n\n    def isEulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        self.n, self.m = n, m\n        self.ans = 1\n        self.dfs(0, 0, 0)\n        return self.ans == 1\n\n    def dfs(self, i, j, k):\n        if self.n == self.m:\n            if k == 1:\n                self.ans = 1\n                return\n            else:\n                return\n        for d in ['U', 'D', 'L', 'R']:\n            if i + d == self.n and j + d == self.m:\n                self.dfs(i + d, j + d, k + 1)\n                return\n            if i + d == self.n and j == self.m:\n                self.dfs(i + d, j + 1, k + 1)\n                return\n            if i == self.n and j + d == self.m:\n                self.dfs(i + 1, j + d, k + 1)\n                return\n            if i + d == self.n and j == self.m:\n                self.dfs(i + 1, j + 1, k + 1)\n                return\n        return\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.isEulerian(7, 5)\n    print sol.isEulerian(7, 7)\n    print sol.isEulerian(7, 9)",
      -7.1875
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 2\n    if n == 5:\n        return 2\n    if n == 6:\n        return 2\n    if n == 7:\n        return 3\n    if n == 8:\n        return 3\n    if n == 9:\n        return 3\n    if n == 10:\n        return 4\n    if n == 11:\n        return 4\n    if n == 12:\n        return 4\n    if n == 13:\n        return 4\n    if n == 14:\n        return 4\n    if n == 15:\n        return 4\n    if n == 16:\n        return 4\n    if n == 17:\n        return 5\n    if n == 18:\n        return 5\n    if n == 19:\n        return 5\n    if n == 20:\n        return 5\n    if n == 21:\n        return 5\n    if n == 22:\n        return 5\n    if n == 23:\n        return 6\n    if n == 24:\n        return 6\n    if n == 25:\n        return 6\n    if n == 26:\n        return 6\n    if n == 27:\n        return 6\n    if n == 28:\n        return 6\n    if n == 29:\n        return 6\n    if n == 30:\n        return 6\n    if n == 31:\n        return 7\n    if n == 32:\n        return 7\n    if n == 33:\n        return 7\n    if n == 34:\n        return 7\n    if n == 35:\n        return 7\n    if n == 36:\n        return 7\n    if n == 37:\n        return 7\n    if n == 38:\n        return 8\n    if n == 39:\n        return 8\n    if n == 40:\n        return 8\n    if n == 41:\n        return 8\n    if n == 42:\n        return 8",
      -7.51953125
    ],
    [
      "import time\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :param n: number of vertices\n    :param m: number of edges\n    :return: eulerian number\n    \"\"\"\n    visited = set()\n    for i in range(m):\n        visited.add(0)\n        visited.add(1)\n        visited.add(2)\n        visited.add(3)\n\n    visited.add(0)\n    visited.add(1)\n    visited.add(2)\n\n    for i in range(m):\n        if visited[i] == 1:\n            for j in range(i + 1, m):\n                if visited[j] == 1:\n                    visited.add(i + j)\n                    visited.add(i + j - 1)\n                    visited.add(i + j - 2)\n                    visited.add(i + j - 3)\n\n    return len(visited) == n * n\n\n\ndef eulerian_number_time_complexity(n, m):\n    \"\"\"\n    :param n: number of vertices\n    :param m: number of edges\n    :return: eulerian number\n    \"\"\"\n    return sum(1 for i in range(m) if i % 2 == 0)\n\n\nif __name__ == '__main__':\n    start_time = time.time()\n    print(eulerian_number(5, 4))\n    print(eulerian_number_time_complexity(5, 4))\n    print('--- %s seconds ---' % (time.time() - start_time))",
      -8.3125
    ],
    [
      "def eulerian_number(n, m):\n    \"\"\"\n    Write a function to find eulerian number a(n, m)\n\n    :param n: integer\n    :param m: integer\n    :return: integer\n    \"\"\"\n    # Write your code here\n    # Hint:\n    # 1. Count the number of vertices of a given graph\n    # 2. If there is a cycle, return 0\n    # 3. If there is no cycle, return 1\n    # 4. If there is a cycle, return 0\n    # 5. If there is no cycle, return 1\n    # 6. If there is a cycle, return 0\n    # 7. If there is no cycle, return 1\n    # 8. If there is a cycle, return 0\n    # 9. If there is no cycle, return 1\n    # 10. If there is a cycle, return 0\n    # 11. If there is no cycle, return 1\n    # 12. If there is a cycle, return 0\n    # 13. If there is no cycle, return 1\n    # 14. If there is a cycle, return 0\n    # 15. If there is no cycle, return 1\n    # 16. If there is a cycle, return 0\n    # 17. If there is no cycle, return 1\n    # 18. If there is a cycle, return 0\n    # 19. If there is no cycle, return 1\n    # 20. If there is a cycle, return 0\n    # 21. If there is no cycle, return 1\n    # 22. If there is a cycle, return 0\n    # 23. If there is no cycle, return 1\n    # 24. If there is a cycle, return 0\n    # 25. If there is no cycle, return 1\n    # 26. If there is a cycle, return 0\n    # 27. If there is no cycle, return 1\n    # 28. If there is a cycle, return 0\n    # 29. If there is no cycle, return 1\n    # 30. If there is a cycle, return 0\n    # 31. If there is no cycle, return 1\n    # 32. If there is a cycle, return 0\n    # 33. If there is no cycle, return 1\n    # 34. If there is a cycle, return 0",
      -8.3203125
    ],
    [
      "import os\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n == 1:\n        return m\n    if m == 0:\n        return n - 1\n    if m == 1:\n        return n - 1\n    if n == 2:\n        return m\n    if m == 2:\n        return n - 1\n    if n == 3:\n        return m - 1\n    if m == 3:\n        return n - 1\n    if n == 4:\n        return m - 2\n    if m == 4:\n        return n - 1\n    if n == 5:\n        return m - 2\n    if m == 5:\n        return n - 2\n    if n == 6:\n        return m - 3\n    if m == 6:\n        return n - 3\n    if n == 7:\n        return m - 3\n    if m == 7:\n        return n - 4\n    if n == 8:\n        return m - 4\n    if m == 8:\n        return n - 5\n    if n == 9:\n        return m - 5\n    if m == 9:\n        return n - 6\n    if n == 10:\n        return m - 6\n    if m == 11:\n        return n - 7\n    if m == 11:\n        return n - 8\n    if m == 12:\n        return n - 9\n    if m == 13:\n        return n - 10\n    if m == 14:\n        return n - 11\n    if m == 15:\n        return n - 12\n    if m == 16:\n        return n - 13\n    if m == 17:\n        return n - 14\n    if m == 18:\n        return n - 15\n    if m == 19:\n        return n - 16\n    if m == 20:\n        return n - 17\n    if m == 21:\n        return n - 18\n    if m == 22:\n        return n - 19\n    if m == 23:\n        return n - 20\n    if m == 24:",
      -8.6875
    ],
    [
      "from itertools import permutations\nfrom collections import defaultdict\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :param n: int, n > 0\n    :param m: int, m > 0\n    :return: int, eulerian number of n, m\n    \"\"\"\n    # n is a positive integer\n    # m is a positive integer\n    # n >= m\n    # n is a prime number\n    # m is a prime number\n    # n is a perfect square\n    # m is a perfect square\n    # n is a perfect cube\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n is a perfect square\n    # m is a perfect cube\n    # n",
      -8.9609375
    ],
    [
      "from collections import defaultdict\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    if n == 0 or m == 0:\n        return 0\n    if n == 1 or m == 1:\n        return 1\n    if m == 2 or m == n - 1:\n        return n\n    if n % 2 == 0 and m % 2 == 0:\n        return eulerian_number(n / 2, m / 2) + eulerian_number(n / 2, m / 2 + 1)\n    if n % 2 == 0 and m % 2 == 1:\n        return eulerian_number(n / 2, m / 2) + eulerian_number(n / 2 + 1, m / 2)\n    if n % 2 == 1 and m % 2 == 0:\n        return eulerian_number(n / 2, m / 2) + eulerian_number(n / 2 + 1, m / 2 + 1)\n    if n % 2 == 1 and m % 2 == 1:\n        return eulerian_number(n / 2, m / 2) + eulerian_number(n / 2 + 1, m / 2 + 1)\n    return 0\n\n\nif __name__ == '__main__':\n    assert eulerian_number(2, 1) == 1\n    assert eulerian_number(3, 2) == 3\n    assert eulerian_number(6, 3) == 8",
      -9.078125
    ],
    [
      "def eulerian_number(n, m):\n    # n is a positive integer, m is a positive integer\n    # n <= m\n    # the eulerian number of a, b is the sum of the number of ways of\n    # partitioning a into b parts,\n    # where a and b are positive integers\n    # and the sum of a and b is a and b.\n    # e.g. a=2, b=3, the eulerian number is 5.\n    # a=2, b=2, the eulerian number is 3.\n    # a=1, b=2, the eulerian number is 2.\n    # a=3, b=1, the eulerian number is 3.\n    # a=1, b=1, the eulerian number is 1.\n    # a=1, b=3, the eulerian number is 3.\n    # a=3, b=1, the eulerian number is 3.\n    # a=3, b=3, the eulerian number is 6.\n    if n==m:\n        return 1\n    elif n>m:\n        return 0\n    elif n==m+1:\n        return m\n    elif n==m+2:\n        return m*(m+1)/2\n    else:\n        return m*(m+1)/2 + eulerian_number(n-1, m+1) + eulerian_number(n-1, m)\n\nif __name__ == '__main__':\n    n = int(input())\n    m = int(input())\n    print(eulerian_number(n, m))",
      -9.09375
    ],
    [
      "from collections import Counter\nfrom itertools import permutations\n\n\ndef eulerian_number(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    def dfs(n, m):\n        if n == 0:\n            return 1\n        if m == 0:\n            return 0\n        if n == m:\n            return 1\n        for i in range(m):\n            if n - i in Counter(permutations(range(n), m - i)):\n                return dfs(n - 1, m) + dfs(n - i - 1, m)\n        return 0\n\n    return dfs(n, m)\n\n\nif __name__ == '__main__':\n    assert eulerian_number(3, 4) == 0\n    assert eulerian_number(4, 4) == 1\n    assert eulerian_number(5, 4) == 0\n    assert eulerian_number(6, 4) == 1\n    assert eulerian_number(7, 4) == 1\n    assert eulerian_number(8, 4) == 2\n    assert eulerian_number(9, 4) == 1\n    assert eulerian_number(10, 4) == 2\n    assert eulerian_number(11, 4) == 2\n    assert eulerian_number(12, 4) == 3\n    assert eulerian_number(13, 4) == 3\n    assert eulerian_number(14, 4) == 3\n    assert eulerian_number(15, 4) == 3\n    assert eulerian_number(16, 4) == 3\n    assert eulerian_number(17, 4) == 4\n    assert eulerian_number(18, 4) == 3\n    assert eulerian_number(19, 4) == 4\n    assert eulerian_number(20, 4) == 4",
      -9.328125
    ],
    [
      "class Solution:\n    # @param n, an integer\n    # @param m, an integer\n    # @return an integer\n    def eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n < 0 or m < 0 or n > m:\n            return -1\n        if m == 1:\n            return n\n        if n == 1:\n            return m\n        if n - m == m - 1:\n            return n\n        else:\n            return -1\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.eulerian(3, 5)",
      -9.3359375
    ],
    [
      "# This is a good idea to try out some of the solutions\n# from the internet.\n# https://en.wikipedia.org/wiki/Eulerian_path\n\n# The solution is the same as the solution from the website.\n\n# The eulerian path is the path of a number from 1 to n that is the same\n# as n minus the sum of the numbers in the path.\n\n# The solution for n = 10 is:\n\n# 11 - 1 = 10\n# 12 - 2 = 8\n# 13 - 3 = 6\n# 14 - 4 = 4\n# 15 - 5 = 3\n# 16 - 6 = 2\n# 17 - 7 = 1\n# 18 - 8 = 0\n# 19 - 9 = -1\n# 20 - 10 = -2\n# 21 - 11 = -3\n# 22 - 12 = -4\n# 23 - 13 = -5\n# 24 - 14 = -6\n# 25 - 15 = -7\n# 26 - 16 = -8\n# 27 - 17 = -9\n# 28 - 18 = -10\n# 29 - 19 = -11\n\n# The solution for n = 20 is:\n\n# 21 - 1 = 20\n# 22 - 2 = 18\n# 23 - 3 = 16\n# 24 - 4 = 14\n# 25 - 5 = 12\n# 26 - 6 = 10\n# 27 - 7 = 8\n# 28 - 8 = 6\n# 29 - 9 = 4\n# 30 - 10 = 2\n# 31 - 11 = 1\n# 32 - 12 = 0\n# 33 - 13 = -1\n# 34 - 14 = -2\n# 35 - 15 = -3\n# 36 - 16 = -4\n# 37 - 17 = -5\n# 38 - 18 = -6\n# 39 - 19 = -7\n# 40 - 20 = -8\n# 41 - 21 = -9\n# 42 - 22 = -10\n# 43 - 23 = -11\n# 44 - 24 = -12\n# 45 - 25 = -13\n# 46 - 26 = -14\n# 47 - 27 = -15\n# 48 - 28 = -16\n# 49 - 29 = -17\n# 50 - 30 = -18\n# 51 - 31 = -19\n# 52 - 32 = -20\n# 53 - 33 = -21\n# 54 -",
      -9.3515625
    ],
    [
      "def euler_number(n, m):\n    \"\"\"\n    For example, if n = 7 and m = 6, return 1.\n    If n = 7 and m = 2, return 8.\n    If n = 9 and m = 2, return 16.\n    \"\"\"\n    if m == 0:\n        return 1\n    if n == 1 or m == 1:\n        return 1\n    if n < m:\n        return 0\n    if n == m:\n        return 1\n    for i in range(2, n):\n        if n % i == 0:\n            if m % i == 0:\n                return euler_number(n / i, m / i) + euler_number(n / i, m / i - 1)\n            else:\n                return euler_number(n / i, m) + euler_number(n / i, m - 1)\n    return 0",
      -9.6171875
    ],
    [
      "def eulerian(n, m):\n    \"\"\"\n    Input: n and m are integers\n    Output: the eulerian number a(n, m)\n    \"\"\"\n    # If m = 0 then there is only one eulerian number\n    # If n < m, the only possible eulerian number is 1\n    # If n > m, the only possible eulerian number is 0\n    # So, if m = 0 or m > n, we just return 0\n    if m == 0 or m > n:\n        return 0\n    # If m = n, we just return 1\n    elif m == n:\n        return 1\n    # Otherwise, we have to count the number of odd numbers\n    # from 1 to n, then from 1 to m, then sum them up\n    odds = [0] * n\n    odds[1] = 1\n    for i in range(2, n + 1):\n        odds[i] = odds[i - 1] + odds[i - 2]\n    odds[0] = odds[0] + odds[1]\n    odds[m] = odds[m] + odds[m - 1]\n    return odds[n]\n\n\nif __name__ == '__main__':\n    assert eulerian(2, 0) == 1\n    assert eulerian(3, 2) == 1\n    assert eulerian(4, 1) == 1\n    assert eulerian(4, 3) == 2\n    assert eulerian(4, 4) == 1",
      -9.8671875
    ],
    [
      "class Solution(object):\n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n\n    def eulerianPath(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if n < 1:\n            return 0\n        if m < 1 or m > n:\n            return 0\n        if n == 1:\n            return 1\n        if m == 1:\n            return 2\n        if m == 2:\n            return 3\n        return self.eulerianPath(n - 1, m) + self.eulerianPath(n - 1, m - 1) + self.eulerianPath(n - 2, m - 2)\n\n\n# Note:\n# 1. We can assume that n and m is even.\n# 2. If m is even, then we can only have one edge for each vertex, so we can do a quick check.\n# 3. If m is odd, then we have two edges for each vertex, so we need to check n - 1 edges for each vertex.\n# 4. We can use a DFS to solve this problem, but it's a bit too complicated.\n# 5. We can do it in O(n) time.\n\n# Note:\n# 1. We can use a DFS to solve this problem, but it's a bit too complicated.\n# 2. We can use a DFS to solve this problem, but it's a bit too complicated.\n\n# Note:\n# 1. We can use a DFS to solve this problem, but it's a bit too complicated.\n# 2. We can use a DFS to solve this problem, but it's a bit too complicated.\n\n# Note:\n# 1. We can use a DFS to solve this problem, but it's a bit too complicated.\n# 2. We can use a DFS to solve this problem, but it's a bit too complicated.\n\n# Note:\n# 1. We can use a DFS to solve this problem, but it's a bit too complicated.\n# 2. We can use a DFS to solve this problem, but it's a bit too complicated.\n\n# Note:\n# 1. We can",
      -9.9296875
    ],
    [
      "import sys\nimport time\n\n# Complete the eulerian function below.\ndef eulerian(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                total += 1\n            elif i == 0 or j == 0:\n                continue\n            else:\n                total += 1 + eulerian(i, j)\n    return total\n\nif __name__ == '__main__':\n    start_time = time.time()\n    n = int(sys.stdin.readline().strip())\n    m = int(sys.stdin.readline().strip())\n    print eulerian(n, m)\n    elapsed = time.time() - start_time\n    if elapsed > 60:\n        print 'Time elapsed: %f minutes' % (elapsed / 60)\n    sys.stdout.write('\\n')\n    sys.stdout.flush()",
      -10.6640625
    ],
    [
      "# Definition for a point\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '<Point %s,%s>' % (self.x, self.y)\n\nclass Solution(object):\n    def eulerianPath(self, numRows, edges):\n        \"\"\"\n        :type numRows: int\n        :type edges: List[List[Point]]\n        :rtype: int\n        \"\"\"\n        visited = [[False for _ in range(numRows)] for _ in range(numRows)]\n        visited[0][0] = True\n        for i in range(1, numRows):\n            for j in range(1, numRows-i+1):\n                if not visited[i][j]:\n                    if i+j > numRows:\n                        return 0\n                    if visited[i+1][j+1]:\n                        visited[i][j] = True\n                    else:\n                        visited[i][j] = self.eulerianPath(numRows, edges)\n        return visited[-1][-1]\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.eulerianPath(2, [[Point(0, 0), Point(1, 0)], [Point(1, 0), Point(2, 0)]])\n    print sol.eulerianPath(3, [[Point(0, 0), Point(1, 0), Point(2, 0)], [Point(0, 0), Point(0, 1), Point(0, 2)], [Point(1, 0), Point(2, 0), Point(1, 1)], [Point(1, 1), Point(1, 2), Point(2, 1)]])\n    print sol.eulerianPath(4, [[Point(0, 0), Point(1, 0), Point(2, 0), Point(3, 0)], [Point(0, 1), Point(1, 1), Point(2, 1), Point(3, 1)], [Point(0, 2), Point(1, 2), Point",
      -11.859375
    ],
    [
      "from collections import deque\nfrom functools import reduce\n\ndef eulerian(n, m):\n    \"\"\"\n    Returns the Eulerian number of n, m.\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n\n    if n == m:\n        return 2\n\n    if n < m:\n        return eulerian(n, m - 1)\n\n    if n % m == 0:\n        return eulerian(n / m, m)\n\n    return eulerian(n - 1, m) + eulerian(n, m - 1)\n\ndef eulerian_number(n):\n    \"\"\"\n    Find the Eulerian number of n.\n    \"\"\"\n    return reduce(lambda x, y: x + y, [eulerian(n, i) for i in range(2, n + 1)])\n\ndef eulerian_number_test():\n    \"\"\"\n    Test the eulerian_number function.\n    \"\"\"\n    assert eulerian_number(1) == 1\n    assert eulerian_number(2) == 2\n    assert eulerian_number(3) == 5\n    assert eulerian_number(4) == 14\n    assert eulerian_number(5) == 42\n    assert eulerian_number(6) == 132\n    assert eulerian_number(7) == 462\n    assert eulerian_number(8) == 2164\n    assert eulerian_number(9) == 8402\n    assert eulerian_number(10) == 4042\n    assert eulerian_number(11) == 16772\n    assert eulerian_number(12) == 82942\n    assert eulerian_number(13) == 422442\n    assert eulerian_number(14) == 1728772\n    assert eulerian_number(15) == 8654224\n    assert eulerian_number(16) == 4304282\n    assert eulerian_number(17) == 17286542\n    assert eulerian_number(18) == 8654224\n    assert eulerian_number(19) == 43042825\n    assert eulerian_number(20) == 1728",
      -12.859375
    ],
    [
      "class Solution:\n    def is_eulerian(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        if n == 0 or m == 0:\n            return False\n        if n < m:\n            return self.is_eulerian(m, n)\n        if n % 2 == 0:\n            return self.is_eulerian(m, n / 2) and self.is_eulerian(m, n / 2 + 1)\n        else:\n            return self.is_eulerian(m, n / 2 + 1) and self.is_eulerian(m, n / 2)\n\na = Solution()\n\nprint a.is_eulerian(0, 0)\nprint a.is_eulerian(1, 1)\nprint a.is_eulerian(2, 2)\nprint a.is_eulerian(3, 4)\nprint a.is_eulerian(4, 5)\nprint a.is_eulerian(5, 6)\nprint a.is_eulerian(6, 7)\nprint a.is_eulerian(7, 8)",
      -13.046875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}