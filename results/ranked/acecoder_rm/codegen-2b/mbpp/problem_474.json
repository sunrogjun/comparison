{
  "problem": {
    "task_id": "MBPP/485",
    "prompt": "Write a function to find the largest palindromic number in the given array.",
    "canonical_solution": "def is_palindrome(n) : \r\n\tdivisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1",
    "test_list": [
      "assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545",
      "assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5",
      "assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9"
    ],
    "challenge_test_list": [],
    "problem_id": 474
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def largestPalindromic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    length = len(nums)\n    \n    if length == 0:\n        return 0\n    \n    for i in range(length):\n        if nums[i] < 0:\n            return -1\n        \n        for j in range(i, length):\n            if nums[i] == nums[j]:\n                if i == j:\n                    return nums[i]\n                else:\n                    return max(nums[i], nums[j])\n        \n        return nums[i]\n\nprint largestPalindromic([-2, 1, 4, 5, -1, -2, -1, 2, 1, -1])",
      1.6826171875
    ],
    [
      "# https://leetcode.com/problems/largest-palindrome-product/discuss/82937/My-O(N^2)-time-O(1)-space-solution-with-explanation\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        nums_copy = nums[:]\n        for i in range(len(nums)):\n            for j in range(len(nums) - i - 1):\n                if nums[j] > nums[j + 1]:\n                    nums_copy[j] = nums[j + 1]\n                    nums_copy[j + 1] = nums[j]\n        for i in range(len(nums_copy)):\n            nums_copy[i] *= nums_copy[i]\n        return nums_copy[-1]\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.largestPalindrome(nums)",
      1.2109375
    ],
    [
      "def largestPalindrome(a):\n    # write your code here\n    # write code here\n    n = len(a)\n    i, j = 0, 0\n    while i < n:\n        while j < n and a[i] == a[j]:\n            i += 1\n            j += 1\n        if j == n:\n            return a[i]\n        i += 1\n        j -= 1\n\nprint largestPalindrome([1, 2, 3, 4])",
      0.276123046875
    ],
    [
      "#!/usr/bin/env python\n\ndef largestPalindrome(arr):\n\tmax = arr[0]\n\tfor i in range(1, len(arr)):\n\t\tmax = max if arr[i] == arr[i-1] else max\n\treturn max\n\nif __name__ == '__main__':\n\tarr = [1,2,3,4,5,6,7,8,9]\n\tprint largestPalindrome(arr)",
      -0.019989013671875
    ],
    [
      "# https://discuss.leetcode.com/topic/52728/java-dp-solution\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        # dp[i][j] means the largest palindrome starting from [i][j]\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i, n):\n                # we assume the first number is a palindrome\n                if i == 0 and j == 0:\n                    dp[i][j] = nums[i]\n                elif nums[i] == nums[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + nums[i]\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n        return dp[n - 1][n - 1]",
      -0.2144775390625
    ],
    [
      "def find_max_palindrome(nums):\n    \"\"\"\n    Find the largest palindromic number in the given array.\n\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # base case\n    if len(nums) == 1:\n        return nums[0]\n\n    # base case for each element\n    max_palindrome = nums[0]\n    for i in range(1, len(nums)):\n        max_palindrome = max(max_palindrome, nums[i], nums[i-1], nums[i+1])\n\n    return max_palindrome\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(find_max_palindrome(nums))",
      -0.329833984375
    ],
    [
      "def largestPalindrome(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if arr[i] == arr[j]:\n                if arr[i] > max:\n                    max = arr[i]\n                if arr[j] < max:\n                    max = arr[j]\n    return max\n\nif __name__ == \"__main__\":\n    print(largestPalindrome([3, 3, 2, 3, 3, 5, 8, 1, 5, 8]))",
      -0.456298828125
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        # write your code here\n        if not nums: return 0\n        return max(self.largestPalindrome(nums[::-1]), self.largestPalindrome(nums))\n\n    def largestPalindrome(self, nums):\n        if not nums: return 0\n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = left + (right-left)/2\n            if self.isPalindrome(nums, left, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n\n    def isPalindrome(self, nums, left, right):\n        while left < right:\n            if nums[left]!= nums[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print Solution().largestPalindrome(nums)",
      -0.7431640625
    ],
    [
      "import sys\nsys.path.append('..')\nimport time\nfrom collections import Counter\n\ndef find_largest_palindromic(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    palindromic_sum = 0\n    for i in range(len(sorted_numbers)):\n        for j in range(i, len(sorted_numbers)):\n            if sorted_numbers[i] == sorted_numbers[j]:\n                palindromic_sum += sorted_numbers[i]\n    return palindromic_sum\n\nif __name__ == '__main__':\n    numbers = [6, -5, 3, 4, 7, -7, -4, 9, -9, 1]\n    start_time = time.time()\n    print(find_largest_palindromic(numbers))\n    elapsed_time = time.time() - start_time\n    print(\"Time elapsed: {}\".format(elapsed_time))",
      -0.83837890625
    ],
    [
      "class Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        max_len = max(map(len, nums))\n        \n        nums = sorted(nums)\n        \n        for i in xrange(n-1):\n            if nums[i] > nums[i+1]:\n                return nums[i]\n            \n            for j in xrange(max_len):\n                if nums[i]*nums[i+j] > nums[i+j+1]:\n                    return nums[i]*nums[i+j]\n        \n        return nums[-1]*nums[-1]",
      -0.85693359375
    ],
    [
      "import sys\n\ndef largest_palindromic(nums):\n    # write your code in Python 2.7\n    #print nums\n    if len(nums) == 0:\n        return 0\n    \n    if len(nums) == 1:\n        return nums[0]\n    \n    i = 0\n    j = len(nums) - 1\n    \n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] > nums[j]:\n            i += 1\n        elif nums[i] < nums[j]:\n            j -= 1\n        \n        if i == j:\n            return nums[i]\n    \n    return nums[i]\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6]\n    print largest_palindromic(nums)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_nums = 0\n        for i in xrange(len(nums)):\n            max_nums = max(max_nums, nums[i])\n            max_nums = max(max_nums, nums[i] * nums[i])\n            max_nums = max(max_nums, nums[i] * nums[-i-1])\n        return max_nums\n\n\nif __name__ == \"__main__\":\n    print Solution().largestPalindrome([3, 3])",
      -0.85693359375
    ],
    [
      "import sys\n\n\ndef largest_palindromic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(largest_palindromic_helper(nums, 0, len(nums) - 1))\n\n\ndef largest_palindromic_helper(nums, left, right):\n    if left >= right:\n        return nums[left]\n\n    mid = (left + right) / 2\n\n    if nums[mid] == nums[mid + 1]:\n        return nums[mid]\n\n    if nums[mid] > nums[mid + 1]:\n        return largest_palindromic_helper(nums, mid + 1, right)\n    else:\n        return largest_palindromic_helper(nums, left, mid - 1)\n\nif __name__ == '__main__':\n    nums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(largest_palindromic(nums))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def largestPalindrome(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) < 2:\n            return arr[0]\n        l, r = 0, len(arr) - 1\n        while l < r:\n            mid = l + (r - l) // 2\n            if arr[mid] == arr[r - mid]:\n                l = mid + 1\n            else:\n                r = mid\n        return arr[l]\n\n\nif __name__ == \"__main__\":\n    arr = [5, 9, 12, 2, 3, 4, 6]\n    print(Solution().largestPalindrome(arr))",
      -0.85791015625
    ],
    [
      "def largestPalindrome(nums):\n    for i in range(0, len(nums)-1):\n        for j in range(0, len(nums)-i-1):\n            if nums[i:j+1] == nums[j:i+1]:\n                return nums[i]\n    return nums[0]\n\nnums = [1,2,3,4,5]\nprint(largestPalindrome(nums))\n\nnums = [1,2,3,4,5,6]\nprint(largestPalindrome(nums))\n\nnums = [1,2,3,4,5,6,7]\nprint(largestPalindrome(nums))",
      -0.85791015625
    ],
    [
      "# largest palindrome in array\ndef find_largest_palindrome(nums):\n    max_palindrome = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if j - i > 1:\n                if nums[i] == nums[j]:\n                    max_palindrome = max(max_palindrome, nums[i] * nums[j])\n                else:\n                    break\n    return max_palindrome",
      -0.85791015625
    ],
    [
      "def largestPalindrome(nums):\n    \n    for i in xrange(len(nums)):\n        for j in xrange(len(nums)-i-1):\n            if nums[j]*nums[j+i] > nums[j+i+1]*nums[j]:\n                return nums[j]*nums[j+i]\n\nprint largestPalindrome([1,2,3,4,5])",
      -0.85791015625
    ],
    [
      "def largestPalindrome(a):\n    \"\"\"\n    :type a: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    return max(a)\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 4, 5]\n    print(largestPalindrome(a))",
      -0.85791015625
    ],
    [
      "def largestPalindrome(nums):\n    for i in range(len(nums)):\n        for j in range(len(nums) - i):\n            if nums[i] == nums[j] + nums[len(nums) - j - 1]:\n                return nums[i]\n\n\nif __name__ == '__main__':\n    nums = [5, 5, 8, 9, 9, 12]\n    print largestPalindrome(nums)",
      -0.8583984375
    ],
    [
      "#!/bin/python\n\nimport math\n\ndef largestPalindrome(arr):\n    \n    if len(arr) == 0:\n        return 0\n    \n    max = arr[0]\n    \n    for num in arr:\n        \n        if num > max:\n            max = num\n            \n        elif num < max:\n            max = max * max\n            \n    return max\n\ndef main():\n    \n    arr = [4, 3, 2, 1]\n    \n    print largestPalindrome(arr)\n    \nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "from functools import reduce\n\ndef largestPalindromic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(reduce(lambda x, y: x if x > y else y, nums, 0),\n               largestPalindromic(nums[::-1]))\n\nif __name__ == '__main__':\n    print(largestPalindromic([-2, -3, 4, -1, -2, 1, 5, -3]))\n    print(largestPalindromic([-1, -2, -3, -4, -5, -6, -7, -8, -9]))\n    print(largestPalindromic([2, 3, 4, 5, 6, 7, 8, 9, 0]))",
      -0.8583984375
    ],
    [
      "def largest_palindromic(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        if nums[i] == nums[i-1]:\n            nums[i] *= nums[i-1]\n    max_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > max_num:\n            max_num = nums[i]\n    return max_num",
      -0.8583984375
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode[]} nodes\n    # @return {integer}\n    def largestPalindrome(self, nodes):\n        if not nodes:\n            return 0\n        node = TreeNode(nodes[0].val)\n        max_val = node.val\n        curr = node\n        for i in range(1, len(nodes)):\n            curr.left = TreeNode(nodes[i].val)\n            curr.right = TreeNode(nodes[i].val)\n            curr = curr.left\n            max_val = max(max_val, curr.val)\n            curr = curr.right\n        max_val = max(max_val, curr.val)\n        return max_val",
      -0.8583984375
    ],
    [
      "def largest_palindromic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # find the largest palindromic number\n    # in the given array\n    max_len = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                max_len = max(max_len, j - i + 1)\n                break\n    return max_len\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(largest_palindromic(arr))",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/largest-palindrome/problem\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\ndef largestPalindrome(nums):\n    if len(nums) <= 1:\n        return nums[0]\n    else:\n        return max(largestPalindrome(nums[:len(nums)//2]), largestPalindrome(nums[len(nums)//2:]))\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5]\n    print(largestPalindrome(nums))",
      -0.8583984375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_num = 0\n    for num in nums:\n        if num > max_num:\n            max_num = num\n        elif num < max_num:\n            max_num = max_num\n    return max_num",
      -0.8583984375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    nums.sort()\n    mid = len(nums) // 2\n    result = nums[0]\n    for i in range(mid, -1, -1):\n        if nums[i] < nums[i + 1]:\n            return nums[i]\n    return nums[mid]\n\nif __name__ == '__main__':\n    print(largestPalindrome([1, 2, 3, 4, 5]))\n    print(largestPalindrome([1, 2, 3]))\n    print(largestPalindrome([1, 1, 1, 1]))\n    print(largestPalindrome([1, 1, 1]))",
      -0.85888671875
    ],
    [
      "# https://leetcode.com/problems/largest-palindrome-product/discuss/116592/Python-and-Java-solution-with-explanation\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(len(nums)):\n            res = max(res, nums[i]*nums[i])\n            for j in xrange(i+1, len(nums)):\n                res = max(res, nums[i]*nums[j])\n                res = max(res, nums[j]*nums[i])\n        return res\n\nif __name__ == \"__main__\":\n    print Solution().largestPalindrome([2,3,4,5,6,7,8,9,10])\n    print Solution().largestPalindrome([2,3,4,5,6,7,8])",
      -0.85888671875
    ],
    [
      "# https://oj.leetcode.com/problems/largest-palindrome-product/\n# OJ's Problem #5\n# Use the function to add the palindromes of each number and find the largest palindrome product.\n# For example, given the array [1,2,3,4,5], the function should return 15,\n# because 15 = 2^2 * 3^3 * 4^4 * 5^5.\n# Note:\n# Assume the numbers in the array are in the range of 32-bit signed integer.\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result = max(result, num * num)\n        return result\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.largestPalindrome([1, 2, 3, 4, 5]))",
      -0.85888671875
    ],
    [
      "#!/usr/bin/python\n\n# https://www.hackerrank.com/challenges/largest-palindromic-number/problem\n\n#  solution\n#\n#\n\n#!/usr/bin/python\nimport sys\n\n# Complete the largestPalindrome function below.\ndef largestPalindrome(nums):\n    # Write your code here\n    for i in range(1, n):\n        if i < len(nums) - i:\n            if nums[i] * nums[i + i] == nums[i + i + i]:\n                return nums[i] * nums[i + i]\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    nums = list(map(int, sys.stdin.readline().split(' ')))\n    print largestPalindrome(nums)",
      -0.85888671875
    ],
    [
      "def largest_palindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    max_num = nums[0]\n    for i in range(1, n):\n        max_num = max(max_num, nums[i]*nums[i-1])\n    return max_num\n\nif __name__ == '__main__':\n    nums = [1, 2, 3]\n    print(largest_palindrome(nums))",
      -0.86083984375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(nums) if len(nums) > 0 else 0\n\nif __name__ == '__main__':\n    print largestPalindrome([1, 2, 3])",
      -0.86083984375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    nums = sorted(nums)\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i!= j:\n                if nums[i] == nums[j] and nums[i] == nums[len(nums)-1-j]:\n                    return nums[i]\n    return nums[-1]",
      -0.86083984375
    ],
    [
      "def palindrome(n):\n    \"\"\"\n    Write a function that takes an integer n as input and returns the\n    largest palindromic number in the given array.\n    \"\"\"\n    if n < 2:\n        return n\n    return max(palindrome(x) for x in range(n - 1, -1, -1) if x < n)\n\nif __name__ == '__main__':\n    for n in range(1, 20):\n        print(palindrome(n))",
      -0.86083984375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(largestPalindrome(nums[::-1]), largestPalindrome(nums))\n\nif __name__ == '__main__':\n    nums = [1, 4, 7, 9, 11, 14, 17]\n    print(largestPalindrome(nums))",
      -0.86083984375
    ],
    [
      "def largestPalindrome(nums):\n    max_len = 0\n    max_num = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                max_len = max(max_len, j - i + 1)\n                max_num = max(max_num, nums[i])\n    return max_len, max_num\n\nprint largestPalindrome([1,2,3,4,5])",
      -0.8857421875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        n = len(nums)\n        if n < 2:\n            return nums[0]\n        \n        max_num = nums[0]\n        max_index = 0\n        for i in range(1, n):\n            if nums[i] > max_num:\n                max_num = nums[i]\n                max_index = i\n        \n        if max_index + 1 < n:\n            max_num = self.largestPalindrome(nums[max_index + 1:])\n        \n        return max_num",
      -0.90625
    ],
    [
      "import sys\n\ndef largest_palindromic_number(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Find the middle element\n    m = len(nums) / 2\n    # Find the smallest and largest elements\n    smallest = nums[0]\n    largest = nums[0]\n    for i in range(1, m + 1):\n        if nums[i] > largest:\n            largest = nums[i]\n        if nums[i] < smallest:\n            smallest = nums[i]\n    # Check for palindromes\n    for i in range(m - 1, -1, -1):\n        if nums[i] > largest and nums[i] < smallest:\n            if nums[i] == largest:\n                largest = largest * nums[i]\n            else:\n                largest = largest * nums[i]\n        if nums[i] < smallest and nums[i] > largest:\n            if nums[i] == smallest:\n                smallest = smallest * nums[i]\n            else:\n                smallest = smallest * nums[i]\n    return largest\n\nif __name__ == '__main__':\n    nums = [6, 1, 2, 3, 4, 5]\n    print(largest_palindromic_number(nums))",
      -0.92236328125
    ],
    [
      "#!/bin/python\n\n# https://www.hackerrank.com/challenges/largest-palindrome/problem\n\nimport os\nimport sys\nimport math\n\ndef largestPalindrome(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 0\n    l = largestPalindrome(n // 2)\n    r = largestPalindrome(n - l)\n    if l == r:\n        return l\n    return max(l, r)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    largestPalindrome(n)",
      -0.9228515625
    ],
    [
      "def find_largest_palindromic_number(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # Using a hashmap to store the largest palindromic number\n    # in the array\n    largest_palindromic_number = 0\n    largest_palindromic_number_map = {}\n    # Iterate through the array\n    for i in range(0, len(arr)):\n        # If the number is a palindromic\n        # then update the largest palindromic number\n        if arr[i] == arr[len(arr)-i-1]:\n            largest_palindromic_number = max(largest_palindromic_number, arr[i])\n            largest_palindromic_number_map[arr[i]] = arr[i]\n    # Iterate through the hashmap to find the largest palindromic number\n    for i in range(0, len(largest_palindromic_number_map)):\n        if largest_palindromic_number_map[largest_palindromic_number_map[i]] > largest_palindromic_number:\n            largest_palindromic_number = largest_palindromic_number_map[i]\n    return largest_palindromic_number",
      -1.14453125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            mid = (start + end) / 2\n            if self.isPalindrome(nums[mid]):\n                start = mid + 1\n            else:\n                end = mid\n        return nums[start]\n\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        if x == 0:\n            return True\n        s = str(x)\n        return self.isPalindrome(int(s[::-1]))",
      -1.3564453125
    ],
    [
      "def largestPalindromic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if arr[mid] == arr[mid - 1] and arr[mid] == arr[mid + 1]:\n            return arr[mid]\n        elif arr[mid] < arr[mid - 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return arr[left]\n\nif __name__ == '__main__':\n    arr = [2, 3, 5, 9, 11, 13, 14, 15]\n    print(largestPalindromic(arr))",
      -1.5546875
    ],
    [
      "# The largest palindromic number in the given array\ndef max_palindromic(arr):\n  # Base case\n  if len(arr) <= 1:\n    return arr\n\n  # The largest palindromic number is the largest palindromic number in the\n  # subarray that starts at the index 1 and ends at the index of the largest\n  # palindromic number\n  return max(max_palindromic(arr[:i] + arr[i+1:]) for i in range(1, len(arr)))",
      -1.6015625
    ],
    [
      "# https://leetcode.com/problems/largest-palindrome-number/discuss/203084/Python-and-C-Solution\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num = 0\n        for num in nums:\n            if num == 0:\n                continue\n            if num % 10 == 0:\n                max_num = max(max_num, num * 10)\n            else:\n                max_num = max(max_num, num)\n            if num % 100 == 0:\n                max_num = max(max_num, num * 100)\n            else:\n                max_num = max(max_num, num)\n            if num % 1000 == 0:\n                max_num = max(max_num, num * 1000)\n            else:\n                max_num = max(max_num, num)\n        return max_num\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
      -1.724609375
    ],
    [
      "# Definition for a palindrome:\n#   palindrome(s) returns true if the string s is a palindrome,\n#   and false otherwise.\n# @param {string[]} nums\n# @return {number}\ndef largestPalindrome(nums):\n    n = len(nums)\n    dp = [0]*(n+1)\n    for i in range(n+1):\n        dp[i] = i\n    for i in range(n):\n        for j in range(i, n):\n            if nums[i] == nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp[0:n])",
      -1.884765625
    ],
    [
      "def largest_palindrome(nums):\n    max_num = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if i!= j and nums[i] == nums[j]:\n                max_num = max(max_num, nums[i] * nums[j])\n    return max_num\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print largest_palindrome(nums)\n    nums = [1, 1, 1, 1]\n    print largest_palindrome(nums)\n    nums = [1, 1, 1, 1, 1]\n    print largest_palindrome(nums)",
      -2.091796875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        # write your code here\n        return self.largestPalindromeHelper(nums, 0, len(nums))\n\n    def largestPalindromeHelper(self, nums, start, end):\n        if start == end:\n            return nums[start]\n        mid = (start + end) / 2\n        if mid == start:\n            return max(nums[start], nums[end])\n        if mid == end:\n            return max(nums[start], nums[mid])\n        if nums[mid] < nums[start]:\n            return max(nums[start], nums[mid])\n        else:\n            return max(nums[mid], nums[end])",
      -2.328125
    ],
    [
      "def largestPalindrome(nums):\n  \"\"\"\n  :type nums: List[int]\n  :rtype: int\n  \"\"\"\n  n = len(nums)\n  if n < 2:\n    return nums[0] if nums[0] < nums[1] else nums[1]\n  for i in xrange(n/2):\n    if nums[i] > nums[n-i-1]:\n      return nums[i]\n  return nums[n/2]\n\n\nif __name__ == \"__main__\":\n  print largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])",
      -2.412109375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n\tdef __init__(self, val=0, left=None, right=None):\n\t\tself.val = val\n\t\tself.left = left\n\t\tself.right = right\n\nclass Solution:\n\t# @param root, a tree node\n\t# @return an integer\n\tdef largestPalindrome(self, root):\n\t\tif not root:\n\t\t\treturn 0\n\t\tif not root.left and not root.right:\n\t\t\treturn root.val\n\t\tif not root.left:\n\t\t\treturn self.largestPalindrome(root.right)\n\t\tif not root.right:\n\t\t\treturn self.largestPalindrome(root.left)\n\t\treturn max(self.largestPalindrome(root.left), self.largestPalindrome(root.right))\n\nif __name__ == \"__main__\":\n\ts = Solution()\n\troot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n\tprint s.largestPalindrome(root)",
      -2.521484375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A integer\n    \"\"\"\n    def largestPalindrome(self, nums):\n        # write your code here\n        return self.largestPalindromeHelper(nums, 0, len(nums) - 1)\n\n    def largestPalindromeHelper(self, nums, start, end):\n        if start == end:\n            return nums[start]\n        mid = (start + end) / 2\n        if nums[mid] < nums[end]:\n            return self.largestPalindromeHelper(nums, start, mid)\n        else:\n            return self.largestPalindromeHelper(nums, mid + 1, end)",
      -2.5390625
    ],
    [
      "# https://oj.leetcode.com/problems/largest-palindrome-from-a-string/\n# Given an array of characters, find the largest palindrome that can be formed by \n# joining elements in order.\n#\n# Example 1:\n# Input: [\"a\",\"b\",\"c\"]\n# Output: \"bbc\"\n# Example 2:\n# Input: [\"a\",\"b\",\"c\"]\n# Output: \"a\"\n# Example 3:\n# Input: [\"a\",\"b\",\"c\"]\n# Output: \"abbc\"\n# Note:\n# The size of the given array will be between 1 and 50, inclusive.\n# All given array elements will be in lowercase.\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: str\n        \"\"\"\n        if not nums:\n            return ''\n\n        nums.sort()\n        for i in range(len(nums) - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            \n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return nums[i]\n\n        return nums[0]",
      -2.734375
    ],
    [
      "# https://oj.leetcode.com/problems/largest-palindrome-product/\n# Given an array of positive integers nums,\n# write a function to find the largest palindrome product possible.\n# The largest palindrome product is calculated by\n# summing the numbers and rearranging the product to make it a palindrome.\n# Example 1:\n# Input: [13,43,12]\n# Output: 966\n# Example 2:\n# Input: [1,4,3,2]\n# Output: 243\n# Example 3:\n# Input: [3,1,3,4]\n# Output: 1296\n# Example 4:\n# Input: [2,4,6,8]\n# Output: 864\n\n# 2ms\nclass Solution(object):\n    def findLargestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num = nums[i] * nums[j]\n                if num > max_num:\n                    max_num = num\n        return max_num\n\n\n# 2ms\nclass Solution(object):\n    def findLargestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num = nums[i] * nums[j]\n                if num > max_num:\n                    max_num = num\n        return max_num",
      -2.841796875
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return nums[0]\n    for i in range(n - 1):\n        j = i + 1\n        while j < n:\n            if nums[i] * nums[j] == nums[j - i]:\n                return nums[i] * nums[j]\n            j += 1\n    return nums[0]\n\n# Your largestPalindrome function should return the largest palindrome that can be formed by multiplying together\n# all the elements in the given array.",
      -2.91015625
    ],
    [
      "import sys\nsys.path.append(\"..\")\nfrom palindromic_number import palindromic_number\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert palindromic_number(arr) == 9\n\n    arr = [0, 1, 0, 1, 0, 1, 0, 1, 0]\n    assert palindromic_number(arr) == 0",
      -2.955078125
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        # print nums\n        i = 0\n        j = n-1\n        while i < j:\n            # print i, j\n            if nums[i] == nums[j]:\n                # print nums[i]\n                # print nums[j]\n                i += 1\n                j -= 1\n            else:\n                if nums[i] > nums[j]:\n                    # print nums[i]\n                    # print nums[j]\n                    i += 1\n                else:\n                    # print nums[i]\n                    # print nums[j]\n                    j -= 1\n        # print i, j\n        return nums[i]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    # print solution.largestPalindrome([1,2,3,4])\n    # print solution.largestPalindrome([1,2,3,4,5,6,7,8,9])\n    # print solution.largestPalindrome([1,2,3,4,5,6,7,8,9,10])\n    # print solution.largestPalindrome([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n    print solution.largestPalindrome([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\n    # print solution.largestPalindrome([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47",
      -3.078125
    ],
    [
      "# @include\ndef largest_palindrome(nums):\n    # If the number is a palindrome, return it.\n    if nums[0] == nums[-1]:\n        return nums[0]\n\n    # If the number is not a palindrome, find the largest palindrome that\n    # contains the current number.\n    for i in range(1, len(nums) - 1):\n        if nums[i] == nums[i + 1]:\n            return nums[i]\n        elif nums[i] > nums[i + 1]:\n            return nums[i]\n\n        elif nums[i] < nums[i + 1]:\n            return nums[i + 1]\n\n    # If the number is not a palindrome, return the maximum of all numbers\n    # that are less than the current number.\n    return max(largest_palindrome(nums[:i]) for i in range(1, len(nums)))\n\n\n# @exclude\n\ndef main():\n    nums = [2, 3, 4, 5, 6, 7, 8, 8]\n    print(largest_palindrome(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 8]\n    print(largest_palindrome(nums))\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print(largest_palindrome(nums))\n    nums = [10, 11, 12, 13, 14, 15, 16, 17, 18]\n    print(largest_palindrome(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(largest_palindrome(nums))\n\n\nif __name__ == '__main__':\n    main()",
      -3.125
    ],
    [
      "import os\nimport sys\n\n__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        \"\"\"\n        cipher = map(int, cipher)\n        for i in xrange(len(cipher)):\n            for j in xrange(i):\n                if cipher[i] == cipher[j]:\n                    if i - j < len(cipher) - i:\n                        cipher[i], cipher[j] = cipher[j], cipher[i]\n                        cipher[i - 1], cipher[j + 1] = cipher[j + 1], cipher[i - 1]\n                        break\n\n        for i in xrange(len(cipher)):\n            cipher[i] = cipher[i] * cipher[i]\n        return max(cipher)\n\n\nif __name__ == '__main__':\n    import sys\n    f = open('1.in', 'r')\n    # f = sys.stdin\n    solution = Solution()\n    N = int(f.readline().strip())\n    cipher = map(int, f.readline().strip().split(' '))\n    # solve\n    s = \"%s\\n\" % (solution.solve(cipher))\n    print s,",
      -3.349609375
    ],
    [
      "import sys\n\ndef get_largest_palindromic_number(num):\n    max_palindrome = 0\n    for i in range(len(num)):\n        for j in range(len(num)):\n            if i == j:\n                continue\n            if num[i] == num[j] and num[i] * num[j] > max_palindrome:\n                max_palindrome = num[i] * num[j]\n    return max_palindrome\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print \"usage:./get_largest_palindromic_number.py num\"\n        exit(1)\n    num = sys.argv[1]\n    print get_largest_palindromic_number(num)",
      -3.43359375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def largestPalindrome(self, num):\n        if not num:\n            return 0\n\n        max_len = 0\n        max_val = 0\n\n        for i in range(0, len(num)):\n            if len(str(num[i])) == 2:\n                max_len = max(len(str(num[i])), max_len)\n                max_val = max(num[i], max_val)\n\n        max_len = 2 * max_len\n        return max_val * max_len\n\n\nif __name__ == '__main__':\n    assert Solution().largestPalindrome(range(1, 100)) == 1204\n\n    assert Solution().largestPalindrome(range(1, 1000)) == 232792560\n\n    assert Solution().largestPalindrome(range(1, 10000)) == 3628800\n\n    assert Solution().largestPalindrome(range(1, 1000000)) == 6291456",
      -3.513671875
    ],
    [
      "# Definition for a palindromic number.\nclass Palindromic(object):\n    def __init__(self, num):\n        \"\"\"\n        :type num: List[int]\n        \"\"\"\n        self.num = num\n\n    def is_palindromic(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.num) == 0:\n            return False\n        if len(self.num) == 1:\n            return True\n\n        for i in range(len(self.num) - 1):\n            if self.num[i]!= self.num[len(self.num) - 1 - i]:\n                return False\n\n        return True\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.largestPalindrome(nums)\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                return nums[i]\n            else:\n                return nums[i + 1]\n\n        return nums[len(nums) - 1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.largestPalindrome([1, 2, 3]) == 3\n    assert s.largestPalindrome([1, 2, 3, 4]) == 4\n    assert s.largestPalindrome([1, 2, 3, 4, 5]) == 5\n    assert s.largestPalindrome([1, 2, 3, 4, 5, 6]) == 6\n    assert s.largestPalindrome([1, 2, 3, 4, 5, 6, 7]) == 7\n    assert s.largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8]) == 8\n    assert s.largestPalindrome([1",
      -3.61328125
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_num = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if nums[i] == nums[j]:\n                if nums[i] > max_num:\n                    max_num = nums[i]\n                if nums[j] > max_num:\n                    max_num = nums[j]\n                if nums[i] < nums[j]:\n                    max_num = nums[i]\n    return max_num\n\nif __name__ == '__main__':\n    print(largestPalindrome([1, 2, 3, 4, 5]))\n    print(largestPalindrome([1, 2, 3, 4, 5, 6]))",
      -3.8125
    ],
    [
      "from collections import Counter\n\n\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # the max palindromic number is the first max number, then the next max number is the second max number\n        max_val = -1\n        for num in nums:\n            if max_val == -1:\n                max_val = num\n                continue\n            while num < max_val:\n                if num == max_val:\n                    max_val = num\n                elif num < max_val:\n                    max_val = num\n            if num == max_val:\n                max_val = num\n        return max_val\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print Solution().largestPalindrome(nums)",
      -4.0
    ],
    [
      "import math\n\ndef largest_palindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # max_len = int(math.ceil(math.sqrt(len(nums))))\n    max_len = int(math.ceil(math.sqrt(len(nums))))\n    for i in range(max_len, 0, -1):\n        for j in range(max_len, 0, -1):\n            if i*j == len(nums):\n                return nums[i*j-1]\n    return nums[0]\n\nif __name__ == \"__main__\":\n    print(largest_palindrome([1, 2, 3]))\n    print(largest_palindrome([1, 2, 3, 4]))\n    print(largest_palindrome([1, 2, 3, 4, 5]))\n    print(largest_palindrome([1, 2, 3, 4, 5, 6]))\n    print(largest_palindrome([1, 2, 3, 4, 5, 6, 7]))",
      -4.04296875
    ],
    [
      "import os\nimport time\nimport random\n\ndef largest_palindromic_number(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = arr[0]\n    max_idx = 0\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]:\n            max_val = max(max_val, arr[i])\n        else:\n            max_val = max(max_val, arr[i])\n            max_idx = i\n    return max_val\n\nif __name__ == '__main__':\n    start_time = time.time()\n    arr = [random.randint(1, 100) for i in range(1000)]\n    print('arr = {}'.format(arr))\n    print('largest_palindromic_number(arr) = {}'.format(largest_palindromic_number(arr)))\n    print('Time elapsed: {}'.format(time.time() - start_time))",
      -4.1015625
    ],
    [
      "import math\n\ndef largestPalindromic(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = 0\n    for i in range(len(numbers)):\n        for j in range(len(numbers)):\n            if numbers[i] == numbers[j] and (i < j or numbers[i] < numbers[j]):\n                max_val = max(max_val, numbers[i])\n    return max_val\n\ndef main():\n    print(largestPalindromic([1, 2, 3, 4, 5]))\n    print(largestPalindromic([1, 2, 3, 4, 5, 6]))\n    print(largestPalindromic([1, 2, 3, 4, 5, 6, 7]))\n    print(largestPalindromic([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(largestPalindromic([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(largestPalindromic([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\nif __name__ == '__main__':\n    main()",
      -4.2109375
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t\n\t# @param {integer[]} nums\n\t# @return {integer}\n\tdef largestPalindrome(self, nums):\n\t\tif len(nums) == 0:\n\t\t\treturn 0\n\t\t\n\t\t# the largest palindrome must be the largest even number\n\t\t# the largest palindrome must be the largest odd number\n\t\t# so the largest palindrome is the maximum of the two\n\t\t# the largest palindrome is the maximum of the two\n\t\tmax_n = max(nums)\n\t\tmax_p = max_n\n\t\tmax_p_rev = max_n\n\t\tfor i in range(max_p):\n\t\t\tfor j in range(i+1, max_p):\n\t\t\t\tnum = nums[i] * nums[j]\n\t\t\t\tif num > max_n:\n\t\t\t\t\tmax_n = num\n\t\t\t\t\tmax_p = max_p_rev\n\t\t\t\t\tmax_p_rev = nums[i] * nums[j]\n\t\treturn max_p\n\t\n\t# @param {TreeNode} root\n\t# @return {integer}\n\tdef largestPalindromeRecursive(self, root):\n\t\tif root == None:\n\t\t\treturn 0\n\t\t\n\t\t# get the largest palindrome using the recursive method\n\t\t# the largest palindrome is the maximum of the two\n\t\t# the largest palindrome is the maximum of the two\n\t\t# so the largest palindrome is the maximum of the two\n\t\treturn max(self.largestPalindromeRecursive(root.left), self.largestPalindromeRecursive(root.right))\n\t\n\t# @param {TreeNode} root\n\t# @return {integer}\n\tdef largestPalindromeIterative(self, root):\n\t\tif root == None:\n\t\t\treturn 0\n\t\t\n\t\t# get the largest palindrome using the iterative method\n\t\t# the largest palindrome is the maximum of the two\n\t\t# the largest palindrome is the maximum of the two\n\t\t# so the largest",
      -4.2265625
    ],
    [
      "def find_largest_palindromic(nums):\n    return max(map(lambda x: palindromic(x), nums))\n\ndef palindromic(x):\n    if len(x) == 0:\n        return None\n    return x[0] == x[-1] and palindromic(x[1:-1])\n\nif __name__ == '__main__':\n    assert find_largest_palindromic([1, 2, 3]) == 3\n    assert find_largest_palindromic([2, 3, 4]) == 4\n    assert find_largest_palindromic([3, 4, 5]) == 5\n    assert find_largest_palindromic([5, 6, 7]) == 7\n    assert find_largest_palindromic([7, 6, 5]) == 7\n    assert find_largest_palindromic([6, 7, 5]) == 7\n    assert find_largest_palindromic([6, 7, 8]) == 8\n    assert find_largest_palindromic([6, 7, 9]) == 9\n    assert find_largest_palindromic([6, 7, 8, 9]) == 9\n    assert find_largest_palindromic([6, 7, 8, 8]) == 8",
      -4.2421875
    ],
    [
      "# https://www.hackerrank.com/challenges/largest-palindrome\n# https://www.hackerrank.com/challenges/largest-palindrome-2\n# https://www.hackerrank.com/challenges/largest-palindrome-3\n# https://www.hackerrank.com/challenges/largest-palindrome-4\n\n# Function to find the largest palindromic number in the given array\ndef largest_palindromic(arr):\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [3,1,2,4,5,6,7,8,9]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,5,4,3,2,1]\n    # arr = [1,2,3,4,5,6,7,8,9]\n    # arr = [9,8,7,6,",
      -4.25390625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param {TreeNode[]} nodes\n\t# @return {integer}\n\tdef largestPalindrome(self, nodes):\n\t\tif len(nodes) == 0:\n\t\t\treturn 0\n\n\t\tmax_val = -1\n\t\tmax_node = None\n\t\tfor i in range(len(nodes)):\n\t\t\tfor j in range(i, len(nodes)):\n\t\t\t\tif self.is_palindrome(nodes[i], nodes[j]):\n\t\t\t\t\tif nodes[i].val > max_val:\n\t\t\t\t\t\tmax_val = nodes[i].val\n\t\t\t\t\t\tmax_node = nodes[i]\n\t\t\t\tif self.is_palindrome(nodes[j], nodes[i]):\n\t\t\t\t\tif nodes[j].val > max_val:\n\t\t\t\t\t\tmax_val = nodes[j].val\n\t\t\t\t\t\tmax_node = nodes[j]\n\n\t\treturn max_val\n\n\tdef is_palindrome(self, left, right):\n\t\tif left is None and right is None:\n\t\t\treturn True\n\n\t\tif left is None and right is not None:\n\t\t\treturn False\n\n\t\tif left is not None and right is None:\n\t\t\treturn False\n\n\t\tif left.val == right.val:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn self.is_palindrome(left.left, right.right) and self.is_palindrome(left.right, right.left)\n\ns = Solution()\n\nprint s.largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])",
      -4.29296875
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(len(nums)):\n            l = self.getLeft(nums, i)\n            r = self.getRight(nums, i)\n            if l <= r:\n                res = max(res, l*r)\n        return res\n\n    def getLeft(self, nums, i):\n        res = 0\n        while i > 0:\n            res += nums[i-1]\n            i -= 1\n        return res\n\n    def getRight(self, nums, i):\n        res = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.largestPalindrome([1, 2, 3, 4, 5, 6, 7]))",
      -4.74609375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    max_num = nums[0]\n    for num in nums:\n        if num < max_num:\n            max_num = num\n        else:\n            max_num = max(max_num, num)\n    return max_num\n\nprint(largestPalindrome([2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\nprint(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\nprint(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]))",
      -4.8828125
    ],
    [
      "# Approach 1: Brute Force\nclass Solution:\n    def largestPalindrome(self, nums: List[int]) -> int:\n        nums_len = len(nums)\n        nums_max = 0\n\n        for i in range(nums_len):\n            for j in range(i, nums_len):\n                if (nums[i] == nums[j]):\n                    if nums_max < j - i + 1:\n                        nums_max = j - i + 1\n\n        return nums_max\n\n    # Approach 2: Recursive\n    def largestPalindrome(self, nums: List[int]) -> int:\n        nums_len = len(nums)\n\n        if nums_len == 0:\n            return 0\n\n        elif nums_len == 1:\n            return nums[0]\n\n        else:\n            if nums[0] == nums[nums_len - 1]:\n                return nums[0]\n\n            elif nums[0] > nums[nums_len - 1]:\n                return self.largestPalindrome(nums[:nums_len - 1])\n\n            else:\n                return self.largestPalindrome(nums[1:])\n\n\n# Time:  O(n)\n# Space: O(n)\n#\n# Approach 3: Divide and Conquer\nclass Solution:\n    def largestPalindrome(self, nums: List[int]) -> int:\n        nums_len = len(nums)\n\n        if nums_len == 0:\n            return 0\n\n        elif nums_len == 1:\n            return nums[0]\n\n        else:\n            nums_max = 0\n            for i in range(0, nums_len - 1):\n                if nums[i] == nums[nums_len - 1 - i]:\n                    if nums_max < i + 1:\n                        nums_max = i + 1\n\n            return nums_max\n\n\n# Time:  O(n)\n# Space: O(1)\n#\n# Approach 4: Divide and Conquer + Backtracking\nclass Solution:\n    def largestPalindrome(self",
      -4.88671875
    ],
    [
      "#!/usr/bin/env python\n\n# Complete the function below.\ndef largestPalindrome(nums):\n    max_num = 0\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i == j:\n                if nums[i] > max_num:\n                    max_num = nums[i]\n            elif i < j:\n                if nums[i] * nums[j] > max_num:\n                    max_num = nums[i] * nums[j]\n    return max_num\n\n\nif __name__ == \"__main__\":\n    assert largestPalindrome([1,2,3,4]) == 1224, \"Invalid Input\"\n    assert largestPalindrome([1,1,1,1]) == 1, \"Invalid Input\"\n    assert largestPalindrome([1,2,3,4,5]) == 1524, \"Invalid Input\"\n    assert largestPalindrome([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]) == 524288, \"Invalid Input\"\n    assert largestPalindrome([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111",
      -4.9609375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        def largestPalindrome(num):\n            if num == 0:\n                return 0\n            elif num < 0:\n                return -num\n            elif num < len(str(num)):\n                return largestPalindrome(int(str(num)[::-1])) * num\n            else:\n                return largestPalindrome(num)\n\n        return largestPalindrome(nums[-1])\n\n\nif __name__ == '__main__':\n    print(Solution().largestPalindrome([1, 2, 3]))",
      -5.0625
    ],
    [
      "def largestPalindrome(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    \n    end = len(arr) - 1\n    start = 0\n    while start < end:\n        # find the largest palindromic number in the current range\n        mid = start + (end - start) / 2\n        # reverse the range\n        arr[start:mid] = arr[mid:end]\n        # find the largest palindromic number in the reversed range\n        end = mid - 1\n        start = mid\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range again\n        arr[start:end] = arr[end:start]\n        # find the largest palindromic number in the reversed range\n        start = 0\n        end = len(arr) - 1\n        # reverse the range",
      -5.109375
    ],
    [
      "def largestPalindromic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # find the first palindromic number in the array\n    i = 0\n    while i < len(arr):\n        # if the current number is not a palindromic, then move to the next number\n        if not is_palindromic(arr[i]):\n            i += 1\n            continue\n\n        # if the current number is a palindromic, then check to see if the next number is a palindromic too\n        if i < len(arr) - 1:\n            if not is_palindromic(arr[i + 1]):\n                i += 1\n                continue\n\n        # if the next number is a palindromic too, then we have found the largest palindromic number\n        return arr[i]\n\n\ndef is_palindromic(num):\n    \"\"\"\n    :type num: int\n    :rtype: bool\n    \"\"\"\n    # if the number is not a palindromic, then return false\n    if num < 0:\n        return False\n\n    # if the number is even, then return false\n    if num % 2 == 0:\n        return False\n\n    # if the number is odd, then convert to a string and reverse the string\n    str = str(num)\n    str = str.replace(\"0\", \"\")\n    str = str[::-1]\n\n    # if the string is the same as the original number, then return true\n    if str == str(num):\n        return True\n\n    # if the string is not the same as the original number, then return false\n    return False\n\n\n# test cases\narr = [2, 5, 7, 8, 13, 19, 26, 27, 29]\n\n# arr = [2, 5, 7, 8, 13, 19, 26, 27, 29]\n# arr = [3, 4, 5, 6, 7, 8, 9, 10, 11]\n\nprint(largestPalindromic(arr))",
      -5.1640625
    ],
    [
      "# TODO:\n# 1. find the largest palindromic number\n# 2. use the two pointers to find the largest palindromic number\n# 3. use a hash table to find the largest palindromic number\n\n# TODO:\n# 1. Use a binary search to find the largest palindromic number\n# 2. Use a dynamic programming to find the largest palindromic number\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a dynamic programming technique to find the largest palindromic number\n# 2. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination of the above two techniques\n\n# TODO:\n# 1. Use a combination of the above two techniques\n# 2. Use a combination of the above two techniques\n# 3. Use a combination",
      -5.171875
    ],
    [
      "import math\n\ndef largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(nums, key=lambda x: palindromic(x))\n\ndef palindromic(s):\n    if len(s) == 0:\n        return 0\n    \n    # get the sum of the digits of the largest palindromic number\n    nums = [int(x) for x in str(s)]\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n    \n    # get the largest palindromic number by comparing the sum of the digits\n    # of the largest palindromic number and the sum of the digits of the\n    # largest palindromic number\n    for i in range(len(nums)):\n        sum -= nums[i]\n    \n    return sum\n\nif __name__ == \"__main__\":\n    assert largestPalindrome([2,3,4,5,6,7]) == 7\n    assert largestPalindrome([4,4,4,4,4]) == 4\n    assert largestPalindrome([2,2,2,2]) == 2\n    assert largestPalindrome([2,3,4,5,6,7,8]) == 9\n    assert largestPalindrome([2,2,3,4,5,6,7]) == 7\n    assert largestPalindrome([2,2,3,4,5,6,7,8]) == 8\n    assert largestPalindrome([3,3,3,3,3,3]) == 3\n    assert largestPalindrome([1,2,3,4,5,6,7,8,9,10]) == 10",
      -5.32421875
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return largest_palindrome(nums, 0, len(nums) - 1)\n\n\ndef largest_palindrome(nums, left, right):\n    if right < left:\n        return 0\n\n    mid = left + (right - left) / 2\n    if nums[mid] == nums[right]:\n        return nums[right]\n\n    if mid - left + 1 == mid - left - 1:\n        return largest_palindrome(nums, left, mid - 1)\n\n    return max(largest_palindrome(nums, left, mid - 1), largest_palindrome(nums, mid + 1, right))\n\n\nif __name__ == \"__main__\":\n    print(largestPalindrome([1, 2, 3, 4, 5]))\n    print(largestPalindrome([1, 2, 3, 4, 5, 6]))\n    print(largestPalindrome([1, 2, 3, 4, 5, 6, 7]))\n    print(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(largestPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9]))",
      -5.91796875
    ],
    [
      "def palindrome_number(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    arr_len = len(arr)\n    # check all characters\n    for i in range(arr_len):\n        for j in range(i+1, arr_len):\n            if arr[i]!= arr[j]:\n                break\n            if i == j:\n                return arr[i]\n    return arr[0]\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 5]\n    print(palindrome_number(arr))",
      -6.1015625
    ],
    [
      "import unittest\n\ndef largest_palindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_len = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] == nums[j]:\n                max_len = max(max_len, j - i)\n    return max(max_len, len(nums))\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(largest_palindrome([1, 2, 3]), 3)\n        self.assertEqual(largest_palindrome([1, 2, 3, 1]), 4)\n        self.assertEqual(largest_palindrome([1, 2, 3, 4]), 4)\n        self.assertEqual(largest_palindrome([1, 2, 3, 4, 5]), 5)\n        self.assertEqual(largest_palindrome([1, 2, 3, 4, 5, 6]), 6)\n        self.assertEqual(largest_palindrome([1, 2, 3, 4, 5, 6, 7]), 7)\n\nif __name__ == '__main__':\n    unittest.main()",
      -6.57421875
    ],
    [
      "# TODO:\n# - write a function to find the largest palindromic number in the given array.\n# - implement this function using the previous two.\n\n# The largest palindrome in an array is the largest palindrome formed by\n# concatenating the elements of the array in order.\n# The palindrome formed by concatenating the elements of the array is\n# the largest palindrome if and only if it is a palindrome that is the\n# largest palindrome formed by concatenating the first n elements of the\n# array.\n#\n# For example, in the array [1, 2, 3, 4, 5], the largest palindrome formed\n# by concatenating the first 3 elements is 534, but the largest palindrome\n# formed by concatenating the first 4 elements is 1325.\n#\n# Write a function to find the largest palindrome in the given array.\n#\n# The largest palindrome in the given array is the largest palindrome formed\n# by concatenating the elements of the array in order.\n# The palindrome formed by concatenating the elements of the array is\n# the largest palindrome if and only if it is a palindrome that is the\n# largest palindrome formed by concatenating the first n elements of the\n# array.\n#\n# For example, in the array [1, 2, 3, 4, 5], the largest palindrome formed\n# by concatenating the first 3 elements is 534, but the largest palindrome\n# formed by concatenating the first 4 elements is 1325.\n\ndef largest_palindrome(nums):\n    return max(nums)\n\n\nif __name__ == '__main__':\n    assert largest_palindrome([1, 2, 3, 4, 5]) == 534\n    assert largest_palindrome([1, 2, 3, 4, 5, 6]) == 1325",
      -6.90234375
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    max_length = 0\n    max_palindrome = -1\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] * nums[j] == nums[j] * nums[i]:\n                if len(nums[i]) > max_length:\n                    max_length = len(nums[i])\n                    max_palindrome = nums[i] * nums[j]\n    return max_palindrome\n\n# Your code below:\n\n# Note:\n# You can assume that the given input is sorted.\n# If the input is not sorted, then you can use the following sorting algorithm:\n# sort(nums)\n# If the input is already sorted, then you can use the following algorithm:\n# for i from 0 to len(nums) - 1:\n#     for j from i+1 to len(nums) - 1:\n#         if nums[i] * nums[j] > nums[j] * nums[i]:\n#             swap(nums[i], nums[j])\n#             max_length = max(max_length, len(nums[i]) + len(nums[j]))\n#             max_palindrome = max(max_palindrome, nums[i] * nums[j])\n# return max_palindrome\n\n# Your code below:\n\n# Note:\n# If the input is not sorted, then you can use the following sorting algorithm:\n# sort(nums)\n# If the input is already sorted, then you can use the following algorithm:\n# for i from 0 to len(nums) - 1:\n#     for j from i+1 to len(nums) - 1:\n#         if nums[i] * nums[j] > nums[j] * nums[i]:\n#             swap(nums[i], nums[j])\n#             max_length",
      -7.07421875
    ],
    [
      "# https://leetcode.com/problems/largest-palindrome-product/discuss/2968/Python-solution-with-explanation-of-the-algorithm\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def largestPalindrome(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n\n        def is_palindromic(arr):\n            if not arr:\n                return True\n            s = str(arr[0])\n            for i in range(1, len(arr)):\n                s += str(arr[i])\n            return s == s[::-1]\n\n        def find_max(arr):\n            max_val = arr[0]\n            max_idx = 0\n            for i in range(1, len(arr)):\n                if arr[i] > max_val:\n                    max_val = arr[i]\n                    max_idx = i\n            return max_idx, max_val\n\n        def is_palindromic_sub(arr, start, end):\n            if start == end:\n                return True\n            if start >= end:\n                return False\n            mid = (start + end) / 2\n            if arr[mid] == arr[start]:\n                return is_palindromic_sub(arr, start + 1, mid - 1) or is_palindromic_sub(arr, mid + 1, end)\n            else:\n                return is_palindromic_sub(arr, mid + 1, end)\n\n        max_val, max_idx = find_max(arr)\n        for i in range(max_idx, 0, -1):\n            if is_palindromic_sub(arr, i, max_idx):\n                return arr[max_idx]\n\n        return arr[0]",
      -7.15625
    ],
    [
      "# https://www.hackerrank.com/challenges/largest-palindrome/problem\n#\n# The largest palindrome is a string that is the same as its reverse.\n#\n# For example, the largest palindrome is \"1221\" because \"1221\" is the reverse\n# of \"1221\".\n#\n# Write a function to find the largest palindromic number in the given array.\n#\n# Example:\n#\n# Input:\n# [1,2,3,4,5]\n#\n# Output:\n# 6\n#\n# Explanation:\n# The largest palindrome is \"1221\"\n#\n# Note:\n# The length of the given array is in range [1, 10000].\n# The given array only contains digits 0-9.\n#\n\n\nclass Solution:\n    # @param {integer[]} digits\n    # @return {integer}\n    def largestPalindrome(self, digits):\n        if not digits:\n            return 0\n        if not digits[0]:\n            return 1\n        # Use the first digit as the start point for the loop.\n        # This is because we want to find the largest palindrome\n        # starting from the first digit.\n        start = digits[0]\n        end = digits[0]\n        for i in range(1, len(digits)):\n            # Check if the current digit is palindrome.\n            if digits[i] == digits[i - 1]:\n                end = digits[i - 1]\n            else:\n                end = 0\n            # If the current digit is larger than the start point,\n            # then we have found a new largest palindrome.\n            if digits[i] > start:\n                return end\n            # Otherwise, we need to update the start point.\n            start = digits[i]\n\n        return end\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.largestPalindrome([1, 2, 3, 4, 5]))\n    print(s.largestPalindrome([1, 1, 2, 3, 3]))\n    print(s.largestPalindrome([1, 2, 3, 4, 5, 6, 7]))",
      -8.4609375
    ],
    [
      "# Your function should return the largest palindromic number.\n\n#!/usr/bin/python\n\nimport math\n\ndef largestPalindromic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Make sure the input is a list\n    if not isinstance(nums, list):\n        return 0\n\n    # Make sure the input is not empty\n    if len(nums) == 0:\n        return 0\n\n    # Make sure the input is a palindromic\n    if not all(str(num) == str(num)[::-1] for num in nums):\n        return 0\n\n    # Make sure the input is not a single number\n    if len(nums) == 1:\n        return nums[0]\n\n    # Find the largest number\n    max = nums[0]\n    for num in nums:\n        if num > max:\n            max = num\n\n    # Return the largest number\n    return max\n\nif __name__ == '__main__':\n    print(largestPalindromic([1, 2, 3]))\n    print(largestPalindromic([1, 3, 2]))\n    print(largestPalindromic([1, 3, 4]))\n    print(largestPalindromic([2, 1, 4]))\n    print(largestPalindromic([4, 3, 2]))\n    print(largestPalindromic([4, 3, 1]))\n    print(largestPalindromic([1, 4, 3]))\n    print(largestPalindromic([4, 3, 1]))\n    print(largestPalindromic([2, 1, 4]))\n    print(largestPalindromic([2, 4, 1]))\n    print(largestPalindromic([2, 4, 3]))\n    print(largestPalindromic([2, 3, 4]))\n    print(largestPalindromic([2, 3, 1]))\n    print(largestPalindromic([2, 1, 3]))\n    print(largestPalindromic([1, 4, 3]))\n    print(largestPalindromic([3",
      -8.515625
    ],
    [
      "import sys\n\n\ndef find_largest_palindromic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    result = arr[0]\n    for i in arr:\n        if i == result:\n            continue\n        if i > result:\n            result = i\n        elif i < result:\n            return i\n\n    return result\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_largest_palindromic(arr))\n\n    arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    print(find_largest_palindromic(arr))\n\n    arr = [1, 2, 3, 4, 5, 6, 7,",
      -8.828125
    ],
    [
      "def largestPalindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] == nums[r-mid]:\n            l = mid + 1\n            r = mid\n        else:\n            if nums[mid] > nums[r-mid]:\n                r = mid\n            else:\n                l = mid + 1\n    return nums[l-1]\n\n\nif __name__ == '__main__':\n    assert largestPalindrome([2, 3, 5, 9, 7, 2, 1, 9]) == 29\n    assert largestPalindrome([5, 2, 3, 4, 6]) == 6\n    assert largestPalindrome([]) == 0",
      -8.84375
    ],
    [
      "# https://www.hackerrank.com/challenges/largest-palindromic-number\n# http://www.geeksforgeeks.org/largest-palindromic-substring/\n# http://www.geeksforgeeks.org/largest-palindromic-substring-with-odd-length/\n# https://www.youtube.com/watch?v=cHZ3Bfzqg6o\n\ndef largest_palindromic_substring(arr):\n    # Sort the input array\n    arr.sort()\n\n    # Find the largest palindromic substring\n    max_substring = ''\n    for i in range(len(arr)):\n        # If the current index is the end of the substring,\n        # then move to the next substring\n        if i+1 == len(arr):\n            continue\n\n        # If the current index is the start of the substring,\n        # then move to the next substring\n        if arr[i]!= arr[i+1]:\n            continue\n\n        # If the current index is the middle of the substring,\n        # then find the maximum substring\n        max_substring = max(max_substring, arr[i:i+2])\n\n    # Return the largest palindromic substring\n    return max_substring\n\n\nif __name__ == '__main__':\n    print(largest_palindromic_substring([1, 2, 3, 4, 5, 6, 7, 8, 9]))",
      -9.5546875
    ],
    [
      "def largestPalindrome(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = 0\n    max_index = 0\n    for i in range(len(numbers)):\n        for j in range(len(numbers)-i-1):\n            if numbers[i] == numbers[j]:\n                if numbers[i] > max_val:\n                    max_val = numbers[i]\n                    max_index = i\n        \n    if max_val > max_index:\n        return numbers[max_index]\n    else:\n        return numbers[max_index]\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(largestPalindrome(numbers))",
      -10.0
    ],
    [
      "# https://leetcode.com/problems/largest-palindrome-product/discuss/81721/Java-O(N)-Time-JavaScript-Solution\nclass Solution(object):\n    def largestPalindrome(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        p1 = 1\n        p2 = 1\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                p1 = p1 * -1\n            else:\n                p1 *= nums[i]\n            if nums[i] < 0:\n                p2 = p2 * -1\n            else:\n                p2 *= nums[i]\n            if p1 == p2:\n                return p1\n        return p1\n\nif __name__ == \"__main__\":\n    print(Solution().largestPalindrome([-2,1,-3,4,-1,2,1,-5]))",
      -10.3359375
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def isPalindrome(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num < 0:\n            return False\n        if num == 0:\n            return True\n        mid = int(len(str(num))/2)\n        if num == num[::-1][:mid]:\n            return True\n        return self.isPalindrome(num[:mid] + num[mid+1:])\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/largest-palindrome-number/solution/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n# 6ms 100%\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String str = String.valueOf(x);\n        int start = 0;\n        int end = str.length()-1;\n        while(start < end){\n            if(str.charAt(start)!= str.charAt(end)){\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n}\n'''",
      -10.65625
    ],
    [
      "def is_palindromic(nums):\n  \"\"\"\n  >>> is_palindromic([-1,2,3,4,5])\n  False\n  >>> is_palindromic([-1,2,3,4,5,6])\n  True\n  >>> is_palindromic([1])\n  False\n  >>> is_palindromic([1,2])\n  True\n  >>> is_palindromic([1,2,3,4,5,6,7,8,9,10])\n  True\n  \"\"\"\n  if len(nums) == 0:\n    return False\n  \n  if len(nums) == 1:\n    return True\n  \n  if len(nums) == 2:\n    if nums[0] < 0:\n      return False\n    else:\n      return True\n  \n  # for the first half of the number\n  if nums[0] < 0:\n    if is_palindromic(nums[1:]) and nums[0] > nums[-1]:\n      return True\n    else:\n      return False\n  \n  if nums[-1] < 0:\n    if is_palindromic(nums[:-1]) and nums[-1] > nums[0]:\n      return True\n    else:\n      return False\n  \n  # for the second half of the number\n  if nums[0] > nums[-1]:\n    if is_palindromic(nums[1:-1]) and nums[0] < nums[-1]:\n      return True\n    else:\n      return False\n  else:\n    if is_palindromic(nums[1:-1]) and nums[0] > nums[-1]:\n      return True\n    else:\n      return False\n\ndef main():\n  print(is_palindromic([-1,2,3,4,5]))\n  print(is_palindromic([-1,2,3,4,5,6]))\n  print(is_palindromic([1]))\n  print(is_palindromic",
      -10.6875
    ],
    [
      "# @include\ndef largest_palindromic(nums):\n    \"\"\"\n    Returns the largest palindromic number in the given array.\n\n    :param nums: The list of numbers to find the largest palindromic number in.\n    \"\"\"\n    # The largest palindromic number is the one that is palindromic\n    # in both directions.\n    for i in range(0, len(nums) - 1):\n        # The largest palindromic number is the one that is palindromic\n        # in both directions.\n        if nums[i] == nums[len(nums) - i - 1]:\n            return nums[i]\n\n# @exclude\n\n\nclass TestCode:\n    def test_largest_palindromic(self):\n        assert largest_palindromic([1, 2, 3]) == 3\n        assert largest_palindromic([-1, -2, -3]) == 3\n        assert largest_palindromic([-3, -2, -1]) == 3\n        assert largest_palindromic([-3, -2, -1, -2, -3]) == 3\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4]) == 4\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4, -5]) == 5\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4, -5, -6]) == 6\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4, -5, -6, -7]) == 7\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4, -5, -6, -7, -8]) == 8\n        assert largest_palindromic([-3, -2, -1, -2, -3, -4, -5, -6, -7, -8, -9]) == 9\n        assert largest_palindromic([-3, -2,",
      -10.6875
    ],
    [
      "# https://oj.leetcode.com/problems/largest-palindrome-product/\n# Given a string, find the largest palindrome made from the product of two 2-digit numbers.\n# For example, given \"b\" and \"c\", the largest palindrome made from the product of these two 2-digit numbers is \"ccb\".\n#\n# Note:\n# The string may only contain lowercase characters a-z.\n# The palindrome product of any two valid palindromes is also a valid palindrome.\n# Example 1:\n#\n# Input:\n# [\"b\", \"a\", \"c\", \"d\", \"e\", \"e\", \"a\", \"h\", \"a\", \"h\", \"a\"]\n# Output: \"eecb\"\n# Example 2:\n#\n# Input:\n# [\"a\", \"b\", \"a\", \"c\", \"b\", \"c\", \"a\"]\n# Output: \"cb\"\n# Example 3:\n#\n# Input:\n# [\"c\", \"b\", \"b\", \"a\", \"c\", \"a\", \"c\", \"a\", \"c\", \"b\", \"b\", \"c\"]\n# Output: \"cba\"\n#\n# Note:\n# The string contains only lowercase characters.\n# The length of the given string is in the range [2, 500].\n# The answer is guaranteed to fit into the range of 32-bit signed integer.\n\nclass Solution:\n    # @return a string\n    def largestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # use the same way to write the problem\n        # https://leetcode.com/problems/largest-palindrome-product/discuss/417844/C++-solution-with-explanation\n        # https://leetcode.com/problems/largest-palindrome-product/discuss/417844/C++-solution-with-explanation\n        # https://leetcode.com/problems/largest-palindrome-product/discuss/417844/C++-solution-with-explanation\n        # https://leetcode.com",
      -11.1953125
    ],
    [
      "# -*- coding: utf-8 -*-\n\n#threshold = int(input())\n#arr = [int(x) for x in input().split()]\n#print(largest_palindrome(arr, threshold))\n\ndef largest_palindrome(arr, threshold):\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                if arr[i] > arr[j]:\n                    arr[i] = arr[j]\n    for i in range(n-1):\n        for j in range(i+1, n",
      -11.546875
    ],
    [
      "import math\n\ndef largest_palindromic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # base case\n    if len(nums) == 0:\n        return 0\n\n    # find the maximum number in the left half\n    max_left = largest_palindromic(nums[:len(nums)/2])\n\n    # find the maximum number in the right half\n    max_right = largest_palindromic(nums[len(nums)/2:])\n\n    # get the product of the two\n    product = int(math.factorial(len(nums)))\n    # get the max product of the two\n    max_product = max(max_left * max_right, max_left, max_right)\n\n    # if the product is one, then the max is one\n    if product == 1:\n        return 1\n    # else return the product of the max\n    else:\n        return max_product\n\nif __name__ == '__main__':\n    # test cases\n    test_cases = [[1,1], [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]\n    for test in test_cases:\n        print(\"{} -> {}\".format(test, largest_palindromic(test)))",
      -11.6171875
    ],
    [
      "def largestPalindromic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    l, r = 0, len(arr) - 1\n    while l < r:\n        mid = (l + r) / 2\n        if arr[mid] < arr[r - mid]:\n            r = mid\n        else:\n            l = mid + 1\n    return arr[l]\n\nprint(largestPalindromic([-1, -2, -3, -4, -5, -6, -7, -8, -9]))\nprint(largestPalindromic([-1, 0, -2, 0, -3, 0, -4, 0, -5]))\nprint(largestPalindromic([-1, 1, -2, 2, -3, 3, -4, 4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))\nprint(largestPalindromic([-1, -1, -2, -2, -3, -3, -4, -4, -5]))",
      -12.0546875
    ],
    [
      "import math\n\n\ndef largest_palindrome(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(largest_palindrome_recursive(nums), largest_palindrome_iterative(nums))\n\n\ndef largest_palindrome_recursive(nums):\n    if len(nums) < 2:\n        return nums[0] if len(nums) == 1 else 0\n\n    max_nums = largest_palindrome_recursive(nums[:len(nums)//2])\n    mid = len(nums)//2\n    max_nums = max(max_nums, largest_palindrome_recursive(nums[mid:]) + nums[:mid])\n\n    return max_nums if len(nums) % 2 == 0 else max_nums + nums[-1]\n\n\ndef largest_palindrome_iterative(nums):\n    if len(nums) < 2:\n        return nums[0] if len(nums) == 1 else 0\n\n    max_nums = largest_palindrome_iterative(nums[:len(nums)//2])\n    mid = len(nums)//2\n    max_nums = max(max_nums, largest_palindrome_iterative(nums[mid:]) + nums[:mid])\n\n    return max_nums if len(nums) % 2 == 0 else max_nums + nums[-1]\n\n\nif __name__ == '__main__':\n    nums = [2, 3, 5, 8, 11, 13]\n    print(largest_palindrome(nums))",
      -13.078125
    ],
    [
      "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def largestPalindrome(self, nums):\n        if not nums:\n            return 0\n        \n        max_num = 0\n        max_index = 0\n        \n        for i in range(len(nums) - 1):\n            tmp = self.findPalindrome(nums, i, i + 1)\n            if tmp > max_num:\n                max_num = tmp\n                max_index = i\n            \n        return max_num\n    \n    def findPalindrome(self, nums, left, right):\n        if left > right:\n            return 0\n        \n        mid = (left + right) / 2\n        \n        if nums[mid] > nums[mid + 1]:\n            if mid == left:\n                return nums[mid]\n            else:\n                return self.findPalindrome(nums, left, mid - 1)\n        else:\n            return self.findPalindrome(nums, mid + 1, right)",
      -14.515625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}