{
  "problem": {
    "task_id": "MBPP/114",
    "prompt": "Write a function to assign frequency to each tuple in the given tuple list.",
    "canonical_solution": "from collections import Counter \r\ndef assign_freq(test_list):\r\n  res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res)) ",
    "test_list": [
      "assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'",
      "assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'",
      "assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'"
    ],
    "challenge_test_list": [],
    "problem_id": 103
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def frequency(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuples:\n        return []\n    freq = {}\n    for t in tuples:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n    res = []\n    for t in freq:\n        res.append((t, freq[t]))\n    res.sort(key=lambda x: x[1], reverse=True)\n    return res\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (1, 3), (1, 2), (2, 4), (2, 5), (2, 5), (3, 5), (3, 4)]\n    print(frequency(tuples))",
      6.0625
    ],
    [
      "def frequency(tupList):\n    \"\"\"\n    :type tupList: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    freqDict = {}\n    for tup in tupList:\n        if tup not in freqDict:\n            freqDict[tup] = 1\n        else:\n            freqDict[tup] += 1\n\n    res = []\n    for k, v in freqDict.items():\n        res.append((k, v))\n    return res\n\n\n# Your frequency function will be called like this:\n# frequency(tuples)\n# freqDict = frequency(tuples)\n# For example, your function should return [('a', 2), ('b', 2)]\n# when tuples = [(1,2), (2,3)]",
      5.8046875
    ],
    [
      "class Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] > nums[j]:\n                    ans.append((i, j, nums[i]))\n                    ans.append((j, i, nums[j]))\n        for i in range(n):\n            ans.append((i, i, 1))\n        ans.sort(key=lambda x: x[1])\n        ans.sort(key=lambda x: x[0])\n        for i in range(k):\n            ans.append((i, n, 1))\n        return ans",
      2.453125
    ],
    [
      "def frequency(tupList):\n    \"\"\"\n    :type tupList: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    freq = {}\n    for tup in tupList:\n        if tup in freq:\n            freq[tup] += 1\n        else:\n            freq[tup] = 1\n    return sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\nif __name__ == \"__main__\":\n    tupList = [(1, 2), (2, 3), (3, 4), (2, 3), (1, 2)]\n    print(frequency(tupList))",
      1.857421875
    ],
    [
      "def frequency(tuple_list):\n    if not tuple_list:\n        return []\n\n    freq = {}\n    for tuple in tuple_list:\n        if tuple not in freq:\n            freq[tuple] = 1\n        else:\n            freq[tuple] += 1\n\n    return sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2, 3), (1, 2, 4), (2, 3, 4), (1, 1, 1), (2, 2, 2)]\n    frequency(tuple_list)",
      1.064453125
    ],
    [
      "from collections import defaultdict\nimport time\n\ndef build_freq_dict(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_2(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_3(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_4(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_5(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_6(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples.\n    \"\"\"\n    freq_dict = defaultdict(lambda: 0)\n    for tup in tup_list:\n        freq_dict[tup] += 1\n    return freq_dict\n\ndef build_freq_dict_7(tup_list):\n    \"\"\"\n    Build a dictionary from a list of tuples",
      0.939453125
    ],
    [
      "import collections\n\n\nclass Solution:\n\n    def assignFrequency(self, nums: List[int], k: int) -> List[List[int]]:\n        freq = collections.defaultdict(int)\n        for num in nums:\n            freq[num] += 1\n\n        res = []\n        for num in freq:\n            res.append([num] + [freq[num]] * k)\n        return res",
      0.1346435546875
    ],
    [
      "#!/usr/bin/env python\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    freq = {}\n    for t in tuples:\n        if t in freq:\n            freq[t] += 1\n        else:\n            freq[t] = 1\n    return freq.items()\n\n# Your assigned function should return the same value as the\n# function below.\ndef assign_frequency2(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    freq = []\n    for t in tuples:\n        freq.append((t, 1))\n    return freq",
      0.131103515625
    ],
    [
      "def count_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[int]\n    \"\"\"\n    frequency = [0] * len(tuple_list)\n    for t in tuple_list:\n        frequency[t[0]] += 1\n    return frequency\n\n\n# Your Code Goes Here\n\ndef count_frequency2(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[int]\n    \"\"\"\n    frequency = [0] * len(tuple_list)\n    for t in tuple_list:\n        frequency[t[0]] += 1\n    return frequency\n\n\nif __name__ == '__main__':\n    print count_frequency([(1, 2), (1, 2), (3, 4)])\n    print count_frequency2([(1, 2), (1, 2), (3, 4)])",
      0.09912109375
    ],
    [
      "class Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.nums = nums\n        self.dict = {}\n        for i in xrange(len(nums)):\n            self.dict[nums[i]] = i\n\n    def assign(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)):\n            nums[i] = self.dict[nums[i]]\n        return nums\n\nif __name__ == \"__main__\":\n    assert Solution().assign([1, 2, 3]) == [0, 1, 2]\n    assert Solution().assign([1, 2, 3, 4]) == [0, 1, 2, 3]\n    assert Solution().assign([1, 2, 3, 4, 5]) == [0, 1, 2, 3, 4]\n    assert Solution().assign([1, 2, 3, 4, 5, 6]) == [0, 1, 2, 3, 4, 5]\n    assert Solution().assign([1, 2, 3, 4, 5, 6, 7]) == [0, 1, 2, 3, 4, 5, 6]",
      -0.0986328125
    ],
    [
      "from collections import defaultdict\n\ndef get_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: dict[tuple, int]\n    \"\"\"\n    frequency = defaultdict(int)\n    for i, tuple_ in enumerate(tuple_list):\n        frequency[tuple_] += 1\n    return frequency\n\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert get_frequency([(1, 2), (1, 3), (2, 3), (1, 2), (2, 3), (1, 2), (2, 3)]) == {(1, 2): 2, (1, 3): 1, (2, 3): 2, (1, 2): 1, (2, 3): 1, (1, 2): 1, (2, 3): 1}, \"Frequency of a correct tuple list is returned\"\n    assert get_frequency([]) == {}, \"Empty tuple list should return empty dict\"\n    assert get_frequency([(1, 2), (1, 3), (2, 3)]) == {(1, 2): 3, (1, 3): 2, (2, 3): 2}, \"Frequency of a tuple list with duplicates should be the same as the tuple list with no duplicates\"",
      -0.307373046875
    ],
    [
      "def frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    frequency = [0] * len(tuple_list)\n    for tuple in tuple_list:\n        frequency[tuple[0]] += 1\n    return frequency\n\nif __name__ == '__main__':\n    print(frequency([(1, 2), (2, 3), (1, 3)]))",
      -0.85693359375
    ],
    [
      "def assign_frequency(tuple_list):\n\t\"\"\"\n\t:type tuple_list: List[Tuple]\n\t:rtype: List[Tuple]\n\t\"\"\"\n\t# write your code here\n\t\n\t# create a dictionary\n\tdic = {}\n\tfor tup in tuple_list:\n\t\tif tup[0] in dic:\n\t\t\tdic[tup[0]] += 1\n\t\telse:\n\t\t\tdic[tup[0]] = 1\n\t\n\t# return the new list\n\treturn dic.items()",
      -0.85693359375
    ],
    [
      "from typing import List\n\n\ndef assign_frequency(tuples: List[tuple]) -> None:\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: None\n    \"\"\"\n    for t in tuples:\n        t[1] += 1",
      -0.85693359375
    ],
    [
      "from collections import defaultdict\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    freq = defaultdict(int)\n    for t in tuples:\n        freq[t] += 1\n    return [t for t in tuples if freq[t] == 1]",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def maxFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        # max_freq = max([max(nums[i]) for i in range(n)])\n        max_freq = 0\n        for i in range(n):\n            max_freq = max(max_freq, nums[i])\n        max_freq += 1\n        for i in range(n):\n            nums[i] = max_freq\n        return max_freq",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def frequencySort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) < 2:\n            return nums\n        nums.sort()\n        result = []\n        for i in range(len(nums)):\n            result.append(nums[i])\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    result[i] += result[j]\n        return result\n\nif __name__ == \"__main__\":\n    nums = [1,1,2,2,3,3]\n    print(Solution().frequencySort(nums))",
      -0.85693359375
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution(object):\n    def __init__(self, nums):\n        self.nums = nums\n\n    def sort(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        nums = self.nums\n        if not nums:\n            return []\n\n        nums.sort()\n        result = []\n        for num in nums:\n            result.append(num)\n        return result\n\n\nif __name__ == \"__main__\":\n    nums = [3, 2, 1, 4]\n    sol = Solution(nums)\n    print sol.sort()",
      -0.85693359375
    ],
    [
      "from collections import defaultdict\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    frequency = defaultdict(int)\n    for t in tuples:\n        frequency[t] += 1\n    return [(t, frequency[t]) for t in sorted(frequency.keys())]",
      -0.85693359375
    ],
    [
      "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'id frequency')\n\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return [(tuple, 1) for tuple in tuples]\n\n\n# Your assigned code here.",
      -0.85693359375
    ],
    [
      "def assign_frequency(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    freq = {}\n    for tuple in list_of_tuples:\n        if tuple in freq:\n            freq[tuple] += 1\n        else:\n            freq[tuple] = 1\n    return freq.items()",
      -0.85693359375
    ],
    [
      "from collections import defaultdict\n\ndef frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    \n    frequency_map = defaultdict(int)\n    for t in tuple_list:\n        frequency_map[t] += 1\n    return [t for t, freq in frequency_map.items() if freq == 1]",
      -0.85693359375
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return [list(t) for t in tuple_list]\n\nif __name__ == '__main__':\n    l = [('a', 1), ('b', 2), ('c', 3)]\n    l = assign_frequency(l)\n    print(l)",
      -0.85693359375
    ],
    [
      "import collections\n\n# your code goes here\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        curr_freq = collections.Counter(t).most_common(1)[0][1]\n        result.append((t, curr_freq))\n    return result",
      -0.85791015625
    ],
    [
      "def tuple_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuple_list:\n        return []\n    frequency = {}\n    for i in range(len(tuple_list)):\n        frequency[tuple_list[i]] = frequency.get(tuple_list[i], 0) + 1\n    return list(frequency.items())\n\nif __name__ == \"__main__\":\n    tuple_list = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1), ('f', 1)]\n    print(tuple_frequency(tuple_list))",
      -0.85791015625
    ],
    [
      "def assign_frequency(tuples):\n  \"\"\"\n  :type tuples: List[List[int]]\n  :rtype: List[List[int]]\n  \"\"\"\n  freq = {}\n  for t in tuples:\n    if t in freq:\n      freq[t] += 1\n    else:\n      freq[t] = 1\n  return sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\n# TESTS\nfor t in [([1, 2, 3], [2, 1, 1]), ([1, 2, 3, 3], [1, 1, 1, 1]), ([1, 1, 1], [1])]:\n  assert assign_frequency(t) == t",
      -0.85791015625
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def assignFreq(self, frequency: List[int], nums: List[int]) -> List[int]:\n        \"\"\"\n        :type frequency: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i, num in enumerate(nums):\n            frequency[num] += 1\n        return [f for f in frequency if f > 0]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.assignFreq([1, 1, 1], [1, 2, 3]))\n    print(sol.assignFreq([1, 1, 1], [1, 2, 3, 4]))",
      -0.85791015625
    ],
    [
      "# https://leetcode.com/problems/assign-frequency-to-the-tuple/\n\nclass Solution(object):\n    def assignFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # sort and then count\n        nums.sort()\n        nums.reverse()\n        freq = [0] * len(nums)\n        for n in nums:\n            freq[n] += 1\n\n        # assign frequency\n        for i in range(len(nums)):\n            nums[i] = freq[i] * k",
      -0.85791015625
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    # TODO\n    return []\n\nif __name__ == '__main__':\n    tuple_list = [(1,2,3,4), (1,2,3,4), (1,2,3,4)]\n    tuple_list = [(1,2,3,4), (1,2,3,4), (1,2,3,4), (1,2,3,4), (1,2,3,4), (1,2,3,4)]\n    print(assign_frequency(tuple_list))",
      -0.85791015625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 1\n\nclass Solution(object):\n    def assignFrequency(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        # Sort the tuples.\n        tuples = sorted(tuples, key=lambda t: t.x)\n        # Use a dictionary to store the frequency.\n        freq = {}\n        for t in tuples:\n            if t.x in freq:\n                freq[t.x] += t.y\n            else:\n                freq[t.x] = t.y\n        # Return the frequency.\n        return [t for t in tuples if t.x in freq]\n\n# Note:\n# 1. This is a simple problem.\n# 2. This solution is not elegant.\n# 3. The solution is not efficient.\n# 4. The solution does not take advantage of the fact that the frequency of each\n#    tuple is sorted.",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def getFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        freq = collections.defaultdict(int)\n        for num in nums:\n            freq[num] += 1\n        freq = [freq[num] for num in nums]\n        freq.sort(reverse=True)\n        ans = []\n        for i in range(len(freq)):\n            ans.append(freq[i] / k)\n        return ans\n\na = Solution()\nprint(a.getFrequency([1, 2, 3, 4], 2))",
      -0.85791015625
    ],
    [
      "import collections\n\ndef assign_freq(tuple_list):\n    \"\"\"\n    Assign frequency to each tuple in the given tuple list.\n\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    freq_dict = collections.Counter(tuple_list)\n    return [freq_dict[tuple_] for tuple_ in freq_dict.keys()]",
      -0.85791015625
    ],
    [
      "# https://oj.leetcode.com/problems/assign-frequency/\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {void} Do not return anything, modify head in-place instead.\n    def assignFrequency(self, head):\n        # write your code here\n        if head is None:\n            return\n\n        freq = [1] * 26\n        freq[ord('a') - ord('A')] = 0\n        self.assignFrequency(head, freq)\n\n    def assignFrequency(self, head, freq):\n        if head is None:\n            return\n\n        curr = head\n        while curr is not None:\n            freq[ord(curr.val) - ord('a')] += 1\n            curr = curr.next\n        \n        if head.next is not None:\n            self.assignFrequency(head.next, freq)\n        \n        curr = head\n        while curr is not None:\n            curr.val = chr(ord(curr.val) + 1)\n            curr = curr.next",
      -0.85791015625
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int]]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    freq = []\n    for i in range(len(tuple_list)):\n        freq.append((tuple_list[i], 1))\n    return freq\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (1, 2), (1, 2)]\n    print assign_frequency(tuple_list)\n    tuple_list = [(1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    print assign_frequency(tuple_list)",
      -0.85791015625
    ],
    [
      "import collections\nimport math\n\ndef frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return collections.Counter(tuple_list).most_common()\n\nif __name__ == '__main__':\n    print(frequency([(1, 2), (1, 1), (2, 1), (2, 2)]))",
      -0.8583984375
    ],
    [
      "from collections import Counter\nfrom math import log10\n\n\ndef frequency_to_tuple(tuple_list, frequency_dict):\n    \"\"\"\n    Given a tuple list and a frequency dict, assign frequency to each tuple.\n    Input:\n        tuple_list: A tuple list.\n        frequency_dict: A dict mapping tuple to a frequency.\n    Output:\n        A tuple list of tuples with assigned frequency.\n    \"\"\"\n    for t in tuple_list:\n        frequency_dict[t] = frequency_dict.get(t, 0) + 1\n\n    for t in tuple_list:\n        frequency_dict[t] = round(frequency_dict[t] / len(tuple_list), 2)\n\n    return tuple(frequency_dict.items())\n\n\ndef main():\n    tuple_list = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    frequency_dict = Counter(tuple_list)\n    print(frequency_to_tuple(tuple_list, frequency_dict))\n\n    tuple_list = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    frequency_dict = Counter(tuple_list)\n    print(frequency_to_tuple(tuple_list, frequency_dict))\n\n\nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "def frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    # write your code here\n    frequency_list = []\n    for tup in tuple_list:\n        frequency_list.append(tup)\n    frequency_list.sort()\n    return frequency_list\n\nif __name__ == '__main__':\n    print(frequency([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2)]))\n    print(frequency([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]))\n    print(frequency([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (2, 4)]))",
      -0.8583984375
    ],
    [
      "from collections import Counter\n\n\ndef frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    c = Counter(tuple_list)\n    return [c.get(tuple_list[i], 0) for i in range(len(tuple_list))]\n\n\ndef main():\n    tuple_list = [\n        (\"a\", \"b\", \"c\"),\n        (\"a\", \"b\", \"c\"),\n        (\"a\", \"b\", \"c\")\n    ]\n    print(frequency(tuple_list))\n\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/assign-frequency/discuss/263821/Python-DP-solution-using-nested-for-loop\n\nclass Solution:\n    def assignFrequency(self, nums: List[int]) -> None:\n        \"\"\"\n        Brute force solution.\n        \"\"\"\n        # dp[i] = sum of nums[0..i]\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                dp[i] += nums[j]\n        for i in range(len(nums)):\n            nums[i] = dp[i]",
      -0.85888671875
    ],
    [
      "import collections\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    frequency_map = collections.defaultdict(int)\n    for t in tuple_list:\n        frequency_map[t] += 1\n    return [t for t in frequency_map.items()]\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2, 3), (4, 5, 6), (1, 2, 3), (1, 2, 3)]\n    print assign_frequency(tuple_list)\n    tuple_list = [(1, 2, 3), (4, 5, 6)]\n    print assign_frequency(tuple_list)\n    tuple_list = [(1, 2, 3), (1, 2, 3), (4, 5, 6)]\n    print assign_frequency(tuple_list)",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param nums: a list of integers\n    # @return: a list of lists of integers\n    def topKFrequency(self, nums, k):\n        ret = []\n        ret.append([0] * len(nums))\n        for i in range(len(nums)):\n            for j in range(k):\n                if nums[i] == j:\n                    ret[0][i] = j\n                    break\n        for i in range(1, k):\n            for j in range(len(nums)):\n                if nums[j] > i:\n                    ret[i].append(ret[i-1][j])\n        return ret\n\n\nif __name__ == \"__main__\":\n    assert Solution().topKFrequency([1, 1, 2, 2, 3, 4], 2) == [[1, 2], [2, 3], [3, 4]]",
      -0.85888671875
    ],
    [
      "from collections import Counter\n\n\ndef assign_frequency(tuples, num_tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type num_tuples: int\n    :rtype: List[Tuple]\n    \"\"\"\n    return [(tuple, Counter(tuples).most_common(num_tuples)) for tuple in tuples]\n\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2, 3), (1, 2, 3), (1, 2, 4), (1, 2, 4)]\n    print(assign_frequency(tuples, 4))",
      -0.85888671875
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    for i,t in enumerate(tuple_list):\n        tuple_list[i] = (i,t[0],t[1])\n    return tuple_list\n\ntuple_list = [(1,2,3),(1,2,3),(1,2,3)]\nprint assign_frequency(tuple_list)",
      -0.85888671875
    ],
    [
      "from collections import defaultdict\n\n__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def frequencySort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        freq = defaultdict(int)\n        for n in nums:\n            freq[n] += 1\n\n        return [f for f in freq.keys()]\n\n\nif __name__ == \"__main__\":\n    so = Solution()\n    nums = [1, 1, 1, 2, 2, 3]\n    print so.frequencySort(nums)",
      -0.86083984375
    ],
    [
      "def assign_freq(tup_list):\n    \"\"\"\n    :type tup_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    count = [0] * len(tup_list)\n    for tup in tup_list:\n        count[tup[0]] += 1\n\n    freq_list = []\n    for i in range(len(tup_list)):\n        freq_list.append((tup_list[i], count[tup_list[i][0]]))\n    return freq_list",
      -0.86083984375
    ],
    [
      "import heapq\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    \n    freq_dict = {}\n    for tuple_item in tuple_list:\n        freq_dict[tuple_item] = freq_dict.get(tuple_item, 0) + 1\n    \n    return sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)\n    \n    \n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]\n    assign_frequency(tuple_list)\n    print(tuple_list)",
      -1.0419921875
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    Assign frequency to each tuple in the given tuple list.\n\n    Args:\n        tuple_list: A tuple list which is used to assign frequency.\n\n    Returns:\n        A tuple list of assigned frequency.\n    \"\"\"\n\n    # Assign frequency to each tuple.\n    frequency_dict = {}\n    for tuple in tuple_list:\n        if tuple in frequency_dict:\n            frequency_dict[tuple] += 1\n        else:\n            frequency_dict[tuple] = 1\n    return list(frequency_dict.items())",
      -1.068359375
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency\n\ndef assign_frequency(tuples):\n    \"\"\"\n    Args:\n        tuples: A list of tuples\n    Returns:\n        A list of tuples. Each element in the list is a tuple of two elements.\n        The first element of the tuple is the frequency of the tuple, and the\n        second element is the tuple itself.\n    \"\"\"\n    freq = {}\n    for t in tuples:\n        freq[t] = freq.get(t, 0) + 1\n    return [(t, freq[t]) for t in sorted(freq)]\n\nif __name__ == \"__main__\":\n    tuples = [\n        (1, 2),\n        (1, 3),\n        (2, 2),\n        (2, 4),\n        (3, 3),\n        (3, 5),\n        (4, 2),\n        (5, 2),\n        (5, 3),\n    ]\n    print(assign_frequency(tuples))",
      -1.662109375
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for i in range(len(tuple_list)):\n        res.append([])\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list[i])):\n            res[i].append(tuple_list[i][j])\n    return res\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert assign_frequency([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [[1, 2, 3], [1, 2, 3], [1, 2, 3]], \"One\"\n    assert assign_frequency([[1, 2, 3], [1, 2, 4], [1, 2, 3]]) == [[1, 2, 3], [1, 2, 4], [1, 2, 3]], \"Two\"\n    assert assign_frequency([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [[1, 2, 3], [1, 2, 3], [1, 2, 3]], \"Three\"\n    assert assign_frequency([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [[1, 2, 3], [1, 2, 3], [1, 2, 3]], \"Four\"",
      -1.7666015625
    ],
    [
      "from collections import Counter\n\n\ndef frequency(tupleList):\n    \"\"\"\n    :type tupleList: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    c = Counter(tupleList)\n    return [tuple(i) for i in c.most_common()]\n\n\nif __name__ == '__main__':\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 2), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)]\n    tupleList = [('a', 1),",
      -2.033203125
    ],
    [
      "from collections import defaultdict\n\ndef find_freq(tuples, freq_dict):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type freq_dict: Dict[Tuple, int]\n    :rtype: Dict[Tuple, int]\n    \"\"\"\n    for t in tuples:\n        if t in freq_dict:\n            freq_dict[t] += 1\n        else:\n            freq_dict[t] = 1\n    return freq_dict\n\ndef assign_freq(tuples, freq_dict):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type freq_dict: Dict[Tuple, int]\n    :rtype: Dict[Tuple, int]\n    \"\"\"\n    for t in tuples:\n        if t in freq_dict:\n            freq_dict[t] += 1\n        else:\n            freq_dict[t] = 1\n    return freq_dict\n\ndef find_freq_with_limit(tuples, freq_dict, limit):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type freq_dict: Dict[Tuple, int]\n    :type limit: int\n    :rtype: Dict[Tuple, int]\n    \"\"\"\n    for t in tuples:\n        if t in freq_dict:\n            if freq_dict[t] <= limit:\n                freq_dict[t] += 1\n        else:\n            freq_dict[t] = 1\n    return freq_dict\n\ndef assign_freq_with_limit(tuples, freq_dict, limit):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type freq_dict: Dict[Tuple, int]\n    :type limit: int\n    :rtype: Dict[Tuple, int]\n    \"\"\"\n    for t in tuples:\n        if t in freq_dict:\n            if freq_dict[t] <= limit:\n                freq_dict[t] += 1\n        else:\n            freq_dict[t",
      -2.046875
    ],
    [
      "import collections\n\n\ndef assign_freq(tuple_list, freq_dict):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type freq_dict: Dict[Tuple, int]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    # build a dict with freq of each tuple\n    freq_dict = collections.defaultdict(int)\n    for t in tuple_list:\n        freq_dict[t] += 1\n\n    # assign the freq to each tuple\n    return [t for t, freq in freq_dict.items() if freq > 1]\n\n\nif __name__ == '__main__':\n    tuple_list = [\n        ('a', 1),\n        ('a', 1),\n        ('a', 1),\n        ('b', 1),\n        ('b', 1),\n        ('c', 1),\n        ('d', 1),\n        ('e', 1),\n        ('f', 1),\n        ('g', 1),\n        ('h', 1),\n        ('i', 1),\n        ('j', 1),\n        ('k', 1),\n        ('l', 1),\n        ('m', 1),\n        ('n', 1),\n        ('o', 1),\n        ('p', 1),\n        ('q', 1),\n        ('r', 1),\n        ('s', 1),\n        ('t', 1),\n        ('u', 1),\n        ('v', 1),\n        ('w', 1),\n        ('x', 1),\n        ('y', 1),\n        ('z', 1),\n    ]\n\n    freq_dict = {\n        ('a', 1): 3,\n        ('b', 1): 2,\n        ('c', 1): 1,\n        ('d', 1): 1,\n        ('e', 1): 1,\n        ('f', 1): 1,\n        ('g', 1): 1,\n        ('h', 1): 1,\n        ('i', 1): 1,\n        ('j', 1): 1,\n        ('k', 1): 1,\n        ('l', 1): 1,\n        ('m', 1): 1,",
      -2.236328125
    ],
    [
      "def get_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for tup in tuple_list:\n        result.append((tup, 1))\n\n    return result\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]\n    result = get_frequency(tuple_list)\n    print(result)",
      -2.30859375
    ],
    [
      "# https://leetcode.com/problems/assign-frequency-to-each-tuple/discuss/106427/C-Python-Python-solution-with-less-than-1000-lines\n\nclass Solution(object):\n    def assignFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return nums\n\n        n = len(nums)\n        freq = [0] * n\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    freq[i] += 1\n                    freq[j] += 1\n        \n        for i in range(n):\n            freq[i] += k\n        \n        res = []\n        for i in range(n):\n            res.append(freq[i])\n        \n        return res\n\nclass Solution2(object):\n    def assignFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        freq = [0] * n\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    freq[i] += 1\n                    freq[j] += 1\n        \n        res = []\n        for i in range(n):\n            res.append(freq[i])\n        \n        for i in range(n):\n            if i > 0 and i < n-1 and res[i] == k:\n                res[i] = res[i-1]\n            elif i < n-1 and res[i] == k:\n                res[i] = res[i+1]\n        \n        return res",
      -2.400390625
    ],
    [
      "# https://www.hackerrank.com/challenges/tuple-frequency\n# https://www.hackerrank.com/challenges/tuple-frequency/problem\n\n# Complete this function\ndef tuple_frequency(tuple_list):\n    \n    # Dictionary to store frequency of tuple\n    frequency = {}\n    \n    # Iterate through the given tuple list\n    for i in range(len(tuple_list)):\n        \n        # If the tuple is not in the dictionary\n        if tuple_list[i] not in frequency:\n            \n            # Add the tuple to the dictionary\n            frequency[tuple_list[i]] = 1\n            \n            # Iterate through the rest of the tuple list\n            for j in range(i+1, len(tuple_list)):\n                \n                # If the tuple is not in the dictionary\n                if tuple_list[j] not in frequency:\n                    \n                    # Add the tuple to the dictionary\n                    frequency[tuple_list[j]] = 1\n                    \n                else:\n                    \n                    # Increment the frequency of the tuple\n                    frequency[tuple_list[j]] += 1\n    \n    # Return the frequency dictionary\n    return frequency\n\n# Driver program to test above function\ntuple_list = [1,2,3]\ntuple_frequency(tuple_list)",
      -2.533203125
    ],
    [
      "def tuple_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    frequency_dict = {}\n    for t in tuple_list:\n        if t not in frequency_dict:\n            frequency_dict[t] = 1\n        else:\n            frequency_dict[t] += 1\n    return list(frequency_dict.values())\n\nif __name__ == '__main__':\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]))\n    print(tuple_frequency([(1, 2), (1, 2),",
      -2.70703125
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim: set expandtab:ts=4:sw=4\n\nimport collections\n\nclass TupleList:\n    \"\"\"\n    List of tuples.\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"\n        Initialize the list with given tuple.\n        \"\"\"\n        self.tuples = []\n        for arg in args:\n            self.tuples.append(arg)\n\n    def __str__(self):\n        \"\"\"\n        Returns the list as string.\n        \"\"\"\n        return str(self.tuples)\n\n    def __repr__(self):\n        \"\"\"\n        Returns the list as string.\n        \"\"\"\n        return str(self.tuples)\n\n    def __iter__(self):\n        \"\"\"\n        Returns the list as iterator.\n        \"\"\"\n        return iter(self.tuples)\n\n    def append(self, arg):\n        \"\"\"\n        Append the given tuple.\n        \"\"\"\n        self.tuples.append(arg)\n\n    def extend(self, arg):\n        \"\"\"\n        Extend the list with given tuple.\n        \"\"\"\n        self.tuples.extend(arg)\n\n    def count(self, arg):\n        \"\"\"\n        Returns the number of the given tuple.\n        \"\"\"\n        return self.tuples.count(arg)\n\n    def index(self, arg):\n        \"\"\"\n        Returns the index of the given tuple.\n        \"\"\"\n        return self.tuples.index(arg)\n\n    def insert(self, arg):\n        \"\"\"\n        Insert the given tuple at the given index.\n        \"\"\"\n        self.tuples.insert(arg)\n\n    def remove(self, arg):\n        \"\"\"\n        Removes the given tuple.\n        \"\"\"\n        self.tuples.remove(arg)\n\n    def __getitem__(self, arg):\n        \"\"\"\n        Returns the tuple at the given index.\n        \"\"\"\n        return self.tuples[arg]\n\n    def __setitem__(self, arg, val):\n        \"\"\"\n        Sets the tuple at the given index.\n        \"\"\"\n        self.tuples[arg] = val",
      -2.875
    ],
    [
      "class Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        @param nums: The given list of integers\n        @return: The frequency list of the given list\n        \"\"\"\n        self.freq = {}\n        for i in nums:\n            if i not in self.freq:\n                self.freq[i] = 1\n            else:\n                self.freq[i] += 1\n        self.freq_sorted = sorted(self.freq.items(), key=lambda x: x[1])\n        self.freq_sum = sum(self.freq.values())\n\n    def getFrequency(self, num):\n        \"\"\"\n        @param num: The given integer\n        @return: The frequency of num\n        \"\"\"\n        if num not in self.freq:\n            return 0\n        return self.freq[num]\n\n    def getFrequencies(self, nums):\n        \"\"\"\n        @param nums: The given list of integers\n        @return: The list of the frequency of each number in the given list\n        \"\"\"\n        return [self.getFrequency(i) for i in nums]\n\nclass Solution2(object):\n    def __init__(self, nums):\n        \"\"\"\n        @param nums: The given list of integers\n        @return: The frequency list of the given list\n        \"\"\"\n        self.freq = {}\n        for i in nums:\n            if i not in self.freq:\n                self.freq[i] = 1\n            else:\n                self.freq[i] += 1\n        self.freq_sorted = sorted(self.freq.items(), key=lambda x: x[1])\n        self.freq_sum = sum(self.freq.values())\n\n    def getFrequency(self, num):\n        \"\"\"\n        @param num: The given integer\n        @return: The frequency of num\n        \"\"\"\n        if num not in self.freq:\n            return 0\n        return self.freq[num]\n\n    def getFrequencies(self, nums):\n        \"\"\"\n        @param nums: The given list of integers",
      -2.88671875
    ],
    [
      "import collections\n\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    d = collections.defaultdict(int)\n    for tuple in tuple_list:\n        d[tuple] += 1\n    return [tuple for tuple, freq in d.items() if freq == 1]\n\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2, 3), (2, 3, 4), (2, 2, 2), (1, 1, 1)]\n    print(assign_frequency(tuple_list))\n    tuple_list = [(1, 2, 3), (2, 3, 4), (2, 2, 2), (1, 1, 1)]\n    print(assign_frequency(tuple_list))\n    tuple_list = [(1, 2, 3), (2, 3, 4), (2, 2, 2), (1, 1, 1)]\n    print(assign_frequency(tuple_list))",
      -2.888671875
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        freq = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] < nums[i]:\n                    freq[j] = freq[i] + 1\n        for i in range(n):\n            freq[i] = freq[i] * k / (n - i)\n        return freq\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/assign-frequency/solution/\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> assignFreq(int[] nums, int k) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] < nums[i]) {\n                    res.add(res.get(i) + 1);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            res.set(i, res.get(i) * k / (n - i));\n        }\n        return res;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> assignFreq(int[] nums, int k) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i +",
      -2.91015625
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency/problem\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    \n    # This is the initial list of tuples\n    freq_list = list(tuple_list)\n    # The number of tuples\n    len_tuple_list = len(tuple_list)\n    \n    # Initialize frequency counter\n    counter = {t: 0 for t in tuple_list}\n    \n    # Count frequency\n    for i in range(len_tuple_list):\n        # Increment frequency\n        counter[freq_list[i]] += 1\n    \n    # Create new list with the frequency\n    new_list = []\n    for t in tuple_list:\n        # Get the frequency\n        frequency = counter[t]\n        # Add to list\n        new_list.append((t, frequency))\n    return new_list",
      -3.130859375
    ],
    [
      "class Solution(object):\n    def __init__(self, n):\n        self.n = n\n\n    def assignFrequency(self, list1, list2):\n        \"\"\"\n        :type list1: List[int]\n        :type list2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(list1)):\n            if i < len(list2):\n                res.append(list1[i] + list2[i])\n            else:\n                res.append(list1[i])\n        return res\n\n# Note:\n# List 1: [1, 2, 1, 2, 3]\n# List 2: [1, 1, 2, 2, 2]\n\ns = Solution(3)\nprint s.assignFrequency([1, 2, 1, 2, 3], [1, 1, 2, 2, 2])",
      -3.275390625
    ],
    [
      "class Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or not k:\n            return nums\n        n = len(nums)\n        freq = [0] * n\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] < nums[j]:\n                    freq[i] += 1\n                    freq[j] -= 1\n        \n        for i in range(n):\n            freq[i] = freq[i] / k\n        return [freq[i] for i in range(n)]",
      -3.365234375
    ],
    [
      "import unittest\n\nfrom algorithms.sort import sort\nfrom algorithms.sort import bubble_sort\nfrom algorithms.sort import insertion_sort\nfrom algorithms.sort import selection_sort\nfrom algorithms.sort import quick_sort\nfrom algorithms.sort import merge_sort\nfrom algorithms.sort import counting_sort\nfrom algorithms.sort import merge_sort\nfrom algorithms.sort import counting_sort\nfrom algorithms.sort import insertion_sort\nfrom algorithms.sort import quick_sort\nfrom algorithms.sort import selection_sort\nfrom algorithms.sort import merge_sort\nfrom algorithms.sort import counting_sort\nfrom algorithms.sort import merge_sort\nfrom algorithms.sort import counting_sort\nfrom algorithms.sort import insertion_sort\nfrom algorithms.sort import quick_sort\nfrom algorithms.sort import selection_sort\nfrom algorithms.sort import merge_sort\nfrom algorithms.sort import counting_sort\n\n\nclass TestSort(unittest.TestCase):\n\n    def test_selection_sort(self):\n        l = [3, 2, 1, 4, 8, 7, 6, 5]\n        s = selection_sort(l)\n        self.assertEqual(s, [1, 2, 3, 4, 5, 6, 7, 8])\n\n    def test_bubble_sort(self):\n        l = [3, 2, 1, 4, 8, 7, 6, 5]\n        s = bubble_sort(l)\n        self.assertEqual(s, [1, 2, 3, 4, 5, 6, 7, 8])\n\n    def test_insertion_sort(self):\n        l = [3, 2, 1, 4, 8, 7, 6, 5]\n        s = insertion_sort(l)\n        self.assertEqual(s, [1, 2, 3, 4, 5, 6, 7, 8])\n\n    def test_quick_sort(self):\n        l = [3, 2, 1, 4, 8, 7, 6, 5]\n        s = quick_sort(l)\n        self.assertEqual(s, [1, 2, 3, 4, 5, 6, 7, 8])\n\n    def test_merge_sort(self):\n        l = [3, 2, 1, 4, 8, 7,",
      -3.427734375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def assignFrequency(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        freq = {}\n        for t in tuples:\n            if t.x not in freq:\n                freq[t.x] = 0\n            freq[t.x] += 1\n            if t.y not in freq:\n                freq[t.y] = 0\n            freq[t.y] += 1\n        return [Tuple(k, v) for k, v in freq.items()]",
      -3.583984375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return str(self.x) + ',' + str(self.y)\n\n\nclass Solution(object):\n    def assignFreq(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        tlen = len(tuples)\n        freq = [0] * tlen\n        for t in tuples:\n            freq[t.y] += 1\n        return freq\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.assignFreq(tuples)",
      -3.84765625
    ],
    [
      "def assign_frequency(tuples, num_tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :type num_tuples: int\n    :rtype: List[int]\n    \"\"\"\n    freq = [0] * num_tuples\n    for tup in tuples:\n        freq[tup[0]] += 1\n        freq[tup[1]] += 1\n    return freq\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def kClosestElements(self, nums, k):\n        if k == 0:\n            return [0] * len(nums)\n        elif k == 1:\n            return [max(nums)]\n        elif k > len(nums):\n            return [0] * len(nums)\n        elif k == len(nums):\n            return nums\n        elif k == len(nums) + 1:\n            return sorted(nums)\n        else:\n            freq = assign_frequency(nums, k)\n            return sorted(list(set(nums)))[freq.index(max(freq))]",
      -4.0078125
    ],
    [
      "# -*- coding: utf-8 -*-\n\nclass Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n\n    def sortByFrequency(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.nums = sorted(self.nums, reverse=True)\n        result = []\n        for num in self.nums:\n            if num not in result:\n                result.append(num)\n        return result",
      -4.015625
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency/problem\n# https://www.hackerrank.com/challenges/assign-frequency/examples\n# https://www.hackerrank.com/challenges/assign-frequency/solutions/python\n\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int]]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    freq = {}\n    for t in tuple_list:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n\n    return [(k, v) for k, v in freq.items()]\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        tuple_list = []\n        for _ in range(n):\n            tuple_list.append(map(int, input().split()))\n\n        print(assign_frequency(tuple_list))",
      -4.2109375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 1\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return str(self.x) + \",\" + str(self.y)\n\nclass Solution(object):\n    def assignFrequency(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        # Use a dict to store frequency\n        freq = {}\n        for t in nums:\n            if t not in freq:\n                freq[t] = 1\n            else:\n                freq[t] += 1\n\n        # Convert to a list, sort by frequency\n        freq_list = sorted(freq.items(), key=lambda t: t[1], reverse=True)\n\n        return [t for t in nums if t in freq_list]\n\nif __name__ == \"__main__\":\n    print Solution().assignFrequency([(1,2),(1,2),(2,3)])",
      -4.21484375
    ],
    [
      "import collections\nimport heapq\n\n\ndef find_freq(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    freq = collections.defaultdict(lambda: 0)\n    for t in tuple_list:\n        freq[t] += 1\n    freq_list = sorted(freq.items(), key=lambda t: t[1], reverse=True)\n    freq_list = sorted(freq_list, key=lambda t: t[0])\n    return freq_list\n\n\ndef main():\n    # these \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_freq([('a', 1), ('a', 2), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('d', 1), ('d', 2)]) == [('a', 2), ('b', 2), ('c', 1), ('d', 1)]\n\n    assert find_freq([('a', 1), ('a', 2), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('d', 1), ('d', 2), ('e', 1), ('e', 2)]) == [('a', 2), ('b', 2), ('c', 1), ('d', 1), ('e', 2)]\n\n\nif __name__ == '__main__':\n    main()",
      -4.2265625
    ],
    [
      "import random\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    freq = {}\n    for t in tuples:\n        if t in freq:\n            freq[t] += 1\n        else:\n            freq[t] = 1\n    return freq\n\ndef test_assign_frequency():\n    assert assign_frequency([[1,2],[3,4]]) == [[1,2,1], [3,4,1]]\n    assert assign_frequency([[1,2],[3,4,5]]) == [[1,2,1], [3,4,5]]\n    assert assign_frequency([[1,2,3],[3,4,5]]) == [[1,2,3], [3,4,5]]\n    assert assign_frequency([[1,2,3,4],[3,4,5,6]]) == [[1,2,3,4], [3,4,5,6]]\n    assert assign_frequency([[1,2,3,4,5],[3,4,5,6,7]]) == [[1,2,3,4,5], [3,4,5,6,7]]\n\nif __name__ == \"__main__\":\n    test_assign_frequency()",
      -4.453125
    ],
    [
      "# https://www.hackerrank.com/challenges/tuple-frequency/problem\n\ndef tuple_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    frequency = {tuple(): 1}\n    for tuple_ in tuple_list:\n        frequency[tuple_] += 1\n    return sorted(frequency.items(), key=lambda t: t[1], reverse=True)\n\n\nif __name__ == \"__main__\":\n    tuple_list = [\n        (1, 1),\n        (1, 2),\n        (2, 1),\n        (2, 2),\n        (3, 1),\n        (3, 2),\n        (3, 3),\n        (4, 1),\n        (4, 2),\n        (4, 3),\n        (5, 1),\n        (5, 2),\n        (5, 3),\n        (6, 1),\n        (6, 2),\n        (6, 3),\n        (7, 1),\n        (7, 2),\n        (7, 3),\n        (8, 1),\n        (8, 2),\n        (8, 3),\n        (9, 1),\n        (9, 2),\n        (9, 3),\n        (10, 1),\n        (10, 2),\n        (10, 3),\n        (11, 1),\n        (11, 2),\n        (11, 3),\n        (12, 1),\n        (12, 2),\n        (12, 3),\n        (13, 1),\n        (13, 2),\n        (13, 3),\n        (14, 1),\n        (14, 2),\n        (14, 3),\n        (15, 1),\n        (15, 2),\n        (15, 3),\n        (16, 1),\n        (16, 2),\n        (16, 3),\n        (17, 1),\n        (17, 2),\n        (17, 3),\n        (18, 1),\n        (18, 2),\n        (18, 3),\n        (19, 1),\n        (19, 2",
      -4.54296875
    ],
    [
      "from collections import defaultdict\n\n__author__ = 'Daniel'\n\n\nclass Solution:\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        dict_freq = defaultdict(lambda: 0)\n        for num in nums:\n            dict_freq[num] += 1\n        freq_list = []\n        for num, freq in dict_freq.items():\n            freq_list.append((freq, num))\n        freq_list.sort(key=lambda x: x[0], reverse=True)\n        freq_list = [x[1] for x in freq_list]\n        freq_list = [x for x in freq_list if x < k]\n        freq_list.sort(reverse=True)\n        return freq_list\n\n\nif __name__ == '__main__':\n    assert Solution().assignFreq([1, 1, 1, 1], 2) == [1, 2, 1, 1]\n    assert Solution().assignFreq([1, 2, 3, 4], 2) == [1, 3, 2, 1]\n    assert Solution().assignFreq([1, 2, 3, 4, 5], 2) == [1, 3, 2, 4, 5]",
      -4.578125
    ],
    [
      "def frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int]]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    frequency_list = {}\n    for tuple in tuple_list:\n        frequency = tuple[0]\n        if tuple[0] in frequency_list:\n            frequency_list[tuple[0]] += 1\n        else:\n            frequency_list[tuple[0]] = 1\n    return sorted(frequency_list.items(), key=lambda x: x[1], reverse=True)\n\nif __name__ == \"__main__\":\n    tuple_list = [(1, 2), (2, 2), (3, 2), (1, 3), (2, 4), (3, 5)]\n    print(frequency(tuple_list))",
      -4.828125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution(object):\n    def addToList(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return ListNode(val)\n        new_head = ListNode(val)\n        new_head.next = head\n        return new_head\n    def addToList2(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        while head is not None:\n            head = head.next\n        node = ListNode(val)\n        node.next = head\n        return node\n    def addToList3(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        while head is not None:\n            head = head.next\n        node = ListNode(val)\n        node.next = head\n        return node\n    def addToList4(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return ListNode(val)\n        node = head\n        while node.next is not None:\n            node = node.next\n        node.next = ListNode(val)\n        return node.next\n    def addToList5(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return ListNode(val)\n        while head is not None:\n            head = head.next\n        new_head = head\n        head = ListNode(val)\n        head.next = new_head\n        return head\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_",
      -5.0703125
    ],
    [
      "def assign_frequency(tuples, input_tuple_list):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :type input_tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    output_tuple_list = []\n    for i in range(len(tuples)):\n        output_tuple_list.append((tuples[i][0], 1))\n        for j in range(len(input_tuple_list)):\n            if input_tuple_list[j][0] == tuples[i][0]:\n                output_tuple_list[i][1] += 1\n    return output_tuple_list\n\nif __name__ == '__main__':\n    print(assign_frequency([(1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (3, 2), (3, 3), (3, 4), (4, 1), (4, 2), (4, 3), (4, 4)], [(1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (3, 2), (3, 3), (3, 4), (4, 1), (4, 2), (4, 3), (4, 4)]))",
      -5.328125
    ],
    [
      "# Example:\n# Input:\n# [1, 2, 1, 3, 4, 1, 1, 2, 1, 1, 3, 4, 5, 1, 2, 3, 4, 5]\n# Output:\n# [(1, 4), (2, 3), (3, 4), (5, 5)]\n# [(1, 2), (2, 1), (3, 1), (4, 2)]\n# [(1, 2), (2, 3), (3, 4), (4, 5)]\n# [(1, 3), (2, 4), (3, 5), (4, 6)]\n# [(1, 3), (2, 4), (3, 5), (4, 7)]\n# [(1, 4), (2, 3), (3, 4), (5, 5)]\n# [(1, 4), (2, 3), (3, 4), (6, 6)]\n# [(1, 4), (2, 3), (3, 4), (7, 7)]\n# [(1, 4), (2, 3), (3, 4), (8, 8)]\n# [(1, 4), (2, 3), (3, 4), (9, 9)]\n# [(1, 4), (2, 3), (3, 4), (10, 10)]\n# [(1, 4), (2, 3), (3, 4), (11, 11)]\n# [(1, 4), (2, 3), (3, 4), (12, 12)]\n# [(1, 4), (2, 3), (3, 4), (13, 13)]\n# [(1, 4), (2, 3), (3, 4), (14, 14)]\n# [(1, 4), (2, 3), (3, 4), (15, 15)]\n# [(1, 4), (2, 3), (3, 4), (16, 16)]\n# [(1, 4), (2, 3), (3, 4), (17, 17)]\n# [(1, 4), (2, 3), (3, 4), (18, 18)]\n# [(1, 4), (2, 3), (3, 4), (19, 19)]\n# [(1, 4), (2, 3), (3, 4), (20, 20",
      -5.65234375
    ],
    [
      "import math\n\ndef get_frequency(tuple_list):\n    \"\"\"\n    Input:\n        tuple_list: A list of tuples.\n    Output:\n        A list of tuples, with each element containing the frequency of the corresponding tuple.\n    \"\"\"\n    frequency_list = []\n    for tuple in tuple_list:\n        frequency_list.append(len(tuple))\n    return frequency_list\n\ndef get_frequency_sum(tuple_list):\n    \"\"\"\n    Input:\n        tuple_list: A list of tuples.\n    Output:\n        A list of tuples, with each element containing the frequency of the corresponding tuple.\n    \"\"\"\n    frequency_list = []\n    for tuple in tuple_list:\n        frequency_list.append(sum(tuple))\n    return frequency_list\n\ndef get_frequency_sum_of_squares(tuple_list):\n    \"\"\"\n    Input:\n        tuple_list: A list of tuples.\n    Output:\n        A list of tuples, with each element containing the frequency of the corresponding tuple.\n    \"\"\"\n    frequency_list = []\n    for tuple in tuple_list:\n        frequency_list.append(sum(tuple)**2)\n    return frequency_list\n\ndef get_frequency_sum_of_squares_of_squares(tuple_list):\n    \"\"\"\n    Input:\n        tuple_list: A list of tuples.\n    Output:\n        A list of tuples, with each element containing the frequency of the corresponding tuple.\n    \"\"\"\n    frequency_list = []\n    for tuple in tuple_list:\n        frequency_list.append(sum(tuple)**3)\n    return frequency_list\n\ndef get_frequency_sum_of_squares_of_squares_of_squares(tuple_list):\n    \"\"\"\n    Input:\n        tuple_list: A list of tuples.\n    Output:\n        A list of tuples, with each element containing the frequency of the corresponding tuple.\n    \"\"\"\n    frequency_list = []\n    for tuple in tuple_list:\n        frequency_list.append(sum(tuple)**4)\n    return",
      -5.67578125
    ],
    [
      "__author__ = 'Danyang'\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __str__(self):\n        return str((self.x, self.y))\n\nclass Solution(object):\n    def __init__(self):\n        self.count = 0\n\n    def assignFrequency(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        self.count = 0\n        for t in tuples:\n            self.count += 1\n            t.y = self.count\n        return tuples\n\n\nif __name__ == \"__main__\":\n    sln = Solution()\n    t1 = Tuple(1)\n    t2 = Tuple(2)\n    t3 = Tuple(3)\n    t4 = Tuple(4)\n    t5 = Tuple(5)\n    t6 = Tuple(6)\n    t7 = Tuple(7)\n    t8 = Tuple(8)\n    t9 = Tuple(9)\n    t10 = Tuple(10)\n    t11 = Tuple(11)\n    t12 = Tuple(12)\n    t13 = Tuple(13)\n    t14 = Tuple(14)\n    t15 = Tuple(15)\n    t16 = Tuple(16)\n    t17 = Tuple(17)\n    t18 = Tuple(18)\n    t19 = Tuple(19)\n    t20 = Tuple(20)\n\n    print sln.assignFrequency([t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20])",
      -5.8125
    ],
    [
      "import unittest\n\n# Time:  O(n)\n# Space: O(n)\n# DP\nclass Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i+1] = dp[i] + 1\n        dp[0] = 1\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if dp[j] < k:\n                    dp[j] = dp[j-1]\n                else:\n                    dp[j] += dp[j-1]\n        return [dp[i] for i in range(n+1)]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/assign-frequency/solution/\n\n# 1ms 100%\nclass Solution {\n    public int[] assignFreq(int[] nums, int k) {\n        int[] dp = new int[nums.length + 1];\n        dp[0] = 1;\n        for (int i = 1; i < dp.length; i++) {\n            dp[i] = dp[i - 1] + 1;\n        }\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (dp[j] < k) {\n                    dp[j] = dp[j - 1];\n                } else {\n                    dp[j] += dp[j - 1];\n                }\n            }\n        }\n        return dp;\n    }\n}\n\n# 1ms 100%\nclass Solution {",
      -6.046875
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __iter__(self):\n        for i in range(1, 5):\n            yield (i, self.x)\n\n    def __str__(self):\n        return str((self.x, self.y))\n\n\nclass Solution(object):\n    def assignFrequency(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        res = []\n        for t in tuples:\n            res.append((t.x, t.y))\n        return res\n\n\na = Solution()\na.assignFrequency([(1, 2), (2, 1), (2, 3), (3, 2), (4, 3), (4, 4)])\n\n# Note:\n# Since we want to keep the frequency of each tuple, we can use a list to store the frequency of each tuple.\n# We can also use a dict to keep the frequency of each tuple.",
      -6.08203125
    ],
    [
      "def frequency(tupleList):\n    \"\"\"\n    :type tupleList: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tupleList:\n        return tupleList\n    \n    freq = {}\n    for t in tupleList:\n        if t not in freq:\n            freq[t] = 1\n        else:\n            freq[t] += 1\n    \n    freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    return [t for t, _ in freq]\n\nif __name__ == '__main__':\n    tupleList = [(1, 2, 3), (1, 3, 4), (1, 3, 5), (2, 3, 4), (2, 4, 5), (3, 4, 5)]\n    print(frequency(tupleList))",
      -6.1015625
    ],
    [
      "def frequency(tupleList):\n    \"\"\"\n    :type tupleList: List[Tuple[int, int, int]]\n    :rtype: List[Tuple[int, int, int]]\n    \"\"\"\n    # time: O(n)\n    # space: O(n)\n    result = []\n    for i in range(len(tupleList)):\n        for j in range(len(tupleList)):\n            if tupleList[i] == tupleList[j]:\n                result.append((i, j, tupleList[i]))\n    return result\n\ndef main():\n    tupleList = [\n        (1, 2, 3),\n        (1, 3, 5),\n        (1, 3, 7),\n        (1, 4, 5),\n        (1, 4, 7),\n        (1, 5, 5),\n        (2, 4, 6),\n        (2, 4, 8),\n        (2, 5, 7),\n        (2, 6, 8),\n        (3, 4, 6),\n        (3, 4, 8),\n        (3, 5, 7),\n        (3, 6, 8),\n        (4, 5, 8),\n        (5, 6, 8)\n    ]\n    result = frequency(tupleList)\n    for item in result:\n        print(item)\n\nif __name__ == '__main__':\n    main()",
      -6.15234375
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency/problem\n\ndef assign_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return sorted(tuple_list, key=lambda x: (x[0], x[1]))\n\ndef main():\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]\n    tuple_list = [('a', 1), ('b', 2), ('a', 2), ('b', 1), ('c', 2), ('c', 1)]",
      -6.65625
    ],
    [
      "# https://leetcode.com/problems/assign-frequency-to-tuple-list/discuss/131667/Python-implementation-using-if-else-if-else\n\nfrom collections import Counter\n\n\nclass Solution(object):\n    def assignFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k == 0:\n            return []\n        if k == 1:\n            return [n for n in nums]\n        if k == 2:\n            return [n for n in nums if n % 2 == 0]\n        if k == 3:\n            return [n for n in nums if n % 3 == 0]\n        if k == 4:\n            return [n for n in nums if n % 4 == 0]\n        if k == 5:\n            return [n for n in nums if n % 5 == 0]\n        if k == 6:\n            return [n for n in nums if n % 6 == 0]\n        if k == 7:\n            return [n for n in nums if n % 7 == 0]\n        if k == 8:\n            return [n for n in nums if n % 8 == 0]\n        if k == 9:\n            return [n for n in nums if n % 9 == 0]\n        if k == 10:\n            return [n for n in nums if n % 10 == 0]\n        if k == 11:\n            return [n for n in nums if n % 11 == 0]\n        if k == 12:\n            return [n for n in nums if n % 12 == 0]\n        if k == 13:\n            return [n for n in nums if n % 13 == 0]\n        if k == 14:\n            return [n for n in nums if n % 14 == 0]\n        if k == 15:\n            return [n for n in nums if n % 15 == 0]\n        if k == 16:\n            return [n for n in nums if n % 16 == 0]\n        if k == 17:\n            return [n for n in num",
      -6.92578125
    ],
    [
      "class Solution:\n    # @param A a list of lists of integers\n    # @return a list of lists of integers\n    def topKFrequencies(self, A):\n        if not A:\n            return [[]]\n        if not A[0]:\n            return [[]]\n        n = len(A[0])\n        freq = [[0 for j in range(n)] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                freq[i][j] = A[i][j]\n        freq.sort(reverse=True)\n        res = [[] for i in range(n)]\n        for i in range(n):\n            res[i] = [freq[i][j] for j in range(n) if freq[i][j] > 0]\n        return res",
      -6.953125
    ],
    [
      "def assign_frequency(tuples):\n    # write your code here\n    freq = {}\n    for tup in tuples:\n        if tup not in freq:\n            freq[tup] = 1\n        else:\n            freq[tup] += 1\n    return freq\n\ndef test():\n    tuples = [(1, 2, 3), (4, 5, 6)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 1, (4, 5, 6): 1}\n    tuples = [(1, 2, 3), (1, 2, 3), (4, 5, 6)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 2, (4, 5, 6): 1}\n    tuples = [(1, 2, 3), (4, 5, 6)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 1, (4, 5, 6): 1}\n    tuples = [(1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 3, (1, 2, 3): 1}\n    tuples = [(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 6, (1, 2, 3): 3}\n    tuples = [(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    assert assign_frequency(tuples) == {(1, 2, 3): 9, (1, 2, 3): 6}\n\nif __name__ == '__main__':\n    test()",
      -7.42578125
    ],
    [
      "class Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        self.nums = nums\n        self.freq = [0] * len(nums)\n\n    def update(self, pos, val):\n        self.freq[pos] += val\n\n    def getFreq(self, pos):\n        return self.freq[pos]\n\n    def getMaxFreq(self):\n        max_freq = 0\n        for i in range(len(self.freq)):\n            if self.freq[i] > max_freq:\n                max_freq = self.freq[i]\n\n        return max_freq\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,2,3,4,4,5,6,6,6]\n    sol = Solution(nums)\n    sol.update(2, 3)\n    sol.update(4, 2)\n    sol.update(5, 1)\n    print sol.getMaxFreq()",
      -7.453125
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency-to-tuple/problem\n\ndef assign_frequency(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int]]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    # Initialize frequency\n    freq = [0] * len(tuples)\n\n    for i in range(len(tuples)):\n        for j in range(i):\n            if tuples[i] == tuples[j]:\n                freq[i] += 1\n    return freq\n\n\ndef main():\n    tuples = [\n        (1, 2, 3),\n        (1, 2, 4),\n        (1, 3, 3),\n        (1, 3, 4),\n        (1, 4, 4),\n        (1, 5, 3),\n        (1, 5, 4),\n        (2, 3, 3),\n        (2, 3, 4),\n        (2, 4, 4),\n        (3, 3, 3),\n        (3, 3, 4),\n        (3, 4, 4),\n        (4, 4, 4)\n    ]\n\n    # Assign frequency\n    freq = assign_frequency(tuples)\n\n    # Print result\n    print(freq)\n\n\nif __name__ == \"__main__\":\n    main()",
      -8.34375
    ],
    [
      "import collections\n\nclass Solution:\n    def frequencySort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums = list(nums)\n        freq = collections.Counter(nums)\n        freq = [freq[i] for i in range(len(freq))]\n        freq.sort(reverse=True)\n        return [freq[i] for i in range(len(freq))]\n\n\nif __name__ == \"__main__\":\n    so = Solution()\n    nums = [1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3",
      -8.3984375
    ],
    [
      "# https://www.hackerrank.com/challenges/assign-frequency/problem\n\nimport math\n\ndef assign_frequency(tuples):\n    # Complete this function\n    result = []\n    for t in tuples:\n        if t[0] in result:\n            result[result.index(t[0])] += 1\n        else:\n            result.append(t[0])\n            result[result.index(t[0])] = 1\n    return result\n\nif __name__ == '__main__':\n    tuples = [\n        ('A', 1),\n        ('A', 2),\n        ('B', 1),\n        ('C', 2),\n        ('C', 3),\n        ('D', 2),\n        ('D', 3),\n        ('E', 2),\n        ('E', 4),\n        ('F', 1),\n        ('F', 3),\n        ('F', 4),\n        ('G', 1),\n        ('G', 3),\n        ('G', 4),\n        ('H', 1),\n        ('H', 2),\n        ('H', 3),\n        ('H', 4),\n        ('H', 5),\n        ('I', 1),\n        ('I', 2),\n        ('I', 3),\n        ('I', 4),\n        ('I', 5),\n        ('I', 6),\n        ('J', 1),\n        ('J', 2),\n        ('J', 3),\n        ('J', 4),\n        ('J', 5),\n        ('K', 1),\n        ('K', 2),\n        ('K', 3),\n        ('K', 4),\n        ('K', 5),\n        ('K', 6),\n        ('K', 7),\n        ('K', 8),\n        ('K', 9),\n        ('K', 10),\n        ('K', 11),\n        ('K', 12),\n        ('L', 1),\n        ('L', 2),\n        ('L', 3),\n        ('L', 4),\n        ('L', 5),\n        ('L', 6),\n        ('L', 7),\n        ('L', 8),\n        ('L', 9),\n        ('L', 10),\n        ('L', 11),\n        ('L',",
      -9.3515625
    ],
    [
      "import collections\n\nclass Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        freq = collections.Counter(nums)\n        freq_dict = dict(freq)\n        freq_dict[0] = 1\n        freq_dict[-1] = 1\n        ans = 0\n        for i in range(len(nums)):\n            ans += freq_dict[nums[i]]\n            freq_dict[nums[i]] = 1\n        return ans / 2\n\n\nif __name__ == \"__main__\":\n    assert Solution().assignFreq([3, 1, 2, 2], 1) == 4\n    assert Solution().assignFreq([3, 1, 2, 2], 2) == 8\n    assert Solution().assignFreq([3, 1, 2, 2], 3) == 12",
      -9.9453125
    ],
    [
      "import collections\n\nclass TupleList(object):\n    def __init__(self, tup_list):\n        self.tup_list = tup_list\n        self.counts = collections.Counter(tuple(tup_list))\n\n    def get_frequency(self, tup):\n        return self.counts[tup]\n\n    def get_frequency_list(self):\n        return self.counts.most_common()\n\n    def get_frequency_set(self):\n        return set(self.counts.values())\n\n    def get_frequency_dict(self):\n        return self.counts\n\n    def get_frequency_dict_max(self):\n        return max(self.counts.values())\n\n    def get_frequency_dict_min(self):\n        return min(self.counts.values())\n\n    def get_frequency_dict_sum(self):\n        return sum(self.counts.values())\n\n    def get_frequency_dict_mean(self):\n        return sum(self.counts.values()) / len(self.counts)\n\n    def get_frequency_dict_stddev(self):\n        return sum((self.counts - self.counts.mean()) ** 2) / len(self.counts) ** 0.5\n\n    def get_frequency_dict_product(self):\n        return reduce(lambda x, y: x * y, self.counts.values())\n\n    def get_frequency_dict_sum_of_squares(self):\n        return sum(self.counts.values() ** 2)\n\n    def get_frequency_dict_sum_of_cubes(self):\n        return sum(self.counts.values() ** 3)\n\n    def get_frequency_dict_max_of_squares(self):\n        return max(self.counts.values() ** 2)\n\n    def get_frequency_dict_max_of_cubes(self):\n        return max(self.counts.values() ** 3)\n\n    def get_frequency_dict_min_of_squares(self):\n        return min(self.counts.values() ** 2)\n\n    def get_frequency_dict_min_of_",
      -10.890625
    ],
    [
      "#!/usr/bin/env python\n\n#import sys\n#sys.path.append('../')\n#import re\nimport re\n#import math\n#import random\nfrom collections import defaultdict\nfrom itertools import groupby\n\ndef assign_frequency(tuples):\n    \"\"\"\n    Assign frequency to each tuple in the given tuple list.\n    \"\"\"\n    # TODO: Write a function to assign frequency to each tuple in the given tuple list.\n    # For each tuple, create a dictionary with keys as the tuple's items and values as the number of tuples that have that item.\n    # Then, group each dictionary into a list of tuples, and sort the list by the number of tuples.\n    # Then, assign frequency to each tuple.\n    #\n    # For example:\n    #\n    # tuples = [\n    #     ('a', 1),\n    #     ('a', 1),\n    #     ('b', 1),\n    #     ('b', 2),\n    #     ('c', 1),\n    #     ('c', 1),\n    #     ('d', 1),\n    #     ('d', 1),\n    #     ('d', 1),\n    #     ('e', 1),\n    #     ('e', 1),\n    #     ('f', 1),\n    # ]\n    #\n    # Assign frequency to each tuple in the given tuple list.\n    #\n    # Output:\n    # [\n    #     (['a', 'b'], 3),\n    #     (['c', 'd'], 2),\n    #     (['e', 'f'], 1),\n    # ]\n    pass\n\nif __name__ == '__main__':\n    tuples = [\n        ('a', 1),\n        ('a', 1),\n        ('b', 1),\n        ('b', 2),\n        ('c', 1),\n        ('c', 1),\n        ('d', 1),\n        ('d', 1),\n        ('d', 1),\n        ('e', 1),\n        ('e', 1),\n        ('f', 1),\n    ]\n    assign_frequency(tuples)\n    print(tuples)",
      -11.2109375
    ],
    [
      "import unittest\nfrom collections import defaultdict\n\n# TLE\nclass Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.freq = defaultdict(int)\n        self.res = defaultdict(int)\n\n    def assignFreq(self):\n        \"\"\"\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i!= j:\n                    self.freq[(i, j)] += 1\n\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i!= j:\n                    self.freq[(i, j)] -= 1\n                    self.res[(i, j)] = self.freq[(i, j)]\n\n    def getFrequency(self, i, j):\n        \"\"\"\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.res[(i, j)]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/assign-frequency/solution/\n\n# 3ms 100%\nclass Solution {\n    public void assignFreq(int[] nums) {\n        int[] freq = new int[nums.length * nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if (i!= j) {\n                    freq[i * nums.length + j] = nums[i] * nums[j];\n                }\n            }\n        }\n        for (int i = 0; i < nums.length;",
      -12.234375
    ],
    [
      "class Solution(object):\n    def assignFreq(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        freq = [0] * (n + 1)\n        for num in nums:\n            freq[num] += 1\n        freq[0] = k\n        freq[n] = k\n        res = [0] * (k + 1)\n        for i in range(n + 1):\n            res[freq[i]] = i\n        return res\n\n# Note:\n# 1. k is a parameter.\n# 2. The function is a solution to the problem.",
      -12.703125
    ],
    [
      "class Solution:\n    # @param {ListNode[]} head\n    # @return {void} Do not return anything, modify head in-place instead.\n    def assignFreq(self, head):\n        n = 0\n        c = 0\n        while head:\n            head = head.next\n            n += 1\n        head = head.next\n        c = head.val\n        head = head.next\n        while head:\n            if head.val == c:\n                head.freq += 1\n            head = head.next\n        return\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    # head = ListNode(1)\n    # head.next = ListNode(2)\n    # head.next.next = ListNode(3)\n    # head.next.next.next = ListNode(3)\n    # head.next.next.next.next = ListNode(4)\n    # head.next.next.next.next.next = ListNode(5)\n    # head.next.next.next.next.next.next = ListNode(5)\n    # head.next.next.next.next.next.next.next = ListNode(6)\n    # head.next.next.next.next.next.next.next.next = ListNode(7)\n    # head.next.next.next.next.next.next.next.next.next = ListNode(8)\n    # head.next.next.next.next.next.next.next.next.next.next = ListNode(9)\n    # head.next.next.next.next.next.next.next.next.next.next.next = ListNode(10)\n    # head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    # head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    # head.next.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    # head.next.next",
      -12.8671875
    ],
    [
      "def find_frequency(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    frequency = [0] * len(tuple_list)\n    for t in tuple_list:\n        frequency[t[0]] += 1\n    return frequency\n\ndef find_frequency_recur(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    if len(tuple_list) == 1:\n        return [1]\n    frequency = [0] * len(tuple_list)\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            frequency[j] += frequency[j-1]\n    return frequency\n\ndef find_frequency_recur_2(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[int]\n    \"\"\"\n    if len(tuple_list) == 1:\n        return [1]\n    frequency = [0] * len(tuple_list)\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            if tuple_list[i][0] == tuple_list[j][0]:\n                frequency[j] += frequency[j-1]\n    return frequency\n\nif __name__ == '__main__':\n    tuple_list = [\n        (1, 2),\n        (1, 3),\n        (1, 4),\n        (2, 3),\n        (2, 4),\n        (3, 4),\n    ]\n    # print(find_frequency(tuple_list))\n    # print(find_frequency_recur(tuple_list))\n    # print(find_frequency_recur_2(tuple_list))",
      -13.453125
    ],
    [
      "def assign_frequency(tuple_list):\n    \"\"\"\n    Input is a list of tuples.\n    Output is a list of lists of tuples, where each inner list has frequency for that tuple.\n    For example:\n    >>> assign_frequency([(1, 2), (1, 2), (1, 2)])\n    [[(1, 2), (1, 2)], [(1, 2), (1, 2)], [(1, 2), (1, 2)]]\n    \"\"\"\n    frequency = {}\n    for tuple_list in tuple_list:\n        key = tuple(tuple_list)\n        if key not in frequency:\n            frequency[key] = 1\n        else:\n            frequency[key] += 1\n    return [[frequency[key], tuple_list] for key, tuple_list in frequency.items()]\n\ndef main():\n    \"\"\"\n    Simple test case.\n    \"\"\"\n    tuple_list = [('a', 1), ('a', 1), ('a', 1)]\n    frequency = assign_frequency(tuple_list)\n    print(frequency)\n    frequency = assign_frequency([('a', 1), ('a', 1), ('a', 1), ('b', 2), ('c', 3), ('d', 4)])\n    print(frequency)\n\nif __name__ == '__main__':\n    main()",
      -14.6640625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}