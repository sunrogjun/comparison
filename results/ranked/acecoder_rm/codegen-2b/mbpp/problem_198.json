{
  "problem": {
    "task_id": "MBPP/209",
    "prompt": "Write a function to delete the smallest element from the given heap and then insert a new item.",
    "canonical_solution": "import heapq as hq\r\ndef heap_replace(heap,a):\r\n  hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap",
    "test_list": [
      "assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]",
      "assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]",
      "assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]"
    ],
    "challenge_test_list": [],
    "problem_id": 198
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Heap(object):\n    \"\"\"\n    A min-heap is a heap where the smallest element is at the root, and the largest element is at the last.\n    \"\"\"\n\n    def __init__(self, heap):\n        self.heap = heap\n\n    def deleteMin(self):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        root = self.heap[0]\n        self.heap[0] = self.heap[self.heap.index(root)]\n        self.heap.remove(root)\n\n    def insert(self, item):\n        \"\"\"\n        :type item: int\n        :rtype: void\n        \"\"\"\n        self.heap.append(item)\n        self.heap.sort()\n        self.heap.reverse()\n        self.heap.insert(0, item)\n\n# Your Heap object will be instantiated and called as such:\n# obj = Heap(heap)\n# obj.insert(item)\n# obj.deleteMin()",
      1.16015625
    ],
    [
      "import heapq\n\nclass Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def push(self, item):\n        self.heap.append(item)\n        heapq.heappush(self.heap, item)\n\n    def pop(self):\n        if len(self.heap) == 0:\n            return None\n        else:\n            return heapq.heappop(self.heap)\n\n    def get_min(self):\n        return heapq.heappop(self.heap)\n\n    def get_max(self):\n        return heapq.heappop(self.heap)\n\n    def __len__(self):\n        return len(self.heap)\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\n    def clear(self):\n        self.heap = []",
      1.13671875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        if not root.left:\n            root = root.right\n            return\n\n        root.left = self.deleteMin(root.left)\n        root.left = self.insert(root.left, root.val)\n\n\n    def insert(self, root, val):\n        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insert(root.left, val)\n        else:\n            root.right = self.insert(root.right, val)\n        return root",
      0.9091796875
    ],
    [
      "import collections\n\nclass Heap:\n    def __init__(self):\n        self.heap = collections.deque()\n\n    def is_empty(self):\n        return self.heap.empty()\n\n    def insert(self, element):\n        self.heap.append(element)\n        self._heapify(self.heap)\n\n    def extract_min(self):\n        return self.heap.popleft()\n\n    def _heapify(self, heap):\n        while not heap.empty() and heap[0] > heap[-1]:\n            heap.popleft()\n            heap.appendleft(heap.pop())\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(1)\n    heap.insert(6)\n    heap.insert(3)\n    heap.insert(7)\n    heap.insert(2)\n    heap.insert(8)\n    heap.insert(4)\n\n    print heap.extract_min()\n    print heap.extract_min()\n    print heap.extract_min()",
      0.0175933837890625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        if not root.left:\n            root.val = root.right.val\n            root.right = None\n        else:\n            root.left = self.deleteMin(root.left)\n        return root",
      -0.0892333984375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root: return root\n        if not root.left:\n            return self.deleteMin(root.right)\n        if not root.right:\n            return self.deleteMin(root.left)\n        # find the smallest node in the left subtree\n        left_min = self.findMin(root.left)\n        # find the smallest node in the right subtree\n        right_min = self.findMin(root.right)\n        root.val = left_min.val\n        root.left = self.deleteMin(left_min.left)\n        root.right = self.deleteMin(right_min.right)\n        return root\n\n    def findMin(self, root):\n        while root.left:\n            root = root.left\n        return root",
      -0.410400390625
    ],
    [
      "class Heap:\n    \"\"\"Heap data structure\"\"\"\n\n    def __init__(self, *args):\n        self.data = list(args)\n\n    def build_heap(self):\n        \"\"\"Build a heap with the given data\"\"\"\n        for i in range(len(self.data) // 2):\n            self.heapify(i)\n\n    def heap_sort(self):\n        \"\"\"Sort the data in heap structure\"\"\"\n        while self.data:\n            self.data.pop()\n            self.heapify(0)\n        return self.data\n\n    def heap_insert(self, item):\n        \"\"\"Insert a new item to the heap structure\"\"\"\n        self.data.insert(0, item)\n        self.heapify(0)\n\n    def heap_delete(self):\n        \"\"\"Delete the smallest element from the heap structure\"\"\"\n        self.data.pop()\n        self.heapify(0)\n\n    def heap_extract(self):\n        \"\"\"Extract the smallest element from the heap structure\"\"\"\n        return self.data.pop(0)\n\n    def heap_extract_min(self):\n        \"\"\"Extract the smallest element from the heap structure\"\"\"\n        return self.data.pop(0)\n\n    def heapify(self, i):\n        \"\"\"Heapify the given node i\"\"\"\n        l = 2 * i + 1\n        r = 2 * i + 2\n        if l < len(self.data) and self.data[l] < self.data[i]:\n            self.data[i], self.data[l] = self.data[l], self.data[i]\n        elif r < len(self.data) and self.data[r] < self.data[i]:\n            self.data[i], self.data[r] = self.data[r], self.data[i]\n        if i > 0 and self.data[i] < self.data[i // 2]:\n            self.data[i], self.data[i // 2] = self.data[i // 2], self.data[i]\n            self.heapify(i // 2)\n\n\n\nif __name__ == \"__main__\":\n    heap",
      -0.767578125
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.heap = []\n        for elem in arr:\n            self.heap.append(elem)\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.pop(0)\n        self.heap[0] = val\n\n    def delete_min(self):\n        self.heap[0] = self.heap.pop(0)\n\n    def get_min(self):\n        return self.heap[0]\n\n    def get_max(self):\n        return self.heap[-1]\n\n# Your Heap object will be instantiated and called as such:\nheap = Heap(arr)\nheap.insert(1)\nheap.insert(2)\nheap.delete_min()\nheap.delete_min()\nheap.insert(3)\nheap.delete_min()\nheap.delete_min()\nheap.insert(4)\nheap.delete_min()\nheap.insert(5)\nheap.insert(6)\nheap.delete_min()\nheap.delete_min()\nheap.get_min()\nheap.get_max()",
      -0.845703125
    ],
    [
      "import heapq\n\nclass Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, element):\n        heapq.heappush(self.heap, element)\n\n    def delete_min(self):\n        return heapq.heappop(self.heap)\n\n    def delete_min_and_insert(self, element):\n        heapq.heappush(self.heap, element)\n        return self.delete_min()\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n    heap.insert(7)\n\n    print heap.delete_min_and_insert(3)\n    print heap.delete_min_and_insert(2)\n    print heap.delete_min_and_insert(1)\n    print heap.delete_min_and_insert(4)\n    print heap.delete_min_and_insert(5)\n    print heap.delete_min_and_insert(7)",
      -0.845703125
    ],
    [
      "from heapq import heappush, heappop\n\ndef delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void Do not return anything, modify heap in-place instead.\n    \"\"\"\n    # O(log(n))\n    heappush(heap, -heap[0])\n    heappop(heap)",
      -0.85693359375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        if not root:\n            return None\n        if root.val == val:\n            if root.left:\n                root = root.left\n            else:\n                root = root.right\n        else:\n            if root.val > val:\n                root.left = self.deleteNode(root.left, val)\n            else:\n                root.right = self.deleteNode(root.right, val)\n        return root",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param head, a list of ListNode\n    # @return a list of ListNode\n    def deleteMin(self, head):\n        if head is None or head.next is None:\n            return head\n\n        p = head\n        while p.next.next is not None:\n            p = p.next\n        head = p.next\n\n        p.next = None\n        p = head\n        while p is not None:\n            if p.next is None:\n                break\n            if p.next.next is not None:\n                p.next = p.next.next\n            else:\n                p.next = None\n                break\n            p = p.next\n\n        return head",
      -0.85791015625
    ],
    [
      "class Heap(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        Initialize your data structure here.\n        :type arr: List[int]\n        \"\"\"\n        self.heap = [i for i in arr]\n        self.size = len(arr)\n\n    def getMin(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.heap[0]\n\n    def deleteMin(self):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        self.heap.pop(0)\n        self.size -= 1\n\n    def insert(self, val):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        self.heap.append(val)\n        self.size += 1\n\n    def getMin(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.heap[0]\n\n\n# Your Heap object will be instantiated and called as such:\n# obj = Heap(arr)\n# obj.insert(val)\n# param_2 = obj.getMin()\n# obj.deleteMin()\n# param_4 = obj.getMin()",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return None\n        if not root.left:\n            root.val = root.right.val\n            root.right = root.right.right\n            return root\n        root.left.val = root.right.val\n        root.right = root.right.right\n        root.left.right = root.right\n        return root",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        \n        if root.left:\n            root.left = self.deleteMin(root.left)\n        \n        if root.val == root.left.val:\n            root.val = root.left.val\n            root.left = None\n        \n        if root.right:\n            root.right = self.deleteMin(root.right)\n        \n        if root.val == root.right.val:\n            root.val = root.right.val\n            root.right = None",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        while root.left:\n            root = root.left\n        root.left = root.right\n        root.right = None",
      -0.8583984375
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def is_empty(self):\n        return self.heap == []\n\n    def delete_min(self):\n        if self.is_empty():\n            return None\n\n        self.heap.pop()\n        return self.heap.pop()\n\n    def insert(self, value):\n        if self.is_empty():\n            self.heap.append(value)\n        else:\n            heap_value = self.heap[0]\n            if value < heap_value:\n                self.heap.insert(0, value)\n            else:\n                self.heap.append(value)\n\n        return self.heap[0]\n\n\n# Your Heap object will be instantiated and called as such:\n# obj = Heap()\n# param_1 = obj.insert(value)\n# param_2 = obj.delete_min()\n# param_3 = obj.is_empty()",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            root.left = right\n            root.right = None\n        else:\n            root.left = None\n            root.right = self.deleteMin(right)\n        \n        return root",
      -0.8583984375
    ],
    [
      "import heapq\n\n\ndef delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    heap.pop(0)\n\n\ndef insert(heap, item):\n    \"\"\"\n    :type heap: List[int]\n    :type item: int\n    :rtype: void\n    \"\"\"\n    heap.append(item)\n    heapq.heapify(heap)",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        curr = root\n        while curr.left:\n            curr = curr.left\n        # curr is the smallest node\n        if not curr.right:\n            # curr is the only node\n            root = curr.right\n        else:\n            # curr is not the only node\n            curr.val = curr.right.val\n            curr.right = curr.right.left\n            root = curr\n        return root",
      -0.85888671875
    ],
    [
      "import heapq\n\nclass Solution(object):\n    def deleteMin(self, heap):\n        \"\"\"\n        :type heap: List[int]\n        :rtype: void Do not return anything, modify heap in-place instead.\n        \"\"\"\n        heapq.heapify(heap)\n        while len(heap) > 1:\n            min_index = 0\n            for i in xrange(len(heap)):\n                if heap[i] < heap[min_index]:\n                    min_index = i\n            heapq.heappop(heap)\n            heapq.heappush(heap, heap[min_index])\n        heapq.heappush(heap, heap[0])\n        heapq.heapify(heap)\n\n    def insert(self, heap, value):\n        \"\"\"\n        :type heap: List[int]\n        :type value: int\n        :rtype: void Do not return anything, modify heap in-place instead.\n        \"\"\"\n        heapq.heappush(heap, value)\n        heapq.heapify(heap)",
      -0.88818359375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        \n        # delete the smallest element\n        root = self.deleteMin(root.left)\n        \n        # insert a new element\n        root.left = self.insert(root.left, root.val)\n        \n        return root\n    \n    def insert(self, root, val):\n        if not root:\n            return TreeNode(val)\n        \n        if val < root.val:\n            root.left = self.insert(root.left, val)\n        else:\n            root.right = self.insert(root.right, val)\n        \n        return root",
      -0.908203125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        if root is None:\n            return None\n\n        if root.val == val:\n            if root.left is None:\n                return root.right\n            else:\n                root.left = self.deleteNode(root.left, val)\n                return root\n        else:\n            if root.right is None:\n                return root.left\n            else:\n                root.right = self.deleteNode(root.right, val)\n                return root\n\n    def insertNode(self, root: TreeNode, val: int) -> TreeNode:\n        if root is None:\n            return TreeNode(val)\n        if root.val < val:\n            root.left = self.insertNode(root.left, val)\n        else:\n            root.right = self.insertNode(root.right, val)\n        return root\n\nroot = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)), TreeNode(5)), TreeNode(6, TreeNode(7)))\nprint(root)\nprint(Solution().insertNode(root, 8))",
      -1.11328125
    ],
    [
      "from heap import Heap\n\n\nclass Heap_Dup_Delete:\n    def __init__(self):\n        self.h = Heap()\n\n    def _heap_insert(self, val):\n        self.h.insert(val)\n\n    def _heap_delete_min(self):\n        self.h.delete_min()\n\n    def _heap_delete_max(self):\n        self.h.delete_max()\n\n    def _heap_delete_middle(self):\n        self.h.delete_middle()\n\n    def _heap_delete_val(self, val):\n        self.h.delete_val(val)\n\n    def _heap_delete_min_val(self):\n        self.h.delete_min_val()\n\n    def _heap_delete_max_val(self):\n        self.h.delete_max_val()\n\n    def _heap_delete_val_val(self, val):\n        self.h.delete_val_val(val)\n\n    def _heap_delete_val_min(self):\n        self.h.delete_val_min()\n\n    def _heap_delete_val_max(self):\n        self.h.delete_val_max()\n\n    def _heap_delete_val_min_val(self):\n        self.h.delete_val_min_val()\n\n    def _heap_delete_val_max_val(self):\n        self.h.delete_val_max_val()\n\n    def _heap_delete_val_min_val_val(self, val):\n        self.h.delete_val_min_val_val(val)\n\n    def _heap_delete_val_min_val_max(self):\n        self.h.delete_val_min_val_max()\n\n    def _heap_delete_val_min_val_max_val(self, val):\n        self.h.delete_val_min_val_max_val(val)\n\n    def _heap_delete_val_min_val_max_val_val(self, val):\n        self.h.delete_val_min_val_max",
      -2.697265625
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.sink(len(self.heap) - 1)\n\n    def sink(self, index):\n        while index > 0:\n            parent_index = (index - 1) >> 1\n            if self.heap[parent_index] < self.heap[index]:\n                break\n            else:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n\n    def deleteMin(self):\n        if len(self.heap) == 0:\n            return None\n        self.heap.pop()\n        self.sink(0)\n        return self.heap[0]\n\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    print heap.deleteMin()\n    print heap.deleteMin()\n    print heap.deleteMin()",
      -3.173828125
    ],
    [
      "class Heap:\n    def __init__(self, array):\n        self.heap = array\n\n    def delete_smallest(self):\n        self.heap.pop()\n\n    def insert(self, item):\n        self.heap.append(item)\n\n    def is_empty(self):\n        return self.heap.__len__() == 0\n\n    def get_min(self):\n        return self.heap[0]\n\n    def get_max(self):\n        return self.heap[-1]\n\nif __name__ == \"__main__\":\n    heap = Heap([1, 2, 3, 4, 5, 6, 7])\n    heap.insert(10)\n    heap.delete_smallest()\n    heap.insert(8)\n    heap.delete_smallest()\n    heap.insert(9)\n    heap.delete_smallest()\n    heap.insert(10)\n    heap.insert(11)\n    heap.insert(12)\n    heap.insert(13)\n    heap.insert(14)\n    heap.insert(15)\n    heap.insert(16)\n    heap.insert(17)\n    heap.insert(18)\n    heap.insert(19)\n    heap.insert(20)\n    heap.insert(21)\n    heap.insert(22)\n    heap.insert(23)\n    heap.insert(24)\n    heap.insert(25)\n    heap.insert(26)\n    heap.insert(27)\n    heap.insert(28)\n    heap.insert(29)\n    heap.insert(30)\n    heap.insert(31)\n    heap.insert(32)\n    heap.insert(33)\n    heap.insert(34)\n    heap.insert(35)\n    heap.insert(36)\n    heap.insert(37)\n    heap.insert(38)\n    heap.insert(39)\n    heap.insert(40)\n    heap.insert(41)\n    heap.insert(42",
      -3.185546875
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def build_heap(self, arr):\n        self.heap = arr[:]\n        for i in range(len(arr) - 1):\n            self.sift_up(i)\n\n    def sift_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.heap[parent] < self.heap[index]:\n                self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent]\n                index = parent\n            else:\n                break\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.sift_up(len(self.heap) - 1)\n\n    def delete_min(self):\n        self.heap.pop()\n        self.sift_up(0)\n\n    def print_heap(self):\n        for i in range(len(self.heap)):\n            print(self.heap[i], end=\" \")\n        print()\n\n\narr = [2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\nheap = Heap()\nheap.build_heap(arr)\nheap.insert(7)\nheap.print_heap()\nheap.delete_min()\nheap.print_heap()",
      -3.298828125
    ],
    [
      "class Heap:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.heap = []\n        self.size = 0\n\n    def push(self, val):\n        \"\"\"\n        Adds a new item to the heap.\n        :type val: int\n        \"\"\"\n        self.heap.append(val)\n        self.size += 1\n        self._siftUp(len(self.heap) - 1)\n\n    def pop(self):\n        \"\"\"\n        Removes the smallest item from the heap and returns it.\n        :rtype: int\n        \"\"\"\n        if self.size == 0:\n            return None\n        ret = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.size -= 1\n        self._siftDown(0)\n        return ret\n\n    def _siftUp(self, pos):\n        \"\"\"\n        Sift up.\n        :type pos: int\n        :rtype: void\n        \"\"\"\n        while pos > 1 and self.heap[pos / 2] > self.heap[pos]:\n            self.heap[pos] = self.heap[pos / 2]\n            pos /= 2\n        self.heap[pos] = self.heap[pos]\n\n    def _siftDown(self, pos):\n        \"\"\"\n        Sift down.\n        :type pos: int\n        :rtype: void\n        \"\"\"\n        while pos * 2 <= self.size:\n            if pos * 2 + 1 <= self.size and self.heap[pos * 2] < self.heap[pos * 2 + 1]:\n                pos *= 2\n            elif pos * 2 + 1 > self.size:\n                break\n            else:\n                if self.heap[pos * 2] < self.heap[pos * 2 + 1]:\n                    self.heap[pos] = self.heap[pos * 2]\n                else:\n                    self.heap[pos] = self.heap[pos * 2 + 1]\n                pos *= 2\n                \n\n# Your Heap object will be instantiated and called as",
      -3.3125
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n    \n    def _build_heap(self, heap):\n        while len(heap) > 1:\n            min_index = len(heap) // 2\n            min_value = heap[min_index]\n            heap[min_index] = heap[0]\n            heap[0] = min_value\n            heap.pop(0)\n            heap.insert(0, min_value)\n    \n    def build_heap(self, heap):\n        self._build_heap(heap)\n    \n    def _delete_min(self, heap):\n        min_index = 0\n        min_value = heap[0]\n        heap[0] = heap[len(heap) - 1]\n        heap.pop()\n        self._build_heap(heap)\n        return min_value\n    \n    def delete_min(self):\n        return self._delete_min(self.heap)\n    \n    def insert(self, value):\n        self.heap.insert(0, value)\n        self._build_heap(self.heap)\n        \n    def get_min(self):\n        return self.heap[0]\n    \n    def get_heap(self):\n        return self.heap\n    \nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    \n    print(heap.get_min())\n    heap.delete_min()\n    print(heap.get_min())\n    heap.insert(1)\n    print(heap.get_min())\n    heap.insert(5)\n    print(heap.get_min())\n    heap.insert(7)\n    print(heap.get_min())\n    heap.insert(6)\n    print",
      -3.322265625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root: return\n        # find the smallest node\n        while root.left:\n            root = root.left\n        # delete the smallest node\n        root.left = root.right\n        # insert the new node\n        root.right = root.right.left\n        root.right.left = root.right.right = None\n        return\n\n# Test cases\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint Solution().deleteMin(root)\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint Solution().deleteMin(root)",
      -3.423828125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n\n        # find the smallest element\n        smallest = root\n        while smallest.left:\n            smallest = smallest.left\n\n        # delete the smallest element\n        smallest.left = smallest.right\n        smallest.right = None\n\n        # insert a new element\n        if not root:\n            return TreeNode(smallest.val)\n        else:\n            root.left = self.deleteMin(root.left)\n            return root\n\n    # @param root: The root of binary tree.\n    # @return: void\n    def insert(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return TreeNode(val)\n        else:\n            root.left = self.insert(root.left, val)\n            return root",
      -3.642578125
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        heap_item = [value, None]\n        self.heap.append(heap_item)\n        self.heapify()\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        self.heap[0] = self.heap.pop()\n        self.heapify()\n\n    def heapify(self):\n        if len(self.heap) == 0:\n            return\n        left = self.heap[0][0]\n        right = self.heap[0][0]\n        parent = None\n        while left <= right:\n            parent = (left + right) / 2\n            if parent < self.heap[0][0]:\n                left = parent + 1\n            else:\n                right = parent - 1\n        if left <= self.heap[0][0]:\n            self.heap[0][0] = left\n        else:\n            self.heap[0][0] = right\n        self.heapify()\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.heap[0][0]\n\n    def size(self):\n        return len(self.heap)\n\nclass HeapAppend:\n    def __init__(self):\n        self.heap = Heap()\n\n    def push(self, value):\n        self.heap.insert(value)\n\n    def pop(self):\n        if self.heap.is_empty():\n            return None\n        return self.heap.delete()\n\ndef test():\n    h = HeapAppend()\n    h.push(1)\n    h.push(2)\n    h.push(3)\n    h.push(4)\n    h.push(5)\n    h.push(6)\n    h.push(7)\n    h.push(8)\n    h.push(9)\n    h.push(",
      -3.744140625
    ],
    [
      "from heapq import heappush, heappop, heapify, heapreplace, heapq\nfrom math import log\n\nclass Heap:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def deleteMin(self):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void\n        \"\"\"\n        if not self.arr:\n            return\n        self.arr.pop()\n        heapify(self.arr)\n\n    def insert(self, val):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: void\n        \"\"\"\n        heappush(self.arr, val)\n        heapify(self.arr)\n\n\ndef testHeap():\n    print(Heap([1, 3, 2, 5, 4]).insert(4))\n    print(Heap([1, 3, 2, 5, 4]).insert(3))\n    print(Heap([1, 3, 2, 5, 4]).insert(2))\n    print(Heap([1, 3, 2, 5, 4]).insert(1))\n    print(Heap([1, 3, 2, 5, 4]).insert(5))\n\nif __name__ == '__main__':\n    testHeap()",
      -3.755859375
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.data = []\n\n    def is_empty(self):\n        return len(self.data) == 0\n\n    def is_full(self):\n        return len(self.data) == len(self.data) + 1\n\n    def insert(self, item):\n        self.data.append(item)\n        self.siftup(len(self.data) - 1)\n\n    def delete(self):\n        if len(self.data) == 0:\n            return\n        self.data.pop()\n        self.siftdown(0)\n\n    def peek(self):\n        if len(self.data) == 0:\n            return None\n        return self.data[0]\n\n    def get_min(self):\n        if len(self.data) == 0:\n            return None\n        return self.data[0]\n\n    def siftup(self, i):\n        while i > 0:\n            parent = (i - 1) / 2\n            if self.data[i] < self.data[parent]:\n                break\n            self.data[i], self.data[parent] = self.data[parent], self.data[i]\n            i = parent\n\n    def siftdown(self, i):\n        child = 2 * i + 1\n        while child < len(self.data):\n            if child + 1 < len(self.data) and self.data[child] < self.data[child + 1]:\n                child += 1\n            if self.data[i] < self.data[child]:\n                break\n            self.data[i], self.data[child] = self.data[child], self.data[i]\n            i = child\n\n\n\nif __name__ == \"__main__\":\n    h = Heap()\n    h.insert(2)\n    h.insert(4)\n    h.insert(6)\n    h.insert(1)\n    h.insert(3)\n    h.insert(5)\n    h.insert(7)\n    h.insert(0)\n    h.insert(8)\n    h.insert(10)\n    h.insert(",
      -3.826171875
    ],
    [
      "def delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    heap_length = len(heap)\n    if heap_length == 0:\n        return\n    smallest_index = 0\n    smallest_value = heap[0]\n    for i in range(1, heap_length):\n        if heap[i] < smallest_value:\n            smallest_index = i\n            smallest_value = heap[i]\n    heap[smallest_index] = heap[0]\n    heap[0] = heap[heap_length - 1]\n    heap_length -= 1\n    return\n\n\ndef insert(heap, value):\n    \"\"\"\n    :type heap: List[int]\n    :type value: int\n    :rtype: void\n    \"\"\"\n    heap_length = len(heap)\n    if heap_length == 0:\n        heap.append(value)\n        return\n    if value < heap[0]:\n        heap[0] = value\n        return\n    if value > heap[heap_length - 1]:\n        heap.append(value)\n        return\n    smallest_index = 0\n    smallest_value = heap[0]\n    for i in range(1, heap_length):\n        if heap[i] < smallest_value:\n            smallest_index = i\n            smallest_value = heap[i]\n    heap[smallest_index] = value\n    return",
      -4.1484375
    ],
    [
      "import heapq\n\n\ndef delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    heapq.heapify(heap)\n    heap[0], heap[-1] = heap[-1], heap[0]\n    heapq.heapify(heap)\n\n\ndef insert(heap, element):\n    \"\"\"\n    :type heap: List[int]\n    :type element: int\n    :rtype: void\n    \"\"\"\n    heapq.heappush(heap, element)\n    heapq.heapify(heap)\n\n\nif __name__ == '__main__':\n    heap = [1, 3, 5, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n    delete_smallest(heap)\n    assert heap == [3, 5, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n    insert(heap, 17)\n    assert heap == [3, 5, 7, 9, 10, 11, 12, 13, 14, 15, 17, 16]",
      -4.171875
    ],
    [
      "class MinHeap(object):\n    \"\"\"\n    Implementation of a min-heap.\n    \"\"\"\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        \"\"\"\n        Insert a value into the heap.\n        \"\"\"\n        self.heap.append(value)\n\n    def delete_min(self):\n        \"\"\"\n        Delete the smallest element from the heap.\n        \"\"\"\n        return self.heap.pop(0)\n\n    def print_heap(self):\n        \"\"\"\n        Print the heap.\n        \"\"\"\n        for i in self.heap:\n            print i,\n\n    def add_all(self, values):\n        \"\"\"\n        Add all values into the heap.\n        \"\"\"\n        for v in values:\n            self.insert(v)\n\n    def delete_all(self):\n        \"\"\"\n        Delete all elements from the heap.\n        \"\"\"\n        while len(self.heap) > 0:\n            self.heap.pop(0)\n\n    def get_min(self):\n        \"\"\"\n        Get the smallest element from the heap.\n        \"\"\"\n        return self.heap[0]\n\n    def is_empty(self):\n        \"\"\"\n        Check if the heap is empty.\n        \"\"\"\n        return len(self.heap) == 0\n\n    def empty(self):\n        \"\"\"\n        Empty the heap.\n        \"\"\"\n        self.heap = []\n\n    def __repr__(self):\n        return \"MinHeap()\"",
      -4.203125
    ],
    [
      "class Heap(object):\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n\n    def deleteMin(self):\n        return self.arr.pop(0)\n\n    def insert(self, item):\n        self.arr.append(item)\n        self.size += 1\n        self.heapify(self.size)\n\n    def heapify(self, index):\n        left = 2*index + 1\n        right = 2*index + 2\n        largest = index\n\n        if left < self.size and self.arr[left] > self.arr[index]:\n            largest = left\n        if right < self.size and self.arr[right] > self.arr[largest]:\n            largest = right\n\n        if largest!= index:\n            self.arr[index], self.arr[largest] = self.arr[largest], self.arr[index]\n            self.heapify(largest)\n\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    heap = Heap(arr)\n    heap.insert(10)\n    heap.insert(9)\n    heap.insert(8)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    print heap.arr\n\n    heap.deleteMin()\n    print heap.arr",
      -4.28515625
    ],
    [
      "def delete_min(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: int\n    \"\"\"\n    if not heap: return None\n    return heap.pop()\n\ndef insert(heap,val):\n    \"\"\"\n    :type heap: List[int]\n    :type val: int\n    :rtype: None\n    \"\"\"\n    heap.append(val)\n    heap.sort()\n    return\n\nclass Solution(object):\n    def deleteAndInsert(self, heap, val):\n        \"\"\"\n        :type heap: List[int]\n        :type val: int\n        :rtype: None\n        \"\"\"\n        heap.pop()\n        insert(heap, val)\n        return\n\nif __name__ == '__main__':\n    sol = Solution()\n    heap = [5,6,7,3,1,8]\n    print(heap)\n    sol.deleteAndInsert(heap, 8)\n    print(heap)\n    sol.deleteAndInsert(heap, 1)\n    print(heap)\n    sol.deleteAndInsert(heap, 5)\n    print(heap)\n    sol.deleteAndInsert(heap, 6)\n    print(heap)\n    sol.deleteAndInsert(heap, 3)\n    print(heap)\n    sol.deleteAndInsert(heap, 7)\n    print(heap)\n    sol.deleteAndInsert(heap, 4)\n    print(heap)\n    sol.deleteAndInsert(heap, 2)\n    print(heap)\n    sol.deleteAndInsert(heap, 8)\n    print(heap)\n    sol.deleteAndInsert(heap, 9)\n    print(heap)",
      -4.3125
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = [0]\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.up(len(self.heap) - 1)\n\n    def extract(self):\n        ret = self.heap[0]\n        self.heap[0] = self.heap[len(self.heap) - 1]\n        self.heap[len(self.heap) - 1] = 0\n        self.down(0)\n        return ret\n\n    def up(self, i):\n        while i > 0 and self.heap[i] > self.heap[(i / 2) - 1]:\n            temp = self.heap[i]\n            self.heap[i] = self.heap[(i / 2) - 1]\n            self.heap[(i / 2) - 1] = temp\n            i = (i / 2) - 1\n\n    def down(self, i):\n        while i < len(self.heap) - 1 and self.heap[(i * 2) + 1] > self.heap[i]:\n            temp = self.heap[i]\n            self.heap[i] = self.heap[(i * 2) + 1]\n            self.heap[(i * 2) + 1] = temp\n            i = (i * 2) + 1\n\n# Your Heap object will be instantiated and called as such:\n# obj = Heap()\n# obj.insert(val)\n# param_2 = obj.extract()",
      -4.31640625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def deleteMin(self, root):\n        if root is None:\n            return\n\n        left = root.left\n        right = root.right\n\n        if left is None:\n            root.left = right\n        else:\n            left.right = right\n\n        if right is None:\n            root.right = left\n        else:\n            right.left = left\n\n        self.deleteMin(root.left)\n        self.deleteMin(root.right)\n        root.left = None\n        root.right = None\n\nif __name__ == \"__main__\":\n    s = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n\n    s.deleteMin(root)\n\n    print(root)",
      -4.5078125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return root\n        while root.left:\n            root = root.left\n        root.left = root.right\n        root.right = None\n        return root",
      -4.55859375
    ],
    [
      "class Heap(object):\n\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify()\n\n    def peek(self):\n        return self.heap[0]\n\n    def delete_min(self):\n        self.heap[0] = self.heap.pop()\n        self.heapify()\n\n    def heapify(self):\n        if len(self.heap) == 1:\n            return\n\n        left = 0\n        right = len(self.heap) - 1\n        min_index = left\n\n        while left < right:\n            if self.heap[left] < self.heap[min_index]:\n                min_index = left\n            elif self.heap[left] > self.heap[min_index]:\n                min_index = right\n\n            if min_index!= left:\n                self.heap[min_index], self.heap[left] = self.heap[left], self.heap[min_index]\n\n            left += 1\n            right -= 1\n\n\nclass Solution(object):\n    def deleteAndInsert(self, heap, val):\n        \"\"\"\n        :type heap: Heap\n        :type val: int\n        :rtype: void Do not return anything, modify heap in-place instead.\n        \"\"\"\n        heap.delete_min()\n        heap.insert(val)",
      -4.609375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport collections\n\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n\n        if val < root.val:\n            root.left = self.deleteNode(root.left, val)\n            if root.left:\n                root.left = root.left\n        elif val > root.val:\n            root.right = self.deleteNode(root.right, val)\n            if root.right:\n                root.right = root.right\n        else:\n            if root.left:\n                root.val = root.left.val\n            if root.right:\n                root.val = root.right.val\n\n        return root\n\n    def insert(self, root, val):\n        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insert(root.left, val)\n        elif val > root.val:\n            root.right = self.insert(root.right, val)\n        return root\n\n\nclass Solution2:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        if root.val == val:\n            if root.left:\n                root.left = self.deleteNode(root.left, val)\n            else:\n                root = None\n        elif root.val > val:\n            root.right = self.deleteNode(root.right, val)\n        return root\n\n    def insert(self, root, val):\n        if not root:\n            return TreeNode(val)\n        if val < root.val:",
      -4.61328125
    ],
    [
      "from heap import Heap\n\nclass Solution(object):\n    def deleteMin(self, heap):\n        \"\"\"\n        :type heap: Heap\n        :rtype: void Do not return anything, modify heap in-place instead.\n        \"\"\"\n        heap.delete()\n        heap.insert(heap.getMin())\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    heap = Heap()\n    heap.insert(10)\n    heap.insert(2)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(1)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n\n    sol.deleteMin(heap)\n    print heap.getMin()",
      -4.88671875
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n        self.max_size = 0\n\n    def insert(self, item):\n        self.heap.append(item)\n        self.max_size += 1\n        self.heapify()\n\n    def delete(self):\n        self.heap.pop()\n        self.max_size -= 1\n        self.heapify()\n\n    def heapify(self):\n        if len(self.heap) == 0:\n            return\n        if len(self.heap) == 1:\n            return\n        l = len(self.heap) - 1\n        r = l / 2\n        while r >= 0:\n            if self.heap[l] > self.heap[r]:\n                # heap[l] > heap[r]\n                # swap\n                self.heap[l], self.heap[r] = self.heap[r], self.heap[l]\n                l = r\n                r = l / 2\n            else:\n                return\n\n    def heap_max(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap[0]\n\n    def heap_min(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap[0]\n\n\n# Your Heap object will be instantiated and called as such:\n# h = Heap()\n# h.insert(1)\n# h.insert(2)\n# h.insert(3)\n# h.delete()\n# h.delete()\n# h.delete()\n# h.heap_max()\n# h.heap_min()",
      -4.94140625
    ],
    [
      "class MinHeap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.heap = []\n\n    def insert(self, item):\n        heap_item = item\n        if len(self.heap) == 0:\n            self.heap.append(heap_item)\n            return\n        while len(self.heap) > 1:\n            if self.heap[0] > heap_item:\n                self.heap[0] = heap_item\n                return\n            else:\n                self.heap[0] = heap_item\n                heap_item = heap_item\n        self.heap.append(heap_item)\n\n    def delete_min(self):\n        self.heap.pop(0)\n\n    def insert_heap(self, item):\n        self.heap.insert(0, item)\n        self.heap.sort()\n\n    def delete_heap(self):\n        self.heap.pop()\n        self.heap.sort()\n\n    def heap_insert(self, item):\n        self.heap.insert(0, item)\n        self.heap.sort()\n\n    def heap_delete(self):\n        self.heap.pop()\n        self.heap.sort()\n\nif __name__ == \"__main__\":\n    heap = MinHeap([4, 5, 6, 7, 8, 9])\n    heap.insert_heap(1)\n    heap.insert_heap(2)\n    heap.insert_heap(3)\n    heap.insert_heap(4)\n    heap.insert_heap(5)\n    heap.insert_heap(6)\n    heap.insert_heap(7)\n    heap.insert_heap(8)\n    heap.insert_heap(9)\n    heap.insert_heap(10)\n    heap.insert_heap(11)\n    heap.insert_heap(12)\n    heap.insert_heap(13)\n    heap.insert_heap(14)\n    heap.",
      -5.07421875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        if root is None:\n            return None\n\n        if root.left is None:\n            return root.right\n        if root.right is None:\n            return root.left\n        root.left = self.deleteMin(root.left)\n        root.val = min(root.val, root.left.val, root.right.val)\n        return root",
      -5.13671875
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = [0]\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\n    def insert(self, item):\n        if self.is_empty():\n            self.heap.append(item)\n        else:\n            self.heap.append(self.heap[0])\n            self.heap.pop(0)\n            self.heap.insert(item)\n\n    def delete_min(self):\n        if self.is_empty():\n            raise Exception(\"Cannot delete minimum element of empty heap.\")\n        return self.heap.pop(0)\n\n    def insert_min(self, item):\n        self.insert(item)\n        return self.delete_min()\n\n    def get_min(self):\n        if self.is_empty():\n            raise Exception(\"Cannot get minimum element of empty heap.\")\n        return self.heap[0]\n\n    def get_size(self):\n        return len(self.heap)\n\n    def get_max(self):\n        if self.is_empty():\n            raise Exception(\"Cannot get maximum element of empty heap.\")\n        return self.heap[-1]\n\n    def get_heap(self):\n        return self.heap\n\n    def print_heap(self):\n        print(self.heap)\n\n# Your Heap object will be instantiated and called as such:\nheap = Heap()\nheap.insert_min(1)\nheap.insert_min(2)\nheap.insert_min(3)\nheap.print_heap()\nheap.insert_min(4)\nheap.print_heap()",
      -5.30859375
    ],
    [
      "from heapq import heappop, heappush\n\ndef delete_min(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    if len(heap) == 0:\n        return\n    heappop(heap)\n    return\n\n\ndef insert(heap, value):\n    \"\"\"\n    :type heap: List[int]\n    :type value: int\n    :rtype: void\n    \"\"\"\n    heappush(heap, value)\n    return\n\nif __name__ == \"__main__\":\n    heap = [5, 4, 1, 3, 2]\n    insert(heap, 0)\n    insert(heap, 8)\n    delete_min(heap)\n    print(heap)\n    insert(heap, 5)\n    print(heap)\n    insert(heap, 6)\n    print(heap)\n    insert(heap, 3)\n    print(heap)\n    insert(heap, 7)\n    print(heap)\n    insert(heap, 6)\n    print(heap)\n    insert(heap, 2)\n    print(heap)\n    insert(heap, 4)\n    print(heap)\n    insert(heap, 9)\n    print(heap)\n    insert(heap, 0)\n    print(heap)\n    insert(heap, 5)\n    print(heap)\n    insert(heap, 6)\n    print(heap)\n    insert(heap, 3)\n    print(heap)\n    insert(heap, 7)\n    print(heap)\n    insert(heap, 6)\n    print(heap)\n    insert(heap, 2)\n    print(heap)\n    insert(heap, 4)\n    print(heap)\n    insert(heap, 9)\n    print(heap)\n    insert(heap, 0)\n    print(heap)\n    insert(heap, 5)\n    print(heap)\n    insert(heap, 6)\n    print(heap)\n    insert(he",
      -5.3203125
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def build_heap(self, list):\n        for i in range(0, len(list)):\n            self.heap.append(list[i])\n            self.percolate_up(i)\n\n    def percolate_up(self, i):\n        while i > 0:\n            parent = (i - 1) / 2\n            if self.heap[parent] > self.heap[i]:\n                self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n                i = parent\n            else:\n                break\n\n    def percolate_down(self, i):\n        while i * 2 + 1 < len(self.heap):\n            child = i * 2 + 1\n            if child + 1 < len(self.heap) and self.heap[child] < self.heap[child + 1]:\n                child = child + 1\n            if self.heap[i] > self.heap[child]:\n                break\n            self.heap[i], self.heap[child] = self.heap[child], self.heap[i]\n            i = child\n        if i!= 0:\n            self.heap[i] = self.heap[0]\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.percolate_up(len(self.heap) - 1)\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n        self.heap[0], self.heap[len(self.heap) - 1] = self.heap[len(self.heap) - 1], self.heap[0]\n        self.heap.pop()\n        self.percolate_down(0)\n\n    def delete_min_and_insert(self, value):\n        self.delete_min()\n        self.insert(value)\n\n    def print_heap(self):\n        print(self.heap)\n\nif __name",
      -5.453125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        while root:\n            if not root.left:\n                root = root.right\n            else:\n                root = root.left\n        root.left = root.right\n        root.right = None\n        return root\n    \n    def insert(self, root, val):\n        if not root:\n            root = TreeNode(val)\n            return root\n        else:\n            if val < root.val:\n                root.left = self.insert(root.left, val)\n            elif val > root.val:\n                root.right = self.insert(root.right, val)\n            return root\n    \n    def build_tree(self, data):\n        root = None\n        for val in data:\n            if root is None:\n                root = TreeNode(val)\n            else:\n                root = self.insert(root, val)\n        return root",
      -5.48046875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        root.left, root.right = root.right, root.left\n        if not root.left:\n            return\n        root.left.right, root.left.left = root.left, None\n        self.deleteMin(root.left)\n\n# Note:\n# 1. use recursion to delete\n# 2. use post-order to get root",
      -5.67578125
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n        self.heap = [x for x in arr]\n        self.heapify()\n\n    def heapify(self):\n        for i in range(self.size-1, -1, -1):\n            if self.arr[i] < self.arr[0]:\n                self.arr[0], self.arr[i] = self.arr[i], self.arr[0]\n                self.heapify()\n\n    def delete_min(self):\n        self.arr[0], self.arr[-1] = self.arr[-1], self.arr[0]\n        self.heap[0] = self.arr[-1]\n        self.heapify()\n        return self.arr[0]\n\n    def insert(self, item):\n        self.arr[self.size] = item\n        self.heap[self.size] = item\n        self.size += 1\n        self.heapify()\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(self.arr[i], self.heap[i])\n\n\ndef main():\n    arr = [3, 2, 4, 1, 5, 6, 7]\n    h = Heap(arr)\n    h.print_heap()\n    h.delete_min()\n    h.print_heap()\n\n    print(\"\")\n    arr = [3, 2, 4, 1, 5, 6, 7]\n    h = Heap(arr)\n    h.insert(8)\n    h.print_heap()\n\n    print(\"\")\n    arr = [3, 2, 4, 1, 5, 6, 7]\n    h = Heap(arr)\n    h.insert(8)\n    h.insert(9)\n    h.insert(10)\n    h.print_heap()\n\n    print(\"\")\n    arr = [3, 2, 4, 1, 5, 6, 7]\n    h = Heap(arr)\n    h.insert(8)\n    h.",
      -5.70703125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if root is None:\n            return\n        self.deleteMin(root.left)\n        root.left = None\n        if root.right is not None:\n            self.deleteMin(root.right)\n        root.right = None\n\n# Note:\n# For a heap, the smallest element is always the left-most node in the right subtree.\n# You can delete the smallest element from the left subtree by reversing the tree.\n# After the deletion, you can insert the new element in the left subtree.",
      -5.73046875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> None:\n        \"\"\"\n        O(n)\n        \"\"\"\n        if root is None:\n            return\n\n        while root.left:\n            root = root.left\n        root.left = root.right\n        root.right = None\n        root.val = root.left.val\n\n    def insert(self, root: TreeNode, val: int) -> None:\n        \"\"\"\n        O(1)\n        \"\"\"\n        if root is None:\n            root = TreeNode(val)\n        else:\n            root.left = TreeNode(val)\n            root.right = None\n\n        while root.left and root.right:\n            if root.left.val < root.right.val:\n                root.right = root.left\n                root.left = root.left.right\n            else:\n                root.left = root.left.right\n                root.right = root.right.left",
      -5.88671875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n\n        if not root.left:\n            return root.right\n\n        # remove the smallest element\n        root.left = self.deleteMin(root.left)\n        root.left = self.insert(root.left, root.val)\n\n        return root\n    \n    def insert(self, root, x):\n        if not root:\n            root = TreeNode(x)\n            return root\n\n        if x <= root.val:\n            root.left = self.insert(root.left, x)\n            return root\n\n        root.right = self.insert(root.right, x)\n        return root\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n\n    print(sol.deleteMin(root))",
      -5.9296875
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n        self.build_heap()\n\n    def build_heap(self):\n        for i in range(self.size/2, -1, -1):\n            self.heapify(i)\n\n    def heapify(self, i):\n        while i > 0:\n            parent = (i-1) // 2\n            if self.arr[parent] > self.arr[i]:\n                break\n            else:\n                self.arr[parent], self.arr[i] = self.arr[i], self.arr[parent]\n                i = parent\n\n    def delete_smallest(self):\n        self.arr[0], self.arr[1] = self.arr[1], self.arr[0]\n        self.heapify(0)\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.heapify(self.size)\n\n    def get_min(self):\n        return self.arr[0]\n\n    def get_max(self):\n        return self.arr[self.size-1]\n\n    def get_size(self):\n        return self.size\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(self.arr[i], end=\" \")\n        print()\n\n\n# Your Heap object will be instantiated and called as such:\n# obj = Heap(nums)\n# param_1 = obj.insert(val)\n# param_2 = obj.get_min()\n# param_3 = obj.get_max()\n# param_4 = obj.get_size()\n# param_5 = obj.print_heap()\n# param_6 = obj.delete_smallest()",
      -5.93359375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        if not root:\n            return None\n        if root.val == val:\n            if root.right:\n                root.right = self.deleteNode(root.right, val)\n                return root\n            else:\n                root = root.left\n                return root\n        elif root.val > val:\n            root.left = self.deleteNode(root.left, val)\n        else:\n            root.right = self.deleteNode(root.right, val)\n        return root\n\n\n# TESTS\ntests = [\n    ([], [], []),\n    ([1], [1], []),\n    ([1, 1], [1, 1], [1]),\n    ([1, 1, 1], [1, 1, 1], [1]),\n    ([1, 2, 3], [1, 2, 3], [1, 2, 3]),\n]\n\nfor t in tests:\n    sol = Solution()\n    root = t[0]\n    actual = t[1]\n    expected = t[2]\n    actual = sol.deleteNode(root, 1)\n    print(actual)\n    assert actual == expected",
      -6.0234375
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = [0]\n\n    def build(self, arr):\n        for i in range(len(arr)):\n            self.heap.append(arr[i])\n            self.heapify(i)\n\n    def heapify(self, i):\n        while i > 0:\n            parent = (i - 1) / 2\n            if self.heap[parent] < self.heap[i]:\n                break\n            elif self.heap[parent] > self.heap[i]:\n                self.heap[i] = self.heap[parent]\n                self.heap[parent] = self.heap[i]\n                i = parent\n            else:\n                break\n\n    def deleteMin(self):\n        if len(self.heap) == 1:\n            return None\n        else:\n            self.heap[0] = self.heap[1]\n            self.heapify(0)\n            return self.heap.pop()\n\n    def insert(self, num):\n        self.heap.append(num)\n        self.heapify(len(self.heap) - 1)\n        return self.heap[-1]\n\n    def printHeap(self):\n        print(self.heap)\n\nif __name__ == '__main__':\n    heap = Heap()\n    arr = [3, 2, 1, 0, 9]\n    heap.build(arr)\n    print(heap.printHeap())\n    print(heap.deleteMin())\n    print(heap.insert(0))\n    print(heap.printHeap())",
      -6.09765625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root: return\n        \n        # get the smallest element\n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        self.deleteMin(root.left)\n        return\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(3)\n    root.left = TreeNode(2)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    sol.deleteMin(root)\n    print root.val, root.left.val, root.right.val\n    sol.deleteMin(root)\n    print root.val, root.left.val, root.right.val",
      -6.13671875
    ],
    [
      "from heapq import heappush, heappop, heapify\n\ndef delete_and_insert(heap, item):\n    heappop(heap)\n    heappush(heap, item)\n\ndef delete_smallest(heap):\n    heappop(heap)\n\ndef insert(heap, item):\n    heappush(heap, item)\n\ndef delete_and_insert_with_heap(heap, item):\n    delete_smallest(heap)\n    insert(heap, item)\n\ndef delete_smallest_with_heap(heap):\n    delete_smallest(heap)\n\ndef delete_smallest_with_heap_and_insert(heap, item):\n    delete_smallest(heap)\n    insert(heap, item)\n\ndef delete_smallest_with_heap_and_insert_with_heap(heap, item):\n    delete_smallest_with_heap(heap)\n    insert_with_heap(heap, item)\n\ndef delete_smallest_with_heap_and_insert_with_heap_and_heapify(heap, item):\n    delete_smallest_with_heap(heap)\n    insert_with_heap(heap, item)\n    heapify(heap)\n\ndef main():\n    heap = [6,2,7,3,1,5,4]\n    delete_and_insert(heap, 2)\n    print heap\n    delete_and_insert(heap, 3)\n    print heap\n    delete_and_insert(heap, 7)\n    print heap\n    delete_and_insert(heap, 1)\n    print heap\n    delete_and_insert(heap, 5)\n    print heap\n    delete_and_insert(heap, 4)\n    print heap\n    delete_and_insert(heap, 6)\n    print heap\n    delete_and_insert(heap, 1)\n    print heap\n    delete_and_insert(heap, 5)\n    print heap\n    delete_and_insert(heap, 4",
      -6.2265625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        O(n) time\n        \"\"\"\n        if not root:\n            return None\n        while root.left:\n            root = root.left\n        root.left = None\n        root.right = root.right.left\n        return root\n\nclass Solution2:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        O(n) time\n        \"\"\"\n        if not root:\n            return None\n        while root.right:\n            root = root.right\n        root.right = root.right.left\n        root.left = root.left.right\n        return root\n\nclass Solution3:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        O(n) time\n        \"\"\"\n        if not root:\n            return None\n        while root.left:\n            root = root.left\n        root.left = root.right\n        root.right = root.right.left\n        return root\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution4:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        O(n) time\n        \"\"\"\n        if not root:\n            return None\n        while root.left:\n            root = root.left\n        root.left = root.right\n        root.right = root.right.left\n        return root",
      -6.25
    ],
    [
      "from heapq import heappush, heappop, heapify\nfrom collections import deque\n\n\ndef delete_min(heap):\n    \"\"\"\n    :type heap: deque\n    :rtype: int\n    \"\"\"\n    heap.popleft()\n    heapify(heap)\n    return heap.popleft()\n\n\ndef insert(heap, value):\n    \"\"\"\n    :type heap: deque\n    :type value: int\n    \"\"\"\n    heappush(heap, value)\n    heapify(heap)\n\n\ndef delete_smallest(heap):\n    \"\"\"\n    :type heap: deque\n    :rtype: int\n    \"\"\"\n    return delete_min(heap)\n\n\ndef main():\n    heap = deque()\n    heap.appendleft(5)\n    heap.appendleft(3)\n    heap.appendleft(1)\n    heap.appendleft(2)\n    heap.appendleft(4)\n    heap.appendleft(6)\n\n    insert(heap, 2)\n    insert(heap, 3)\n    insert(heap, 5)\n    insert(heap, 1)\n    insert(heap, 7)\n    insert(heap, 9)\n    insert(heap, 6)\n    insert(heap, 8)\n    insert(heap, 10)\n    insert(heap, 11)\n    insert(heap, 12)\n\n    print(heap)\n\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n    # print(heap.popleft())\n\n    # print(heap.pop())\n    # print(heap.pop())\n    # print(heap.pop())\n    # print(heap.pop())",
      -6.28515625
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.data = []\n\n    def empty(self):\n        return len(self.data) == 0\n\n    def isEmpty(self):\n        return self.empty()\n\n    def insert(self, val):\n        self.data.append(val)\n        self.sink(len(self.data) - 1)\n\n    def extractMin(self):\n        if self.empty():\n            return None\n        return self.data.pop(0)\n\n    def sink(self, i):\n        while i > 0:\n            parent = (i - 1) // 2\n            if parent >= 0 and self.data[parent] > self.data[i]:\n                self.data[parent], self.data[i] = self.data[i], self.data[parent]\n                i = parent\n            else:\n                break\n\n    def deleteMin(self):\n        if self.empty():\n            return None\n        self.data.pop(0)\n        self.sink(0)\n        return self.extractMin()\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n\n    heap.insert(6)\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(6)\n\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n    heap.insert(5)\n\n    heap",
      -6.73046875
    ],
    [
      "class Heap:\n\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n        self.heap = [0]*self.size\n        self.min_index = 0\n\n    def get_min(self):\n        return self.arr[self.min_index]\n\n    def get_min_index(self):\n        return self.min_index\n\n    def insert(self, val):\n        self.heap[self.size] = val\n        self.size += 1\n        self.heapify(self.size)\n\n    def heapify(self, index):\n        if index < self.size:\n            self.heap[index] = self.get_min()\n            self.min_index = index\n            l = 2 * index + 1\n            r = 2 * index + 2\n            if l < self.size and self.heap[l] < self.heap[index]:\n                self.heap[index] = self.heap[l]\n                self.min_index = l\n            if r < self.size and self.heap[r] < self.heap[index]:\n                self.heap[index] = self.heap[r]\n                self.min_index = r\n\n    def delete_min(self):\n        self.heap[self.min_index] = self.heap[0]\n        self.heap[0] = self.heap[self.size-1]\n        self.heap[self.size-1] = 0\n        self.size -= 1\n        self.heapify(0)",
      -6.8046875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a tree node\n    def deleteMin(self, root):\n        if root is None:\n            return None\n        if root.left is None:\n            root.val = root.right.val\n            return root.right\n        if root.right is None:\n            root.val = root.left.val\n            return root.left\n\n        root.left = self.deleteMin(root.left)\n        root.val = root.right.val\n        root.right = self.deleteMin(root.right)\n        return root\n\nif __name__ == '__main__':\n    s = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.right.left = TreeNode(7)\n    root.right.right.right = TreeNode(8)\n    root.right.right.right.left = TreeNode(9)\n    root.right.right.right.right = TreeNode(10)\n    root.right.right.right.right.left = TreeNode(11)\n    root.right.right.right.right.right = TreeNode(12)\n    root.right.right.right.right.right.left = TreeNode(13)\n    root.right.right.right.right.right.right = TreeNode(14)\n    root.right.right.right.right.right.right.left = TreeNode(15)\n    print(s.deleteMin(root))",
      -6.96875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        if not root.left:\n            root.left = None\n            return\n        root.left = self.deleteMin(root.left)\n        if not root.left:\n            return root.right = None\n        root.left = self.deleteMin(root.left)\n        return\n\n    def insert(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insert(root.left, val)\n            return root\n        root.right = self.insert(root.right, val)\n        return root",
      -7.0078125
    ],
    [
      "def delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    \n    # find smallest element\n    while len(heap) > 1:\n        if heap[0] > heap[1]:\n            heap[0], heap[1] = heap[1], heap[0]\n        else:\n            break\n\n    # remove smallest element\n    heap.pop(0)\n\n    # insert a new element\n    heap.append(heap[0])\n    heap[0] = heap[0]\n\ndef insert(heap, value):\n    \"\"\"\n    :type heap: List[int]\n    :type value: int\n    :rtype: void\n    \"\"\"\n    \n    # find smallest element\n    while len(heap) > 1:\n        if heap[0] > heap[1]:\n            heap[0], heap[1] = heap[1], heap[0]\n        else:\n            break\n\n    # remove smallest element\n    heap.pop(0)\n\n    # insert a new element\n    heap.append(value)\n    heap[0] = value\n\nif __name__ == '__main__':\n    heap = [3,2,4,1]\n    delete_smallest(heap)\n    print(heap)\n    insert(heap, 5)\n    print(heap)",
      -7.25
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if root is None:\n            return\n        \n        while root.left is not None:\n            root = root.left\n        \n        root.left = root.right\n        root.right = None\n        \n        if root.left is not None:\n            self.deleteMin(root.left)\n    \n    def insert(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if root is None:\n            root = TreeNode(val)\n            return root\n        \n        if root.val > val:\n            root.right = self.insert(root.right, val)\n        elif root.val < val:\n            root.left = self.insert(root.left, val)\n        else:\n            return root\n        \n        return root\n\nif __name__ == '__main__':\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.right = TreeNode(15)\n    root.right.right.left = TreeNode(7)\n    root.right.right.right = TreeNode(8)\n    root.right.right.right.left = TreeNode(11)\n    \n    root = Solution().insert(root, 5)\n    print root.val\n    root = Solution().deleteMin(root)\n    print root.val",
      -7.26953125
    ],
    [
      "# Definition for a heap node.\n# class HeapNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#\n\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def deleteMin(self, root):\n        # write your code here\n        if root is None:\n            return\n        if root.left is None:\n            root.left = None\n        else:\n            self.deleteMin(root.left)\n        root.left = None\n        root.val = root.val * -1\n        self.deleteMin(root.right)\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    node = HeapNode(1, None, None)\n    assert node.val == 1\n    node.left = HeapNode(2, None, None)\n    assert node.left.val == 2\n    node.right = HeapNode(3, None, None)\n    assert node.right.val == 3\n    assert Solution().deleteMin(node) == node.val\n    assert node.val == 3\n    node.right.left = HeapNode(4, None, None)\n    assert node.right.left.val == 4\n    assert Solution().deleteMin(node) == node.val\n    assert node.val == 4\n    node.right.right = HeapNode(5, None, None)\n    assert node.right.right.val == 5\n    assert Solution().deleteMin(node) == node.val\n    assert node.val == 5\n    node.left = HeapNode(6, None, None)\n    assert node.left.val == 6\n    assert Solution().deleteMin(node) == 6",
      -7.30078125
    ],
    [
      "from collections import deque\n\ndef delete_smallest(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    heap.pop()\n\ndef insert(heap, element):\n    \"\"\"\n    :type heap: List[int]\n    :type element: int\n    :rtype: void\n    \"\"\"\n    heap.append(element)\n\ndef build_heap(heap):\n    \"\"\"\n    :type heap: List[int]\n    :rtype: void\n    \"\"\"\n    while len(heap) > 1:\n        heap_left = deque()\n        heap_right = deque()\n        heap_left.append(heap[0])\n        heap_right.append(heap[-1])\n        heap[0] = heap[-1]\n        heap[-1] = heap_right.popleft()\n        heap[-1] = heap[-1]\n        heap[-1] = heap_left.popleft()\n        heap[-1] = heap[-1]\n        heap_left = deque()\n        heap_right = deque()\n        heap_left.append(heap[0])\n        heap_right.append(heap[-1])\n        heap[0] = heap[-1]\n        heap[-1] = heap_right.popleft()\n        heap[-1] = heap[-1]\n        heap[-1] = heap_left.popleft()\n        heap[-1] = heap[-1]\n\nif __name__ == '__main__':\n    heap = [1,2,3,4,5,6]\n    heap = [1,2,3,4,5,6]\n    heap = [1,2,3,4,5,6]\n    heap = [1,2,3,4,5,6]\n    heap = [1,2,3,4,5,6]\n    heap = [1,2,3,4,5,6]\n    he",
      -7.34765625
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> None:\n        \"\"\"\n        do not use min heap\n        \"\"\"\n        if not root:\n            return\n        if root.left:\n            root.left.right = root.right\n        if root.right:\n            root.right.left = root.left\n        self.deleteMin(root.left)\n        root.val = root.right.val\n        root.right = root.right.right\n        self.deleteMin(root.right)\n\n    def insert(self, root: TreeNode, val: int) -> None:\n        \"\"\"\n        use min heap\n        \"\"\"\n        if not root:\n            root = TreeNode(val)\n            return\n        if root.val < val:\n            root.left = self.insert(root.left, val)\n            return\n        root.right = self.insert(root.right, val)\n        if root.val > val:\n            if root.left and root.left.val < val:\n                root.left = self.insert(root.left, val)\n            if root.right and root.right.val < val:\n                root.right = self.insert(root.right, val)\n        else:\n            if root.right and root.right.val < val:\n                root.right = self.insert(root.right, val)\n            if root.left and root.left.val < val:\n                root.left = self.insert(root.left, val)\n        return root\n\n    def createMinHeap(self, root: TreeNode) -> None:\n        \"\"\"\n        do not use min heap\n        \"\"\"\n        if not root:\n            return\n        self.createMinHeap(root.left)\n        self.createMinHeap(root.right)\n        root.val = root.right.val\n        root.right = root.right.right\n        self.createMinHeap(root.right)\n        return root",
      -7.44921875
    ],
    [
      "class Heap:\n    def __init__(self, max_size):\n        self.heap = []\n        self.max_size = max_size\n\n    def push(self, item):\n        self.heap.append(item)\n        self.heapify()\n\n    def pop(self):\n        if len(self.heap) == 0:\n            return None\n        else:\n            return self.heap.pop()\n\n    def peek(self):\n        return self.heap[0]\n\n    def getSize(self):\n        return len(self.heap)\n\n    def isEmpty(self):\n        return self.heap == []\n\n    def heapify(self):\n        for i in range(self.max_size, 0, -1):\n            min_index = i - 1\n            if self.heap[min_index] < self.heap[i]:\n                self.heap[min_index], self.heap[i] = self.heap[i], self.heap[min_index]\n                \n    def heap_sort(self):\n        while not self.isEmpty():\n            self.heapify()\n            while not self.isEmpty():\n                print(self.heap.pop())\n\n    def deleteMin(self):\n        if self.isEmpty():\n            return None\n        else:\n            temp = self.heap[0]\n            self.heap[0] = self.heap.pop()\n            self.heapify()\n            return temp\n\nif __name__ == \"__main__\":\n    h = Heap(3)\n    h.push(5)\n    h.push(3)\n    h.push(2)\n    h.push(1)\n    h.heap_sort()\n    print(h.pop())\n    print(h.pop())\n    print(h.pop())\n    print(h.pop())\n    print(h.pop())\n    h.deleteMin()\n    h.heap_sort()\n    print(h.pop())\n    print(h.pop())\n    print(h.pop())\n    print(h.pop())\n    print(h",
      -7.67578125
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def build_heap(self, arr):\n        for i in range(len(arr)):\n            self.heap.append(arr[i])\n        return self.heap\n\n    def print_heap(self):\n        for i in range(len(self.heap)):\n            print(self.heap[i])\n\n    def heap_size(self):\n        return len(self.heap)\n\n    def delete_smallest(self):\n        \"\"\"\n        This function will delete the smallest element from the heap and then insert the new element.\n        \"\"\"\n        if self.heap_size() == 0:\n            return\n\n        new_heap = self.build_heap(self.heap[:self.heap_size()-1])\n        self.heap[0] = self.heap[self.heap_size()-1]\n        self.heap[0] = self.heap[0]\n\n        return new_heap\n\n    def insert(self, arr):\n        \"\"\"\n        This function will insert a new element in the heap\n        \"\"\"\n        if self.heap_size() == 0:\n            self.heap = [arr]\n        else:\n            new_heap = self.delete_smallest()\n            self.heap = new_heap + [arr]\n\n    def is_heap(self):\n        \"\"\"\n        This function will check the heap property\n        \"\"\"\n        if self.heap_size() == 0:\n            return True\n        else:\n            return self.heap[0] <= self.heap[1] and self.heap[1] <= self.heap[2] and self.heap[2] <= self.heap[3] and self.heap[3] <= self.heap[4] and self.heap[4] <= self.heap[0]\n\n\n# Test cases\narr = [5, 6, 7, 8, 9, 10]\nheap = Heap()\nheap.insert(arr)\nheap.print_heap()\nprint(\"",
      -7.99609375
    ],
    [
      "import collections\nimport heapq\n\nclass Heap:\n    def __init__(self):\n        self.heap = collections.deque()\n        \n    def push(self, val):\n        self.heap.append(val)\n        heapq.heapify(self.heap)\n        \n    def pop(self):\n        if self.heap:\n            return heapq.heappop(self.heap)\n        return None\n        \n    def peek(self):\n        if self.heap:\n            return self.heap[0]\n        return None\n        \n    def empty(self):\n        return len(self.heap) == 0\n        \n    def size(self):\n        return len(self.heap)\n        \n    def is_empty(self):\n        return self.empty()\n        \n    def delete_min(self):\n        if self.empty():\n            return None\n        return self.pop()\n        \n    def insert(self, val):\n        self.push(val)\n        \nclass Heap_Min_Delete_Node:\n    def __init__(self, node):\n        self.node = node\n        \n    def __lt__(self, other):\n        return self.node.val < other.node.val\n    \nclass Heap_Min_Delete:\n    def __init__(self):\n        self.heap = None\n        \n    def push(self, val):\n        if self.heap is None:\n            self.heap = Heap()\n            self.heap.push(Heap_Min_Delete_Node(val))\n        else:\n            self.heap.push(Heap_Min_Delete_Node(val))\n            self.heap.push(Heap_Min_Delete_Node(self.heap.pop()))\n        \n    def pop(self):\n        if self.heap is None:\n            return None\n        else:\n            return self.heap.pop()\n        \n    def peek(self):\n        if self.heap is None:\n            return None\n        else:\n            return self.heap.peek()\n        \n    def empty",
      -8.234375
    ],
    [
      "class Heap:\n    def __init__(self, heap_size):\n        self.heap = [0] * heap_size\n        self.size = 0\n\n    def is_empty(self):\n        return self.size == 0\n\n    def insert(self, val):\n        self.heap[self.size] = val\n        self.size += 1\n\n    def delete_min(self):\n        self.size -= 1\n        return self.heap[0]\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(self.heap[i])\n\nclass HeapTest():\n    def __init__(self):\n        self.heap = Heap(10)\n\n    def test_heap(self):\n        self.heap.insert(5)\n        self.heap.insert(3)\n        self.heap.insert(4)\n        self.heap.insert(2)\n        self.heap.insert(1)\n        self.heap.insert(6)\n        self.heap.insert(7)\n        self.heap.insert(8)\n        self.heap.insert(9)\n        self.heap.print_heap()\n        self.heap.delete_min()\n        self.heap.print_heap()\n\ntest = HeapTest()\ntest.test_heap()",
      -8.3203125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        if not root.left and not root.right:\n            return\n        if not root.left:\n            root.left = root.right\n        elif not root.right:\n            root.right = root.left\n            root.left = None\n        else:\n            minnode = root.left\n            while minnode.right:\n                minnode = minnode.right\n            minnode.right = root.right\n            root.right = root.left\n            root.left = root.right\n            root.right = None\n            root.val = minnode.val\n\n    def insert(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            root = TreeNode(val)\n            return root\n        if root.val > val:\n            root.left = self.insert(root.left, val)\n            return root\n        root.right = self.insert(root.right, val)\n        return root",
      -8.6328125
    ],
    [
      "# Heap\nclass Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n\n    def extract_min(self):\n        if len(self.heap) == 0:\n            return None\n        else:\n            ret = self.heap[0]\n            self.heap[0] = self.heap.pop()\n            return ret\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n        else:\n            ret = self.heap[0]\n            self.heap[0] = self.heap.pop()\n            return ret\n\n\n# Your Heap object will be instantiated and called as such:\nheap = Heap()\nheap.insert(1)\nheap.insert(3)\nheap.insert(2)\nheap.insert(4)\nheap.insert(5)\n\nprint heap.extract_min()\nprint heap.extract_min()\nprint heap.extract_min()\nprint heap.extract_min()\nprint heap.extract_min()\nprint heap.extract_min()",
      -8.859375
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, element):\n        self.heap.append(element)\n        self.up_heap()\n\n    def delete_smallest(self):\n        element = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        self.down_heap()\n        return element\n\n    def up_heap(self):\n        parent = (self.heap[0]) / 2\n        while parent >= 0:\n            if self.heap[parent] > self.heap[0]:\n                break\n            else:\n                self.heap[parent], self.heap[0] = self.heap[0], self.heap[parent]\n                parent = (self.heap[0]) / 2\n        return\n\n    def down_heap(self):\n        left_child = 2 * self.heap[0] + 1\n        right_child = 2 * self.heap[0] + 2\n        child = left_child\n        while child < len(self.heap):\n            if left_child < len(self.heap):\n                if self.heap[left_child] < self.heap[child]:\n                    child = left_child\n                else:\n                    self.heap[child], self.heap[left_child] = self.heap[left_child], self.heap[child]\n                    left_child += 1\n            if right_child < len(self.heap):\n                if self.heap[right_child] < self.heap[child]:\n                    child = right_child\n                else:\n                    self.heap[child], self.heap[right_child] = self.heap[right_child], self.heap[child]\n                    right_child += 1\n            if child >= len(self.heap):\n                break\n            self.heap[child], self.heap[child] = self.heap[child], self.heap[0]\n            child += 1\n            self.heap",
      -8.890625
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n\n    def deleteMin(self):\n        self.heap.pop()\n\n    def delete(self, index):\n        self.heap[index] = self.heap.pop()\n\n    def getMin(self):\n        return self.heap[0]\n\n    def isEmpty(self):\n        return self.heap == []\n\n\"\"\"\nInput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nOutput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[4, 5, 6, 7, 8, 9, 10]\n[8, 9, 10]\n[9, 10]\n[10]\n\"\"\"\n\ndef heapSort(array):\n    if len(array) == 0:\n        return array\n\n    heap = Heap()\n    for value in array:\n        heap.insert(value)\n\n    for i in range(len(array) - 1, 0, -1):\n        heap.deleteMin()\n\n    return heap.heap\n\n\n\"\"\"\nInput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nOutput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[4, 5, 6, 7, 8, 9, 10]\n[8, 9, 10]\n[9, 10]\n[10]\n\"\"\"\n\ndef heapSort(array):\n    if len(array) == 0:\n        return array\n\n    heap = Heap()\n    for value in array:\n        heap.insert(value)\n\n    for i in range(len(array) - 1, 0, -1):\n        heap.deleteMin()\n\n    return heap.heap\n\n\n\"\"\"\nInput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nOutput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
      -9.1328125
    ],
    [
      "import heapq\n\n\nclass Heap:\n    def __init__(self, heap):\n        self.heap = heap\n\n    def delete_min(self):\n        return self.heap.pop()\n\n    def insert(self, item):\n        heapq.heappush(self.heap, item)\n\n\nclass HeapList:\n    def __init__(self, heap):\n        self.heap = heap\n\n    def delete_min(self):\n        return self.heap.pop()\n\n    def insert(self, item):\n        self.heap.insert(item)\n\n\nclass HeapListTest(unittest.TestCase):\n    def test_heap_list(self):\n        heap = HeapList([5, 7, 3, 9, 2, 1])\n        heap.insert(10)\n        heap.insert(5)\n        heap.insert(6)\n        heap.insert(4)\n        heap.insert(8)\n        heap.insert(13)\n        heap.insert(14)\n\n        self.assertEqual(heap.delete_min(), 5)\n        self.assertEqual(heap.delete_min(), 7)\n        self.assertEqual(heap.delete_min(), 3)\n        self.assertEqual(heap.delete_min(), 9)\n        self.assertEqual(heap.delete_min(), 2)\n        self.assertEqual(heap.delete_min(), 1)\n        self.assertEqual(heap.delete_min(), 10)\n        self.assertEqual(heap.delete_min(), 5)\n        self.assertEqual(heap.delete_min(), 6)\n        self.assertEqual(heap.delete_min(), 4)\n        self.assertEqual(heap.delete_min(), 8)\n        self.assertEqual(heap.delete_min(), 13)\n        self.assertEqual(heap.delete_min(), 14)\n\n    def test_heap(self):\n        heap = Heap([5, 7, 3, 9, 2, 1])\n        heap.insert(10)",
      -11.3984375
    ],
    [
      "class Heap:\n\tdef __init__(self, arr):\n\t\tself.arr = arr\n\t\tself.length = len(arr)\n\t\tself.heapify(0)\n\t\n\tdef heapify(self, index):\n\t\twhile index < self.length:\n\t\t\tparent = index >> 1\n\t\t\tif self.arr[index] < self.arr[parent]:\n\t\t\t\tbreak\n\t\t\telif self.arr[index] > self.arr[parent]:\n\t\t\t\tself.arr[index], self.arr[parent] = self.arr[parent], self.arr[index]\n\t\t\t\tindex = parent\n\t\t\telse:\n\t\t\t\tbreak\n\t\n\tdef delete_min(self):\n\t\tself.arr[0], self.arr[0] = self.arr[0], self.arr[self.length - 1]\n\t\tself.heapify(0)\n\t\treturn self.arr[0]\n\t\n\tdef insert(self, val):\n\t\tself.arr.append(val)\n\t\tself.heapify(self.length)\n\t\n\tdef get_min(self):\n\t\treturn self.arr[0]\n\t\n\tdef get_max(self):\n\t\treturn self.arr[self.length - 1]\n\t\n\tdef is_empty(self):\n\t\treturn self.length == 0\n\t\n\tdef size(self):\n\t\treturn self.length\n\t\n\tdef get_arr(self):\n\t\treturn self.arr\n\t\n\tdef __str__(self):\n\t\treturn '\\n'.join([str(i) for i in self.arr])\n\t\n\tdef __repr__(self):\n\t\treturn 'Heap(%s)' % self.arr\n\t\n\tdef __eq__(self, other):\n\t\treturn self.arr == other.arr\n\t\n\tdef __hash__(self):\n\t\treturn hash(self.arr)\n\nif __name__ == '__main__':\n\tarr = [1, 2, 3, 4, 5]\n\theap = Heap(arr)\n\theap.insert(6)\n\theap.insert(7)\n\theap.insert(8)\n\theap.insert(9)\n\theap",
      -11.46875
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, data):\n        self.heap.append(data)\n        self.up_heap(len(self.heap) - 1)\n\n    def up_heap(self, index):\n        while index > 0 and self.heap[index] < self.heap[index / 2]:\n            temp = self.heap[index]\n            self.heap[index] = self.heap[index / 2]\n            self.heap[index / 2] = temp\n            index = index / 2\n        return index\n\n    def delete_min(self):\n        self.heap.pop()\n        self.down_heap(0)\n\n    def down_heap(self, index):\n        while index * 2 + 1 < len(self.heap):\n            if index * 2 + 2 < len(self.heap) and self.heap[index] < self.heap[index * 2 + 2]:\n                temp = self.heap[index]\n                self.heap[index] = self.heap[index * 2 + 2]\n                self.heap[index * 2 + 2] = temp\n            else:\n                break\n            index = index * 2 + 1\n        return index\n\n    def __len__(self):\n        return len(self.heap)\n\n    def __str__(self):\n        return str(self.heap)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    heap.insert(10)\n    heap.insert(11)\n    heap.insert(12)\n    heap.insert(13)\n    heap.insert(14)\n    heap.insert(15)\n    heap.insert(16)",
      -12.046875
    ],
    [
      "class Heap(object):\n    def __init__(self):\n        self.items = []\n\n    def insert(self, item):\n        self.items.append(item)\n        self._sift_up()\n\n    def _sift_up(self):\n        while self.items and self.items[0] < self.items[-1]:\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n\n    def deleteMin(self):\n        if self.items:\n            return self.items.pop(0)\n        else:\n            return None\n\n    def insert(self, item):\n        self.items.append(item)\n        self._sift_up()\n\n    def _sift_down(self):\n        while self.items and self.items[0] > self.items[-1]:\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n            self.items[0], self.items[-1] = self.items[-1], self.items[0]\n\nclass Solution(object):\n    def deleteMin(self, heap):\n        \"\"\"\n        :type heap: Heap\n        :rtype: void Do not return anything, modify heap in-place instead.\n        \"\"\"\n        if not heap.items:\n            return\n        heap.items.pop(0)\n        heap._sift_down()\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6",
      -12.4375
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def push(self, item):\n        self.heap.append(item)\n        self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        return self.heap.pop()\n\n    def get_min(self):\n        return self.heap[0]\n\n    def get_size(self):\n        return self.size\n\n    def get_heap(self):\n        return self.heap\n\nclass Heap_Test(unittest.TestCase):\n\n    def test_push(self):\n        h = Heap()\n        h.push(5)\n        h.push(3)\n        h.push(4)\n        h.push(1)\n        h.push(6)\n        h.push(2)\n        self.assertEqual(h.get_size(), 5)\n        self.assertEqual(h.get_min(), 1)\n        self.assertEqual(h.get_heap(), [1, 2, 3, 4, 5, 6])\n\n    def test_pop(self):\n        h = Heap()\n        h.push(5)\n        h.push(3)\n        h.push(4)\n        h.push(1)\n        h.push(6)\n        h.push(2)\n        self.assertEqual(h.get_size(), 5)\n        self.assertEqual(h.get_min(), 1)\n        self.assertEqual(h.get_heap(), [1, 2, 3, 4, 5, 6])\n        self.assertEqual(h.pop(), 1)\n        self.assertEqual(h.get_size(), 4)\n        self.assertEqual(h.get_heap(), [2, 3, 4, 5])\n\n    def test_delete_min(self):\n        h = Heap()\n        h.push(5)\n        h.push(3)\n        h.push(4)\n        h.push(1)\n        h.push(6)",
      -12.8125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root is None:\n            return None\n        else:\n            node = root\n            while node.left:\n                node = node.left\n            node.left = node.right\n            if node.right:\n                node.right = node.right.left\n            return node.val\n\n    def insert(self, root, val):\n        if root is None:\n            return TreeNode(val)\n        else:\n            node = root\n            while node.left or node.right:\n                if node.left is None:\n                    node.left = TreeNode(val)\n                    break\n                elif node.right is None:\n                    node.right = TreeNode(val)\n                    break\n                else:\n                    node = node.right\n            return node\n\nclass Solution2:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root is None:\n            return None\n        else:\n            node = root\n            while node.left:\n                node = node.left\n            node.left = node.right\n            if node.right:\n                node.right = node.right.left\n            return node.val\n\n    def insert(self, root, val):\n        if root is None:\n            return TreeNode(val)\n        else:\n            node = root\n            while node.left or node.right:\n                if node.left is None:\n                    node.left = TreeNode(val)\n                    break\n                elif node.right is None:\n                    node.right = TreeNode(val)\n                    break\n                else:\n                    node = node.right\n            return node\n\nclass Solution3:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if",
      -13.21875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        # get the smallest child\n        smallest = self.getSmallestChild(root)\n\n        # remove the smallest child\n        self.deleteNode(root, smallest)\n\n        # insert the new node\n        self.insertNode(root, smallest.val)\n\n    def getSmallestChild(self, root):\n        if not root:\n            return None\n\n        if not root.left:\n            return root.right\n\n        if not root.right:\n            return root.left\n\n        smallest = root.left if root.left.val < root.right.val else root.right\n\n        # recursively find the smallest child\n        return self.getSmallestChild(smallest)\n\n    def deleteNode(self, root, node):\n        if not root:\n            return\n\n        if node == root.left:\n            root.left = None\n        elif node == root.right:\n            root.right = None\n        else:\n            if not root.left:\n                root.left = node.left\n            else:\n                root.right = node.left\n\n            if not root.left:\n                root.left = node.right\n            else:\n                root.right = node.right\n\n    def insertNode(self, root, val):\n        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insertNode(root.left, val)\n        elif val > root.val:\n            root.right = self.insertNode(root.right, val)\n        else:\n            return root\n\n    def printTree(self, root):\n        if not root:\n            return\n        self.printTree(root.left)\n        print(root.val)\n        self.printTree(root.right",
      -13.7734375
    ],
    [
      "class Solution:\n    # @param head, a list node\n    # @return a list node\n    def deleteMin(self, head):\n        if head is None or head.next is None:\n            return None\n        \n        node = head\n        while node.next is not None:\n            if node.next.next is not None:\n                node = node.next\n                while node.next.next is not None:\n                    node = node.next\n                    if node.next is None:\n                        return None\n                    node = node.next\n                node.next = node.next.next\n                break\n        \n        node.next = node.next.next\n        return node.next\n    \n    def insert(self, head, data):\n        node = Node(data)\n        node.next = head\n        return node\n    \n    def print_list(self, head):\n        while head is not None:\n            print(head.data)\n            head = head.next\n    \n    def delete_min(self, head):\n        if head is None or head.next is None:\n            return head\n        node = head\n        while node.next is not None:\n            if node.next.next is None:\n                return node.next\n            node = node.next\n        return node.next\n    \n    def delete_min_2(self, head):\n        if head is None or head.next is None:\n            return head\n        node = head\n        while node.next is not None:\n            if node.next.next is None:\n                return node.next\n            node = node.next\n        return node.next\n    \n    def delete_min_3(self, head):\n        if head is None or head.next is None:\n            return head\n        node = head\n        while node.next is not None:\n            if node.next.next is None:\n                return node.next\n            node = node.next\n        return node.next\n    \n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next = None\n    \n    def test(self):\n        print(\"Test delete_min:\")\n        head = self.insert",
      -14.0859375
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n\n    def deleteMin(self):\n        min = self.arr[0]\n        self.arr[0] = self.arr[self.size - 1]\n        self.size -= 1\n        self.arr = self.arr[1:]\n        return min\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.size += 1\n        self.arr = self.arr[1:]\n\n\n\nclass HeapTest:\n    def test(self):\n        arr = [2, 5, 3, 6, 4, 7]\n        heap = Heap(arr)\n        heap.insert(2)\n        heap.insert(5)\n        heap.insert(4)\n        heap.insert(6)\n        heap.insert(3)\n        heap.insert(7)\n        assert heap.deleteMin() == 7\n        assert heap.deleteMin() == 6\n        assert heap.deleteMin() == 5\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 4\n        assert heap.deleteMin() == 3\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.deleteMin() == 2\n        assert heap.",
      -14.296875
    ],
    [
      "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def deleteMin(self):\n        \"\"\"\n        :type heap: List[int]\n        :rtype: void\n        \"\"\"\n        if len(self.heap) == 0:\n            return\n\n        heap = self.heap\n        heap[0] = heap[-1]\n        heap[-1] = heap[-2]\n        heap[-2] = heap[-3]\n        heap[-3] = heap[-4]\n        heap[-4] = heap[-5]\n        heap[-5] = heap[-6]\n        heap[-6] = heap[-7]\n        heap[-7] = heap[-8]\n        heap[-8] = heap[-9]\n        heap[-9] = heap[-10]\n        heap[-10] = heap[-11]\n        heap[-11] = heap[-12]\n        heap[-12] = heap[-13]\n        heap[-13] = heap[-14]\n        heap[-14] = heap[-15]\n        heap[-15] = heap[-16]\n        heap[-16] = heap[-17]\n        heap[-17] = heap[-18]\n        heap[-18] = heap[-19]\n        heap[-19] = heap[-20]\n        heap[-20] = heap[-21]\n        heap[-21] = heap[-22]\n        heap[-22] = heap[-23]\n        heap[-23] = heap[-24]\n        heap[-24] = heap[-25]\n        heap[-25] = heap[-26]\n        heap[-26] = heap[-27]\n        heap[-27] = heap[-28]\n        heap[-28] = heap[-29]\n        heap[-29] = heap[-30]\n        heap[-30] = heap[-31]",
      -14.375
    ],
    [
      "class Heap:\n    \"\"\" Heap data structure. \"\"\"\n    def __init__(self, arr):\n        \"\"\" Create an empty heap. \"\"\"\n        self.arr = arr\n        self.size = 0\n\n    def is_empty(self):\n        \"\"\" Returns true if the heap is empty. \"\"\"\n        return self.size == 0\n\n    def is_full(self):\n        \"\"\" Returns true if the heap is full. \"\"\"\n        return self.size == len(self.arr)\n\n    def insert(self, item):\n        \"\"\" Insert an element into the heap. \"\"\"\n        if self.is_full():\n            self.heapify(self.size)\n        self.size += 1\n        self.arr[self.size-1] = item\n        self.heapify(self.size)\n\n    def remove(self):\n        \"\"\" Remove the smallest element from the heap and return it. \"\"\"\n        if self.is_empty():\n            return None\n        elif self.size == 1:\n            self.heapify(1)\n            return self.arr[1]\n        else:\n            self.arr[1], self.arr[self.size-1] = self.arr[self.size-1], self.arr[1]\n            self.heapify(1)\n            return self.arr[1]\n\n    def heapify(self, i):\n        \"\"\" Heapify. \"\"\"\n        while i >= 1 and self.arr[i] < self.arr[i/2]:\n            self.arr[i], self.arr[i/2] = self.arr[i/2], self.arr[i]\n            i = i/2\n\ndef delete_and_insert(arr, size, item):\n    \"\"\" Delete the smallest element from the heap and then insert a new item. \"\"\"\n    heap = Heap(arr)\n    heap.remove()\n    heap.insert(item)\n\ndef test_delete_and_insert():\n    \"\"\" Test the delete and insert functions. \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    delete_and_insert(arr, len(arr), 6)\n    assert arr == [1, 2, 3, 4, 5",
      -14.3984375
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def is_heap(self):\n        heap_size = len(self.arr)\n        for i in range(heap_size / 2, -1, -1):\n            if self.arr[i] < self.arr[0]:\n                break\n            tmp = self.arr[i]\n            self.arr[i] = self.arr[0]\n            self.arr[0] = tmp\n            i -= 1\n\n    def build_heap(self):\n        i = len(self.arr) / 2\n        while i > 0:\n            self.arr[i] = self.arr[0]\n            i -= 1\n            self.arr[0] = self.arr[i]\n            i = (i - 1) / 2\n\n    def delete_min(self):\n        i = 0\n        min = self.arr[0]\n        while i < len(self.arr):\n            if self.arr[i] < min:\n                min = self.arr[i]\n                j = i\n            i += 1\n        self.arr[j] = self.arr[0]\n        self.arr[0] = min\n        self.heapify(0)\n\n    def heapify(self, i):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < len(self.arr):\n            if self.arr[left] < self.arr[i]:\n                self.arr[i] = self.arr[left]\n                self.arr[left] = self.arr[i]\n                self.heapify(left)\n            else:\n                self.arr[i] = self.arr[left]\n                self.arr[left] = self.arr[i]\n                self.heapify(left)\n        if right < len(self.arr):\n            if self.arr[right] < self.arr[i]:\n                self.arr[i] = self.arr[right]\n                self.arr[right] = self.arr[i]\n                self.heapify(right)\n            else:",
      -14.875
    ],
    [
      "class Heap:\n    def __init__(self):\n        self.data = []\n\n    def delete_min(self):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        if len(self.data) == 0:\n            return\n        heap_element = self.data[0]\n        self.data[0] = self.data.pop()\n        self.data.insert(0, heap_element)\n        self.heapify(0)\n\n    def insert(self, element):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        self.data.append(element)\n        self.heapify(len(self.data) - 1)\n\n    def heapify(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: void\n        \"\"\"\n        while index * 2 <= len(self.data):\n            if index * 2 + 1 > len(self.data):\n                break\n            if self.data[index * 2].value < self.data[index * 2 + 1].value:\n                break\n            else:\n                self.data[index * 2], self.data[index * 2 + 1] = self.data[index * 2 + 1], self.data[index * 2]\n                index = index * 2 + 1\n        return\n\n\nif __name__ == '__main__':\n    h = Heap()\n    h.insert(5)\n    h.insert(10)\n    h.insert(15)\n    h.insert(7)\n    h.insert(3)\n    h.insert(2)\n    h.insert(1)\n    h.insert(6)\n    h.insert(9)\n    h.insert(11)\n    h.insert(13)\n    h.insert(14)\n    h.insert(16)\n    h.insert(18)\n    h.insert(19)\n    h.insert(17)\n    h.insert(20)\n    h.insert(22)\n    h.insert(24)\n    h.insert(25)\n    h.insert(21)\n    h.insert(23)\n    h.insert(26)\n    h.insert(",
      -14.9453125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if root is None:\n            return\n        \n        if root.left is None:\n            root.left = None\n        else:\n            self.deleteMin(root.left)\n            \n        if root.right is None:\n            root.right = None\n        else:\n            self.deleteMin(root.right)\n            \n        root.left = root.right = None\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    root = Solution().deleteMin(root)\n    print root.val\n    \n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    root = Solution().deleteMin(root)\n    print root.val\n    \n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    root = Solution().deleteMin(root)\n    print root.val",
      -15.1796875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n\n        # Find the smallest node.\n        min = self.findMin(root)\n        if not min:\n            return root\n\n        # Delete the smallest node.\n        root.left = self.deleteMin(root.left)\n        root.right = self.deleteMin(root.right)\n        return root\n\n    def findMin(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n\n        if not root.left:\n            return root\n\n        return self.findMin(root.left)\n\n\n# TESTS\nfor tree, expected in [\n    ([1, 3, 2, 5, 7, 4, 6], [1, 3, 2, 5, 7, 4, 6]),\n    ([1, 3, 2, 5, 7, 4, 6], [1, 3, 2, 5, 7, 4, 6]),\n    ([1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7]),\n    ([1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7]),\n]:\n    sol = Solution()\n    actual = sol.deleteMin(TreeNode.from_list(tree))\n    print(\"Delete min of\", tree, \"->\", actual)\n    assert expected == actual",
      -15.53125
    ],
    [
      "class Heap:\n\n    def __init__(self, size):\n        self.size = size\n        self.heap = [0 for i in range(size)]\n\n    def is_empty(self):\n        return self.heap[0] == 0\n\n    def insert(self, item):\n        self.heap[0] = item\n        self.heap[1:] = [x for x in reversed(self.heap[1:])] + [item]\n\n    def delete_min(self):\n        return self.heap.pop(0)\n\n    def delete_max(self):\n        return self.heap.pop()\n\n    def delete_node(self, node):\n        self.heap[node] = self.heap[0]\n        self.heap[0] = self.heap.pop(node)\n        self.heap[0] = self.heap[0]\n\n    def insert_node(self, node):\n        self.heap[node] = self.heap[0]\n        self.heap[0] = node\n        self.heap[node] = self.heap[node]\n\nclass Solution:\n    def deleteMin(self, heap):\n        \"\"\"\n        :type heap: Heap\n        :rtype: None\n        \"\"\"\n        if not heap.is_empty():\n            heap.delete_min()\n        else:\n            return\n        while not heap.is_empty():\n            heap.delete_node(0)\n\n    def insert(self, heap, item):\n        \"\"\"\n        :type heap: Heap\n        :type item: int\n        :rtype: None\n        \"\"\"\n        heap.insert_node(0)\n        while not heap.is_empty():\n            if heap.heap[0] < item:\n                heap.delete_node(0)\n            else:\n                break",
      -15.9296875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        if root.left:\n            self.deleteMin(root.left)\n        if root.right:\n            self.deleteMin(root.right)\n        root.val = root.left.val if root.left else root.right.val\n        root.left = None\n        root.right = None\n\nif __name__ == \"__main__\":\n    tree = TreeNode(1)\n    tree.left = TreeNode(2)\n    tree.right = TreeNode(3)\n    tree.left.left = TreeNode(4)\n    tree.left.right = TreeNode(5)\n    tree.left.left.left = TreeNode(6)\n    tree.left.right.left = TreeNode(7)\n    tree.left.right.right = TreeNode(8)\n    tree.left.right.right.left = TreeNode(9)\n    tree.left.right.right.right = TreeNode(10)\n    tree.right.left = TreeNode(11)\n    tree.right.right = TreeNode(12)\n    tree.right.left.left = TreeNode(13)\n    tree.right.right.left = TreeNode(14)\n    tree.right.right.right = TreeNode(15)\n    tree.right.right.right.left = TreeNode(16)\n    tree.right.right.right.right = TreeNode(17)\n    tree.right.right.right.right.left = TreeNode(18)\n    tree.right.right.right.right.right = TreeNode(19)\n    tree.right.right.right.right.right.left = TreeNode(20)\n    tree.right.right.right.right.right.right = TreeNode(21)",
      -16.078125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteMin(self, root: TreeNode) -> None:\n        \"\"\"\n        O(logn) time\n        O(1) space\n        \"\"\"\n        if root is None:\n            return\n        while root.left is not None:\n            root = root.left\n        root.left = root.right\n        root.right = None\n        root.val = root.left.val if root.left else None\n        self.deleteMin(root.left)\n\n    def insert(self, root, val):\n        if root is None:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insert(root.left, val)\n            return root\n        root.right = self.insert(root.right, val)\n        return root\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.left = TreeNode(7)\n    root.right.left.left = TreeNode(8)\n    root.right.left.right = TreeNode(9)\n    root.right.right.left = TreeNode(10)\n    root.right.right.right = TreeNode(11)\n    root.right.right.right.right = TreeNode(12)\n    root.right.right.right.right.right = TreeNode(13)\n    root.right.right.right.right.right.right = TreeNode(14)\n\n    sol.insert(root, 8)\n    sol.insert(root, 2)\n    sol.insert(root, 1)\n    sol.insert(root, 3)\n    sol.insert(root, 10)\n    sol.insert(root, 4)",
      -17.390625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, val: int) -> TreeNode:\n        \"\"\"\n        O(n)\n        \"\"\"\n        if not root:\n            return None\n\n        if root.val == val:\n            if root.left:\n                root.left = self.deleteNode(root.left, val)\n            else:\n                root.left = None\n            return root\n        elif root.val > val:\n            root.left = self.deleteNode(root.left, val)\n        elif root.val < val:\n            root.right = self.deleteNode(root.right, val)\n        else:\n            return root\n\n# TESTS\nfor n, root, expected in [\n    (3, [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n    (1, [1], [1]),\n    (3, [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n    (2, [1, 2], [1, 2]),\n    (3, [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n    (1, [], []),\n    (1, [1], [1]),\n    (1, [1, 2], [1, 2]),\n    (1, [1, 2, 3], [1, 2, 3]),\n    (2, [1, 2], [1, 2]),\n    (2, [1, 2, 3], [1, 2, 3]),\n    (2, [1, 2, 3, 4], [1, 2, 3, 4]),\n]:\n    sol = Solution()\n    actual = sol.deleteNode(TreeNode(n), n)\n    print",
      -19.046875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}