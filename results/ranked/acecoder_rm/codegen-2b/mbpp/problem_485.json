{
  "problem": {
    "task_id": "MBPP/496",
    "prompt": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.",
    "canonical_solution": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):\r\n  smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums",
    "test_list": [
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ",
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]",
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]"
    ],
    "challenge_test_list": [],
    "problem_id": 485
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "import heapq\n\ndef find_min(nums):\n    if not nums:\n        return 0\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n    return heap[0]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print find_min(nums)",
      2.677734375
    ],
    [
      "import heapq\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMin(self, nums):\n        if not nums: return 0\n        heapq.heapify(nums)\n        res = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < res:\n                res = nums[i]\n        return res\n\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMin1(self, nums):\n        if not nums: return 0\n        heapq.heapify(nums)\n        res = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < res:\n                res = nums[i]\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.findMin([]))\n    print(sol.findMin([3, 1, 2, 1]))\n    print(sol.findMin([1, 1, 2, 3]))\n    print(sol.findMin([1, 2, 3, 1]))\n    print(sol.findMin([2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2, 2, 2, 2, 2]))\n    print(sol.findMin([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]))",
      2.576171875
    ],
    [
      "import heapq\n\n\ndef find_min(array):\n    heap = []\n    for i in array:\n        heapq.heappush(heap, i)\n    return heap[0]\n\n\n# test\nassert find_min([1, 2, 3, 4, 5, 6, 7]) == 1\nassert find_min([1, 2, 3, 4, 5, 6, 7, 8]) == 1\nassert find_min([2, 3, 4, 5, 6, 7, 8, 9]) == 2\nassert find_min([3, 4, 5, 6, 7, 8, 9, 10]) == 3\nassert find_min([4, 5, 6, 7, 8, 9, 10, 11]) == 4\nassert find_min([5, 6, 7, 8, 9, 10, 11, 12]) == 5\nassert find_min([6, 7, 8, 9, 10, 11, 12, 13]) == 6\nassert find_min([7, 8, 9, 10, 11, 12, 13, 14]) == 7\nassert find_min([8, 9, 10, 11, 12, 13, 14, 15]) == 8\nassert find_min([9, 10, 11, 12, 13, 14, 15, 16]) == 9\nassert find_min([10, 11, 12, 13, 14, 15, 16, 17]) == 10\nassert find_min([11, 12, 13, 14, 15, 16, 17, 18]) == 11\nassert find_min([12, 13, 14, 15, 16, 17, 18, 19]) == 12\nassert find_min([13, 14, 15, 16, 17, 18, 19, 20]) == 13\nassert find_min([14, 15, 16, 17, 18, 19, 20, 21]) == 14\nassert find_min([15, 16, 17, 18, 19, 20, 21, 22]) == 15\nassert find_min([16, 17, 18, 19, 20, 21, 22, 23]) == 16\nassert find_min([17, 18, 19, 20, 21, 22, 23, 24]) == 17\nassert find_min([18, 19, 20, 21, 22, 23, 24, 25]) == 18\nassert find_min([",
      2.1640625
    ],
    [
      "# Heap Queue\n# Heap Queue is a data structure that keeps track of the smallest values in the queue,\n# while maintaining the order of the queue.\n\n# Heap Queue Example\n# Input: [1,2,3,4,5]\n# Output: 1,2,3,4,5\n\n# Heap Queue Example\n# Input: [2,4,3,1]\n# Output: 1,2,3,4\n\n# Heap Queue Example\n# Input: [2,3,1,5,4]\n# Output: 1,2,3,4,5\n\n\ndef smallest_heap_queue(nums):\n    heap = []\n    for i in range(len(nums)):\n        heap.append((nums[i], i))\n    heapq.heapify(heap)\n    for i in range(len(nums)):\n        heap.append((nums[i], i))\n        heapq.heapify(heap)\n    return heap[0][1]\n\n\ndef main():\n    nums = [1, 2, 3, 4, 5]\n    print(smallest_heap_queue(nums))\n\n    nums = [2, 4, 3, 1]\n    print(smallest_heap_queue(nums))\n\n    nums = [2, 3, 1, 5, 4]\n    print(smallest_heap_queue(nums))\n\n\nif __name__ == \"__main__\":\n    main()",
      0.98046875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution(object):\n    def smallestFromHeap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = nums[0]\n        for num in nums:\n            if num < res:\n                res = num\n        return res\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,3]\n    res = Solution().smallestFromHeap(nums)\n    print(res)\n    nums = [1,2,3,4]\n    res = Solution().smallestFromHeap(nums)\n    print(res)\n    nums = [4,5,6,7]\n    res = Solution().smallestFromHeap(nums)\n    print(res)",
      0.76904296875
    ],
    [
      "def find_smallest(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for i in nums:\n        heapq.heappush(heap, i)\n    heapq.heappop(heap)\n    return heap[0]\n\nif __name__ == '__main__':\n    nums = [3, 1, 4, 2]\n    print(find_smallest(nums))",
      0.2410888671875
    ],
    [
      "from heapq import heappush, heappop, heapify\n\ndef getMinHeap(heap):\n    \"\"\"\n    Input:\n        heap: list of integers\n    Output:\n        minHeap: list of integers\n    \"\"\"\n    minHeap = []\n    for i in range(len(heap)):\n        heappush(minHeap, heap[i])\n    return minHeap\n\ndef getMinHeap2(heap):\n    \"\"\"\n    Input:\n        heap: list of integers\n    Output:\n        minHeap: list of integers\n    \"\"\"\n    minHeap = []\n    heapify(minHeap, len(heap))\n    for i in range(len(heap)):\n        heappush(minHeap, heap[i])\n    return minHeap\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    minHeap = getMinHeap(heap)\n    print(minHeap)\n    print(minHeap[0], minHeap[-1])\n    minHeap = getMinHeap2(heap)\n    print(minHeap)\n    print(minHeap[0], minHeap[-1])\n\nif __name__ == \"__main__\":\n    main()",
      0.235107421875
    ],
    [
      "def min_heap_queue(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = [nums[0]]\n    for i in range(1, len(nums)):\n        if heap[0] > nums[i]:\n            heap[0] = nums[i]\n        else:\n            heap.append(nums[i])\n    return heap[0]\n\nif __name__ == '__main__':\n    nums = [1,3,2,4,5,7]\n    print(min_heap_queue(nums))",
      -0.05255126953125
    ],
    [
      "def findMin(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    q = [0]*(len(arr)+1)\n    for i in range(1, len(arr)+1):\n        q[i] = max(arr[0], i)\n        for j in range(1, i):\n            if arr[j] < arr[i]:\n                q[i] = min(q[i], j)\n    return q[1]\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        heap = [0]*len(nums)+[0]*(len(nums)+1)\n        heapq.heapify(heap)\n        for i in range(len(nums)):\n            heap[i+1][0] = heap[i][0] + nums[i]\n            heapq.heapify(heap)\n        return heapq.heappop(heap)[0]",
      -0.0533447265625
    ],
    [
      "import heapq\n\ndef find_smallest(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heapq.heapify(numbers)\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n\nif __name__ == '__main__':\n    assert find_smallest([3, 2, 1, 4, 5, 6]) == 1\n    assert find_smallest([-2, 0, 2, 4, -5]) == -2\n    assert find_smallest([-2, 0, 2, 4, -5]) == -2\n    assert find_smallest([]) == 0\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([]) == 0\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([-2, -3, -4, -5, -6]) == -6\n    assert find_smallest([]) == 0",
      -0.055267333984375
    ],
    [
      "import heapq\n\ndef find_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    heapq.heapify(nums)\n    min_value = nums[0]\n    for i in range(1, n):\n        if nums[i] < min_value:\n            min_value = nums[i]\n    return min_value\n\n\nif __name__ == '__main__':\n    nums = [1,2,3,4]\n    print(find_min(nums))\n    nums = [1,3,2,4]\n    print(find_min(nums))",
      -0.12017822265625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def smallestNumbers(self, root, numbers):\n        \"\"\"\n        :type root: TreeNode\n        :type numbers: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums = numbers\n        heapq.heapify(nums)\n        res = []\n        while nums:\n            res.append(nums.pop())\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    root = TreeNode(1)\n    numbers = [2, 4, 3, 1, 5, 6]\n    res = s.smallestNumbers(root, numbers)\n    print res",
      -0.259521484375
    ],
    [
      "from heapq import heappush, heappop\nfrom itertools import islice\n\ndef heap_min(heap):\n    return min(heap)\n\ndef min_heap(heap):\n    return min(heap)\n\ndef heap_min_with_dict(heap):\n    return min(heap)\n\ndef min_heap_with_dict(heap):\n    return min(heap)\n\ndef min_heap_with_dict_2(heap):\n    return min(heap)\n\ndef min_heap_with_dict_3(heap):\n    return min(heap)\n\ndef min_heap_with_dict_4(heap):\n    return min(heap)\n\ndef min_heap_with_dict_5(heap):\n    return min(heap)\n\ndef min_heap_with_dict_6(heap):\n    return min(heap)\n\ndef min_heap_with_dict_7(heap):\n    return min(heap)\n\ndef min_heap_with_dict_8(heap):\n    return min(heap)\n\ndef min_heap_with_dict_9(heap):\n    return min(heap)\n\ndef min_heap_with_dict_10(heap):\n    return min(heap)\n\ndef min_heap_with_dict_11(heap):\n    return min(heap)\n\ndef min_heap_with_dict_12(heap):\n    return min(heap)\n\ndef min_heap_with_dict_13(heap):\n    return min(heap)\n\ndef min_heap_with_dict_14(heap):\n    return min(heap)\n\ndef min_heap_with_dict_15(heap):\n    return min(heap)\n\ndef min_heap_with_dict_16(heap):\n    return min(heap)\n\ndef min_heap_with_dict_17(heap):\n    return min(heap)\n\ndef min_heap_with",
      -0.379638671875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def smallestNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        self.helper(root, res)\n        return res\n\n    def helper(self, root, res):\n        if not root:\n            return\n        if root.left:\n            self.helper(root.left, res)\n        if root.right:\n            self.helper(root.right, res)\n        res.append(root.val)",
      -0.71435546875
    ],
    [
      "class MinHeap:\n    def __init__(self, nums):\n        self.heap = []\n        for num in nums:\n            heap_add(self.heap, num)\n\n    def insert(self, num):\n        heap_add(self.heap, num)\n\n    def delete_min(self):\n        return heap_delete_min(self.heap)\n\n    def delete_max(self):\n        return heap_delete_max(self.heap)\n\n    def get_min(self):\n        return heap_get_min(self.heap)\n\n    def get_max(self):\n        return heap_get_max(self.heap)\n\n\ndef heap_add(heap, num):\n    heap.append(num)\n    heap_sift_up(heap, len(heap) - 1)\n\n\ndef heap_delete_min(heap):\n    return heap[0]\n\n\ndef heap_delete_max(heap):\n    return heap[-1]\n\n\ndef heap_get_min(heap):\n    return heap[0]\n\n\ndef heap_get_max(heap):\n    return heap[-1]\n\n\ndef heap_sift_up(heap, idx):\n    while idx > 0:\n        parent_idx = (idx - 1) // 2\n        if heap[idx] < heap[parent_idx]:\n            heap[idx], heap[parent_idx] = heap[parent_idx], heap[idx]\n            idx = parent_idx\n        else:\n            break\n    return idx\n\n\nif __name__ == \"__main__\":\n    nums = [3, 2, 4, 1, 1, 2, 5, 3, 1, 1]\n    min_heap = MinHeap(nums)\n    print(min_heap.get_min())\n    print(min_heap.get_max())\n    print(min_heap.delete_min())\n    print(min_heap.get_min())\n    print(min_heap.get_max())\n    print(min_heap",
      -0.76904296875
    ],
    [
      "def smallest_number(arr):\n    if not arr:\n        return None\n    heap = []\n    heapq.heappush(heap, arr[0])\n    min_heap = heap[0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_heap:\n            heapq.heappush(heap, arr[i])\n            min_heap = heap[0]\n    return min_heap\n\n\nif __name__ == \"__main__\":\n    print smallest_number([1,2,3,4,5])",
      -0.85693359375
    ],
    [
      "from heapq import heappush, heappop\nimport timeit\n\n\ndef find_smallest(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for num in numbers:\n        heappush(heap, num)\n        if len(heap) > 1:\n            heappop(heap)\n    return min(heap)\n\n\nif __name__ == '__main__':\n    print(timeit.timeit(\"find_smallest(numbers)\", setup=\"from __main__ import find_smallest, numbers\", number=1000))",
      -0.85693359375
    ],
    [
      "import heapq\n\nnumbers = [3, 2, 4, 5, 1, 6]\n\ndef find_min_heap(numbers):\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, number)\n    return heap\n\ndef find_min(numbers):\n    min_heap = find_min_heap(numbers)\n    return min(min_heap)\n\nprint(find_min(numbers))",
      -0.85693359375
    ],
    [
      "def findMin(nums):\n    heap = []\n    for i in range(0, len(nums)):\n        heapq.heappush(heap, nums[i])\n    return heap[0]\n\n\nif __name__ == '__main__':\n    nums = [2, 5, 6, 1, 8]\n    print(findMin(nums))",
      -0.85693359375
    ],
    [
      "class Solution:\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        heap = []\n        for n in nums:\n            heapq.heappush(heap, n)\n            if len(heap) > 1:\n                heapq.heappop(heap)\n        return heap[0] if len(heap) == 1 else -1",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for num in A:\n            heapq.heappush(heap, (num, -1))\n        return [heappop(heap)[0] for _ in range(len(heap))]",
      -0.85693359375
    ],
    [
      "from heapq import heappush, heappop, heapify\nfrom math import ceil\n\ndef find_smallest(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heapify(nums)\n    return nums[0]\n\ndef main():\n    nums = [1,2,3,4,5,6,7,8]\n    print(find_smallest(nums))\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "def smallest_numbers_from_heap_queue(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    heap = [0] * n\n    heapq.heapify(heap)\n    for i in range(n):\n        heapq.heappush(heap, nums[i])\n        while n > 1 and nums[n-1] > nums[n]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, nums[n-1])\n        n -= 1\n    return heapq.heappop(heap)\n\nif __name__ == '__main__':\n    print smallest_numbers_from_heap_queue([1,2,3,4])",
      -0.85791015625
    ],
    [
      "from heapq import heappush, heappop\n\ndef smallest_int_heap_queue(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for num in nums:\n        heappush(heap, num)\n    return nums[0]\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4]\n    print(smallest_int_heap_queue(nums))",
      -0.85791015625
    ],
    [
      "import heapq\n\ndef find_smallest(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heapq.heapify(numbers)\n    result = numbers[0]\n    for number in numbers:\n        if number < result:\n            result = number\n    return result\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print(find_smallest(numbers))",
      -0.85791015625
    ],
    [
      "from heapq import heappush, heappop, heapify\nfrom collections import deque\n\ndef find_min(nums):\n    if not nums:\n        return 0\n    heap = deque()\n    for num in nums:\n        heappush(heap, num)\n    return heappop(heap)\n\n# Your NumHeap object will be instantiated and called as such:\n# numHeap = NumHeap([2,6,9,3,5,7,8])\n# numHeap.insert(4)\n# numHeap.remove(5)\n# numHeap.min()",
      -0.85791015625
    ],
    [
      "# -*- coding: utf-8 -*-\n\nimport heapq\n\ndef find_smallest(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    numbers = sorted(numbers)\n    heap = []\n    for n in numbers:\n        heapq.heappush(heap, (n, 0))\n    min_val = heap[0][0]\n    for i in xrange(len(heap)):\n        heapq.heappop(heap)\n        min_val = min(min_val, heap[0][0])\n    return min_val\n\n\nif __name__ == \"__main__\":\n    numbers = [1, 2, 3, 4, 5]\n    print find_smallest(numbers)",
      -0.85791015625
    ],
    [
      "import heapq\n\ndef heap_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    h = []\n    for i in nums:\n        heapq.heappush(h, i)\n    return heapq.heappop(h)\n\nif __name__ == '__main__':\n    print(heap_min([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(heap_min([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))\n    print(heap_min([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
      -0.85791015625
    ],
    [
      "from heapq import *\n\ndef find_min_heap(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    # write your code here\n    # for the first element in the heap\n    heapq.heappush(min_heap, numbers[0])\n    # for the next elements\n    for i in range(1, len(numbers)):\n        heapq.heappush(min_heap, numbers[i])\n    # print the min element\n    return min_heap[0]\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_min_heap(numbers))",
      -0.8583984375
    ],
    [
      "class HeapQueue:\n    def __init__(self, nums):\n        self.nums = nums\n        self.size = len(nums)\n        self.heap = [0] * self.size\n        self.heapq = []\n\n    def build_heap(self):\n        for i in range(self.size - 1, 0, -1):\n            heapq.heappush(self.heapq, self.nums[i])\n\n    def heap_sort(self):\n        self.build_heap()\n        for i in range(self.size - 1, 0, -1):\n            self.nums[i], self.nums[0] = self.nums[0], self.nums[i]\n            heapq.heapify(self.heapq)\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(heapq.heappop(self.heapq), end=\" \")\n\n\nif __name__ == '__main__':\n    nums = [0, 1, 3, 5, 6, 8, 10, 12, 15, 18, 20]\n    heap = HeapQueue(nums)\n    heap.heap_sort()\n    print(heap.nums)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Heap queue\n        heap = []\n        for n in nums:\n            heapq.heappush(heap, n)\n            if len(heap) > 1:\n                heapq.heappop(heap)\n\n        return heapq.heappop(heap) if len(heap) > 0 else nums[0]",
      -0.8583984375
    ],
    [
      "import heapq\n\ndef smallest_integers(numbers):\n    heapq.heapify(numbers)\n    heapq.heappush(numbers, 1)\n    result = []\n    for _ in range(len(numbers)):\n        result.append(heapq.heappop(numbers))\n\n    return result\n\n\n\nif __name__ == '__main__':\n    numbers = [3, 2, 4, 1, 5]\n    print smallest_integers(numbers)",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallestRange(self, nums):\n        nums.sort()\n        return min(nums[0], nums[-1])\n\n\nif __name__ == '__main__':\n    assert Solution().smallestRange([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13]) == -13",
      -0.8583984375
    ],
    [
      "def find_min(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # Heap queue algorithm\n    heap = [i for i in arr]\n    heapq.heapify(heap)\n    min_num = heapq.heappop(heap)\n    # print min_num\n    while heap:\n        # print heap\n        heapq.heappush(heap, heapq.heappop(heap))\n        # print heap\n        if heapq.heappop(heap) < min_num:\n            min_num = heapq.heappop(heap)\n    return min_num\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    print(find_min(arr))",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param numbers, a list of integers\n    # @return an integer\n    def smallest(self, numbers):\n        if not numbers:\n            return 0\n        heap = []\n        heapq.heappush(heap, numbers[0])\n        for i in xrange(1, len(numbers)):\n            if heapq.heappush(heap, numbers[i]):\n                heapq.heappop(heap)\n                heapq.heappush(heap, numbers[i])\n        return heapq.heappop(heap)\n\nnumbers = [1, 3, 5, 7, 8, 9]\nprint Solution().smallest(numbers)",
      -0.8583984375
    ],
    [
      "from heapq import heappush, heappop\nfrom collections import deque\n\ndef heap_smallest(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = deque()\n    for num in nums:\n        heappush(heap, num)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    nums = [4, 3, 5, 2, 1]\n    print(heap_smallest(nums))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.smallestNumbers_heap_queue(nums, 0)\n\n    def smallestNumbers_heap_queue(self, nums, start):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :rtype: List[int]\n        \"\"\"\n        if nums:\n            q = [heapq.heappop(nums) for _ in range(len(nums))]\n            return self.smallestNumbers_heap_queue(nums, start) + [heapq.heappop(q) for _ in range(len(nums))]\n        else:\n            return []",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallestFromHeap(self, nums):\n        if not nums:\n            return 0\n        pq = PriorityQueue()\n        for num in nums:\n            pq.enqueue(num)\n        return pq.getMin()",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i], i))\n\n        return [heapq.heappop(heap)[1] for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    assert Solution().smallestNumbers([-1, -2, -3, -4]) == [-4, -3, -2, -1]",
      -0.85888671875
    ],
    [
      "from collections import deque\n\ndef smallest_integers(numbers):\n    heap = deque()\n    for num in numbers:\n        heap.append(num)\n    while heap:\n        heap.popleft()\n        heap.appendleft(heap.popleft())\n    return heap.popleft()\n\n\n# Your code here\n# numbers = [2, 3, 1, 2, 4, 5, 2, 3, 4]\n# smallest_integers(numbers)\n# print(heap)",
      -0.85888671875
    ],
    [
      "from heapq import *\n\ndef find_min(lst):\n\t\"\"\"\n\tGiven a list of numbers, find the smallest one and return it.\n\t\"\"\"\n\theap = []\n\tfor i in lst:\n\t\theappush(heap, i)\n\treturn heappop(heap)\n\n#Testing\nif __name__ == '__main__':\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tprint(find_min(lst))\n\tlst = [1, 5, 6, 7, 9]\n\tprint(find_min(lst))\n\tlst = [1, 2, 3]\n\tprint(find_min(lst))\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tprint(find_min(lst))",
      -0.85888671875
    ],
    [
      "from heapq import heappush, heappop\n\nclass HeapQueue:\n    def __init__(self):\n        self.queue = []\n\n    def push(self, item):\n        heappush(self.queue, item)\n\n    def pop(self):\n        return heappop(self.queue)\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\nif __name__ == '__main__':\n    input_list = [1, 3, 5, 2, 4, 6]\n    heap = HeapQueue()\n    for num in input_list:\n        heap.push(num)\n\n    print heap.pop()\n    print heap.pop()\n    print heap.pop()\n    print heap.pop()\n    print heap.is_empty()",
      -0.85888671875
    ],
    [
      "class MinHeap(object):\n    \"\"\"\n    Min Heap implementation.\n    \"\"\"\n    def __init__(self, array):\n        self.array = array\n\n    def getMin(self):\n        return self.array[0]\n\n    def insert(self, val):\n        heapq.heappush(self.array, val)\n\n    def deleteMin(self):\n        return heapq.heappop(self.array)\n\n\ndef main():\n    print MinHeap([100, 2, 8, 5, 1, 7]).deleteMin()\n\nif __name__ == \"__main__\":\n    main()",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallest(self, nums):\n        if not nums:\n            return 0\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, (-num,))\n        heapq.heappop(heap)\n        return -heap[0][0]",
      -0.85888671875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n            if len(heap) > 1:\n                heapq.heappop(heap)\n        return [heapq.heappop(heap) for _ in xrange(len(heap))]",
      -0.85888671875
    ],
    [
      "def heap_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    nums.sort()\n    heap = []\n    for i in range(len(nums)):\n        heap.append((nums[i], i))\n    return nums[0]\n\n\ndef main():\n    nums = [1, 2, 3, 4, 5]\n    print heap_min(nums)\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "class MinHeap:\n    def __init__(self, numbers):\n        self.heap = []\n        for number in numbers:\n            self.heap.append(number)\n\n    def min(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap[0]\n\n    def pop(self):\n        return self.heap.pop(0)\n\ndef min_heap_with_sorting(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heap = MinHeap(numbers)\n    for number in numbers:\n        heap.heap.append(number)\n    return heap.min()\n\n\nif __name__ == \"__main__\":\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"min heap with sorting:\", min_heap_with_sorting(numbers))\n    print(\"min heap with queue:\", min_heap_with_queue(numbers))",
      -0.85888671875
    ],
    [
      "# Heap queue algorithm\nclass HeapQueue(object):\n    def __init__(self):\n        self.heap = []\n\n    def push(self, item):\n        heapq.heappush(self.heap, item)\n\n    def pop(self):\n        return heapq.heappop(self.heap)\n\n    def is_empty(self):\n        return self.heap == []\n\n    def peek(self):\n        return self.heap[0]\n\n\n# Heap queue test\ndef main():\n    heap = HeapQueue()\n    heap.push(2)\n    heap.push(1)\n    heap.push(3)\n    heap.push(9)\n    heap.push(10)\n    heap.push(4)\n    heap.push(5)\n    heap.push(6)\n    heap.push(7)\n    heap.push(8)\n    heap.push(0)\n    heap.push(11)\n\n    while not heap.is_empty():\n        print(heap.pop())\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "import heapq\n\n\ndef min_heap_numbers(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, number)\n    return heap\n\n\ndef min_heap_numbers_2(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, number)\n    return heap[0]",
      -0.93017578125
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n\n        heap = []\n        for i in range(len(nums)):\n            heap.append(nums[i])\n            while len(heap) > 1 and heap[0] > heap[1]:\n                heap[0], heap[1] = heap[1], heap[0]\n                heap.pop()\n        return heap[0]\n\nif __name__ == \"__main__\":\n    print Solution().findMin([1,2,3])",
      -0.93359375
    ],
    [
      "import heapq\nimport bisect\n\n\ndef smallest_from_heap(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, number)\n    heap.sort()\n    return heap[0]\n\n\ndef smallest_from_bisect(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    # use bisect to find the smallest number\n    # use heapq to sort the numbers\n    # return the first one\n    return bisect.bisect_left(numbers, numbers[0])\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6]\n    print smallest_from_heap(numbers)\n    print smallest_from_bisect(numbers)",
      -1.4287109375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def smallestFromHeap(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        heap = []\n        heap.append(root)\n        while len(heap) > 1:\n            parent = heap[0]\n            left = parent.left\n            right = parent.right\n            if left is not None and left.val < parent.val:\n                parent.left = left\n                if left.val < right.val:\n                    heap.append(left)\n                else:\n                    heap.append(right)\n            elif right is not None and right.val < parent.val:\n                parent.right = right\n                if right.val < left.val:\n                    heap.append(right)\n                else:\n                    heap.append(left)\n            else:\n                heap.pop()\n        return heap[0].val\n\n\ndef main():\n    root = TreeNode(5)\n    root.left = TreeNode(2)\n    root.left.left = TreeNode(1)\n    root.right = TreeNode(3)\n    root.right.right = TreeNode(4)\n    root.right.right.left = TreeNode(6)\n    root.right.right.right = TreeNode(7)\n    print Solution().smallestFromHeap(root)\n\n\nif __name__ == '__main__':\n    main()",
      -1.861328125
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        heap = [(n, i) for i, n in enumerate(nums)]\n        heapq.heapify(heap)\n        while len(heap) > 1:\n            heapq.heappop(heap)\n            heapq.heappop(heap)\n        return heap[0][1]\n\nif __name__ == \"__main__\":\n    print Solution().smallestNumbers([1, 2, 3, 4, 5])\n    print Solution().smallestNumbers([6, 7, 8, 9, 10])\n    print Solution().smallestNumbers([1, 2, 3, 4, 5, 6])",
      -2.109375
    ],
    [
      "from heapq import heappush, heappop\nfrom collections import deque\n\ndef find_min(nums):\n    heap = []\n    for num in nums:\n        heappush(heap, num)\n    return min(heap)\n\ndef find_min_heap_queue(nums):\n    heap = deque()\n    for num in nums:\n        heappush(heap, num)\n    return min(heap)\n\ndef find_min_heap_queue_2(nums):\n    heap = []\n    for num in nums:\n        heappush(heap, num)\n    return min(heap)\n\ndef find_min_heap_queue_3(nums):\n    heap = []\n    for num in nums:\n        heappush(heap, num)\n        while len(heap) > 1 and heap[0] <= heap[1]:\n            heappop(heap)\n    return min(heap)\n\nif __name__ == \"__main__\":\n    print find_min([2, 3, 4, 5, 6])\n    print find_min_heap_queue([2, 3, 4, 5, 6])\n    print find_min_heap_queue_2([2, 3, 4, 5, 6])\n    print find_min_heap_queue_3([2, 3, 4, 5, 6])",
      -2.130859375
    ],
    [
      "class HeapQueue(object):\n    \"\"\"\n    Use a queue to implement a heap.\n    \"\"\"\n    def __init__(self):\n        self.q = []\n\n    def push(self, num):\n        \"\"\"\n        Push a new number into the queue.\n        \"\"\"\n        heapq.heappush(self.q, num)\n\n    def pop(self):\n        \"\"\"\n        Pop a number from the queue and return it.\n        \"\"\"\n        return heapq.heappop(self.q)\n\n    def is_empty(self):\n        \"\"\"\n        Check whether the queue is empty or not.\n        \"\"\"\n        return self.q == []\n\nclass Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = HeapQueue()\n        for num in nums:\n            heap.push(num)\n        for i in range(len(nums)):\n            heap.push(heap.pop())\n        return [heap.pop() for i in range(len(nums))]",
      -2.181640625
    ],
    [
      "# Heap queue algorithm\n# Time complexity: O(n)\n# Space complexity: O(1)\n# https://discuss.leetcode.com/topic/874/java-solution-using-heap-queue-algorithm-with-space-and-time-complexity/5\n\nclass Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(nums)\n        return [heapq.heappop(nums) for _ in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    print Solution().smallestNumbers([1, 2, 3, 4, 5])",
      -2.193359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def minHeap(self, nums):\n        if not nums:\n            return 0\n        \n        heap = []\n        heap.append(nums[0])\n        for i in range(1, len(nums)):\n            # heap push\n            if heap[0] > nums[i]:\n                heap[0] = nums[i]\n            # heap pop\n            elif heap[0] < nums[i]:\n                heap[0] = nums[i]\n                heap.append(nums[i])\n        \n        return heap[0]\n\nif __name__ == \"__main__\":\n    nums = [2, 1, 3, 4, 5, 7, 6, 8]\n    print Solution().minHeap(nums)",
      -2.50390625
    ],
    [
      "from heapq import heappush, heappop\n\n\ndef find_min(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for i in array:\n        heappush(heap, (i, i))\n\n    min = min(heap)\n    while heap:\n        heappop(heap)\n        min = min(heap)\n\n    return min\n\nif __name__ == \"__main__\":\n    print(find_min([2, 3, 1, 4]))",
      -2.57421875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def minHeap(self, root: TreeNode, n: int) -> TreeNode:\n        def push(node):\n            heapq.heappush(queue, node)\n            while node.left:\n                push(node.left)\n                node = node.right\n\n        def pop(node):\n            if node:\n                heapq.heappop(queue)\n                node.right = pop(node.right)\n                node.left = pop(node.left)\n                return node\n            else:\n                return None\n\n        queue = []\n        push(root)\n        result = None\n        while queue:\n            node = queue.pop(0)\n            if result is None:\n                result = node\n            else:\n                if node.val <= result.val:\n                    break\n                else:\n                    heapq.heappush(queue, node)\n        return result\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(val=5, left=TreeNode(val=4, left=TreeNode(val=3), right=TreeNode(val=2)), right=TreeNode(val=1))\n    root.left.left = TreeNode(val=9, left=TreeNode(val=8, left=TreeNode(val=7), right=TreeNode(val=6)), right=TreeNode(val=5))\n    root.left.right.left = TreeNode(val=15, left=TreeNode(val=14, left=TreeNode(val=13), right=TreeNode(val=12)), right=TreeNode(val=11))\n    root.left.right.right = TreeNode(val=17, left=TreeNode(val=16, left=TreeNode(val=15), right=TreeNode(val=14)), right=TreeNode(val=19))\n    root.left.right.right.left = TreeNode(val=21, left=TreeNode(val=20",
      -2.634765625
    ],
    [
      "# Heap Queue\n# https://www.youtube.com/watch?v=G6xzZvwUQcw\n# https://www.youtube.com/watch?v=6lZ5q5l0Qz4\n# https://www.youtube.com/watch?v=jvQFJ3q_JYs\n# https://www.youtube.com/watch?v=3Uf8iVcHW0U\n# https://www.youtube.com/watch?v=7k5D_yV9rjw\n# https://www.youtube.com/watch?v=8R5LzKlDqU4\n# https://www.youtube.com/watch?v=3r6v9nV5Ylw\n# https://www.youtube.com/watch?v=4NxJ8Wu_zD0\n# https://www.youtube.com/watch?v=e7z_fG5jw7w\n# https://www.youtube.com/watch?v=VXVwX1mC4Q4\n# https://www.youtube.com/watch?v=GZg4wzW_0eI\n# https://www.youtube.com/watch?v=qK0pVXzDZ_w\n# https://www.youtube.com/watch?v=1cM3lmFyY6s\n# https://www.youtube.com/watch?v=a8Qi5Z_2C6g\n# https://www.youtube.com/watch?v=ZxJQF3zP2_I\n# https://www.youtube.com/watch?v=i-zWw6l2xCc\n# https://www.youtube.com/watch?v=lE0z0-VY0WQ\n# https://www.youtube.com/watch?v=iC6xj4mF9Ek\n# https://www.youtube.com/watch?v=jfkQ_QV5ZM0\n# https://www.youtube.com/watch?v=Fx1wB_8ZrZc\n# https://www.",
      -2.8046875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        h = [root]\n        depth = 1\n        while h:\n            cur_depth = len(h)\n            for i in range(cur_depth):\n                n = h[i]\n                if n.left:\n                    h.append(n.left)\n                if n.right:\n                    h.append(n.right)\n            depth += cur_depth\n            h.pop()\n        return depth",
      -3.0390625
    ],
    [
      "#!/usr/bin/env python\n\nimport heapq\n\nnums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# min heap\ndef min_heap(nums):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) == len(nums):\n            break\n    return heap\n\n# max heap\ndef max_heap(nums):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, -num)\n        if len(heap) == len(nums):\n            break\n    return heap\n\n# min heap\ndef min_heap2(nums):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) == len(nums):\n            break\n    return heap\n\n# max heap\ndef max_heap2(nums):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, -num)\n        if len(heap) == len(nums):\n            break\n    return heap\n\nprint min_heap(nums)\nprint min_heap2(nums)\nprint max_heap(nums)\nprint max_heap2(nums)",
      -3.046875
    ],
    [
      "import collections\n\ndef smallest_from_heap(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: int\n    \"\"\"\n    if not lst:\n        return 0\n    min_heap = collections.deque()\n    for i in lst:\n        min_heap.append(i)\n        if len(min_heap) == 1:\n            return i\n        min_heap.popleft()\n    return min_heap.popleft()\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print(smallest_from_heap(lst))\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print(smallest_from_heap(lst))",
      -3.232421875
    ],
    [
      "# Heap queue\ndef find_min_heap(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    nums.sort()\n    heap_queue = []\n    for i in range(len(nums)):\n        heap_queue.append((nums[i], i))\n    heap_queue.append((nums[len(nums) - 1], len(nums) - 1))\n    while heap_queue:\n        if len(heap_queue) > 1:\n            heap_queue[0][1] -= 1\n            heap_queue[0][0] = nums[heap_queue[0][1]]\n        else:\n            return nums[0]\n        heapq.heapify(heap_queue)\n    return nums[0]\n\n# Heap queue\ndef find_min_heap2(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    heap_queue = []\n    for i in range(len(nums)):\n        heap_queue.append((nums[i], i))\n    heap_queue.append((nums[len(nums) - 1], len(nums) - 1))\n    heapq.heapify(heap_queue)\n    while heap_queue:\n        if len(heap_queue) > 1:\n            heap_queue[0][1] -= 1\n            heap_queue[0][0] = nums[heap_queue[0][1]]\n        else:\n            return nums[0]\n        heapq.heapify(heap_queue)\n    return nums[0]\n\n# Heap queue\ndef find_min_heap3(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    heap_queue = []\n    for i in range(len",
      -3.416015625
    ],
    [
      "from heapq import *\n\ndef find_smallest(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    heapify(numbers)\n    return numbers[0]\n\n\ndef heapify(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    \"\"\"\n    heapify(numbers, 0, len(numbers))\n\n\ndef heapify(numbers, start, end):\n    \"\"\"\n    :type numbers: List[int]\n    :type start: int\n    :type end: int\n    \"\"\"\n    if start >= end:\n        return\n    index = start + (end - start) // 2\n    while index >= start and numbers[index] < numbers[start]:\n        heapify(numbers, index, end)\n        index = start + (end - start) // 2\n\n\ndef main():\n    numbers = [2, 4, 6, 8, 10, 12, 14, 16]\n    find_smallest(numbers)\n    print(find_smallest(numbers))\n\n\nif __name__ == '__main__':\n    main()",
      -3.5
    ],
    [
      "import heapq\n\ndef smallest_integers(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    smallest_integers = []\n    for i in range(len(numbers)):\n        heapq.heappush(smallest_integers, numbers[i])\n        if len(smallest_integers) > len(numbers):\n            heapq.heappop(smallest_integers)\n    return smallest_integers\n\nif __name__ == \"__main__\":\n    assert smallest_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert smallest_integers([]) == []\n    assert smallest_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    assert smallest_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    assert smallest_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,",
      -3.65234375
    ],
    [
      "# heapsort\ndef heap_sort(nums):\n    \"\"\"\n    >>> heap_sort([10,7,6,5,4,3,2,1,0])\n    [0, 1, 2, 3, 4, 5, 6, 7, 10]\n    \"\"\"\n    heap = []\n    for n in nums:\n        heap.append(n)\n    while len(heap) > 1:\n        heapq.heappop(heap)\n        heapq.heappush(heap, heap[0])\n    return heap\n\n# heap queue\ndef heap_queue(nums):\n    \"\"\"\n    >>> heap_queue([10,7,6,5,4,3,2,1,0])\n    [0, 1, 2, 3, 4, 5, 6, 7, 10]\n    \"\"\"\n    heap = []\n    for n in nums:\n        heap.append(n)\n    while len(heap) > 1:\n        heapq.heappop(heap)\n        heapq.heappush(heap, heap[0])\n    return heap\n\n# bubble sort\ndef bubble_sort(nums):\n    \"\"\"\n    >>> bubble_sort([10,7,6,5,4,3,2,1,0])\n    [0, 1, 2, 3, 4, 5, 6, 7, 10]\n    \"\"\"\n    while len(nums) > 1:\n        for i in range(len(nums)):\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n    return nums\n\nif __name__ == \"__main__\":\n    nums = [10,7,6,5,4,3,2,1,0]\n    print(heap_sort(nums))\n    print(heap_queue(nums))\n    print(bubble_sort(nums))",
      -3.736328125
    ],
    [
      "# https://www.hackerrank.com/challenges/smallest-integers/problem\n\nimport sys\n\n# Heap Queue\n# 1. Create a new queue with the given list of numbers.\n# 2. Insert all the numbers into the queue.\n# 3. Delete all the numbers from the queue.\n# 4. Print the smallest number in the queue.\n\ndef smallest_integers(numbers):\n    # 1. Create a new queue with the given list of numbers.\n    queue = []\n    for number in numbers:\n        queue.append(number)\n\n    # 2. Insert all the numbers into the queue.\n    for number in numbers:\n        queue.append(number)\n\n    # 3. Delete all the numbers from the queue.\n    for number in numbers:\n        queue.pop()\n\n    # 4. Print the smallest number in the queue.\n    print(queue[0])\n\nif __name__ == '__main__':\n    numbers = list(map(int, sys.stdin.readline().split()))\n    smallest_integers(numbers)",
      -3.83203125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def minNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        heap = []\n        for i in xrange(len(nums)):\n            heapq.heappush(heap, (nums[i], i))\n        return min(heap)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.minNumber([-1, 0, -2, 1, -3, 2, 3, 4, 5, 6, 7])",
      -3.9453125
    ],
    [
      "from heapq import *\nimport random\nimport time\n\ndef min_heap_queue(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify(arr)\n    return arr\n\n\ndef max_heap_queue(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify(arr)\n    return arr\n\n\ndef heap_queue(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify(arr)\n    return arr\n\n\ndef heap_queue2(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify2(arr)\n    return arr\n\n\ndef heap_queue3(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify3(arr)\n    return arr\n\n\ndef heap_queue4(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify4(arr)\n    return arr\n\n\ndef heap_queue5(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify5(arr)\n    return arr\n\n\ndef heap_queue6(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify6(arr)\n    return arr\n\n\ndef heap_queue7(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify7(arr)\n    return arr\n\n\ndef heap_queue8(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapify8(arr)\n    return arr\n\n\ndef heap_queue9(arr):",
      -4.09765625
    ],
    [
      "class HeapQueue:\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.heap = []\n        for i in nums:\n            self.push(i)\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the heap.\n        :type x: int\n        \"\"\"\n        self.heap.append(x)\n        while len(self.heap) > 1 and x < self.heap[0]:\n            self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\n            self.heap[-1] = self.heap[-1] - self.heap[0]\n            self.heap[0] = self.heap[0] - self.heap[-1]\n\n    def peek(self):\n        \"\"\"\n        Get the top element from the heap.\n        :rtype: int\n        \"\"\"\n        if self.heap:\n            return self.heap[0]\n        else:\n            return None\n\n    def pop(self):\n        \"\"\"\n        Pop the top element from the heap and return its top value.\n        :rtype: int\n        \"\"\"\n        if self.heap:\n            return self.heap.pop()\n        else:\n            return None\n\n    def get_min(self):\n        \"\"\"\n        Return the minimum element in the heap.\n        :rtype: int\n        \"\"\"\n        if self.heap:\n            return self.heap[0]\n        else:\n            return None\n\n    def get_min_index(self):\n        \"\"\"\n        Return the index of the minimum element in the heap.\n        :rtype: int\n        \"\"\"\n        if self.heap:\n            return 0\n        else:\n            return None\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return len(self.heap) == 0\n\n    def size(self):\n        \"\"\"\n        Returns the size of the queue.",
      -4.41015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def smallestValues(self, root: TreeNode) -> List[int]:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        heap = [root]\n        while heap:\n            root = heap.pop()\n            if root.left:\n                heap.append(root.left)\n            if root.right:\n                heap.append(root.right)\n        return [root.val for root in heap]",
      -4.98828125
    ],
    [
      "# Heap queue implementation\ndef min_heap(nums):\n    heap = []\n    for i in range(nums):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_2(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_3(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_4(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_5(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_6(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_7(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i], i))\n    return heap[0]\n\n# Heap queue implementation\ndef min_heap_8(nums):\n    heap = []\n    for i in range(len(nums)):\n        heapq.heappush(heap, (nums[i",
      -5.19140625
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        # make a heap queue\n        queue = []\n        for number in nums:\n            heapq.heappush(queue, number)\n            if len(queue) > 1 and number > heapq.heappop(queue):\n                heapq.heappush(queue, number)\n\n        # pop the smallest one\n        while queue:\n            heapq.heappop(queue)\n\n        # return the smallest one\n        return queue[0]\n\n# Note:\n# 1. The smallest number in a heap queue is always the smallest one.\n# 2. The size of the queue is the number of numbers in the queue.\n# 3. The size of the queue is always 1 or greater.",
      -5.25
    ],
    [
      "# Heap queue implementation\nclass HeapQueue(object):\n    def __init__(self):\n        self.queue = []\n\n    def push(self, val):\n        self.queue.append(val)\n        self.update_heap()\n\n    def update_heap(self):\n        while len(self.queue) > 1:\n            left_child = len(self.queue) / 2\n            right_child = left_child + 1\n            if left_child >= len(self.queue):\n                break\n            if self.queue[left_child] > self.queue[right_child]:\n                # swap\n                self.queue[left_child], self.queue[right_child] = self.queue[right_child], self.queue[left_child]\n                # update_heap\n                left_child = len(self.queue) / 2\n                right_child = left_child + 1\n                if left_child >= len(self.queue):\n                    break\n            elif self.queue[left_child] < self.queue[right_child]:\n                break\n        return\n\n    def pop(self):\n        if len(self.queue) == 0:\n            return None\n        # update_heap\n        self.queue[0], self.queue[len(self.queue) - 1] = self.queue[len(self.queue) - 1], self.queue[0]\n        self.update_heap()\n        return self.queue.pop(0)\n\n\n# Your HeapQueue object will be instantiated and called as such:\n# obj = HeapQueue()\n# obj.push(val)\n# param_2 = obj.pop()\n\ndef smallest_integers_from_list(numbers):\n    heap = HeapQueue()\n    for number in numbers:\n        heap.push(number)\n    return heap.pop()\n\n# Note:\n# This solution is from the LeetCode.com\n# http://www.leetcode.com/problems/smallest-integers-from-a-sorted-list/solution/\n# This is an algorithm that uses a heap queue and a binary search tree to solve this problem.\n# This is a",
      -5.89453125
    ],
    [
      "# Heap queue algorithm\n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n# Heap queue is a data structure that uses a heap to keep track of the order of the elements. \n#",
      -6.1484375
    ],
    [
      "from heapq import heappush, heappop\n\n\ndef smallest_number_in_heap(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(numbers)\n    heap = [heappop(numbers) for _ in range(n)]\n    while n > 1:\n        heappush(heap, heappop(numbers))\n        n -= 1\n    return heap[0]\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(smallest_number_in_heap(numbers))",
      -6.4296875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n        \n        # construct a heap\n        # heap[0] = min(nums)\n        heap = [max(nums)]\n        \n        for i in range(1, len(nums)):\n            heap.append(min(heap[-1:] + [nums[i]]))\n        \n        # find the smallest\n        min_ = heap[0]\n        \n        for i in range(1, len(heap)):\n            if heap[i] < min_:\n                min_ = heap[i]\n        \n        return min_",
      -6.55078125
    ],
    [
      "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.size = len(arr)\n        self.heap = [x for x in arr]\n        self.size = len(arr)\n\n    def heapify(self):\n        for i in range(self.size/2, -1, -1):\n            self.heapify(i)\n\n    def build_heap(self):\n        for i in range(self.size/2, -1, -1):\n            self.heapify(i)\n\n    def heap_size(self):\n        return self.size\n\n    def heap_is_empty(self):\n        return self.heap_size() == 0\n\n    def heap_is_full(self):\n        return self.heap_size() == self.size\n\n    def heap_is_sorted(self):\n        for i in range(self.size/2, -1, -1):\n            if self.arr[i] > self.arr[i-1]:\n                return False\n        return True\n\n    def heap_is_min(self, index):\n        return self.arr[index] == min(self.heap)\n\n    def heap_push(self, val):\n        self.arr[self.size] = val\n        self.heap.append(val)\n        self.size += 1\n\n    def heap_pop(self):\n        if self.heap_is_empty():\n            return None\n        else:\n            self.arr[0] = self.arr[self.heap_size()-1]\n            self.arr[self.heap_size()-1] = min(self.heap)\n            self.heap_size() -= 1\n            self.heap.pop()\n            self.heapify()\n            return self.arr[0]\n\n    def heap_peek(self):\n        if self.heap_is_empty():\n            return None\n        else:\n            return self.arr[0]\n\n    def heap_peek_index(self):\n        if self.heap_is_empty():\n            return None\n        else:\n            return 0",
      -6.796875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def minHeap(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n\n        queue = []\n        for i in range(len(arr)):\n            node = TreeNode(arr[i])\n            heapq.heappush(queue, node)\n\n        return min(queue)\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = []\n# param_3 = []\n# param_4 = []\n# param_5 = []\n# param_6 = []\n# obj.minHeap(param_1)",
      -7.2421875
    ],
    [
      "class Solution(object):\n    def smallestNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        heap = []\n        for n in nums:\n            heap.append((n, heapq.heappop(heap)))\n        heapq.heappush(heap, (0, heap[0]))\n        return heap[0][0]\n\n\nif __name__ == '__main__':\n    print Solution().smallestNumbers([1, 2, 3, 4, 5])",
      -7.44921875
    ],
    [
      "# Heap queue\nclass MinHeap:\n    def __init__(self):\n        self.queue = []\n\n    def insert(self, value):\n        self.queue.append(value)\n\n        while len(self.queue) > 1 and self.queue[-1] > self.queue[-2]:\n            self.queue[-1] = self.queue.pop()\n            self.queue[-2] = self.queue[-1]\n\n    def peek(self):\n        return self.queue[0]\n\n    def pop(self):\n        return self.queue.pop()\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)\n\n\n# Solution\nclass MinHeap:\n    def __init__(self):\n        self.queue = []\n\n    def insert(self, value):\n        self.queue.append(value)\n\n        while len(self.queue) > 1 and self.queue[-1] > self.queue[-2]:\n            self.queue[-1] = self.queue.pop()\n            self.queue[-2] = self.queue[-1]\n\n    def peek(self):\n        return self.queue[0]\n\n    def pop(self):\n        return self.queue.pop()\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)\n\n\n# Heap queue\nclass MinHeap:\n    def __init__(self):\n        self.queue = []\n\n    def insert(self, value):\n        self.queue.append(value)\n\n        while len(self.queue) > 1 and self.queue[-1] > self.queue[-2]:\n            self.queue[-1] = self.queue.pop()\n            self.queue[-2] = self.queue[-1]\n\n    def peek(self):\n        return self.queue[0]\n\n    def pop(self):\n        return self.queue.pop()\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def size(self):",
      -7.5546875
    ],
    [
      "# Heap queue algorithm\n# Time complexity: O(n)\n# Space complexity: O(n)\n\nclass Solution(object):\n    def minHeap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return 0\n\n        heap_list = []\n        for i in range(len(nums)):\n            heap_list.append(nums[i])\n\n        heap_list.sort()\n        heap_list.reverse()\n\n        for i in range(len(nums)):\n            nums[i] = heap_list[i]\n\n        return nums[0]\n\n    def minHeap2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return 0\n\n        heap_list = [0] * len(nums)\n        heap_list[0] = nums[0]\n\n        for i in range(1, len(nums)):\n            heap_list[i] = nums[i]\n            if heap_list[i - 1] > nums[i]:\n                heap_list[i] = heap_list[i - 1]\n            else:\n                heap_list[i] = nums[i]\n\n        return heap_list[0]\n\n\nif __name__ == \"__main__\":\n    nums = [2, 4, 6, 1, 3]\n    print(Solution().minHeap(nums))\n    print(Solution().minHeap2(nums))",
      -8.125
    ],
    [
      "# Heap queue\nclass HeapQueue:\n    def __init__(self, list):\n        self.heap = list\n\n    def peek(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap[0]\n\n    def pop(self):\n        if len(self.heap) == 0:\n            return None\n        temp = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        return temp\n\n    def insert(self, value):\n        self.heap.insert(value)\n\n\n# Binary Heap\nclass BinaryHeap:\n    def __init__(self, list):\n        self.heap = list\n        self.size = len(list)\n\n    def peek(self):\n        if self.size == 0:\n            return None\n        return self.heap[0]\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        temp = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.size -= 1\n        return temp\n\n    def insert(self, value):\n        self.heap.insert(value)\n\n\n# Recursive Heap\nclass RecursiveHeap:\n    def __init__(self, list):\n        self.heap = list\n        self.size = len(list)\n\n    def peek(self):\n        if self.size == 0:\n            return None\n        return self.heap[0]\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        temp = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.size -= 1\n        return temp\n\n    def insert(self, value):\n        self.heap.insert(value)\n\n\n# Heap\nclass Heap:\n    def __init__(self, list):\n        self.heap = list\n        self.size = len(list)\n\n    def peek(self):\n        if self.size == 0:\n            return None\n        return self.heap[0]",
      -8.515625
    ],
    [
      "class Heap(object):\n\n    def __init__(self, arr):\n        self.arr = arr\n\n    def build_heap(self):\n        for i in range(len(self.arr)):\n            self.arr[i], self.arr[-1] = self.arr[-1], self.arr[i]\n            self.heapify(i)\n\n    def heapify(self, i):\n        while i > 0:\n            # left child\n            j = i * 2 + 1\n            if j < len(self.arr) and self.arr[j] < self.arr[i]:\n                i = j\n            else:\n                return\n\n        self.arr[i], self.arr[0] = self.arr[0], self.arr[i]\n        self.heapify(0)\n\n\ndef heap_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    heap = Heap(arr)\n    heap.build_heap()\n\n    for i in range(len(arr)):\n        arr[i] = heap.arr[0]\n        heap.heapify(0)\n\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [4, 6, 2, 3, 1, 5]\n    print(heap_sort(arr))",
      -8.6015625
    ],
    [
      "from collections import deque\n\nclass MinHeap(object):\n    \"\"\"\n    Heap implementation using a min heap.\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        Initialize a new MinHeap with the given list of numbers.\n        \"\"\"\n        self.nums = nums\n        self.heap = deque()\n        for num in nums:\n            self.insert(num)\n\n    def insert(self, num):\n        \"\"\"\n        Insert a new number into the heap.\n        \"\"\"\n        heap_item = (num, 1)\n        self.heap.append(heap_item)\n        while len(self.heap) > 1 and self.heap[0][0] > self.heap[1][0]:\n            self.heap.popleft()\n\n    def delete_min(self):\n        \"\"\"\n        Delete the smallest element from the heap.\n        \"\"\"\n        heap_item = self.heap.popleft()\n        self.nums.remove(heap_item[0])\n        return heap_item\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of the heap.\n        \"\"\"\n        return \"Heap: \" + str(self.heap)\n\ndef min_heap_with_function(nums):\n    \"\"\"\n    Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.\n    \"\"\"\n    min_heap = MinHeap(nums)\n    for num in nums:\n        min_heap.insert(num)\n    while min_heap.heap:\n        min_heap.delete_min()\n    return min_heap.nums\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert min_heap_with_function([1, 3, 2, 5, 4, 7, 8, 6]) == [1, 2, 3, 4, 5, 6, 7, 8], \"Example\"\n    assert min_heap_with_function([2, 4, 6, 8, 10, 9]) ==",
      -9.2109375
    ],
    [
      "import heapq\n\n\ndef min_heap(heap_list):\n    heap_list = sorted(heap_list)\n    heap_list = [heapq.heappush(heap_list, x) for x in heap_list]\n    return heap_list\n\n\ndef min_heap_recursive(heap_list):\n    if not heap_list:\n        return heap_list\n    left = heap_list[0]\n    right = heap_list[1]\n    if left < right:\n        heap_list[0] = right\n        heap_list[1] = left\n        heap_list = min_heap_recursive(heap_list[2:])\n    else:\n        heap_list = heap_list[1:]\n    return heap_list\n\n\nif __name__ == '__main__':\n    heap_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(min_heap_recursive(heap_list))",
      -9.453125
    ],
    [
      "# Heap queue is a very fast and simple algorithm, but it is not very good.\n# If you want to use it, please make sure it's faster than other algorithms.\n# For example, if you want to find the smallest number in a list of integers, you can use heap queue algorithm.\n# But if you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# The difference between the two algorithms is that priority queue uses a priority queue to store its elements.\n# You can use priority queue to store your elements and then use heap queue to find the smallest number.\n# But priority queue is slower than heap queue.\n# As a result, if you want to use priority queue to find the smallest number, you can use another algorithm like binary search to find the smallest number.\n\n# Example\n# Input: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Output: 1\n# Explanation: Heap queue is not the best algorithm for this problem.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in a list of integers, you can use priority queue algorithm.\n# If you want to find the smallest number in",
      -9.7421875
    ],
    [
      "# Heap Queue\n# https://www.youtube.com/watch?v=WpC6Q9mVlkU\n# http://www.programcreek.com/2012/12/leetcode-smallest-numbers-in-heap/\n# https://www.youtube.com/watch?v=nGwXpXKs0sY\n# http://www.programcreek.com/2012/12/leetcode-smallest-numbers-in-heap/\n# http://www.programcreek.com/2012/12/leetcode-smallest-numbers-in-heap/\n# http://www.programcreek.com/2012/12/leetcode-smallest-numbers-in-heap/\n# https://www.youtube.com/watch?v=fhq8M5B1sJk\n# https://www.youtube.com/watch?v=4QmMj8RVwXg\n# https://www.youtube.com/watch?v=zcx2K0bXg7o\n# https://www.youtube.com/watch?v=lJWqX6uwc8w\n# https://www.youtube.com/watch?v=3cVwZuUoWcU\n# https://www.youtube.com/watch?v=1Z7Ywz6aO4o\n\nclass Solution:\n    def smallestNumbers(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        return self.smallest(nums, 0, len(nums) - 1)\n\n    def smallest(self, nums, start, end):\n        if start == end:\n            return nums[start]\n        mid = (start + end) / 2\n        if nums[mid] > nums[end]:\n            return self.smallest(nums, start, mid)\n        elif nums[mid] < nums[end]:\n            return self.smallest(nums, mid + 1, end)\n        else:\n            return nums[start]\n\n\nif __name__ == '__main__':",
      -10.3828125
    ],
    [
      "class MinHeap(object):\n    \"\"\"\n    class MinHeap\n    \"\"\"\n    def __init__(self, array):\n        \"\"\"\n        initialize your data structure here.\n        :type array: List[int]\n        \"\"\"\n        self.array = array\n        self.heap_size = len(array)\n        self.heap_queue = [None] * (self.heap_size + 1)\n        self.heap_queue[0] = MinHeap.heap_queue[1] = self.array[0]\n        for i in range(1, self.heap_size):\n            self.heap_queue[i] = MinHeap.heap_queue[i] = MinHeap.heap_queue[2 * i - 1]\n            if self.heap_queue[i] < self.heap_queue[2 * i - 2]:\n                MinHeap.heap_queue[i] = self.heap_queue[i]\n            else:\n                MinHeap.heap_queue[i] = self.heap_queue[2 * i - 2]\n        return\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the heap.\n        :type val: int\n        :rtype: void\n        \"\"\"\n        self.heap_size += 1\n        self.heap_queue[self.heap_size] = val\n        self.heap_queue[self.heap_size] = self.heap_queue[self.heap_size]\n        i = self.heap_size\n        while i > 1:\n            if self.heap_queue[i] < self.heap_queue[i / 2]:\n                self.heap_queue[i] = self.heap_queue[i / 2]\n                i = i / 2\n            else:\n                break\n        return\n\n    def delete_min(self):\n        \"\"\"\n        Delete the root of the tree.\n        :rtype: void\n        \"\"\"\n        self.heap_size -= 1\n        if self.heap_size == 0:\n            return\n        self.heap_queue[1",
      -11.3515625
    ],
    [
      "#!/usr/bin/env python\n# coding: utf-8\n\nclass MyHeapQueue(object):\n    def __init__(self):\n        self.__heap = []\n\n    def push(self, value):\n        self.__heap.append(value)\n        heapify(self.__heap)\n\n    def pop(self):\n        if len(self.__heap) == 0:\n            raise IndexError('No elements in queue')\n        else:\n            return self.__heap.pop()\n\n    def peek(self):\n        if len(self.__heap) == 0:\n            raise IndexError('No elements in queue')\n        else:\n            return self.__heap[0]\n\n    def is_empty(self):\n        return len(self.__heap) == 0\n\n    def __len__(self):\n        return len(self.__heap)\n\n    def __str__(self):\n        return str(self.__heap)\n\n    def __repr__(self):\n        return repr(self.__heap)\n\n\ndef heapify(heap):\n    i = len(heap) - 1\n    while i >= 0:\n        # \u5982\u679c\u5df2\u7ecf\u6392\u597d\u5e8f\uff0c\u5219\u9000\u51fa\u5faa\u73af\n        if heap[i] > heap[0]:\n            break\n        # \u5982\u679c\u5df2\u7ecf\u6392\u597d\u5e8f\uff0c\u5219\u9000\u51fa\u5faa\u73af\n        elif heap[i] < heap[0]:\n            heapify(heap[:i + 1])\n            break\n        # \u5982\u679c\u5df2\u7ecf\u6392\u597d\u5e8f\uff0c\u5219\u9000\u51fa\u5faa\u73af\n        else:\n            i -= 1\n\ndef main():\n    queue = MyHeapQueue()\n    queue.push(1)\n    queue.push(3)\n    queue.push(2)\n    print queue.pop()\n    print queue.pop()\n    print queue.pop()\n    print queue.pop()\n    print queue.",
      -12.453125
    ],
    [
      "# HeapQueue\n# 1. Insert: Insert an element into the queue\n# 2. Delete: Remove the least element from the queue\n# 3. Peek: Return the least element\n# 4. Size: Return the size of the queue\n# 5. Empty: Return true if the queue is empty\n\n# heapq\n# 1. Insert: Insert an element into the queue\n# 2. Remove: Remove the least element from the queue\n# 3. Peek: Return the least element\n# 4. Empty: Return true if the queue is empty\n\n# In O(n) time, you can remove and insert the same element twice.\n# In O(n) space, you need to use two lists to store the elements and the indexes of elements in the queue.\n# In O(n) time, you can remove and insert the same element twice.\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallestRange(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n\n        heap = []\n        heapq = []\n\n        for i in range(len(nums)):\n            heapq.append((nums[i], i))\n        heapq.sort()\n\n        for i in range(len(nums)):\n            heapq.append((nums[i], i))\n        heapq.sort()\n\n        while len(heapq) > 0:\n            heapq.pop(0)\n            heapq.pop(0)\n            heapq.append((heapq[0][0], 0))\n            heapq.append((heapq[0][0], 1))\n\n        heapq.sort()\n        return heapq[0][0]",
      -13.28125
    ],
    [
      "def smallest_from_heap(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n    return min(heap)\n\n# Your SmallestFromHeap solution (in python)\n# def smallest_from_heap(nums):\n#     heap = []\n#     for num in nums:\n#         heapq.heappush(heap, num)\n#     return heapq.heappop(heap)\n\n# Your SmallestFromHeap solution (in python)\n# def smallest_from_heap(nums):\n#     heap = []\n#     for num in nums:\n#         heap.append(num)\n#     return heap[0]\n\n# Your SmallestFromHeap solution (in python)\n# def smallest_from_heap(nums):\n#     return min(heap)\n\nif __name__ == \"__main__\":\n    print(smallest_from_heap([2,3,4,5,6,7]))\n    print(smallest_from_heap([0,3,6,4,7,2,1]))\n    print(smallest_from_heap([1,2,3,4,5,6,7,8]))\n    print(smallest_from_heap([-1,-2,-3,-4,-5,-6,-7,-8]))\n    print(smallest_from_heap([-1,-2,-3,-4,-5,-6,-7,-8,-9]))\n    print(smallest_from_heap([-1,0,1,2,3,4,5,6,7,8,9]))\n    print(smallest_from_heap([-1,0,1,2,3,4,5,6,7,8,9,-10]))\n    print(smallest_from_heap([-1,0,1,2,3,4,5,6,7,8,9,-10,-11]))",
      -15.421875
    ],
    [
      "def find_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    q = []\n    heapq.heappush(q, nums[0])\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            heapq.heappop(q)\n            heapq.heappush(q, nums[i])\n    return heapq.heappop(q)\n\nif __name__ == \"__main__\":\n    assert find_min([-1, -2, 1]) == 1\n    assert find_min([-1, -2, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]) == 0\n    assert find_min([-1, -2, 0, 0, 0, 0, 0, 0, 0",
      -15.515625
    ],
    [
      "class Solution:\n    # @param nums, a list of integer\n    # @return an integer\n    def smallest(self, nums):\n        if not nums: return 0\n        heap = []\n        for num in nums:\n            heap.append((-num, num))\n        heapq.heapify(heap)\n        while heap:\n            (num, next) = heapq.heappop(heap)\n            if next < 0:\n                return num\n            heapq.heappush(heap, (next, num))\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.smallest([3,1,-1,2,-2,0]))",
      -16.140625
    ],
    [
      "class Solution(object):\n    def getSmallest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        h = heap(nums)\n        ans = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < ans:\n                ans = nums[i]\n        return ans\n\nclass heap(object):\n    def __init__(self, nums):\n        self.heap = [heap_node(n) for n in nums]\n        self.heap_size = len(nums)\n    \n    def peek(self):\n        return self.heap[0]\n    \n    def is_empty(self):\n        return self.heap_size == 0\n    \n    def insert(self, num):\n        heap_node(num).insert(self)\n    \n    def remove(self):\n        return heap_node(heap_node(self.heap[0]).pop(self)).value\n    \n    def size(self):\n        return self.heap_size\n    \n    def __iter__(self):\n        return iter(self.heap)\n\nclass heap_node(object):\n    def __init__(self, num):\n        self.value = num\n        self.child_nodes = [heap_node(n) for n in [num * 10, num * 10 + 1, num * 10 + 2]]\n        self.insert(self)\n    \n    def insert(self, heap):\n        heap.insert(self.value)\n        if self.child_nodes[0].is_empty():\n            self.child_nodes[1].insert(self.child_nodes[0].peek())\n        if self.child_nodes[1].is_empty():\n            self.child_nodes[2].insert(self.child_nodes[1].peek())\n    \n    def peek(self):\n        return self.value\n    \n    def is_empty(self):\n        return self.child_nodes",
      -16.25
    ],
    [
      "class Solution(object):\n    def findMin(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        heap = []\n        for i in range(len(arr)):\n            heapq.heappush(heap, arr[i])\n        return heap[0]\n\n    def findMin_1(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return 0\n        min_heap = []\n        for i in range(len(arr)):\n            min_heap.append(arr[i])\n            while len(min_heap) > 1 and min_heap[0] > min_heap[1]:\n                min_heap[0], min_heap[1] = min_heap[1], min_heap[0]\n                heapq.heapify(min_heap)\n        return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    print Solution().findMin([1, 2, 3, 4])",
      -16.734375
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n        return heap[0]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.findMin([1, 2, 3, 4, 5])\n    print sol.findMin([1, 2, 3, 4, 5, 6])\n    print sol.findMin([1, 2, 3, 4, 5, 6, 7])\n    print sol.findMin([1, 2, 3, 4, 5, 6, 7, 8])\n    print sol.findMin([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    print sol.findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])",
      -16.84375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def minHeap(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        heap = []\n        for i in range(len(arr)):\n            heapq.heappush(heap, TreeNode(arr[i]))\n        res = arr[0]\n        for i in range(1, len(arr)):\n            if heapq.heappop(heap) > arr[i]:\n                res = arr[i]\n        return res\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [",
      -16.84375
    ],
    [
      "def find_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    heap = [(n, i) for i, n in enumerate(nums)]\n    heapq.heapify(heap)\n    while len(heap) > 1:\n        # swap the minimum element in heap with the last element in heap\n        min_heap, last_heap = heap[0], heap[-1]\n        if last_heap[0] < min_heap[0]:\n            heapq.heapreplace(heap, (last_heap[0], last_heap[1]))\n        else:\n            heapq.heappop(heap)\n    return heap[0][1]\n\n\n# Your FindMin function should return the minimum.\n# If there is no minimum, return -1\n#\n# Note:\n# You may assume that the list is sorted in ascending order.\n#\n# Follow up:\n# Could you solve it with constant space complexity?\n#\n# Companies\n# Amazon\n# Related Topics\n# Heap\n# Similar Questions\n# Smallest Multiple",
      -18.0
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}