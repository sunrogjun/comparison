{
  "problem": {
    "task_id": "MBPP/174",
    "prompt": "Write a function to group a sequence of key-value pairs into a dictionary of lists.",
    "canonical_solution": "def group_keyvalue(l):\r\n    result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result",
    "test_list": [
      "assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}",
      "assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}",
      "assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}"
    ],
    "challenge_test_list": [],
    "problem_id": 163
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    \"\"\"\n    @param: a list of key-value pairs\n    @return: a dictionary of lists\n    \"\"\"\n    def groupBy(self, kvs):\n        d = {}\n        for k, v in kvs:\n            if k not in d:\n                d[k] = []\n            d[k].append(v)\n        return d\n\nclass Solution:\n    \"\"\"\n    @param: a list of key-value pairs\n    @return: a dictionary of lists\n    \"\"\"\n    def groupBy(self, kvs):\n        d = {}\n        for k, v in kvs:\n            if k not in d:\n                d[k] = []\n            d[k].append(v)\n        return d\n\nclass Solution:\n    \"\"\"\n    @param: a list of key-value pairs\n    @return: a dictionary of lists\n    \"\"\"\n    def groupBy(self, kvs):\n        d = {}\n        for k, v in kvs:\n            if k not in d:\n                d[k] = []\n            d[k].append(v)\n        return d",
      9.046875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def groupByUnique(self, root: TreeNode) -> Dict[int, List[int]]:\n        res = {}\n        def dfs(node):\n            if node is None:\n                return\n            if node.val not in res:\n                res[node.val] = []\n            res[node.val].append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return res",
      1.833984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '<Pair %r, %r>' % (self.x, self.y)\n\nclass Solution(object):\n    def groupThem(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        d = defaultdict(list)\n        for p in pairs:\n            d[p.y].append(p.x)\n        return [list(v) for v in d.values()]",
      1.56640625
    ],
    [
      "import collections\nimport collections.abc\n\n\nclass MyList(collections.abc.Mapping):\n    def __init__(self, values):\n        self.__dict__['_list'] = values\n\n    def __getitem__(self, key):\n        return self._list[key]\n\n    def __iter__(self):\n        return iter(self._list)\n\n    def __len__(self):\n        return len(self._list)\n\n\ndef group_values(values):\n    if isinstance(values, collections.abc.Mapping):\n        return MyList(values.items())\n    else:\n        return MyList(values)\n\n\ndef main():\n    values = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}\n    mylist = group_values(values)\n    print(list(mylist))\n\n\nif __name__ == '__main__':\n    main()",
      1.439453125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def groupThem(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if root is None:\n            return []\n        ret = []\n        curr = root\n        while curr is not None:\n            if curr.left is not None:\n                ret.append([curr.left.val, curr.left])\n                curr = curr.left\n            else:\n                ret.append([curr.val, curr])\n                curr = curr.right\n        return ret\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    tree = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    print(sol.groupThem(tree))",
      1.21484375
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/discuss/136400/Python-C-Solution-using-dictionary-and-list\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def groupTheWords(self, root: TreeNode) -> List[List[str]]:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[str]]\n        \"\"\"\n        if root is None:\n            return []\n\n        result = []\n        ans = []\n        stack = []\n        stack.append((root, 0))\n        while stack:\n            node, level = stack.pop()\n            if node is None:\n                result.append(ans)\n                ans = []\n                continue\n            if level == 0:\n                ans.append(node.val)\n                stack.append((node.left, level + 1))\n                stack.append((node.right, level + 1))\n            else:\n                stack.append((node.left, level - 1))\n                stack.append((node.right, level - 1))\n\n        result.append(ans)\n        return result\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    root.left = TreeNode(8, TreeNode(9), TreeNode(10))\n    root.right = TreeNode(11, TreeNode(12), TreeNode(13))\n    s = Solution()\n    print(s.groupTheWords(root))",
      1.0419921875
    ],
    [
      "import collections\n\n# https://leetcode.com/problems/group-the-words-by-length/discuss/240465/Python-C%2B%2B-O(NlogN)-Java-O(N)-Time-Easy\nclass Solution:\n    # @param {List<String>} words\n    # @return {Map<Integer, List<String>>}\n    def groupTheWords(self, words):\n        d = collections.defaultdict(list)\n        for w in words:\n            d[len(w)].append(w)\n        return d\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.groupTheWords([\"Hello\", \"world\", \"world\", \"world\"]))",
      0.9775390625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not pairs:\n            return []\n        result = [[] for _ in range(len(pairs))]\n        for i, pair in enumerate(pairs):\n            result[i].append(pair.x)\n            result[pair.y].append(pair.x)\n        return result",
      0.90869140625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def groupThem(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(node, cur_dict, cur_list):\n            if not node:\n                return\n            cur_dict[node.val] = cur_list\n            cur_list.append(node.val)\n            dfs(node.left, cur_dict, cur_list)\n            dfs(node.right, cur_dict, cur_list)\n            cur_list.pop()\n        cur_dict = {}\n        cur_list = []\n        dfs(root, cur_dict, cur_list)\n        return cur_dict.values()",
      0.80712890625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def groupBy(self, pairs, key):\n        \"\"\"\n        :type pairs: List[Pair]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(pairs) == 0:\n            return []\n        else:\n            groups = {}\n            for pair in pairs:\n                key = pair.key\n                if key not in groups:\n                    groups[key] = []\n                groups[key].append(pair)\n            result = []\n            for key in groups:\n                result.append(groups[key])\n            return result",
      0.0235748291015625
    ],
    [
      "#!/usr/bin/python\n\n# @param {integer} n\n# @return {dictionary}\ndef group(n):\n    d = {}\n    for i in xrange(n):\n        if i not in d:\n            d[i] = []\n        d[i].append(i)\n    return d\n\ndef test():\n    assert group(3) == {1: [1], 2: [2, 1], 3: [3, 2, 1]}\n\nif __name__ == \"__main__\":\n    test()",
      -0.423095703125
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List]\n        \"\"\"\n        d = {}\n        for pair in pairs:\n            if pair.key in d:\n                d[pair.key].append(pair)\n            else:\n                d[pair.key] = [pair]\n        result = []\n        for key in d:\n            result.append(d[key])\n        return result\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    pairs = [Pair(1, 1), Pair(1, 2), Pair(1, 3), Pair(2, 1), Pair(2, 2), Pair(2, 3), Pair(3, 1), Pair(3, 2), Pair(3, 3)]\n    print(sol.group(pairs))",
      -0.44775390625
    ],
    [
      "class Solution(object):\n    def groupBy(self, key, dict):\n        \"\"\"\n        :type key: List[str]\n        :type dict: Dict[str, List[str]]\n        :rtype: List[Dict[str, List[str]]]\n        \"\"\"\n        d = {}\n        for k, v in dict.items():\n            if key[0] not in d:\n                d[key[0]] = [v]\n            else:\n                d[key[0]].append(v)\n        for k, v in d.items():\n            d[k] = sorted(v)\n        return d.values()\n\n\nif __name__ == \"__main__\":\n    assert Solution().groupBy([\"a\", \"b\", \"c\"], {\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"7\", \"8\", \"9\"]}) == [[{\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"7\", \"8\", \"9\"]}], [{\"a\": [\"7\", \"8\", \"9\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"1\", \"2\", \"3\"]}]]\n    assert Solution().groupBy([\"a\", \"b\", \"c\"], {\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"7\", \"8\", \"9\"]}) == [[{\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"7\", \"8\", \"9\"]}], [{\"a\": [\"7\", \"8\", \"9\"], \"b\": [\"4\", \"5\", \"6\"], \"c\": [\"1\", \"2\", \"3\"]}]]",
      -0.5068359375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        dic = {}\n        for p in pairs:\n            if p.x in dic:\n                dic[p.x].append(p.y)\n            else:\n                dic[p.x] = [p.y]\n        for k in dic:\n            res.append(dic[k])\n        return res",
      -0.78564453125
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def groupByUniqueKeys(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[Pair]]\n        \"\"\"\n        # if not pairs:\n        #     return []\n\n        d = defaultdict(list)\n        for pair in pairs:\n            d[pair.key].append(pair)\n\n        result = []\n        for key in d:\n            result.append(d[key])\n\n        return result",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def groupBy(self, nums, key):\n        \"\"\"\n        :type nums: List[int]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = [[] for i in range(key)]\n        for i in range(len(nums)):\n            res[nums[i] % key].append(nums[i])\n        return res",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def groupThem(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums = sorted(nums)\n        key = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i]!= key:\n                result.append([key, []])\n                key = nums[i]\n            result[-1][1].append(nums[i])\n        return result",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def group_into_dictionary(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: dict\n        \"\"\"\n        dic = {}\n        for word in words:\n            if word not in dic:\n                dic[word] = []\n            dic[word].append(word)\n        return dic",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def groupThem(self, nums):\n        n = len(nums)\n        if n == 0:\n            return []\n        res = [[]]\n        for i in range(n):\n            if i == 0:\n                res[0].append(nums[i])\n                continue\n            if res[i-1][-1] == nums[i]:\n                res[i].append(res[i-1][-1])\n            else:\n                res[i].append(nums[i])\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 1, 2, 2, 3]\n    print(sol.groupThem(nums))",
      -0.85693359375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def groupThem(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if root is None:\n            return []\n        elif root.left is None and root.right is None:\n            return [[root.val]]\n        else:\n            result = []\n            stack = [root]\n            while stack:\n                curr = stack.pop()\n                if curr.left is not None:\n                    stack.append(curr.left)\n                if curr.right is not None:\n                    stack.append(curr.right)\n                result.append([curr.val])\n            return result",
      -0.85693359375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List]\n        \"\"\"\n        if not pairs:\n            return []\n\n        # [1]\n        dic = {}\n        for pair in pairs:\n            dic.setdefault(pair.x, []).append(pair)\n\n        # [2]\n        result = []\n        for x in dic:\n            result.append(dic[x])\n\n        return result",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def groupBy(self, items, key):\n        \"\"\"\n        :type items: List[Tuple[int, int]]\n        :type key: int\n        :rtype: List[Dict[int, List[int]]]\n        \"\"\"\n        dic = {}\n        for i, v in items:\n            if key not in dic:\n                dic[key] = []\n            dic[key].append(i)\n        return dic.values()",
      -0.85791015625
    ],
    [
      "def group_by_key(items):\n    \"\"\"\n    :type items: List[Tuple[str, str]]\n    :rtype: Dict[str, List[Tuple[str, str]]]\n    \"\"\"\n    d = {}\n    for item in items:\n        k = item[0]\n        if k not in d:\n            d[k] = []\n        d[k].append(item)\n    return d",
      -0.85791015625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def groupBy(self, key, dict):\n        \"\"\"\n        :type key: List[int]\n        :type dict: Dict[int, List[Pair]]\n        :rtype: Dict[int, List[Pair]]\n        \"\"\"\n        result = {}\n        for item in dict:\n            if key in item:\n                if item not in result:\n                    result[item[key]] = []\n                result[item[key]].append(item)\n            else:\n                if item not in result:\n                    result[item[key]] = []\n                result[item[key]].append(item)\n        return result\n\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def groupNum(self, nums):\n        # write your code here\n        result = []\n        count = {}\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        for num in count:\n            result.append([num, count[num]])\n        return result",
      -0.8583984375
    ],
    [
      "import collections\n\n# Your Codec class should subclass the dict class\nclass Codec:\n\n    def __init__(self, dict):\n        self.dict = dict\n\n    def serialize(self):\n        return self.dict\n\n    def deserialize(self, data):\n        self.dict = data\n\n    def encode(self, obj):\n        return obj\n\n    def decode(self, obj):\n        return obj\n\nclass Solution(Codec):\n\n    def serialize(self, obj):\n        if isinstance(obj, collections.Mapping):\n            return {k: self.encode(v) for k, v in obj.items()}\n        elif isinstance(obj, collections.Iterable):\n            return [self.encode(v) for v in obj]\n        else:\n            return obj\n\n    def deserialize(self, data):\n        if isinstance(data, dict):\n            return {self.decode(k): self.decode(v) for k, v in data.items()}\n        elif isinstance(data, list):\n            return [self.decode(v) for v in data]\n        else:\n            return data\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec(some_list_of_dicts)\n# codec.serialize(some_list_of_dicts)\n# codec.deserialize(codec.serialize(some_list_of_dicts))\n# codec.decode(codec.serialize(some_list_of_dicts))",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        dicts = []\n        for pair in pairs:\n            key = pair.key\n            value = pair.value\n            if key not in dicts:\n                dicts.append([key, [value]])\n            else:\n                dicts[-1][1].append(value)\n        return dicts",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\n# class Pair(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        dic = {}\n        for pair in pairs:\n            if pair.x not in dic:\n                dic[pair.x] = []\n            dic[pair.x].append(pair.y)\n        for key, values in dic.items():\n            res.append(values)\n        return res",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def groupThem(self, kvp):\n        \"\"\"\n        :type kvp: List[Tuple[str, str]]\n        :rtype: Dict[str, List[Tuple[str, str]]]\n        \"\"\"\n        d = {}\n        for k, v in kvp:\n            if k not in d:\n                d[k] = []\n            d[k].append((k, v))\n        return d\n\n    def groupThem_2(self, kvp):\n        \"\"\"\n        :type kvp: List[Tuple[str, str]]\n        :rtype: Dict[str, List[Tuple[str, str]]]\n        \"\"\"\n        d = {}\n        for k, v in kvp:\n            if k not in d:\n                d[k] = [v]\n            else:\n                d[k].append(v)\n        return d",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def groupBy(self, nums, key):\n        \"\"\"\n        :type nums: List[int]\n        :type key: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            k = key[i]\n            if d.has_key(k):\n                d[k].append(nums[i])\n            else:\n                d[k] = [nums[i]]\n        return d.values()\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 1, 2, 3]\n    key = [1, 2]\n    print Solution().groupBy(nums, key)",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def groupThem(self, root: TreeNode, k: int) -> List[List[int]]:\n        if not root:\n            return []\n        res = []\n        curr = [root]\n        while curr:\n            node = curr.pop(0)\n            if node.left and len(curr) == k:\n                curr.append(node.left)\n            if node.right and len(curr) == k:\n                curr.append(node.right)\n            if len(curr) == k:\n                res.append(list(map(lambda x: x.val, curr)))\n                curr = []\n        return res",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {string[]} pairs\n    # @return {Map}\n    def groupBy(self, pairs):\n        # create a map\n        result = {}\n        for pair in pairs:\n            # split the pair into key and value\n            k, v = pair.split(\":\")\n            # get the list of the key\n            if k not in result:\n                result[k] = []\n            # append the value to the list of the key\n            result[k].append(v)\n        # return the map\n        return result\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    pairs = [\"k1:v1\", \"k2:v2\", \"k3:v3\", \"k4:v4\"]\n    result = solution.groupBy(pairs)\n    print result\n    print \"---\"\n    pairs = [\"k1:v1\", \"k2:v2\"]\n    result = solution.groupBy(pairs)\n    print result",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/discuss/151209/Python-with-recursion-and-stack\n\nclass Solution(object):\n    def groupByLength(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        dic = {}\n        for s in strs:\n            l = len(s)\n            if l not in dic:\n                dic[l] = []\n            dic[l].append(s)\n        return dic.values()\n\n\nif __name__ == '__main__':\n    so = Solution()\n    strs = [\"a\", \"bbb\", \"cc\", \"dddd\", \"eee\"]\n    print(so.groupByLength(strs))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def groupThem(self, kvs):\n        \"\"\"\n        :type kvs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        kv_dict = {}\n        for kv in kvs:\n            kv = kv.split('=')\n            if kv[0] not in kv_dict:\n                kv_dict[kv[0]] = []\n            kv_dict[kv[0]].append(kv[1])\n        return kv_dict.values()\n\ns = Solution()\nkvs = [\"key1=value1\", \"key2=value2\", \"key3=value3\", \"key4=value4\", \"key5=value5\"]\nkvs_result = s.groupThem(kvs)\nprint(kvs_result)",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\n# class KeyValuePair(object):\n#     def __init__(self, key, value):\n#         self.key = key\n#         self.value = value\n#         self.next = None\n\nclass Solution(object):\n    def groupBy(self, key, pairs):\n        \"\"\"\n        :type key: str\n        :type pairs: List[KeyValuePair]\n        :rtype: Dict[str, List[KeyValuePair]]\n        \"\"\"\n        dic = {}\n        for pair in pairs:\n            if pair.key == key:\n                if pair.value not in dic:\n                    dic[pair.value] = []\n                dic[pair.value].append(pair)\n            else:\n                if pair.value in dic:\n                    dic[pair.value].append(pair)\n        return dic",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def groupThem(self, nums):\n        res = []\n        # initialize res as empty list\n        for i in range(len(nums)):\n            res.append([])\n        \n        for i in range(len(nums)):\n            res[i].append(nums[i])\n            \n        for i in range(len(nums)):\n            # if there is a key with same value, put the key into res[i]\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    res[i].append(nums[j])\n                    # remove nums[j] from nums\n                    nums[j] = nums[len(nums)-1]\n                    nums[len(nums)-1] = None\n                    break\n        return res",
      -0.8583984375
    ],
    [
      "import collections\nclass Solution(object):\n    def groupThem(self, kvs):\n        \"\"\"\n        :type kvs: List[tuple]\n        :rtype: List[List[str]]\n        \"\"\"\n        kvs.sort()\n        result = collections.defaultdict(list)\n        for (k,v) in kvs:\n            result[k].append(v)\n        return result.values()",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        d = {}\n        for pair in pairs:\n            if pair.key in d:\n                d[pair.key].append(pair.value)\n            else:\n                d[pair.key] = [pair.value]\n        for key, value_list in d.iteritems():\n            result.append(value_list)\n        return result",
      -0.8583984375
    ],
    [
      "def group_pairs(pairs):\n    result = {}\n    for key, value in pairs:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n\n    return result\n\nclass Solution:\n    def groupThePeople(self, people: List[Tuple[str, int]]) -> List[List[int]]:\n        people_dict = group_pairs(people)\n        result = []\n        for key, value in people_dict.items():\n            result.append(value)\n\n        return result",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = [[] for _ in range(len(pairs))]\n        for i in range(len(pairs)):\n            res[i].append(pairs[i].x)\n        for i in range(len(pairs)):\n            for j in range(i+1, len(pairs)):\n                if pairs[i].x == pairs[j].x:\n                    res[i].append(pairs[j].y)\n        return res",
      -0.8583984375
    ],
    [
      "import collections\n\n\nclass Solution(object):\n\n    def group_into_list(self, kvs):\n        \"\"\"\n        :type kvs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        kv_dict = collections.defaultdict(list)\n        for kv in kvs:\n            key, value = kv.split(\":\", 1)\n            kv_dict[key].append(value)\n        return [kv_dict[key] for key in sorted(kv_dict.keys())]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    kvs = [\"a:1\", \"b:2\", \"a:3\", \"a:4\", \"c:6\", \"b:5\", \"a:7\", \"a:8\", \"a:9\", \"b:10\"]\n    result = sol.group_into_list(kvs)\n    print(result)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def group(self, items):\n        \"\"\"\n        :type items: List[Tuple[str, str]]\n        :rtype: List[Dict[str, List[str]]]\n        \"\"\"\n        if not items:\n            return []\n        \n        res = []\n        dic = {}\n        for item in items:\n            key = item[0]\n            val = item[1]\n            if key not in dic:\n                dic[key] = []\n            dic[key].append(val)\n        \n        for key, value in dic.iteritems():\n            res.append({key: value})\n        return res",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} pairs\n    # @return {integer[][]}\n    def groupThem(self, pairs):\n        d = defaultdict(list)\n        for k, v in pairs:\n            d[k].append(v)\n        return d.values()",
      -0.8583984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        dic = {}\n        for pair in pairs:\n            if pair.x in dic:\n                dic[pair.x].append(pair.y)\n            else:\n                dic[pair.x] = [pair.y]\n        for key in dic:\n            ret.append(dic[key])\n        return ret",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def groupThem(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [[root.val]]\n        lists = []\n        stack = [root]\n        while stack:\n            top = stack.pop()\n            if not top.left:\n                lists.append([top.val])\n                stack.append(top.right)\n            else:\n                stack.append(top.left)\n                stack.append(top.right)\n        return lists",
      -0.85888671875
    ],
    [
      "def group_by(lst, key):\n    dic = {}\n    for item in lst:\n        if key in dic:\n            dic[key].append(item)\n        else:\n            dic[key] = [item]\n    return dic\n\ndef main():\n    lst = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]\n    print group_by(lst, 'key')\n    \nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "import collections\n\nclass Solution(object):\n    def groupBy(self, nums, key):\n        \"\"\"\n        :type nums: List[int]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        groups = collections.defaultdict(list)\n        for num in nums:\n            groups[num % key].append(num)\n        return groups.values()\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.groupBy([1, 2, 3, 1, 2, 3], 2))",
      -0.85888671875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution:\n    def groupBy(self, kvs: List[Pair]) -> Dict[str, List[Pair]]:\n        dic = {}\n        for kv in kvs:\n            if kv.key not in dic:\n                dic[kv.key] = []\n            dic[kv.key].append(kv)\n        return dic",
      -0.86083984375
    ],
    [
      "import collections\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def groupThem(self, nums):\n        def to_list(num):\n            return [num] if num!= -1 else []\n\n        groups = collections.defaultdict(list)\n        for i, n in enumerate(nums):\n            groups[n].append(to_list(i))\n        return groups.values()",
      -1.333984375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def groupThem(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        key = {}\n        for pair in pairs:\n            key[pair.x] = key.get(pair.x, [])\n            key[pair.x].append(pair.y)\n        for key_value in key.values():\n            result.append(key_value)\n        return result\n\n\nif __name__ == \"__main__\":\n    pairs = [Pair(1, 2), Pair(1, 3), Pair(2, 3), Pair(3, 4)]\n    print Solution().groupThem(pairs)",
      -1.462890625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"{} -> {}\".format(self.x, self.y)\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not pairs:\n            return []\n\n        result = []\n        curr = []\n        for pair in pairs:\n            curr.append(pair)\n            if len(curr) == 2:\n                result.append(curr)\n                curr = []\n        if len(curr) > 0:\n            result.append(curr)\n\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    pairs = [Pair(1,2), Pair(1,3), Pair(2,4)]\n    result = s.group(pairs)\n    print(result)",
      -1.6708984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\nclass Solution:\n    def groupByUnique(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(root):\n            if root is None:\n                return []\n            if root.left is None and root.right is None:\n                return [root.val]\n            if root.left is None:\n                return [root.val] + dfs(root.right)\n            if root.right is None:\n                return dfs(root.left) + [root.val]\n            return dfs(root.left) + dfs(root.right) + [root.val]\n        return dfs(root)",
      -1.7529296875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def groupByUnique(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        # return [ [ [x], [y] ] for x, y in pairs ]\n        dic = {}\n        for pair in pairs:\n            key = pair.x\n            if key not in dic:\n                dic[key] = []\n            dic[key].append(pair)\n        return dic.values()\n\nif __name__ == \"__main__\":\n    pairs = [ Pair(1, 2), Pair(1, 3), Pair(2, 3), Pair(1, 4), Pair(2, 4), Pair(3, 4) ]\n    solution = Solution()\n    result = solution.groupByUnique(pairs)\n    print(result)",
      -1.9853515625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def groupThePeople(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        if not root:\n            return res\n\n        self.group(root, res, [])\n        return res\n\n    def group(self, root, res, group):\n        if not root:\n            return\n\n        if root.left:\n            self.group(root.left, res, group + [root.val])\n        if root.right:\n            self.group(root.right, res, group + [root.val])\n\n        group.append(root.val)",
      -1.9921875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution:\n    def groupThem(self, input: List[Pair]) -> Dict[str, List[str]]:\n        d = defaultdict(list)\n        for p in input:\n            d[p.x].append(p.y)\n        return d\n\n    def groupThem2(self, input: List[Pair]) -> Dict[str, List[str]]:\n        d = defaultdict(list)\n        for p in input:\n            d[p.x].append(p.y)\n        return d\n\n    def groupThem3(self, input: List[Pair]) -> Dict[str, List[str]]:\n        d = defaultdict(list)\n        for p in input:\n            d[p.x].append(p.y)\n        return d\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    input = [Pair(1,2), Pair(2,3), Pair(3,4)]\n    print(sol.groupThem(input))\n    input = [Pair(1,2), Pair(2,3), Pair(3,4), Pair(1,2)]\n    print(sol.groupThem(input))\n    input = [Pair(1,2), Pair(2,3), Pair(3,4), Pair(1,2), Pair(2,3)]\n    print(sol.groupThem(input))\n    input = [Pair(1,2), Pair(2,3), Pair(3,4), Pair(1,2), Pair(2,3), Pair(3,4)]\n    print(sol.groupThem(input))\n    input = [Pair(1,2), Pair(2,3), Pair(3,4), Pair(1,2), Pair(2,3), Pair(3,4), Pair(1,2), Pair(2,3)]\n    print(sol.groupThem(input))\n    input = [Pair(1,2), Pair(2,3",
      -2.205078125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def groupThem(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.recur(root, res)\n        return res\n\n    def recur(self, root, res):\n        if root is None:\n            return\n        if root.left is None and root.right is None:\n            res.append([root.val])\n        else:\n            if root.left is not None:\n                self.recur(root.left, res)\n            if root.right is not None:\n                self.recur(root.right, res)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.left.left.right = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.right.right.right = TreeNode(8)\n    print(s.groupThem(root))",
      -2.23046875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        for pair in pairs:\n            res.append([])\n            while pair.x in res[-1]:\n                res[-1].append(pair.x)\n                pair = pairs.pop(0)\n            res[-1].append(pair.x)\n            while pair.y in res[-1]:\n                res[-1].append(pair.y)\n                pair = pairs.pop(0)\n            res[-1].append(pair.y)\n        return res\n\n\na = Solution()\n\npairs = [\n    Pair(1, 1),\n    Pair(1, 2),\n    Pair(2, 3),\n    Pair(3, 1),\n    Pair(3, 2),\n    Pair(3, 3),\n]\n\nprint(a.group(pairs))",
      -2.240234375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def groupThem(self, root: TreeNode) -> List[Dict[int, List[int]]]:\n        if not root:\n            return []\n        result = []\n        stack = [root]\n        while stack:\n            curr = stack.pop()\n            if curr:\n                if curr.left:\n                    stack.append(curr.left)\n                if curr.right:\n                    stack.append(curr.right)\n        return result",
      -2.24609375
    ],
    [
      "# Definition for a key-value pair.\n# class Pair(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def groupThem(self, input):\n        \"\"\"\n        :type input: List[Pair]\n        :rtype: List[List[str]]\n        \"\"\"\n        # Sort the input pairs.\n        input.sort(key=lambda pair: pair.x)\n\n        # Map the input pairs to lists of keys.\n        mapper = {}\n        for pair in input:\n            if pair.x in mapper:\n                mapper[pair.x].append(pair.y)\n            else:\n                mapper[pair.x] = [pair.y]\n\n        # Create a list of lists of keys.\n        result = []\n        for key, value in mapper.items():\n            result.append(list(value))\n\n        return result",
      -2.24609375
    ],
    [
      "# https://oj.leetcode.com/problems/group-the-words-by-length/\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom common.tree_node import TreeNode\n\nclass Solution:\n    # @param root, a tree node\n    # @return a dictionary\n    def groupByLength(self, root):\n        d = {}\n        self.group(root, d)\n        return d\n    \n    def group(self, root, d):\n        if root is None:\n            return\n        \n        key = root.val\n        if key in d:\n            d[key].append(root)\n        else:\n            d[key] = [root]\n        \n        self.group(root.left, d)\n        self.group(root.right, d)",
      -2.310546875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def groupBy(self, pairs, key):\n        \"\"\"\n        :type pairs: List[Pair]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not pairs:\n            return []\n        dict = {}\n        for pair in pairs:\n            if key in dict:\n                dict[key].append(pair)\n            else:\n                dict[key] = [pair]\n        return dict.values()\n\n\nif __name__ == \"__main__\":\n    pairs = [Pair(1, 2), Pair(1, 3), Pair(2, 1), Pair(2, 3), Pair(3, 1), Pair(3, 2)]\n    print Solution().groupBy(pairs, 1)\n    print Solution().groupBy(pairs, 2)\n    print Solution().groupBy(pairs, 3)",
      -2.328125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def group(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        self.group_recursive(root, [], result)\n        return result\n\n    def group_recursive(self, root, path, result):\n        if not root:\n            return\n        path.append(root.val)\n        if root.left and root.right:\n            self.group_recursive(root.left, path, result)\n            self.group_recursive(root.right, path, result)\n        elif root.left:\n            self.group_recursive(root.left, path, result)\n        elif root.right:\n            self.group_recursive(root.right, path, result)\n        else:\n            result.append(path)\n            path = []\n            self.group_recursive(root.right, path, result)",
      -2.44140625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def groupBy(self, pairs, key):\n        \"\"\"\n        :type pairs: List[Pair]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not pairs:\n            return []\n\n        res = []\n        map_ = {}\n        for pair in pairs:\n            if key not in map_:\n                map_[key] = []\n            map_[key].append(pair)\n        for key in map_:\n            res.append(map_[key])\n\n        return res",
      -2.6484375
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/discuss/173368/Java-O(N)-dp-solution\n\nclass Solution(object):\n    def groupByLength(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        ret = [[] for _ in range(len(words))]\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if len(words[i]) > len(words[j]):\n                    ret[i].append(words[j])\n                    ret[j].append(words[i])\n        return ret",
      -3.16015625
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = [[] for _ in xrange(10)]\n        for pair in pairs:\n            ret[pair.y].append(pair.x)\n        return ret\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.group([Pair(1,2), Pair(2,3), Pair(3,4), Pair(4,5), Pair(5,6)])\n    print s.group([Pair(1,2), Pair(2,3), Pair(3,4), Pair(4,5), Pair(5,6), Pair(6,7), Pair(7,8)])\n    print s.group([Pair(1,2), Pair(2,3), Pair(3,4), Pair(4,5), Pair(5,6), Pair(6,7), Pair(7,8), Pair(8,9)])",
      -3.22265625
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def groupTheWords(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        if root is None:\n            return result\n        stack = []\n        stack.append([root])\n        while stack:\n            node = stack.pop()\n            if node[0].left is not None:\n                stack.append([node[0].left])\n            if node[0].right is not None:\n                stack.append([node[0].right])\n            result.append([node[0].val])\n        return result",
      -3.419921875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\n    def __repr__(self):\n        return '<Pair: %s: %s>' % (self.key, self.value)\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        # Use a hash map to store the list of lists.\n        res = [[] for _ in range(len(pairs))]\n        # Use a dictionary to store the list of lists.\n        d = {}\n        for pair in pairs:\n            key = pair.key\n            # If the list of lists of the same key is not in the dictionary,\n            # create a new list of lists and add the pair to it.\n            if key not in d:\n                res[key] = [pair]\n                d[key] = [pair]\n            # Otherwise, add the pair to the list of lists of the same key.\n            else:\n                d[key].append(pair)\n        # Find the lists of lists of the same key, and append the pairs to them.\n        for key in d:\n            if len(d[key]) > 1:\n                res[key].extend(d[key])\n        return res",
      -3.52734375
    ],
    [
      "class Solution(object):\n    def groupBy(self, nums, key):\n        \"\"\"\n        :type nums: List[int]\n        :type key: int\n        :rtype: Dict[int, List[int]]\n        \"\"\"\n        d = {}\n        for i in range(len(nums)):\n            if nums[i] in d:\n                d[nums[i]].append(key)\n            else:\n                d[nums[i]] = [key]\n        return d\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1,2,1,3,5]\n    print(s.groupBy(nums, 1))\n    nums = [1,1,1,2,3]\n    print(s.groupBy(nums, 1))\n    nums = [1,1,2,2,2,3,3,4,4]\n    print(s.groupBy(nums, 1))\n    nums = [1,2,3,4,5]\n    print(s.groupBy(nums, 1))",
      -3.560546875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[][]}\n    def groupThem(self, nums, k):\n        if not nums or not k:\n            return []\n        res = [[]]\n        for i in xrange(len(nums)):\n            if len(res) == k:\n                res.append([])\n            res[len(res) - 1].append(nums[i])\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.groupThem([1,2,3,4,5,6], 2)",
      -3.90625
    ],
    [
      "import collections\n\n\nclass Solution:\n    def groupBy(self, key, dict):\n        \"\"\"\n        :type key: List[int]\n        :type dict: List[List[int]]\n        :rtype: List[Dict[int, List[int]]]\n        \"\"\"\n        result = collections.defaultdict(list)\n        for i in range(len(key)):\n            result[key[i]].append(dict[i])\n        return result.values()\n\n\nif __name__ == \"__main__\":\n    cases = [([1, 2, 3], [[1, 2, 3]]), ([1, 2, 3, 4], [[1, 2], [3, 4]]), ([1, 2, 3], [[1, 2]]), ([1, 2], [[1]]), ([], [])]\n    s = Solution()\n    for case in cases:\n        result = s.groupBy(*case[0])\n        print(result)",
      -4.2578125
    ],
    [
      "from collections import defaultdict\n\nclass Solution(object):\n    def groupThem(self, items):\n        \"\"\"\n        :type items: List[Tuple[int, int]]\n        :rtype: List[List[Tuple[int, int]]]\n        \"\"\"\n        # convert to a map\n        map = defaultdict(list)\n        for k, v in items:\n            map[k].append(v)\n        # build the list\n        result = []\n        for key, values in map.items():\n            result.append(values)\n        return result\n\nif __name__ == '__main__':\n    sol = Solution()\n    items = [\n        (1, 10),\n        (1, 20),\n        (2, 10),\n        (2, 20),\n        (3, 30),\n        (4, 40),\n    ]\n    print(sol.groupThem(items))",
      -4.26171875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\nclass Solution:\n    def groupThePeople(self, root: TreeNode, groupSize: int) -> List[List[int]]:\n        def dfs(node, groups, level):\n            if node is None:\n                return\n            if node.val in groups:\n                groups[node.val].append(node.val)\n            else:\n                groups[node.val] = [node.val]\n            dfs(node.left, groups, level + 1)\n            dfs(node.right, groups, level + 1)\n\n        groups = {}\n        dfs(root, groups, 0)\n        return groups.values()",
      -4.34765625
    ],
    [
      "import collections\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(some_list_of_dicts))\n\nclass Codec:\n\n    def __init__(self):\n        self.dict_list = collections.defaultdict(list)\n\n    def encode(self, dict_list):\n        \"\"\"\n        Encodes a list of key-value pairs to a single string.\n        :param dict_list: a list of key-value pairs\n        :return: a single string\n        \"\"\"\n        result = ''\n        for key, value in dict_list:\n            result += str(key) + ':' + str(value) +''\n        return result\n\n    def decode(self, string):\n        \"\"\"\n        Decodes a string and returns a list of key-value pairs.\n        :param string: a string of the form \"k1:v1 k2:v2 k3:v3...\"\n        :return: a list of key-value pairs\n        \"\"\"\n        result = []\n        for line in string.split(' '):\n            if not line:\n                continue\n            key, value = line.split(':')\n            result.append((key, value))\n        return result\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(some_list_of_dicts))\n\nclass Codec2:\n\n    def __init__(self):\n        self.dict_list = collections.defaultdict(list)\n\n    def encode(self, dict_list):\n        \"\"\"\n        Encodes a list of key-value pairs to a single string.\n        :param dict_list: a list of key-value pairs\n        :return: a single string\n        \"\"\"\n        result = ''\n        for key, value in dict_list:\n            result += str(key) + ':' + str(value) +''\n        return result\n\n    def decode(self, string):\n        \"\"\"\n        Decodes a string and returns a list of key-value pairs.\n        :param string: a string of the form \"k1:v1 k2:v2 k3",
      -4.375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def groupThem(self, root: TreeNode) -> List[List[int]]:\n        if not root: return []\n        \n        result = []\n        stack = []\n        stack.append(root)\n        \n        while stack:\n            node = stack.pop()\n            \n            if node:\n                result.append(node)\n                if node.left: stack.append(node.left)\n                if node.right: stack.append(node.right)\n                \n        return result",
      -4.38671875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def groupBy(self, pairs, key):\n        \"\"\"\n        :type pairs: List[Pair]\n        :type key: int\n        :rtype: List[List[Pair]]\n        \"\"\"\n        d = {}\n        for p in pairs:\n            if p.key not in d:\n                d[p.key] = []\n            d[p.key].append(p)\n        result = []\n        for k in d:\n            result.append([d[k][0]])\n            for p in d[k][1:]:\n                result[-1].append(p)\n        return result\n\nif __name__ == \"__main__\":\n    pairs = [Pair(1, 1), Pair(1, 2), Pair(2, 1), Pair(2, 2)]\n    print Solution().groupBy(pairs, 1)\n    print Solution().groupBy(pairs, 2)",
      -4.71484375
    ],
    [
      "class Solution(object):\n    def groupThem(self, kvs):\n        \"\"\"\n        :type kvs: List[Tuple[str, int]]\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        for k, v in kvs:\n            if result and result[-1][0] == k:\n                result[-1][1].append(v)\n            else:\n                result.append([k, [v]])\n        return result\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    kvs = [(\"a\", 1), (\"b\", 2), (\"c\", 3), (\"a\", 4), (\"b\", 5)]\n    print sol.groupThem(kvs)\n    kvs = [(\"a\", 1), (\"b\", 2), (\"c\", 3), (\"a\", 4), (\"b\", 5), (\"c\", 6)]\n    print sol.groupThem(kvs)\n    kvs = [(\"a\", 1), (\"b\", 2), (\"c\", 3), (\"a\", 4), (\"b\", 5), (\"c\", 6), (\"a\", 7)]\n    print sol.groupThem(kvs)",
      -4.765625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[][]}\n    def groupThem(self, nums):\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in range(len(nums)):\n            if i == 0:\n                res.append([])\n            if nums[i] == nums[i-1]:\n                res[-1].append(nums[i])\n            else:\n                res[-1].append(nums[i])\n                res.append([])\n        return res\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [1,2,3]\n    nums = [1,1,1,1]\n    nums = [1,1,2,3]\n    nums = [1,2,2,2,2]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,1,1,1,1,1,1,1,1,1]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8]\n    n",
      -5.18359375
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/discuss/203601/C-Python-Solution-with-explanation\n\n# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def groupByLength(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[Pair]]\n        \"\"\"\n        dic = {}\n        for pair in pairs:\n            if pair.key not in dic:\n                dic[pair.key] = []\n            dic[pair.key].append(pair)\n        result = []\n        for key, val in dic.items():\n            result.append([pair for pair in val])\n        return result\n\n\nif __name__ == \"__main__\":\n    pairs = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)]\n    sol = Solution()\n    print(sol.groupByLength(pairs))",
      -5.4921875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        # use a map to store the key-value pair.\n        # store the list of keys in the map.\n        result = {}\n        for pair in pairs:\n            if pair.x not in result:\n                result[pair.x] = []\n            result[pair.x].append(pair.y)\n        return result.values()\n\nif __name__ == \"__main__\":\n    pairs = [Pair(1, 2), Pair(1, 3), Pair(2, 3), Pair(2, 4), Pair(3, 5)]\n    print Solution().group(pairs)",
      -6.08203125
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def groupByLength(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # list of list, each of which is a list of tree nodes\n        groups = [[] for _ in range(20)]\n        \n        if root is None:\n            return groups\n        \n        cur_group = []\n        cur_group.append(root)\n        \n        while cur_group:\n            # append current node to current group\n            cur_group.append(cur_group[-1].left)\n            cur_group.append(cur_group[-1].right)\n            \n            # remove current node from current group\n            cur_group.pop()\n            \n            # check if there is more nodes in current group\n            if cur_group[-1].right is not None:\n                cur_group[-1].right.left = cur_group[-1].left\n                cur_group[-1].right.right = cur_group[-1].right.right\n            \n            # append current group to corresponding group\n            groups[cur_group[-1].val].append(cur_group[-1])\n            \n        return groups\n\nif __name__ == \"__main__\":\n    tree = TreeNode(1)\n    tree.left = TreeNode(2)\n    tree.right = TreeNode(3)\n    tree.left.left = TreeNode(4)\n    tree.left.right = TreeNode(5)\n    tree.right.left = TreeNode(6)\n    tree.right.right = TreeNode(7)\n    \n    s = Solution()\n    print s.groupByLength(tree)",
      -6.16015625
    ],
    [
      "class Solution(object):\n    def group(self, items):\n        \"\"\"\n        :type items: List[Tuple[str, int]]\n        :rtype: List[List[Tuple[str, int]]]\n        \"\"\"\n        groups = []\n        for item in items:\n            key, value = item\n            if not groups:\n                groups.append([item])\n            else:\n                groups[-1].append(item)\n        return groups\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    # print(sol.group([('a', 1), ('b', 2)]))\n    # print(sol.group([('a', 1), ('b', 2), ('c', 3)]))\n    # print(sol.group([('a', 1), ('b', 2)]))\n    # print(sol.group([('a', 1), ('b', 2), ('c', 3), ('d', 4)]))\n    print(sol.group([('a', 1), ('b', 2), ('c', 3)]))\n    print(sol.group([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]))\n    print(sol.group([('a', 1), ('b', 2), ('c', 3)]))\n    print(sol.group([('a', 1), ('b', 2), ('c', 3), ('d', 4)]))",
      -6.71875
    ],
    [
      "class Solution(object):\n    def groupThem(self, input):\n        \"\"\"\n        :type input: str\n        :rtype: List[List[str]]\n        \"\"\"\n        result = [['', '']]\n        for i in range(len(input)):\n            if input[i] == ',':\n                if result[-1][0]!= '':\n                    result[-1][1] += input[i]\n                else:\n                    result[-1][0] += input[i]\n                continue\n            if result[-1][0] == '':\n                result[-1][0] = input[i]\n                result[-1][1] = ''\n            else:\n                result[-1][1] += input[i]\n        return result",
      -7.265625
    ],
    [
      "import collections\nimport random\nimport unittest\n\n\nclass Solution(object):\n    \"\"\"\n    @param pairs: The pairs of a key-value pair.\n    @return: A list of lists of key-value pairs.\n    \"\"\"\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        d = collections.defaultdict(list)\n        for pair in pairs:\n            d[pair[0]].append(pair[1])\n        for key in d.keys():\n            result.append(sorted(d[key]))\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/group-the-people-into-groups/solution/\n# Approach 1: Sort\n# Complexity Analysis\n# Time Complexity: O(N)\n# Space Complexity: O(N)\n#\n# # Approach 2: Use Set\n# Complexity Analysis\n# Time Complexity: O(N)\n# Space Complexity: O(N)\n\n# 9ms 100%\nclass Solution {\n    public List<List<String>> groupThePeopleIntoGroups(List<List<String>> persons) {\n        List<List<String>> res = new ArrayList<>();\n        if (persons == null || persons.size() == 0) return res;\n\n        Set<String> set = new HashSet<>();\n        for (List<String> person : persons) {\n            set.add(person.get(0));\n        }\n        List<String> list = new ArrayList<>(set);\n        Collections.sort(list);\n        for (String s : list) {\n            res.add(new ArrayList<>(Collections.singletonList(s)));\n        }\n\n        return res;\n    }\n}\n\n# Approach 3: Generate random groups\n# Complexity Analysis\n# Time",
      -7.99609375
    ],
    [
      "# https://leetcode.com/problems/group-the-people-into-groups/description/\n# To do\n# 1. sort the list of lists\n# 2. sort the list of keys\n# 3. group by the sorted keys\n# 4. group by the sorted lists\n# 5. sort the list of lists\n# 6. group by the sorted keys\n# 7. sort the list of lists\n# 8. group by the sorted lists\n# 9. sort the list of lists\n# 10. group by the sorted lists\n# 11. sort the list of lists\n# 12. group by the sorted lists\n# 13. sort the list of lists\n# 14. group by the sorted lists\n# 15. sort the list of lists\n# 16. group by the sorted lists\n# 17. sort the list of lists\n# 18. group by the sorted lists\n# 19. sort the list of lists\n# 20. group by the sorted lists\n# 21. sort the list of lists\n# 22. group by the sorted lists\n# 23. sort the list of lists\n# 24. group by the sorted lists\n# 25. sort the list of lists\n# 26. group by the sorted lists\n# 27. sort the list of lists\n# 28. group by the sorted lists\n# 29. sort the list of lists\n# 30. group by the sorted lists\n# 31. sort the list of lists\n# 32. group by the sorted lists\n# 33. sort the list of lists\n# 34. group by the sorted lists\n# 35. sort the list of lists\n# 36. group by the sorted lists\n# 37. sort the list of lists\n# 38. group by the sorted lists\n# 39. sort the list of lists\n# 40. group by the sorted lists\n# 41. sort the list of lists\n# 42. group by the sorted lists\n# 43. sort the list of lists\n# 44. group by the sorted lists\n# 45. sort the list of lists\n# 46. group by the sorted lists\n# 47. sort the list of lists\n# 48. group by the sorted lists\n# 49. sort the list of lists\n# 50. group by the sorted lists\n# 51. sort the list of lists\n# 52. group by the sorted lists\n# 53. sort the list of lists\n# 54. group by",
      -8.078125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n    def __str__(self):\n        return str(self.val) +'' + str(self.left) +'' + str(self.right) +'' + str(self.next)\n\n\nclass Solution:\n    def groupThem(self, head):\n        \"\"\"\n        :type head: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        dic = {}\n        p = head\n        while p:\n            if p.left:\n                dic.setdefault(p.left.val, []).append(p)\n            if p.right:\n                dic.setdefault(p.right.val, []).append(p)\n            p = p.next\n\n        return dic.values()\n\n\nif __name__ == '__main__':\n    s = Solution()\n    t = TreeNode(val=1, left=TreeNode(val=2, left=TreeNode(val=3, next=TreeNode(val=4, left=TreeNode(val=5), right=TreeNode(val=6, next=TreeNode(val=7, left=TreeNode(val=8), right=TreeNode(val=9))))), right=TreeNode(val=10, right=TreeNode(val=11, next=TreeNode(val=12, left=TreeNode(val=13, next=TreeNode(val=14))))), next=TreeNode(val=15, left=TreeNode(val=16, left=TreeNode(val=17, next=TreeNode(val=18, left=TreeNode(val=19, next=TreeNode(val=20, left=TreeNode(val=21, next=TreeNode(val=22, left=TreeNode(val=23, next=TreeNode(val=24))))), right=TreeNode(val=25, right=TreeNode(val=26, next=TreeNode(val=27, left=TreeNode",
      -8.5546875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not pairs:\n            return []\n\n        # sort\n        pairs.sort(key=lambda pair: pair.value)\n\n        # group\n        result = []\n        stack = []\n        key = None\n        for pair in pairs:\n            if pair.key!= key:\n                if key:\n                    result[-1].append(key)\n                key = pair.key\n                stack.append([])\n            stack[-1].append(pair.value)\n        result[-1].append(key)\n\n        return result\n\n\nif __name__ == '__main__':\n    pairs = [\n        Pair('a', 1),\n        Pair('b', 2),\n        Pair('c', 3),\n        Pair('d', 4),\n        Pair('e', 5),\n        Pair('f', 6),\n        Pair('g', 7),\n        Pair('h', 8),\n        Pair('i', 9),\n        Pair('j', 10),\n        Pair('k', 11),\n        Pair('l', 12),\n        Pair('m', 13),\n        Pair('n', 14),\n        Pair('o', 15),\n        Pair('p', 16),\n        Pair('q', 17),\n        Pair('r', 18),\n        Pair('s', 19),\n        Pair('t', 20),\n        Pair('u', 21),\n        Pair('v', 22),\n        Pair('w', 23),\n        Pair('x', 24),\n        Pair('y', 25),\n        Pair('z', 26),\n    ]\n\n    solution = Solution()\n    result = solution.group(pairs)\n    for item in result:\n        print(item)",
      -9.3046875
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n    def __repr__(self):\n        return \"{}:{}\".format(self.key, self.value)\n\nclass Solution(object):\n    def groupBy(self, pairs, key):\n        \"\"\"\n        :type pairs: List[Pair]\n        :type key: int\n        :rtype: List[List[int]]\n        \"\"\"\n        # key_map[key] = [key_map[key] if key_map[key] else [], []]\n        key_map = {}\n        for pair in pairs:\n            if key_map.has_key(pair.key):\n                key_map[pair.key].append(pair)\n            else:\n                key_map[pair.key] = [pair]\n        result = []\n        for key in key_map.keys():\n            if key_map[key]:\n                result.append(key_map[key])\n        return result\n\n# Note:\n# pair.key is a list of keys\n# pair.value is a list of values\n# key_map[key] is a list of pairs with the same key\n\n# Note:\n# A single key can appear in multiple pairs.\n# A pair can appear in multiple keys.\n\n# Note:\n# Pair is a pair of key and value.\n# key is a list of keys.\n# value is a list of values.\n\n# Note:\n# The key type must be int.\n# The value type must be int.",
      -9.609375
    ],
    [
      "class Solution(object):\n    def group_into_list(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = list(nums)\n        if not nums:\n            return []\n        n = len(nums)\n        dp = [[0] * n for _ in xrange(n)]\n        #dp[0][0] = nums[0]\n        for i in xrange(1, n):\n            dp[i][i] = nums[i]\n        for i in xrange(n - 1, -1, -1):\n            for j in xrange(i + 1, n):\n                dp[i][j] = max(nums[i] + dp[i + 1][j], dp[i + 1][j])\n        return dp[0]\n\n\nif __name__ == '__main__':\n    nums = [1, 3, 2, 3]\n    print Solution().group_into_list(nums)\n    nums = [1, 3, 2, 3, 5, 7, 6, 5, 4, 7, 7, 9, 6, 5, 4, 5, 6, 5, 6, 7, 7, 7, 7, 7, 7, 7, 8, 7, 9, 7, 7, 8, 7, 9, 7, 8, 8, 7, 7, 7, 7, 7, 7, 7, 8, 7, 9, 7, 8, 7, 8, 8, 7, 7, 7, 7, 8, 8, 7, 8, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,",
      -10.578125
    ],
    [
      "# https://leetcode.com/problems/group-the-people-into-groups/discuss/136597/Java-Python-Solutions-2-3-4-and-7-solutions\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def groupThePeople(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n\n        res = []\n        self.group(root, res)\n        return res\n\n    def group(self, root, res):\n        if root is None:\n            return\n        \n        if root.left is None and root.right is None:\n            res.append([root.val])\n        else:\n            if root.left is not None:\n                self.group(root.left, res)\n            if root.right is not None:\n                self.group(root.right, res)",
      -11.46875
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-frequency/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def groupByUnique(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        # base case\n        if not root.left and not root.right:\n            return [root.val]\n        # recurse\n        res = []\n        def dfs(node):\n            if not node:\n                return\n            if not node.left and not node.right:\n                res.append([node.val])\n            else:\n                res.append([])\n                dfs(node.left)\n                dfs(node.right)\n        dfs(root)\n        return res",
      -11.921875
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-length/\n\n# Definition for a `key-value pair`:\n# class KeyValuePair(object):\n#     def __init__(self, key, value):\n#         self.key = key\n#         self.value = value\n#\n#     def __repr__(self):\n#         return '<KeyValuePair: %s -> %s>' % (self.key, self.value)\n#\n#     def __eq__(self, other):\n#         return self.key == other.key and self.value == other.value\n#\n#     def __hash__(self):\n#         return hash(self.key) ^ hash(self.value)\nclass Solution(object):\n    def groupByLength(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[KeyValuePair]]\n        \"\"\"\n        # TODO\n        return []\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = []\n# param_2 = obj.groupByLength(param_1)",
      -12.859375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def groupThem(self, root: TreeNode) -> List[List[int]]:\n        # level_list = []\n        # group_list = []\n        # cur_level = []\n        # level_list.append(cur_level)\n        # cur_level.append(root)\n        # while cur_level:\n        #     cur_level = cur_level[1:]\n        #     if cur_level:\n        #         cur_level = [cur_level[0]] + cur_level[1:]\n        #     else:\n        #         cur_level = []\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         group_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list.append(cur_level)\n        #         cur_level = []\n        #         cur_level.append(root)\n        #         level_list",
      -13.0078125
    ],
    [
      "# Definition for a key-value pair.\nclass Pair:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Pair({}, {})\".format(self.x, self.y)\n\nclass Solution(object):\n    def group(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        curr_list = []\n        for pair in pairs:\n            if len(curr_list) == 0:\n                curr_list.append(pair)\n            else:\n                if curr_list[-1] > pair:\n                    curr_list.append(pair)\n                else:\n                    if curr_list[-1] < pair:\n                        result.append(curr_list)\n                        curr_list = [pair]\n                    else:\n                        curr_list.append(pair)\n        result.append(curr_list)\n        return result\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    pairs = [\n        Pair(1, 2),\n        Pair(3, 4),\n        Pair(5, 6),\n        Pair(7, 8),\n        Pair(9, 10),\n        Pair(11, 12),\n        Pair(13, 14),\n        Pair(15, 16),\n        Pair(17, 18),\n        Pair(19, 20),\n        Pair(21, 22),\n        Pair(23, 24),\n        Pair(25, 26),\n        Pair(27, 28),\n        Pair(29, 30),\n        Pair(31, 32),\n        Pair(33, 34),\n        Pair(35, 36),\n        Pair(37, 38),\n        Pair(39, 40),\n        Pair(41, 42),\n        Pair(43, 44),\n        Pair(45, 46),\n        Pair(47, 48),\n        Pair(49, 50),\n        Pair",
      -13.171875
    ],
    [
      "# Example\n# dict_of_lists = group_sequence_of_key_value_pairs([\"key1\", \"val1\", \"key2\", \"val2\", \"key3\", \"val3\", \"key4\", \"val4\", \"key5\", \"val5\", \"key6\", \"val6\"])\n# dict_of_lists = group_sequence_of_key_value_pairs([\"key1\", \"val1\", \"key2\", \"val2\", \"key3\", \"val3\", \"key4\", \"val4\", \"key5\", \"val5\", \"key6\", \"val6\", \"key7\", \"val7\", \"key8\", \"val8\", \"key9\", \"val9\"])\n# dict_of_lists = group_sequence_of_key_value_pairs([\"key1\", \"val1\", \"key2\", \"val2\", \"key3\", \"val3\", \"key4\", \"val4\", \"key5\", \"val5\", \"key6\", \"val6\", \"key7\", \"val7\", \"key8\", \"val8\", \"key9\", \"val9\", \"key10\", \"val10\"])\n\n# Output\n# {\n#     'key1': ['val1', 'val2', 'val3', 'val4'],\n#     'key2': ['val2', 'val3', 'val4', 'val5'],\n#     'key3': ['val3', 'val4', 'val5', 'val6'],\n#     'key4': ['val4', 'val5', 'val6', 'val7'],\n#     'key5': ['val5', 'val6', 'val7', 'val8'],\n#     'key6': ['val6', 'val7', 'val8', 'val9'],\n#     'key7': ['val7', 'val8', 'val9', 'val10'],\n#     'key8': ['val8', 'val9', 'val10'],\n#     'key9': ['val9', 'val10']\n# }\n\n# Assumptions\n# 1) The input is a list of key-value pairs separated by a space\n# 2) The key",
      -13.6015625
    ],
    [
      "# https://oj.leetcode.com/problems/group-the-words-by-count/\n# tags: easy, array, hash-table\n\n\"\"\"\nThe key of the dictionary is a string, and the value is a list of strings.\n\nThe input is represented by a list of strings.\n\nExample 1:\nInput: [\"this\", \"is\", \"an\", \"example\", \"of\", \"strings\"]\nOutput:\n{\n  \"this\": [\u201cthis\u201d, \u201cis\u201d, \u201can\u201d, \u201cexample\u201d, \u201cof\u201d, \u201cstrings\u201d],\n  \"is\": [\u201cis\u201d],\n  \"an\": [\u201can\u201d],\n  \"example\": [\u201cexample\u201d],\n  \"of\": [\u201cof\u201d],\n  \"strings\": [\u201cstrings\u201d]\n}\nExplanation:\n\"this\" is in the first group with 3 elements (key, value, list).\n\"is\" is in the second group with 2 elements (key, value).\n\"an\" is in the third group with 2 elements (key, value).\n\"example\" is in the fourth group with 3 elements (key, value, list).\n\"of\" is in the fifth group with 2 elements (key, value).\n\"strings\" is in the sixth group with 3 elements (key, value, list).\nThe order of groups doesn't matter.\n\"\"\"\n\nclass Solution:\n    # @param {string[]} strs\n    # @return {dict}\n    def groupTheWords(self, strs):\n        if not strs:\n            return dict()\n        d = dict()\n        s = set()\n        for s in strs:\n            s = s.split()\n            for w in s:\n                d[w] = d.get(w, []) + [s]\n        for k in d:\n            d[k] = list(set(d[k]))\n        return d\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    strs = [\"this\", \"is\", \"an\", \"example\", \"of\", \"strings\"]\n    d = sol.groupTheWords(strs)",
      -13.8671875
    ],
    [
      "# https://leetcode.com/problems/group-the-words-by-frequency/discuss/96660/Python-solution-with-explanation-using-recursion-and-iterators\n# https://leetcode.com/problems/group-the-words-by-frequency/discuss/96660/Python-solution-with-explanation-using-recursion-and-iterators\n# https://leetcode.com/problems/group-the-words-by-frequency/discuss/96660/Python-solution-with-explanation-using-recursion-and-iterators\n# https://leetcode.com/problems/group-the-words-by-frequency/discuss/96660/Python-solution-with-explanation-using-recursion-and-iterators\n\nclass Solution(object):\n    def groupTheWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        def group(word, cnt, list_):\n            if cnt == 0:\n                list_.append(word)\n            else:\n                for i in range(1, cnt):\n                    word = word +'' + str(i)\n                    list_.append(word)\n                    group(word, cnt - i, list_)\n                    word = word[:-1]\n\n        list_ = []\n        for word in words:\n            group(word, len(word), list_)\n        return list_\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.groupTheWords(['The', 'quick', 'brown', 'fox', 'jumped', 'over', 'the', 'lazy', 'dog']))",
      -14.0625
    ],
    [
      "import collections\n\n# Your function should return a dictionary mapping from the key to a list of values.\n# The value list is in the same order as the given keys.\n#\n# Example:\n#\n# Input:\n# [[1,2,3], [4,5,6], [7,8,9]], \"even\"\n# [[1,2,3], [5,6,7], [9,10,11]]\n#\n# Output:\n# {'even': [[4, 5, 6], [7, 8, 9], [10, 11, 12]]}\n#\n# Explanation:\n# The values of the first key-value pair is 4, 5, 6.\n# The values of the second key-value pair is 7, 8, 9.\n# The values of the third key-value pair is 10, 11, 12.\n# The key 'even' is given.\n#\n# Note:\n#\n# The value of each key is a non-empty list of integers.\n# The length of the given key-value pairs is in the range [1, 100].\n# The values of the given key-value pairs are in the range [-1000, 1000].\n# The key and value of each key-value pair is a string with length in the range [1, 50].\n\n# TLE\nclass Solution:\n    def groupThem(self, arr: List[List[int]]) -> dict:\n        res = collections.defaultdict(list)\n        for key, val in arr:\n            res[key].append(val)\n        return res\n\n    # TLE\n    def groupThem(self, arr: List[List[int]]) -> dict:\n        res = collections.defaultdict(list)\n        for key, val in arr:\n            res[key].append(val)\n        return res",
      -14.296875
    ],
    [
      "# https://www.hackerrank.com/challenges/keyvalue/problem\n# http://www.geeksforgeeks.org/group-a-dictionary-into-a-dictionary/\n\ndef group(dictionary):\n    dictionary = sorted(dictionary.items())\n    dictionary = group_list(dictionary)\n    return dictionary\n\n\ndef group_list(dictionary):\n    dictionary = group_list_iterative(dictionary)\n    dictionary = group_list_recursive(dictionary)\n    return dictionary\n\n\ndef group_list_iterative(dictionary):\n    dictionary = dict(dictionary)\n    for key in dictionary.keys():\n        if dictionary[key] is None:\n            dictionary[key] = []\n    for key in dictionary.keys():\n        if dictionary[key] is not None:\n            dictionary[key].append(dictionary[key][0])\n            del dictionary[key][0]\n    return dictionary\n\n\ndef group_list_recursive(dictionary):\n    dictionary = dict(dictionary)\n    for key in dictionary.keys():\n        if dictionary[key] is None:\n            dictionary[key] = []\n    for key in dictionary.keys():\n        if dictionary[key] is not None:\n            dictionary[key].append(dictionary[key][0])\n            del dictionary[key][0]\n            group_list_recursive(dictionary[key])\n    return dictionary\n\n\nif __name__ == '__main__':\n    dictionary = {'key1': [1, 2, 3], 'key2': [4, 5, 6], 'key3': [7, 8, 9]}\n    print(group(dictionary))",
      -14.4375
    ],
    [
      "# Definition for a key-value pair.\nclass Pair(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return \"Pair({0},{1})\".format(self.x, self.y)\n\nclass Solution(object):\n    def groupThem(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        def rec(cur, res, cur_key, res_key):\n            if cur_key not in res:\n                res[cur_key] = []\n            res[cur_key].append(cur)\n            if cur_key not in cur:\n                cur_key = cur[0]\n            else:\n                cur_key = cur_key\n            res_key = res_key + '->' + cur_key\n            rec(cur[1:], res, cur_key, res_key)\n        for p in pairs:\n            rec(p, ans, p.x, p.y)\n        return ans\n\n    def groupThem2(self, pairs):\n        \"\"\"\n        :type pairs: List[Pair]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        def rec(cur, res):\n            if not res:\n                res.append(cur)\n            else:\n                for p in res:\n                    if p.x == cur.x:\n                        p.y = cur.y\n                        break\n            rec(cur[1:], res)\n        for p in pairs:\n            rec(p, res)\n        return res",
      -15.6484375
    ],
    [
      "class Solution(object):\n    def groupBy(self, key, dict):\n        \"\"\"\n        :type key: List[int]\n        :type dict: Dict[List[int], List[int]]\n        :rtype: List[Dict[str, List[int]]]\n        \"\"\"\n        def dfs(k, v, l):\n            if len(l) == 0:\n                dict[k] = [v]\n            else:\n                k1, k2 = l[0], l[1]\n                if key[k1] == key[k2]:\n                    l[1] = l[1] + l[2]\n                    l[2] = []\n                    l[0] = k1\n                else:\n                    l[0] = k2\n                    l[1] = l[1] + l[2]\n                    l[2] = []\n                dfs(k1, v, l)\n                dfs(k2, v, l)\n\n        dict = {}\n        dfs(0, [], [[0, -1]])\n        return dict.values()\n\n\nif __name__ == '__main__':\n    assert Solution().groupBy([1, 2, 1, 3], {1: [1, 2, 3], 2: [1, 2, 3]}) == [[1, [1, 2, 3]], [2, [1, 2, 3]]]\n    assert Solution().groupBy([1, 2, 1, 3], {}) == [[1, [1, 2, 3]]]",
      -17.0
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def groupThem(self, root: TreeNode) -> List[Dict[str, List[int]]]:\n        ans = []\n        stack = []\n        if not root:\n            return ans\n        stack.append((root.val, [root.val]))\n        while stack:\n            val, list_ = stack.pop()\n            if not root.left:\n                ans.append({val: list_})\n            else:\n                stack.append((root.left.val, list_ + [root.left.val]))\n            if not root.right:\n                ans.append({val: list_})\n            else:\n                stack.append((root.right.val, list_ + [root.right.val]))\n        return ans\n\n\n# TESTS\nfor tree, expected in [\n    (None, {}),\n    ([[1, 2], [3, 4]], {1: [[1, 2]], 3: [[3, 4]]}),\n    ([[1, 2], [3, 4]], {1: [[1, 2]]}),\n    ([[1, 2], [3, 4]], {2: [[3, 4]]}),\n    ([[1, 2], [3, 4]], {3: [[1, 2]]}),\n    ([[1, 2], [3, 4]], {1: [[1, 2]]}),\n    ([[1, 2], [3, 4]], {2: [[1, 2]]}),\n]:\n    sol = Solution()\n    actual = sol.groupThem(tree)\n    assert actual == expected",
      -18.046875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}