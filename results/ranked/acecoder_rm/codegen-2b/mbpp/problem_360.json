{
  "problem": {
    "task_id": "MBPP/371",
    "prompt": "Write a function to find the smallest missing element in a sorted array.",
    "canonical_solution": "def smallest_missing(A, left_element, right_element):\r\n    if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)",
    "test_list": [
      "assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7",
      "assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3",
      "assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0"
    ],
    "challenge_test_list": [],
    "problem_id": 360
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def findMissing(self, num):\n        if len(num) == 0:\n            return 0\n        if len(num) == 1:\n            return num[0] - 1\n\n        max_index = len(num) - 1\n        min_index = 0\n        for i in range(len(num)):\n            if i == max_index:\n                if num[i] > num[min_index]:\n                    min_index = i\n            elif i < min_index:\n                max_index = i\n        return num[min_index] + 1",
      3.927734375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.findMissing_2(nums)\n\n    def findMissing_2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in xrange(1, n):\n            if nums[i] < nums[i-1]:\n                return i\n        return n\n\n    def findMissing_3(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in xrange(1, n):\n            while nums[i] < nums[i-1]:\n                nums[i] = nums[i] + 1\n            if nums[i]!= i+1:\n                return i\n        return n\n\n    def findMissing_4(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in xrange(1, n):\n            while nums[i] < nums[i-1]:\n                nums[i] = nums[i] + 1\n            if nums[i]!= i+1:\n                return i\n        return n\n\n\nif __name__ == \"__main__\":\n    print Solution().findMissing([1, 2, 3, 4, 5])",
      3.208984375
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n        min_idx = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[min_idx]:\n                min_idx = i\n        return nums[min_idx]\n\n    def findMin_2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n        min_idx = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[min_idx]:\n                min_idx = i\n            elif nums[i] < nums[min_idx]:\n                min_idx = i\n        return nums[min_idx]",
      2.453125
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a list node\n    # @return an integer\n    def findMissing(self, head):\n        if not head:\n            return 0\n        curr = head\n        while curr:\n            curr = curr.next\n            if not curr:\n                return curr.val\n            curr = curr.next\n        return curr.val",
      1.6845703125
    ],
    [
      "class Solution:\n    # @param nums, a list of integer\n    # @return an integer\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = 0\n        while i < len(nums):\n            if nums[i]!= i+1:\n                return i+1\n            i += 1\n        return len(nums) + 1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findMissing([1, 2, 3, 4, 5]))\n    print(s.findMissing([2, 3, 4, 5, 6]))\n    print(s.findMissing([5, 6, 7, 8, 9]))\n    print(s.findMissing([5, 6, 7, 8, 9, 10]))\n    print(s.findMissing([1, 2, 3, 4, 5, 6]))\n    print(s.findMissing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
      0.9599609375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/missing-number/discuss/917/simple-java-solution-with-explanation\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if nums[0] == nums[1]:\n            return 1\n        for i in range(2, len(nums)):\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:\n                return i\n        return len(nums)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 2, 3]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4, 5]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(sol.findMissing(nums))",
      0.6796875
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            if nums[0] < nums[1]:\n                return nums[0]\n            else:\n                return nums[1]\n        if n > 2:\n            # get the middle num\n            i = n / 2\n            # check if the middle num is smaller than the last num\n            if nums[i - 1] < nums[i]:\n                # if so, then the missing element is the last num\n                return nums[i - 1]\n            # if not, then the missing element is the middle num\n            else:\n                return nums[i]\n        return 0",
      0.4833984375
    ],
    [
      "# https://leetcode.com/problems/smallest-missing-element-in-sorted-array/\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n\n        nums.append(nums[-1])\n        nums.sort()\n        for i in xrange(len(nums) - 1):\n            if nums[i] + 1!= nums[i + 1]:\n                return nums[i] + 1\n        return nums[-1] + 1",
      -0.051910400390625
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer\n    \"\"\"\n    def smallestMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n\n        n = len(nums)\n        for i in range(n):\n            if nums[i] == i:\n                continue\n            if nums[i]!= i + 1:\n                return i + 1\n        return n + 1",
      -0.76025390625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        start = 0\n        end = n - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if nums[mid] == mid:\n                start = mid + 1\n            else:\n                end = mid\n        if nums[start]!= start:\n            return start\n        else:\n            return -1",
      -0.85693359375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            if nums[i] > i:\n                return i\n            i += 1\n        return i\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findMissing([1,2,3])\n    print s.findMissing([1,3,5])\n    print s.findMissing([1,2,4,5,6])",
      -0.85693359375
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def findMissing(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                return i + 1\n        return len(nums) + 1\n\n\ndef main():\n    sol = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print(sol.findMissing(nums))\n\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMissing(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n\n        p = nums[0]\n        for i in range(1, n):\n            if nums[i] < nums[i-1]:\n                p = min(p, nums[i])\n\n        return p\n\n\nif __name__ == '__main__':\n    nums = [2,3,4]\n    print Solution().findMissing(nums)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        min_value = nums[0]\n        for value in nums:\n            if value < min_value:\n                min_value = value\n        for value in nums:\n            if value > min_value:\n                return value\n        return min_value\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,2,3]\n    print sol.findMissing(nums)\n    nums = [4,5,6,7]\n    print sol.findMissing(nums)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return nums[len(nums) - 1] + 1 - nums[0]",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        i = 0\n        while i < len(nums) and nums[i]!= i:\n            i += 1\n        return i + 1",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i]!= i+1:\n                return i+1\n        return len(nums)",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMissing(self, nums):\n        n = len(nums)\n        for i in xrange(1, n):\n            if nums[i]!= nums[i-1]:\n                return i\n        return n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMissing([1, 2, 3])",
      -0.85791015625
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findMissing(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        if not intervals[0].start:\n            return 1\n        start = intervals[0].start\n        end = intervals[0].end\n        for i in range(1, len(intervals)):\n            if not intervals[i].start:\n                return i + 1\n            if intervals[i].start > end:\n                end = intervals[i].end\n            else:\n                start = min(start, intervals[i].start)\n        return end + 1",
      -0.85791015625
    ],
    [
      "import math\n\n\ndef find_smallest_missing_element(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start < end:\n        mid = start + (end - start) / 2\n\n        if arr[mid] == mid:\n            return mid\n        elif arr[mid] > mid:\n            end = mid - 1\n        else:\n            start = mid + 1\n\n    return arr[start]\n\nif __name__ == '__main__':\n    arr = [2, 3, 1, 4, 5]\n\n    print(find_smallest_missing_element(arr))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in xrange(n):\n            if nums[i]!= i + 1:\n                return i + 1\n        return n + 1\n\n\nif __name__ == '__main__':\n    so = Solution()\n    print so.findMissing([1, 2, 3])\n    print so.findMissing([1, 2, 4])\n    print so.findMissing([1, 2, 3, 5])\n    print so.findMissing([-1, -2, -3, -4])\n    print so.findMissing([-1, -2, -3, -4, -5])",
      -0.85791015625
    ],
    [
      "from typing import List\n\ndef find_smallest_missing_element(arr: List[int]) -> int:\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    smallest = arr[0]\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n    return smallest + 1",
      -0.85791015625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\n\nclass Solution:\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if nums[mid] > nums[end]:\n                end = mid\n            elif nums[mid] < nums[end]:\n                start = mid + 1\n            else:\n                return mid\n        return nums[start]",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n\n        left, right = 0, n-1\n        while left < right:\n            mid = (left + right) / 2\n            if nums[mid] == mid:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left]!= left:\n            return left\n        return right\n\nif __name__ == \"__main__\":\n    print Solution().findMissing([1,3,5])",
      -0.85791015625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        while fast:\n            fast = fast.next\n            slow = slow.next\n        return slow.val",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/sorted-array-missing-element/problem\n\ndef find_missing_element(arr):\n    \"\"\"\n    :param arr: An unsorted list of integers.\n    :return: The index of the missing element.\n    \"\"\"\n    arr = sorted(arr)\n    return arr.index(min(arr))",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def findMin(self, num):\n        if not num:\n            return None\n        min_index = 0\n        for i in xrange(len(num)):\n            if num[i] > num[min_index]:\n                min_index = i\n        return num[min_index]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMin([2, 3, 4, 5])\n    print s.findMin([1, 2, 3, 4, 5, 6, 7, 8, 9])",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/smallest-missing-element-in-sorted-array/discuss/142936/Java-Python-C#\n\nclass Solution(object):\n    def smallestMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        for i in xrange(2, n+1):\n            if nums[i-1] > nums[i]:\n                return i\n        return nums[n-1]",
      -0.8583984375
    ],
    [
      "from math import log\nfrom collections import defaultdict\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        dic = defaultdict(int)\n        for n in nums:\n            dic[n] += 1\n        for n in nums:\n            if dic[n] == 0:\n                return n\n        return -1\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3]\n    print sol.findMissing(nums)\n    nums = [1,2,3,4,5]\n    print sol.findMissing(nums)\n    nums = [1,2,3,4,5,6]\n    print sol.findMissing(nums)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] == i+1:\n                return i+1\n        return len(nums)\n\n    def findMin_2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] == i+1:\n                return i+1\n        for i in range(len(nums)-1, -1, -1):\n            if nums[i] == i+1:\n                return i+1\n        return len(nums)\n\na = Solution()\na.findMin([1,2,3,4,5])",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMissing(self, nums):\n        # write your code here\n        return self.findMissing1(nums)\n\n    def findMissing1(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        \n        m = max(nums)\n        for i in range(m+1):\n            if i not in nums:\n                return i\n        return m + 1\n\n\nif __name__ == \"__main__\":\n    print Solution().findMissing([1, 2, 3])",
      -0.8583984375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[i - 1] + 1:\n                return i\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findMissing([1, 2, 3, 4, 5, 6])\n    print s.findMissing([1, 2, 3, 4, 5, 6, 7])",
      -0.8583984375
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return nums[-1] - nums[0] + 1\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3]\n    print(sol.findMissing(nums))\n    nums = [1, 2, 3, 4, 5, 6]\n    print(sol.findMissing(nums))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i, v in enumerate(nums):\n            if v!= i:\n                nums[v] = nums[i]\n                nums[i] = i\n        for i, v in enumerate(nums):\n            if v!= i:\n                return i\n        return i\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 2, 3, 4]\n    print(Solution().findMissing(nums))",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i-1]!= 1:\n                return i\n        return len(nums)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1:\n            return 0\n        mid = len(nums) / 2\n        if nums[mid - 1] == nums[mid]:\n            return nums[mid - 1]\n        if nums[mid] == nums[mid + 1]:\n            return nums[mid]\n        return self.findMissing(nums[:mid]) + self.findMissing(nums[mid + 1:])\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print Solution().findMissing(nums)",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def find(start, end):\n            if start == end:\n                return start\n            mid = (start + end) / 2\n            if nums[mid] < nums[start] or nums[mid] < nums[end]:\n                return find(start, mid)\n            else:\n                return find(mid + 1, end)\n        \n        return find(0, len(nums) - 1)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(nums)[0] - 1\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 2, 3, 5]\n    print Solution().findMissing(nums)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in xrange(len(nums)):\n            if nums[i] > i:\n                return i\n        return len(nums)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11]\n    print Solution().findMissing(nums)",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def findMissingBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if nums[mid] > nums[end]:\n                end = mid\n            else:\n                start = mid + 1\n        return nums[start]",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param A, a list of integers\n    # @return an integer\n    def findMissing(self, A):\n        # Write your code here\n        \n        if A is None or len(A) == 0:\n            return 0\n        \n        # first index of missing element\n        i = 0\n        \n        # find the first missing element\n        while A[i]!= i+1:\n            i += 1\n        \n        # find the next missing element\n        while A[i]!= i+1:\n            i += 1\n        \n        return i",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def smallestMissing(self, root):\n        if root is None:\n            return 0\n\n        def findSmallestMissing(node):\n            if node.left is None and node.right is None:\n                return node.val\n            else:\n                return max(findSmallestMissing(node.left), findSmallestMissing(node.right))\n\n        return findSmallestMissing(root)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # write your code here\n        if not nums:\n            return 0\n        if nums[0]!= nums[-1]:\n            return 0\n        idx = 0\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[idx]:\n                idx += 1\n            if idx == i:\n                idx += 1\n        return idx",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i]!= i+1:\n                return i+1\n        return n+1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3,4,5]\n    print(sol.findMissing(nums))",
      -0.8583984375
    ],
    [
      "def smallest_missing_element(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    # base case\n    if len(arr) == 0:\n        return 0\n\n    # base case for smallest element\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) / 2\n        if arr[mid] == mid:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    # base case for smallest missing element\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) / 2\n        if arr[mid] == mid:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return arr[low]",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/smallest-missing-element-in-sorted-array/discuss/87934/Python-solution-with-detailed-explanation\n\nclass Solution(object):\n    def smallestMissingElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        for i in range(n):\n            if nums[i] < 0:\n                return i\n        return n",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) / 2\n            if nums[mid]!= mid + 1:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n\n\nif __name__ == \"__main__\":\n    print Solution().findMissing([1, 2, 3])",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param nums, a list of integer\n    # @return an integer\n    def findMissing(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if nums[0]!= 0:\n            return nums[0]\n        nums[0] = nums[n-1]\n        return self.findMissing(nums[1:])",
      -0.85888671875
    ],
    [
      "import random\n\ndef find_smallest_missing(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return arr[0]\n\n    min_val = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        elif arr[i] > min_val:\n            return min_val\n    return min_val\n\ndef main():\n    random.seed(0)\n    arr = [random.randint(1, 100) for i in range(100)]\n    print(find_smallest_missing(arr))\n    arr = [1, 5, 10, 15, 20, 25, 30, 35, 40]\n    print(find_smallest_missing(arr))\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def smallestMissing(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if head is None:\n            return 0\n        count = 0\n        cur = head\n        while cur:\n            if cur.val == count:\n                cur = cur.next\n                count += 1\n            else:\n                cur = cur.next\n        return count",
      -0.85888671875
    ],
    [
      "def find_smallest_missing(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] > nums[i+1]:\n            return i\n    return len(nums)\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print(find_smallest_missing(nums))",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1:\n            return nums[0]\n        \n        left, right = 0, len(nums)-1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid]!= mid:\n                if nums[mid] > mid:\n                    left = mid+1\n                else:\n                    right = mid-1\n            else:\n                return mid\n        return nums[left]",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # http://www.cnblogs.com/grandyang/p/4436596.html\n        # https://gist.github.com/hongyu/8296601\n        n = len(nums)\n        for i in xrange(n):\n            if nums[i] > i+1:\n                return i\n        return n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMissing([2, 3, 5, 6, 7, 8, 9])",
      -1.0712890625
    ],
    [
      "def smallest_missing_element(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    return arr[0]\n\n\n# Your SmallestMissingElement solution (in Python)\n# class Solution:\n#     def smallestMissingElement(self, arr):\n#         \"\"\"\n#         :type arr: List[int]\n#         :rtype: int\n#         \"\"\"\n#         return arr[0]",
      -1.125
    ],
    [
      "# https://leetcode.com/problems/smallest-missing-element-in-sorted-array/\n# time: O(n)\n# space: O(1)\n\nfrom collections import deque\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # for i in range(len(nums)):\n        #     if nums[i] < 0:\n        #         nums[i] += len(nums)\n        #     else:\n        #         nums[i] -= len(nums)\n        # return nums[0]\n        # nums.sort()\n        # return nums[0]\n        # nums.sort()\n        # for i in range(len(nums)):\n        #     if nums[i] < 0:\n        #         nums[i] += len(nums)\n        #     else:\n        #         nums[i] -= len(nums)\n        # return nums[0]\n        return nums[0]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, -1, 4, -2, -3]\n    print(Solution().findMissing(nums))",
      -1.142578125
    ],
    [
      "# https://leetcode.com/problems/missing-number/discuss/49500/Python-O(n)-Time-Sorting-Solution\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        # for i in xrange(n):\n        #     if nums[i] == i:\n        #         continue\n        #     if nums[i] > i:\n        #         return i - 1\n        #     else:\n        #         return i + 1\n        # return n\n        i = 0\n        while i < n:\n            if nums[i] == i:\n                i += 1\n            else:\n                return i\n        return n\n\nif __name__ == \"__main__\":\n    assert Solution().findMissing([1,2,3]) == 0\n    assert Solution().findMissing([1,2,4]) == 3\n    assert Solution().findMissing([1,2,3,4]) == 2",
      -1.33203125
    ],
    [
      "# https://www.hackerrank.com/challenges/find-the-missing-element/problem\ndef find_missing(arr):\n    \"\"\"\n    Returns the smallest missing element in a sorted array.\n    :param arr: sorted array\n    :return: smallest missing element\n    \"\"\"\n    return arr[0] if arr[0]!= None else arr[1]\n\n\nif __name__ == \"__main__\":\n    import sys\n    if (len(sys.argv) <= 1):\n        arr = list(map(int, input().split()))\n    else:\n        arr = list(map(int, sys.argv[1].split()))\n    print(find_missing(arr))",
      -1.400390625
    ],
    [
      "from collections import Counter\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        cnt = Counter(nums)\n        for i in range(len(nums)):\n            if cnt[nums[i]] == 1:\n                nums[i] = None\n            else:\n                nums[i] = i + 1\n        return None\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.findMissing([0, 1, 2, 3, 4, 5])\n    print sol.findMissing([0, 1, 3, 4, 5])\n    print sol.findMissing([1, 2, 3, 4, 5])",
      -2.087890625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallestMissingElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        l = len(nums)\n        for i in range(0, l):\n            if nums[i] == i+1:\n                nums[i] = -1\n        for i in range(0, l):\n            if nums[i] == -1:\n                return i\n        return l\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print solution.smallestMissingElement(nums)",
      -2.1953125
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # TODO: use binary search\n        low = 0\n        high = len(nums) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if nums[mid] == nums[mid - 1]:\n                return mid\n            elif nums[mid] > nums[mid - 1]:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n    def findMin1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if nums[mid] == nums[mid - 1]:\n                return mid\n            elif nums[mid] > nums[mid - 1]:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().findMin(nums))",
      -2.734375
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def findMinMissing(self, num):\n        if not num:\n            return 0\n        if not num[0]:\n            return 0\n        l = 0\n        r = len(num) - 1\n        while l < r:\n            m = (l + r) // 2\n            if num[m] == m:\n                l = m + 1\n            else:\n                r = m\n        return num[l]\n\n\nif __name__ == '__main__':\n    num = [2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17]\n    sol = Solution()\n    print(sol.findMinMissing(num))",
      -3.296875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMissing(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if head is None:\n            return 0\n        pre = None\n        cur = head\n        while cur:\n            if pre is None:\n                pre = cur\n                cur = cur.next\n            else:\n                if cur.val <= pre.val:\n                    pre = cur\n                    cur = cur.next\n                else:\n                    break\n        return cur.val if cur else 0\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(3)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\n    head.next.next.next.next.next.next.next.next.next.next",
      -3.341796875
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == mid + 1:\n                low = mid + 1\n            elif nums[mid] > mid + 1:\n                high = mid\n            else:\n                return mid + 1\n        return low + 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMissing([0, 1, 2, 3, 4, 5, 6, 7, 8])",
      -3.69140625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        head = ListNode(0)\n        cur = head\n        for i in nums:\n            cur = cur.next\n            cur.next = ListNode(i)\n        cur = head\n        while cur.next:\n            if cur.next.val!= cur.val + 1:\n                return cur.val\n            cur = cur.next\n        return cur.val",
      -3.703125
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findMissing(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        n = len(intervals)\n        if n == 0:\n            return 0\n        if n == 1:\n            return intervals[0].start\n        \n        # find the leftmost interval\n        leftmost = 0\n        for i in range(1, n):\n            if intervals[i].start < intervals[leftmost].end:\n                leftmost = i\n        \n        # find the rightmost interval\n        rightmost = n - 1\n        for i in range(n - 1, -1, -1):\n            if intervals[i].end > intervals[rightmost].start:\n                rightmost = i\n        \n        # if the rightmost interval is not the same as the leftmost one,\n        # the last missing is the rightmost one\n        if intervals[rightmost].start!= intervals[leftmost].end:\n            return intervals[rightmost].start\n        \n        # otherwise, the last missing is the leftmost one\n        return intervals[leftmost].start",
      -3.861328125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findMissingBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        mid = len(nums) / 2\n        self.findMissingBST(nums[:mid])\n        self.findMissingBST(nums[mid:])\n        return nums[mid]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findMissingBST([1,3,5,6,7,10,12,13]))\n    print(sol.findMissingBST([1,2,4,6,8]))\n    print(sol.findMissingBST([1,2,4,5,6]))\n    print(sol.findMissingBST([1,2,3,4,5]))\n    print(sol.findMissingBST([1,2,3,4,5,6,7]))",
      -3.943359375
    ],
    [
      "def smallest_missing(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return None\n    smallest = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < smallest:\n            smallest = arr[i]\n    return smallest\n\n\nif __name__ == '__main__':\n    assert smallest_missing([1, 3, 5]) == 1\n    assert smallest_missing([6, 1, 2, 3, 5]) == 3\n    assert smallest_missing([3, 1, 5, 6, 8, 7]) == 7\n    assert smallest_missing([-1, -2, -3]) == -1",
      -3.974609375
    ],
    [
      "# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=7K1b8t2fBbw\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?v=mvXA0n8BjZ4\n# https://www.youtube.com/watch?v=i8qbvB6dA0g\n# https://www.youtube.com/watch?",
      -4.08984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def getSmallestMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        elif n == 2:\n            return min(nums[0], nums[1])\n        else:\n            p = 0\n            for i in range(n):\n                if nums[i]!= nums[p]:\n                    p = i\n            return nums[p]\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 3, 5]\n    print s.getSmallestMissing(nums)\n    nums = [1, 3, 5, 6]\n    print s.getSmallestMissing(nums)\n    nums = [1, 2, 3, 4, 5, 6]\n    print s.getSmallestMissing(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    print s.getSmallestMissing(nums)",
      -4.12890625
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0] - 1\n        i = 0\n        j = n - 1\n        while i < j:\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n        if nums[i]!= nums[j]:\n            return nums[i]\n        return nums[i] - 1\n\na = Solution()\nprint(a.findMissing([2, 7, 11, 15]))",
      -4.21484375
    ],
    [
      "import os\nimport sys\nimport time\nimport random\n\nstart_time = time.time()\n\n# https://www.hackerrank.com/challenges/sorted-array-missing-element/problem\ndef smallest_missing_element(arr):\n    # Complete this function\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = low + (high - low) / 2\n        if arr[mid]!= mid + 1:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return arr[low]\n\n\nif __name__ == '__main__':\n    try:\n        f = open(os.environ['OUTPUT_PATH'], 'w')\n    except IOError:\n        exit(get_exception())\n    f.write(str(smallest_missing_element(sys.stdin.readlines())) + '\\n')\n    f.close()\n    print 'Time elapsed:'+ str(int(time.time() - start_time))",
      -4.2578125
    ],
    [
      "# https://leetcode.com/problems/find-smallest-missing-number/discuss/62428/Java-O(N)-Time-Java-Sorting-and-Pair-Sorting\n\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n        for i in range(n - 1, -1, -1):\n            if nums[i]!= i + 1:\n                return i + 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findMissing([3, 2, 1]))\n    print(s.findMissing([1, 2, 3]))\n    print(s.findMissing([1, 3, 5, 7]))\n    print(s.findMissing([5, 7, 2, 3]))\n    print(s.findMissing([4, 3, 4, 3]))\n    print(s.findMissing([3, 2, 1]))",
      -4.26171875
    ],
    [
      "def find_smallest_missing(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == mid:\n            low = mid + 1\n        elif arr[mid] < mid:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\ndef find_smallest_missing_2(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return -1\n    \n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == mid:\n            low = mid + 1\n        elif arr[mid] < mid:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_smallest_missing(arr))\n    print(find_smallest_missing_2(arr))\n    arr = [1, 2, 3, 4, 5]\n    print(find_smallest_missing(arr))\n    print(find_smallest_missing_2(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76",
      -5.2890625
    ],
    [
      "class Solution:\n    # @param nums, a list of integer\n    # @return an integer\n    def findMissing(self, nums):\n        return self.findMissing_2(nums)\n\n    def findMissing_2(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        min = 0\n        max = n - 1\n        while min < max:\n            mid = min + (max - min) / 2\n            if nums[mid] == mid + 1:\n                min = mid + 1\n            elif nums[mid] < mid + 1:\n                max = mid\n            else:\n                return mid + 1\n        return max + 1\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMissing([1, 2, 3, 4, 5])\n    print s.findMissing([1, 2, 3, 4, 5, 6])\n    print s.findMissing([])",
      -5.44921875
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i]!= i+1:\n                j = i+1\n                while j < n and nums[j]!= j+1:\n                    j += 1\n                if j == n:\n                    return i+1\n        return n+1\n\n\nif __name__ == \"__main__\":\n    nums = [2,3,4,5]\n    print Solution().findMissing(nums)",
      -5.515625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i]!= i+1:\n                return i+1\n        return n+1\n\ndef main():\n    nums = [0,1,3,5,7]\n    nums = [1,2,3,4,5,6,7]\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [1,2,3,4,5,6,7,8,9]\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    nums = [1,2,3,4,5,6,7,8,9,10,11]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,",
      -6.34375
    ],
    [
      "# https://www.hackerrank.com/challenges/sorted-array-min-missing\n# time limit: 1000 ms\n# memory limit: 64 MB\n# input:\n#   int[] nums = {1,2,3,4,5,6,7,8,9,10};\n#   int target = 4;\n# output:\n#   4\n#   4\n#   4\n#   3\n#   3\n#   3\n#   3\n#   3\n#   3\n#   2\n#   2\n#   2\n#   2\n#   2\n#   2\n#   2\n#   2\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#   1\n#",
      -6.48046875
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def smallestMissing(self, num):\n        # write your code here\n        return self.findSmallestMissing(num)\n\n    def findSmallestMissing(self, num):\n        if not num:\n            return -1\n        minIdx = 0\n        for i in range(1, len(num)):\n            if num[i] < num[minIdx]:\n                minIdx = i\n        if num[minIdx]!= num[-1]:\n            return minIdx\n        else:\n            return self.findSmallestMissing(num[:minIdx])\n\nif __name__ == '__main__':\n    assert Solution().smallestMissing([1,3,5,7,9,11,13]) == 5\n    assert Solution().smallestMissing([1,2,3,4,5,6,7,8,9,10]) == 3",
      -6.6875
    ],
    [
      "import bisect\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n\n    def findMissing(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        elif n == 2:\n            return nums[0] if nums[0] < nums[1] else nums[1]\n        else:\n            left = 0\n            right = n - 1\n            mid = (left + right) // 2\n            while left <= right:\n                if nums[mid] == mid + 1:\n                    left = mid + 1\n                elif nums[mid] < mid + 1:\n                    right = mid - 1\n                else:\n                    return mid + 1\n                mid = (left + right) // 2\n            return mid + 1\n\n\nif __name__ == \"__main__\":\n    print Solution().findMissing([0, 1, 2, 3, 4, 5, 6])",
      -6.828125
    ],
    [
      "# Time:  O(n)\n# Space: O(1)\n\n# Approach 1: Brute Force\n# Time:  O(n^2)\n# Space: O(1)\n# Approach 2: Binary Search\n# Time:  O(nlog(n))\n# Space: O(1)\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0] - 1\n        # The first element in nums is missing.\n        for i in range(0, n):\n            if nums[i] == i + 1:\n                return i + 1\n        # The last element in nums is missing.\n        for i in range(n - 1, -1, -1):\n            if nums[i] == i - 1:\n                return i - 1\n        return 0\n\n# Time:  O(nlog(n))\n# Space: O(1)\nclass Solution2(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0] - 1\n        # The first element in nums is missing.\n        for i in range(0, n):\n            if nums[i] == i + 1:\n                return i + 1\n        # The last element in nums is missing.\n        for i in range(n - 1, -1, -1):\n            if nums[i] == i - 1:\n                return i - 1\n        return 0",
      -7.27734375
    ],
    [
      "import math\n\n\ndef smallest_missing(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    return math.ceil(math.log(len(arr), 2))\n\n\nif __name__ == '__main__':\n    assert smallest_missing([1, 2, 3, 4, 5]) == 2\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7]) == 6\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8]) == 8\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 11\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 12\n    assert smallest_missing([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 13",
      -7.5
    ],
    [
      "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] > nums[j]:\n                j -= 1\n            else:\n                i += 1\n        return nums[i]\n\nif __name__ == '__main__':\n    assert Solution().findMin([1,3,5,7]) == 1\n    assert Solution().findMin([1,3,5,7,9]) == 1\n    assert Solution().findMin([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 1\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 1\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 3\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 4\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 5\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) == 6\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 7\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == 8\n    assert Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == 9",
      -7.5078125
    ],
    [
      "import unittest\nimport sys\nimport os\n\n# Directory to look for modules in\ndirectory = \"./sandbox/archive/order_of_the_magnitude\"\n\n# Add directory to the path if necessary\nif directory not in sys.path:\n    sys.path.append(directory)\n\n# Import the module\nfrom array_utils import *\n\nclass TestArrayUtils(unittest.TestCase):\n\n    def test_find_smallest_missing_element_sorted_list(self):\n        \"\"\"\n        Test the function find_smallest_missing_element_sorted_list\n        \"\"\"\n        # Create an array with elements to test\n        test_array = [1, 2, 3, 4, 5, 6]\n        # Test the function\n        self.assertEqual(find_smallest_missing_element_sorted_list(test_array), 4)\n\n    def test_find_smallest_missing_element_unsorted_list(self):\n        \"\"\"\n        Test the function find_smallest_missing_element_unsorted_list\n        \"\"\"\n        # Create an array with elements to test\n        test_array = [6, 5, 4, 3, 2, 1]\n        # Test the function\n        self.assertEqual(find_smallest_missing_element_unsorted_list(test_array), 1)\n\n    def test_find_smallest_missing_element_sorted_array(self):\n        \"\"\"\n        Test the function find_smallest_missing_element_sorted_array\n        \"\"\"\n        # Create an array with elements to test\n        test_array = [1, 2, 3, 4, 5, 6]\n        # Test the function\n        self.assertEqual(find_smallest_missing_element_sorted_array(test_array), 4)\n\n    def test_find_smallest_missing_element_unsorted_array(self):\n        \"\"\"\n        Test the function find_smallest_missing_element_unsorted_array\n        \"\"\"\n        # Create an array with elements to test\n        test_array = [6, 5, 4, 3, 2, 1]\n        # Test the function\n        self.assertEqual(find_small",
      -7.60546875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        head = ListNode(nums[0])\n        current = head\n\n        for i in range(1, len(nums)):\n            current = current.next\n            current.next = ListNode(nums[i])\n\n        current = head\n        while current.next:\n            if current.next.val > current.val:\n                current = current.next\n            else:\n                current = current.next.next\n        else:\n            return current.val\n\n        return -1\n\n\nif __name__ == '__main__':\n    assert Solution().findMissing([0, 1, 3, 4, 5]) == 2\n    assert Solution().findMissing([0, 1, 2, 3]) == 3\n    assert Solution().findMissing([]) == 0",
      -8.0703125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.append(nums[-1] + 1)\n        head = ListNode(-1)\n        head.next = ListNode(nums[0])\n        cur = head\n        for i in xrange(1, len(nums)):\n            cur = cur.next\n            cur.next = ListNode(nums[i])\n        for i in xrange(len(nums)):\n            if cur.val < 0:\n                cur = cur.next\n                cur.val = nums[i]\n            else:\n                cur = cur.next\n        for i in xrange(len(nums)):\n            if cur.val < 0:\n                break\n            cur = cur.next\n            cur.val = nums[i]\n        if cur.val < 0:\n            return -1\n        else:\n            return cur.val",
      -8.1328125
    ],
    [
      "import unittest\n\nclass Solution:\n    # @return an integer\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return nums[0] if len(nums) > 0 else -1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/missing-element/solution/\n\n# Approach 1: Sort\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 2: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 3: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 4: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 5: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 6: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 7: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 8: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 9: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 10: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n\n# Approach 11: Binary Search\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O",
      -9.109375
    ],
    [
      "__author__ = 'Danyang'\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if not nums[0]: return 0\n        return nums[0]\n\n    def findMissing2(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if nums[0]: return 0\n        return nums[0]\n\n    def findMissing3(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if not nums[0]: return 0\n        return nums[0]\n\n    def findMissing4(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if nums[0]: return 0\n        return nums[0]\n\n    def findMissing5(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if nums[0]: return 0\n        return nums[0]\n\n    def findMissing6(self, nums):\n        \"\"\"\n        check the first element\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return None\n        if nums[0]: return 0\n        return nums[0]\n\nif __name__==\"__main__\":\n    print Solution().findMissing([1,2,3])\n    print Solution().findMissing2([1,2,3])\n    print Solution().findMissing3([1,2,3])\n    print Solution().findMissing4([1,2,3])\n    print Solution().findMissing5([1,",
      -9.6328125
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i] > nums[i+1]:\n                nums[i] = nums[i+1]\n        for i in range(n-1, -1, -1):\n            if nums[i] > nums[i+1]:\n                nums[i] = nums[i+1]\n        for i in range(n-2, -1, -1):\n            if nums[i] > nums[i+2]:\n                nums[i] = nums[i+2]\n        for i in range(n-3, -1, -1):\n            if nums[i] > nums[i+3]:\n                nums[i] = nums[i+3]\n        for i in range(n-4, -1, -1):\n            if nums[i] > nums[i+4]:\n                nums[i] = nums[i+4]\n        for i in range(n-5, -1, -1):\n            if nums[i] > nums[i+5]:\n                nums[i] = nums[i+5]\n        for i in range(n-6, -1, -1):\n            if nums[i] > nums[i+6]:\n                nums[i] = nums[i+6]\n        for i in range(n-7, -1, -1):\n            if nums[i] > nums[i+7]:\n                nums[i] = nums[i+7]\n        for i in range(n-8, -1, -1):\n            if nums[i] > nums[i+8]:\n                nums[i] = nums[i+8]\n        for i in range(n-9, -1, -1):\n            if nums[i] > nums[i+9]:\n                nums[",
      -9.9765625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def smallestMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # check if nums is sorted\n        if len(nums) < 2:\n            return 0\n\n        # iterate through all elements\n        for i in range(len(nums)):\n            # if i is missing\n            if nums[i]!= i + 1:\n                # find the smallest missing element\n                smallest = i + 1\n                for j in range(i + 1, len(nums)):\n                    # if j is missing\n                    if nums[j]!= j + 1:\n                        # if j is smaller\n                        if nums[j] < smallest:\n                            smallest = nums[j]\n                # if smallest is larger than i, then swap them\n                if smallest > i + 1:\n                    nums[i], nums[smallest] = nums[smallest], nums[i]\n                # return smallest\n                return smallest\n        return 0\n\n\n# test cases\ntest = Solution()\n\n# nums = [1,2,3,4,5]\n# nums = [1]\n# nums = [0]\n# nums = [1,2,3,4,5]\n# nums = [5,6,7,8,9]\n# nums = [2,3,4,5,6]\n# nums = [1,2,3,4,5,6,7]\n# nums = [2,3,4,5,6,7,8]\n# nums = [1,2,3,4,5,6,7,8,9]\n# nums = [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n# nums = [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]\n# nums = [2,3,4",
      -11.4453125
    ],
    [
      "class Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def findMin(self, num):\n        if len(num) == 0:\n            return 0\n        else:\n            start = 0\n            end = len(num) - 1\n            while start < end:\n                mid = (start + end) / 2\n                if num[mid] == num[end]:\n                    end = mid\n                elif num[mid] < num[end]:\n                    start = mid + 1\n                else:\n                    end = mid\n            return num[start]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.findMin([1, 2, 3, 4, 5])\n    print solution.findMin([-1, -2, -3, -4, -5])\n    print solution.findMin([])\n    print solution.findMin([-1])",
      -11.828125
    ],
    [
      "# https://www.hackerrank.com/challenges/smallest-missing-element-in-a-sorted-array/problem\n\n# A solution is to create a new array with the missing element as the last element and sort it.\n# The problem is that we may have to sort the array many times.\n# If we sort the array at the end, we need to check if the last element is missing.\n# If the last element is missing, we need to insert it into the sorted array.\n# If the last element is not missing, we can use the original array.\n#\n# For example, given [1,2,3,4,5,6,7,8,9], the missing element is 8.\n# We need to insert 8 into the array.\n\nimport collections\n\ndef smallest_missing_element_in_sorted_array(array):\n    # write your code here\n    if len(array) == 0:\n        return 0\n    elif len(array) == 1:\n        return array[0]\n\n    sorted_array = sorted(array)\n    if sorted_array[-1]!= sorted_array[-2]:\n        return sorted_array[-1]\n\n    return smallest_missing_element_in_sorted_array(sorted_array[:-1])\n\nif __name__ == \"__main__\":\n    array = [1,2,3,4,5,6,7,8,9]\n    print(smallest_missing_element_in_sorted_array(array))",
      -12.1484375
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findMissing(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/missing-interval/discuss/84592/Python-O(1)-Time-Solution-with-Interval-List\n        # use the interval tree to find the missing interval.\n        interval_tree = IntervalTree(intervals)\n        return interval_tree.find_missing()\n\nclass IntervalTree(object):\n    def __init__(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        \"\"\"\n        self.intervals = intervals\n        self.min_start = self.min_end = float(\"inf\")\n        self.max_start = self.max_end = float(\"-inf\")\n        for interval in intervals:\n            self.min_start = min(interval.start, self.min_start)\n            self.min_end = max(interval.end, self.min_end)\n            self.max_start = max(interval.start, self.max_start)\n            self.max_end = min(interval.end, self.max_end)\n\n    def find_missing(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/missing-interval/discuss/84592/Python-O(1)-Time-Solution-with-Interval-List\n        # Use a binary search to find the missing interval.\n        # if the interval tree is empty, return 0.\n        if len(self.intervals) == 0:\n            return 0\n        mid = len(self.intervals) / 2\n        if self.intervals[mid].start == self.intervals[mid].end:\n            return mid + 1\n        if self.intervals[mid].start > self.intervals[mid].end:",
      -12.4609375
    ],
    [
      "def smallest_missing(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    return smallest_missing(arr[1:])\n\n\nif __name__ == '__main__':\n    arr = [2, 1, 3]\n    print(smallest_missing(arr))\n    arr = [1, 2, 3]\n    print(smallest_missing(arr))\n    arr = [1, 2, 3, 4, 5]\n    print(smallest_missing(arr))\n    arr = [1, 2, 3, 4, 5, 6]\n    print(smallest_missing(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    print(smallest_missing(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(smallest_missing(arr))",
      -12.8828125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def findMinMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        head = ListNode(-1)\n        head.next = nums[0]\n        i = 0\n        j = 0\n        while i < len(nums):\n            if nums[i]!= head.val:\n                head.next = ListNode(nums[i])\n                head = head.next\n            else:\n                i += 1\n        while j < len(nums):\n            if nums[j]!= head.val:\n                return j + 1\n            j += 1\n        return 0\n\n    def findMinMissing2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        head = ListNode(-1)\n        head.next = nums[0]\n        i = 0\n        j = 0\n        while i < len(nums):\n            if nums[i]!= head.val:\n                head.next = ListNode(nums[i])\n                head = head.next\n            else:\n                i += 1\n        while j < len(nums):\n            if nums[j]!= head.val:\n                return j + 1\n            j += 1\n        return 0\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,3,5,7]\n    print(sol.findMinMissing(nums))\n    nums = [1,2,3]\n    print(sol.findMinMissing(nums))\n    nums = [1,2,3,4]\n    print(sol.findMinMissing(nums))",
      -13.1484375
    ],
    [
      "class Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # the difference between the two\n        diff = sum(nums[1:]) - sum(nums)\n        # the index of the missing element\n        i = 0\n        # for each element in the array\n        for j in range(len(nums)):\n            # if the element is missing\n            if nums[j]!= j+1:\n                # if the difference is zero\n                if diff == 0:\n                    # return the index\n                    return j\n                # if the difference is not zero\n                else:\n                    # subtract the element from the difference\n                    diff -= nums[j]\n            # if the element is present\n            else:\n                # increment the index\n                i += 1\n        # return the index of the missing element\n        return i\n\nif __name__ == '__main__':\n    print Solution().findMissing([1,2,3])\n    print Solution().findMissing([4,5])\n    print Solution().findMissing([-1,0])\n    print Solution().findMissing([-1,1])\n    print Solution().findMissing([-1,1,2])\n    print Solution().findMissing([1,2,3,4,5,6])\n    print Solution().findMissing([1,2,3,4,5,6,7,8])",
      -13.25
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer\n    \"\"\"\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.find_smallest_missing(nums, 0, len(nums) - 1)\n\n    def find_smallest_missing(self, nums, start, end):\n        if start == end:\n            return nums[start]\n        mid = (start + end) / 2\n        if nums[mid] == nums[start] and nums[mid] == nums[end]:\n            return nums[mid]\n        if nums[mid] > nums[start]:\n            return self.find_smallest_missing(nums, mid + 1, end)\n        else:\n            return self.find_smallest_missing(nums, start, mid - 1)\n\n\nif __name__ == '__main__':\n    print Solution().findMissing([1,2,3])\n    print Solution().findMissing([1,2,3,4])\n    print Solution().findMissing([1,2,3,4,5])\n    print Solution().findMissing([1,2,3,4,5,6])\n    print Solution().findMissing([1,2,3,4,5,6,7])\n    print Solution().findMissing([1,2,3,4,5,6,7,8])",
      -13.6015625
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def findMissing(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        i = 0\n        while i < len(intervals):\n            j = i + 1\n            while j < len(intervals):\n                if intervals[i].end < intervals[j].start:\n                    intervals[i].end = max(intervals[i].end, intervals[j].end)\n                    intervals[j].end = max(intervals[j].end, intervals[i].end)\n                elif intervals[i].end > intervals[j].end:\n                    j += 1\n                else:\n                    intervals[j].start = max(intervals[i].start, intervals[j].start)\n                    intervals[i].start = max(intervals[i].start, intervals[j].start)\n                i += 1\n                j += 1\n        return intervals[0].start",
      -14.4765625
    ],
    [
      "def smallest_missing(arr):\n    # write your code here\n    if len(arr) == 0:\n        return None\n\n    min_index = 0\n    min_val = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_index = i\n            min_val = arr[i]\n\n    return arr[min_index]\n\n# arr = [1, 3, 4, 5, 6, 7]\n# smallest_missing(arr)\n# arr = [1, 2, 3, 4, 5, 6, 7, 8]\n# smallest_missing(arr)",
      -14.71875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def smallestMissing(self, root):\n        if root is None:\n            return 0\n        return self.smallestMissing(root.left) + self.smallestMissing(root.right) - root.val\n\n    # @param root, a tree node\n    # @return an integer\n    def smallestMissing2(self, root):\n        if root is None:\n            return 0\n        return min(self.smallestMissing(root.left), self.smallestMissing(root.right)) - root.val\n\n    # @param root, a tree node\n    # @return an integer\n    def smallestMissing3(self, root):\n        if root is None:\n            return 0\n        return min(self.smallestMissing(root.left), self.smallestMissing(root.right)) - root.val\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.right = TreeNode(10)\n    root.left.right.left = TreeNode(11)\n    root.left.right.right.right = TreeNode(12)\n    root.right.left.left = TreeNode(13)\n    root.right.right.right = TreeNode(14)\n    root.right.right.right.left = TreeNode(15)\n    root.right.right.right.right = TreeNode(16)\n    root.right.right.right.right = TreeNode(17)\n    root.right.",
      -15.171875
    ],
    [
      "# https://leetcode.com/problems/smallest-missing-element-in-sorted-array/discuss/187085/C++-solution-in-O(n)\n\nclass Solution(object):\n    def findMissing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n        if nums[i] > nums[j]:\n            nums[i], nums[j] = nums[j], nums[i]\n\n        return i\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMissing([0, 1, 2, 3, 4, 5])\n    print s.findMissing([1, 2, 3, 4, 5])\n    print s.findMissing([1, 2, 3])\n    print s.findMissing([2, 3, 4, 5])\n    print s.findMissing([3, 4, 5])\n    print s.findMissing([3, 4, 5, 6])\n    print s.findMissing([4, 5, 6])\n    print s.findMissing([4, 5, 6, 7])\n    print s.findMissing([5, 6, 7])\n    print s.findMissing([5, 6, 7, 8])\n    print s.findMissing([6, 7, 8])\n    print s.findMissing([6, 7, 8, 9])\n    print s.findMissing([7, 8, 9])\n    print s.findMissing([7, 8, 9, 10])\n    print s.findMissing([8, 9, 10])\n    print s.findMissing([8, 9, 10, 11])\n    print s.findMissing([9, 10, 11])\n    print s.findMissing([9, 10, 11, 12])\n    print s.findMissing([10, 11, 12])\n    print",
      -17.328125
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}