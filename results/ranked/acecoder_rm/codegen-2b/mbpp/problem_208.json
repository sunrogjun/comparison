{
  "problem": {
    "task_id": "MBPP/219",
    "prompt": "Write a function to extract maximum and minimum k elements in the given tuple.",
    "canonical_solution": "\r\ndef extract_min_max(test_tup, K):\r\n  res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res) ",
    "test_list": [
      "assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)",
      "assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)",
      "assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)"
    ],
    "challenge_test_list": [],
    "problem_id": 208
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def maxKSubsets(self, nums, k):\n        if not nums or len(nums) < k:\n            return []\n        \n        result = []\n        self.findSubsets(nums, k, result)\n        return result\n        \n    def findSubsets(self, nums, k, result):\n        if len(nums) == 1:\n            if len(result) == k:\n                result.append(nums)\n            return\n        \n        for i in range(len(nums)):\n            self.findSubsets(nums[:i] + nums[i+1:], k, result)\n            \n            # if len(result) == k:\n            #     result.append(nums)\n            # return\n            \n            if len(result) == k:\n                result.append(nums)\n                return",
      1.5673828125
    ],
    [
      "# https://oj.leetcode.com/problems/maximum-and-minimum-k-elements-in-a-sorted-tuple/\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, t):\n        self.data = t\n\nclass Solution(object):\n    def maxKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        res = 0\n        for i in range(1, len(nums)):\n            if k <= len(nums):\n                if i < len(nums) - k:\n                    res += 1\n                else:\n                    res += 1 + self.maxKSubsets(nums[i:], k)\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxKSubsets([1,2,3], 2)",
      0.82763671875
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @param k, an integer\n    # @return a list node\n    def getKthNode(self, head, k):\n        cur = head\n        res = []\n        while cur:\n            if k == 0:\n                break\n            k -= 1\n            res.append(cur.val)\n            cur = cur.next\n        if k > 0:\n            return None\n        res.reverse()\n        return ListNode(*res)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    print(sol.getKthNode(head, 4))",
      0.79541015625
    ],
    [
      "from collections import namedtuple\n\ndef extract_max_min(tuple_tuple):\n    \"\"\"\n    :type tuple_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(max(tuple_tuple) if len(tuple_tuple) > i else min(tuple_tuple) for i in range(len(tuple_tuple)))\n\n\ndef test_extract_max_min():\n    assert extract_max_min((3, 5, 2, 1, 4)) == (5, 3)\n\nif __name__ == \"__main__\":\n    tuple_tuple = (3, 5, 2, 1, 4)\n    test_extract_max_min()",
      0.43994140625
    ],
    [
      "class Solution:\n    def maxmin(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        max_nums = []\n        min_nums = []\n        n = len(nums)\n        for i in range(0, n):\n            if k == 0:\n                break\n            if nums[i] > nums[0]:\n                max_nums.append(nums[i])\n                k -= 1\n            elif nums[i] < nums[0]:\n                min_nums.append(nums[i])\n                k -= 1\n        return max_nums, min_nums",
      0.09735107421875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getKthNode(self, head, k):\n        if not head:\n            return None\n\n        l, r = head, head\n        while l and l.next:\n            l = l.next\n            r = r.next\n        l.next = None\n\n        n = 1\n        while l:\n            l = l.next\n            n += 1\n\n        if k == n:\n            return head\n        elif k > n:\n            return self.getKthNode(head.next, k - n)\n        else:\n            return self.getKthNode(head.next, k)",
      -0.482177734375
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution:\n    def findKthMax(self, tuple, k):\n        \"\"\"\n        :type tuple: List[Tuple]\n        :type k: int\n        :rtype: Tuple\n        \"\"\"\n        if len(tuple) == 0:\n            return Tuple(0)\n        \n        sorted_tuple = sorted(tuple)\n        \n        if k <= len(sorted_tuple):\n            return tuple[k-1]\n        \n        return tuple[len(sorted_tuple)-1]\n\nif __name__ == '__main__':\n    tuple = [Tuple(i) for i in range(1, 10)]\n    s = Solution()\n    k = 3\n    print s.findKthMax(tuple, k)",
      -0.62109375
    ],
    [
      "# https://oj.leetcode.com/problems/maximum-and-minimum-in-a-sorted-and-unsorted-array/\n# time: O(n^2)\n# space: O(n)\n\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of Interval\n    def findIntervals(self, intervals):\n        if not intervals:\n            return []\n        sorted_intervals = sorted(intervals, key=lambda x: x.start)\n        result = []\n        for interval in sorted_intervals:\n            if interval.start < sorted_intervals[0].start:\n                result.append(sorted_intervals[0])\n                sorted_intervals = sorted_intervals[1:]\n            elif interval.end > sorted_intervals[-1].end:\n                result.append(sorted_intervals[-1])\n                sorted_intervals = sorted_intervals[:-1]\n            else:\n                result.append(interval)\n        return result",
      -0.74853515625
    ],
    [
      "def get_k_min_max(tuple_list, k):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :type k: int\n    :rtype: List[Tuple]\n    \"\"\"\n    if len(tuple_list) == 0:\n        return []\n    else:\n        # Sort the list\n        tuple_list.sort()\n        # Find the minimum and maximum elements\n        min_value = tuple_list[0][0]\n        max_value = tuple_list[0][0]\n        for i in range(0, k):\n            if tuple_list[i][0] < min_value:\n                min_value = tuple_list[i][0]\n            if tuple_list[i][0] > max_value:\n                max_value = tuple_list[i][0]\n        # Return the minimum and maximum elements\n        return [min_value, max_value]",
      -0.79833984375
    ],
    [
      "class Solution:\n    def getMaxMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return [0, 0]\n        \n        max_max = max(nums)\n        max_min = max_max\n        min_max = min(nums)\n        min_min = min_max\n        \n        for x in nums:\n            if x > max_max:\n                max_max = x\n            if x < min_min:\n                min_min = x\n            \n        return [max_max, min_min]",
      -0.85595703125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxAndMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return [-1, -1]\n        l, r = [root.val], [root.val]\n        while root.left is not None:\n            l.append(root.left.val)\n            root = root.left\n        while root.right is not None:\n            r.append(root.right.val)\n            root = root.right\n        return [max(l), min(r)]",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def getMin(self, tuple):\n        return tuple[0]\n\n    def getMax(self, tuple):\n        return tuple[-1]\n\n    def getMinMax(self, tuple):\n        min_val = self.getMin(tuple)\n        max_val = self.getMax(tuple)\n        return (min_val, max_val)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.getMinMax([1, 2, 3, 4, 5])\n    print s.getMinMax([1, 2, 3])",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def findMinAndMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return [0, 0]\n        max_ = 0\n        min_ = 0\n        for num in nums:\n            if num > max_:\n                max_ = num\n            elif num < min_:\n                min_ = num\n        return [min_, max_]\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.findMinAndMax([1,2,3,4,5])",
      -0.85693359375
    ],
    [
      "from collections import Counter\n\ndef max_min(tuple):\n    \"\"\"\n    :type tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    max_k = []\n    min_k = []\n    for i in range(0, len(tuple)):\n        if tuple[i] in max_k:\n            continue\n        if tuple[i] not in min_k:\n            min_k.append(tuple[i])\n        if tuple[i] not in max_k:\n            max_k.append(tuple[i])\n    return tuple[max_k.index(max(max_k))], tuple[min_k.index(min(min_k))]\n\nif __name__ == '__main__':\n    tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    print max_min(tuple)",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param nums, a list of integers\n    # @param k, an integer\n    # @return a tuple of integer\n    def maxMin(self, nums, k):\n        ans = (None, None)\n        for i in range(len(nums)):\n            if i >= k:\n                if nums[i-k] > nums[i]:\n                    ans = (ans[0], i-k)\n                elif nums[i-k] < nums[i]:\n                    ans = (i-k, nums[i])\n            else:\n                if nums[i] > nums[i-k]:\n                    ans = (ans[1], i)\n                elif nums[i] < nums[i-k]:\n                    ans = (i, nums[i])\n        return ans",
      -0.85693359375
    ],
    [
      "def max_min(tuple):\n    \"\"\"\n    tuple -> tuple\n    \n    max_min(tuple) -> (max_value, min_value)\n    \n    returns the tuple's maximum and minimum elements.\n    \"\"\"\n    max_value = max(tuple)\n    min_value = min(tuple)\n    return (max_value, min_value)",
      -0.85693359375
    ],
    [
      "# https://www.hackerrank.com/challenges/k-element-max-min/problem\n\ndef get_max_min_k(a):\n    max_k, min_k = 0, 0\n    for i in a:\n        if i > max_k:\n            max_k = i\n        elif i < min_k:\n            min_k = i\n    return max_k, min_k\n\na = [2, 5, 1, 3, 7, 6, 4, 8, 1, 5]\nmax_k, min_k = get_max_min_k(a)\nprint(max_k, min_k)",
      -0.85693359375
    ],
    [
      "# -*- coding: utf-8 -*-\n\nfrom collections import namedtuple\n\nTuple = namedtuple('Tuple','min max')\n\n\nclass Solution:\n    \"\"\"\n    @param: k: An integer\n    @return: A tuple of length 3\n    \"\"\"\n    def max_k_element(self, tuple_list, k):\n        if not tuple_list:\n            return Tuple(0, 0, 0)\n\n        min_value = min(tuple_list)\n        max_value = max(tuple_list)\n\n        if k == 1:\n            return Tuple(min_value, max_value, max_value)\n\n        tuple_list.sort()\n        max_value = tuple_list[k-1]\n        max_value_index = tuple_list.index(max_value)\n        max_value_index_minus_k = max_value_index - k\n\n        return Tuple(min_value, max_value, max_value_index_minus_k)",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def maxmin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return [0, 0]\n\n        nums.sort()\n        max_left, min_left = nums[0], nums[0]\n        max_right, min_right = nums[0], nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > max_right:\n                max_right = nums[i]\n            elif nums[i] < min_left:\n                min_left = nums[i]\n            else:\n                min_right = nums[i]\n\n        return [max_right, min_left]",
      -0.85693359375
    ],
    [
      "def find_k_elements(tuple_list):\n    return max(tuple_list), min(tuple_list)\n\n# Your find_k_elements function will be called like this:\n# find_k_elements(tuple_list)",
      -0.85791015625
    ],
    [
      "def k_minmax(tuple):\n    return min(tuple), max(tuple)\n\ntuple = (1,2,3,4,5,6,7,8,9,10)\nprint(k_minmax(tuple))",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxK(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if k == 1:\n            return max(self.maxK(root.left, k), self.maxK(root.right, k))\n        else:\n            return max(self.maxK(root.left, k), self.maxK(root.right, k-1))",
      -0.85791015625
    ],
    [
      "# -*- coding: utf-8 -*-\n\nfrom typing import List\nimport collections\n\n\nclass Solution:\n    \"\"\"\n    @param: A tuple of N integers\n    @return: An integer array with length = N and the maximum and minimum values\n    \"\"\"\n\n    def maxmin(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        @param: A tuple of N integers\n        @return: An integer array with length = N and the maximum and minimum values\n        \"\"\"\n        if not nums:\n            return []\n\n        ans = collections.defaultdict(int)\n        for val in nums:\n            ans[val] += 1\n\n        max_key = max(ans, key=ans.get)\n        min_key = min(ans, key=ans.get)\n\n        return [max_key, min_key]",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def kthSmallest(self, nums, k):\n        return self.helper(nums, k, 0, len(nums)-1)\n    \n    def helper(self, nums, k, start, end):\n        if end - start < k-1:\n            return nums[start]\n        else:\n            middle = (start + end) / 2\n            if nums[middle] < nums[start]:\n                return self.helper(nums, k, start, middle)\n            else:\n                return self.helper(nums, k, middle+1, end)",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxSumSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        max_left = self.maxSumSubtree(root.left)\n        max_right = self.maxSumSubtree(root.right)\n        if max_left:\n            return [root.val] + max_left\n        if max_right:\n            return [root.val] + max_right\n        return []",
      -0.85791015625
    ],
    [
      "def extract_max_min(tuple):\n    \"\"\"\n    :type tuple: List[int]\n    :rtype: Tuple[int, int]\n    \"\"\"\n    max_element = 0\n    min_element = 0\n    for i in tuple:\n        if i > max_element:\n            max_element = i\n        elif i < min_element:\n            min_element = i\n    return (max_element, min_element)",
      -0.85791015625
    ],
    [
      "from collections import defaultdict\n\ndef max_min(t):\n    \"\"\"\n    :type t: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    d = defaultdict(int)\n    for i in range(len(t)):\n        for j in range(len(t[i])):\n            d[t[i][j]] += 1\n    return [max(d[i] for i in range(len(t))) if i in d else 0 for i in range(len(t))]",
      -0.85791015625
    ],
    [
      "import collections\n\n\nclass Solution(object):\n    def maxMinK(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = collections.defaultdict(int)\n        for num in nums:\n            res[num] += 1\n        return [res[x] for x in sorted(res)]",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def maxK(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        res = []\n        self.helper(root, res, k, 0)\n        return max(res)\n\n    def helper(self, node, res, k, cur):\n        if node is None:\n            return\n        if cur == k:\n            res.append(node.val)\n        else:\n            self.helper(node.left, res, k, cur + 1)\n            self.helper(node.right, res, k, cur + 1)",
      -0.8583984375
    ],
    [
      "from collections import namedtuple\n\nimport numpy as np\n\ndef max_min(k, t):\n    \"\"\"\n    Extract maximum and minimum k elements in the given tuple.\n    \"\"\"\n    k_elements = namedtuple(\"k_elements\", [\"max\", \"min\"])\n    return k_elements(np.max(t), np.min(t))\n\n\ndef main():\n    \"\"\"\n    Write a function to extract maximum and minimum k elements in the given tuple.\n    \"\"\"\n    t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    k = 3\n    print(max_min(k, t))\n\nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def maxK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        if k == 1:\n            return [max(nums), min(nums)]\n        ans = [None, None]\n        ans[0] = nums[0]\n        ans[1] = nums[0]\n        for i in range(1, len(nums)):\n            if ans[0] < nums[i]:\n                ans[0] = nums[i]\n            if ans[1] > nums[i]:\n                ans[1] = nums[i]\n        return ans",
      -0.8583984375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param: tuple: a tuple of integers\n    @return: a tuple of integers\n    \"\"\"\n    def getMinMax(self, k, tuple):\n        # write your code here\n        min_ = None\n        max_ = None\n        for i in tuple:\n            if i == min_:\n                continue\n            if i == max_:\n                continue\n            if min_ == None:\n                min_ = i\n            elif i < min_:\n                min_ = i\n            elif i > max_:\n                max_ = i\n        return (min_, max_)",
      -0.8583984375
    ],
    [
      "def maxmin(k, tuple):\n    \"\"\"\n    :type k: int\n    :type tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple[k-1], tuple[0]\n\nif __name__ == '__main__':\n    tuple = (1, 2, 3, 4, 5)\n    print maxmin(2, tuple)\n    print maxmin(3, tuple)\n    print maxmin(4, tuple)\n    print maxmin(5, tuple)",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {T} nums\n    # @return {Tuple[T,T]}\n    def findMinAndMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Tuple[int, int]\n\n        Time complexity: O(n).\n        Space complexity: O(1).\n        \"\"\"\n        if not nums:\n            return (0, 0)\n\n        min_index, max_index = 0, len(nums) - 1\n\n        for i in range(len(nums)):\n            if nums[i] < nums[min_index]:\n                min_index = i\n            if nums[i] > nums[max_index]:\n                max_index = i\n\n        return (nums[min_index], nums[max_index])",
      -0.8583984375
    ],
    [
      "from collections import Counter\n\nclass Solution:\n    def maxK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)):\n            if len(nums[i:]) < k:\n                break\n            if i == 0:\n                return [nums[0], nums[0]]\n            if i == len(nums) - 1:\n                return [nums[-1], nums[-1]]\n            if nums[i] > nums[i+1]:\n                return [nums[i], nums[i]]\n        return [nums[i] for i in range(k, len(nums))]",
      -0.8583984375
    ],
    [
      "from collections import Counter\n\ndef max_min(tuple):\n    \"\"\"\n    :type tuple: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(tuple) == 0:\n        return [0, 0]\n    cnt = Counter(tuple)\n    max_k = 0\n    min_k = 0\n    for key, value in cnt.items():\n        if value > max_k:\n            max_k = value\n        if value < min_k:\n            min_k = value\n    return [max_k, min_k]",
      -0.8583984375
    ],
    [
      "# https://leetcode.com/problems/max-and-min-in-a-sorted-tuple/\n\n\nclass Solution(object):\n    def maxAndMin(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if k > n:\n            return nums\n        if k == 0:\n            return [min(nums), max(nums)]\n        if k == 1:\n            return [min(nums), nums[0]]\n        if k == 2:\n            return [min(nums), max(nums)]\n        if k == 3:\n            return [min(nums), min(nums), max(nums)]\n        if k > 3:\n            return [min(nums), min(nums), min(nums), max(nums)]\n\n        return [min(nums), min(nums), min(nums), min(nums), max(nums)]",
      -0.8583984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def findMinAndMax(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return [None, None]\n        if root.left is None:\n            return [root.val, root.val]\n        min, max = self.findMinAndMax(root.left)\n        if root.val <= min:\n            min = root.val\n        if root.val >= max:\n            max = root.val\n        return [min, max]\n\n\ndef main():\n    solution = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print solution.findMinAndMax(root)\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    print solution.findMinAndMax(root)\n\n\nif __name__ == '__main__':\n    main()",
      -0.9814453125
    ],
    [
      "def extract_max_min_k(a_tuple, k):\n    \"\"\"\n    :type a_tuple: tuple\n    :type k: int\n    :rtype: tuple\n    \"\"\"\n    return a_tuple[k-1], a_tuple[0]\n\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    a = (1, 2, 3, 4, 5, 6)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)\n    print(extract_max_min_k(a, 3))\n    a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n    print(extract_max_min_k(a, 3))\n\nif __name__ == '__main__':\n    main()",
      -1.0771484375
    ],
    [
      "class Solution:\n    # @param A, a list of integers\n    # @param k, an integer\n    # @return a tuple, (index1, index2)\n    def maxAndMin(self, A, k):\n        # write your code here\n        if len(A) <= k:\n            return (0, len(A) - 1)\n        m = 0\n        n = len(A) - 1\n        while m < n:\n            m = min(m, k - 1)\n            n = max(n, k - 1)\n        return (m, n)",
      -1.400390625
    ],
    [
      "from collections import defaultdict\nimport operator\n\n\nclass Solution:\n    def kthMaxMin(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: tuple\n        \"\"\"\n        # find max and min\n        max_val = arr[0]\n        min_val = arr[0]\n        for i in range(1, k):\n            max_val = max(max_val, arr[i])\n            min_val = min(min_val, arr[i])\n        # return max and min\n        return (max_val, min_val)\n\n    def kthMaxMin2(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: tuple\n        \"\"\"\n        # find max and min\n        max_val = arr[0]\n        min_val = arr[0]\n        for i in range(1, k):\n            max_val = max(max_val, arr[i])\n            min_val = min(min_val, arr[i])\n        # return max and min\n        return (max_val, min_val)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 7, 9]\n    print(Solution().kthMaxMin(arr, 1))\n    print(Solution().kthMaxMin2(arr, 1))\n    arr = [1, 2, 3, 4]\n    print(Solution().kthMaxMin(arr, 1))",
      -1.556640625
    ],
    [
      "def max_min_k(tuple):\n    \"\"\"\n    :type tuple: List[int]\n    :rtype: List[int]\n    \"\"\"\n    k, min_x, max_x = 0, 99999999, -99999999\n    for x in tuple:\n        if x > max_x:\n            max_x = x\n        if x < min_x:\n            min_x = x\n        if x == min_x and k < 2:\n            k += 1\n    return [max_x, min_x, k]\n\nif __name__ == '__main__':\n    tuple = [1, 2, 3, 4, 5]\n    print max_min_k(tuple)",
      -1.6162109375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxAndMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return [0, 0]\n        if root.left is None and root.right is None:\n            return [root.val, root.val]\n        res = [root.val, root.val]\n        if root.left:\n            res[0] = min(res[0], root.left.val)\n        if root.right:\n            res[0] = min(res[0], root.right.val)\n        if root.left:\n            res[1] = max(res[1], root.left.val)\n        if root.right:\n            res[1] = max(res[1], root.right.val)\n        return res",
      -1.7890625
    ],
    [
      "def extract_min_max(tuple):\n    min_value = float(\"-inf\")\n    max_value = float(\"inf\")\n\n    for i in range(0, len(tuple)):\n        if tuple[i] < min_value:\n            min_value = tuple[i]\n        if tuple[i] > max_value:\n            max_value = tuple[i]\n\n    return min_value, max_value\n\n\nif __name__ == \"__main__\":\n    tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    min_value, max_value = extract_min_max(tuple)\n    print(\"Minimum: {}\".format(min_value))\n    print(\"Maximum: {}\".format(max_value))",
      -1.90234375
    ],
    [
      "import collections\n\nclass Solution:\n    def maxAndMin(self, arr: List[int]) -> List[List[int]]:\n        max_values = collections.defaultdict(lambda: -sys.maxsize)\n        min_values = collections.defaultdict(lambda: sys.maxsize)\n\n        for i in range(len(arr)):\n            for key, value in arr[i].items():\n                max_values[key] = max(max_values[key], value)\n                min_values[key] = min(min_values[key], value)\n\n        max_values = collections.OrderedDict(sorted(max_values.items(), reverse=True))\n        min_values = collections.OrderedDict(sorted(min_values.items(), reverse=True))\n\n        return [max_values, min_values]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(Solution().maxAndMin(arr))",
      -2.2578125
    ],
    [
      "def find_min_max(arr):\n    \"\"\"\n    Write a function to extract maximum and minimum k elements in the given tuple.\n    \"\"\"\n    return max(arr), min(arr)\n\n\nif __name__ == '__main__':\n    t = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n    print(find_min_max(t))\n    t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)\n    print(find_min_max(t))\n    t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)\n    print(find_min_max(t))",
      -2.421875
    ],
    [
      "class Solution:\n    # @param {List[T]} nums\n    # @param {number} k\n    # @return {[number, number]}\n    def getMaxMin(self, nums, k):\n        maxes = [0] * k\n        mins = [0] * k\n\n        for i in range(len(nums)):\n            for j in range(k):\n                if nums[i] < maxes[j]:\n                    maxes[j] = nums[i]\n                if nums[i] > mins[j]:\n                    mins[j] = nums[i]\n\n        return maxes, mins\n\nif __name__ == \"__main__\":\n    print Solution().getMaxMin([3, 5, 2, 1, 4], 3)",
      -2.80078125
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, tup):\n        self.tup = tup\n\n    def __iter__(self):\n        return iter(self.tup)\n\n\nclass Solution:\n    def getMaxMin(self, k, tuple):\n        \"\"\"\n        :type k: int\n        :type tuple: Tuple\n        :rtype: List[int]\n        \"\"\"\n        return max(tuple, key=lambda x: len(x))[:k]",
      -2.87109375
    ],
    [
      "# https://www.hackerrank.com/challenges/maximum-and-minimum-k-elements/problem\n# https://www.hackerrank.com/challenges/maximum-and-minimum-k-elements/submissions/code/13013077\n\n\ndef max_min(tuple_list, k):\n    # k - number of elements\n    # tuple_list - list of tuples\n    # returns tuple (max_element, min_element)\n    max_element = tuple_list[0]\n    min_element = tuple_list[0]\n    for item in tuple_list:\n        if max_element < item:\n            max_element = item\n        if min_element > item:\n            min_element = item\n    return (max_element, min_element)\n\n\nif __name__ == '__main__':\n    tuple_list = [(-5, 10, -10), (10, 20, 15), (20, -20, -10), (-10, -5, -10)]\n    max_min(tuple_list, 3)\n    print(max_min(tuple_list, 3))",
      -3.193359375
    ],
    [
      "def max_min_k(tuple, k):\n    \"\"\"\n    :type tuple: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    max_val, min_val = 0, 999999999\n    for i in range(len(tuple) - k):\n        for j in range(i + 1, len(tuple)):\n            if tuple[i] < tuple[j] and (tuple[i] + tuple[j]) < max_val:\n                max_val = tuple[i] + tuple[j]\n                max_ind = i\n            if tuple[i] > tuple[j] and (tuple[i] - tuple[j]) > min_val:\n                min_val = tuple[i] - tuple[j]\n                min_ind = i\n    return [max_val, min_val, max_ind, min_ind]\n\nif __name__ == '__main__':\n    tuple = [1, 3, 2, 5, 6, 4, 2, 1, 8]\n    k = 2\n    print(max_min_k(tuple, k))",
      -3.19921875
    ],
    [
      "import unittest\nimport collections\n\nclass Solution(object):\n    def kthMaxMin(self, k, t):\n        \"\"\"\n        :type k: int\n        :type t: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = collections.defaultdict(int)\n        for i in xrange(k):\n            res[i] = max(t)\n        res[k] = min(t)\n        return list(res.values())\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/k-th-max-and-min-in-a-tuple/solution/\n#\nApproach #1: Sort [1, 2, 3, 4, 5] to get [1, 2, 3, 4, 5]\nComplexity Analysis\nTime Complexity: O(k), where k is the number of elements to extract.\nSpace Complexity: O(k), the space used by sorting.\n\n# 12ms 99.66%\nclass Solution {\n    public List<Integer> kthMaxMin(int k, List<Integer> t) {\n        Collections.sort(t);\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = 0; i < k; i++) {\n            res.add(t.get(i));\n        }\n        res.add(t.get(k));\n        res.add(t.get(k));\n        return res;\n    }\n}\n\n# Approach #2: Sort [1, 2, 3, 4, 5] to get [1, 2, 3, 4, 5]\n# Complexity Analysis\nTime Complexity: O(k), where k is the number of elements to extract.\nSpace Complexity: O(k), the space used by sorting.\n\n# 12ms 99.66%\nclass Solution {\n    public List<Integer> kthMaxMin(int k, List<Integer> t) {",
      -3.298828125
    ],
    [
      "def get_min_max_k(tuple):\n    \"\"\"\n    :type tuple: List[int]\n    :rtype: Tuple[int, int]\n    \"\"\"\n    return min(tuple), max(tuple)\n\n\nif __name__ == '__main__':\n    tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    print(get_min_max_k(tuple))\n    tuple = (1, 2, 3, 4, 5)\n    print(get_min_max_k(tuple))\n    tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n    print(get_min_max_k(tuple))",
      -3.4765625
    ],
    [
      "# https://oj.leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def maxK(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n\n        k = 1\n        while head.next:\n            head = head.next\n            k += 1\n\n        head = dummy.next\n        head = self.getKth(head, k)\n\n        return head\n\n    def getKth(self, head: ListNode, k: int) -> ListNode:\n        n = 0\n        while head:\n            n += 1\n            head = head.next\n        n -= k\n        head = head.next\n        while n > 0:\n            head = head.next\n            n -= 1\n        return head",
      -3.60546875
    ],
    [
      "class Solution(object):\n    def maxKSubsets(self, S, k):\n        \"\"\"\n        :type S: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(S)\n        if k > n:\n            return 0\n        if k == 1:\n            return 1\n        max_k_subsets = 0\n        for i in range(n):\n            for j in range(k):\n                if j > i:\n                    break\n                elif j == i:\n                    max_k_subsets += 1\n                elif j > i + 1:\n                    max_k_subsets += 2\n        return max_k_subsets\n\n\nif __name__ == '__main__':\n    print(Solution().maxKSubsets([3, 2, 4, 1], 4))",
      -3.9765625
    ],
    [
      "class Solution(object):\n    def maxAndMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_val = nums[0]\n        min_val = nums[0]\n\n        for num in nums:\n            if num > max_val:\n                max_val = num\n            if num < min_val:\n                min_val = num\n\n        return [max_val, min_val]\n\nif __name__ == \"__main__\":\n    assert Solution().maxAndMin([1, 3, 4, 1]) == [1, 1]\n    assert Solution().maxAndMin([1, 3, 4, 2]) == [1, 2]\n    assert Solution().maxAndMin([3, 4, 5, 1, 1]) == [1, 1]\n    assert Solution().maxAndMin([3, 4, 5, 1, 2]) == [1, 2]",
      -4.1015625
    ],
    [
      "class Solution(object):\n    def maxmin(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        \n        maxes = [nums[0]]\n        mines = [nums[0]]\n        for i in xrange(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                maxes.append(nums[i])\n            else:\n                mines.append(nums[i])\n        \n        if k == 1:\n            return maxes + mines\n        elif k == 2:\n            return maxes[0], maxes[1], mines[0], mines[1]\n        else:\n            return maxes, mines",
      -4.2734375
    ],
    [
      "class Solution:\n    # @param {List[T]} nums\n    # @param {integer} k\n    # @return {List[T]}\n    def kthSmallest(self, nums, k):\n        result = []\n        self.kthSmallestRec(nums, k, 0, len(nums) - 1, result)\n        return result\n\n    def kthSmallestRec(self, nums, k, start, end, result):\n        if start > end:\n            return\n        mid = (start + end) / 2\n        if start == end:\n            result.append(nums[start])\n            return\n        if nums[mid] < nums[end]:\n            self.kthSmallestRec(nums, k, start, mid - 1, result)\n        else:\n            self.kthSmallestRec(nums, k, mid + 1, end, result)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8,9]\n    k = 3\n    result = sol.kthSmallest(nums, k)\n    print(result)\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    k = 3\n    result = sol.kthSmallest(nums, k)\n    print(result)\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    k = 4\n    result = sol.kthSmallest(nums, k)\n    print(result)",
      -4.3984375
    ],
    [
      "def max_min(a_tuple):\n    \"\"\"\n    :type a_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    min_value = min(a_tuple)\n    max_value = max(a_tuple)\n    return min_value, max_value\n\ndef main():\n    \"\"\"\n    Simple test case.\n    \"\"\"\n    a_tuple = (1, 2, 3)\n    min_value, max_value = max_min(a_tuple)\n    print(min_value, max_value)\n\nif __name__ == '__main__':\n    main()",
      -4.3984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def kthSmallest(self, nums, k):\n        if len(nums) == 0 or k == 1:\n            return nums\n        elif k == 2:\n            return min(nums), max(nums)\n        else:\n            left = self.kthSmallest(nums[:k-1], k-1)\n            right = self.kthSmallest(nums[k-1:], k-1)\n            return max(left[1], right[1]), min(left[0], right[0])\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8]\n    print(sol.kthSmallest(nums, 3))",
      -4.6015625
    ],
    [
      "class Solution(object):\n    def findMinAndMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: tuple[int, int]\n        \"\"\"\n        return min(nums), max(nums)\n\n# Note:\n#   1. There are more than 1 possible solution.\n#   2. This question is about the maximum and minimum element in a list.\n#   3. This question is about the minimum and maximum element in a tuple.",
      -4.71875
    ],
    [
      "# Definition for a tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def maxK(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        max_val = 0\n        min_val = 0\n        max_k = 0\n        min_k = 0\n\n        for num in nums:\n            if num[0] > max_val:\n                max_val = num[0]\n                max_k = 1\n            elif num[0] == max_val:\n                max_k += 1\n            if num[1] < min_val:\n                min_val = num[1]\n                min_k = 1\n            elif num[1] == min_val:\n                min_k += 1\n\n        return [Tuple(max_k, min_k)]\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    k = 3\n    nums = [(1, 2), (1, 3), (2, 2), (3, 2), (3, 4)]\n    print solution.maxK(k, nums)",
      -4.7734375
    ],
    [
      "import math\n\n\ndef get_max_min(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return max_min(nums, 0, len(nums) - 1)\n\n\ndef max_min(nums, start, end):\n    if start == end:\n        return [nums[start], nums[start]]\n    else:\n        mid = (start + end) / 2\n        return max_min(nums, start, mid), max_min(nums, mid + 1, end)\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print(get_max_min(nums))",
      -5.2265625
    ],
    [
      "def findMaxMin(tuple):\n    if len(tuple) == 0:\n        return 0, 0\n    min_val = min(tuple)\n    max_val = max(tuple)\n    return max_val, min_val\n\ndef findMaxMin2(tuple):\n    max_val, min_val = 0, 0\n    for val in tuple:\n        if val > max_val:\n            max_val = val\n        elif val < min_val:\n            min_val = val\n    return max_val, min_val\n\ndef findMaxMin3(tuple):\n    max_val, min_val = 0, 0\n    for val in tuple:\n        if val > max_val:\n            max_val = val\n        elif val < min_val:\n            min_val = val\n    return max_val, min_val\n\ntuple = (3, 1, 2, 4, 5, 6)\nprint findMaxMin(tuple)\nprint findMaxMin2(tuple)\nprint findMaxMin3(tuple)",
      -5.2265625
    ],
    [
      "class Solution(object):\n    def maxKSubarray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        if not nums:\n            return result\n        max_len = 0\n        min_len = 0\n        max_val = nums[0]\n        min_val = nums[0]\n        max_index = 0\n        min_index = 0\n        for i in range(len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n                max_index = i\n            elif nums[i] < min_val:\n                min_val = nums[i]\n                min_index = i\n        if max_val - min_val > k:\n            return [max_val]\n        if max_val - min_val == k:\n            result.append(max_val)\n        if min_val - max_val > k:\n            return [min_val]\n        if min_val - max_val == k:\n            result.append(min_val)\n        for i in range(len(nums)):\n            if i!= min_index and i!= max_index:\n                if nums[i] - max_val > k:\n                    return [max_val]\n                if nums[i] - min_val < k:\n                    return [min_val]\n        return result",
      -5.46875
    ],
    [
      "import collections\n\n\nclass Solution:\n    def maxMinK(self, arr: List[int], k: int) -> List[int]:\n        if not arr:\n            return []\n        min_val = arr[0]\n        max_val = arr[0]\n        res = []\n        for num in arr:\n            if num > max_val:\n                max_val = num\n            if num < min_val:\n                min_val = num\n            if num == max_val:\n                res.append(max_val)\n            if num == min_val:\n                res.append(min_val)\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 2\n    print(sol.maxMinK(arr, k))",
      -5.49609375
    ],
    [
      "# Approach 1: Extracting k elements in the tuple.\n# This is a O(n^2) solution.\ndef get_min_max(tuple_list, k):\n    # Sorting the tuple list.\n    sorted_list = sorted(tuple_list)\n    \n    # Extracting k elements from the sorted list.\n    extracted_list = sorted_list[:k]\n    \n    # Extracting the minimum and maximum elements from the extracted list.\n    return min(extracted_list), max(extracted_list)\n\n# Approach 2: Extracting k elements in the tuple.\n# This is a O(n) solution.\ndef get_min_max_2(tuple_list, k):\n    # Extracting k elements from the tuple list.\n    extracted_list = tuple_list[:k]\n    \n    # Extracting the minimum and maximum elements from the extracted list.\n    return min(extracted_list), max(extracted_list)\n\n# Approach 3: Extracting k elements in the tuple.\n# This is a O(n) solution.\ndef get_min_max_3(tuple_list, k):\n    # Extracting k elements from the tuple list.\n    extracted_list = tuple_list[:k]\n    \n    # Extracting the minimum and maximum elements from the extracted list.\n    return min(extracted_list), max(extracted_list)\n\n# Approach 4: Extracting k elements in the tuple.\n# This is a O(n) solution.\ndef get_min_max_4(tuple_list, k):\n    # Extracting k elements from the tuple list.\n    extracted_list = tuple_list[:k]\n    \n    # Extracting the minimum and maximum elements from the extracted list.\n    return min(extracted_list), max(extracted_list)\n\n# Approach 5: Extracting k elements in the tuple.\n# This is a O(n) solution.\ndef get_min_max_5(tuple_list, k):\n    # Extracting k elements from the tuple list.\n    extracted_list = tuple_list[:k]\n    \n    # Extracting the minimum and maximum elements",
      -5.56640625
    ],
    [
      "from collections import defaultdict\n\nclass Solution:\n    def findMinAndMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dic = defaultdict(int)\n        for num in nums:\n            dic[num] += 1\n        max_k = 0\n        min_k = 0\n        for k in range(1, len(dic)):\n            if dic[k] > dic[max_k]:\n                max_k = k\n            if dic[k] < dic[min_k]:\n                min_k = k\n        return [max_k, min_k]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMinAndMax([1,3,5,6,7])",
      -6.15234375
    ],
    [
      "def k_max_min(tuple):\n    return max(tuple), min(tuple)\n\nif __name__ == '__main__':\n    t = (1, 2, 3, 4, 5)\n    k = 2\n    print k_max_min(t)\n    print k_max_min(t[0:k])\n    print k_max_min(t[k:])\n    print k_max_min(t[0:k])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(t[k:])\n    print k_max_min(",
      -6.1875
    ],
    [
      "class Solution(object):\n    def maxmin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [0, 0]\n        # store the max and min value in the list\n        max_val = nums[0]\n        min_val = nums[0]\n        for i in range(1, n):\n            if nums[i] > max_val:\n                max_val = nums[i]\n            elif nums[i] < min_val:\n                min_val = nums[i]\n        return [max_val, min_val]\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print Solution().maxmin(nums)\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print Solution().maxmin(nums)\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print Solution().maxmin(nums)",
      -6.296875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def findMaxMin(self, root: TreeNode) -> int:\n        \"\"\"\n        BFS\n        \"\"\"\n        if not root:\n            return 0, 0\n        queue = [(root, 0)]\n        while queue:\n            node, level = queue.pop(0)\n            if level == 0:\n                if node.left:\n                    queue.append((node.left, level + 1))\n                if node.right:\n                    queue.append((node.right, level + 1))\n            if node.left:\n                queue.append((node.left, level))\n            if node.right:\n                queue.append((node.right, level))\n        return max(root.val, root.left.val), min(root.val, root.right.val)",
      -6.4609375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, tup):\n        self.tup = tup\n\n    def __str__(self):\n        return str(self.tup)\n\n    def __repr__(self):\n        return str(self.tup)\n\n# Your Solution here.\ndef maximum_k(tuple_list):\n    return max(map(lambda tup: max(tup), tuple_list))\n\ndef minimum_k(tuple_list):\n    return min(map(lambda tup: min(tup), tuple_list))\n\nif __name__ == '__main__':\n    tuple_list = [Tuple([1, 2, 3, 4]), Tuple([5, 6, 7, 8]), Tuple([9, 10, 11, 12, 13, 14, 15])]\n    print maximum_k(tuple_list), minimum_k(tuple_list)",
      -6.5390625
    ],
    [
      "from collections import defaultdict\n\ndef max_min_k(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: Tuple[int, int]\n    \"\"\"\n    k_dict = defaultdict(lambda: 0)\n    for t in tuple_list:\n        k_dict[t] += 1\n\n    k_list = sorted(k_dict.items(), key=lambda x: x[1], reverse=True)\n    return k_list[0][0], k_list[0][1]\n\n\nif __name__ == '__main__':\n    tuple_list = [(1, 1), (2, 2), (3, 3), (1, 2), (2, 3), (1, 3)]\n    print max_min_k(tuple_list)",
      -6.64453125
    ],
    [
      "def max_min_k(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: tuple\n    \"\"\"\n    if len(tuple_list) == 0:\n        return (0, 0)\n    if len(tuple_list) == 1:\n        return tuple_list[0]\n    m = max(tuple_list)\n    k = min(tuple_list)\n    for i in range(len(tuple_list)):\n        if tuple_list[i] == m:\n            m = k\n            k = tuple_list[i]\n    return (m, k)\n\nif __name__ == \"__main__\":\n    tuple_list = [(1,2), (2,3), (3,4), (4,5), (5,6)]\n    print(max_min_k(tuple_list))",
      -6.8203125
    ],
    [
      "from collections import defaultdict\n\ndef max_min(a):\n    \"\"\"\n    :type a: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_min_dict = defaultdict(int)\n    for x in a:\n        max_min_dict[x] += 1\n    max_k_list = []\n    min_k_list = []\n    for k in range(1, len(a)):\n        if max_min_dict[k] > 0:\n            max_k_list.append(k)\n        if max_min_dict[k] < 0:\n            min_k_list.append(k)\n    return max_k_list, min_k_list\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print max_min(a)\n    a = [0, 1, 0, 1, 1]\n    print max_min(a)\n    a = [0, 1, 2, 3, 4]\n    print max_min(a)\n    a = [0, 1, 2, 3, 4, 5]\n    print max_min(a)",
      -6.8515625
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def maxMin(self, k, tuple):\n        \"\"\"\n        :type k: int\n        :type tuple: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(tuple)\n        if k > n:\n            return tuple\n        min_val = tuple[0]\n        max_val = tuple[0]\n        for i in range(n):\n            if tuple[i] < min_val:\n                min_val = tuple[i]\n            if tuple[i] > max_val:\n                max_val = tuple[i]\n        if k == 1:\n            return [max_val]\n        elif k == 2:\n            return [max_val, min_val]\n        elif k == 3:\n            return [min_val, max_val, min_val]\n        else:\n            ans = []\n            for i in range(k - 2):\n                ans.append(min_val)\n                ans.append(max_val)\n            return ans\n\nif __name__ == '__main__':\n    sol = Solution()\n    t = (2, 3, 1, 4, 0, 1, 5)\n    k = 4\n    print(sol.maxMin(k, t))\n    k = 5\n    print(sol.maxMin(k, t))\n    k = 6\n    print(sol.maxMin(k, t))\n    k = 7\n    print(sol.maxMin(k, t))\n    k = 8\n    print(sol.maxMin(k, t))\n    k = 9\n    print(sol.maxMin(k, t))\n    k = 10\n    print(sol.maxMin(k, t))\n    k = 11\n    print(sol.maxMin(k, t))",
      -6.9375
    ],
    [
      "def extract_maxmin_k(tuple):\n    return tuple[0], tuple[1], tuple[2]\n\nif __name__ == '__main__':\n    print extract_maxmin_k((1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n    print extract_maxmin_k((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))\n    print extract_maxmin_k((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))\n    print extract_maxmin_k((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174",
      -6.96875
    ],
    [
      "class Solution:\n    # @param {List<int>} nums\n    # @return {[int, int]}\n    def kthMaxMin(self, nums, k):\n        max_num = 0\n        min_num = 0\n        for i in range(len(nums)):\n            if k == 1:\n                max_num = max(max_num, nums[i])\n                min_num = min(min_num, nums[i])\n            elif k == 2:\n                max_num = max(max_num, max(nums[i-1], nums[i]))\n                min_num = min(min_num, min(nums[i-1], nums[i]))\n            else:\n                max_num = max(max_num, max(max(nums[i-k+1:i]), nums[i]))\n                min_num = min(min_num, min(min(nums[i-k+1:i]), nums[i]))\n        return [max_num, min_num]",
      -7.4375
    ],
    [
      "def max_min(tuple_):\n    return max(tuple_), min(tuple_)\n\ndef max_min_k(tuple_):\n    max_tuple, min_tuple = max_min(tuple_)\n    max_k = max_tuple[0]\n    min_k = min_tuple[0]\n    for i in range(1, len(max_tuple)):\n        if max_tuple[i] > max_k:\n            max_k = max_tuple[i]\n        if min_tuple[i] < min_k:\n            min_k = min_tuple[i]\n    return max_k, min_k",
      -7.7265625
    ],
    [
      "class Solution(object):\n    def kthMaxMin(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_k = []\n        min_k = []\n        for i in range(len(nums)):\n            if i < k:\n                max_k.append(nums[i])\n            elif i == k:\n                max_k.append(max(nums))\n            elif i > k:\n                min_k.append(min(nums))\n        return max_k, min_k\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8,9]\n    max_k, min_k = sol.kthMaxMin(2, nums)\n    print max_k\n    print min_k\n    print nums\n\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    max_k, min_k = sol.kthMaxMin(3, nums)\n    print max_k\n    print min_k\n    print nums\n\n    nums = [1,2,3,4,5,6,7,8,9]\n    max_k, min_k = sol.kthMaxMin(10, nums)\n    print max_k\n    print min_k\n    print nums\n\n    nums = [1,2,3,4,5,6,7,8,9]\n    max_k, min_k = sol.kthMaxMin(1, nums)\n    print max_k\n    print min_k\n    print nums\n\n    nums = [1,2,3,4,5,6,7,8,9]\n    max_k, min_k = sol.kthMaxMin(0, nums)\n    print max_k\n    print min_k\n    print nums\n\n    nums = [1,2,3,4,5,6,7,8,9",
      -8.2265625
    ],
    [
      "class Solution:\n    # @param k, an integer\n    # @param nums, a tuple of integers\n    # @return a tuple of integer\n    def kClosestElements(self, k, nums):\n        if k == 0:\n            return nums\n        elif k == 1:\n            return max(nums), min(nums)\n        else:\n            min_nums = []\n            max_nums = []\n            for n in nums:\n                if len(min_nums) == k - 1:\n                    min_nums.append(min(min_nums, n))\n                    max_nums.append(max(max_nums, n))\n                else:\n                    min_nums.append(min(min_nums, n))\n                    max_nums.append(max(max_nums, n))\n            return max(max_nums), min(min_nums)",
      -8.25
    ],
    [
      "import collections\n\ndef max_min(tuple_to_max_min):\n    \"\"\"\n    :type tuple_to_max_min: tuple\n    :rtype: tuple\n    \"\"\"\n    max_min = collections.defaultdict(lambda: (0, 0))\n    for i in range(len(tuple_to_max_min)):\n        if tuple_to_max_min[i] > max_min[tuple_to_max_min[i]]:\n            max_min[tuple_to_max_min[i]] = (i, tuple_to_max_min[i])\n        elif tuple_to_max_min[i] < max_min[tuple_to_max_min[i]][0]:\n            max_min[tuple_to_max_min[i]] = (i, tuple_to_max_min[i])\n    return max_min.values()",
      -8.28125
    ],
    [
      "from collections import defaultdict\n\n\ndef find_max_min_k(items):\n    \"\"\"\n    :type items: List[Tuple[int,...]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    max_k_dict = defaultdict(int)\n    min_k_dict = defaultdict(int)\n    for item in items:\n        for i, k in enumerate(item):\n            max_k_dict[k] += 1\n            min_k_dict[k] += 1\n    max_k = max(max_k_dict, key=max_k_dict.get)\n    min_k = min(min_k_dict, key=min_k_dict.get)\n    return [max_k, min_k]\n\n\nif __name__ == '__main__':\n    assert find_max_min_k([(1, 2), (3, 4), (2, 3), (1, 3), (3, 4)]) == [3, 2]\n    assert find_max_min_k([(1, 2), (3, 4), (2, 3), (1, 3), (3, 4)]) == [3, 2]\n    assert find_max_min_k([(1, 2), (3, 4), (2, 3), (1, 3), (3, 4)]) == [3, 2]",
      -8.5234375
    ],
    [
      "def max_min(t):\n    \"\"\"\n    Returns a tuple (max, min) for the given tuple t.\n    \"\"\"\n    return (t[0], t[-1])\n\ndef test_max_min():\n    assert max_min((1,2,3,4,5,6)) == (6, 5)\n    assert max_min((2,1,2,3,4,5)) == (5, 2)\n    assert max_min((1,2,3,4,5,6,7)) == (6, 5)\n\ndef test_extract():\n    assert extract(max_min, (1,2,3,4,5,6)) == (6, 5)\n    assert extract(max_min, (2,1,2,3,4,5)) == (5, 2)\n    assert extract(max_min, (1,2,3,4,5,6,7)) == (6, 5)\n\ndef test_max_min_from_tuple():\n    assert max_min_from_tuple((1,2,3,4,5,6)) == (6, 5)\n    assert max_min_from_tuple((2,1,2,3,4,5)) == (5, 2)\n    assert max_min_from_tuple((1,2,3,4,5,6,7)) == (6, 5)\n\ndef test_extract_from_tuple():\n    assert extract_from_tuple(max_min_from_tuple, (1,2,3,4,5,6)) == (6, 5)\n    assert extract_from_tuple(max_min_from_tuple, (2,1,2,3,4,5)) == (5, 2)\n    assert extract_from_tuple(max_min_from_tuple, (1,2,3,4,5,6,7)) == (6, 5)",
      -8.8671875
    ],
    [
      "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'a b c d')\n\ndef max_min(tup):\n    return (tup.a, tup.b, tup.c, tup.d)\n\n\ndef main():\n    tup1 = Tuple(1, 2, 3, 4)\n    tup2 = Tuple(5, 6, 7, 8)\n    tup3 = Tuple(9, 10, 11, 12)\n    tup4 = Tuple(13, 14, 15, 16)\n    tup5 = Tuple(17, 18, 19, 20)\n    tup6 = Tuple(21, 22, 23, 24)\n    tup7 = Tuple(25, 26, 27, 28)\n    tup8 = Tuple(29, 30, 31, 32)\n    tup9 = Tuple(33, 34, 35, 36)\n    tup10 = Tuple(37, 38, 39, 40)\n    tup11 = Tuple(41, 42, 43, 44)\n    tup12 = Tuple(45, 46, 47, 48)\n    tup13 = Tuple(49, 50, 51, 52)\n    tup14 = Tuple(53, 54, 55, 56)\n\n    tups = [tup1, tup2, tup3, tup4, tup5, tup6, tup7, tup8, tup9, tup10, tup11, tup12, tup13, tup14]\n\n    for tup in tups:\n        print(max_min(tup))\n\n\nif __name__ == '__main__':\n    main()",
      -8.9140625
    ],
    [
      "class Solution(object):\n    def maxKSimilar(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        if not nums:\n            return []\n        if not k:\n            return nums\n        if k == 1:\n            return max(nums)\n        result = []\n        for n in nums:\n            if k == 2:\n                if n > nums[0]:\n                    result.append(n)\n                elif n == nums[0]:\n                    result.append(n)\n                    result.append(n)\n            elif k == 3:\n                if n > nums[0] and n > nums[1]:\n                    result.append(n)\n                elif n > nums[0] and n == nums[1]:\n                    result.append(n)\n                    result.append(n)\n                elif n > nums[1] and n == nums[0]:\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                elif n == nums[0] and n == nums[1]:\n                    result.append(n)\n                    result.append(n)\n            elif k > 3:\n                if n > nums[0]:\n                    result.append(n)\n                elif n == nums[0]:\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                elif n > nums[1]:\n                    result.append(n)\n                elif n == nums[1]:\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                elif n > nums[2]:\n                    result.append(n)\n                elif n == nums[2]:\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)\n                    result.append(n)",
      -9.7734375
    ],
    [
      "from collections import Counter\n\ndef k_max_min(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: Tuple[int, int]\n    \"\"\"\n    k_max_list = []\n    k_min_list = []\n\n    for tup in tuple_list:\n        k_max_list.append(max(tup))\n        k_min_list.append(min(tup))\n\n    return (max(k_max_list), min(k_min_list))\n\nif __name__ == \"__main__\":\n    tuple_list = [\n        (1,2,3),\n        (1,5,6),\n        (1,1,2),\n        (1,1,1),\n        (2,3,4),\n        (2,5,6),\n        (2,1,2),\n        (2,1,1),\n        (3,4,5),\n        (3,5,6),\n        (3,1,2),\n        (3,1,1),\n        (4,5,6),\n        (4,1,2),\n        (4,1,1),\n        (5,6,7),\n        (5,1,2),\n        (5,1,1),\n        (6,7,8),\n        (6,1,2),\n        (6,1,1),\n        (7,8,9),\n        (7,1,2),\n        (7,1,1),\n        (8,9,10),\n        (8,1,2),\n        (8,1,1),\n        (9,10,11),\n        (9,1,2),\n        (9,1,1),\n        (10,11,12),\n        (10,1,2),\n        (10,1,1),\n        (11,12,13),\n        (11,1,2),\n        (11,1,1),\n        (12,13,14),\n        (12,1,2),\n        (12,1,1),\n        (13,14,15),\n        (",
      -10.2421875
    ],
    [
      "import collections\n\n\ndef max_min_k(k, t):\n    \"\"\"\n    :type k: int\n    :type t: tuple\n    :rtype: tuple\n    \"\"\"\n    if k > len(t):\n        return t[0], t[0]\n    elif k == 1:\n        return t[0], t[0]\n    elif k > len(t):\n        return t[0], t[0]\n    elif k == 1:\n        return t[0], t[0]\n\n    if len(t) <= k:\n        return t[0], t[0]\n    else:\n        k_list = []\n        for i in range(k):\n            k_list.append(t[i])\n        max_list = []\n        min_list = []\n        for i in range(k, len(t)):\n            if t[i] > k_list[-1]:\n                max_list.append(t[i])\n                min_list.append(k_list[-1])\n            elif t[i] < k_list[-1]:\n                max_list.append(k_list[-1])\n                min_list.append(t[i])\n            else:\n                max_list.append(t[i])\n                min_list.append(k_list[-1])\n            k_list.append(t[i])\n        return max_list[-1], min_list[-1]\n\n\nif __name__ == \"__main__\":\n    # k = 2\n    # t = (1, 2, 3, 4, 5, 6)\n    # print(max_min_k(k, t))\n    k = 3\n    t = (1, 2, 3, 4, 5, 6)\n    print(max_min_k(k, t))",
      -10.3671875
    ],
    [
      "# https://leetcode.com/problems/maximum-and-minimum-k-elements-in-a-tuple/discuss/231533/Python-C-Solution-with-explanation\n\nclass Solution(object):\n    def maxAndMin(self, k, tuple):\n        \"\"\"\n        :type k: int\n        :type tuple: List[int]\n        :rtype: List[int]\n\n        Time complexity: O(n).\n        Space complexity: O(k).\n        \"\"\"\n        if not tuple:\n            return []\n        else:\n            return self.maxMin(k, tuple, 0, len(tuple) - 1)\n\n    def maxMin(self, k, tuple, start, end):\n        if start == end:\n            if k == 0:\n                return [tuple[start]]\n            else:\n                return [tuple[start], tuple[end]]\n        else:\n            mid = (start + end) / 2\n            left = self.maxMin(k, tuple, start, mid)\n            right = self.maxMin(k, tuple, mid + 1, end)\n            return self.max(left, right)\n\n    def max(self, left, right):\n        if left[0] > right[0]:\n            return left\n        else:\n            return right\n\nclass Solution2(object):\n    def maxAndMin(self, k, tuple):\n        \"\"\"\n        :type k: int\n        :type tuple: List[int]\n        :rtype: List[int]\n\n        Time complexity: O(n).\n        Space complexity: O(k).\n        \"\"\"\n        if not tuple:\n            return []\n        else:\n            return self.maxMin(k, tuple, 0, len(tuple) - 1)\n\n    def maxMin(self, k, tuple, start, end):\n        if start == end:\n            if k == 0:\n                return [tuple[start]]\n            else:\n                return [tuple[start], tuple[end]]\n        else:\n            mid = (start + end) / 2\n            left = self.maxMin(k, tuple, start, mid)\n            right = self.max",
      -10.7578125
    ],
    [
      "class Solution(object):\n    def getMaxMin(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if k == 0:\n            return [min(nums), max(nums)]\n        if len(nums) < k:\n            return [0, nums[0]]\n\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[left] and nums[mid] > nums[right]:\n                return [nums[mid], nums[mid]]\n            elif nums[mid] > nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        if left == right:\n            return [min(nums[left:]), max(nums[left:])]\n        else:\n            return [nums[left], nums[right]]",
      -12.7734375
    ],
    [
      "class Solution(object):\n    def maxAndMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Note: \n        # 1. O(n^2) solution.\n        # 2. If nums is sorted, the max and min can be found by counting the number of elements in the range [0,n-1].\n        # 3. If nums is not sorted, the max and min can be found by finding the first element and the last element,\n        #    and then count the number of elements in the range [first, last).\n        # 4. If nums is sorted, we can find the max and min by counting the number of elements in the range [0,k-1].\n        #    If nums is not sorted, we can find the max and min by counting the number of elements in the range [k,n-1].\n        # 5. If nums is sorted, we can use the binary search to find the first and last elements.\n        #    If nums is not sorted, we can use the binary search to find the first and last elements,\n        #    and then count the number of elements in the range [first, last).\n        # 6. If nums is sorted, we can use the binary search to find the first and last elements,\n        #    and then count the number of elements in the range [first, last).\n        if not nums:\n            return [0, 0]\n        elif len(nums) == 1:\n            return [nums[0], nums[0]]\n        elif len(nums) == 2:\n            return [nums[0], nums[1]]\n        elif len(nums) == 3:\n            return [nums[0], nums[1], nums[2]]\n        elif len(nums) == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        elif len(nums) == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        else:\n            return self.binary",
      -13.1953125
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, t):\n        self.data = t\n\n    def __str__(self):\n        return str(self.data)\n\n    def __cmp__(self, other):\n        return cmp(self.data, other.data)\n\n\nclass Solution(object):\n    def maxKSubarray(self, nums, k):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        min_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i][0])\n            min_sum = min(min_sum, nums[i][0])\n        max_sum = max(max_sum, min_sum)\n        min_sum = min(min_sum, max_sum)\n        return max(k, max_sum - min_sum)\n\n\nif __name__ == '__main__':\n    t = Tuple([2, 3, 1, 1, 4])\n    t = Tuple([-1, -2, -3])\n    t = Tuple([-1, -2, -3, -4])\n    t = Tuple([-1, -2, -3, -4, -5])\n    t = Tuple([-1, -2, -3, -4, -5, -6])\n    t = Tuple([-1, -2, -3, -4, -5, -6, -7])\n    t = Tuple([-1, -2, -3, -4, -5, -6, -7, -8])\n    t = Tuple([-1, -2, -3, -4, -5, -6, -7, -8, -9])\n    t = Tuple([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10])\n    t = Tuple([-1, -2, -3, -4, -5, -6, -7, -8",
      -13.328125
    ],
    [
      "from collections import namedtuple\n\nKV = namedtuple('KV', ['key', 'value'])\n\nclass Solution(object):\n    def findMaxMin(self, k, tuple):\n        \"\"\"\n        :type k: int\n        :type tuple: List[int]\n        :rtype: int\n        \"\"\"\n        return self._findMaxMin(k, tuple, [])\n\n    def _findMaxMin(self, k, tuple, curr):\n        if len(curr) < k:\n            return curr\n\n        for i in range(k):\n            if tuple[i] > curr[i]:\n                curr[i] = tuple[i]\n            elif tuple[i] < curr[i]:\n                curr[i] = tuple[i]\n\n        return self._findMaxMin(k, tuple, curr)\n\n\nif __name__ == '__main__':\n    assert Solution().findMaxMin(2, [3, 1, 2, 4, 5]) == [5, 4]\n    assert Solution().findMaxMin(2, [1, 2, 3, 4, 5]) == [5, 4]\n    assert Solution().findMaxMin(2, [1, 2, 3, 4]) == [3, 2]\n    assert Solution().findMaxMin(2, [1, 2]) == [1, 2]\n    assert Solution().findMaxMin(3, [3, 1, 2, 4, 5]) == [5, 4, 3]\n    assert Solution().findMaxMin(3, [1, 2, 3, 4, 5]) == [5, 4, 3]\n    assert Solution().findMaxMin(3, [1, 2, 3, 4]) == [1, 2, 3]\n    assert Solution().findMaxMin(3, [1, 2]) == [1, 2]",
      -13.421875
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def get_max_min(self, k, t):\n        \"\"\"\n        :type k: int\n        :type t: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_k_tuple = []\n        min_k_tuple = []\n        for i in range(len(t)):\n            if len(max_k_tuple) == k:\n                max_k_tuple.pop()\n            max_k_tuple.append(max(t[i], max_k_tuple[-1]))\n            if len(min_k_tuple) == k:\n                min_k_tuple.pop()\n            min_k_tuple.append(min(t[i], min_k_tuple[-1]))\n\n        return max_k_tuple, min_k_tuple\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# 2ms 98.94%\nclass Solution {\n    public int[] getMaxMin(int k, int[] t) {\n        int[] max_min = new int[2];\n        int[] max_k_tuple = new int[k];\n        int[] min_k_tuple = new int[k];\n        for (int i = 0; i < t.length; i++) {\n            if (max_k_tuple[k - 1] == Integer.MIN_VALUE) {\n                max_k_tuple[k - 1] = t[i];\n                min_k_tuple[k - 1] = t[i];\n            } else {\n                max_k_tuple[k - 1] = max(t[i], max_k_tuple[k - 1]);\n                min_k_tuple[k - 1] = min(t[i], min_k_tuple[k - 1]);\n            }\n        }\n        max_min[0",
      -14.3125
    ],
    [
      "class Solution(object):\n    def maxKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.helper(nums, k, 0)\n\n    def helper(self, nums, k, index):\n        if k == 0:\n            return [[nums[i] for i in range(index, len(nums))] ]\n\n        if index == len(nums):\n            return []\n\n        ret = []\n        for i in range(index, len(nums)):\n            if i == len(nums) - 1:\n                ret.append(self.helper(nums, k - 1, i))\n            else:\n                ret.append(self.helper(nums, k, i))\n\n        return ret\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxKSubsets([1,2,3,4,5,6], 3) == [[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5]]\n    assert Solution().maxKSubsets([1,2,3,4,5,6], 3) == [[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5]]\n    assert Solution().maxKSubsets([1,2,3,4,5,6], 3) == [[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5]]",
      -14.828125
    ],
    [
      "# https://leetcode.com/problems/maximum-and-minimum-k-elements-in-a-sorted-tuple/\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        l = len(nums)\n        if l == 0:\n            return 0\n        if k == 1:\n            return nums[0]\n        if k > l:\n            return self.findKthLargest(nums, l)\n        if k <= l/2:\n            return self.findKthLargest(nums, k)\n        else:\n            return self.findKthLargest(nums[:k-1], k-1)\n\n    def findKthLargest(self, nums, k):\n        l = len(nums)\n        i = 0\n        while i < l:\n            if nums[i] < nums[k-1]:\n                k -= 1\n            i += 1\n        return nums[k-1]\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findKthLargest([1, 2, 3, 4, 5, 6], 1))\n    print(s.findKthLargest([1, 2, 3, 4, 5, 6, 7], 2))",
      -15.21875
    ],
    [
      "# https://leetcode.com/problems/max-and-min-in-a-sorted-tuple/\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def getMaxMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n\n        res = [root.val]\n        if root.left is not None:\n            res.append(self.getMaxMin(root.left))\n        if root.right is not None:\n            res.append(self.getMaxMin(root.right))\n        return res\n\n    def getMaxMin2(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n\n        if root.left is None:\n            res = [root.val]\n        else:\n            res = self.getMaxMin(root.left)\n        res.append(root.val)\n        if root.right is None:\n            res.append(root.val)\n        else:\n            res.append(self.getMaxMin(root.right))\n        return res",
      -15.296875
    ],
    [
      "# https://leetcode.com/problems/maximum-subarray-sum/discuss/49142/C++-Python-Solution-using-two-pointers-with-memoization\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def maxSlidingWindow(self, nums, k):\n        # write your code here\n        if len(nums) == 0 or k == 0:\n            return []\n        # initialize\n        m, n, ans = 0, 0, []\n        memo = {}\n        for i in range(len(nums)):\n            if i < k:\n                m = max(m, nums[i])\n            else:\n                # update\n                if m in memo:\n                    ans.append(memo[m])\n                else:\n                    ans.append(m)\n                    memo[m] = nums[i - k + 1:i + 1]\n                # update\n                m = nums[i]\n            n += 1\n            # update\n            if n >= k:\n                m = max(m, nums[i - k + 1:i + 1])\n                n = 0\n        return ans\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxSlidingWindow([-2, 1, -3, 4, -1, 2, 1, -5, 4], 2))",
      -15.796875
    ],
    [
      "# https://leetcode.com/problems/minimum-and-maximum-element-in-a-sorted-matrix/discuss/4416/Python-solution-with-explanation\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findMaxMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return [0, 0]\n\n        left = self.findMaxMin(root.left)\n        right = self.findMaxMin(root.right)\n\n        if root.val > left[0] and root.val > right[0]:\n            return [root.val, root.val]\n\n        if root.val < left[0]:\n            left[0] = root.val\n        if root.val < right[0]:\n            right[0] = root.val\n\n        if root.val > left[1]:\n            left[1] = root.val\n        if root.val > right[1]:\n            right[1] = root.val\n\n        return left + right\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.left.right.left = TreeNode(6)\n    root.left.right.right = TreeNode(7)\n    root.right.left = TreeNode(8)\n    root.right.right = TreeNode(9)\n    root.right.left.left = TreeNode(10)\n    root.right.left.right = TreeNode(11)\n\n    s = Solution()\n    print s.findMaxMin(root)",
      -16.09375
    ],
    [
      "from collections import Counter\nclass Solution(object):\n    def maxKSubsets(self, k, arr):\n        \"\"\"\n        :type k: int\n        :type arr: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        counter = Counter(arr)\n        return self.get_max_subsets(k, counter, [], [])\n\n    def get_max_subsets(self, k, counter, subset, solution):\n        if k == 0:\n            if len(subset) == 1:\n                solution.append(subset[0])\n            return solution\n        for item in counter.keys():\n            if len(subset) < k:\n                subset.append(item)\n                self.get_max_subsets(k - len(subset), counter, subset, solution)\n                subset.pop()\n            else:\n                if counter[item] > counter[subset[-1]]:\n                    solution.append(subset)\n                self.get_max_subsets(k, counter, subset[:-1], solution)\n                subset.pop()\n        return solution\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9,10]\n    solution = Solution().maxKSubsets(3, arr)\n    print(solution)",
      -18.625
    ],
    [
      "# -*- coding: utf-8 -*-\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n     def __init__(self, x):\n         self.val = x\n         self.left = None\n         self.right = None\n\"\"\"\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    # @param root, a tree node\n    # @param k, an integer\n    # @return a list of k integers\n    def kthSmallest(self, root, k):\n        res = []\n        self.helper(root, k, res)\n        return res\n\n    def helper(self, node, k, res):\n        if not node:\n            return\n        if len(res) == k:\n            res.append(node.val)\n        else:\n            self.helper(node.left, k, res)\n            self.helper(node.right, k, res)",
      -19.234375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}