{
  "problem": {
    "task_id": "MBPP/206",
    "prompt": "Write a function to perform the adjacent element concatenation in the given tuples.",
    "canonical_solution": "def concatenate_elements(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ",
    "test_list": [
      "assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')",
      "assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == ('RES IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL QESR')",
      "assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == ('MSAMIS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL SKD')"
    ],
    "challenge_test_list": [],
    "problem_id": 195
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Solution:\n    # @param {List[Tuple[int]]} nums\n    # @return {Tuple[int]}\n    def getConcatenatedElement(self, nums):\n        if not nums:\n            return None\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return (nums[0][0], nums[1][1])\n        ans = (nums[0][0], nums[0][1])\n        for i in range(1, n):\n            ans = (ans[0], nums[i][1])\n            ans = (ans[0], nums[i][1])\n        return ans\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.getConcatenatedElement([(1,2),(3,4)]))\n    print(sol.getConcatenatedElement([(1,2),(3,4),(5,6)]))\n    print(sol.getConcatenatedElement([(1,2),(3,4),(5,6),(7,8)]))",
      2.458984375
    ],
    [
      "def adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return [tuple(sorted(t)) for t in zip(*tuples)]\n\n\nif __name__ == \"__main__\":\n    t = [(1, 2), (3, 4), (5, 6)]\n    assert adjacent_element_concatenation(t) == [\n        (1, 2, 3, 4),\n        (3, 4, 5, 6)\n    ]\n    t = [(1, 2), (3, 4), (5, 6)]\n    assert adjacent_element_concatenation(t) == [\n        (1, 2, 3, 4),\n        (3, 4, 5, 6)\n    ]",
      1.16015625
    ],
    [
      "# https://leetcode.com/problems/adjacent-element-concatenation/\n\nclass Solution(object):\n    def concat(self, iterable):\n        \"\"\"\n        :type iterable: List[tuple]\n        :rtype: List[str]\n        \"\"\"\n        return \"\".join(list(map(lambda x: \"\".join(x), iterable)))",
      0.98193359375
    ],
    [
      "class Solution(object):\n    def getConcatenated(self, tuples):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for t in tuples:\n            ret.append(t[0])\n            for i in range(1, len(t)):\n                ret.append(t[i])\n        return ret",
      0.13134765625
    ],
    [
      "class Solution:\n    # @param {List[List[int]]} tuples\n    # @return {List[int]}\n    def concat(self, tuples):\n        res = []\n        for t in tuples:\n            res += t\n        return res",
      0.0352783203125
    ],
    [
      "# https://leetcode.com/problems/concatenated-strings/\n# Given a list of strings, concatenate all the strings into one long string.\n# Note:\n# All of the given strings' lengths will not exceed 100.\n# Example 1:\n# Input: [\"Hello\", \"World\"]\n# Output: \"HelloWorld\"\n# Example 2:\n# Input: [\"apple\", \"banana\", \"lemon\"]\n# Output: \"applebananalemon\"\n\n# Note:\n# The order of the input strings do not matter.\n\nclass Solution(object):\n    def concatenate(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        s = ''\n        for str in strs:\n            s += str\n        return s\n\n    # Note:\n    # It's not a good idea to use the list to keep track of the position of each string.\n    # Instead, we can use a hash table to keep track of the position.\n    # We can use a hash table to keep track of the position of each string.\n    # If we keep track of the position of each string, we can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each string.\n    # If we keep track of the position of each string, we can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each string.\n    # We can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each string.\n    # We can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each string.\n    # We can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each string.\n    # We can use a hash table to keep track of the position of all the strings.\n    # We can use a hash table to keep track of the position of each",
      -0.354736328125
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution:\n    def getConcat(self, tuples: List[Tuple]) -> str:\n        def get(i):\n            if i == len(tuples):\n                return str(tuples[-1])\n            return str(tuples[i]) + \",\" + get(i+1)\n        return get(0)",
      -0.85693359375
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return [t for t in tuple_list if len(t) > 1]\n\n\ndef main():\n    \"\"\"\n    Example:\n    >>> adjacent_element_concatenation([(1, 2), (3, 4), (5, 6)])\n    [(1, 2, 3, 4, 5, 6)]\n    \"\"\"\n    tuple_list = [\n        (1, 2),\n        (3, 4),\n        (5, 6)\n    ]\n    print(adjacent_element_concatenation(tuple_list))\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, tup):\n        self.tup = tup\n\n    def __eq__(self, other):\n        return self.tup == other.tup\n\nclass Solution(object):\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in range(len(nums) - 1):\n            if i == 0 or nums[i]!= nums[i - 1]:\n                result.append(nums[i])\n        return result",
      -0.85693359375
    ],
    [
      "from collections import namedtuple\n\ndef adjacent_concatenation(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    tuple_list = sorted(tuple_list, key=lambda x: x[0])\n    tuple_list.append((0, 0))\n    tuple_list = sorted(tuple_list, key=lambda x: x[1])\n    return tuple_list",
      -0.85693359375
    ],
    [
      "from collections import namedtuple\n\nAdjacentElementTuple = namedtuple('AdjacentElementTuple', 'first second')\n\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: Iterable[AdjacentElementTuple]\n    :rtype: Iterable[str]\n    \"\"\"\n    for first, second in tuples:\n        yield str(first) + str(second)\n\n\ndef main():\n    tuples = (\n        AdjacentElementTuple(1, 2),\n        AdjacentElementTuple(2, 3),\n        AdjacentElementTuple(4, 5),\n    )\n    print(adjacent_element_concatenation(tuples))\n\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def concat(self, iterable):\n        \"\"\"\n        :type iterable: List[tuple]\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for item in iterable:\n            if item[0] is None:\n                result.append(str(item[1]))\n            else:\n                result.append(item[0] + str(item[1]))\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/concatenated-strings/solution/\n\n# 1ms 100%\nclass Solution {\n    public List<String> concat(List<Tuple> tuples) {\n        List<String> result = new ArrayList<>();\n        for (Tuple tuple : tuples) {\n            if (tuple.getFirst() == null) {\n                result.add(String.valueOf(tuple.getSecond()));\n            } else {\n                result.add(tuple.getFirst() + String.valueOf(tuple.getSecond()));\n            }\n        }\n        return result;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<String> concat(List<Tuple> tuples) {\n        List<String> result = new ArrayList<>();\n        for (Tuple tuple : tuples) {\n            if (tuple.getFirst() == null) {\n                result.add(tuple.getSecond().toString());\n            } else {\n                result.add(tuple.getFirst() + tuple.getSecond().toString());\n            }\n        }\n        return result;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<String> concat(List<Tuple> tuples) {\n        List<String> result = new ArrayList<>();\n        for (Tuple tuple : tu",
      -0.857421875
    ],
    [
      "def adjacent_element_concat(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    return [t[0] for t in tuples]",
      -0.85791015625
    ],
    [
      "def adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    return [tup[-1] for tup in tuples]",
      -0.85791015625
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __str__(self):\n        return str(self.x)\n\n\nclass Solution(object):\n    def concat(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: str\n        \"\"\"\n        res = []\n        for t in tuples:\n            if t.y == 0:\n                res.append(str(t.x))\n            else:\n                res.append(str(t.x) + str(t.y))\n            t.y = 0\n        return \"\".join(res)",
      -0.85791015625
    ],
    [
      "# https://www.hackerrank.com/challenges/tuple-concatenation\n\ndef tupleConcatenation(t):\n    # Write your code here\n    # Convert tuple to list\n    t = list(t)\n    # Create a new list\n    new = []\n    # Iterate through the list\n    for i in range(0, len(t)):\n        # Append the value of the current element\n        new.append(t[i])\n        # If current element is the last element in the tuple,\n        # append the value of the next element in the tuple\n        if (i + 1 == len(t)):\n            new.append(t[i + 1])\n    # Return the new list\n    return new\n\n\nif __name__ == \"__main__\":\n    t = (1, 2, 3, 4, 5, 6)\n    print(tupleConcatenation(t))",
      -0.85791015625
    ],
    [
      "from collections import namedtuple\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    def adjacent_element_concatenation_rec(tuples, current_index):\n        if current_index < len(tuples) - 1:\n            next_index = current_index + 1\n            next_item = tuples[next_index]\n            if type(next_item) is tuple:\n                return adjacent_element_concatenation_rec(tuples, next_index)\n            else:\n                return tuple(tuples[current_index:next_index]) + (next_item,)\n        else:\n            return tuples\n\n    return adjacent_element_concatenation_rec(tuples, 0)\n\ndef test_adjacent_element_concatenation():\n    tuples = [\n        (\"a\", \"b\"),\n        (\"c\", \"d\"),\n        (\"e\", \"f\")\n    ]\n\n    assert adjacent_element_concatenation(tuples) == [\n        (\"a\", \"b\"),\n        (\"c\", \"d\"),\n        (\"e\", \"f\")\n    ]\n\nif __name__ == '__main__':\n    test_adjacent_element_concatenation()",
      -0.85791015625
    ],
    [
      "class Solution:\n    def getConcat(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        l, r = len(A), len(B)\n        res = []\n        for i in range(l):\n            for j in range(r):\n                res.append(A[i] + B[j])\n        return res",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param {List[T]} nums\n    # @return {String}\n    def getAdjacent(self, nums):\n        # Write your code here\n        if not nums:\n            return ''\n        s = ''\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                s += str(nums[i])\n            else:\n                s += str(nums[i]) + str(nums[i - 1])\n        return s\n\ns = Solution()\n\nprint s.getAdjacent([1, 2, 3])",
      -0.85791015625
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.next is None:\n            self.next = Tuple(self.x)\n        return self.next.x\n\nclass Solution(object):\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[Tuple[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            tmp = []\n            for j in range(len(nums)):\n                if i == j:\n                    continue\n                if nums[j].x < nums[i].x:\n                    tmp.append(nums[j].x)\n                else:\n                    tmp.append(nums[i].x)\n            res.append(reduce(lambda x, y: x + y, tmp))\n        return res",
      -0.85791015625
    ],
    [
      "def adjacent_concat(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # time complexity: O(n)\n    # space complexity: O(n)\n    result = []\n    for i in range(len(tuples) - 1):\n        if tuples[i][0] == tuples[i+1][0]:\n            result.append(tuples[i][0] * (tuples[i+1][1] + tuples[i+1][2]))\n    return result",
      -0.85791015625
    ],
    [
      "import sys\n\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    for i, t in enumerate(tuples):\n        for j in range(i + 1, len(tuples)):\n            tuples.append(tuple(list(t) + list(tuples[j])))\n    return tuples\n\nif __name__ == '__main__':\n    t = tuple(map(int, input().split()))\n    print(adjacent_concatenation([t]))",
      -0.85791015625
    ],
    [
      "import collections\n\n\nclass Solution:\n    \"\"\"\n    @param tuples: a list of tuples\n    @return: a list of strings\n    \"\"\"\n    def concatenate(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[str]\n        \"\"\"\n        return collections.defaultdict(list).fromkeys(tuples).values()",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def adjacentSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        l, r = 0, len(nums) - 1\n        while l < r:\n            if nums[l] + nums[r] == nums[l + 1]:\n                l += 1\n            elif nums[l] + nums[r] < nums[l + 1]:\n                r -= 1\n            else:\n                return nums[l] + nums[r]\n        return nums[l] + nums[r]",
      -0.85791015625
    ],
    [
      "from collections import namedtuple\n\nTuple = namedtuple(\"Tuple\", \"a b\")\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    \n    result = []\n    for tup in tuples:\n        result.append(tup)\n        if tup.b:\n            result.append(tup.a)\n    return result",
      -0.85791015625
    ],
    [
      "# https://leetcode.com/problems/concatenated-strings/discuss/69892/Python-O(n)-Time-Solution-with-Java-and-C\n# https://leetcode.com/problems/concatenated-strings/discuss/72454/Python-O(n)-Time-Solution-with-Java-and-C\n# https://leetcode.com/problems/concatenated-strings/discuss/72454/Python-O(n)-Time-Solution-with-Java-and-C\n\nfrom collections import namedtuple\n\n\ndef adjacent_element_concatenation(tuples: tuple) -> str:\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: str\n    \"\"\"\n    Tuple = namedtuple('Tuple', ['a', 'b'])\n\n    def adjacent_element_concatenation(tuples: tuple) -> str:\n        result = ''\n        for t in tuples:\n            result += str(t.a) + str(t.b) +''\n        return result[:-1]\n\n    return adjacent_element_concatenation(tuples)",
      -0.85791015625
    ],
    [
      "def adjacent_concatenation(tuples):\n    # write your code here\n    if not tuples:\n        return tuple()\n    \n    result = []\n    for t in tuples:\n        result.extend(t)\n    \n    return tuple(result)\n\nif __name__ == \"__main__\":\n    assert adjacent_concatenation([(1, 2), (3, 4, 5)]) == tuple(range(1, 6))\n    assert adjacent_concatenation([(1, 2), (3, 4, 5), (6, 7)]) == tuple(range(1, 8))\n    assert adjacent_concatenation([(1, 2), (3, 4, 5), (6, 7), (8, 9)]) == tuple(range(1, 10))\n    assert adjacent_concatenation([(1, 2), (3, 4, 5), (6, 7), (8, 9), (10, 11)]) == tuple(range(1, 12))",
      -0.8583984375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, tup):\n        self.tup = tup\n    def __str__(self):\n        return str(self.tup)\n\nclass Solution(object):\n    def getConcat(self, arr):\n        \"\"\"\n        :type arr: List[Tuple]\n        :rtype: str\n        \"\"\"\n        ret = \"\"\n        for tup in arr:\n            ret += str(tup)\n        return ret\n\n    def getConcat1(self, arr):\n        ret = \"\"\n        for tup in arr:\n            ret += str(tup)\n        return ret\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.getConcat([])\n    print sol.getConcat([(1,2,3),(1,2,3)])\n    print sol.getConcat1([(1,2,3),(1,2,3)])\n    print sol.getConcat1([(1,2,3),(1,2,3)])",
      -0.8583984375
    ],
    [
      "import collections\n\n\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: tuple\n    \"\"\"\n    concatenated = tuple(map(lambda t: t[0], tuples))\n    return concatenated\n\n\nif __name__ == '__main__':\n    tuples = (('a', 'b'), ('c', 'd'), ('e', 'f'))\n    assert adjacent_concatenation(tuples) == ('ab', 'cd', 'ef')",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/adjacency-list-concatenation\ndef adjacent_element_concatenation(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return ''.join(result)\n\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(adjacent_element_concatenation(tuples))",
      -0.8583984375
    ],
    [
      "import collections\n\ndef adjacent_concat(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: tuple\n    \"\"\"\n    return tuple(collections.ChainMap(*tuples).values())",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @return a tuple, (index1, index2)\n    def getTwoIndices(self, nums):\n        length = len(nums)\n        if length == 0:\n            return (0, 0)\n        if length == 1:\n            return (0, length)\n        if length == 2:\n            return (length - 1, length - 1)\n        \n        if nums[0] > nums[1]:\n            return (0, length - 1)\n        elif nums[0] < nums[1]:\n            return (length - 1, length - 1)\n        else:\n            return (length - 1, length - 2)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def adjacentSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        prev = nums[0]\n        for i in range(1, len(nums)):\n            curr = nums[i]\n            if curr == prev + nums[i - 1]:\n                prev = curr\n            else:\n                return prev\n        return prev",
      -0.8583984375
    ],
    [
      "from typing import List, Tuple\n\nclass Solution(object):\n    def adjacentSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 1):\n            if nums[i] + nums[i + 1] == nums[i + 2]:\n                result.append(nums[i] + nums[i + 1] + nums[i + 2])\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sol.adjacentSum(nums))",
      -0.8583984375
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int,...]]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    t = collections.defaultdict(list)\n    for tup in tuples:\n        t[tup[0]].append(tup)\n    return [tup for tup in t.items() if len(tup[1]) > 1]\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2, 3), (1, 3, 4), (2, 3, 4), (2, 4, 5), (3, 4, 5), (3, 5, 6)]\n    print adjacent_element_concatenation(tuples)",
      -0.8583984375
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def adjacent(self, nums, target):\n        \"\"\"\n        :type nums: List[Tuple]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if nums is None or len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            if nums[0] == target:\n                return 1\n            else:\n                return 0\n\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i].x == target:\n                return i + 1\n        return 0\n\nif __name__ == '__main__':\n    print Solution().adjacent([(1,2),(3,4)], 3)",
      -0.8583984375
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for t in tuples:\n        for i in range(len(t)):\n            result.append(t[i])\n    return result\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [4, 5], [6, 7, 8]]\n    print adjacent_element_concatenation(tuples)\n    tuples = [[1], [2, 3], [4], [5, 6, 7, 8]]\n    print adjacent_element_concatenation(tuples)\n    tuples = [[1, 2, 3, 4, 5], [6, 7, 8], [9]]\n    print adjacent_element_concatenation(tuples)\n    tuples = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\n    print adjacent_element_concatenation(tuples)\n    tuples = [[1, 2], [3, 4, 5], [6, 7, 8, 9, 10]]\n    print adjacent_element_concatenation(tuples)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def getConcat(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not A: return []\n\n        length = len(A)\n        ret = []\n        i = 0\n        while i < length:\n            j = i\n            while j < length and A[i][0] == A[j][0]:\n                j += 1\n            ret.append(A[i][0] * (j - i))\n            i = j\n        return ret\n\n\nif __name__ == \"__main__\":\n    assert Solution().getConcat([[1,2], [3,4]]) == [1, 2, 3, 4]\n    assert Solution().getConcat([[1,2], [3,4,5]]) == [1, 2, 3, 4, 5]\n    assert Solution().getConcat([]) == []",
      -0.8583984375
    ],
    [
      "import collections\n\n\nclass Tuple(object):\n    def __init__(self, elements):\n        self.elements = elements\n\n    def __add__(self, other):\n        return Tuple(self.elements + other.elements)\n\n    def __str__(self):\n        return str(self.elements)\n\n\ndef adjacent_elements_concatenation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[Tuple]\n    :rtype: Tuple\n    \"\"\"\n    return Tuple(sum(t.elements for t in tuples))\n\n\nif __name__ == '__main__':\n    tuples = [Tuple(['a', 'b', 'c']), Tuple(['d', 'e', 'f']), Tuple(['g', 'h', 'i'])]\n    print adjacent_elements_concatenation(tuples)",
      -0.8583984375
    ],
    [
      "def adjacent_elements_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    result = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            result.append(tuples[i][0] + tuples[j][0])\n    return result\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (2, 3), (3, 4), (4, 5)]\n    print(adjacent_elements_concatenation(tuples))",
      -0.8583984375
    ],
    [
      "def adjacent_element_concatenation(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: List[int]\n    \"\"\"\n    \n    if not tuple_list:\n        return []\n\n    result = []\n\n    for i in range(len(tuple_list)):\n        if i == 0 or tuple_list[i-1][0]!= tuple_list[i][0]:\n            result.append(tuple_list[i][0])\n        if i == 0 or tuple_list[i-1][1]!= tuple_list[i][1]:\n            result.append(tuple_list[i][1])\n\n    return result",
      -0.85888671875
    ],
    [
      "def adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            tuples[i] += tuples[j]\n    return tuples\n\nif __name__ == '__main__':\n    tuples = [(1,2),(3,4),(5,6)]\n    print adjacent_element_concatenation(tuples)",
      -0.85888671875
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\nclass Solution:\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for n in nums:\n            cur = n\n            while cur.next:\n                cur = cur.next\n                result.append(cur.x)\n        return result",
      -0.85888671875
    ],
    [
      "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\nclass Solution:\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return nums\n        t = Tuple(nums[0])\n        ans = [0] * n\n        for i in range(1, n):\n            t.next = Tuple(nums[i])\n            while t.next:\n                ans[i] = ans[i-1] + t.next.x\n                t = t.next\n                if t.next:\n                    t.next = Tuple(nums[i+1])\n                else:\n                    break\n        return ans",
      -0.85888671875
    ],
    [
      "def adjacent_element_concatenation(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for t in tuple_list:\n        for i in range(len(t) - 1):\n            result.append(t[i] + t[i + 1])\n    return result\n\n# Your AdjacentElementConcatenation object will be instantiated and called as such:\n# obj = AdjacentElementConcatenation()\n# param_1 = obj.adjacent_element_concatenation([[1, 2], [3]])",
      -0.85888671875
    ],
    [
      "# https://leetcode.com/problems/concatenated-string/\n# https://leetcode.com/problems/concatenated-string-ii/\n\nclass Solution:\n    # @param {List[List[str]]} strs\n    # @return {List[str]}\n    def concatenate(self, strs):\n        result = []\n        for s in strs:\n            result.append(\"\".join(s))\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    strs = [['ab', 'cd', 'ef'], ['gh', 'ij', 'kl'], ['mn', 'op', 'qr']]\n    print(s.concatenate(strs))",
      -0.85888671875
    ],
    [
      "class Solution:\n    def getConcat(self, tuples: List[List[int]]) -> List[int]:\n        if not tuples:\n            return []\n        if len(tuples) == 1:\n            return tuples[0]\n        res = []\n        for t in tuples:\n            res = [t[0]] + res + t[1:]\n        return res",
      -0.85888671875
    ],
    [
      "# https://leetcode.com/problems/concatenated-adjacent-sequences/description/\n\nimport collections\n\n\ndef adjacent_tuple(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            result.append(' '.join(tuple_list[i] + tuple_list[j]))\n    return result\n\n\nclass Solution(object):\n    def adjacent_tuple(self, tuples):\n        \"\"\"\n        :type tuples: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def adjacent_tuple_helper(tuple_list):\n            if len(tuple_list) == 0:\n                return []\n            result = []\n            for i in range(len(tuple_list) - 1):\n                for j in range(i + 1, len(tuple_list)):\n                    result.append(tuple_list[i] + tuple_list[j])\n            return result\n        return adjacent_tuple_helper(tuples)\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.adjacent_tuple([1, 2, 3, 4])",
      -0.85888671875
    ],
    [
      "def adjacent_tuple_concatenation(tuples):\n    # write your code here\n    # return the adjacent elements in the given tuple, and return a list\n    if not tuples:\n        return []\n\n    ret = []\n    for i in range(len(tuples) - 1):\n        ret.append(tuples[i][0] + tuples[i + 1][0])\n\n    return ret",
      -0.86083984375
    ],
    [
      "# Your code here\n\n#\n#\n#\n#\n\ndef adjacent_concat(t1, t2):\n\tif len(t1)!= len(t2):\n\t\treturn None\n\telse:\n\t\treturn ','.join(map(str,t1 + t2))\n\nif __name__ == \"__main__\":\n\tprint adjacent_concat(('a','b','c'),('d','e','f'))\n\tprint adjacent_concat(('a','b','c'),('d','e','f','g'))",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def getConcat(self, arr):\n        \"\"\"\n        :type arr: List[Tuple[int]]\n        :rtype: List[str]\n        \"\"\"\n        return self.getConcatSlow(arr)\n\n    def getConcatSlow(self, arr):\n        if not arr:\n            return []\n        # TODO:\n        return arr\n\n    def getConcatSlow2(self, arr):\n        # TODO:\n        return arr",
      -0.86083984375
    ],
    [
      "class Solution:\n    # @param A, a list of lists of integers\n    # @return a string\n    def getIntersection(self, A):\n        if not A:\n            return \"\"\n\n        # get the first and last item of the first list\n        first, last = A[0][0], A[0][-1]\n\n        for i in range(1, len(A)):\n            # get the first and last item of the next list\n            first, last = min(first, A[i][0]), max(last, A[i][-1])\n\n        # get the length of the intersection\n        inter = last - first + 1\n\n        # get the list of numbers to concatenate\n        ret = []\n        for i in range(first, last + 1):\n            ret.append(i)\n\n        return \"\".join(str(i) for i in ret)\n\nif __name__ == \"__main__\":\n    A = [[1, 2, 3], [4, 5, 6]]\n    print Solution().getIntersection(A)",
      -0.9052734375
    ],
    [
      "import collections\n\ndef adjacent_concat(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_2(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_3(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_4(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_5(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_6(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_7(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return result\n\ndef adjacent_concat_8(tuples):\n    result = []\n    for t in tuples:\n        result.append(t[0])\n        for i in range(1, len(t)):\n            result.append(t[i])\n    return",
      -0.9140625
    ],
    [
      "import collections\n\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: tuple\n    \"\"\"\n    return tuple(itertools.chain(*tuples))\n\n\nif __name__ == '__main__':\n    assert adjacent_element_concatenation(((1, 2), (3, 4))) == (1, 2, 3, 4)\n    assert adjacent_element_concatenation(((1, 2), (3, 4), (5, 6))) == (1, 2, 3, 4, 5, 6)\n    assert adjacent_element_concatenation(((1, 2), (3, 4), (5, 6), (7, 8))) == (1, 2, 3, 4, 5, 6, 7, 8)\n    assert adjacent_element_concatenation(((1, 2), (3, 4), (5, 6), (7, 8), (9, 10))) == (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)",
      -1.08984375
    ],
    [
      "class Solution(object):\n    def getConcat(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return ''\n        if n == 1:\n            return str(nums[0])\n        result = ''\n        for i in xrange(1, n):\n            result += str(nums[i-1]) + str(nums[i])\n        return result[::-1]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.getConcat([1, 2, 3, 4, 5])\n    print s.getConcat([])\n    print s.getConcat([1, 2, 3, 4, 5, 6, 7, 8])\n    print s.getConcat([1, 2, 3, 4, 5, 6, 7, 8, 9])",
      -1.2451171875
    ],
    [
      "def adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    if len(tuples) < 2:\n        return tuples\n    \n    result = []\n    for i in range(len(tuples)):\n        if i == 0 or tuples[i-1][1]!= tuples[i][0]:\n            result.append(tuples[i])\n    \n    for i in range(len(tuples)):\n        if i == len(tuples) - 1 or tuples[i+1][0]!= tuples[i][1]:\n            result.append(tuples[i])\n    \n    return result\n\ndef test_adjacent_concatenation():\n    tuples = [(1, 2), (2, 3), (3, 4)]\n    assert adjacent_concatenation(tuples) == [1, 2, 3, 4]\n\nif __name__ == \"__main__\":\n    test_adjacent_concatenation()",
      -1.4306640625
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def concat(self, iterable):\n        \"\"\"\n        :type iterable: List[Tuple[int, int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for item in iterable:\n            res.append(item[0])\n            res.append(item[1])\n        return res\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/concatenated-adjacent-elements/solution/\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> concat(List<Tuple<Integer, Integer>> iterable) {\n        List<Integer> res = new LinkedList<>();\n        for (Tuple<Integer, Integer> item : iterable) {\n            res.add(item.getX());\n            res.add(item.getY());\n        }\n        return res;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> concat(List<Tuple<Integer, Integer>> iterable) {\n        List<Integer> res = new ArrayList<>();\n        for (Tuple<Integer, Integer> item : iterable) {\n            res.add(item.getX());\n            res.add(item.getY());\n        }\n        return res;\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public List<Integer> concat(List<Tuple<Integer, Integer>> iterable) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < iterable.size(); i++) {\n            Tuple<Integer, Integer> item = iterable.get(i);\n            res.add(item.getX());\n            if (i < iterable.size() - 1) {\n                res.add(item.getY());\n            }\n        }",
      -1.5048828125
    ],
    [
      "# Approach 1: Brute force\ndef adjacent_concat(tuples):\n    if not tuples:\n        return ()\n    result = []\n    for i in range(len(tuples) - 1):\n        result.append(tuples[i][0] + tuples[i + 1][0])\n    result.append(tuples[-1][0] + tuples[0][0])\n    return tuple(result)\n\n# Approach 2: Recursion\ndef adjacent_concat_rec(tuples):\n    if not tuples:\n        return ()\n    result = []\n    for i in range(len(tuples) - 1):\n        result.append(tuples[i][0] + tuples[i + 1][0])\n    result.append(tuples[-1][0] + tuples[0][0])\n    return tuple(result)\n\n# Approach 3: DFS\ndef adjacent_concat_dfs(tuples):\n    if not tuples:\n        return ()\n    result = []\n    for i in range(len(tuples) - 1):\n        result.append(tuples[i][0] + tuples[i + 1][0])\n    result.append(tuples[-1][0] + tuples[0][0])\n    return tuple(result)\n\n# Approach 4: Recursion\ndef adjacent_concat_rec_1(tuples):\n    if not tuples:\n        return ()\n    result = []\n    for i in range(len(tuples) - 1):\n        result.append(tuples[i][0] + tuples[i + 1][0])\n    result.append(tuples[-1][0] + tuples[0][0])\n    return tuple(result)\n\n# Approach 4: Recursion\ndef adjacent_concat_rec_2(tuples):\n    if not tuples:\n        return ()\n    result = []\n    for i in range(len(tuples) - 1):\n        result.append(tuples[i][0] + tuples[i + 1][0])\n    result.append(tuples[-1][0] + tuples[0][0])",
      -1.576171875
    ],
    [
      "# https://leetcode.com/problems/concatenated-strings/discuss/157927/Python-DP-Solution\n\nclass Solution(object):\n    def concatenate(self, iterable):\n        \"\"\"\n        :type iterable: List[tuple]\n        :rtype: str\n        \"\"\"\n        iterable = list(iterable)\n        if not iterable:\n            return ''\n\n        def dfs(i, j, s):\n            if i == len(iterable) or j == len(iterable[i]):\n                return s\n            else:\n                return dfs(i, j + 1, s + iterable[i][j])\n\n        return dfs(0, 0, '')",
      -1.8837890625
    ],
    [
      "def adjacent_concatenation(t):\n    \"\"\"\n    :type t: List[Tuple[int, int]]\n    :rtype: List[int]\n    \"\"\"\n    return [sum(t),]\n\nif __name__ == \"__main__\":\n    print(adjacent_concatenation([(1, 2), (3, 4)]))\n    print(adjacent_concatenation([(1, 2), (2, 3), (3, 4), (4, 5)]))",
      -1.9853515625
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        res = []\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                res.append(nums[i] + nums[j])\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/adjacent-element-concatenation/solution/\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> adjacentElements(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                res.add(nums[i] + nums[j]);\n            }\n        }\n        return res;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public List<Integer> adjacentElements(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                res.add(nums[i] + nums[j]);\n            }\n        }\n        return res;\n    }\n}\n'''",
      -2.05859375
    ],
    [
      "import unittest\n\nfrom solution import adjacent_element_concatenation\n\n\nclass TestAdjacentElementConcatenation(unittest.TestCase):\n    def test_adjacent_element_concatenation(self):\n        self.assertEqual(adjacent_element_concatenation([]), [])\n        self.assertEqual(adjacent_element_concatenation([(1, 2)]), [(1, 2)])\n        self.assertEqual(adjacent_element_concatenation([(1, 2), (3, 4)]), [(1, 2), (3, 4)])\n        self.assertEqual(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6)]), [(1, 2), (3, 4), (5, 6)])\n        self.assertEqual(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8)]), [(1, 2), (3, 4), (5, 6), (7, 8)])\n\nif __name__ == '__main__':\n    unittest.main()",
      -2.380859375
    ],
    [
      "def adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    \n    result = []\n    \n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            result.append(tuples[i][0] + tuples[j][1])\n    \n    return result\n\nprint(adjacent_element_concatenation([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\nprint(adjacent_element_concatenation([[1, 2], [3, 4], [5, 6]]))\nprint(adjacent_element_concatenation([[1, 2], [3, 4], [5, 6], [7, 8]]))\nprint(adjacent_element_concatenation([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))",
      -2.81640625
    ],
    [
      "import unittest\n\n# https://www.hackerrank.com/challenges/tuple-concatenation-ii/problem\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    Returns the adjacent element concatenation of a given list of tuples.\n\n    :param tuples: List of tuples.\n\n    :rtype: Tuple.\n\n    Concatenates adjacent elements in the given list of tuples.\n\n    Example\n    >>> adjacent_element_concatenation([(1, 2), (3, 4), (5, 6)])\n    (1, 2, 3, 4, 5, 6)\n    \"\"\"\n    # Your code here\n    res = []\n    for tup in tuples:\n        for i in range(1, len(tup)):\n            res.append(tup[i-1])\n    return tuple(res)\n\n\nclass Tests(unittest.TestCase):\n    def test_adjacent_element_concatenation(self):\n        tuples = [(1, 2), (3, 4), (5, 6)]\n        self.assertEqual(adjacent_element_concatenation(tuples), (1, 2, 3, 4, 5, 6))\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -2.865234375
    ],
    [
      "import sys\nimport os\n\n# Complete the adjacentElementConcatenation function below.\ndef adjacentElementConcatenation(tuples):\n    if len(tuples) == 0:\n        return \"\"\n    elif len(tuples) == 1:\n        return str(tuples[0])\n    else:\n        # if the first tuple has only one element, return the concatenation of the rest tuples\n        if len(tuples[0]) == 1:\n            return \"\".join([str(t) for t in tuples[1:]])\n        else:\n            # if the first tuple has more than one element, return the concatenation of the first element with the rest tuples\n            return str(tuples[0][0]) + \"\".join([str(t) for t in tuples[1:]])\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    tuples = [(1,2,3,4),(5,6,7,8),(9,10,11,12)]\n\n    fptr.write(\" \".join(map(str, adjacentElementConcatenation(tuples))))\n    fptr.write('\\n')\n\n    fptr.close()",
      -3.07421875
    ],
    [
      "# https://leetcode.com/problems/concatenated-strings/discuss/252561/Python-Solution-with-explanation-using-recursion\n\nimport unittest\n\nclass Solution:\n    def concatenate(self, strs):\n        \"\"\"\n        :type strs: List[List[str]]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        s = strs[0]\n        for i in range(1, len(strs)):\n            s += strs[i]\n        return s\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/concatenated-strings/solution/\n\nApproach #1: Recursion [Accepted]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the input.\nSpace Complexity: O(n), where n is the length of the input.\n\n# 7ms 20.99%\nclass Solution {\n    public String concatenate(List<List<String>> strs) {\n        if (strs.isEmpty()) return \"\";\n        StringBuilder sb = new StringBuilder();\n        List<String> first = strs.get(0);\n        for (String s: first) {\n            sb.append(s);\n        }\n        for (int i = 1; i < strs.size(); i++) {\n            List<String> cur = strs.get(i);\n            for (int j = 0; j < cur.size(); j++) {\n                sb.append(cur.get(j));\n            }\n        }\n        return sb.toString();\n    }\n}\n\nApproach #2: Iteration [Accepted]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the input.\nSpace Complexity: O(n), where n is the length of the input.\n\n# 7ms 20",
      -3.283203125
    ],
    [
      "import random\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(t[0] + t[-1])\n    return result\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\n    print(adjacent_element_concatenation(tuples))\n    tuples = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9]]\n    print(adjacent_element_concatenation(tuples))\n    tuples = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9], [5, 6, 7, 8, 9, 10]]\n    print(adjacent_element_concatenation(tuples))\n    tuples = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10, 11]]\n    print(adjacent_element_concatenation(tuples))\n    tuples = [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8], [4, 5, 6, 7, 8, 9], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10, 11], [7, 8, 9, 10, 11, 12]]\n    print(adjacent_element_concatenation(",
      -3.416015625
    ],
    [
      "import collections\nimport itertools\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: tuple\n    \"\"\"\n    return tuple(itertools.chain.from_iterable(tuples))\n\n\nif __name__ == '__main__':\n    tuples = (\n        (1, 2, 3),\n        (1, 2, 3, 4),\n        (1, 2, 3, 4, 5),\n        (1, 2, 3, 4, 5, 6),\n        (1, 2, 3, 4, 5, 6, 7),\n        (1, 2, 3, 4, 5, 6, 7, 8),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11),\n        (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),\n    )\n\n    print(adjacent_element_concatenation(tuples))",
      -3.447265625
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: collections.Iterable[tuple]\n    :rtype: tuple\n    \"\"\"\n    def adjacent_element_concatenation_aux(tuple_iter):\n        for tuple in tuple_iter:\n            yield tuple[0]\n            yield tuple[1]\n            yield tuple[2]\n    return tuple(adjacent_element_concatenation_aux(tuples))\n\nif __name__ == \"__main__\":\n    tuples = [(1,2,3),(2,3,4),(3,4,5),(4,5,6)]\n    print adjacent_element_concatenation(tuples)",
      -3.576171875
    ],
    [
      "# https://leetcode.com/problems/concatenated-string/#/description\n# Given a list of tuples, each tuple contains a string and an integer, and the integer indicates the position of the string in the original list.\n# Return a list of strings, each of which is the concatenation of all strings in the original list, in order.\n\n# Example 1:\n# Input: [(1, \"a\"),(2, \"b\"),(3, \"c\")]\n# Output: [\"abc\", \"a1b2c3\"]\n# Example 2:\n# Input: [(1, \"a\"),(3, \"b\"),(4, \"c\")]\n# Output: [\"a1b3c4\", \"a1b3c4\", \"a1b3c4\"]\n# Example 3:\n# Input: [(1, \"a\"),(3, \"b\"),(5, \"c\")]\n# Output: [\"a1b3c5\", \"a1b3c5\", \"a1b3c5\"]\n# Note:\n# The length of all tuples is in the range of [1, 100].\n# The length of all strings in the tuple and the input list will be in the range of [1, 200].\n# The input list is already sorted in ascending order by the integer.\n\n# DFS solution:\nclass Solution(object):\n    def findConcatenation(self, strings, positions):\n        \"\"\"\n        :type strings: List[Tuple[int, str]]\n        :rtype: List[str]\n        \"\"\"\n        strings.sort(key=lambda x: x[0])\n        res = []\n        for i in range(len(strings)):\n            if i == len(strings) - 1:\n                res.append(strings[i][1])\n                continue\n            j = i\n            while j < len(strings) and strings[j][0] == strings[i][0] and positions[strings[i][0]] < positions[strings[j][0]]:\n                j += 1\n            res.append(strings[i][1] + strings[j][1])\n        return res",
      -4.39453125
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    if not tuples:\n        return []\n    \n    # first tuple\n    first_tuple = tuples[0]\n    \n    # all other tuples\n    other_tuples = tuples[1:]\n    \n    # list of tuples\n    result = [first_tuple]\n    \n    # get a list of adjacent tuples\n    for t in other_tuples:\n        if t[0] == first_tuple[-1]:\n            result.append(t)\n        else:\n            result.append(first_tuple + tuple(t))\n    \n    return result\n\nif __name__ == \"__main__\":\n    tuples = [(\"a\", \"b\", \"c\"), (\"d\", \"e\", \"f\")]\n    print(adjacent_element_concatenation(tuples))\n    \n    tuples = [(\"a\", \"b\", \"c\"), (\"d\", \"e\", \"f\"), (\"g\", \"h\", \"i\"), (\"j\", \"k\", \"l\")]\n    print(adjacent_element_concatenation(tuples))\n    \n    tuples = [(\"a\", \"b\", \"c\"), (\"d\", \"e\", \"f\"), (\"g\", \"h\", \"i\"), (\"j\", \"k\", \"l\"), (\"m\", \"n\", \"o\")]\n    print(adjacent_element_concatenation(tuples))\n    \n    tuples = [(\"a\", \"b\", \"c\"), (\"d\", \"e\", \"f\"), (\"g\", \"h\", \"i\"), (\"j\", \"k\", \"l\"), (\"m\", \"n\", \"o\"), (\"p\", \"q\", \"r\")]\n    print(adjacent_element_concatenation(tuples))",
      -4.921875
    ],
    [
      "# https://leetcode.com/problems/concatenated-paths/discuss/186596/Python-Coding-Solution-with-explanation-and-test-case-examples\nclass Solution(object):\n    def concatenatedPaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if not root:\n            return []\n\n        paths = []\n        self.helper(root, paths)\n        return paths\n\n    def helper(self, root, paths):\n        if not root:\n            return\n\n        paths.append(str(root.val))\n        self.helper(root.left, paths)\n        self.helper(root.right, paths)",
      -4.95703125
    ],
    [
      "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __str__(self):\n        return str(self.x)\n\n    def __add__(self, other):\n        self.y += other.y\n        return self\n\n\ndef adjacent_element_concatenation(tuples):\n    if len(tuples) == 0:\n        return Tuple(0)\n    if len(tuples) == 1:\n        return tuples[0]\n\n    t = Tuple(tuples[0])\n    for tup in tuples[1:]:\n        t.x += tup.x\n        t.y += tup.y\n\n    return t\n\n\nclass Solution(object):\n    def adjacentElementSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        t = adjacent_element_concatenation(nums)\n        return t.x + t.y\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4]\n    assert(Solution().adjacentElementSum(nums) == 6)",
      -4.96875
    ],
    [
      "# The tuple is a list of elements.\n# The adjacent elements are two elements that are adjacent to each other.\n# We assume that the adjacent elements are not in the same position.\n\n# Example 1:\n# Input: [1,2,3], [2,3], [1,3]\n# Output: [1,2,3,2,3,1,3]\n# Example 2:\n# Input: [1,2,3], [1,2], [1,2]\n# Output: [1,2,1,2,1,2]\n\n# Note:\n# The length of all input tuples is in range [1, 100].\n# The length of all input tuples is in range [1, 100].\n# The tuples have only numbers. No special characters are allowed.\n\n# Related Topics:\n# Array, Trie, Two Pointers\n#\n# dfs, Binary Search\n\nclass Solution(object):\n    def getAdjacent(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 1):\n            if nums[i] + 1 == nums[i + 1]:\n                result.append(nums[i])\n        return result",
      -5.484375
    ],
    [
      "import collections\n\n# Your Solution\n\ndef adjacent_element_concatenation(tuples):\n    # Initialize a list to store the adjacent elements\n    concatenated_list = []\n    # Iterate over the tuples and concatenate adjacent elements\n    for tup in tuples:\n        # Iterate over the list and append the adjacent elements\n        for i in range(len(tup) - 1):\n            # Add the adjacent elements\n            concatenated_list.append(tup[i] + tup[i+1])\n    # Return the concatenated list\n    return concatenated_list\n\n# Test cases\n\n# tuples = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n# adjacent_element_concatenation(tuples)\n# # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n# tuples = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n# adjacent_element_concatenation(tuples)\n# # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# tuples = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n# adjacent_element_concatenation(tuples)\n# # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ntuples = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\nprint(adjacent_element_concatenation(tuples))\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\ntuples = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\nprint(adjacent_element_concatenation(tuples))\n# Output: [1, 2, 3, 4, 5, 6, 7",
      -5.55078125
    ],
    [
      "def adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    ans = []\n    for t in tuples:\n        for i in range(len(t) - 1):\n            ans.append(t[i] + t[i+1])\n        ans.append(t[-1])\n    return ans\n\n\n# Your Adjacent Element Concatenation solution\n# TESTCASE\n# - [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9]]\n# - [[1, 2, 3, 4, 5], [6, 7, 8, 9]]\n# - [[1, 2, 3, 4, 5, 6], [7, 8, 9]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0], [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0], [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0], [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]]\n# - [[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,",
      -5.70703125
    ],
    [
      "def adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return [tuple(map(lambda x: x + x[0], t)) for t in tuples]\n\nif __name__ == '__main__':\n    tuples = [[1, 2, 3], [2, 3], [1, 2], [1, 2, 3]]\n    assert adjacent_concatenation(tuples) == [[1, 2, 3, 2, 3], [2, 3], [1, 2], [1, 2, 3]]",
      -5.88671875
    ],
    [
      "# https://leetcode.com/problems/concatenated-sorted-array-of-integers/discuss/181209/Python-Solution\n# http://www.programcreek.com/2012/12/leetcode-concatenated-sorted-array-of-integers/\n# https://leetcode.com/problems/concatenated-sorted-array-of-integers/discuss/221624/Java-O(N)\n\nimport collections\n\nclass Solution(object):\n    def concatenate(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(arr)):\n            res += arr[i]\n        return res\n\nclass Solution(object):\n    def concatenate(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(arr)):\n            for j in xrange(len(arr[i])):\n                res.append(arr[i][j])\n        return res\n\nclass Solution(object):\n    def concatenate(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(arr)):\n            res += arr[i]\n        return res\n\nclass Solution(object):\n    def concatenate(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(arr)):\n            for j in xrange(len(arr[i])):\n                res.append(arr[i][j])\n        return res\n\nclass Solution(object):\n    def concatenate(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []",
      -5.93359375
    ],
    [
      "import collections\n\n# https://www.geeksforgeeks.org/given-a-list-of-tuples-find-the-adjacent-concatenated-tuples/\ndef adjacent_tuple_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    def find_adjacent_tuples(tuples):\n        for i in range(len(tuples)):\n            if i!= 0:\n                if tuples[i-1][0]!= tuples[i][0] or tuples[i-1][1]!= tuples[i][1]:\n                    yield tuples[i-1], tuples[i]\n            if i!= len(tuples) - 1:\n                if tuples[i+1][0]!= tuples[i][0] or tuples[i+1][1]!= tuples[i][1]:\n                    yield tuples[i], tuples[i+1]\n\n    return list(find_adjacent_tuples(tuples))\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2),\n        (3, 4),\n        (5, 6),\n        (7, 8),\n        (9, 10),\n        (11, 12),\n        (13, 14),\n        (15, 16),\n        (17, 18),\n        (19, 20),\n    ]\n\n    print(adjacent_tuple_concatenation(tuples))",
      -5.95703125
    ],
    [
      "# https://oj.leetcode.com/problems/concatenated-adjacent-matrix-elements/\n# tag:medium\n\n# The adjacent matrix is a matrix with the same size as the given matrix, where the (i, j) entry is 1 if the matrix\n# at (i, k) and (k + 1, j) is 1, and 0 otherwise.\n# \n# Example 1:\n# Input:\n# a = [\n#     [1, 0, 1],\n#     [1, 1, 0],\n#     [0, 0, 1]\n# ]\n# Output:\n# [\n#     [1, 1, 1],\n#     [1, 1, 0],\n#     [0, 0, 1]\n# ]\n# Explanation:\n# The adjacent matrix is:\n# a[0][0] = 1, a[0][1] = 1, a[0][2] = 1, \n# a[1][0] = 1, a[1][1] = 1, a[1][2] = 0, \n# a[2][0] = 0, a[2][1] = 0, a[2][2] = 1.\n# Example 2:\n# Input:\n# a = [\n#     [1, 0, 1],\n#     [1, 1, 0],\n#     [0, 1, 1]\n# ]\n# Output:\n# [\n#     [1, 1, 1],\n#     [1, 1, 0],\n#     [0, 0, 1]\n# ]\n# Explanation:\n# The adjacent matrix is:\n# a[0][0] = 1, a[0][1] = 1, a[0][2] = 1, \n# a[1][0] = 1, a[1][1] = 1, a[1][2] = 0, \n# a[2][0] = 0, a[2][1] = 0, a[2][2] = 1.\n\n# 2017.02.14\nclass Solution:\n    def getAdjacentMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype",
      -6.0625
    ],
    [
      "class Solution(object):\n    def adjacentConcat(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        # Sort the numbers.\n        nums = sorted(nums)\n        # Count the adjacent numbers.\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[j] - nums[i] == 1:\n                    count += 1\n                    break\n        # Concatenate the adjacent numbers.\n        res = []\n        for i in range(n):\n            if count == 0:\n                res.append(nums[i])\n                count = 1\n            else:\n                res.append(nums[i] + res[-1])\n                count -= 1\n        return res\n\n# Test Cases\nsolution = Solution()\n\n# Input: [1,2,3,4,5]\n# Output: [1,2,3,4,5,1,2,3,4,5]\nprint solution.adjacentConcat([1,2,3,4,5])\n\n# Input: [1,2,3,4,5,6,7]\n# Output: [1,2,3,4,5,6,7,1,2,3,4,5,6,7]\nprint solution.adjacentConcat([1,2,3,4,5,6,7])\n\n# Input: [1,2,3,4,5,6]\n# Output: [1,2,3,4,5,6,1,2,3,4,5,6]\nprint solution.adjacentConcat([1,2,3,4,5,6])",
      -6.09375
    ],
    [
      "# Example 1\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2), (3, 4), (5, 6)]\n    Output: [(1, 2, 3, 4), (5, 6, 1, 2)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 2\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2, 3), (4, 5)]\n    Output: [(1, 2, 3, 4), (1, 2, 3, 5)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 3\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2), (3, 4), (5, 6)]\n    Output: [(1, 2, 3, 4), (5, 6, 1, 2)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 4\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2, 3), (4, 5)]\n    Output: [(1, 2, 3, 4), (1, 2, 3, 5)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 5\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2, 3), (4, 5)]\n    Output: [(1, 2, 3, 4), (1, 2, 3, 5)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 6\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2), (3, 4), (5, 6)]\n    Output: [(1, 2, 3, 4), (5, 6, 1, 2)]\n    \"\"\"\n    return [x for x in tuples if len(x) > 1]\n\n# Example 7\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    Input: [(1, 2), (",
      -6.2421875
    ],
    [
      "import random\n\n# Your code here.\n\ndef adjacent_element_concatenation(tuples):\n    if len(tuples) <= 1:\n        return tuples\n    elif len(tuples) == 2:\n        return (tuples[0][0] + tuples[1][0], tuples[0][1] + tuples[1][1])\n    else:\n        return adjacent_element_concatenation(tuples[:-1]) + (tuples[-1][0] + tuples[-1][1],)\n\n\nif __name__ == \"__main__\":\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17, 18)]))\n    print(adjacent_element_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17",
      -6.51953125
    ],
    [
      "import collections\n\n\nclass Solution:\n    def adjacent_concatenation(self, tuples: List[List[int]]) -> List[int]:\n        if not tuples:\n            return []\n        result = []\n        for t in tuples:\n            for i in range(0, len(t)):\n                for j in range(i + 1, len(t)):\n                    if t[i] == t[j]:\n                        result.append(t[i] * 2)\n                        result.append(t[j])\n        return result\n\n\nif __name__ == \"__main__\":\n    assert Solution().adjacent_concatenation([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]\n    assert Solution().adjacent_concatenation([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert Solution().adjacent_concatenation([[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert Solution().adjacent_concatenation([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    assert Solution().adjacent_concatenation([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    assert Solution().adjacent_concatenation([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14], [15, 16]]) == [1, 2, 3, 4",
      -6.609375
    ],
    [
      "import unittest\n\nfrom collections import namedtuple\n\nTuple = namedtuple(\"Tuple\", \"a b\")\n\n\nclass Solution:\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums = list(nums)\n        nums.sort()\n        ret = []\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] == 1:\n                ret.append(nums[i])\n        return ret\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/concatenated-strings/solution/\n#\nApproach #1: Sort [a b c d e]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the given array.\nSpace Complexity: O(n).\n\n# 7ms 96.21%\nclass Solution {\n    public List<Integer> adjacentElements(int[] nums) {\n        List<Integer> ret = new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] - nums[i - 1] == 1) {\n                ret.add(nums[i]);\n            }\n        }\n        return ret;\n    }\n}\n\nApproach #2: Brute Force\nComplexity Analysis\nTime Complexity: O(n^2), where n is the length of the given array.\nSpace Complexity: O(n).\n\n# 7ms 97.20%\nclass Solution {\n    public List<Integer> adjacentElements(int[] nums) {\n        List<Integer> ret = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int",
      -7.015625
    ],
    [
      "from collections import defaultdict\n\ndef adjacent_element_concatenation(tup_list):\n    \"\"\"\n    :type tup_list: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # O(n^2) time, O(n) space\n    def adjacent_element_concatenation_1(tup_list):\n        tup_len = len(tup_list)\n        if tup_len <= 1:\n            return tup_list\n        res = []\n        for i in range(tup_len):\n            for j in range(i + 1, tup_len):\n                if tup_list[i][0] == tup_list[j][0]:\n                    res.append(tup_list[i] + tup_list[j])\n        return res\n\n    def adjacent_element_concatenation_2(tup_list):\n        tup_len = len(tup_list)\n        if tup_len <= 1:\n            return tup_list\n        res = []\n        for i in range(tup_len):\n            for j in range(i + 1, tup_len):\n                if tup_list[i][0] == tup_list[j][0]:\n                    res.append(tup_list[i] + tup_list[j])\n        return res\n\n    return adjacent_element_concatenation_1(tup_list)\n\ndef adjacent_element_concatenation_3(tup_list):\n    tup_len = len(tup_list)\n    if tup_len <= 1:\n        return tup_list\n    res = []\n    for i in range(tup_len):\n        for j in range(i + 1, tup_len):\n            if tup_list[i][0] == tup_list[j][0]:\n                res.append(tup_list[i] + tup_list[j])\n    return res\n\ndef adjacent_element_concatenation_4(tup_list):\n    tup_len = len(tup_list)",
      -7.0625
    ],
    [
      "import sys\nimport collections\n\n\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    # sort the tuples\n    tuples = sorted(tuples, key=lambda t: t[0])\n\n    # get the length of the largest tuple\n    max_len = len(tuples[0])\n\n    # for each tuple, get the adjacent elements\n    for i in range(0, len(tuples)):\n        for j in range(max_len):\n            if j == 0:\n                tuples[i][j] = tuples[i][j] + tuples[i][j + 1]\n            elif j == max_len - 1:\n                tuples[i][j] = tuples[i][j] + tuples[i][j - 1]\n            else:\n                tuples[i][j] = tuples[i][j] + tuples[i][j - 1] + tuples[i][j + 1]\n    return tuples\n\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert adjacent_concatenation([(1, 2), (3, 4), (5, 6)]) == [(1, 2, 3, 4, 5, 6)], '1st example'\n    assert adjacent_concatenation([(1, 2), (3, 4), (5,)]) == [(1, 2, 3, 4, 5)], '2nd example'\n    assert adjacent_concatenation([(1, 2), (3, 4), (5, 6), (7, 8)]) == [(1, 2, 3, 4, 5, 6, 7, 8)], '3rd example'\n    assert adjacent_concatenation([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == [(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)], '4th example'\n    assert adjacent_concatenation([(1, 2), (3, 4",
      -7.16796875
    ],
    [
      "class Solution:\n    # @param a list of tuple, each element is (start, end)\n    # @return a string\n    def getConcatenation(self, tuples):\n        if not tuples:\n            return ''\n        \n        if len(tuples) == 1:\n            return str(tuples[0])\n        \n        for i in range(len(tuples)):\n            if i == 0:\n                for j in range(len(tuples)):\n                    if j == 0:\n                        return ''.join(str(t) for t in tuples[i])\n                    else:\n                        return ''.join(str(t) for t in tuples[i]) + ''.join(str(t) for t in tuples[j])\n            elif i == len(tuples) - 1:\n                for j in range(len(tuples)):\n                    if j == len(tuples) - 1:\n                        return ''.join(str(t) for t in tuples[i])\n                    else:\n                        return ''.join(str(t) for t in tuples[i]) + ''.join(str(t) for t in tuples[j])\n            else:\n                for j in range(len(tuples)):\n                    if j == 0:\n                        return ''.join(str(t) for t in tuples[i]) + ''.join(str(t) for t in tuples[j])\n                    elif j == len(tuples) - 1:\n                        return ''.join(str(t) for t in tuples[i]) + ''.join(str(t) for t in tuples[j])\n                    else:\n                        return ''.join(str(t) for t in tuples[i]) + ''.join(str(t) for t in tuples[j]) + ''.join(str(t) for t in tuples[j + 1])\n        \n        return ''.join(str(t) for t in tuples[0])",
      -7.2265625
    ],
    [
      "from collections import namedtuple\n\nTuple = namedtuple('Tuple', ['a', 'b'])\n\n\ndef adjacent_concat(tuples: list) -> list:\n    \"\"\"\n    :param tuples: List of tuples.\n    :return: List of adjacent tuples.\n    \"\"\"\n    return [Tuple(*t) for t in zip(*tuples)]\n\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 2),\n        (3, 4),\n        (5, 6),\n        (7, 8),\n        (9, 10),\n        (11, 12),\n        (13, 14),\n        (15, 16),\n        (17, 18),\n        (19, 20),\n        (21, 22),\n        (23, 24),\n        (25, 26),\n        (27, 28),\n        (29, 30),\n        (31, 32),\n        (33, 34),\n        (35, 36),\n        (37, 38),\n        (39, 40),\n        (41, 42),\n        (43, 44),\n        (45, 46),\n        (47, 48),\n        (49, 50),\n        (51, 52),\n        (53, 54),\n        (55, 56),\n        (57, 58),\n        (59, 60),\n        (61, 62),\n        (63, 64),\n        (65, 66),\n        (67, 68),\n        (69, 70),\n        (71, 72),\n        (73, 74),\n        (75, 76),\n        (77, 78),\n        (79, 80),\n        (81, 82),\n        (83, 84),\n        (85, 86),\n        (87, 88),\n        (89, 90),\n        (91, 92),\n        (93, 94),\n        (95, 96),\n        (97, 98),\n        (99, 100),\n        (101, 102),\n        (103, 104),\n        (105, 106),\n        (107, 108),\n        (109, 110),\n        (111, 112),\n        (113, 114),\n        (115, 116),",
      -7.8203125
    ],
    [
      "from collections import namedtuple\n\nElement = namedtuple(\"Element\", [\"x\", \"y\"])\n\n\nclass AdjacentElementConcatenation(object):\n    \"\"\"\n    A solution to the problem using the namedtuple.\n    \"\"\"\n\n    def __init__(self, elements):\n        self.elements = elements\n\n    def adjacent_element_concatenation(self):\n        \"\"\"\n        :rtype: List[Element]\n        \"\"\"\n        return [\n            Element(a, b)\n            for a in self.elements\n            for b in self.elements\n            if a.x == b.x and a.y == b.y\n        ]\n\n\nclass AdjacentElementConcatenation2(object):\n    \"\"\"\n    A solution to the problem using a generator expression.\n    \"\"\"\n\n    def __init__(self, elements):\n        self.elements = elements\n\n    def adjacent_element_concatenation(self):\n        for a, b in zip(self.elements, self.elements):\n            yield Element(a.x, a.y)\n            yield Element(b.x, b.y)\n\n\nif __name__ == \"__main__\":\n    elements = [\n        Element(1, 1),\n        Element(1, 2),\n        Element(2, 1),\n        Element(2, 2),\n        Element(3, 1),\n        Element(3, 2),\n    ]\n\n    adjacent_element_concatenation = AdjacentElementConcatenation(elements)\n    adjacent_element_concatenation2 = AdjacentElementConcatenation2(elements)\n    adjacent_element_concatenation3 = AdjacentElementConcatenation3(elements)\n\n    assert adjacent_element_concatenation.adjacent_element_concatenation() == [\n        Element(1, 1),\n        Element(1, 2),\n        Element(2, 1),\n        Element(2, 2),\n        Element(3, 1),\n        Element(3, 2),\n    ]\n\n    assert adjacent_element_concatenation2.adjacent_element_concatenation",
      -7.98046875
    ],
    [
      "from collections import defaultdict\nfrom typing import List\nfrom typing import Tuple\n\nclass Solution:\n    def adjacentElements(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        ret = 0\n        for i in range(1, n):\n            if nums[i - 1] == nums[i]:\n                ret += 1\n        return ret\n\n    def adjacentElements2(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        ret = 0\n        for i in range(1, n):\n            if nums[i - 1] == nums[i]:\n                ret += 1\n        return ret\n\n    def adjacentElements3(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        ret = 0\n        for i in range(1, n):\n            if nums[i - 1] == nums[i]:\n                ret += 1\n        for i in range(n - 1, -1, -1):\n            if nums[i] == nums[i + 1]:\n                ret += 1\n        return ret\n\n    def adjacentElements4(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        ret = 0\n        for i in range(1, n):\n            if nums[i - 1] == nums[i]:\n                ret += 1\n        for i in range(n - 1, -1, -1):\n            if nums[i] == nums[i + 1]:\n                ret += 1\n        return ret\n\nif __name__ == '__main__':\n    assert Solution().adjacentElements([1, 2, 3]) == 3\n    assert Solution().adjacentElements([1, 2, 2]) == 2\n    assert Solution().adjacentElements([2, 3]) == 1\n    assert Solution().adjacentElements([1, 1, 1]) == 1\n    assert Solution().adjacentElements",
      -8.1953125
    ],
    [
      "import collections\n\ndef adjacent_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    def get_min_max(t):\n        min_max = collections.namedtuple('MinMax','min max')\n        return min_max(min(t), max(t))\n    tuple_length = len(tuples)\n    result = [0] * tuple_length\n    for i in range(tuple_length):\n        min_max_tuple = get_min_max(tuples[i])\n        result[min_max_tuple.min:min_max_tuple.max + 1] = tuples[i]\n    return result",
      -8.65625
    ],
    [
      "import unittest\nfrom copy import deepcopy\n\nclass Solution(object):\n    def adjacentSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums = deepcopy(nums)\n        nums.sort()\n        result = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i+1]:\n                result += nums[i]\n                continue\n            if i > 0 and nums[i] == nums[i-1]:\n                result += nums[i-1]\n                continue\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/adjacent-element-concatenation/solution/\n\n# 1ms 100%\nclass Solution {\n    public int adjacentSum(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        Arrays.sort(nums);\n        int result = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] == nums[i+1]) {\n                result += nums[i];\n                continue;\n            }\n            if (i > 0 && nums[i] == nums[i-1]) {\n                result += nums[i-1];\n                continue;\n            }\n        }\n        return result;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int adjacentSum(int[] nums) {\n        int result = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] == num",
      -8.8515625
    ],
    [
      "import collections\nimport sys\n\n__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def adjacentElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        # find the first and last index of the list\n        first_idx = 0\n        last_idx = len(nums) - 1\n        while first_idx < last_idx and nums[first_idx] == nums[last_idx]:\n            first_idx += 1\n            last_idx -= 1\n\n        # use a stack to store the result\n        stack = collections.deque()\n\n        # push the first element to the stack\n        stack.append(nums[first_idx])\n\n        # push all the adjacent elements to the stack\n        for i in range(first_idx + 1, last_idx):\n            stack.append(nums[i])\n\n        # pop the first element from the stack\n        while stack:\n            yield stack.popleft()\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 2, 3]\n    nums = [1, 2, 2, 3, 3]\n    nums = [1, 2, 3]\n    nums = [1, 2, 3, 4]\n    nums = [1, 2, 3, 4, 5]\n    nums = [1, 2, 3, 4, 5, 6]\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]",
      -9.9921875
    ],
    [
      "import collections\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.x)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(tuples)\n# param_1 = obj.concatenate(tuple_1,tuple_2)\nclass Solution(object):\n    def concatenate(self,t1,t2):\n        \"\"\"\n        :type t1: List[Tuple]\n        :type t2: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if not t1 or not t2:\n            return t1 or t2\n        result = []\n        for i in range(len(t1)):\n            t1_item = t1[i]\n            t2_item = t2[i]\n            if t1_item.x == t2_item.x:\n                result.append(t1_item)\n            else:\n                result.append(Tuple(t1_item.x))\n        return result\n\nif __name__ == \"__main__\":\n    t1 = (1,2,3)\n    t2 = (4,5,6)\n    t3 = (1,2,3,4,5,6,7)\n    t4 = (1,2,3,4,5,6,7,8)\n    t5 = (1,2,3,4,5,6,7,8,9)\n    t6 = (1,2,3,4,5,6,7,8,9,10)\n    t7 = (1,2,3,4,5,6,7,8,9,10,11)\n    t8 = (1,2,3,4,5,6,7,8,9,10,11,12)\n    t9 = (1,2,3,4,5,6,7,8,9,10,11,12,13)\n    t10 = (1,2,3,",
      -10.5390625
    ],
    [
      "# https://leetcode.com/problems/adjacent-element-concatenation/\n\n# Definition for a tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.next = None\n\nclass Solution(object):\n    def getConcat(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        return self.getConcatRecur(nums, 0, len(nums))\n\n    def getConcatRecur(self, nums, start, end):\n        if end - start == 1:\n            return nums[start].x\n        if start == end - 1:\n            return nums[start].x + nums[end - 1].x\n        return self.getConcatRecur(nums, start + 1, end - 1) + nums[start].x + nums[end - 1].x\n\n    def getConcatRecur2(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        return self.getConcatRecur2Recur(nums, 0, len(nums))\n\n    def getConcatRecur2Recur(self, nums, start, end):\n        if end - start == 1:\n            return nums[start].x\n        if start == end - 1:\n            return nums[start].x + nums[end - 1].x\n        return self.getConcatRecur2Recur(nums, start + 1, end - 1) + nums[start].x + nums[end - 1].x\n\n\nif __name__ == '__main__':\n    nums = [Tuple(1), Tuple(2), Tuple(3)]\n    s = Solution()\n    print(s.getConcat(nums))\n    nums = [Tuple(1), Tuple(2), Tuple(3), Tuple(1)]\n    print(s.getConcat(nums))\n    nums = [Tuple(1), T",
      -11.3125
    ],
    [
      "from collections import defaultdict\nfrom typing import List, Tuple\n\ndef adjacent_element_concatenation(tuples: List[Tuple[int,...]]) -> List[Tuple[int,...]]:\n    \"\"\"\n    Write a function to perform the adjacent element concatenation in the given tuples.\n\n    Example\n    >>> adjacent_element_concatenation([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)])\n    [(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    >>> adjacent_element_concatenation([(1, 2), (1, 2), (1, 2), (1, 2)])\n    [(1, 2), (1, 2), (1, 2), (1, 2)]\n    >>> adjacent_element_concatenation([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)])\n    [(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    >>> adjacent_element_concatenation([(1, 2), (1, 2), (1, 2), (1, 2)])\n    [(1, 2), (1, 2), (1, 2), (1, 2)]\n    >>> adjacent_element_concatenation([(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)])\n    [(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.extend(t)\n    return result\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      -11.9375
    ],
    [
      "# https://oj.leetcode.com/problems/concatenated-array/\n\nclass Solution:\n    # @param {List[List[int]]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def concatenate(self, nums):\n        if len(nums) == 0:\n            return\n\n        if len(nums) == 1:\n            nums.append(nums[0])\n            return\n\n        for i in range(len(nums) - 2):\n            nums[i] = (nums[i][0] + nums[i+1][0], nums[i][1] + nums[i+1][1])\n        nums[-1] = (nums[-1][0] + nums[-2][0], nums[-1][1] + nums[-2][1])\n\n        return",
      -14.8828125
    ],
    [
      "import collections\n\ndef adjacent_element_concatenation(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    if not tuples:\n        return []\n\n    def adjacency_dict(tuple):\n        tup_dict = collections.defaultdict(list)\n        for i, elem in enumerate(tuple):\n            tup_dict[elem].append(i)\n\n        return tup_dict\n\n    adj_dict = adjacency_dict(tuples[0])\n    for tup in tuples[1:]:\n        for elem in tup:\n            adj_dict[elem].extend(adj_dict[elem])\n\n    return [tup for tup in tuples[0] if tup not in adj_dict]",
      -15.5390625
    ],
    [
      "# https://leetcode.com/problems/adjacent-element-concatenation/\n# Definition for a  tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.next = None\n\nclass Solution(object):\n    def getConcat(self, T):\n        \"\"\"\n        :type T: List[Tuple]\n        :rtype: List[str]\n        \"\"\"\n        if not T:\n            return []\n\n        def _getConcat(head, tail):\n            if not tail:\n                return head\n            else:\n                return _getConcat(head + tail[0], tail[1:])\n\n        concat = []\n        head = []\n        for t in T:\n            head.append(t.x)\n            concat.append(_getConcat(head, t.next))\n\n        return concat",
      -16.109375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}