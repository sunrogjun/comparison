{
  "problem": {
    "task_id": "MBPP/300",
    "prompt": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
    "canonical_solution": "def count_binary_seq(n): \r\n\tnCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res ",
    "test_list": [
      "assert count_binary_seq(1) == 2.0",
      "assert count_binary_seq(2) == 6.0",
      "assert count_binary_seq(3) == 20.0"
    ],
    "challenge_test_list": [],
    "problem_id": 289
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "import math\n\ndef sum_bits(n):\n    return sum([(1<<i) for i in range(0, n+1)])\n\ndef count(n):\n    return sum([1 for i in range(1, int(math.pow(2, n))+1) if sum_bits(n) == sum_bits(n-1) + i])\n\n# test cases\nassert count(5) == 2\nassert count(7) == 3\nassert count(13) == 4\nassert count(15) == 5\n\n# follow up\n# Write a function to count the number of binary sequences of length n, where n is a positive integer.\n#\n# For example, Given n = 5, return 6.\n#\n# Follow up:\n# Could you do it without using any loop / recursion?",
      -0.03765869140625
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def findSubstring(self, s, n):\n        return self.findSubstring_slow(s, n)\n\n    def findSubstring_slow(self, s, n):\n        if n == 0:\n            return 0\n\n        res = 0\n        for i in range(len(s) - n + 1):\n            if sum(s[i:i + n]) == sum(s[i + n:i + 2 * n]):\n                res += 1\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = '101001010111001'\n    n = 3\n    print(sol.findSubstring(s, n))",
      -0.62109375
    ],
    [
      "class Solution(object):\n    def countBinarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(n-1):\n            sum = 0\n            for j in range(i+1, n):\n                sum = sum ^ (1 << j)\n            if sum == sum ^ (1 << (n-1)):\n                res += 1\n        return res",
      -0.73291015625
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def countBinarySequences(self, n):\n        return 0",
      -0.75
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def countBinarySequences(self, n):\n        return sum(bin(sum(map(int, str(i)))).count('1') for i in range(2, n+1))",
      -0.7666015625
    ],
    [
      "class Solution:\n\t# @return an integer\n\tdef countBinarySequences(self, n):\n\t\tcount = 0\n\t\tfor i in range(2**n):\n\t\t\tnum = sum(bin(i)[2:])\n\t\t\tif num == sum(bin(i)[:n]):\n\t\t\t\tcount += 1\n\t\treturn count\n\nif __name__ == '__main__':\n\ts = Solution()\n\tprint s.countBinarySequences(2)",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def countBinary(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(1<<i for i in range(n, 0, -1))",
      -0.85595703125
    ],
    [
      "def find_sum_of_binary(n):\n    if n < 1:\n        return 0\n    s = 0\n    for i in range(1, n):\n        s += bin(i)[2:]\n    return s\n\ndef main():\n    print(find_sum_of_binary(2))\n    print(find_sum_of_binary(3))\n\nif __name__ == '__main__':\n    main()",
      -0.85595703125
    ],
    [
      "class Solution:\n    # @return an integer\n    def binarySubsequenceSum(self, n):\n        # write your code here\n        i = 0\n        sum = 0\n        while i < n:\n            if sum == sum(bin(i)[2:]):\n                sum = sum(bin(i)[:-2])\n            i += 1\n        return sum\n\na = Solution()\nprint(a.binarySubsequenceSum(2))\nprint(a.binarySubsequenceSum(10))",
      -0.85595703125
    ],
    [
      "def binary_search(n, target):\n    def is_sum_same(i, target):\n        for j in xrange(i, n):\n            if sum(seq[j:n])!= sum(seq[:j]):\n                return False\n        return True\n    return sum(xrange(2 ** n)) if is_sum_same(0, target) else 0\n\ndef main():\n    print binary_search(10, 2)\n\nif __name__ == \"__main__\":\n    main()",
      -0.85693359375
    ],
    [
      "import sys\n\ndef binary_sequence_sum(n):\n    binary_sequence = []\n    sum_n = 0\n    for i in range(n):\n        sum_n += 1\n        binary_sequence.append(sum_n)\n    return binary_sequence\n\n\ndef binary_sequence_sum_check(binary_sequence):\n    sum_n = 0\n    for i in binary_sequence:\n        sum_n += 1\n        if sum_n % 2 == 0:\n            return False\n    return True\n\n\ndef main():\n    n = int(sys.argv[1])\n    binary_sequence = binary_sequence_sum(n)\n    if binary_sequence_sum_check(binary_sequence):\n        print \"YES\"\n    else:\n        print \"NO\"\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "def count_bst(n):\n    res = 0\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    res = count_bst(n - 1) + count_bst(n - 2)\n    for i in range(n - 3, -1, -1):\n        res += count_bst(n - i - 1) * count_bst(i)\n    return res\n\nprint count_bst(5)",
      -0.85693359375
    ],
    [
      "def binary_sequence(n):\n    sum = 0\n    for i in range(n):\n        sum += 1 if (i & 1) == 1 else 0\n    return sum\n\nprint binary_sequence(10)\n\n\"\"\"\nOutput:\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\"\"\"",
      -0.85693359375
    ],
    [
      "def binary_sum_of_bits(n):\n    return sum([1 << i for i in range(n)])\n\nif __name__ == '__main__':\n    print(binary_sum_of_bits(2))",
      -0.85693359375
    ],
    [
      "#!/bin/python\n\ndef sum_bits(n):\n    if n <= 0:\n        return 0\n    else:\n        return sum([bin(i)[2:] for i in range(2**n)])\n\ndef find_binary_seq(n):\n    return sum_bits(n) == sum_bits(n-1)\n\ndef main():\n    #print find_binary_seq(8)\n    #print find_binary_seq(10)\n    #print find_binary_seq(12)\n    #print find_binary_seq(100)\n    print sum_bits(100)\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "from time import time\n\nclass Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 1:\n            return 0\n        return sum(1 for i in xrange(n/2) if sum(1<<i for j in xrange(n/2+1-i) if sum(1<<j for k in xrange(i+1) if sum(1<<k) == sum(1<<i+j))) == sum(1<<i))\n\n\nif __name__ == '__main__':\n    start_time = time()\n    print Solution().countBinarySequences(5)\n    print time() - start_time,'s'",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        result = 0\n        for i in range(n):\n            result += self.countBinarySequence(n, i)\n        return result\n\n    def countBinarySequence(self, n, i):\n        result = 0\n        for j in range(i + 1, n):\n            if n & 1 == 1:\n                result += 1\n            n >>= 1\n        return result",
      -0.85791015625
    ],
    [
      "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def countBinarySequences(self, n):\n        return sum(1 for _ in range(2**n))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 0:\n            return 0\n        res = 0\n        for i in range(2, n + 1):\n            res += self.countBinary(n, i)\n        return res\n\n    def countBinary(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(m - n + 1):\n            res += self.countBinary(n, m - i)\n        return res\n\n\na = Solution()\nprint(a.countBinarySequences(10))",
      -0.85791015625
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ret = 0\n        n = len(s)\n        for i in xrange(n):\n            if s[i] == '1' and s[i + 1] == '0':\n                ret += 2\n            elif s[i] == '0' and s[i + 1] == '1':\n                ret += 2\n            else:\n                ret += 1\n        return ret\n\nif __name__ == '__main__':\n    print Solution().countBinarySubstrings('01')",
      -0.8583984375
    ],
    [
      "class Solution:\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        ans = 0\n        for i in range(2, n + 1):\n            for j in range(i - 1, -1, -1):\n                if j >= 0 and (i & j) == 0:\n                    ans += 1\n                    break\n        return ans",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        \n        count = 0\n        for i in range(2, n + 1):\n            s = sum([1 << j for j in range(0, n - i + 1)])\n            if s == sum([1 << j for j in range(n - i, n)]):\n                count += 1\n        return count",
      -0.8583984375
    ],
    [
      "from __future__ import print_function\nimport math\nimport sys\n\n# @include\ndef count_binary_sequences(n):\n    count = 0\n    for i in range(2 ** n):\n        if sum(bin(i)[:n]) == sum(bin(i)[n:]):\n            count += 1\n    return count\n# @exclude\n\n\ndef main():\n    n = 10\n    expected = sum(bin(2 ** n)[:n])\n    actual = count_binary_sequences(n)\n    print(expected == actual)\n\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # DP solution\n        # dp[i][j] means the count of all binary sequences of length 2n that sum of first i bits is same as sum of last j bits\n        dp = [[0 for _ in xrange(2 ** n)] for _ in xrange(2 ** n)]\n        # DP solution\n        # dp[i][j] means the count of all binary sequences of length 2n that sum of first i bits is same as sum of last j bits\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        for i in xrange(2 ** n):\n            for j in xrange(0, i):\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        return dp[2 ** n - 1][n - 1]\n\n\nif __name__ == '__main__':\n    n = 2\n    print Solution().countBinarySequences(n)",
      -0.8583984375
    ],
    [
      "# https://oj.leetcode.com/problems/find-all-n-bit-sequences/discuss/176868/Python-O(n)-time-and-space-Solution-with-explaination\n\nclass Solution(object):\n    def countBinary(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 0:\n            return 0\n        cnt = 0\n        for i in range(n):\n            cnt += self.countBinary(n - 1 - i)\n        return cnt",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def numBinaryRepresentations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(sum(bin(i)[2:]) for i in range(2, n+1))",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} n\n    # @return {integer}\n    def countBinarySequences(self, nums, n):\n        if not nums:\n            return 0\n        count = 0\n        for i in range(0, n):\n            count += sum(1 for x in nums[i:]) == sum(1 for x in nums[:n - i])\n        return count\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countBinarySequences([1,1], 2))\n    print(sol.countBinarySequences([1,1,0], 2))",
      -0.8583984375
    ],
    [
      "def binary_sequence_with_sum(n):\n\ts = 0\n\tfor i in range(2, n+1):\n\t\ts += i\n\treturn s\n\nprint binary_sequence_with_sum(5)\n\n\"\"\"\nInput:\nn = 5\n\nOutput:\n3\n\"\"\"",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBinarySubsequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(1 << i for i in range(n + 1) if (1 << i) == (1 << (n + 1 - i)) - 1)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(1 for _ in xrange(n + 1) if self.sum(n) == self.sum(n + 1))\n\n    def sum(self, n):\n        return sum(bin(i)[2:].count('1') for i in xrange(2**n))",
      -0.8583984375
    ],
    [
      "def binary_seq(n):\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                continue\n            if sum(bin(i)[2:]) == sum(bin(j)[2:]):\n                count += 1\n    return count\n\ndef main():\n    print(binary_seq(10))\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return self.findSumOfBits(n)\n    \n    def findSumOfBits(self, n):\n        nums = [1]\n        for i in range(2, n):\n            nums.append(nums[-1] + nums[-2])\n        \n        return sum(nums)",
      -0.8583984375
    ],
    [
      "from itertools import product\n\ndef sum_of_binary_seq_with_length_2(n):\n    return sum(product(range(2, 2*n + 2), repeat=2))\n\nprint(sum_of_binary_seq_with_length_2(8))",
      -0.8583984375
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport unittest\n\nfrom binary_sequence_with_sum_sum import BinarySequenceWithSumSum\n\n\nclass TestBinarySequenceWithSumSum(unittest.TestCase):\n    def test_binary_sequence_with_sum_sum(self):\n        binary_sequence_with_sum_sum = BinarySequenceWithSumSum()\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(6), 2)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(7), 3)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(8), 4)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(9), 5)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(10), 6)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(11), 7)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(12), 8)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(13), 9)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(14), 10)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(15), 11)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(16), 12)\n        self.assertEqual(binary_sequence_with_sum_sum.get_binary_sequence_with_sum_sum(17), 13)",
      -0.8583984375
    ],
    [
      "# @param {number} n\n# @return {number}\n# @examples\n# given n = 2\n# return 3\n# return 0\n# @examples\n# given n = 3\n# return 1\n# return 0\ndef binary_seq_sum(n):\n    return binary_sum_count(n)\n\ndef binary_sum_count(n):\n    return sum([sum([bin(x) for x in range(n)]) for i in range(2**n)])",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def countBinarySequences(self, n):\n        ret = 0\n        count = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(2, n + 1):\n            for j in range(n + 1 - i):\n                if count[i][j] == 0:\n                    continue\n                if count[i - 1][j + 1] == 0:\n                    continue\n                if count[i - 1][j] + count[i][j + 1] == i:\n                    count[i][j] += 1\n                    ret += 1\n        return ret\n\n\nif __name__ == '__main__':\n    assert Solution().countBinarySequences(2) == 4\n    assert Solution().countBinarySequences(3) == 7\n    assert Solution().countBinarySequences(5) == 17",
      -0.85888671875
    ],
    [
      "# https://oj.leetcode.com/problems/subsets/\nclass Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = [[]]\n        for i in range(1, len(nums) + 1):\n            res = [x + [nums[i - 1]] for x in res]\n        return res\n\nif __name__ == '__main__':\n    print Solution().subsets([1,2,3])\n    print Solution().subsets([3,3,3])",
      -0.85888671875
    ],
    [
      "def count_binary_seq(n):\n    ans = 0\n    for i in range(n):\n        if sum([2**i for i in range(n)]) == sum([2**(n-i) for i in range(n)]):\n            ans += 1\n    return ans\n\nprint count_binary_seq(2)\n\n# Time:  O(n)\n# Space: O(1)",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countBinary(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        max_sum = 0\n        for i in range(2, n):\n            max_sum = max(max_sum, i * 2)\n            if max_sum == i * 2 + i:\n                return i\n        return 0",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(1 for i in range(n+1) if sum(bin(i)[2:]) == sum(bin(i)[:n]))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def binarySubset(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(bin(i)[2:] == bin(i+1)[2:] for i in range(n))\n\n    def binarySubsetSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(bin(i)[2:] for i in range(n))\n\n\ns = Solution()\nprint s.binarySubset(4)\nprint s.binarySubsetSum(4)",
      -0.85888671875
    ],
    [
      "from collections import Counter\n\ndef count_binary_sequences(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    c = Counter(sum(bin(i)[2:] for i in range(2**n)) for i in range(2**n))\n    return sum(c.get(i, 0) for i in range(2**n))\n\nif __name__ == '__main__':\n    print(count_binary_sequences(10))",
      -0.85888671875
    ],
    [
      "import sys\nimport math\n\n# @include\ndef sum_of_bits(n):\n    return sum(1 << i for i in range(n))\n# @exclude\n\n\ndef main():\n    for n in range(1, 100):\n        print(n, sum_of_bits(n))\n\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "from collections import defaultdict\nimport math\n\ndef sum_of_bits(n):\n    return sum(bin(i).count('1') for i in range(2**n))\n\ndef binary_sequence(n):\n    return [sum_of_bits(i) for i in range(1, n+1)]\n\ndef main():\n    print(binary_sequence(2))\n    print(binary_sequence(3))\n    print(binary_sequence(4))\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "# https://leetcode.com/problems/sum-of-binary-subsequences/discuss/245739/Python-Solution-with-O(N^2)-Space\nclass Solution(object):\n    def binarySubsequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # dp[i][j] = the number of binary sequences with sum of first i bits and sum of last j bits is same as sum of first j bits\n        dp = [[0] * (n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i == 1 or j == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n][n]",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in range(1, n+1):\n            result += sum(bin(i)[2:]) == sum(bin(i+1)[::-1][2:])\n        return result\n\nif __name__ == '__main__':\n    print Solution().countBinarySequences(3)",
      -0.86083984375
    ],
    [
      "# @author   :   Shujia Zhang\n# @date     :   2013-01-30\n\ndef sum_of_n_bits(n):\n    return sum(bin(i).count('1') for i in range(2**n))\n\nprint sum_of_n_bits(10)",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def binarySubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        return sum([1<<(i+1) - 1 for i in xrange(len(nums) - 1)]) - sum([1<<(i+1) for i in xrange(len(nums) - 1)])",
      -0.86083984375
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def countBinarySequence(self, n):\n        if n <= 0:\n            return 0\n        result = 0\n        for i in range(2, n + 1):\n            sum_first = sum_last = 0\n            for j in range(0, n - i + 1):\n                sum_first += (1 << j)\n                sum_last += (1 << (n - 1 - j))\n            if sum_first == sum_last:\n                result += 1\n        return result",
      -0.89013671875
    ],
    [
      "class Solution(object):\n    def findLength(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(bin(i).count('1') for i in xrange(2**n)) == sum(bin(i).count('0') for i in xrange(2**n))",
      -1.134765625
    ],
    [
      "class Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        res = 0\n        for i in range(n):\n            res += self.countBinarySubstrings(s[i+1:n])\n            if s[i] == '0':\n                res += self.countBinarySubstrings(s[:i])\n        return res",
      -1.4580078125
    ],
    [
      "import timeit\n\n\ndef sum_of_binary_seq_of_length_2n(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    result = 0\n    while n >= 0:\n        result += n % 2\n        n //= 2\n    return result\n\n\nprint(timeit.timeit(stmt=\"sum_of_binary_seq_of_length_2n(1)\", setup=\"from __main__ import sum_of_binary_seq_of_length_2n\", number=1000))",
      -1.7041015625
    ],
    [
      "import math\nclass Solution(object):\n    def countBinarySubsequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/count-binary-subsequences/discuss/111452/Java-Python-C-Solution-2ms-O(n)\n        # https://discuss.leetcode.com/topic/84724/python-c-o-n-o-2ms-o-1ms\n        if n == 1:\n            return 1\n        # the first n-1 bits are the same, so we only need to check the last n-1 bits\n        # https://leetcode.com/problems/count-binary-subsequences/discuss/111452/Java-Python-C-Solution-2ms-O(n)\n        # https://discuss.leetcode.com/topic/84724/java-c-o-n-o-2ms-o-1ms\n        sum = 0\n        for i in range(n - 1):\n            sum += n - i\n            if sum == n:\n                return 2\n        return 0\n\ns = Solution()\nprint s.countBinarySubsequences(0)",
      -1.8486328125
    ],
    [
      "class Solution(object):\n    def binarySubsequenceSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(1, n+1):\n            result += sum(bin(i)[2:])\n        return result\n\nif __name__ == \"__main__\":\n    print Solution().binarySubsequenceSum(3)",
      -1.99609375
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        \n        nums = [0] * (n + 1)\n        \n        nums[0] = 1\n        \n        for i in range(1, n + 1):\n            nums[i] = nums[i-1] + nums[i-2]\n        \n        return nums[n]",
      -2.619140625
    ],
    [
      "class Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        s1 = sum(bin(i)[2:] for i in range(n))\n        s2 = sum(bin(i)[:2] for i in range(n))\n        return n*(n+1)//2 - s1 - s2",
      -2.79296875
    ],
    [
      "import unittest\nfrom binary_sequences import *\n\nclass TestBinarySequences(unittest.TestCase):\n    def test_binary_sequences(self):\n        self.assertEqual(sum_binary_sequence(0), 0)\n        self.assertEqual(sum_binary_sequence(1), 1)\n        self.assertEqual(sum_binary_sequence(2), 2)\n        self.assertEqual(sum_binary_sequence(3), 4)\n        self.assertEqual(sum_binary_sequence(4), 8)\n        self.assertEqual(sum_binary_sequence(5), 12)\n        self.assertEqual(sum_binary_sequence(6), 16)\n        self.assertEqual(sum_binary_sequence(7), 18)\n        self.assertEqual(sum_binary_sequence(8), 20)\n        self.assertEqual(sum_binary_sequence(9), 22)\n        self.assertEqual(sum_binary_sequence(10), 24)\n        self.assertEqual(sum_binary_sequence(11), 26)\n        self.assertEqual(sum_binary_sequence(12), 28)\n        self.assertEqual(sum_binary_sequence(13), 30)\n        self.assertEqual(sum_binary_sequence(14), 32)\n        self.assertEqual(sum_binary_sequence(15), 34)\n        self.assertEqual(sum_binary_sequence(16), 36)\n        self.assertEqual(sum_binary_sequence(17), 38)\n        self.assertEqual(sum_binary_sequence(18), 40)\n        self.assertEqual(sum_binary_sequence(19), 42)\n        self.assertEqual(sum_binary_sequence(20), 44)\n        self.assertEqual(sum_binary_sequence(21), 46)\n        self.assertEqual(sum_binary_sequence(22), 48)\n        self.assertEqual(sum_binary_sequence(23), 50)\n        self.assertEqual(sum_binary_sequence(24), 52)\n        self.assertEqual(sum_binary_sequence(25), 54)\n        self",
      -2.98828125
    ],
    [
      "import math\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        if n == 1:\n            return 1\n        l = [0] * (n + 1)\n        l[0] = 1\n        for i in xrange(1, n + 1):\n            l[i] = l[i - 1] + l[i - 2]\n        return l[n]",
      -3.603515625
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(bin(i)[2:].count('1') for i in range(1 << len(s)))\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-binary-substrings/solution/\n\n# 3ms 100%\nclass Solution {\n    public int countBinarySubstrings(String s) {\n        return countBinarySubstrings(s, 0, s.length());\n    }\n    private int countBinarySubstrings(String s, int start, int end) {\n        if (start == end) return 1;\n        if (end - start < 2) return 0;\n        int count = 0;\n        for (int i = start; i < end; i++) {\n            if (s.charAt(i) == '1') count += countBinarySubstrings(s, i + 1, end);\n            else count += countBinarySubstrings(s, start, i);\n        }\n        return count;\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public int countBinarySubstrings(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j < s.length(); j++) {\n                if (s.charAt(i) == '1' && s.charAt(j) == '0') count++;\n                else if (s.charAt(i) == '0' && s.charAt(j) == '1') count--;\n            }\n        }\n        return count;\n    }\n}\n'''",
      -4.15625
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        res = 0\n        for i in range(n):\n            res += self.countBinarySubstringsHelper(s, i, n, res)\n        return res\n        \n    def countBinarySubstringsHelper(self, s, start, end, res):\n        if start == end:\n            return 1\n        if start + 1 == end:\n            return self.countBinarySubstringsHelper(s, start+1, end, res)\n        \n        # if sum of first n bits is same as sum of last n bits, then there is a binary substring of length 2n\n        # if sum of first n bits is not same as sum of last n bits, then there is no binary substring of length 2n\n        # so there is no binary substring of length 2n, hence return 0\n        sum_first = sum(s[start:end])\n        sum_last = sum(s[start:end-1])\n        if sum_first == sum_last:\n            return 0\n        return self.countBinarySubstringsHelper(s, start, end-1, res)\n        \n        \nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-binary-substrings/solution/\n#\nApproach 1: Brute Force\nComplexity Analysis\nTime Complexity: O(n^2). We iterate over all characters of the string s.\nSpace Complexity: O(n).\n\n# 14ms 97.36%\nclass Solution {\n    public int countBinarySubstrings(String s) {\n        int res = 0;\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            res += countBinarySubstringsHelper(s, i, n,",
      -4.5625
    ],
    [
      "class Solution(object):\n    def numBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        count = 0\n        for i in range(n):\n            count += self.binarySearch(n - i) * self.binarySearch(i)\n        return count\n\n    def binarySearch(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = 2 ** n\n        while start < end:\n            mid = (start + end) / 2\n            if mid * mid == n:\n                return mid\n            if mid * mid < n:\n                start = mid + 1\n            else:\n                end = mid\n        return 0\n\n# Your NumBinarySequences solution looks good.",
      -5.12109375
    ],
    [
      "# https://www.hackerrank.com/challenges/count-binary-sequences/problem\n\n# 1st solution\n# from collections import Counter\n# def count_binary_sequences(n):\n#     return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n\n# 2nd solution\n# from collections import Counter\n# def count_binary_sequences(n):\n#     return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n\n# 3rd solution\ndef count_binary_sequences(n):\n    return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n\n\n\n# 4th solution\ndef count_binary_sequences(n):\n    # return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n    return sum(bin(i)[:n] == bin(i)[-n:])\n\n\n# 5th solution\ndef count_binary_sequences(n):\n    # return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n    return sum(bin(i)[:n] == bin(i)[-n:])\n\n\n# 6th solution\ndef count_binary_sequences(n):\n    # return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n    return sum(bin(i)[:n] == bin(i)[-n:])\n\n\n# 7th solution\ndef count_binary_sequences(n):\n    # return sum(1 for i in range(2**n) if sum(bin(i)[:n]) == sum(bin(i)[-n:]))\n    return sum(bin(i)[:n] == bin(i)[-n:])\n\n\n# 8th solution\ndef count_binary_sequ",
      -5.28125
    ],
    [
      "# https://oj.leetcode.com/problems/binary-substring-search/\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = 0\n        n = len(s)\n        for i in xrange(n):\n            for j in xrange(i, n):\n                if s[i] == s[j]:\n                    if sum(ord(x) for x in s[i:j+1]) == sum(ord(x) for x in s[j+1:i+1]):\n                        count += 1\n        return count\n\n# Time:  O(n)\n# Space: O(n)\n# Union Find\n# https://discuss.leetcode.com/topic/30608/nice-union-find-solution\nclass Solution2(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        count = 0\n        uf = UnionFind(n)\n        for i in xrange(n):\n            for j in xrange(i, n):\n                if s[i] == s[j]:\n                    if uf.find(i) == uf.find(j):\n                        count += 1\n        return count\n\nclass UnionFind(object):\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.n = n\n        self.p = [0] * (n + 1)\n        self.q = [0] * (n + 1)\n        for i in xrange(1, n + 1):\n            self.p[i] = self.q[i] = i\n        self.count = n\n\n    def find(self, i):\n        while self.p[i]!= i:\n            self.p[i] = self.p[self.p[i]]\n        return i\n\n    def unite(self, i, j):\n        i = self.find(i)",
      -5.29296875
    ],
    [
      "import os\nimport sys\nimport math\n\ndef sum_diff(s):\n    return sum(s) - sum(s[::-1])\n\ndef binary_search_sum_diff(a):\n    \"\"\"\n    :type a: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(a)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return sum_diff(a)\n    else:\n        left = 0\n        right = n\n        mid = (left + right) / 2\n        while left < right:\n            if sum_diff(a[left:mid]) == sum_diff(a[mid:]):\n                left = mid\n            else:\n                right = mid\n            mid = (left + right) / 2\n        if sum_diff(a[left:n]) == sum_diff(a):\n            return sum_diff(a[:left])\n        else:\n            return sum_diff(a[:right])\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    print binary_search_sum_diff(a)",
      -5.37109375
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def numBits_2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        while n > 0:\n            cnt += 2 ** n\n            n -= 1\n        return cnt\n\n    def numBits_3(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return 2 ** n - 1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-binary-substrings/solution/\n\n# 2ms 100%\nclass Solution {\n    public int numBits(int n) {\n        int cnt = 0;\n        while (n > 0) {\n            cnt += 2 << n;\n            n -= 1;\n        }\n        return cnt;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int numBits(int n) {\n        if (n == 0) return 0;\n        int cnt = 0;\n        while (n > 0) {\n            cnt += (n & 1) << n;\n            n >>= 1;\n        }\n        return cnt;\n    }\n}\n'''",
      -5.47265625
    ],
    [
      "def binary_search(x, l, h, sum):\n    if l == h:\n        return l\n    mid = (l + h) / 2\n    if sum == x[:sum] and sum == x[-sum:]:\n        return mid\n    if sum > x[:sum] and sum > x[-sum:]:\n        return binary_search(x, mid, h, sum)\n    elif sum < x[:sum] and sum < x[-sum:]:\n        return binary_search(x, l, mid, sum)\n    return binary_search(x, mid + 1, h, sum)\n\ndef find_binary_seq(x):\n    sum = 0\n    for i in range(len(x)):\n        sum += x[i]\n        sum %= 2**32\n    return binary_search(x, 0, len(x), sum)\n\nif __name__ == '__main__':\n    x = [1, 1, 1, 1, 1, 1, 1, 1, 1]\n    print find_binary_seq(x)",
      -5.53515625
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in xrange(n, 0, -1):\n            res += self.count_seq(i)\n        return res\n\n    def count_seq(self, n):\n        res = 0\n        for i in xrange(1, n+1):\n            if (n-i) % 2 == 0:\n                res += 1\n            if (n-i) % 2 == 1:\n                res += 2\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-binary-sequences/solution/\n\n# 1ms 100%\nclass Solution {\n    public int countBinarySequences(int n) {\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n            if ((n - i) % 2 == 0) {\n                res += 1;\n            }\n            if ((n - i) % 2 == 1) {\n                res += 2;\n            }\n        }\n        return res;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int countBinarySequences(int n) {\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n            if ((n - i) % 2 == 0) {\n                res += 1;\n            } else if ((n - i) % 2 == 1) {\n                res += 2;\n            }\n        }\n        return res;\n    }\n}\n'''",
      -5.625
    ],
    [
      "import math\n\ndef count_binary(n):\n    return sum(bin(i).count('1') for i in range(2 ** n))\n\ndef count_binary_1(n):\n    return sum(bin(i).count('1') for i in range(2 ** n))\n\ndef count_binary_2(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 1), 2 ** n))\n\ndef count_binary_3(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 1), 2 ** n))\n\ndef count_binary_4(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 2), 2 ** n))\n\ndef count_binary_5(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 3), 2 ** n))\n\ndef count_binary_6(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 4), 2 ** n))\n\ndef count_binary_7(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 5), 2 ** n))\n\ndef count_binary_8(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 6), 2 ** n))\n\ndef count_binary_9(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 7), 2 ** n))\n\ndef count_binary_10(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 8), 2 ** n))\n\ndef count_binary_11(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 9), 2 ** n))\n\ndef count_binary_12(n):\n    return sum(bin(i).count('1') for i in range(2 ** (n - 10), 2 ** n))\n\ndef count_",
      -5.83984375
    ],
    [
      "def count_binary_seqs(n):\n    res = 0\n    for i in range(2**n):\n        sum_ = sum(bin(i)[2:])\n        if sum_ == sum(bin(i)[:-2]):\n            res += 1\n    return res\n\nprint(count_binary_seqs(2))\nprint(count_binary_seqs(3))\nprint(count_binary_seqs(4))\nprint(count_binary_seqs(5))\nprint(count_binary_seqs(6))",
      -5.86328125
    ],
    [
      "from collections import Counter\n\n# Returns a list of all binary sequences of length n\ndef find_sequences(n):\n    result = []\n    if n == 0:\n        return result\n    if n == 1:\n        result.append([0, 1])\n        return result\n    for i in range(2, n+1):\n        result += find_sequences(i)\n        result += find_sequences(n-i)\n        result += find_sequences(n-i-1)\n    return result\n\ndef find_sequences_2(n):\n    result = []\n    if n == 0:\n        return result\n    if n == 1:\n        result.append([0, 1])\n        return result\n    for i in range(2, n+1):\n        result += find_sequences_2(i)\n        result += find_sequences_2(n-i)\n        result += find_sequences_2(n-i-1)\n    return result\n\ndef find_sequences_3(n):\n    result = []\n    if n == 0:\n        return result\n    if n == 1:\n        result.append([0, 1])\n        return result\n    for i in range(2, n+1):\n        result += find_sequences_3(i)\n        result += find_sequences_3(n-i)\n        result += find_sequences_3(n-i-1)\n    return result\n\ndef find_sequences_4(n):\n    result = []\n    if n == 0:\n        return result\n    if n == 1:\n        result.append([0, 1])\n        return result\n    for i in range(2, n+1):\n        result += find_sequences_4(i)\n        result += find_sequences_4(n-i)\n        result += find_sequences_4(n-i-1)\n    return result\n\ndef find_sequences_5(n):\n    result = []\n    if n == 0:\n        return result\n    if n == 1:\n        result.append([0, 1])\n        return result\n    for i in range(2, n",
      -6.36328125
    ],
    [
      "class Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return self.binarySequence_slow(n)\n\n    def binarySequence_slow(self, n):\n        return sum(1 << x for x in range(n, 1, -1))\n\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(1 << x for x in range(n, 1, -1))",
      -6.828125
    ],
    [
      "class Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(2, n+1):\n            count += (1 << i) - 1\n        count -= (1 << n) - 1\n        return count\n\n\nif __name__ == '__main__':\n    Solution().binarySequence(3)",
      -6.875
    ],
    [
      "import time\nstart_time = time.time()\n\ndef find_all_binary_sequences(n):\n    \"\"\"\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    ret = []\n    for i in range(n):\n        for j in range(i + 1):\n            ret.append([])\n            for k in range(n):\n                if i == k:\n                    ret[i].append(0)\n                elif j == k:\n                    ret[i].append(0)\n                elif i + j == k:\n                    ret[i].append(1)\n                else:\n                    ret[i].append(0)\n    return ret\n\nprint \"Time:\", time.time() - start_time",
      -7.31640625
    ],
    [
      "def sum_of_bits(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    total = 0\n    for i in range(n):\n        total += 2**(n - i - 1)\n    return total\n\ndef binary_sequence_sum(n):\n    total = 0\n    for i in range(2**n):\n        if i & 2**(n-1) == 0:\n            total += i\n    return total\n\ndef sum_of_bits_2(n):\n    return sum(i & 2**(n-1) for i in range(2**n))\n\ndef sum_of_bits_3(n):\n    total = 0\n    for i in range(2**n):\n        if i & 2**(n-1) == 0:\n            total += i\n    return total\n\ndef sum_of_bits_4(n):\n    total = 0\n    for i in range(2**n):\n        if i & 2**(n-1) == 0:\n            total += i\n    return total\n\ndef sum_of_bits_5(n):\n    total = 0\n    for i in range(2**n):\n        if i & 2**(n-1) == 0:\n            total += i\n    return total\n\nif __name__ == \"__main__\":\n    assert sum_of_bits(0) == 0\n    assert sum_of_bits(1) == 1\n    assert sum_of_bits(2) == 3\n    assert sum_of_bits(3) == 7\n    assert sum_of_bits(4) == 15\n    assert sum_of_bits(5) == 31\n    assert sum_of_bits(6) == 63\n    assert sum_of_bits(7) == 127\n    assert sum_of_bits(8) == 255\n    assert sum_of_bits(9) == 511\n    assert sum_of_bits(10) == 1023\n    assert sum_of_bits(11) == 2047\n    assert sum_of_bits(12) == 4095\n    assert sum_of_bits(13) == 8191\n    assert sum_of",
      -7.6015625
    ],
    [
      "class Solution(object):\n    def find_binary_sequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def count_binary(n, sum):\n            if sum == 0:\n                return 0\n            if sum == 1:\n                return 1\n            if sum == 2:\n                return 1\n            if sum == 3:\n                return 2\n            if sum == 4:\n                return 3\n            if sum == 5:\n                return 4\n            if sum == 6:\n                return 5\n            if sum == 7:\n                return 6\n            if sum == 8:\n                return 7\n            if sum == 9:\n                return 8\n            if sum == 10:\n                return 9\n            if sum == 11:\n                return 10\n            if sum == 12:\n                return 11\n            if sum == 13:\n                return 12\n            if sum == 14:\n                return 13\n            if sum == 15:\n                return 14\n            if sum == 16:\n                return 15\n            if sum == 17:\n                return 16\n            if sum == 18:\n                return 17\n            if sum == 19:\n                return 18\n            if sum == 20:\n                return 19\n            if sum == 21:\n                return 20\n            if sum == 22:\n                return 21\n            if sum == 23:\n                return 22\n            if sum == 24:\n                return 23\n            if sum == 25:\n                return 24\n            if sum == 26:\n                return 25\n            if sum == 27:\n                return 26\n            if sum == 28:\n                return 27\n            if sum == 29:\n                return 28\n            if sum == 30:\n                return 29\n            if sum == 31:\n                return 30\n            if sum == 32:\n                return 31\n            if sum == 33:\n                return 32\n            if sum == 34:\n                return 33\n            if sum == 35:\n                return 34\n            if sum == 36:\n                return 35\n            if sum == 37:\n                return 36\n            if sum == 38:\n                return 37\n            if sum == 39:\n                return 38\n            if sum == 40:\n                return 39\n            if sum == 41:\n                return 40",
      -7.82421875
    ],
    [
      "# https://www.hackerrank.com/challenges/binary-seq-with-sum-equal-to-sum-of-next-n-bits/problem\n\nimport collections\n\ndef binary_sequence_with_sum_equal_to_sum_of_next_n_bits(n):\n    count = collections.Counter()\n    for i in range(2 ** n):\n        count[i] += sum(i & (i + 1))\n    return count\n\nif __name__ == '__main__':\n    n = int(input())\n    print(binary_sequence_with_sum_equal_to_sum_of_next_n_bits(n))",
      -7.8515625
    ],
    [
      "# https://oj.leetcode.com/problems/binary-subsequence-sum/\n\nclass Solution(object):\n    def binarySubsequenceSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # https://oj.leetcode.com/discuss/3870/solution-using-bit-manipulation-with-n-1-and-n-2-n-1-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3486/solution-using-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3698/concise-java-solution-with-binary-subsequence-sum\n        # https://oj.leetcode.com/discuss/3081/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3062/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3065/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3183/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3186/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/3186/solution-with-bit-manipulation-with-n-1-and-n-2-n-3-n-4\n        # https://oj.leetcode.com/discuss/",
      -8.7421875
    ],
    [
      "# https://www.hackerrank.com/challenges/binary-subarrays-with-sum-equal-to-sum-of-n-binary-slices/problem\n# Input:\n# The first line of input contains an integer T denoting the number of test cases. T test cases follow.\n# Each test case consists of two lines. The first line contains an integer N denoting the length of the input string.\n# The second line contains N space-separated integers denoting the input string.\n# Output:\n# For each test case, output a single line containing the number of binary sequences that satisfy the conditions.\n# For example, if N = 10 and the input string is\n# \"101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101",
      -9.1015625
    ],
    [
      "def sumOfBinarySequence(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n < 2:\n        return 0\n    # 2n+1, 2n+2\n    # n+1, n+2\n    # n-1, n\n    # n-2, n-1\n    # 2n-1, 2n\n    # 2n-2, 2n-1\n    # 2n-3, 2n-2\n    # 2n-4, 2n-3\n    # 2n-5, 2n-4\n    # 2n-6, 2n-5\n    # 2n-7, 2n-6\n    # 2n-8, 2n-7\n    # 2n-9, 2n-8\n    # 2n-10, 2n-9\n    # 2n-11, 2n-10\n    # 2n-12, 2n-11\n    # 2n-13, 2n-12\n    # 2n-14, 2n-13\n    # 2n-15, 2n-14\n    # 2n-16, 2n-15\n    # 2n-17, 2n-16\n    # 2n-18, 2n-17\n    # 2n-19, 2n-18\n    # 2n-20, 2n-19\n    # 2n-21, 2n-20\n    # 2n-22, 2n-21\n    # 2n-23, 2n-22\n    # 2n-24, 2n-23\n    # 2n-25, 2n-24\n    # 2n-26, 2n-25\n    # 2n-27, 2n-26\n    # 2n-28, 2n-27\n    # 2n-29, 2n-28\n    # 2n-30, 2n-29\n    # 2n-31, 2n-30\n    # 2n-32, 2n-31\n    # 2n-33, 2n-32\n    # 2n-34, 2n-33\n    # 2n-35, 2n-34\n    # 2n-36, 2n-35",
      -9.21875
    ],
    [
      "# The sum of the first n bits is equal to the sum of the last n bits.\n# The sum of the last n bits is equal to the sum of the first n bits.\n# The sum of the first n bits is equal to the sum of the last n bits.\n# Note: the sum of the first n bits is equal to the sum of the last n bits.\n# Example 1:\n# Input: n = 1\n# Output: 4\n# Explanation:\n# The sequences are:\n# 0 1 2 3\n# 0 2 4 6\n# 0 4 8 12\n# 0 6 12 18\n# 0 8 12 24\n# The sum of the first n bits is equal to the sum of the last n bits.\n# The sum of the last n bits is equal to the sum of the first n bits.\n# The sum of the first n bits is equal to the sum of the last n bits.\n# Note:\n# n is in the range [0, 10^4].\n# The input is guaranteed to have a sum equal to the sum of the last n bits.\n# Follow up:\n# Can you solve it without using any extra space?\n\nclass Solution(object):\n    def numBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 4\n        if n == 2:\n            return 8\n        if n == 3:\n            return 16\n        if n == 4:\n            return 32\n        if n == 5:\n            return 64\n        if n == 6:\n            return 128\n        if n == 7:\n            return 256\n        if n == 8:\n            return 512\n        return n\n\n\nif __name__ == '__main__':\n    assert Solution().numBinarySequences(1) == 4\n    assert Solution().numBinarySequences(2) == 8\n    assert Solution().numBinarySequences(3) == 16\n    assert Solution().numBinarySequences(4) == 32\n    assert Solution().numBinarySequences(5) == 64\n    assert Solution().numBinarySequences(6) == 128\n    assert Solution().numBinarySequences(7) == 256\n    assert Solution().numBinary",
      -10.0390625
    ],
    [
      "# https://leetcode.com/problems/sum-of-binary-substrings/discuss/170143/Python-O(2n)-time-O(n)-space\nclass Solution(object):\n    def sumOfBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s is None or len(s) == 0:\n            return 0\n        n = len(s)\n        ret = 0\n        for i in range(0, n):\n            ret += self.countBits(s[i:i+2])\n        return ret\n\n    def countBits(self, x):\n        ret = 0\n        while x:\n            ret += x & 1\n            x >>= 1\n        return ret\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def sumOfBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s is None or len(s) == 0:\n            return 0\n        n = len(s)\n        ret = 0\n        for i in range(0, n):\n            ret += self.countBits(s[i:i+2])\n        return ret\n\n    def countBits(self, x):\n        ret = 0\n        while x:\n            ret += x & 1\n            x >>= 1\n        return ret\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3(object):\n    def sumOfBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s is None or len(s) == 0:\n            return 0\n        n = len(s)\n        ret = 0\n        for i in range(0, n):\n            ret += self.countBits(s[i:i+2])\n        return ret\n\n    def countBits(self, x):\n        ret = 0\n        while x:\n            ret += x & 1\n            x >>= 1\n        return ret\n\n# Time:",
      -10.21875
    ],
    [
      "import unittest\n\nclass Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(map(lambda x: sum(map(lambda y: (x[0] + y[0]) % 2, x[1:])), range(2, n + 1)))\n\n    def binarySequence2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(map(lambda x: sum(map(lambda y: (x[0] + y[0]) % 2, x[1:])), range(2, n + 1))) % (2 ** n)\n\n    def binarySequence3(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum(map(lambda x: sum(map(lambda y: (x[0] + y[0]) % 2, x[1:])), range(2, n + 1))) % (2 ** n)\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/binary-sequence/solution/\n\n# DFS:\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum(sum(1))) % 2\n# 2n - sum(sum(1) + sum",
      -10.390625
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        count = 0\n        for i in range(1, n + 1):\n            for j in range(0, i):\n                if i - j == 0:\n                    count += 1\n        return count\n\n\nif __name__ == '__main__':\n    print Solution().countBinarySequences(1)",
      -10.828125
    ],
    [
      "class Solution(object):\n    def countBinarySubsequences(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/discuss/111251/python-solution-with-explanation\n        # 1. for i in range(N+1):\n        # 2. \tcount = 0\n        # 3. \tfor j in range(N-i+1):\n        # 4. \t\tif i+j == i+1 and (sum(bin(i+j)) == sum(bin(N-i+j))):\n        # 5. \t\t\tcount += 1\n        # 6. return count\n        return 0\n\n\nif __name__ == '__main__':\n    assert Solution().countBinarySubsequences(2) == 3\n    assert Solution().countBinarySubsequences(10) == 15\n    assert Solution().countBinarySubsequences(20) == 14\n    assert Solution().countBinarySubsequences(30) == 5\n    assert Solution().countBinarySubsequences(100) == 12\n    assert Solution().countBinarySubsequences(1000) == 10\n    assert Solution().countBinarySubsequences(10000) == 3",
      -11.015625
    ],
    [
      "# @include\ndef find_all_binary_sequences(n):\n    s = 0\n    for i in range(n):\n        s += bin(i).count('1')\n    return sum(bin(i).count('1') for i in range(n)) == sum(bin(i).count('0') for i in range(n))\n# @exclude\n\n\ndef main():\n    # 3\n    # 1 0 1\n    # 1 0 1\n    # 1 0 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    # 1 1 1\n    #",
      -11.3046875
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # base case\n        if n == 0:\n            return 1\n        # binary search\n        low, high = 0, n\n        while low < high:\n            mid = low + (high - low) / 2\n            if mid > 0:\n                high = mid - 1\n            else:\n                low = mid + 1\n            if mid % 2 == 0:\n                # mid is even\n                if mid == 0:\n                    # n-1\n                    return sum(bin(x)[2:].count(1) for x in range(1, n))\n                else:\n                    # mid+1\n                    return sum(bin(x)[2:].count(1) for x in range(1, mid + 1))\n            else:\n                # mid is odd\n                if mid == n:\n                    # n\n                    return sum(bin(x)[2:].count(1) for x in range(1, n))\n                else:\n                    # mid+1\n                    return sum(bin(x)[2:].count(1) for x in range(1, mid + 1))\n        return 1\n\n\nif __name__ == \"__main__\":\n    assert Solution().countBinarySequences(1) == 1\n    assert Solution().countBinarySequences(2) == 1\n    assert Solution().countBinarySequences(3) == 2\n    assert Solution().countBinarySequences(4) == 3\n    assert Solution().countBinarySequences(5) == 5\n    assert Solution().countBinarySequences(6) == 8\n    assert Solution().countBinarySequences(7) == 13\n    assert Solution().countBinarySequences(8) == 21\n    assert Solution().countBinarySequences(9) == 34\n    assert Solution().countBinarySequences(10) == 55",
      -11.3671875
    ],
    [
      "import unittest\n\n# @include\ndef count_binary_sequences(n):\n    # Counts number of binary sequences of length 2n.\n    count = 0\n    # Start with n-1 bits.\n    for i in range(n - 1):\n        # Count the number of binary sequences of length 2n.\n        count += count_binary_sequence(i + 1, n)\n    # Count the number of binary sequences of length 2n.\n    count += count_binary_sequence(0, n)\n    return count\n# @exclude\n\n\ndef count_binary_sequence(start, end):\n    # Counts number of binary sequences of length 2n.\n    # If the last n bits of a binary sequence are same as the sum of the first n bits,\n    # return 1. Otherwise return 0.\n    if end - start < 1:\n        return 0\n    if start == 0 and end == n:\n        return 1\n    if start == 0:\n        return count_binary_sequence(start + 1, end)\n    if end == n:\n        return count_binary_sequence(start, end - 1)\n    return count_binary_sequence(start + 1, end) + count_binary_sequence(start, end - 1)\n\n\nclass Test(unittest.TestCase):\n    def test_count_binary_sequences(self):\n        self.assertEqual(count_binary_sequences(1), 0)\n        self.assertEqual(count_binary_sequences(2), 3)\n        self.assertEqual(count_binary_sequences(3), 9)\n        self.assertEqual(count_binary_sequences(4), 25)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -12.1640625
    ],
    [
      "class Solution(object):\n    def countBinarySequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        dp = [0] * (2 ** n)\n        dp[0] = 1\n        for i in range(1, 2 ** n):\n            dp[i] = dp[i >> 1] + dp[i & 1]\n        return dp[2 ** n - 1]\n\n# debug\ns = Solution()\nprint s.countBinarySequences(1)\nprint s.countBinarySequences(2)\nprint s.countBinarySequences(3)\nprint s.countBinarySequences(4)",
      -12.5546875
    ],
    [
      "class Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        a = [0] * (2 ** n)\n        b = [0] * (2 ** n)\n        cnt = 0\n        for i in range(2 ** n):\n            if a[i] == b[i]:\n                cnt += 1\n            else:\n                a[i] = b[i] = 0\n        return cnt\n\n\nif __name__ == \"__main__\":\n    assert Solution().binarySequence(1) == 1\n    assert Solution().binarySequence(2) == 3\n    assert Solution().binarySequence(3) == 7\n    assert Solution().binarySequence(4) == 13\n    assert Solution().binarySequence(5) == 21",
      -12.65625
    ],
    [
      "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def numBinarySequences(self, n):\n        return sum(self.numBinarySequence(n))\n        \n    def numBinarySequence(self, n):\n        return sum(self.countBinarySequence(n))\n        \n    def countBinarySequence(self, n):\n        if n == 0:\n            return 0\n        else:\n            count = 0\n            for i in range(n+1):\n                count += self.countBinarySequence(n-i)\n            return count\n            \n        \ns = Solution()\nprint s.numBinarySequences(0)\nprint s.numBinarySequences(1)\nprint s.numBinarySequences(2)\nprint s.numBinarySequences(3)\nprint s.numBinarySequences(4)\nprint s.numBinarySequences(5)\nprint s.numBinarySequences(6)\nprint s.numBinarySequences(7)\nprint s.numBinarySequences(8)\nprint s.numBinarySequences(9)\nprint s.numBinarySequences(10)\nprint s.numBinarySequences(11)\nprint s.numBinarySequences(12)\nprint s.numBinarySequences(13)\nprint s.numBinarySequences(14)\nprint s.numBinarySequences(15)\nprint s.numBinarySequences(16)\nprint s.numBinarySequences(17)\nprint s.numBinarySequences(18)\nprint s.numBinarySequences(19)\nprint s.numBinarySequences(20)\nprint s.numBinarySequences(21)\nprint s.numBinarySequences(22)\nprint s.numBinarySequences(23)\nprint s.numBinarySequences(24)\nprint s.numBinarySequences(25)\nprint s.numBinarySequences(26)\nprint s.numBinarySequences(27)\nprint s.numBinarySequences(28)\nprint s.numBinarySequences(29",
      -12.6875
    ],
    [
      "import unittest\n\n\ndef sum_binary_seq(n):\n    return sum(bin(i)[2:] for i in range(2**n))\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(sum_binary_seq(1), 1)\n        self.assertEqual(sum_binary_seq(2), 3)\n        self.assertEqual(sum_binary_seq(3), 7)\n        self.assertEqual(sum_binary_seq(4), 13)\n        self.assertEqual(sum_binary_seq(5), 21)\n        self.assertEqual(sum_binary_seq(6), 35)\n        self.assertEqual(sum_binary_seq(7), 51)\n        self.assertEqual(sum_binary_seq(8), 71)\n        self.assertEqual(sum_binary_seq(9), 91)\n        self.assertEqual(sum_binary_seq(10), 100)\n        self.assertEqual(sum_binary_seq(11), 110)\n        self.assertEqual(sum_binary_seq(12), 120)\n        self.assertEqual(sum_binary_seq(13), 130)\n        self.assertEqual(sum_binary_seq(14), 140)\n        self.assertEqual(sum_binary_seq(15), 150)\n        self.assertEqual(sum_binary_seq(16), 160)\n        self.assertEqual(sum_binary_seq(17), 170)\n        self.assertEqual(sum_binary_seq(18), 180)\n        self.assertEqual(sum_binary_seq(19), 190)\n        self.assertEqual(sum_binary_seq(20), 200)\n        self.assertEqual(sum_binary_seq(21), 210)\n        self.assertEqual(sum_binary_seq(22), 220)\n        self.assertEqual(sum_binary_seq(23), 230)\n        self.assertEqual(sum_binary_seq(24), 240)\n        self.assertEqual(sum_binary_seq(25), 250)\n        self.assertEqual",
      -12.890625
    ],
    [
      "import unittest\n\ndef is_binary(s):\n    return all(ord(c) < 128 for c in s)\n\ndef sum_bits(s):\n    return sum(ord(c) for c in s)\n\ndef count_binary(n):\n    return sum(1 if is_binary(s) else 0 for s in str(n))\n\nclass TestCode(unittest.TestCase):\n    def test_is_binary(self):\n        self.assertTrue(is_binary(\"11\"))\n        self.assertFalse(is_binary(\"100\"))\n        self.assertFalse(is_binary(\"101\"))\n\n    def test_sum_bits(self):\n        self.assertEqual(sum_bits(\"11\"), 3)\n        self.assertEqual(sum_bits(\"100\"), 4)\n        self.assertEqual(sum_bits(\"101\"), 3)\n        self.assertEqual(sum_bits(\"100101\"), 5)\n\n    def test_count_binary(self):\n        self.assertEqual(count_binary(2), 3)\n        self.assertEqual(count_binary(3), 3)\n        self.assertEqual(count_binary(4), 5)\n        self.assertEqual(count_binary(5), 7)\n        self.assertEqual(count_binary(6), 11)\n        self.assertEqual(count_binary(7), 15)\n        self.assertEqual(count_binary(8), 23)\n        self.assertEqual(count_binary(9), 31)\n        self.assertEqual(count_binary(10), 41)\n        self.assertEqual(count_binary(11), 51)\n        self.assertEqual(count_binary(12), 61)\n        self.assertEqual(count_binary(13), 71)\n        self.assertEqual(count_binary(14), 83)\n        self.assertEqual(count_binary(15), 95)\n        self.assertEqual(count_binary(16), 107)\n        self.assertEqual(count_binary(17), 119)\n        self.assertEqual(count_binary(18), 131)\n        self.assertE",
      -14.1953125
    ],
    [
      "import unittest\n\n\nclass Solution(object):\n    def binarySequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return sum([1 << x for x in range(n + 1)]) - sum([1 << (n - x - 1) for x in range(n + 1)])\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/binary-sequence-with-sum-equal-to-the-sum-of-its-last-n-bits/solution/\n\n# 1ms 100%\nclass Solution {\n    public int binarySequence(int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += 1 << i;\n        }\n        int count = 0;\n        while (sum > 0) {\n            int t = sum & -sum;\n            sum -= t;\n            count++;\n        }\n        return count;\n    }\n}\n\n# 3ms 100%\nclass Solution {\n    public int binarySequence(int n) {\n        return Integer.bitCount(sum(n));\n    }\n\n    public int sum(int n) {\n        return n == 0? 0 : (n & 1) == 0? n : sum(n - 1) + 1;\n    }\n}\n'''",
      -14.375
    ],
    [
      "class Solution:\n    # @param {int} n\n    # @return {int}\n    def countBinarySequences(self, n):\n        ans = 0\n        n = n-1\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                if (i+j)&1:\n                    ans += 1\n                    if (i&j)&1:\n                        ans += 1\n        return ans\n\nif __name__ == \"__main__\":\n    print Solution().countBinarySequences(5)",
      -15.890625
    ],
    [
      "# @author: Junaid Quresh\n# @date:   2016-06-06\n# @modified by:   @date:   2016-06-06\n# @modified by:   @date:   2016-06-06\n# @description:   # TODO: Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n# @reference: https://www.hackerrank.com/challenges/count-binary-sequences/problem\n\ndef count_binary_seq(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(0, n):\n        if i % 2 == 0:\n            sum_bits = sum_bits_left = sum_bits_right = 0\n        else:\n            sum_bits = sum_bits_left = sum_bits_right = 1\n\n        for j in range(0, i + 1):\n            sum_bits = sum_bits * 2\n            sum_bits_left = sum_bits_left + 1\n            sum_bits_right = sum_bits_right + 1\n\n        if sum_bits == sum_bits_left + sum_bits_right:\n            count += 1\n\n    return count\n\n\nif __name__ == '__main__':\n    n = int(input())\n    print(count_binary_seq(n))",
      -15.9921875
    ],
    [
      "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def countBinary(self, n):\n        if n == 0:\n            return 0\n        # p = 1, q = 2, r = 4, s = 8\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(r + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(s + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(s + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(r + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(s + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(r + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(s + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(r + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(s + i)[2:])\n        # return sum(bin(p + i)[2:]) == sum(bin(q + i)[2:])\n        return sum(bin(p + i)[2:]) == sum(bin(r + i)[2:])\n\n\nif __name__ == '__main__':\n    print Solution().countBinary",
      -16.09375
    ],
    [
      "import sys\nimport timeit\nimport os\nimport random\n\nsys.path.append(os.path.join(os.path.dirname(__file__), '..'))\nimport pyspark.sql.functions as F\n\nfrom pyspark.sql import SparkSession\n\n# Use SparkSession to create a SparkContext\nspark = SparkSession.builder.appName(\"Binary Sequence Count\").getOrCreate()\n\n# Use the SparkContext to create a SparkContext\nsc = spark.sparkContext\n\n# Create a Spark SQL DataFrame\ndf = sc.parallelize([\n    [random.randint(0, 1) for _ in range(100000)]\n    for _ in range(100)]).toDF()\n\n# Create a Spark SQL DataFrame with the sum of the first and last bits of each element\ncounts = df.withColumn(\"sum\", F.sum(F.bitwise(F.bitwiseAnd(df.value, 0x01), 0x01).cast(int))).withColumn(\"sum2\", F.sum(F.bitwise(F.bitwiseAnd(df.value, 0x01), 0x01).cast(int).bitwiseOr(F.bitwiseAnd(df.value, 0x01).cast(int).bitwiseOr(0x01))))\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts2 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts3 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts4 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts5 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts6 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts7 = spark.createDataFrame(counts)\n\n# Use the Spark SQL DataFrame to create a Spark SQL DataFrame\ncounts8 = spark.createDataFrame(counts)\n\n#",
      -16.203125
    ],
    [
      "import math\nimport sys\n\ndef get_sum(n, nums):\n    sum_nums = 0\n    for num in nums:\n        sum_nums += num\n    sum_nums %= 2\n    \n    for i in range(n):\n        sum_nums += nums[i]\n        sum_nums %= 2\n    \n    return sum_nums\n\ndef count(n, nums):\n    if n == 0:\n        return 0\n    \n    # sum of all nums is same as sum of last n bits\n    sum_nums = get_sum(n, nums)\n    \n    # count the number of binary sequences that sum to the sum of last n bits\n    count = 0\n    for i in range(n):\n        sum_nums += nums[i]\n        if sum_nums % 2 == 0:\n            count += 1\n    \n    return count\n    \nif __name__ == '__main__':\n    print count(0, [1, 2, 3])\n    print count(1, [1, 2, 3])\n    print count(2, [1, 2, 3])\n    print count(3, [1, 2, 3])\n    print count(4, [1, 2, 3])\n    print count(5, [1, 2, 3])\n    print count(6, [1, 2, 3])\n    print count(7, [1, 2, 3])\n    print count(8, [1, 2, 3])\n    print count(9, [1, 2, 3])\n    print count(10, [1, 2, 3])\n    print count(11, [1, 2, 3])\n    print count(12, [1, 2, 3])\n    print count(13, [1, 2, 3])\n    print count(14, [1, 2, 3])\n    print count(15, [1, 2, 3])\n    print count(16, [1, 2, 3])\n    print count(17, [1, 2, 3])\n    print count(18, [1, 2, 3])\n    print count(19, [1, 2, 3])\n    print",
      -17.140625
    ],
    [
      "class Solution(object):\n    def binarySubsequenceSum(self, n, s):\n        \"\"\"\n        :type n: int\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # dp\n        dp = [0] * (2 ** n)\n        for i in range(2 ** n):\n            dp[i] = sum(dp[2 * i:2 * i + 2])\n        return dp[2 ** n - 1]\n\na = Solution()\nprint(a.binarySubsequenceSum(5, '11101'))",
      -17.546875
    ],
    [
      "import math\n\ndef find_binary_seq_sum(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    count = 0\n    for i in range(2, n + 1):\n        if (2 ** i) - 1 == sum(bin(i)[2:]):\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    print(find_binary_seq_sum(10))\n    print(find_binary_seq_sum(20))\n    print(find_binary_seq_sum(32))\n    print(find_binary_seq_sum(100))\n    print(find_binary_seq_sum(1000))\n    print(find_binary_seq_sum(2000))\n    print(find_binary_seq_sum(4000))\n    print(find_binary_seq_sum(10000))\n    print(find_binary_seq_sum(20000))\n    print(find_binary_seq_sum(40000))\n    print(find_binary_seq_sum(100000))\n    print(find_binary_seq_sum(200000))\n    print(find_binary_seq_sum(400000))\n    print(find_binary_seq_sum(1000000))\n    print(find_binary_seq_sum(2000000))\n    print(find_binary_seq_sum(4000000))\n    print(find_binary_seq_sum(10000000))\n    print(find_binary_seq_sum(20000000))\n    print(find_binary_seq_sum(40000000))\n    print(find_binary_seq_sum(100000000))\n    print(find_binary_seq_sum(200000000))\n    print(find_binary_seq_sum(4000000000))\n    print(find_binary_seq_sum(10000000000))\n    print(find_binary_seq_sum(20000000000))\n    print(find_binary_seq_sum(400000000000))\n    print(find_binary_seq_sum(1000000000000))\n    print(find_binary_seq_sum(200000000000))\n    print",
      -17.59375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}