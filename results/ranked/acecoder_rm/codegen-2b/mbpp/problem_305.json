{
  "problem": {
    "task_id": "MBPP/316",
    "prompt": "Write a function to find the index of the last occurrence of a given number in a sorted array.",
    "canonical_solution": "def find_last_occurrence(A, x):\r\n    (left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result ",
    "test_list": [
      "assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3",
      "assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9",
      "assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6"
    ],
    "challenge_test_list": [],
    "problem_id": 305
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def last_occurrence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    i = len(arr) - 1\n    while i >= 0:\n        if arr[i] == target:\n            return i\n        elif arr[i] > target:\n            i -= 1\n        else:\n            i -= 1\n    return -1\n\n\nif __name__ == \"__main__\":\n    assert last_occurrence([2, 5, 1, 6, 4], 5) == 4\n    assert last_occurrence([2, 5, 1, 6, 4], 7) == -1",
      5.10546875
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def lastIndex(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        start = 0\n        end = n-1\n        while start < end:\n            mid = start + (end-start)/2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid+1\n            else:\n                end = mid\n        return start",
      3.15625
    ],
    [
      "class Solution:\n    def lastPosition(self, arr: List[int], n: int) -> int:\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == n:\n                return mid\n            elif arr[mid] > n:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n\n\n# TESTS\nfor arr, n, expected in [\n    ([1, 3, 4, 5, 7], 7, 4),\n    ([1, 2, 3, 4, 5, 6], 5, 4),\n    ([1, 2, 3, 4, 5, 6], 7, -1),\n    ([1, 2, 3, 4, 5, 6], 7, -1),\n    ([1, 2, 3, 4, 5, 6], 1, 0),\n]:\n    sol = Solution()\n    actual = sol.lastPosition(arr, n)\n    print(\"Last position of\", n, \"in\", arr, \"->\", actual)\n    assert actual == expected",
      2.64453125
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if nums == None or nums == []:\n            return -1\n\n        length = len(nums)\n        if length == 0:\n            return -1\n\n        idx = 0\n        while idx < length:\n            if nums[idx] == target:\n                return idx\n            if nums[idx] < target:\n                idx += 1\n            else:\n                idx -= 1\n\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,3,4,5,6,7,8]\n    nums = [7,6,5,4,3,2,1]\n    nums = [1,1,1,1,1,1,1,1]\n    nums = [1]\n    nums = [1]\n    print sol.lastPosition(nums, 1)",
      2.154296875
    ],
    [
      "import math\n\n\ndef find_last_occurrence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # Sort the list\n    arr = sorted(arr)\n    # Find the last occurrence\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == target:\n            return i\n        elif arr[i] > target:\n            break\n\n    return -1\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 3, 2, 1, 4, 4, 3, 2, 1, 4, 4, 3, 2, 1]\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 2))\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 2))\n    print(find_last_occurrence(arr, 2))\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 2))\n    print(find_last_occurrence(arr, 2))\n    print(find_last_occurrence(arr, 4))\n    print(find_last_occurrence(arr, 4))",
      2.0078125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param {ListNode} head\n    # @param {integer} val\n    # @return {integer}\n    def lastIndexOfNumber(self, head, val):\n        if not head:\n            return -1\n        slow = head\n        fast = head\n        while fast.next:\n            if fast.next.val == val:\n                return slow.val\n            fast = fast.next\n            slow = slow.next\n        return -1\n\n    # @param {ListNode} head\n    # @param {integer} val\n    # @return {ListNode}\n    def lastIndexOfNumber_iterative(self, head, val):\n        slow = head\n        fast = head\n        while fast.next:\n            if fast.next.val == val:\n                return slow\n            slow = slow.next\n            fast = fast.next\n        return -1",
      1.994140625
    ],
    [
      "from typing import List\n\nclass Solution:\n    \"\"\"\n    @param: A list of integers\n    @return: the index of the last number\n    \"\"\"\n    def lastPosition(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        size = len(nums)\n        \n        for i in range(size-1):\n            if nums[i] < nums[i+1]:\n                return i\n        return size-1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.lastPosition([1, 2, 3, 1]))\n    print(sol.lastPosition([2, 1, 3, 4]))\n    print(sol.lastPosition([4, 1, 3, 4]))\n    print(sol.lastPosition([3, 1, 3, 4]))",
      1.7890625
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n-1, -1, -1):\n            if nums[i] == nums[n-1]:\n                return i\n        return n-1",
      1.6875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def lastOccurrence(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        current = head\n        while current:\n            if current.val == target:\n                count += 1\n            current = current.next\n        return count - 1\n\n\ndef main():\n    sol = Solution()\n    head = ListNode(2)\n    head.next = ListNode(5, head)\n    head.next.next = ListNode(3, head.next)\n    head.next.next.next = ListNode(6, head.next.next)\n    head.next.next.next.next = ListNode(4, head.next.next.next)\n    print sol.lastOccurrence(head, 5)\n    print sol.lastOccurrence(head, 6)\n\nif __name__ == '__main__':\n    main()",
      0.9677734375
    ],
    [
      "# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def lastIndex(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not arr: return -1\n        arr.sort()\n        start = 0\n        end = len(arr) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1",
      0.83837890625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastIndexOfTarget(self, nums, target):\n        if len(nums) == 0: return -1\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [3,4,5,1,2,3,4]\n    print(s.lastIndexOfTarget(nums, 3))",
      0.6923828125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param {ListNode} head\n    # @param {integer} x\n    # @return {integer}\n    def lastIndexOfNumber(self, head, x):\n        dummy = ListNode(-1)\n        dummy.next = head\n        prev = dummy\n        while prev.next:\n            prev = prev.next\n            if prev.val < x:\n                prev = prev.next\n            else:\n                break\n        while prev.next and prev.next.val < x:\n            prev = prev.next\n        return prev.val",
      0.316162109375
    ],
    [
      "def last_occurrence_of_number_in_sorted_array(array, number):\n    \"\"\"\n    :type array: List[int]\n    :type number: int\n    :rtype: int\n    \"\"\"\n    if not array:\n        return -1\n    \n    idx = 0\n    while idx < len(array):\n        if array[idx] == number:\n            return idx\n        idx += 1\n    return -1",
      0.27001953125
    ],
    [
      "from typing import List\n\nclass Solution:\n    def lastPosition(self, nums: List[int]) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        # nums is sorted\n        return len(nums) - 1 - self.binarySearch(nums, nums[len(nums) - 1])\n\n    def binarySearch(self, nums: List[int], num: int) -> int:\n        \"\"\"\n        Time: O(logn)\n        Space: O(1)\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] > num:\n                high = mid - 1\n            elif nums[mid] < num:\n                low = mid + 1\n            else:\n                return mid\n        return -1",
      0.09539794921875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            cur = cur.next\n            if cur.val == head.val:\n                break\n        return cur",
      0.034698486328125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a list node\n\t# @param val, an integer\n\t# @return an integer\n\tdef lastIndexOfNumber(self, head, val):\n\t\tif head == None:\n\t\t\treturn 0\n\t\t\n\t\tcount = 0\n\t\twhile head!= None:\n\t\t\tif head.val == val:\n\t\t\t\treturn count\n\t\t\telse:\n\t\t\t\thead = head.next\n\t\t\t\tcount += 1\n\t\treturn -1\n\n# Test\nif __name__ == '__main__':\n\thead = ListNode(3)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(1)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\tprint Solution().lastIndexOfNumber(head, 3)",
      -0.4873046875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def searchLast(self, nums, target):\n        n = len(nums)\n        i = n - 1\n        while i >= 0:\n            if nums[i] == target:\n                return i\n            elif nums[i] > target:\n                i -= 1\n            else:\n                i -= 1\n        return -1\n\nnums = [2, 5, 6, 7]\ntarget = 7\nob = Solution()\nprint(ob.searchLast(nums, target))",
      -0.51611328125
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def lastIndex(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return -1\n        if not arr[0]:\n            return 0\n        start = 0\n        end = len(arr) - 1\n        while start < end:\n            mid = (start + end) / 2\n            if arr[mid] >= target:\n                end = mid\n            elif arr[mid] < target:\n                start = mid + 1\n            else:\n                return mid\n        if arr[start]!= target:\n            return -1\n        else:\n            return start",
      -0.517578125
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def lastOccurrence(self, head: ListNode, target: int) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast and fast.val == target:\n                break\n\n        if fast:\n            slow = slow.next\n        while slow:\n            if slow.val == target:\n                break\n            slow = slow.next\n        return slow\n\n    def lastOccurrence_2(self, head: ListNode, target: int) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast and fast.val == target:\n                break\n        if fast:\n            slow = slow.next\n        while slow:\n            if slow.val == target:\n                break\n            slow = slow.next\n        return slow",
      -0.6845703125
    ],
    [
      "import numpy as np\n\ndef findLast(arr, num):\n    \"\"\"\n    :type arr: list\n    :type num: int\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    lo = 0\n    hi = n - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == num:\n            return mid\n        if arr[mid] < num:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9]\n    print(findLast(arr, 9))\n    print(findLast(arr, 8))\n    print(findLast(arr, 10))\n    print(findLast(arr, 7))\n    print(findLast(arr, 0))",
      -0.7275390625
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.find(nums, nums[-1])\n\n    def find(self, nums, target):\n        n = len(nums)\n        i = n - 1\n        while i >= 0 and nums[i]!= target:\n            i -= 1\n        return i + 1",
      -0.79248046875
    ],
    [
      "import sys\n\nclass Solution(object):\n    def lastOccurrence(self, num, arr):\n        \"\"\"\n        :type num: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        i = len(arr) - 1\n        while i >= 0:\n            if arr[i] == num:\n                return i\n            i -= 1\n        return -1\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.lastOccurrence(2, [1,2,3,4,3,2,1])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1])\n    print sol.lastOccurrence(4, [1,2,3,4,3,2,1])\n    print sol.lastOccurrence(4, [1,2,3,4,3,2,1,3,4])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6,7])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6,7,8])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6,7,8,9])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6,7,8,9,10])\n    print sol.lastOccurrence(1, [1,2,3,4,3,2,1,3,4,5,6,7,8,9,",
      -0.80224609375
    ],
    [
      "def last_occurrence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    return arr.index(target) + 1\n\n\nif __name__ == '__main__':\n    arr = [1,2,3,3,3,4,5,6,7,8]\n    print last_occurrence(arr, 3)",
      -0.85791015625
    ],
    [
      "def last_occurence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return -1\n    \n    last = 0\n    for i in range(len(arr)):\n        if arr[i] == target:\n            last = i\n        elif arr[i] > target:\n            last = -1\n    return last",
      -0.85791015625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def lastOccurrence(self, head: ListNode, value: int) -> int:\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            if curr.val == value:\n                return curr.val\n            if curr.val > value:\n                prev = curr\n                curr = curr.next\n            else:\n                prev = prev.next\n                curr = curr.next\n        return -1",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        if len(nums) == 1:\n            return 0\n        i = len(nums) - 1\n        while i >= 0:\n            if nums[i]!= nums[i - 1]:\n                break\n            i -= 1\n        return i + 1",
      -0.85791015625
    ],
    [
      "def last_occurrence(numbers, target):\n    \n    if not numbers:\n        return -1\n    \n    if numbers[0] == target:\n        return 0\n    \n    end = len(numbers) - 1\n    while end >= 0:\n        if numbers[end] == target:\n            return end\n        else:\n            end -= 1\n    \n    return -1",
      -0.8583984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n\n        slow = head\n        fast = head\n        while fast.next is not None and fast.next.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n\n        if fast is None:\n            return None\n\n        while fast.next is not None:\n            slow = slow.next\n            fast = fast.next\n\n        return slow",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastIndexOfNumber(self, A, n):\n        \"\"\"\n        :type A: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if len(A) == 0:\n            return -1\n        if len(A) == 1:\n            if A[0] == n:\n                return 0\n            else:\n                return -1\n        mid = len(A) // 2\n        if A[mid] == n:\n            return mid\n        elif A[mid] > n:\n            return self.lastIndexOfNumber(A[:mid], n)\n        else:\n            return self.lastIndexOfNumber(A[mid+1:], n)\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.lastIndexOfNumber(A, n)",
      -0.8583984375
    ],
    [
      "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def lastIndex(self, intervals: List[Interval]) -> int:\n        start, end = 0, len(intervals) - 1\n        while start < end:\n            mid = start + (end - start) // 2\n            if intervals[mid].start <= intervals[mid].end:\n                start = mid + 1\n            else:\n                end = mid\n        return start",
      -0.8583984375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return nums.index(nums[-1])\n\n\nif __name__==\"__main__\":\n    print Solution().lastPosition([2,5,7,1,2,3])",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastIndexOfNum(self, num, nums):\n        \"\"\"\n        :type num: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = len(nums) - 1\n        while i >= 0:\n            if num == nums[i]:\n                return i\n            i -= 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().lastIndexOfNum(1, [2,3,1])",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastIndexOf(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        i = n - 1\n        while i >= 0:\n            if nums[i] == nums[i-1]:\n                i -= 1\n            else:\n                break\n        return i\n\n\nif __name__ == \"__main__\":\n    print(Solution().lastPosition([2,2,2,3,3,4,4,4,4,5,5,6,6,7,7,7,8,8,8,9,9,9,9]))",
      -0.8583984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head or not head.next:\n            return 0\n        else:\n            i = head\n            while i.next:\n                i = i.next\n            return i.val",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastIndexOfNumber(self,nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i, j = 0, len(nums) - 1\n        while i < j:\n            mid = i + (j-i)/2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                j = mid - 1\n            else:\n                i = mid + 1\n        return -1",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastIndexOf(self, num, arr):\n        \"\"\"\n        :type num: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        l, r = 0, len(arr) - 1\n        while l < r:\n            m = l + (r - l) // 2\n            if arr[m] < num:\n                l = m + 1\n            elif arr[m] > num:\n                r = m - 1\n            else:\n                return m\n        return l",
      -0.8583984375
    ],
    [
      "def last_occurrence(arr, value):\n    \"\"\"\n    :type arr: List[int]\n    :type value: int\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return -1\n    if len(arr) == 1:\n        return 0\n    if value > arr[-1]:\n        return -1\n    idx = -1\n    for i in range(len(arr)-2, -1, -1):\n        if arr[i] > value:\n            idx = i\n    return idx",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastIndexOf(self, nums, target):\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return lo\n\ns = Solution()\nprint(s.lastIndexOf([5, 7, 7, 8, 8, 10], 8))",
      -0.8583984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return -1\n        while head and head.next:\n            head = head.next\n            if head.val == head.next.val:\n                head = head.next\n            else:\n                break\n        if not head:\n            return -1\n        while head.next:\n            if head.next.val == head.val:\n                head = head.next\n            else:\n                break\n        return head.val",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        n = len(nums)\n        \n        left, right = 0, n\n        \n        while left < right:\n            mid = left + (right - left) / 2\n            \n            if nums[mid] == nums[right - 1]:\n                return mid\n            elif nums[mid] < nums[right - 1]:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def lastIndexOfNumber(self, num, nums):\n        \"\"\"\n        :type num: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # return self.lastIndexOfNumberHelper(num, nums, 0, len(nums))\n        return self.lastIndexOfNumberHelper(num, nums, 0, len(nums) - 1)\n\n    def lastIndexOfNumberHelper(self, num, nums, start, end):\n        if start > end:\n            return -1\n        mid = (start + end) / 2\n        if num == nums[mid]:\n            return mid\n        elif num < nums[mid]:\n            return self.lastIndexOfNumberHelper(num, nums, start, mid - 1)\n        else:\n            return self.lastIndexOfNumberHelper(num, nums, mid + 1, end)",
      -0.8583984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def lastOccurrence(self, head: ListNode, val: int) -> ListNode:\n        slow = head\n        fast = head\n        while fast and fast.val!= val:\n            fast = fast.next\n            slow = slow.next\n\n        if fast is None:\n            return None\n        else:\n            return slow\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = int(input())\n# param_2 = int(input())\n# obj.lastOccurrence(head, val)",
      -0.8583984375
    ],
    [
      "import bisect\n\ndef last_occurrence(numbers, target):\n    \"\"\"\n    :type numbers: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # return the first number greater than target\n    for i in range(len(numbers)):\n        if numbers[i] > target:\n            return i\n\n    # return the last index\n    return len(numbers) - 1\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\ntarget = 20\n\nprint last_occurrence(numbers, target)",
      -0.85888671875
    ],
    [
      "def last_occur(arr, n):\n    \"\"\"\n    :type arr: List[int]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    i = 0\n    while i < len(arr):\n        if arr[i] == n:\n            return i\n        elif arr[i] > n:\n            return -1\n        i += 1\n    return -1\n\nif __name__ == '__main__':\n    print(last_occur([1, 2, 3, 4, 5], 5))",
      -0.85888671875
    ],
    [
      "def last_occurrence(arr, target):\n    # write your code here\n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9]\n    print(last_occurrence(arr, 3))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        n = len(nums)\n        mid = n/2\n        while mid > 0:\n            if nums[mid] == nums[n-1]:\n                return n-1\n            else:\n                mid -= 1\n        return mid",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        count = 0\n        while head:\n            if head.val == count:\n                count += 1\n            head = head.next\n        return count - 1",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastIndexOf(self, nums, target):\n        if not nums:\n            return -1\n        end = len(nums) - 1\n        while end >= 0:\n            if nums[end] == target:\n                return end\n            elif nums[end] > target:\n                return -1\n            end -= 1\n        return -1",
      -0.85888671875
    ],
    [
      "def last_occurrence(nums, target):\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n        if nums[i] > target:\n            return -1\n    return -1\n\nnums = [1, 3, 5, 7, 9, 10, 12]\ntarget = 9\nprint last_occurrence(nums, target)",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def lastPosition(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i = len(A) - 1\n        while i >= 0:\n            if A[i] == target:\n                return i\n            elif A[i] > target:\n                i -= 1\n            else:\n                i -= 1\n        return -1",
      -0.86083984375
    ],
    [
      "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        l, r = 0, n - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            if nums[m] < target:\n                l = m + 1\n            elif nums[m] > target:\n                r = m - 1\n            else:\n                return m\n        return -1\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.search([0, 1, 3, 5, 6], 4))",
      -1.025390625
    ],
    [
      "def last_occurrence(arr, target):\n    if not arr:\n        return -1\n\n    lo = 0\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        mid = (lo + hi) / 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n\n    return hi\n\n\nif __name__ == '__main__':\n    arr = [1, 5, 8, 7, 4, 6, 7, 3, 1]\n    target = 8\n    print(last_occurrence(arr, target))",
      -1.0830078125
    ],
    [
      "def last_occurrence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return -1\n\n    last_num = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > last_num:\n            last_num = arr[i]\n\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == target:\n            return i\n\n    return -1\n\n\nprint(last_occurrence([1, 2, 3, 3, 3, 4, 5], 3))",
      -1.1064453125
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def lastIndexOfNumber(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: int\n        \"\"\"\n        slow, fast = head, head\n        while fast.next is not None and fast.next.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        slow = slow.next\n        while slow.next is not None:\n            slow = slow.next\n            if slow.val == target:\n                return slow.next.val\n        return -1\n\nif __name__ == \"__main__\":\n    assert Solution().lastIndexOfNumber([1,2,3], 3) == 1\n    assert Solution().lastIndexOfNumber([1,2,3], 4) == -1\n    assert Solution().lastIndexOfNumber([1,2,3], 0) == -1",
      -1.1494140625
    ],
    [
      "def last_occurrence(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if nums is None or len(nums) == 0:\n        return -1\n    \n    if nums[0] == target:\n        return 0\n    \n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      -1.25
    ],
    [
      "# https://leetcode.com/problems/find-the-index-of-a-given-number-in-sorted-array/discuss/452344/Java-Solution\n\nclass Solution(object):\n    def findLast(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i = len(nums) - 1\n        while i >= 0 and nums[i]!= target:\n            i -= 1\n        return i",
      -1.6005859375
    ],
    [
      "import unittest\n\n# Your function will be called as such:\n# for i in range(len(arr)):\n#   for j in range(len(arr)):\n#     Your function should return the index of the last occurrence of arr[j] in arr[:j] + arr[j+1:].\n\ndef find_last_occurrence(arr, num):\n    # base case\n    if len(arr) == 0:\n        return -1\n    # binary search\n    lo = 0\n    hi = len(arr) - 1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        if arr[mid] == num:\n            return mid\n        elif arr[mid] > num:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return -1\n\n\nclass UnitTest(unittest.TestCase):\n    def test_find_last_occurrence(self):\n        self.assertEqual(find_last_occurrence([4, 7, 5, 0, 1, 2, 3], 5), 4)\n        self.assertEqual(find_last_occurrence([4, 7, 5, 0, 1, 2, 3], 7), 3)\n        self.assertEqual(find_last_occurrence([4, 7, 5, 0, 1, 2, 3], 0), -1)\n\n\nif __name__ == '__main__':\n    unittest.main()",
      -1.80859375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        # for each number, search the last occurrence\n        # return the last occurrence number\n        for i in xrange(len(nums)):\n            if nums[i] == nums[-1]:\n                return i\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().lastPosition([3, 2, 1])",
      -1.9423828125
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lastPosition(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l, r = 0, len(A)-1\n        while l < r:\n            m = l + (r-l)//2\n            if A[m] == target:\n                return m\n            elif A[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return l\n\n\nif __name__ == \"__main__\":\n    print Solution().lastPosition([2, 5, 6, 7], 6)",
      -1.9609375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return -1\n        p = head\n        while p:\n            if p.val == head.val:\n                return p.val\n            p = p.next\n        return -1",
      -2.138671875
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lastIndexOf(self, num, arr):\n        \"\"\"\n        :type num: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(arr)\n        while start < end:\n            mid = (start + end) // 2\n            if arr[mid] == num:\n                return mid\n            elif arr[mid] > num:\n                end = mid\n            else:\n                start = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().lastIndexOf(5, [1, 3, 5, 7, 8])\n    print Solution().lastIndexOf(5, [3, 5, 7, 8, 1])\n    print Solution().lastIndexOf(4, [3, 5, 7, 8, 1])\n    print Solution().lastIndexOf(4, [3, 5, 7, 8, 1, 4])\n    print Solution().lastIndexOf(4, [3, 5, 7, 8, 1, 4, 2])",
      -2.328125
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        elif n == 1:\n            return 0\n        else:\n            # for each index, find the last position\n            pos = n - 1\n            while pos >= 0:\n                if nums[pos] == nums[pos - 1]:\n                    pos -= 1\n                else:\n                    break\n            return pos",
      -2.349609375
    ],
    [
      "from math import log\n\nclass Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.binarySearch(nums, nums[-1])\n\n    def binarySearch(self, nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            elif nums[mid] > target:\n                right = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 2, 2, 5, 6]\n    print Solution().lastPosition(nums)",
      -2.568359375
    ],
    [
      "import numpy as np\nimport time\nfrom time import time\n\n# @include\ndef last_occurrence_in_sorted_array(arr):\n    # Returns the index of the last occurrence of a given number in a sorted array.\n    # Assumes that arr is sorted.\n    # Time complexity: O(n).\n    # Space complexity: O(1).\n    # Returns -1 if the number is not found.\n    return arr.searchsorted(arr[-1])\n# @exclude\n\n\ndef last_occurrence_in_sorted_array_alternate(arr):\n    # Returns the index of the last occurrence of a given number in a sorted array.\n    # Assumes that arr is sorted.\n    # Time complexity: O(n).\n    # Space complexity: O(1).\n    # Returns -1 if the number is not found.\n    return arr.searchsorted(arr[-1])\n\n\ndef last_occurrence_in_sorted_array_alternate2(arr):\n    # Returns the index of the last occurrence of a given number in a sorted array.\n    # Assumes that arr is sorted.\n    # Time complexity: O(n).\n    # Space complexity: O(1).\n    # Returns -1 if the number is not found.\n    return arr.searchsorted(arr[-1])\n\n\ndef last_occurrence_in_sorted_array_alternate3(arr):\n    # Returns the index of the last occurrence of a given number in a sorted array.\n    # Assumes that arr is sorted.\n    # Time complexity: O(n).\n    # Space complexity: O(1).\n    # Returns -1 if the number is not found.\n    return arr.searchsorted(arr[-1])\n\n\ndef last_occurrence_in_sorted_array_alternate4(arr):\n    # Returns the index of the last occurrence of a given number in a sorted array.\n    # Assumes that arr is sorted.\n    # Time complexity: O(n).\n    # Space complexity: O(1).\n    # Returns -1 if the number is not found.\n    return arr.searchsorted(arr[-1])\n\n\ndef last_occurrence_in_",
      -2.630859375
    ],
    [
      "import unittest\n\n# Your LastOccurrence function should return the index.\n# If the number is not found, return -1\n\nclass Solution(object):\n    def lastIndexOfNumber(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        i = len(nums) - 1\n        while i >= 0:\n            if nums[i] == target:\n                return i\n            if nums[i] > target:\n                i -= 1\n            else:\n                i -= 1\n        return -1\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/last-occurrence-number/solution/\n\n# Approach #2: Binary Search\n# Complexity Analysis\n# Time Complexity: O(log(n))\n# Space Complexity: O(1)\n# We can use the fact that the array is sorted and then we can do binary search to find the last number.\n#\n# 4ms 100%\nclass Solution {\n    public int lastIndexOfNumber(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n# Approach #1: Sort\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n# We can use the fact that the array is sorted and then we can do binary search to find the last number.\n#\n# 4ms 100%\nclass Solution {\n    public int lastIndexOfNumber(int[]",
      -2.734375
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = len(nums) - 1\n        while i >= 0:\n            if nums[i] == nums[-1]:\n                return i\n            else:\n                i -= 1\n        return -1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.lastPosition([1, 1, 2])\n    print s.lastPosition([1, 2, 2])\n    print s.lastPosition([1, 2, 2, 3, 2, 2, 1, 1, 1])\n    print s.lastPosition([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    print s.lastPosition([2, 1, 2, 4, 3, 3, 5, 6, 7, 8, 9, 9])",
      -2.78125
    ],
    [
      "# https://www.hackerrank.com/challenges/sorted-array-reverse/problem\n\n# Implement a function that takes in an array and a number and returns the index of the last occurrence of the number in the array.\n# If the number is not present in the array, return -1.\n# Assume that the array is sorted in ascending order.\n\n# Example 1:\n# Input: nums = [1,2,2,3,1], num = 2\n# Output: 2\n# Explanation: The 2 is at index 2, and the 1 at index 3.\n# Example 2:\n# Input: nums = [1,2,2,3,1], num = 4\n# Output: -1\n# Explanation: 4 is not in the array.\n# Note:\n# - The size of the array will be between 1 and 50,000.\n# - The range of numbers in the array is between -1,000,000 and 1,000,000.\n\n# -100,000\n# -1,000,000\n# 100,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,000,000\n# 1,",
      -2.814453125
    ],
    [
      "import numpy as np\n\ndef last_occurrence(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_searchsorted(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_searchsorted_reverse(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_2(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_3(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_4(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_5(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_6(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_7(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_8(arr, val):\n    return arr.searchsorted(val, side='right') - 1\n\ndef last_occurrence_with_sorted_searchsorted_reverse_9(arr, val):\n    return arr.searchsorted",
      -2.93359375
    ],
    [
      "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def lastPosition(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        i, j = 0, len(nums) - 1\n        while i < j:\n            mid = i + (j - i) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                i = mid + 1\n            else:\n                j = mid\n        return j\n\n\nif __name__ == \"__main__\":\n    print Solution().lastPosition([1, 5, 6, 7, 8], 8)",
      -3.037109375
    ],
    [
      "def findLast(nums, target):\n    return findLastHelper(nums, target, 0, len(nums))\n\ndef findLastHelper(nums, target, start, end):\n    while start < end:\n        mid = (start + end) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            start = mid + 1\n        else:\n            end = mid\n    return start",
      -3.119140625
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        return binary_search(nums, target)\n\ndef binary_search(nums, target):\n    lo = 0\n    hi = len(nums) - 1\n    while lo <= hi:\n        mid = (lo + hi) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nnums = [1, 3, 5, 6, 7, 9, 10]\ntarget = 5\nprint(Solution().search(nums, target))",
      -3.177734375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastIndexOfNumber(self, nums, target):\n        if not nums or not target:\n            return -1\n\n        return self.binarySearch(nums, target, len(nums) - 1)\n\n    def binarySearch(self, nums, target, left, right):\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
      -3.470703125
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        i = n - 1\n        while i >= 0:\n            if nums[i] == nums[i - 1]:\n                i -= 1\n            else:\n                break\n        return i\n\n\nif __name__ == \"__main__\":\n    assert Solution().lastPosition([3, 1, 2, 2, 3, 4, 5, 4, 5, 6]) == 6",
      -3.505859375
    ],
    [
      "class Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        l = 0\n        r = len(nums)\n        while l < r:\n            m = (l + r) / 2\n            if nums[m] == nums[r-1]:\n                r = m\n            elif nums[m] > nums[r-1]:\n                l = m + 1\n            else:\n                r = m\n        return l",
      -3.5859375
    ],
    [
      "import math\n\n\nclass Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) / 2\n            if nums[m] == nums[r]:\n                r = m - 1\n            else:\n                l = m + 1\n        return l",
      -3.681640625
    ],
    [
      "def last_occur(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if nums is None or nums == []:\n        return 0\n    \n    n = len(nums)\n    \n    for i in range(n-1, -1, -1):\n        if nums[i] == target:\n            return i\n        elif nums[i] > target:\n            return last_occur(nums[:i], target)\n    return 0\n\nif __name__ == \"__main__\":\n    print last_occur([1,2,3,4,5,6,7], 5)",
      -3.732421875
    ],
    [
      "def last_occurrence(arr, target):\n    if len(arr) == 0:\n        return -1\n    if len(arr) == 1:\n        return 0\n    if arr[0] == target:\n        return 0\n    if arr[0] > target:\n        return -1\n    if arr[len(arr) - 1] == target:\n        return len(arr) - 1\n    if arr[len(arr) - 1] > target:\n        return -1\n    for i in range(0, len(arr) - 1):\n        if arr[i] > target:\n            return i\n        if arr[i] <= target:\n            if arr[i] == target:\n                return i\n            else:\n                continue\n        return -1\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(last_occurrence(arr, 4))\n    print(last_occurrence(arr, 6))\n    print(last_occurrence(arr, 10))\n    print(last_occurrence(arr, 0))\n    print(last_occurrence(arr, 1))\n    print(last_occurrence(arr, 10))\n    print(last_occurrence(arr, -1))",
      -3.962890625
    ],
    [
      "#!/usr/bin/python\n\nclass Solution(object):\n    def lastIndexOfNumber(self, num, arr):\n        \"\"\"\n        :type num: int\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return -1\n        if len(arr) == 1:\n            return arr[0] == num and 0 or -1\n        mid = len(arr) / 2\n        if arr[mid-1] < num:\n            return self.lastIndexOfNumber(num, arr[:mid])\n        if arr[mid] == num:\n            return mid\n        if arr[mid] > num:\n            return self.lastIndexOfNumber(num, arr[mid:])\n        return self.lastIndexOfNumber(num, arr[:mid])\n\n    # @return a tuple, (index, value).\n    def findLast(self, arr):\n        if len(arr) == 0:\n            return (-1, -1)\n        if len(arr) == 1:\n            return (0, arr[0])\n        mid = len(arr) / 2\n        if arr[mid] == arr[mid-1]:\n            return (mid, arr[mid])\n        if arr[mid] < arr[mid-1]:\n            return self.findLast(arr[:mid])\n        if arr[mid] > arr[mid-1]:\n            return self.findLast(arr[mid:])\n        return self.findLast(arr[:mid])\n\n    def lastIndexOfNumber(self, num, arr):\n        if len(arr) == 0:\n            return -1\n        if len(arr) == 1:\n            return arr[0] == num and 0 or -1\n        mid = len(arr) / 2\n        if arr[mid-1] < num:\n            return self.lastIndexOfNumber(num, arr[:mid])\n        if arr[mid] == num:\n            return mid\n        if arr[mid] > num:\n            return self.lastIndexOfNumber(num, arr[mid:])\n        return self.lastIndexOfNumber(num, arr[:mid])\n\n    def last",
      -3.978515625
    ],
    [
      "import math\n\nclass Solution(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        if len(nums) == 1:\n            return 0\n        if nums[0]!= nums[-1]:\n            return -1\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) / 2\n            if nums[m]!= nums[l]:\n                r = m\n            else:\n                l = m + 1\n        return l\n\n\nclass Solution2(object):\n    def lastPosition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        if len(nums) == 1:\n            return 0\n        if nums[0]!= nums[-1]:\n            return -1\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) / 2\n            if nums[m]!= nums[l]:\n                r = m\n            else:\n                l = m + 1\n        return l\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 3, 3, 4]\n    print(Solution().lastPosition(nums))\n    nums = [1, 2, 3, 3, 3, 4, 5]\n    print(Solution().lastPosition(nums))\n    nums = [1, 2, 3, 3, 3, 4, 5, 6]\n    print(Solution().lastPosition(nums))\n    nums = [2]\n    print(Solution().lastPosition(nums))",
      -3.99609375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def lastOccurrence(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: int\n        \"\"\"\n        p = head\n        while p:\n            if p.val == target:\n                return p.val\n            p = p.next\n        return -1",
      -4.796875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def lastPosition(self, nums, target):\n        if len(nums) == 0:\n            return 0\n        elif nums[0] == target:\n            return 0\n        elif nums[0] < target:\n            return -1\n        elif nums[0] > target:\n            return -1\n        else:\n            for i in xrange(len(nums)):\n                if nums[i] == target:\n                    return i\n                elif nums[i] < target:\n                    return -1\n        return -1\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 7, 9]\n    print Solution().lastPosition(nums, 9)",
      -4.8671875
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return, a ListNode\n    def findLast(self, head, val):\n        slow = head\n        fast = head\n        while fast and fast.val!= val:\n            fast = fast.next\n            slow = slow.next\n        return slow\n    \n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        return slow",
      -4.9296875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast == head:\n            return -1\n        slow = head\n        while slow.next and slow.next.val == fast.val:\n            slow = slow.next\n            fast = fast.next\n        return slow.val",
      -5.5
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        l = None\n        r = head\n        while r:\n            if r.next:\n                l = r\n                r = r.next\n            else:\n                r = None\n        if l:\n            while l.next:\n                l = l.next\n            return l.val\n        return -1",
      -6.01171875
    ],
    [
      "class Solution:\n\t\n\t# @param num, a list of integer\n\t# @return an integer\n\tdef lastIndexOf(self, num):\n\t\t# write your code here\n\t\tif not num or not len(num):\n\t\t\treturn -1\n\t\tif len(num) == 1:\n\t\t\treturn num[0]\n\t\t\n\t\tn = len(num)\n\t\tm = len(num) / 2\n\t\twhile m > 0:\n\t\t\tif num[m] > num[-1]:\n\t\t\t\tm -= 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\n\t\tif m == 0:\n\t\t\treturn -1\n\t\t\n\t\twhile m < n:\n\t\t\tif num[m] <= num[-1]:\n\t\t\t\tm += 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\n\t\treturn m - 1",
      -6.50390625
    ],
    [
      "import sys\nsys.path.append('..')\nimport tools.tools as tl\n\ndef main():\n    testCases = [\n        ([], 1),\n        ([1], 1),\n        ([1], 2),\n        ([2, 1], 2),\n        ([2, 1], 1),\n        ([3, 2, 1], 1),\n        ([3, 2, 1], 2),\n        ([3, 2, 1], 3),\n        ([3, 2, 1], 4),\n        ([3, 2, 1], 5),\n        ([3, 2, 1], 6),\n        ([3, 2, 1], 7),\n        ([3, 2, 1], 8),\n        ([3, 2, 1], 9),\n        ([3, 2, 1], 10),\n        ([3, 2, 1], 11),\n        ([3, 2, 1], 12),\n        ([3, 2, 1], 13),\n        ([3, 2, 1], 14),\n        ([3, 2, 1], 15),\n        ([3, 2, 1], 16),\n        ([3, 2, 1], 17),\n        ([3, 2, 1], 18),\n        ([3, 2, 1], 19),\n        ([3, 2, 1], 20),\n        ([3, 2, 1], 21),\n        ([3, 2, 1], 22),\n        ([3, 2, 1], 23),\n        ([3, 2, 1], 24),\n        ([3, 2, 1], 25),\n        ([3, 2, 1], 26),\n        ([3, 2, 1], 27),\n        ([3, 2, 1], 28),\n        ([3, 2, 1], 29),\n        ([3, 2, 1], 30),\n        ([3, 2, 1], 31),\n        ([3, 2, 1], 32),\n        ([3, 2, 1], 33),\n        ([3, 2, 1], 34),\n        ([3, 2, 1], 35),\n        ([3, 2, 1], 36),\n        ([3, 2, 1], 37),\n        ([3, 2, 1], 38),\n        ([3, 2, 1], 39),\n        ([3, 2, 1], 40),",
      -6.58203125
    ],
    [
      "import unittest\n\nclass Solution:\n    # @param num, a list of integer\n    # @return an integer\n    def lastIndexOfNum(self, num):\n        n = len(num)\n        if n == 0:\n            return 0\n        if n == 1:\n            return n\n        # for each element\n        for i in range(n-1):\n            # if it is not the last element\n            if num[i] < num[i+1]:\n                # move to the left\n                j = i\n                # while num[j] > num[i]\n                while num[j] > num[i]:\n                    # move j to the left\n                    j -= 1\n                # return the index of the last element\n                return j+1\n        # if it is the last element\n        return n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/last-element-of-sorted-array/solution/\n\n# 15ms 100%\nclass Solution {\n    public int lastIndexOfNum(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int i = 0;\n        int j = nums.length - 1;\n        while (i < j) {\n            while (nums[i] < nums[j]) {\n                i++;\n            }\n            while (nums[j] > nums[i]) {\n                j--;\n            }\n            if (i > j) {\n                break;\n            }\n            i++;\n            j--;\n        }\n        return i;\n    }\n}\n\n# 8ms 59.35%\nclass Solution {\n    public int lastIndexOfNum(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int i = 0;\n        int j = nums.length",
      -8.1640625
    ],
    [
      "import random\nimport unittest\n\ndef last_occurrence(arr, num):\n    \"\"\"\n    :type arr: List[int]\n    :type num: int\n    :rtype: int\n    \"\"\"\n    return len(arr) - 1 - last_occurrence_binary_search(arr, num, 0, len(arr) - 1)\n\n\ndef last_occurrence_binary_search(arr, num, lo, hi):\n    \"\"\"\n    :type arr: List[int]\n    :type num: int\n    :type lo: int\n    :type hi: int\n    :rtype: int\n    \"\"\"\n    while lo <= hi:\n        mid = lo + (hi - lo) / 2\n        if arr[mid] == num:\n            return mid\n        elif arr[mid] < num:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\n\ndef last_occurrence_recursive(arr, num):\n    \"\"\"\n    :type arr: List[int]\n    :type num: int\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return -1\n\n    mid = len(arr) / 2\n    if arr[mid] == num:\n        return mid\n\n    if arr[mid] < num:\n        return last_occurrence_recursive(arr[:mid], num)\n    else:\n        return last_occurrence_recursive(arr[mid:], num)\n\n\nclass TestLastOccurrence(unittest.TestCase):\n    def test_last_occurrence(self):\n        arr = [2, 6, 5, 4, 3]\n        self.assertEqual(last_occurrence(arr, 5), 2)\n        self.assertEqual(last_occurrence(arr, 7), -1)\n\n    def test_last_occurrence_recursive(self):\n        arr = [2, 6, 5, 4, 3]\n        self.assertEqual(last_occurrence_recursive(arr, 5), 2)\n        self.assertEqual(last_occurrence_recursive(arr, 7), -1)\n\n\nif __name__ == '__main__':",
      -8.5390625
    ],
    [
      "# https://leetcode.com/problems/search-a-2d-matrix/discuss/49800/Java-O(n)-Time-Java-O(1)-Space-solution-and-optimization\n# https://discuss.leetcode.com/topic/50783/java-solution-with-explanation\nclass Solution:\n    # @return an integer\n    def searchMatrix(self, matrix, target):\n        m = len(matrix)\n        n = len(matrix[0])\n        l = 0\n        r = n*m - 1\n        while l <= r:\n            mid = l + (r-l)/2\n            if matrix[mid/n][mid%n] == target:\n                return mid/n\n            elif matrix[mid/n][mid%n] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1\n\nif __name__ == '__main__':\n    print Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 3)\n    print Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 7)\n    print Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 5)\n    print Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 8)",
      -8.9921875
    ],
    [
      "def last_occurrence(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    for i, v in enumerate(arr):\n        if arr[i] == target:\n            return i\n        elif arr[i] > target:\n            return last_occurrence(arr[i:], target)\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution(object):\n    def lastIndexOfElement(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(arr) == 0:\n            return -1\n        if arr[0] == target:\n            return 0\n        if arr[len(arr) - 1] == target:\n            return len(arr) - 1\n        mid = len(arr) // 2\n        if arr[mid] == target:\n            return mid\n        if arr[mid] > target:\n            return self.lastIndexOfElement(arr[0:mid], target)\n        return self.lastIndexOfElement(arr[mid + 1:], target)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n    target = 20\n    print(last_occurrence(arr, target))\n    print(last_occurrence(arr, -1))\n    print(last_occurrence(arr, -2))\n    print(last_occurrence(arr, -1000))\n    print(last_occurrence(arr, -2000))\n    print(last_occurrence(arr, -20000))\n    print(last_occurrence(arr, -30000))\n    print(last_occurrence(arr, -40000))\n    print(last_occurrence(arr, -50000))\n    print(last_occurrence(arr, -60000))\n    print(last_occurrence(arr, -70000))\n    print(",
      -9.1171875
    ],
    [
      "# https://www.hackerrank.com/challenges/sorted-array-search/problem\n\ndef last_occurrence(nums, target):\n    return nums.index(target) + 1\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,",
      -9.2890625
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param val, an integer\n\t# @return a ListNode\n\tdef getLastOccurrence(self, head, val):\n\t\tresult = head\n\t\twhile result is not None and result.val!= val:\n\t\t\tresult = result.next\n\t\treturn result\n\n\t# @param head, a ListNode\n\t# @param val, an integer\n\t# @return a ListNode\n\tdef getLastOccurrence(self, head, val):\n\t\tresult = head\n\t\twhile result is not None:\n\t\t\tif result.val == val:\n\t\t\t\tbreak\n\t\t\tresult = result.next\n\t\treturn result\n\n\n\t# @param head, a ListNode\n\t# @param val, an integer\n\t# @return a ListNode\n\tdef getLastOccurrence(self, head, val):\n\t\tresult = head\n\t\twhile result is not None:\n\t\t\tif result.val == val:\n\t\t\t\treturn result\n\t\t\tresult = result.next\n\t\treturn None\n\nif __name__ == '__main__':\n\thead = ListNode(1)\n\thead.next = ListNode(3)\n\thead.next.next = ListNode(5)\n\thead.next.next.next = ListNode(7)\n\thead.next.next.next.next = ListNode(9)\n\thead.next.next.next.next.next = ListNode(11)\n\thead.next.next.next.next.next.next = ListNode(13)\n\thead.next.next.next.next.next.next.next = ListNode(15)\n\thead.next.next.next.next.next.next.next.next = ListNode(17)\n\thead.next.next.next.next.next.next.next.next.next = ListNode(19)\n\n\tprint Solution().getLastOccurrence(head, 13)\n\tprint Solution().getLastOccurrence(head, 7)\n\tprint Solution().getLastOccurrence(head, 3)\n\tprint Solution().get",
      -10.4453125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param val, an integer\n\t# @return a ListNode\n\tdef findLastOccurrence(self, head, val):\n\t\tp = head\n\t\twhile p:\n\t\t\tif p.val == val:\n\t\t\t\treturn p\n\t\t\tp = p.next\n\t\treturn None\n\nif __name__ == '__main__':\n\ts = Solution()\n\thead = ListNode(1)\n\thead.next = ListNode(2)\n\thead.next.next = ListNode(3)\n\thead.next.next.next = ListNode(4)\n\thead.next.next.next.next = ListNode(5)\n\thead.next.next.next.next.next = ListNode(6)\n\tprint s.findLastOccurrence(head, 3)",
      -10.703125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def lastPosition(self, head: ListNode, val: int) -> ListNode:\n        \"\"\"\n        1. \u521d\u59cb\u72b6\u6001\u4e3a\u7a7a\n        2. \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\u627e\u5230\u6700\u9760\u524d\u7684\u90a3\u4e2a\uff0c\u6700\u540e\u63d2\u5165\u5230\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u8fd4\u56de\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\n        \"\"\"\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n        while head and head.next:\n            if head.next.val < val:\n                head = head.next\n            else:\n                break\n        head.next = head.next.next\n        return dummy.next\n\n    def lastPosition2(self, head: ListNode, val: int) -> ListNode:\n        \"\"\"\n        1. \u521d\u59cb\u72b6\u6001\u4e3a\u7a7a\n        2. \u653e\u5230\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u5224\u65ad\u4e0b\u4e00\u4e2a\uff0c\u6309\u4f4d\u7f6e\u6392\u5e8f\uff0c\u7136\u540e\u518d\u6309\u4f4d\u7f6e\u63d2\u5165\u5230\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\n        \"\"\"\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n        while head and head.next:\n            if head.next.val < val:\n                head = head.next\n            else:\n                break\n        head.next = head.next.next\n        return dummy.next",
      -11.4453125
    ],
    [
      "from collections import Counter\n\ndef last_occurrence(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    c = Counter(nums)\n    last_occurrence = 0\n    for i in range(len(c)):\n        if c[i] == 1:\n            if target == nums[i]:\n                last_occurrence = i\n            else:\n                break\n    return last_occurrence\n\n# Note:\n# This is a much better solution than the one above.\n# This solution can easily run in O(n) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(1) time.\n# This solution can easily run in O(1) space.\n# This solution can easily run in O(",
      -11.5390625
    ],
    [
      "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def lastIndex(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # sort the list by start time\n        intervals = sorted(intervals, key=lambda x: x.start)\n        # if target is out of the interval range, return the last position\n        if target >= intervals[-1].end:\n            return len(intervals) - 1\n        # otherwise, search the last position\n        last_index = 0\n        while last_index < len(intervals):\n            if target < intervals[last_index].start:\n                last_index += 1\n            else:\n                return last_index - 1\n        return last_index - 1\n\n\nif __name__ == \"__main__\":\n    sln = Solution()\n    # print(sln.lastIndex([Interval(1, 3), Interval(5, 7), Interval(9, 10)], 4))\n    print(sln.lastIndex([Interval(1, 3), Interval(5, 7), Interval(9, 10)], 4))",
      -12.2734375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return an integer\n    def lastOccurrencesOf1(self, head, val):\n        if head == None or head.next == None:\n            return 0\n        \n        cur = head\n        pre = None\n        pre_val = -1\n        while cur!= None:\n            if cur.val == val:\n                if pre_val == -1:\n                    pre_val = cur.val\n                else:\n                    pre_val = pre_val - 1\n            pre = cur\n            cur = cur.next\n            if cur == None:\n                break\n        if pre_val == -1:\n            return 0\n        return pre_val\n    \n    def lastOccurrencesOf1_slow(self, head, val):\n        if head == None or head.next == None:\n            return 0\n        \n        cur = head\n        pre = None\n        pre_val = -1\n        while cur!= None:\n            if cur.val == val:\n                if pre_val == -1:\n                    pre_val = cur.val\n                else:\n                    pre_val = pre_val - 1\n            pre = cur\n            cur = cur.next\n            if cur == None:\n                break\n        if pre_val == -1:\n            return 0\n        return pre_val\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    print Solution().lastOcc",
      -13.546875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        dummy = ListNode(-1)\n        dummy.next = head\n        pre = dummy\n        while pre.next and pre.next.next:\n            pre = pre.next\n            while pre.next and pre.next.val == pre.next.next.val:\n                pre = pre.next\n        return pre.val",
      -13.5546875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def lastOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        # Use a stack to keep track of the nodes to be inspected\n        stack = []\n        # Use a queue to keep track of the nodes to be inspected\n        q = []\n\n        # Initialize the stack and queue\n        stack.append(head)\n        q.append(head)\n\n        # While there are nodes in the stack, pop one off of the stack and add the\n        # current node to the queue\n        while stack:\n            node = stack.pop()\n            while node:\n                stack.append(node.next)\n                node = node.next\n                q.append(node)\n\n        # At this point, the last occurrence of the number in the array is in the\n        # queue. We can now return the index of that node.\n        return q.pop().val\n\n\nif __name__ == '__main__':\n    head = ListNode(2)\n    head.next = ListNode(1)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)",
      -13.890625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}