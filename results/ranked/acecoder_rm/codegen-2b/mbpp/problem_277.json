{
  "problem": {
    "task_id": "MBPP/288",
    "prompt": "Write a function to count array elements having modular inverse under given prime number p equal to itself.",
    "canonical_solution": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element",
    "test_list": [
      "assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2",
      "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3",
      "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1"
    ],
    "challenge_test_list": [],
    "problem_id": 277
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "# https://leetcode.com/problems/count-and-say/#/solutions\n\nclass Solution:\n    # @return an integer\n    def countAndSay(self, n):\n        if n < 2:\n            return 1\n        res = 1\n        str = \"1\"\n        for i in range(2, n+1):\n            res *= i\n            str += str[i-1]\n            res %= i\n        return res\n\n\nif __name__ == \"__main__\":\n    print(Solution().countAndSay(3))\n    print(Solution().countAndSay(5))",
      3.92578125
    ],
    [
      "import unittest\nimport timeit\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countModInverse(self, nums, p):\n        if not nums or not p: return 0\n        n = len(nums)\n        result = 1\n        for i in range(n):\n            result = (result * nums[i]) % p\n        return result\n\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countModInverse_2(self, nums, p):\n        if not nums or not p: return 0\n        result = 1\n        for i in range(len(nums)):\n            result = (result * nums[i]) % p\n        return result\n\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countModInverse_3(self, nums, p):\n        if not nums or not p: return 0\n        result = 1\n        for i in range(len(nums)):\n            result = (result * nums[i]) % p\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-mod-inverse/solution/\n#\n# Approach #1: Brute force\n# Complexity Analysis\n# Time Complexity: O(n^2), where n is the length of the array.\n# Space Complexity: O(n)\n#\n# Approach #2: Math\n# Complexity Analysis\n# Time Complexity: O(n^2), where n is the length of the array.\n# Space Complexity: O(n)\n#\n# Approach #3: Math\n# Complexity Analysis\n# Time Complexity: O(n), where n is the length of the array.\n# Space Complexity:",
      0.82763671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def modularInverse(self, nums, p):\n        nums.sort()\n        p = p % nums[-1]\n        m = pow(p, nums[-1], nums[-1])\n        ans = 1\n        for i in range(len(nums)-1, -1, -1):\n            if (nums[i] % nums[i+1]) == 0:\n                ans = (ans * m) % nums[i+1]\n            else:\n                ans = (ans * (nums[i] * m) % nums[i+1]) % nums[i+1]\n        return ans\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [3, 7, 15, 20, 22]\n    p = 2\n    print(sol.modularInverse(nums, p))\n    nums = [1, 2, 4, 8]\n    p = 3\n    print(sol.modularInverse(nums, p))",
      0.1402587890625
    ],
    [
      "# https://oj.leetcode.com/problems/count-and-say/#/description\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n <= 1:\n            return str(n)\n        s = str(n)\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n            else:\n                s = s[:i] + '1' + s[i+1:]\n        return s\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countAndSay(2))",
      -0.1815185546875
    ],
    [
      "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def modInverse(self, n, p):\n        # write your code here\n        if n == 0:\n            return 0\n        # for i in range(1, p):\n        #     if (n % i) == 0:\n        #         return i\n        # return 0\n        for i in range(2, p):\n            if n % i == 0:\n                return i\n        return 0\n\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def modInverse(self, n, p):\n        # write your code here\n        if n == 0:\n            return 0\n        i = 2\n        while i < p:\n            if n % i == 0:\n                return i\n            i += 1\n        return 0\n\n# test\nsol = Solution()\nprint(sol.modInverse(4, 7))\nprint(sol.modInverse(6, 7))\nprint(sol.modInverse(9, 7))\nprint(sol.modInverse(15, 7))\nprint(sol.modInverse(15, 11))\nprint(sol.modInverse(15, 13))\nprint(sol.modInverse(15, 17))\nprint(sol.modInverse(15, 19))\nprint(sol.modInverse(15, 23))\nprint(sol.modInverse(15, 29))\nprint(sol.modInverse(15, 31))\nprint(sol.modInverse(15, 37))\nprint(sol.modInverse(15, 41))\nprint(sol.modInverse(15, 43))\nprint(sol.modInverse(15, 47))\nprint(sol.modInverse(15, 53))\nprint(sol.modInverse(15, 59))\nprint(sol.modInverse(15, 61))\nprint(sol.modInverse(15, 67))\nprint(sol.modInverse(15, 71))\nprint(sol.modInverse(15, 73))\nprint(sol.modInverse(15, 79))\nprint(sol.modInverse(15, 83))\nprint(",
      -0.47314453125
    ],
    [
      "class Solution(object):\n    def countInverse(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # https://leetcode.com/problems/count-inverse/discuss/164476/Python-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164478/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164481/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164482/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164484/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164486/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164487/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164489/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164490/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164494/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164495/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164496/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164497/Java-Solution-O(n)\n        # https://leetcode.com/problems/count-inverse/discuss/164498/Java-Solution-O(n",
      -0.57666015625
    ],
    [
      "class Solution(object):\n    def countInverse(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int(n ** 0.5) % (n + 1) - 1\n\n\nif __name__ == '__main__':\n    assert Solution().countInverse(2) == 1\n    assert Solution().countInverse(3) == 2\n    assert Solution().countInverse(10) == 5",
      -0.85595703125
    ],
    [
      "def modularInverse(a, p):\n\tif a == 0:\n\t\treturn 0\n\tx, y = a, 1\n\twhile y!= 0:\n\t\tx, y = y, x % p\n\treturn x\n\nif __name__ == \"__main__\":\n\tprint(modularInverse(5, 7))",
      -0.85595703125
    ],
    [
      "def count_mod_inverse(n, p):\n    # write your code here\n    ans = 0\n    for i in range(p):\n        if (n % i == 0):\n            ans = ans + (n // i)\n    return ans\n\n\nprint count_mod_inverse(6, 11)",
      -0.85595703125
    ],
    [
      "def count_mod_inverse(n,p):\n    # write your code here\n    # n is an array, p is a number\n    result = 0\n    for i in range(n):\n        if pow(n,p,p) == i:\n            result += 1\n    return result\n\nif __name__ == \"__main__\":\n    print count_mod_inverse([1,2,3,4],7)\n    print count_mod_inverse([2,4,6,8],7)\n    print count_mod_inverse([2,4,6,8],7)",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def countInverse(self, x, n):\n        \"\"\"\n        :type x: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return (x**n-1) % n",
      -0.85693359375
    ],
    [
      "def modular_inverse(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(n, p - 2, p)\n\nif __name__ == '__main__':\n    print modular_inverse(10, 7)\n    print modular_inverse(100, 7)",
      -0.85693359375
    ],
    [
      "# https://leetcode.com/problems/count-modular-inverses/discuss/83698/Python-O(1)-solution-with-explanation\n\nclass Solution(object):\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n = int(n)\n        p = int(p)\n        if n < 2:\n            return 0\n        if p == n:\n            return 1\n        if p > n:\n            return 0\n        if n % p == 0:\n            return 0\n        return (n - 1) // p + 1",
      -0.85693359375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer[]}\n    def modularInverse(self, nums, p):\n        nums = sorted(nums)\n        m = len(nums)\n        inv = pow(p, m, p)\n        # find the pth root of each num\n        # pth root is the inverse of the number in the array\n        for i in range(m):\n            nums[i] = pow(nums[i], inv, p)\n        # find the inverse of each number\n        for i in range(m):\n            if nums[i]!= i:\n                nums[i] = nums[i] ^ inv\n        return nums",
      -0.85693359375
    ],
    [
      "class Solution(object):\n    def countInverse(self, arr, p):\n        \"\"\"\n        :type arr: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for i in range(len(arr)):\n            if arr[i] % p == 0:\n                ans += 1\n        return ans\n\na = Solution()\nprint(a.countInverse([5, 2, 4, 1], 7))\nprint(a.countInverse([1, 3, 2, 4, 6], 7))",
      -0.85693359375
    ],
    [
      "import math\n\ndef count_mod_inv(a, p):\n    \"\"\"\n    a - number to be modulo\n    p - prime number\n    \"\"\"\n    if p == 2:\n        return int(math.sqrt(a))\n    if p == 3:\n        return int(math.sqrt(a) % 3)\n    if p % 2 == 0:\n        return int(math.sqrt(a) % p)\n    return int(math.sqrt(a) % (p - 1))\n\na = [1, 2, 3, 4, 5]\np = 7\nprint(count_mod_inv(a, p))",
      -0.85791015625
    ],
    [
      "from math import ceil, sqrt\n\ndef mod_inv(n, p):\n    # write your code here\n    if n % p == 0:\n        x = (n % p)\n        return pow(x, (p - 1) // 2, p)\n    else:\n        return 1\n\n\ndef count_mod(n, p):\n    # write your code here\n    count = 0\n    for i in range(1, ceil(sqrt(n)) + 1):\n        if (n % i == 0) and (mod_inv(n, p) == 1):\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    n = 1000000\n    p = 100\n    print(count_mod(n, p))",
      -0.85791015625
    ],
    [
      "class Solution(object):\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return n * (n - 1) // 2 // p\n\n\nif __name__ == \"__main__\":\n    assert Solution().countModInverse(10, 5) == 15\n    assert Solution().countModInverse(15, 15) == 1\n    assert Solution().countModInverse(3, 5) == 3\n    assert Solution().countModInverse(3, 7) == 0",
      -0.85791015625
    ],
    [
      "class Solution:\n\t\n\t# @return an integer\n\tdef countInverse(self, n: int, p: int) -> int:\n\t\t\n\t\t# 1. find the square root of n\n\t\ts = int(n ** 0.5)\n\t\t\n\t\t# 2. find the mod inverse of s\n\t\tinv = pow(s, (p - 1) / 2, p)\n\t\t\n\t\t# 3. count the number of elements having inverse mod p\n\t\treturn (n - inv * inv) / p\n\nif __name__ == \"__main__\":\n\ts = Solution()\n\tprint(s.countInverse(3, 7))",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countModInverse(self, arr, p):\n        \"\"\"\n        :type arr: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        mod_inv = 0\n        for i in range(len(arr)):\n            mod_inv = (arr[i] - 1) * (arr[i] - 1) % p\n            arr[i] = mod_inv % p\n        return len(arr)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return ((p-1)//2) * n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = int(input(\"Enter number:\"))\n# param_2 = int(input(\"Enter prime number:\"))\n# param_3 = obj.countModInverse(param_1, param_2)",
      -0.8583984375
    ],
    [
      "import math\n\ndef count_mod_inv(n):\n    return math.floor(math.log(n, 2) + 1)\n\nif __name__ == '__main__':\n    print count_mod_inv(6)",
      -0.8583984375
    ],
    [
      "# https://oj.leetcode.com/problems/count-modular-inverse/\n# Given a positive integer n, count the number of numbers in [1, n] inclusive that are relatively prime to n.\n# For example, if n = 13, your function should return 8, as there are 8 numbers in [1, n] that are relatively prime to n.\n# Note:\n# 1. n is a positive integer and n < 2^31 - 1\n# 2. 1 < n < 2^31 - 1\n# 3. There are at most 2^31 - 1 numbers in [1, n] inclusive that are relatively prime to n.\n# 4. 1 < p < n\n\nclass Solution(object):\n    def countModInverse(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int(n**0.5)\n\n\nif __name__ == '__main__':\n    print Solution().countModInverse(13)",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer} x\n    # @return {integer}\n    def modularInverse(self, x):\n        if x < 2:\n            return 0\n        if x % 2 == 0:\n            return x\n        t = x\n        while t % 2 == 0:\n            t = t / 2\n        if t == 1:\n            return 0\n        while t!= 1:\n            if t % 2 == 0:\n                t = t / 2\n            else:\n                t = (t - 1) / 2\n        return t\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.modularInverse(3)\n    print s.modularInverse(4)\n    print s.modularInverse(5)",
      -0.8583984375
    ],
    [
      "def count_modular_inverse(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # TODO\n    return 0\n\nif __name__ == \"__main__\":\n    n = 10\n    print(count_modular_inverse(n))",
      -0.8583984375
    ],
    [
      "from math import ceil\n\ndef modular_inverse(a, p):\n    \"\"\"\n    Given an array a, and a prime number p, return the modular inverse of a\n    under p.\n    \"\"\"\n    return pow(a, p-2, p)\n\ndef main():\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert modular_inverse(1, 2) == 1\n    assert modular_inverse(5, 7) == -1\n    assert modular_inverse(4, 7) == 1\n    assert modular_inverse(3, 7) == -1\n    assert modular_inverse(5, 7) == -1\n\nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse\n\n# -*- coding: utf-8 -*-\n\nimport math\n\ndef modular_inverse(num, p):\n    \"\"\"\n    :type num: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if p == 1:\n        return 1\n    if p % 2 == 0:\n        return (num * (p - 1) % p) % p\n    else:\n        return (num * (p + 1) % p) % p\n\nif __name__ == \"__main__\":\n    p = int(input())\n    n = int(input())\n    print(modular_inverse(n, p))",
      -0.8583984375
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse/problem\n\ndef modular_inverse(x, p):\n    return pow(x, (p - 1) // 2, p)\n\ndef count_mod(x, p):\n    return (modular_inverse(x, p) * x) % p\n\ndef main():\n    num = int(input())\n    for i in range(num):\n        p = int(input())\n        x = int(input())\n        print(count_mod(x, p))\n\nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "def modular_inverse(arr, p):\n    \"\"\"\n    :type arr: List[int]\n    :type p: int\n    :rtype: List[int]\n    \"\"\"\n    inv = [0] * (p - 1)\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i!= j and arr[i] % p == arr[j] % p and arr[i]!= arr[j]:\n                inv[arr[i] % p - 1] += 1\n    return inv\n\n# Your Modular Inverse Solution is a function that takes a number and returns the modular inverse.\n# https://www.hackerrank.com/challenges/modular-inverse/problem",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @return an integer\n    def countModularInverse(self, n):\n        # write your code here\n        l, r = 0, n - 1\n        while l < r:\n            m = (l + r) // 2\n            if m % 2 == 0:\n                r = m\n            else:\n                l = m + 1\n        return (r - l + 1) % n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countModularInverse(5))",
      -0.8583984375
    ],
    [
      "import time\nstart_time = time.time()\n\nclass Solution:\n    \"\"\"\n    @param: n: An integer\n    @return: An integer\n    \"\"\"\n    def count(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def count(n, p):\n            if n == 1:\n                return 1\n            if n == 0:\n                return 0\n            return count(n-1, p) + (n % p == 0)\n        return count(n, 2)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.count(3)\n    print s.count(4)\n    print time.time() - start_time",
      -0.8583984375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countInverse(self, nums, p):\n        p = p-1\n        cnt = 0\n        for i in range(len(nums)):\n            if nums[i]%p == 1:\n                cnt += 1\n                if (p%nums[i]) == 0:\n                    return cnt\n        return cnt\n\ns = Solution()\nprint s.countInverse([4,2,3], 7)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countInverse(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        n = int(n)\n        result = 0\n        for i in range(1, n + 1):\n            if (n % i) == 0:\n                if (i % n) == 0:\n                    result += n/i\n                else:\n                    result += n/i + 1\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.countInverse(5)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def countInverse(self, A, p):\n        \"\"\"\n        :type A: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        A.sort()\n        for i in range(len(A)):\n            A[i] = pow(A[i], p, p)\n        return len(A) - 1",
      -0.8583984375
    ],
    [
      "import sys\nimport math\n\ndef modular_inverse(a, p):\n    if a == 0:\n        return 0\n    a_mod_p = pow(a, p-1, p)\n    if a_mod_p == 1:\n        return 0\n    b = pow(a_mod_p, p-2, p)\n    if b == 1:\n        return 0\n    c = pow(a_mod_p, p-3, p)\n    if c == 1:\n        return 0\n    d = pow(a_mod_p, p-4, p)\n    if d == 1:\n        return 0\n    e = pow(a_mod_p, p-5, p)\n    if e == 1:\n        return 0\n    return pow(a_mod_p, (p-1)/2, p)\n\ndef main(p):\n    s = 1\n    for i in range(2, p):\n        s *= (i-1)\n        s /= i\n    for i in range(2, p):\n        a = pow(i, p-2, p)\n        if modular_inverse(a, p) == 1:\n            print(a, i)\n            break\n\nif __name__ == \"__main__\":\n    p = int(sys.argv[1])\n    main(p)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def modularInverse(self, a, p):\n        \"\"\"\n        :type a: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n = p\n        while n % a!= 0:\n            n += 1\n        return pow(n, -1, p)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.modularInverse(100, 10)\n    print s.modularInverse(100, 9)\n    print s.modularInverse(100, 11)",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countInverse(self, nums, p):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0] % p == 0 and nums[0] % p!= 0\n        if nums[0] % p == 0:\n            return self.countInverse(nums[1:], p)\n        else:\n            return self.countInverse(nums[1:], p) % p",
      -0.85888671875
    ],
    [
      "# https://leetcode.com/problems/count-the-inverse-of-an-array/description/\n\nclass Solution(object):\n    def countInverse(self, nums, p):\n        \"\"\"\n        :type nums: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            while nums[i] % p == 0:\n                nums[i] = nums[i] / p\n                count += 1\n        return count",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def countModInverse(self, nums, p):\n        ans = 0\n        for i in range(1, len(nums)):\n            if nums[i] % p == 0:\n                ans += 1\n                nums[i] = nums[i] % p\n        return ans\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 2, 3, 4, 5]\n    p = 7\n    print(sol.countModInverse(nums, p))",
      -0.85888671875
    ],
    [
      "class Solution:\n    \"\"\"\n    @param num: A positive integer\n    @return: An integer\n    \"\"\"\n    def modularInverse(self, num: int) -> int:\n        \"\"\"\n        https://leetcode.com/problems/modular-inverse/solution/\n        \"\"\"\n        return pow(num, 1 + (num - 1) % (num - 1)) % num\n\nif __name__ == \"__main__\":\n    print(Solution().modularInverse(10))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countModInverse(self, A, p):\n        \"\"\"\n        :type A: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return len(set(map(lambda x: p % x, A)))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countModularInverses(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return pow(n, 2, n) - 1",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countModInverse(self, a, p):\n        \"\"\"\n        :type a: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        # https://discuss.leetcode.com/topic/8791/java-solution-with-explanation\n        if p == 1 or a % p == 0:\n            return 0\n        a, mod = a % p, p\n        while a > 1:\n            if a % p == 1:\n                a = a * (p - 1) % p\n            else:\n                a = a * (p - 1) % p\n            mod = mod * (p - 1) % p\n        return a\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = int(input())\n# param_2 = int(input())\n# param_3 = obj.countModInverse(param_1, param_2)",
      -0.85888671875
    ],
    [
      "# https://oj.leetcode.com/problems/modular-inverse/\n# I'd like to do this in python, but it's not allowed\n\n# Note: The modular inverse is denoted by a/b\n# If b is 1, then a is the inverse\n# If b is not 1, then a is the inverse mod b\n\nclass Solution:\n    # @param {integer} x\n    # @param {integer} p\n    # @return {integer}\n    def modInverse(self, x, p):\n        if x == 0:\n            return 0\n        else:\n            x = p - x\n            x = pow(x, p-2, p)\n            return x % p",
      -0.85888671875
    ],
    [
      "import math\n\ndef modular_inverse(a, p):\n    d = 2\n    while True:\n        if d % p == 0:\n            return d\n        d += 1\n\ndef modinv(a, p):\n    g = modular_inverse(a, p)\n    b = pow(g, p - 2, p)\n    return b\n\ndef count_modular_inverse(arr, p):\n    ans = 0\n    for i in range(len(arr)):\n        ans += arr[i] % p == 0 and modinv(arr[i], p) == 1\n    return ans\n\nif __name__ == '__main__':\n    arr = [2, 3, 4, 5, 6, 7, 8]\n    print(count_modular_inverse(arr, 7))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def countModularInverses(self, x, p):\n        \"\"\"\n        :type x: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        def modularInverse(a, p):\n            return pow(a, (p+1)/2, p)\n        return sum(1 for x in range(1, int(p**0.5)+1) if modularInverse(x, p) % x == 1)",
      -0.85888671875
    ],
    [
      "import math\n\ndef modular_inverse(a, p):\n    return pow(a, p-2, p)\n\ndef count_modular_inverse(a, p):\n    return sum(1 for x in range(p) if modular_inverse(x, p) == a)\n\nif __name__ == '__main__':\n    print(count_modular_inverse(2, 7))\n    print(count_modular_inverse(3, 7))\n    print(count_modular_inverse(7, 7))\n    print(count_modular_inverse(5, 7))\n    print(count_modular_inverse(4, 7))\n    print(count_modular_inverse(3, 7))\n    print(count_modular_inverse(5, 7))",
      -0.85888671875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def modInverse(self, x, p):\n        \"\"\"\n        :type x: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return pow(x, p-2, p) % p\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.modInverse(3, 7)\n    print sol.modInverse(4, 7)\n    print sol.modInverse(5, 7)\n    print sol.modInverse(6, 7)\n    print sol.modInverse(7, 7)\n    print sol.modInverse(8, 7)\n    print sol.modInverse(9, 7)\n    print sol.modInverse(10, 7)\n    print sol.modInverse(11, 7)\n    print sol.modInverse(12, 7)",
      -0.85888671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def modularInverse(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target == 1:\n            return 1\n        if target == 0:\n            return 0\n        m = pow(target, -1, target)\n        s = 0\n        for i in range(len(nums)):\n            s = (s + pow(nums[i], m, target)) % target\n        return s",
      -1.14453125
    ],
    [
      "def modular_inverse(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(n, p-2, p)\n\ndef main():\n    print(modular_inverse(11, 17))\n\nif __name__ == \"__main__\":\n    main()",
      -1.3369140625
    ],
    [
      "# https://oj.leetcode.com/problems/count-modular-inverse/\n\nclass Solution:\n    # @param x, a long integer\n    # @param p, a long integer\n    # @return an integer\n    def countModInverse(self, x, p):\n        if x == 0:\n            return 0\n        if x < 0:\n            x = -x\n        if x == 1:\n            return 1\n        # If p = 1, then x is the inverse\n        if p == 1:\n            return x\n        # If p is not 1, then x is not the inverse\n        if p % x!= 0:\n            return 0\n        # If p is prime, then x is the modular inverse\n        if p == x:\n            return 1\n        # If p is composite, then x is not the inverse\n        return 0\n\n# Test Cases\nprint Solution().countModInverse(2, 3)\nprint Solution().countModInverse(4, 5)\nprint Solution().countModInverse(3, 5)",
      -1.392578125
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse/problem\n\ndef modular_inverse(a, p):\n    return (a**(p-2) + 1) // p\n\ndef modular_inverse_prime(a, p):\n    return (a**(p-2) + 1) // (p-1)\n\ndef modular_inverse_prime_prime(a, p, q):\n    return (a**(p-2) + 1) // (q-1)\n\n\nif __name__ == '__main__':\n    a = int(input())\n    p = int(input())\n    print(modular_inverse(a, p))",
      -2.36328125
    ],
    [
      "#!/usr/bin/env python\n\nimport timeit\nimport math\n\ndef modular_inverse(x, p):\n    \"\"\"\n    return modular inverse of x under p.\n    \"\"\"\n    if p % x!= 0:\n        return 0\n    r = pow(p, x % (p - 1), p)\n    return r\n\ndef modular_inverse_mod(x, p):\n    \"\"\"\n    return modular inverse of x under p.\n    \"\"\"\n    if p % x!= 0:\n        return 0\n    r = pow(p, x % (p - 1), p)\n    return r % p\n\ndef modular_inverse_mod_prime(x, p):\n    \"\"\"\n    return modular inverse of x under p.\n    \"\"\"\n    if p % x!= 0:\n        return 0\n    r = pow(p, x % (p - 1), p)\n    return r % p\n\nif __name__ == '__main__':\n    print timeit.timeit('modular_inverse(12, 7)', setup=\"from __main__ import modular_inverse\", number=1)\n    print timeit.timeit('modular_inverse_mod(12, 7)', setup=\"from __main__ import modular_inverse_mod\", number=1)\n    print timeit.timeit('modular_inverse_mod_prime(12, 7)', setup=\"from __main__ import modular_inverse_mod_prime\", number=1)",
      -2.38671875
    ],
    [
      "class Solution(object):\n    def countModularInverses(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: int\n        \"\"\"\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/Python-Solution-using-bitwise-operations\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-inverses/discuss/133547/C-Python-Solution\n        # https://oj.leetcode.com/problems/count-modular-in",
      -2.498046875
    ],
    [
      "import time\nimport math\n\nstart_time = time.time()\n\ndef modular_inverse(n, p):\n    a = math.floor(n/p)\n    b = n - a*p\n    if a % 2 == 0:\n        return pow(b, p-1, p)\n    else:\n        return pow(b, p, p)\n\nprint(\"Time used: {}\".format(time.time() - start_time))\n\ndef count_mod(n, p):\n    return pow(n, p-2, p)\n\nprint(count_mod(1, 2))\nprint(count_mod(2, 2))\nprint(count_mod(3, 2))\nprint(count_mod(4, 2))\nprint(count_mod(5, 2))\nprint(count_mod(6, 2))\nprint(count_mod(7, 2))\nprint(count_mod(8, 2))\nprint(count_mod(9, 2))\nprint(count_mod(10, 2))\nprint(count_mod(11, 2))\nprint(count_mod(12, 2))\nprint(count_mod(13, 2))\nprint(count_mod(14, 2))\nprint(count_mod(15, 2))\nprint(count_mod(16, 2))\nprint(count_mod(17, 2))\nprint(count_mod(18, 2))\nprint(count_mod(19, 2))\nprint(count_mod(20, 2))\nprint(count_mod(21, 2))\nprint(count_mod(22, 2))\nprint(count_mod(23, 2))\nprint(count_mod(24, 2))\nprint(count_mod(25, 2))\nprint(count_mod(26, 2))\nprint(count_mod(27, 2))\nprint(count_mod(28, 2))\nprint(count_mod(29, 2))\nprint(count_mod(30, 2))\nprint(count_mod(31, 2))\nprint(count_mod(32, 2))\nprint(count_mod(33, 2))\nprint(count_mod(34, 2))\nprint(count_mod(",
      -2.619140625
    ],
    [
      "def modular_inverse(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_1(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_2(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_3(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_4(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_5(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_6(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:\n    a^(-1) mod p\n    '''\n    return pow(a, (p-1)/2, p)\n\ndef modular_inverse_7(a, p):\n    '''\n    Input:\n    a = a mod p\n    p = prime number\n    Output:",
      -2.724609375
    ],
    [
      "# https://discuss.leetcode.com/topic/16296/share-my-o-n-time-and-space-solution-with-explanation\n\nclass Solution(object):\n    def modularInverse(self, x, p):\n        \"\"\"\n        :type x: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        # https://discuss.leetcode.com/topic/16296/share-my-o-n-time-and-space-solution-with-explanation\n        # http://blog.csdn.net/linhuanmars/article/details/52093948\n        # x = x mod p\n        # x = (x * p - 1) / (p - 1)\n        # x = x * x % p\n        # x = x * (p - 1) % p\n        # x = x * (x * x + 1) % p\n        # x = (x * x + 1) % p\n        # x = (x * x + p) % p\n        # x = (x * x + p * p) % p\n        # x = (x * x + p * p * p) % p\n        # x = (x * x + p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p * p * p * p * p * p * p * p * p) % p\n        # x = (x * x + p * p * p",
      -2.921875
    ],
    [
      "from math import sqrt\n\ndef modular_inverse(a, p):\n    return pow(a, (p-1)/2, p)\n\ndef count_modular_inverse(arr, p):\n    n = len(arr)\n    return sum([1 if arr[i] == modular_inverse(arr[i], p) else 0 for i in range(n)])\n\ndef test_count_modular_inverse():\n    assert count_modular_inverse([1,2,3,4], 7) == 4\n    assert count_modular_inverse([1,2,3,4], 5) == 2\n    assert count_modular_inverse([1,2,3,4], 2) == 0\n    assert count_modular_inverse([1,2,3,4], 3) == 1\n    assert count_modular_inverse([1,2,3,4], 4) == 1\n    assert count_modular_inverse([1,2,3,4], 5) == 0\n    assert count_modular_inverse([1,2,3,4], 6) == 1\n    assert count_modular_inverse([1,2,3,4], 7) == 1\n\ndef main():\n    test_count_modular_inverse()\n\nif __name__ == \"__main__\":\n    main()",
      -2.958984375
    ],
    [
      "class Solution(object):\n    def countInverse(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return len(set(nums)) - 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.countInverse([1,2,3,4,5])\n    print s.countInverse([5,6,7,8,9])\n    print s.countInverse([1,2,3,4,5,6,7,8,9])\n    print s.countInverse([1,2,3,4,5,6,7,8,9,10])\n    print s.countInverse([1,2,3,4,5,6,7,8,9,10,11])",
      -3.123046875
    ],
    [
      "# https://oj.leetcode.com/problems/modular-inverse-problem/\n# Given a positive integer n, return an integer array A having A[i] = 1 if n % i = 0, otherwise A[i] = 0 for all 0 < i < n.\n#\n# Note:\n# 1. 1 < n < 100.\n# 2. For example, if n = 7, your function should return [1, 0, 0, 1, 1, 0].\n# 3. You may assume that n is an integer within the range [1, 100].\n# 4. You may assume that all the elements in A are unique.\n# 5. The array A is in ascending order.\n# 6. Example:\n# Input: n = 7, p = 2\n# Output: [1, 1, 0, 1, 1, 0]\n# Explanation:\n# If n is 7, then 7 % 1 = 0, 1 % 1 = 0,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 2 = 0, 1 % 2 = 1,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 3 = 0, 1 % 3 = 1,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 4 = 0, 1 % 4 = 1,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 5 = 0, 1 % 5 = 1,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 6 = 0, 1 % 6 = 1,..., 7 % 7 = 0, 7 % 7 = 1.\n# If n is 7, then 7 % 7 = 1.\n#\n# Note:\n# The modular inverse of n is the number p such that n % p = 0.\n# The modular inverse of p is the number n such that p % n = 0.\n# You may assume that p and n are both positive integers and n < p.\n#\n# Follow up:\n# Could you solve it with constant space complexity?\n\nclass Solution(object):\n    def count(self, n, p",
      -3.263671875
    ],
    [
      "# https://leetcode.com/problems/count-modular-inverse-of-array-elements-having-modular-inverse/discuss/447924/python-dp-solution-with-explanation\n\n\nclass Solution(object):\n    def countModularInverse(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) == 0:\n            return 0\n        if len(A) == 1:\n            return A[0]\n        if len(A) == 2:\n            return A[0] * A[1] % self.prime\n        n = len(A)\n        dp = [0] * (self.prime + 1)\n        dp[0] = 1\n        for i in range(1, self.prime):\n            dp[i] = dp[i - 1]\n            for j in range(0, n):\n                if i * A[j] % self.prime == 0:\n                    dp[i] += dp[i - 1]\n\n        return dp[-1]\n\n# Note:\n# dp[i] is the number of positive integers i such that i * A[j] % p == 0\n# for j = 1,..., n, p is prime\n\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3]\n    print(Solution().countModularInverse(A))\n    A = [1, 2, 3, 4, 5]\n    print(Solution().countModularInverse(A))",
      -3.294921875
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse/problem\n\nimport math\n\n\ndef modular_inverse(x, p):\n    return pow(x, (p - 1) // 2, p)\n\n\ndef modular_inverse_recursive(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse(x, p) * modular_inverse_recursive(modular_inverse(x, p), p)) % p\n\n\ndef modular_inverse_iterative(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse_iterative(modular_inverse(x, p), p) * modular_inverse_iterative(modular_inverse(x, p), p)) % p\n\n\ndef modular_inverse_pow(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse_pow(modular_inverse(x, p), p) * modular_inverse_pow(modular_inverse(x, p), p)) % p\n\n\ndef modular_inverse_pow_recursive(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse_pow_recursive(modular_inverse(x, p), p) * modular_inverse_pow_recursive(modular_inverse(x, p), p)) % p\n\n\ndef modular_inverse_pow_iterative(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse_pow_iterative(modular_inverse(x, p), p) * modular_inverse_pow_iterative(modular_inverse(x, p), p)) % p\n\n\ndef modular_inverse_pow_iterative_prime(x, p):\n    if x == 1:\n        return 1\n    return (modular_inverse_pow_iterative(modular_inverse(x, p), p) * modular_inverse_pow_iterative(modular_inverse(x, p",
      -3.390625
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse/problem\n\nimport math\nimport timeit\n\n\ndef mod_inv(n, p):\n    return pow(n, p - 2, p)\n\n\ndef mod_inv_recur(n, p):\n    if n == 1:\n        return 1\n    return mod_inv(mod_inv(n, p), p)\n\n\ndef mod_inv_iter(n, p):\n    if n == 1:\n        return 1\n    return mod_inv_recur(n, p)\n\n\ndef mod_inv_dp(n, p):\n    if n == 1:\n        return 1\n    return (mod_inv_recur(n, p) if n % p == 0 else mod_inv_iter(n, p)) % p\n\n\nif __name__ == \"__main__\":\n    start = timeit.default_timer()\n    print(mod_inv_dp(10, 3))\n    print(timeit.default_timer() - start)",
      -3.712890625
    ],
    [
      "# https://oj.leetcode.com/problems/count-and-say/\n# Given a positive integer n, generate a list such that every element is the modular inverse of some element in the list.\n# Return the list.\n# Note: The returned list must not contain duplicate elements.\n\n# Example:\n# Input:\n# n = 3\n# p = 7\n# Output: [1, 3, -1, -3, 5]\n\n# Note:\n# The input is positive and will not exceed 100.\n# The input p is positive and will not exceed 200.\n# The length of the output list is at most 1000.\n\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        res = []\n        if n == 0:\n            return '1'\n        res.append(1)\n        for i in range(1, n):\n            cur = res[-1]\n            cur = cur * 10 + res[-2]\n            cur = cur % p\n            res.append(cur)\n        return ''.join(str(x) for x in res)\n\ns = Solution()\nprint s.countAndSay(3)",
      -4.21484375
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def modularInverse(self, nums, p):\n        result = 1\n        for i in range(1, len(nums)):\n            result = (nums[i] * result) % p\n        return result\n\n\ns = Solution()\n# print(s.modularInverse([1, 2, 3], 7))\n# print(s.modularInverse([3, 2, 1], 7))\n# print(s.modularInverse([1, 3, 2], 7))\n# print(s.modularInverse([1, 3, 3, 1], 7))\n# print(s.modularInverse([1, 3, 3, 2], 7))\n# print(s.modularInverse([1, 3, 3, 3], 7))\n# print(s.modularInverse([1, 3, 3, 3, 1], 7))\n# print(s.modularInverse([1, 3, 3, 3, 2], 7))\n# print(s.modularInverse([1, 3, 3, 3, 3], 7))\n# print(s.modularInverse([1, 3, 3, 3, 3, 1], 7))\n# print(s.modularInverse([1, 3, 3, 3, 3, 2], 7))\n# print(s.modularInverse([1, 3, 3, 3, 3, 3], 7))",
      -4.68359375
    ],
    [
      "from math import ceil\nfrom random import randint\n\nclass Solution(object):\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 2:\n            return n\n        if p % 2 == 0:\n            return self.countModInverse(n, p // 2) % p\n        if p % 4 == 0:\n            return self.countModInverse(n, p // 4) % p\n        if p % 8 == 0:\n            return self.countModInverse(n, p // 8) % p\n        if p % 16 == 0:\n            return self.countModInverse(n, p // 16) % p\n        if p % 32 == 0:\n            return self.countModInverse(n, p // 32) % p\n        if p % 64 == 0:\n            return self.countModInverse(n, p // 64) % p\n        if p % 128 == 0:\n            return self.countModInverse(n, p // 128) % p\n        if p % 256 == 0:\n            return self.countModInverse(n, p // 256) % p\n        return self.countModInverse(n, p // 512) % p\n\n\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return pow(n, p - 2, p)\n\nif __name__ == '__main__':\n    s = Solution()\n    n = randint(2, 10)\n    p = randint(2, 10)\n    print(s.countModInverse(n, p))",
      -4.77734375
    ],
    [
      "# https://oj.leetcode.com/problems/modular-inverse/\n# Given a positive integer n, return a positive integer m which is equal to n (modulo 2) and is the modular inverse of n modulo p, i.e.\n# there is an integer a which is equal to 1 (modulo p) and such that n (mod p) = a (mod p) and p is a prime number.\n\n# Note:\n# n and p are non-negative integers.\n# n is greater than p.\n\n# Example 1:\n# Input: n = 7, p = 61\n# Output: 1\n# Explanation: There are two solutions (1 and 3).\n# Example 2:\n# Input: n = 7, p = 61\n# Output: 3\n# Explanation: There are two solutions (3 and 1) and (3 and 3).\n\n\nclass Solution(object):\n    def modInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return pow(pow(n, p-2, p), p-2, p)",
      -4.8671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} mod\n    # @return {integer}\n    def countInverse(self, nums, mod):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        # 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53\n        # 1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31",
      -5.421875
    ],
    [
      "# https://leetcode.com/problems/find-modular-inverse/discuss/203388/Python-Cython-Cython-Cython\n\nclass Solution(object):\n    def modularInverse(self, x, n):\n        \"\"\"\n        :type x: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if x == 1:\n            return 1\n        if x == n:\n            return 1\n        if x == 0:\n            return 0\n        if x % 2 == 0:\n            return self.modularInverse(x/2, n)\n        else:\n            return self.modularInverse(x-1, n)\n\n    # def modularInverse(self, x, n):\n    #     \"\"\"\n    #     :type x: int\n    #     :type n: int\n    #     :rtype: int\n    #     \"\"\"\n    #     if x == 1:\n    #         return 1\n    #     if x == n:\n    #         return 1\n    #     if x == 0:\n    #         return 0\n    #     if x % 2 == 0:\n    #         return self.modularInverse(x/2, n)\n    #     else:\n    #         return self.modularInverse(x-1, n)\n\nif __name__ == \"__main__\":\n    print(Solution().modularInverse(2, 3))",
      -5.5546875
    ],
    [
      "# The following solution is from https://www.geeksforgeeks.org/count-modular-inverse-of-array-elements-equal-to-itself/\ndef modular_inverse(array, p):\n    s = 0\n    for i in range(p):\n        s += (array[i] * (array[i] - 1) % p) % p\n    return s\n\ndef count_modular_inverse(array, p):\n    return sum(1 for x in array if modular_inverse(array, p) == x)\n\nif __name__ == \"__main__\":\n    array = [4, 3, 2, 1]\n    p = 7\n    print(count_modular_inverse(array, p))",
      -5.92578125
    ],
    [
      "# https://oj.leetcode.com/problems/count-modular-inverse-of-array/\n# Given an integer array nums, return an array length 2, where for each element in nums, the value is the modular inverse of the element.\n# Example 1:\n# Input: nums = [1, 2, 3]\n# Output: [2, 3, 1]\n# Example 2:\n# Input: nums = [1, 1]\n# Output: [1, 1]\n# Example 3:\n# Input: nums = [1, 0]\n# Output: [0, 1]\n\n# score:100(9ms)\n# time:O(N^2)\n# space:O(1)\nclass Solution(object):\n    def countModInverse(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        return [nums[i] for i in range(len(nums)) if nums[i] % nums[i+1]!= nums[i] % nums[i-1]]\n\n# score:100(9ms)\n# time:O(N^2)\n# space:O(1)\nclass Solution2(object):\n    def countModInverse(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = [0] * (n + 1)\n        for i in range(1, n):\n            result[nums[i]] = nums[i] % nums[i-1]\n        for i in range(n-1, -1, -1):\n            if result[i] == i:\n                result[i] = nums[i] % nums[i+1]\n        return result\n\nif __name__ == \"__main__\":\n    print Solution().countModInverse([1, 2, 3])\n    print Solution2().countModInverse([1, 2, 3])",
      -6.0390625
    ],
    [
      "class Solution:\n    # @param x, an integer\n    # @param n, an integer\n    # @return an integer\n    def modularInverse(self, x, n):\n        # write your code here\n        if x == 1:\n            return 1\n        if x == n:\n            return 1\n        if x == n-1:\n            return n-1\n        if x == n+1:\n            return n+1\n        if x == n-2:\n            return n-2\n        if x == n+2:\n            return n+2\n        # 1st\n        if x % 2 == 0:\n            return self.modularInverse(n-x, n)\n        # 2nd\n        if x % 3 == 0:\n            return self.modularInverse(n-x, n)\n        # 3rd\n        if x % 5 == 0:\n            return self.modularInverse(n-x, n)\n        # 4th\n        if x % 7 == 0:\n            return self.modularInverse(n-x, n)\n        # 5th\n        if x % 11 == 0:\n            return self.modularInverse(n-x, n)\n        # 6th\n        if x % 13 == 0:\n            return self.modularInverse(n-x, n)\n        # 7th\n        if x % 17 == 0:\n            return self.modularInverse(n-x, n)\n        # 8th\n        if x % 19 == 0:\n            return self.modularInverse(n-x, n)\n        # 9th\n        if x % 23 == 0:\n            return self.modularInverse(n-x, n)\n        # 10th\n        if x % 29 == 0:\n            return self.modularInverse(n-x, n)\n        # 11th\n        if x % 31 == 0:\n            return self.modularInverse(n-x, n)\n        # 12th\n        if x % 37 == 0:\n            return self.modularInverse(n-x, n)\n        # 13th\n        if x % 41 == 0:\n            return self.modularIn",
      -6.05859375
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/modular-inverse\n\nimport sys\nimport math\n\ndef modular_inverse(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_2(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_3(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_5(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_7(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_11(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_13(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_17(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_19(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a\n    return b\n\ndef modular_inverse_prime_mod_23(a, p):\n    b = 1\n    while b!= a:\n        b = b * p % a",
      -6.14453125
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} mod\n    # @return {integer}\n    def modularInverse(self, nums, mod):\n        if not nums or len(nums) == 0:\n            return 0\n        maxN = max(nums)\n        nums.sort()\n        r = pow(mod, maxN, mod)\n        result = 1\n        for i in range(0, len(nums)):\n            result = (result * r) % mod\n            if result == 1:\n                return i\n        return 0\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.modularInverse([2,3,5,7], 17)\n    print solution.modularInverse([3,2,1], 7)\n    print solution.modularInverse([3,2,1], 15)\n    print solution.modularInverse([3,2,1], 23)\n    print solution.modularInverse([3,2,1], 29)\n    print solution.modularInverse([3,2,1], 37)",
      -6.34375
    ],
    [
      "from math import ceil\n\nclass Solution:\n    def modularInverse(self, A: List[int], P: int) -> int:\n        mod = P\n        a = 1\n        b = 1\n        c = 1\n        d = 1\n        while a < P:\n            b = (b*P+1)%mod\n            c = (c*P+1)%mod\n            d = (d*P+1)%mod\n            a = (a*b+c)%mod\n        return a\n    \n    def modularInverse2(self, A: List[int], P: int) -> int:\n        if len(A) < 2:\n            return 0\n        a = A[0]\n        b = A[-1]\n        if a < 0:\n            a = a + P\n        if b < 0:\n            b = b + P\n        return ((b-a) % P + P) % P\n        \n    def modularInverse3(self, A: List[int], P: int) -> int:\n        if len(A) < 2:\n            return 0\n        a = A[0]\n        b = A[-1]\n        if a < 0:\n            a = a + P\n        if b < 0:\n            b = b + P\n        return (b-a) % P\n\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5]\n    print(Solution().modularInverse(A, 5))",
      -6.6640625
    ],
    [
      "# https://github.com/kamyu104/LeetCode/blob/master/Python/modular-inverse.py\n# https://www.youtube.com/watch?v=3q-uHrAJg4U\n# https://www.youtube.com/watch?v=x-7o9jv1pT4\n\nclass Solution(object):\n    def modularInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n, p = abs(n), abs(p)\n        if n == p:\n            return 1\n        if n < p:\n            return self.modularInverse(p, n)\n        # n >= p\n        if p == 2:\n            return 1\n        if p % 2 == 0:\n            return self.modularInverse(p, n)\n        x = pow(n, (p - 1) / 2, p)\n        return pow(x, -1, p)\n\nif __name__ == '__main__':\n    assert Solution().modularInverse(3, 7) == -1\n    assert Solution().modularInverse(3, 13) == -3\n    assert Solution().modularInverse(3, 17) == -5\n    assert Solution().modularInverse(2, 3) == 1\n    assert Solution().modularInverse(5, 7) == -1\n    assert Solution().modularInverse(5, 13) == -3\n    assert Solution().modularInverse(5, 17) == -5",
      -6.875
    ],
    [
      "class Solution(object):\n    def countModularInverse(self, a, p):\n        \"\"\"\n        :type a: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 1:\n            return 1\n\n        if p == 2:\n            return a % 2 == 0\n\n        if p == 3:\n            return a % 3 == 0\n\n        if p == 5:\n            return a % 5 == 0\n\n        if p == 7:\n            return a % 7 == 0\n\n        if p == 11:\n            return a % 11 == 0\n\n        if p == 13:\n            return a % 13 == 0\n\n        if p == 17:\n            return a % 17 == 0\n\n        if p == 19:\n            return a % 19 == 0\n\n        if p == 23:\n            return a % 23 == 0\n\n        if p == 29:\n            return a % 29 == 0\n\n        if p == 31:\n            return a % 31 == 0\n\n        if p == 37:\n            return a % 37 == 0\n\n        if p == 41:\n            return a % 41 == 0\n\n        if p == 43:\n            return a % 43 == 0\n\n        if p == 47:\n            return a % 47 == 0\n\n        if p == 49:\n            return a % 49 == 0\n\n        if p == 53:\n            return a % 53 == 0\n\n        if p == 59:\n            return a % 59 == 0\n\n        if p == 61:\n            return a % 61 == 0\n\n        if p == 67:\n            return a % 67 == 0\n\n        if p == 71:\n            return a % 71 == 0\n\n        if p == 73:\n            return a % 73 == 0\n\n        if p == 79:\n            return a % 79 == 0\n\n        if p == 83:\n            return a % 83 == 0\n\n        if p == 89:\n            return a % 89 == 0\n\n        if p == 97:\n            return a % 97 == 0\n\n        if p == 101:\n            return a % 101 == 0\n\n        if p == 103:\n            return a % 103 == 0\n\n        if p == 107:\n            return a % 107 == 0\n\n        if p == 109:\n            return a % 109 == 0\n\n        if",
      -7.1015625
    ],
    [
      "class Solution(object):\n    def countModInverse(self, A, P):\n        \"\"\"\n        :type A: List[int]\n        :type P: int\n        :rtype: int\n        \"\"\"\n        if not A or len(A) == 0:\n            return 0\n        \n        if not P or P == 1:\n            return len(A)\n        \n        # compute mod inverse\n        # https://en.wikipedia.org/wiki/Modular_inverse\n        # a^p = 1 (mod p)\n        # a^p = a (mod p)\n        # a^p = a (mod P)\n        # a^p = a^(p/2) (mod P)\n        # a^p = a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) * a^(p/2) (mod P)\n        # a^p = a^(p/2) * a^(p/2) * a^(",
      -7.11328125
    ],
    [
      "# https://oj.leetcode.com/problems/modular-inverse/\n\nclass Solution(object):\n    def modularInverse(self, a, p):\n        \"\"\"\n        :type a: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 2:\n            return 1\n        if p == 3:\n            return 1\n        if p == 5:\n            return 1\n        if p == 7:\n            return 1\n        if p == 11:\n            return 1\n        if p == 13:\n            return 1\n        if p == 17:\n            return 1\n        if p == 19:\n            return 1\n        if p == 23:\n            return 1\n        if p == 29:\n            return 1\n        if p == 31:\n            return 1\n        if p == 37:\n            return 1\n        if p == 41:\n            return 1\n        if p == 43:\n            return 1\n        if p == 47:\n            return 1\n        if p == 53:\n            return 1\n        if p == 59:\n            return 1\n        if p == 61:\n            return 1\n        if p == 67:\n            return 1\n        if p == 71:\n            return 1\n        if p == 73:\n            return 1\n        if p == 79:\n            return 1\n        if p == 83:\n            return 1\n        if p == 89:\n            return 1\n        if p == 97:\n            return 1\n        if p == 101:\n            return 1\n        if p == 103:\n            return 1\n        if p == 107:\n            return 1\n        if p == 109:\n            return 1\n        if p == 113:\n            return 1\n        if p == 127:\n            return 1\n        if p == 131:\n            return 1\n        if p == 137:\n            return 1\n        if p == 139:\n            return 1\n        if p == 149:\n            return 1\n        if p == 151:\n            return 1\n        if p == 157:\n            return 1\n        if p == 163:\n            return 1\n        if p == 167:\n            return 1\n        if p == 173:\n            return 1\n        if p ==",
      -7.14453125
    ],
    [
      "# https://github.com/kamyu104/LeetCode/blob/master/Python/count-modular-inverse-in-a-prime-number/count-modular-inverse-in-a-prime-number.py\nclass Solution(object):\n    def countModularInverse(self, mod, n):\n        \"\"\"\n        :type mod: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # base case\n        if n == 1:\n            return 1\n\n        # base case\n        if mod == 1:\n            return n\n\n        # base case\n        if mod == 2:\n            return n % 2\n\n        # base case\n        if mod == 3:\n            return n % 3\n\n        # base case\n        if mod == 4:\n            return n % 4\n\n        # base case\n        if mod == 5:\n            return n % 5\n\n        # base case\n        if mod == 6:\n            return n % 6\n\n        # base case\n        if mod == 7:\n            return n % 7\n\n        # base case\n        if mod == 8:\n            return n % 8\n\n        # base case\n        if mod == 9:\n            return n % 9\n\n        # base case\n        if mod == 10:\n            return n % 10\n\n        # base case\n        if mod == 11:\n            return n % 11\n\n        # base case\n        if mod == 12:\n            return n % 12\n\n        # base case\n        if mod == 13:\n            return n % 13\n\n        # base case\n        if mod == 14:\n            return n % 14\n\n        # base case\n        if mod == 15:\n            return n % 15\n\n        # base case\n        if mod == 16:\n            return n % 16\n\n        # base case\n        if mod == 17:\n            return n % 17\n\n        # base case\n        if mod == 18:\n            return n % 18\n\n        # base case\n        if mod == 19:\n            return n % 19\n\n        # base case\n        if mod == 20:\n            return n % 20\n\n        # base case\n        if mod == 21:\n            return n % 21\n\n        # base case\n        if mod == 22:\n            return",
      -7.2734375
    ],
    [
      "# https://leetcode.com/problems/modular-inverse-of-numbers-under-prime-number/discuss/83549/Python-solution-using-prime-number-search-solutions\n# https://leetcode.com/problems/modular-inverse-of-numbers-under-prime-number/discuss/83549/Python-solution-using-prime-number-search-solutions\n# https://leetcode.com/problems/modular-inverse-of-numbers-under-prime-number/discuss/83549/Python-solution-using-prime-number-search-solutions\n\nclass Solution(object):\n    def modularInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0: return 1\n        if n == 1: return 0\n        if n == 2: return 1\n        \n        # Using prime number search to find the prime number that the modulus is divisible by\n        while p % n == 0:\n            p = p/n\n        if p == 1: return 1\n        \n        # Using the prime number search to find the number of modular inverse\n        divisor = 2\n        while True:\n            if divisor % p == 0:\n                return (p**(n-1) + 1) / (divisor * (n-1))\n            divisor += 1\n            if divisor % p == 0:\n                return (p**(n-1) + 1) / (divisor * (n-1))\n            \n        return 0\n\n\n# Note:\n#\n# n is a positive integer.\n# p is a prime number.\n# p > 1 and p < n.\n#\n# Time:  O(n)\n# Space: O(1)\n#\n# Idea:\n#\n# Modular inverse is the number of positive integers that are divisible by p-1 and that are not divisible by p-1.\n# So, we can simply count the number of positive integers that are divisible by p-1.\n# We can then find the number of",
      -7.671875
    ],
    [
      "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} p\n    # @return {integer}\n    def count(self, nums, p):\n        if p % 2 == 0:\n            return self.count_mod_2(nums, p)\n        else:\n            return self.count_mod_2(self.inverse(nums, p), p)\n\n    def count_mod_2(self, nums, p):\n        return sum(nums) % p == 0\n        \n    def inverse(self, nums, p):\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        \n        t = p\n        for i in range(2, n + 1):\n            t = (t * nums[i-1]) % p\n        return t\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1], 2)\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1], 3)\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1], 5)\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1], 7)\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1], 11)\n    print s.count([0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
      -7.7578125
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution(object):\n    def count_mod(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n = 2\n        while n < p:\n            if m % n == 0:\n                break\n            else:\n                n += 1\n        return n - 2\n\n    def count_mod_2(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return (m + p - 1) // p\n\n    def count_mod_3(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1)\n\n    def count_mod_4(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1) + p\n\n    def count_mod_5(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1) + p\n\n    def count_mod_6(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1) + p\n\n    def count_mod_7(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1) + p\n\n    def count_mod_8(self, m, p):\n        \"\"\"\n        :type m: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        return m % (p - 1) + p\n\n    def count_mod_9(self, m, p):\n        \"\"\"\n        :type m: int",
      -7.87109375
    ],
    [
      "# https://github.com/lunatic-python/Lunatic/issues/37\n# https://en.wikipedia.org/wiki/Modular_integers\n# https://en.wikipedia.org/wiki/Modular_arithmetic\n# https://en.wikipedia.org/wiki/Modular_multiplication\n# https://en.wikipedia.org/wiki/Modular_addition\n# https://en.wikipedia.org/wiki/Modular_division\n# https://en.wikipedia.org/wiki/Modular_exponentiation\n\nimport random\n\ndef modular_inverse(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(p, n - 1, p)\n\ndef modular_gcd(a, b):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :rtype: int\n    \"\"\"\n    return pow(a, b, p)\n\ndef modular_lcm(a, b):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :rtype: int\n    \"\"\"\n    return pow(a, (a * b) // gcd(a, b), p)\n\ndef modular_exponentiation(a, b, p):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(a, b, p)\n\ndef modular_add(a, b, p):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(a, b, p)\n\ndef modular_sub(a, b, p):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    return pow(a, b, p)\n\ndef modular_mul(a, b, p):\n    \"\"\"\n    :type a: int\n    :type b: int\n    :type p: int\n    :rtype: int",
      -8.875
    ],
    [
      "def modular_inverse(x, p):\n    \"\"\"\n    :type x: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if x == 1:\n        return 1\n    if x == 0:\n        return 0\n    if x == 2:\n        return 1\n    if x == 3:\n        return 2\n    if x == 5:\n        return 4\n    if x == 7:\n        return 6\n    if x == 11:\n        return 8\n    if x == 13:\n        return 12\n    if x == 17:\n        return 16\n    if x == 19:\n        return 18\n    if x == 23:\n        return 22\n    if x == 29:\n        return 24\n    if x == 31:\n        return 26\n    if x == 37:\n        return 32\n    if x == 41:\n        return 36\n    if x == 43:\n        return 40\n    if x == 47:\n        return 44\n    if x == 53:\n        return 48\n    if x == 59:\n        return 52\n    if x == 61:\n        return 56\n    if x == 67:\n        return 60\n    if x == 71:\n        return 64\n    if x == 73:\n        return 68\n    if x == 79:\n        return 72\n    if x == 83:\n        return 76\n    if x == 89:\n        return 80\n    if x == 97:\n        return 88\n    if x == 101:\n        return 92\n    if x == 103:\n        return 96\n    if x == 107:\n        return 100\n    if x == 109:\n        return 104\n    if x == 113:\n        return 108\n    if x == 127:\n        return 112\n    if x == 131:\n        return 120\n    if x == 137:\n        return 124\n    if x == 139:\n        return 128\n    if x == 143:\n        return 132\n    if x == 149:\n        return 136\n    if x == 151:\n        return 140\n    if x == 157:\n        return 144\n    if x == 163:\n        return 152\n    if x == 167:\n        return 156\n    if x == 173:\n        return 160",
      -8.9375
    ],
    [
      "import math\nimport timeit\n\n\ndef modular_inverse(a, p):\n    return pow(a, p - 2, p)\n\n\ndef main():\n    start = timeit.default_timer()\n\n    # the number of tests\n    num_tests = 100000\n\n    # the number of bits in the number we're working with\n    num_bits = 32\n\n    # the number of numbers we're working with\n    num_numbers = 10\n\n    # the number of primes we're using\n    num_primes = 10\n\n    # the prime number we're working with\n    prime = 2\n\n    # the number of times we're going to call the function\n    num_calls = 100\n\n    # the array we're going to test\n    test_array = [0] * num_numbers\n\n    # the array we're going to count the number of times modular inverse is called\n    # this is to test if the function is working properly\n    modular_inverse_count = [0] * num_numbers\n\n    # we're going to make a list of the values we're going to test\n    # the number of tests will be the product of the values in the list\n    # this is to ensure that the function is being called for every number\n    # we're going to test\n    test_list = [0] * num_tests\n    for i in range(num_tests):\n        test_list[i] = i\n\n    # we're going to make a list of the values we're going to test\n    # the number of tests will be the product of the values in the list\n    # this is to ensure that the function is being called for every number\n    # we're going to test\n    test_list2 = [0] * num_tests\n\n    # we're going to make a list of the values we're going to test\n    # the number of tests will be the product of the values in the list\n    # this is to ensure that the function is being called for every number\n    # we're going to test\n    test_list3 = [0] * num_tests\n\n    # we're going to make a list of the values we're going to test\n    # the number of tests will be the product of the values in the list\n    # this is to",
      -9.125
    ],
    [
      "import math\n\ndef count_mod_inverse(n, p):\n    \"\"\"\n    :type n: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    # compute the modular inverse mod p\n    # the modular inverse is (n+1)/(p-1)\n    # p is the prime number\n    # n is the number to be multiplied\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular inverse is (n+1)/(p-1)\n    # n is the number to be multiplied\n    # p is the prime number\n    # the modular",
      -9.359375
    ],
    [
      "def modular_inverse(a, p):\n    if p == 1: return 1\n    if p == 2: return 0\n    if p % 2 == 0:\n        return modular_inverse(a % p, p)\n    else:\n        return (a * (p - 1) % p + p) % p\n\ndef count_modular_inverse(a, p):\n    count = 0\n    for i in range(2, p):\n        if modular_inverse(i, p) == a % p:\n            count += 1\n    return count\n\nprint(count_modular_inverse(3, 7))\n\n\"\"\"\nInput: a = 3, p = 7\nOutput: 2\n\nInput: a = 17, p = 37\nOutput: 4\n\"\"\"",
      -9.6796875
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse/problem\n# https://www.hackerearth.com/practice/algorithms/number-theory/integer-modular-inverse/practice-problems/algorithm/inverse-modular-inverse/\n\ndef modular_inverse(a, p):\n    # if a == p then return 1\n    if a == p:\n        return 1\n    # if a < 0 return 0\n    if a < 0:\n        return 0\n    # for all x:\n    for x in range(2, p):\n        # if (a*x) % p == 1 then return (a*x) / p\n        if (a * x) % p == 1:\n            return (a * x) / p\n        # if (a*x) % p == p-1 then return (a*x) / p\n        if (a * x) % p == p - 1:\n            return (a * x) / p\n        # if (a*x) % p == 0 then return 0\n        if (a * x) % p == 0:\n            return 0\n    # if a == 1 return 1\n    if a == 1:\n        return 1\n    # if a == 0 return 0\n    if a == 0:\n        return 0\n\nprint(modular_inverse(5, 7))",
      -9.7890625
    ],
    [
      "from math import ceil, floor\n\n\ndef modular_inverse(a, p):\n    # If a is even, then p-1 is the modular inverse\n    if a % 2 == 0:\n        return (p - 1) % a\n    # If a is odd, then p-1 is the modular inverse\n    else:\n        return (p - 1 + a) % a\n\n\ndef solve(p, a):\n    # If p is a prime number, then modular inverse of a under p is 1\n    if p == 2 or p == 3:\n        return 1\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 2 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 3 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 5 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 7 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 11 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 13 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 17 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 19 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 23 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 29 == 0:\n        return 0\n    # If p is not a prime number, then modular inverse of a under p is 0\n    elif p % 31 == 0:\n        return 0\n    # If p is not a",
      -10.2421875
    ],
    [
      "class Solution(object):\n    def countModInverse(self, n, p):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if p == 2:\n            return n * (n - 1) / 2\n        if p == 3:\n            return n * (n - 1) / 2 + n * n / 2\n        \n        # p is prime\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        \n        # for 2 * 3, 2 * 3 * 5, 2 * 3 * 5 * 7, 2 * 3 * 5 * 7 * 11, 2 * 3 * 5 * 7 * 11 * 13\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17, 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43\n        \n        # p is prime\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43 * 47\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43 * 47 * 53\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43 * 47 * 53 * 59\n        # for 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43 * 47 * 53 * 59 * 61\n        # for 2",
      -10.2734375
    ],
    [
      "# https://www.hackerearth.com/practice/algorithms/number-theory/modular-inverse/practice-problems/algorithm/modular-inverse/\n# https://www.youtube.com/watch?v=8yTc6mq3cXU\n# https://www.youtube.com/watch?v=zMg5YyLbL7A\n\ndef modular_inverse(a, p):\n    \"\"\"\n    :type a: int\n    :type p: int\n    :rtype: int\n    \"\"\"\n    # p is prime\n    # if p == a % p, then a is not inversed\n    # if p == a % p, then a is inversed\n    # if p is not prime, then a is not inversed\n    # if p is not prime, then a is inversed\n    # a is inversed if a is inversed and p is prime\n    # a is inversed if a is inversed and p is not prime\n    # a is inversed if a is not inversed and p is prime\n    # a is inversed if a is not inversed and p is not prime\n    # a is not inversed if a is not inversed and p is not prime\n    # a is not inversed if a is not inversed and p is prime\n    # a is not inversed if a is not inversed and p is not prime\n    # a is not inversed if a is not inversed and p is prime\n    # a is not inversed if a is not inversed and p is not prime\n    if p % a == 0:\n        return a\n    elif p % a == a % p:\n        return a\n    elif p % a == 0:\n        return a\n    else:\n        return modular_inverse(a, p)\n\nif __name__ == '__main__':\n    print(modular_inverse(11, 11))",
      -10.421875
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @param p, a positive integer\n    # @return a list of integers\n    def modularInverse(self, root, p):\n        if root is None:\n            return []\n        if p % root.val == 0:\n            return []\n        # print 'root', root.val, 'p', p, 'root.val', root.val % p\n        res = self.modularInverse(root.left, p)\n        if p % root.val == 1:\n            res.append(root.val)\n        res.extend(self.modularInverse(root.right, p))\n        return res\n\nroot = TreeNode(3, TreeNode(4, TreeNode(8), TreeNode(7)), TreeNode(5, TreeNode(9), TreeNode(6)))\n# root = TreeNode(3, TreeNode(4, TreeNode(8), TreeNode(7)), TreeNode(5, TreeNode(9), TreeNode(6)))\np = 9\n# print 'root', root.val, 'p', p, 'root.val', root.val % p\nprint Solution().modularInverse(root, p)",
      -10.890625
    ],
    [
      "class Solution(object):\n    def countModInverse(self, arr, p):\n        \"\"\"\n        :type arr: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n = len(arr)\n        m = pow(p, n)\n        ans = 0\n        for i in range(n):\n            if arr[i] % p == 1:\n                ans += 1\n                for j in range(n):\n                    if j!= i and arr[j] % p == arr[i] % p:\n                        ans += (arr[i] % p) * (arr[j] % p) % m\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().countModInverse([1,2,3], 2) == 3\n    assert Solution().countModInverse([2,3,1], 3) == 4\n    assert Solution().countModInverse([4,2,3], 5) == 5\n    assert Solution().countModInverse([3,4,5], 5) == 5\n    assert Solution().countModInverse([1,3,2,1], 5) == 7\n    assert Solution().countModInverse([3,2,1], 5) == 7\n    assert Solution().countModInverse([1,3,2,1], 7) == 7\n    assert Solution().countModInverse([1,1,1,1,1,1,1,1], 7) == 7",
      -11.2421875
    ],
    [
      "# https://leetcode.com/problems/modular-inverse-of-a-n-digit-number/discuss/154417/Python-solution-with-in-time-and-space-complexity\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} m\n    # @return {integer[]}\n    def modularInverse(self, nums, m):\n        nums_inv = self.modularInverse(nums, m)\n        nums_inv.reverse()\n        return nums_inv\n\n    def modularInverse(self, nums, m):\n        nums_inv = [0] * len(nums)\n        for i in range(len(nums)):\n            nums_inv[i] = nums[i] % m\n        return nums_inv\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [3,2,1]\n    print(solution.modularInverse(nums, 3))\n    nums = [2,3,1]\n    print(solution.modularInverse(nums, 3))",
      -11.703125
    ],
    [
      "# The following code is from https://www.hackerearth.com/problem/algorithm/modular-inverse-problem/\n# I have added a small change to use the function find_phi_coeffs() to solve this problem\n# I have also added a check to make sure the input is a valid number.\n\n# In[3]:\n\nimport math\n\ndef modular_inverse_problem(p, x):\n    \"\"\"\n    Given a positive integer p and a positive integer x,\n    return a positive integer with modulus p and modular inverse with modulus p.\n    \"\"\"\n    if p == 1:\n        return x\n    if p == x:\n        return 1\n    m = math.ceil(math.sqrt(p))\n    for i in range(2, m+1):\n        if p % i == 0:\n            if x % i == 0:\n                return (p*x) % (i*m)\n            else:\n                return (p*x) % (i*m)\n    raise Exception(\"The input is not a valid number\")\n\ndef find_phi_coeffs(p, q):\n    \"\"\"\n    Given a prime number p and a composite number q,\n    return a tuple containing (phi(q), phi(p)).\n    \"\"\"\n    if p == q:\n        return (1, 1)\n    if p < q:\n        return find_phi_coeffs(q, p)\n    m = math.ceil(math.sqrt(p))\n    for i in range(2, m+1):\n        if p % i == 0:\n            return (modular_inverse_problem(i, q), modular_inverse_problem(p, q))\n    raise Exception(\"The input is not a valid number\")\n\n# In[ ]:\n\n\n\n# In[ ]:\n\n\n# My Solution\n\n# In[ ]:\n\n\ndef find_phi_coeffs(p, q):\n    \"\"\"\n    Given a prime number p and a composite number q,\n    return a tuple containing (phi(q), phi(p)).\n    \"\"\"\n    if p == q:\n        return (1, 1)\n    if p <",
      -12.171875
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse-count/problem\n#\n# Problem\n#\n# A number is called modulable if it is divisible by the prime number p.\n#\n# A modular inverse is the number m such that p mod m = 1.\n#\n# Given an array of non-negative integers, find the number of elements\n# that have modular inverse under p.\n#\n# Example\n#\n# Input:\n# [2,4,5,6]\n# p = 7\n# Output:\n# 6\n# Explanation:\n# The array has 2, 4, 5, 6, 7.\n# 2, 4, 5 and 6 have modular inverse under 7.\n# 7 has modular inverse under 7.\n#\n# Note\n#\n# The size of the input array will be in range [1, 5000].\n# 1 <= p <= 2^32\n# The modulable number (p mod m) will be in range [1, 2^p - 1]\n# The modulable number (m mod p) will be in range [1, 2^m - 1]\n# The input array will be sorted in ascending order.\n#\n\n# https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Algorithm\ndef modular_inverse(arr, p):\n    return reduce(lambda x, y: x*p+y, arr, 1) % p\n\n# https://www.hackerrank.com/challenges/modular-inverse-count/problem\n#\n# Modular Inverse Count\n#\n# Write a function to count the number of elements having modular inverse under p.\n#\n# Input:\n# p is a positive integer\n# arr is a list of integers\n#\n# Output:\n# A list of integers denoting the number of elements having modular inverse under p.\n#\n# Note\n#\n# The size of the input array will be in range [1, 5000].\n# 1 <= p <= 2^32\n# The modulable number (p mod m) will be in range [1, 2^p - 1]\n# The modulable number (m mod p) will be in range [1, 2^m - 1]\n#",
      -13.1640625
    ],
    [
      "class Solution:\n\t# @param {integer[]} nums\n\t# @param {integer} p\n\t# @return {integer[]}\n\tdef findInverseElements(self, nums, p):\n\t\t# base case\n\t\tif not nums:\n\t\t\treturn []\n\t\t# base case\n\t\tif len(nums) == 1:\n\t\t\treturn [1] if nums[0] % p == 0 else []\n\t\t# base case\n\t\tif len(nums) == 2:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == 0:\n\t\t\treturn [nums[0] % p, 1]\n\t\t# base case\n\t\tif nums[1] % p == 0:\n\t\t\treturn [nums[1] % p, 1]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case\n\t\tif nums[0] % p == nums[1] % p:\n\t\t\treturn [nums[0] % p, nums[1] % p]\n\t\t# base case",
      -13.2265625
    ],
    [
      "# Definition for an array of int.\nclass Array(object):\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n\n    def modular_inverse(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        n = len(self.nums)\n        for i in range(n):\n            res = (res + (self.nums[i] % p) * (p - 1) % p) % p\n        return res\n\nclass Solution(object):\n    def countInverseModular(self, arr, p):\n        \"\"\"\n        :type arr: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        n = len(arr)\n        if n < 3:\n            return 0\n        res = 0\n        for i in range(n):\n            if arr[i] % p == 0:\n                res += 1\n                arr[i] = arr[i] % p\n        return res\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3]\n    arr2 = [2, 2]\n    arr3 = [4, 4, 4]\n    arr4 = [3, 5, 6, 7, 8, 9]\n    arr5 = [6, 7, 8, 9, 10]\n    arr6 = [11, 12, 13]\n    arr7 = [13, 14, 15, 16, 17, 18]\n    arr8 = [16, 17, 18, 19, 20, 21]\n    arr9 = [20, 21, 22]\n    arr10 = [22, 23, 24]\n    arr11 = [25, 26, 27]\n    arr12 = [28, 29, 30]\n    arr13 = [31, 32, 33]\n    arr14 = [34, 35, 36]\n    arr15 = [37, 38, 39]\n    arr16 = [40, 41, 42]\n    arr17 = [43, 44, 45]\n    arr18 = [46, 47, 48, 49, 50]",
      -13.828125
    ],
    [
      "# https://www.hackerrank.com/challenges/modular-inverse\n\ndef modular_inverse(a, p):\n    # Convert to binary number\n    a = str(a)\n    if len(a)!= len(p):\n        return False\n    # Find the last non-zero digit\n    n = len(a)\n    for i in range(n, 0, -1):\n        if a[i]!= '0':\n            n = i\n            break\n    # Convert binary number to decimal\n    a = '0' * (n - 1) + a[n:]\n    # Convert to integer\n    a = int(a)\n    # Modular inverse\n    # If a is zero, return False\n    if a == 0:\n        return False\n    # Find the prime number\n    p = int(p)\n    # If p is not a prime number, return False\n    if p < 2 or p > p**2 or p % 2 == 0:\n        return False\n    # Calculate the modulus\n    m = p\n    # Find the smallest positive integer k\n    while m % 2 == 0:\n        m = m / 2\n    # Find the smallest positive integer k\n    while m % p == 0:\n        m = m / p\n    # Calculate the modular inverse\n    while m % p == 0:\n        m = m / p\n    # Return the modular inverse\n    return m\n\n\ndef main():\n    # Test cases\n    cases = [\n        [7, 7],\n        [7, 13],\n        [23, 23]\n    ]\n\n    # Run each test case\n    for a, b in cases:\n        print 'a = {0}, b = {1}'.format(a, b)\n        assert modular_inverse(a, b) == True, 'Expected True'\n\nif __name__ == '__main__':\n    main()",
      -15.859375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}