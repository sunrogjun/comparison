{
  "problem": {
    "task_id": "MBPP/71",
    "prompt": "Write a function to sort a list of elements using comb sort.",
    "canonical_solution": "def comb_sort(nums):\r\n    shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums",
    "test_list": [
      "assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]",
      "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]",
      "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"
    ],
    "challenge_test_list": [],
    "problem_id": 60
  },
  "model_name": "codegen-2b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def comb_sort(arr, n):\n    \"\"\"\n    Comb sort.\n\n    Time complexity: O(n*log(n))\n    Space complexity: O(1)\n    \"\"\"\n    if n < 2:\n        return arr\n\n    for i in range(n-1):\n        j = i\n        while j > 0 and arr[j] < arr[j-1]:\n            arr[j], arr[j-1] = arr[j-1], arr[j]\n            j -= 1\n        if j == 0:\n            break\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [7, 6, 5, 4, 3, 2, 1]\n    n = len(arr)\n    print(comb_sort(arr, n))",
      3.208984375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort is a simple sorting algorithm that is based on a combination of\n    selection and insertion. The idea is to use the combination of selection\n    and insertion to sort an array in O(n log(n)) time.\n    \"\"\"\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n\nif __name__ == '__main__':\n    arr = [2, 1, 3, 4, 5, 6, 7, 8, 9, 10]\n    comb_sort(arr)\n    print(arr)",
      1.8896484375
    ],
    [
      "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        if not head.next.next:\n            return head\n        \n        cur = head\n        while cur.next.next:\n            cur = cur.next\n            while cur.next and cur.next.next:\n                if cur.next.next.val < cur.next.val:\n                    tmp = cur.next\n                    cur.next = tmp.next\n                    tmp.next = cur.next.next\n                    cur.next.next = tmp\n                else:\n                    break\n        return head",
      1.5673828125
    ],
    [
      "def comb_sort(lst):\n    \"\"\"\n    Input:\n        lst - list of integers\n    Output:\n        the list in sorted order\n    \"\"\"\n    \n    if len(lst) < 2:\n        return lst\n    else:\n        for i in range(len(lst) - 1):\n            temp = lst[i]\n            j = i\n            while j >= 0 and lst[j - 1] > temp:\n                lst[j] = lst[j - 1]\n                j -= 1\n            lst[j] = temp\n    return lst\n\ndef main():\n    lst = [2, 4, 5, 6, 7, 8, 9, 11, 12, 13]\n    print(lst)\n    print(\"\\nSorted: \")\n    print(comb_sort(lst))\n\nif __name__ == \"__main__\":\n    main()",
      1.3876953125
    ],
    [
      "def combSort(list):\n    \"\"\"\n    >>> combSort([4, 6, 1, 2, 7])\n    [1, 2, 4, 6, 7]\n    >>> combSort([1, 2, 4, 6, 7])\n    [1, 2, 4, 6, 7]\n    >>> combSort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    n = len(list)\n    for i in range(n//2):\n        for j in range(n-i-1):\n            if list[j] > list[j+1]:\n                list[j], list[j+1] = list[j+1], list[j]\n    return list\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      0.98046875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        pivot = head\n        n = 1\n        while n < len(head.next.next):\n            pivot = self.comb_sort(pivot, head.next.next)\n            n = n + 1\n        \n        return self.comb_sort(pivot, head.next)\n        \n    def comb_sort(self, head, next_head):\n        if not head or not next_head:\n            return head\n        \n        pivot = head\n        n = 1\n        while n < len(next_head.next):\n            if n % 2 == 0:\n                pivot = self.comb_sort(pivot, next_head.next)\n                n = n + 1\n            else:\n                next_head = next_head.next\n                n = n + 1\n                \n        return pivot",
      0.88134765625
    ],
    [
      "def combSort(array):\n    \"\"\"\n    For each element in array, compare to the first element, and swap if they are different.\n    If they are equal, compare the second element to the first element, and swap if they are different.\n    Repeat this process until array is sorted.\n    :param array: list of integers\n    :return: list of integers\n    \"\"\"\n    def _combSort(array):\n        for i in range(len(array) - 1):\n            if array[i] > array[i + 1]:\n                array[i], array[i + 1] = array[i + 1], array[i]\n                _combSort(array[:i + 2])\n    _combSort(array)\n    return array\n\nif __name__ == \"__main__\":\n    array = [3, 1, 2, 5, 4, 8, 7, 9, 6]\n    array = combSort(array)\n    print(array)",
      0.8271484375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return arr\n\n    for i in range(n):\n        j = i\n        while j > 0 and arr[j-1] > arr[j]:\n            arr[j], arr[j-1] = arr[j-1], arr[j]\n            j -= 1\n    return arr\n\n\ndef main():\n    arr = [10, 12, 14, 8, 6, 1, 5, 3, 7, 9]\n    print comb_sort(arr)\n\nif __name__ == '__main__':\n    main()",
      0.82568359375
    ],
    [
      "def comb_sort(list):\n    \"\"\"\n    Sort a list using the combination sort.\n\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    if not list or len(list) == 1:\n        return list\n    n = len(list)\n    for i in range(n-1):\n        j = i\n        while j > 0 and list[j-1] > list[j]:\n            temp = list[j-1]\n            list[j-1] = list[j]\n            list[j] = temp\n            j -= 1\n    return list\n\n# Test cases\nlist = [1, 4, 2, 7, 3, 6]\nprint(\"Before sorting:\", list)\nprint(\"Sorted using comb sort:\", comb_sort(list))",
      0.81640625
    ],
    [
      "def comb_sort(nums):\n    if len(nums) <= 1:\n        return nums\n    else:\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return nums\n\ndef test():\n    assert comb_sort([3, 4, 5, 1, 2, 6]) == [1, 2, 3, 4, 5, 6]\n    assert comb_sort([6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6]\n    assert comb_sort([1]) == [1]\n    assert comb_sort([]) == []\n    assert comb_sort([7, 5, 3, 2, 1]) == [1, 2, 3, 5, 7]\n    assert comb_sort([-1, -2, -3]) == [-1, -2, -3]\n    assert comb_sort([-1, -2, -3, -4]) == [-1, -2, -3, -4]\n    assert comb_sort([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5]\n\nif __name__ == '__main__':\n    test()",
      0.814453125
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    comb_sort(arr)\n\n    Sorts an array using comb sort.\n\n    Combo sort is a variation of the bubble sort which works by repeatedly\n    swapping adjacent elements.\n\n    Time Complexity - O(n^2)\n    Space Complexity - O(n)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        for i in range(len(arr)):\n            # Bubble sort\n            for j in range(len(arr) - i - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n        return arr\n\n\ndef main():\n    # Test 0: empty list\n    arr = []\n    print(comb_sort(arr))\n\n    # Test 1: single element list\n    arr = [1]\n    print(comb_sort(arr))\n\n    # Test 2: single element list\n    arr = [1]\n    print(comb_sort(arr))\n\n    # Test 3: single element list\n    arr = [1]\n    print(comb_sort(arr))\n\n    # Test 4: multiple element list\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(comb_sort(arr))\n\n\nif __name__ == '__main__':\n    main()",
      0.7587890625
    ],
    [
      "def comb_sort(list_):\n    for i in range(len(list_)):\n        for j in range(i+1, len(list_)):\n            if list_[j] < list_[i]:\n                temp = list_[j]\n                list_[j] = list_[i]\n                list_[i] = temp\n\ndef main():\n    list_ = [5,4,3,2,1,0]\n    comb_sort(list_)\n    for i in range(len(list_)):\n        print(list_[i])\n\nif __name__ == \"__main__\":\n    main()",
      0.3544921875
    ],
    [
      "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        \n        # sort the first half of the array\n        nums[:n/2] = sorted(nums[:n/2])\n        \n        # sort the second half of the array\n        for i in range(1, n/2):\n            if nums[i] < nums[i-1]:\n                nums[i] = nums[i-1]\n            else:\n                nums[i] = nums[i]\n        \n        # sort the last half of the array\n        nums[n/2:] = sorted(nums[n/2:])\n        \n        return\n\na = Solution()\n\nprint(a.sort([2,1,3,5,4,5,6,8,10,7]))",
      -0.039520263671875
    ],
    [
      "def sort_list(lst):\n    \"\"\"\n    Sort the list using comb sort.\n\n    Combsort is a simple way to sort a list of elements using a combination\n    of the element itself and its previous and next elements. The idea is that\n    there are two consecutive elements. The next element is either the next\n    element in the list or the first element in the list.\n    \"\"\"\n    if not lst:\n        return lst\n\n    for i in range(len(lst) - 1):\n        for j in range(len(lst) - 1):\n            if lst[j] > lst[j + 1]:\n                lst[j], lst[j + 1] = lst[j + 1], lst[j]\n\n    return sort_list(lst)\n\nif __name__ == \"__main__\":\n    lst = [6, 2, 5, 3, 1, 4, 7, 8, 9, 10, 11]\n    lst = sort_list(lst)\n    print lst",
      -0.043426513671875
    ],
    [
      "def comb_sort(alist):\n    \"\"\"\n    Sort the elements of alist using comb sort.\n    \"\"\"\n\n    def _comb_sort(alist, left, right):\n        if left >= right:\n            return\n\n        mid = left + (right - left) // 2\n\n        # swap elements at mid\n        alist[left], alist[mid] = alist[mid], alist[left]\n\n        # sort elements on left and right\n        _comb_sort(alist, left + 1, right)\n        _comb_sort(alist, left, mid - 1)\n        _comb_sort(alist, mid + 1, right)\n\n    _comb_sort(alist, 0, len(alist) - 1)\n    return alist\n\n\nif __name__ == \"__main__\":\n    alist = [2, 1, 5, 4, 7, 6, 8, 3]\n    print(alist)\n    print(comb_sort(alist))",
      -0.05426025390625
    ],
    [
      "def comb_sort(a):\n    \"\"\"\n    Sort a list of elements using comb sort.\n    \n    Time Complexity: O(n log n)\n    Space Complexity: O(1)\n    \"\"\"\n    for i in range(len(a)-1):\n        for j in range(i+1, len(a)):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n\n# Your CombSort object will be instantiated and called as such:\n# obj = CombSort(a)\n# obj.sort(a)\n\nif __name__ == \"__main__\":\n    a = [3, 5, 1, 2, 6, 7, 9, 8]\n    comb_sort(a)\n    print a",
      -0.363525390625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Input: an unsorted list of elements.\n    Output: the sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    comb_sort(left)\n    comb_sort(right)\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[j] = left[i]\n            i += 1\n        else:\n            arr[j] = right[j]\n            j += 1\n    arr[j:j + len(left)] = left[i:]\n    return arr\n\n\n#print comb_sort([2,1,3,4,5,6])",
      -0.55322265625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort is a method of sorting that uses the combination of\n    two or more elements to sort the list.\n    Input:\n    The input is a list of integers.\n    Output:\n    The output is a sorted list of integers.\n    Complexity:\n    Time Complexity: O(n log n)\n    Space Complexity: O(1)\n    \"\"\"\n    for i in range(0, len(arr)):\n        for j in range(i, len(arr)):\n            if arr[j] < arr[i]:\n                arr[j], arr[i] = arr[i], arr[j]\n    return arr\n\n\nif __name__ == \"__main__\":\n    print(comb_sort([4, 6, 3, 1, 2, 5, 7, 8, 9, 10]))",
      -0.6083984375
    ],
    [
      "def sort(data):\n    if len(data) <= 1:\n        return data\n    middle = len(data) // 2\n    left = data[:middle]\n    right = data[middle:]\n    left_sorted = sort(left)\n    right_sorted = sort(right)\n    return left_sorted + right_sorted\n\nif __name__ == '__main__':\n    assert sort([1, 3, 5, 2, 4, 7, 9]) == [1, 2, 3, 4, 5, 7, 9]\n    assert sort([1, 3, 5, 2, 4, 7, 9, 5, 4]) == [1, 2, 3, 4, 5, 4, 5, 7, 9]",
      -0.6181640625
    ],
    [
      "def comb_sort(lst):\n    if len(lst) <= 1:\n        return lst\n    mid = len(lst) // 2\n    left = comb_sort(lst[:mid])\n    right = comb_sort(lst[mid:])\n    return left + [lst[i] for i in range(mid, len(lst))] + right\n\nif __name__ == \"__main__\":\n    lst = [1, 5, 3, 4, 2, 8, 6, 7]\n    print(comb_sort(lst))",
      -0.7177734375
    ],
    [
      "def comb_sort(list_of_elements):\n    \"\"\"\n    Input: list_of_elements = [2, 4, 5, 1, 3]\n    Output: list_of_elements = [1, 2, 3, 4, 5]\n    \"\"\"\n    for i in range(1, len(list_of_elements)):\n        for j in range(i):\n            if list_of_elements[j] > list_of_elements[j+1]:\n                temp = list_of_elements[j]\n                list_of_elements[j] = list_of_elements[j+1]\n                list_of_elements[j+1] = temp\n    return list_of_elements\n\nif __name__ == \"__main__\":\n    assert(comb_sort([2, 4, 5, 1, 3]) == [1, 2, 3, 4, 5])\n    assert(comb_sort([3, 2, 1, 5, 4]) == [1, 2, 3, 4, 5])\n    assert(comb_sort([3, 1, 2, 4, 5]) == [1, 2, 3, 4, 5])\n    assert(comb_sort([1, 3, 2, 4, 5]) == [1, 2, 3, 4, 5])",
      -0.77685546875
    ],
    [
      "def sort(list):\n    \"\"\"\n    Input:\n        list: A list of elements.\n\n    Output:\n        A sorted list.\n    \"\"\"\n    n = len(list)\n    if n <= 1:\n        return list\n    mid = n/2\n    left = sort(list[:mid])\n    right = sort(list[mid:])\n    return combine(left, right)\n\ndef combine(left, right):\n    \"\"\"\n    Input:\n        left: A list of elements.\n        right: A list of elements.\n\n    Output:\n        A sorted list.\n    \"\"\"\n    i = 0\n    j = 0\n    k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            list[k] = left[i]\n            i += 1\n        else:\n            list[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        list[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        list[k] = right[j]\n        j += 1\n        k += 1\n    return list",
      -0.77880859375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        while head and head.next:\n            p = head\n            n = head.next\n            while n and n.val < p.val:\n                p = n\n                n = n.next\n            if p == head:\n                break\n            \n            n.next = head\n            head.next = p.next\n            p.next = head\n            \n            head = n\n        return head",
      -0.80859375
    ],
    [
      "def comb_sort(list_of_elements):\n    \"\"\"\n    Input: A list of elements.\n    Output: Sorted list of elements.\n    \"\"\"\n    if len(list_of_elements) <= 1:\n        return list_of_elements\n    else:\n        for i in range(len(list_of_elements) - 1):\n            for j in range(i + 1, len(list_of_elements)):\n                if list_of_elements[j] < list_of_elements[i]:\n                    list_of_elements[i], list_of_elements[j] = list_of_elements[j], list_of_elements[i]\n    return list_of_elements\n\n\nif __name__ == \"__main__\":\n    list_of_elements = [8, 5, 6, 4, 3, 1, 2]\n    print(comb_sort(list_of_elements))",
      -0.8291015625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sort a list using comb sort.\n\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    if len(arr) < 2:\n        return\n\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[i]:\n                arr[i], arr[j] = arr[j], arr[i]",
      -0.85595703125
    ],
    [
      "def comb_sort(list):\n    \"\"\"\n    Sort a list using comb sort.\n    :param list: List of elements\n    :return: Sorted list of elements\n    \"\"\"\n    if len(list) <= 1:\n        return list\n\n    for i in range(len(list)):\n        for j in range(i):\n            if list[i] > list[j]:\n                list[i], list[j] = list[j], list[i]\n\n    return comb_sort(list[:len(list) // 2]) + comb_sort(list[len(list) // 2:])\n\n\nprint(comb_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
      -0.85693359375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort the elements of arr.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n\n    return comb_sort(arr)\n\n\nif __name__ == '__main__':\n    arr = [5, 2, 3, 1, 4, 6]\n    print(arr)\n    print(comb_sort(arr))",
      -0.85693359375
    ],
    [
      "def comb_sort(lst):\n    \"\"\"\n    Sort a list using comb sort.\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i+1]:\n            lst[i], lst[i+1] = lst[i+1], lst[i]\n\n\nif __name__ == '__main__':\n    lst = [2, 1, 4, 3, 5, 6]\n    comb_sort(lst)\n    print(lst)",
      -0.85693359375
    ],
    [
      "import random\n\ndef comb_sort(data_list):\n    for i in range(1, len(data_list)):\n        for j in range(i):\n            if data_list[j] < data_list[j + 1]:\n                data_list[j], data_list[j + 1] = data_list[j + 1], data_list[j]\n\ndef test_comb_sort():\n    data_list = [3, 4, 1, 2, 5]\n    comb_sort(data_list)\n    assert data_list == [1, 2, 3, 4, 5]\n\ndef test_comb_sort_random():\n    data_list = [random.randint(0, 100) for _ in range(100)]\n    comb_sort(data_list)\n    assert data_list == sorted(data_list)\n\nif __name__ == '__main__':\n    test_comb_sort()\n    test_comb_sort_random()",
      -0.85693359375
    ],
    [
      "def comb_sort(nums):\n    for i in range(nums):\n        for j in range(i+1, nums):\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n    return nums\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = comb_sort(nums)\n    print(nums)",
      -0.85693359375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n\n        slow = head\n        fast = head.next\n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n\n        if fast is None:\n            return head\n\n        if fast.next is not None:\n            slow.next = fast.next\n            fast.next = head\n            return self.sortList(slow)\n        else:\n            slow.next = None\n            return self.sortList(head)",
      -0.85693359375
    ],
    [
      "def comb_sort(list):\n    \"\"\"\n    Sort a list using comb sort.\n\n    :type list: List\n    :rtype: void\n    \"\"\"\n    if len(list) < 2:\n        return\n\n    for i in range(len(list) - 1):\n        min_index = i\n        min_value = list[i]\n        for j in range(i + 1, len(list)):\n            if list[j] < min_value:\n                min_index = j\n                min_value = list[j]\n        list[i], list[min_index] = list[min_index], list[i]\n\n    comb_sort(list)",
      -0.85693359375
    ],
    [
      "import random\n\ndef sort_list(elements):\n    \"\"\"\n    elements: a list of elements to be sorted.\n    \"\"\"\n    random.shuffle(elements)\n    for i in range(len(elements) - 1):\n        for j in range(len(elements) - i - 1):\n            if elements[j] > elements[j + 1]:\n                elements[j], elements[j + 1] = elements[j + 1], elements[j]\n    return elements\n\n\nif __name__ == '__main__':\n    elements = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    elements = sort_list(elements)\n    print(elements)",
      -0.85693359375
    ],
    [
      "def combSort(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n    else:\n        mid = len(lst) / 2\n        lst1 = lst[:mid]\n        lst2 = lst[mid:]\n        lst1 = combSort(lst1)\n        lst2 = combSort(lst2)\n        return lst1 + lst2\n\nif __name__ == \"__main__\":\n    lst = [6, 7, 3, 1, 2, 4]\n    print(combSort(lst))",
      -0.85791015625
    ],
    [
      "def comb_sort(a):\n    \"\"\"\n    Sort a list using comb sort.\n\n    :param a: list of integers.\n    :return: sorted list.\n    \"\"\"\n    if len(a) < 2:\n        return a\n    temp = a[:]\n    for i in range(len(a) - 1):\n        for j in range(len(a) - i - 1):\n            if a[j] > a[j + 1]:\n                a[j], a[j + 1] = a[j + 1], a[j]\n    return comb_sort(a)\n\nif __name__ == \"__main__\":\n    a = [9, 6, 3, 1, 2, 8, 5, 7, 4]\n    b = comb_sort(a)\n    print b",
      -0.85791015625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort the given list arr.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    for i in range(len(arr)):\n        # find the largest element in arr[i:len(arr)]\n        max_ind = i\n        for j in range(i+1, len(arr)):\n            if arr[max_ind] <= arr[j]:\n                max_ind = j\n        # swap arr[i] and arr[max_ind]\n        arr[i], arr[max_ind] = arr[max_ind], arr[i]\n        # recursively sort arr[i+1:len(arr)]\n        comb_sort(arr[i+1:len(arr)])\n\n    return arr\n\nif __name__ == '__main__':\n    arr = [1, 3, 2, 5, 4, 6, 7]\n    print(comb_sort(arr))",
      -0.8583984375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    comb_sort(arr)\n\n    Comb sort is a simple sorting algorithm that repeatedly performs\n    insertion sort on subarrays of size 2 until the entire array is sorted.\n\n    Complexity: O(n^2)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i-1]:\n                arr[i-1], arr[i] = arr[i], arr[i-1]\n            else:\n                j = i - 1\n                while j >= 0 and arr[j] > arr[j-1]:\n                    arr[j], arr[j-1] = arr[j-1], arr[j]\n                    j -= 1\n        return arr\n\ndef main():\n    arr = [3, 5, 1, 9, 2, 7, 4, 8, 6]\n    print comb_sort(arr)\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "import unittest\n\n\ndef comb_sort(lst):\n    \"\"\"\n    Sort a list using comb sort.\n    :param lst: List of elements\n    :return: List of elements sorted\n    \"\"\"\n    for i in range(len(lst)):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                lst[j], lst[i] = lst[i], lst[j]\n    return lst\n\n\nclass TestCombSort(unittest.TestCase):\n    def test_comb_sort(self):\n        lst = [3, 1, 2, 4, 5, 8, 9, 7, 6]\n        self.assertEqual(comb_sort(lst), sorted(lst))",
      -0.8583984375
    ],
    [
      "import random\n\ndef comb_sort(arr):\n    \"\"\"\n    Sort a list using comb sort.\n\n    Time complexity: O(n^2)\n    Space complexity: O(1)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        for i in range(len(arr) - 1):\n            j = i + 1\n            while j < len(arr):\n                if arr[j] < arr[i]:\n                    arr[j], arr[i] = arr[i], arr[j]\n                j += 1\n        return arr\n\n\ndef test():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(\"Sorted list: {}\".format(comb_sort(arr)))\n\n\nif __name__ == '__main__':\n    test()",
      -0.8583984375
    ],
    [
      "def comb_sort(array):\n    for i in range(0, len(array)-1):\n        for j in range(i, len(array)):\n            if array[j] < array[j-1]:\n                array[j], array[j-1] = array[j-1], array[j]\n                \n            \n    return array\n\nif __name__ == \"__main__\":\n    array = [2, 5, 6, 3, 1, 4, 7, 8]\n    comb_sort(array)\n    print array",
      -0.8583984375
    ],
    [
      "def combSort(arr):\n    \"\"\"\n    Comb Sort\n\n    Time Complexity: O(n log n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = combSort(arr[:mid])\n    right = combSort(arr[mid:])\n\n    for i in range(len(arr)):\n        arr[i] = left[i]\n        arr[i] = right[i]\n\n    return arr",
      -0.8583984375
    ],
    [
      "import random\n\ndef sort(list):\n    \"\"\"\n    Sort the elements of the list using comb sort.\n    :param list: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    if len(list) <= 1:\n        return list\n    new_list = []\n    for i in range(len(list)):\n        new_list.append(list[i])\n    for i in range(len(list) - 1):\n        new_list.append(sorted(list[i], reverse=True))\n        new_list.append(list[i])\n    return new_list\n\ndef test_sort():\n    \"\"\"\n    Test the sort function.\n    :return: None.\n    \"\"\"\n    list_to_sort = [2, 1, 3, 4, 5, 6, 7, 8, 9]\n    print(\"Sorted list: {}\".format(sort(list_to_sort)))\n\nif __name__ == '__main__':\n    test_sort()",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n        while head and head.next:\n            x = head.val\n            while head.next and head.next.val < x:\n                head = head.next\n            if head.next:\n                x = head.val\n                head = head.next\n            while head.next and head.next.val > x:\n                head = head.next\n            if head.next:\n                x = head.val\n                head = head.next\n            dummy.next = head\n            dummy = dummy.next\n            head = dummy\n        return dummy.next",
      -0.85888671875
    ],
    [
      "def sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    if not arr:\n        return\n    for i in range(1, len(arr)):\n        arr[i], arr[i-1] = arr[i-1], arr[i]\n        for j in range(0, len(arr)-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
      -0.85888671875
    ],
    [
      "def combSort(lst):\n    \"\"\"\n    Input: a list of integers\n    Output: the sorted list\n    \n    Combo sort algorithm\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n    \n    for gap in range(len(lst) - 1):\n        for i in range(gap + 1, len(lst)):\n            if lst[i] < lst[i - gap]:\n                lst[i], lst[i - gap] = lst[i - gap], lst[i]\n    return lst\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5]\n    lst = combSort(lst)\n    print lst",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def combSort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        slow, fast = head, head\n        while fast.next and fast.next.next:\n            slow, fast = slow.next, fast.next.next\n        while fast:\n            tmp = slow.next\n            slow.next = fast\n            fast = tmp\n            tmp = slow.next\n            slow.next = fast.next\n            fast.next = tmp\n        return head",
      -0.85888671875
    ],
    [
      "#!/usr/bin/python\n\ndef print_list(list):\n    for item in list:\n        print item,\n    print\n\ndef comb_sort(list):\n    for i in range(len(list)):\n        for j in range(i):\n            if list[i] < list[j]:\n                list[j], list[i] = list[i], list[j]\n    return list\n\ndef test_comb_sort():\n    list = [5, 3, 4, 2, 1, 6]\n    print_list(list)\n    print comb_sort(list)\n\ntest_comb_sort()",
      -0.85888671875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        if head.next.val < head.val:\n            head.next, head.val = head, head.next\n        while head.next and head.next.val < head.val:\n            temp = head.next\n            head.next, head.val = temp, temp.next\n        return head",
      -0.85888671875
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Input:\n        arr: A list of integers\n    Output:\n        sorted_arr: A sorted list of integers\n    \"\"\"\n    if not arr:\n        return arr\n\n    mid = len(arr) / 2\n    left = [arr[i] for i in range(mid)]\n    right = [arr[i] for i in range(mid, len(arr))]\n    sorted_left = comb_sort(left)\n    sorted_right = comb_sort(right)\n    return sorted_left + sorted_right + arr[mid:]\n\nif __name__ == '__main__':\n    arr = [1, 4, 2, 8, 3, 5, 6, 7]\n    print comb_sort(arr)",
      -0.85888671875
    ],
    [
      "def sort_list(lst):\n    \"\"\"\n    Sort the list using comb sort.\n    \"\"\"\n    i, j = 0, len(lst)-1\n    while i < j:\n        while i < j and lst[i] <= lst[j]:\n            j -= 1\n        lst[i], lst[j] = lst[j], lst[i]\n        while i < j and lst[i] > lst[j]:\n            i += 1\n        lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\n\nif __name__ == '__main__':\n    lst = [1, 4, 7, 9, 2, 5, 8, 0, 3]\n    lst = sort_list(lst)\n    print lst",
      -0.85888671875
    ],
    [
      "def sort(lst):\n    \"\"\"\n    Sort a list using comb sort.\n    \"\"\"\n    for i in range(len(lst)-1):\n        for j in range(i+1, len(lst)):\n            if lst[i] > lst[j]:\n                lst[i], lst[j] = lst[j], lst[i]\n    return lst",
      -0.85888671875
    ],
    [
      "import random\n\n\ndef sort(arr, num):\n    \"\"\"\n    Sorts arr using comb sort.\n    :param arr: Array to be sorted.\n    :param num: Size of array.\n    :return: Sorted array.\n    \"\"\"\n    # TODO: Implement comb sort\n    # TODO: Implement random insertion sort\n    return",
      -0.86083984375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sort a list of elements using comb sort.\n    \"\"\"\n    n = len(arr)\n    for gap in range(n):\n        for i in range(n-gap-1):\n            if arr[i] > arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n    return arr",
      -0.86083984375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        p = head\n        q = head.next\n        while q and q.next:\n            p = self.comb(p, q.next)\n            q = q.next.next\n        p = self.comb(p, q)\n        return p\n        \n    def comb(self, p, q):\n        if not q:\n            return p\n        if not p:\n            return q\n        if p.val < q.val:\n            p.next = self.comb(p.next, q)\n            return p\n        else:\n            q.next = self.comb(p, q.next)\n            return q",
      -1.0693359375
    ],
    [
      "def comb_sort(alist):\n    \"\"\"\n    Sorts the list using combination sort.\n    Time complexity: O(n log n).\n    Space complexity: O(1).\n    \"\"\"\n    for i in range(len(alist)-1):\n        for j in range(len(alist)-i-1):\n            if alist[j] > alist[j+1]:\n                alist[j], alist[j+1] = alist[j+1], alist[j]\n    return alist\n\nif __name__ == \"__main__\":\n    alist = [6, 1, 3, 2, 5, 7, 9]\n    print(comb_sort(alist))",
      -1.0908203125
    ],
    [
      "class Solution:\n    def combSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n        nums.sort()\n        mid = len(nums) // 2\n        for i in range(mid):\n            j = i + 1\n            while j < len(nums):\n                if nums[j] < nums[i]:\n                    nums[i], nums[j] = nums[j], nums[i]\n                j += 1\n        self.combSort(nums[:mid])\n        self.combSort(nums[mid:])\n\ns = Solution()\nnums = [1,2,3]\ns.combSort(nums)\nprint(nums)",
      -1.2265625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    This function sorts an array using the comb sort.\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) / 2\n    left = comb_sort(arr[:mid])\n    right = comb_sort(arr[mid:])\n    res = []\n    i = 0\n    while i < len(left):\n        res.append(left[i])\n        i += 1\n    i = 0\n    while i < len(right):\n        res.append(right[i])\n        i += 1\n    return res\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(arr)\n    print(\"sorted using comb sort: \")\n    print(comb_sort(arr))",
      -1.5380859375
    ],
    [
      "def comb_sort(arr, n):\n    if n <= 1:\n        return arr\n    arr_copy = arr[:]\n    arr_copy.sort()\n    new_arr = arr[:]\n    for i in range(1, n):\n        for j in range(i):\n            if arr_copy[j] > arr_copy[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            else:\n                break\n    return arr_copy\n\ndef main():\n    arr = [6, 5, 7, 4, 9, 1, 3]\n    print(arr)\n    print(comb_sort(arr, len(arr)))\n    print(arr)\n\nif __name__ == '__main__':\n    main()",
      -1.7412109375
    ],
    [
      "class Solution:\n    # @param {ListNode} head\n    # @return {void} Do not return anything, modify the list in-place instead.\n    def sortList(self, head):\n        if head is None or head.next is None:\n            return\n\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # find the middle node\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # swap the middle node with the first node\n        self.swap(slow, head)\n        \n        # sort the sub-list\n        self.sortList(head)\n\n        # swap the middle node with the last node\n        self.swap(slow, head)\n\n    # swap two nodes\n    def swap(self, n1, n2):\n        tmp = n1.next\n        n1.next = n2.next\n        n2.next = tmp\n\n    # get the length of the list\n    def getLength(self, head):\n        if head is None:\n            return 0\n        else:\n            return 1 + self.getLength(head.next)",
      -2.103515625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Args:\n        arr: The list to sort.\n    Returns:\n        The sorted list.\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) / 2\n    left = arr[:mid]\n    right = arr[mid:]\n    comb_sort(left)\n    comb_sort(right)\n    for i in range(mid):\n        arr[i], arr[i + mid] = arr[i + mid], arr[i]\n    return arr\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(arr)\n    comb_sort(arr)\n    print(arr)",
      -2.119140625
    ],
    [
      "from random import shuffle\n\ndef comb_sort(lst):\n    \"\"\"\n    Comb sort is a simple sorting algorithm that is used to sort a list of\n    elements using a combination of insertion sort and selection sort.\n    \"\"\"\n    if len(lst) < 2:\n        return lst\n    \n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if lst[i] > lst[j]:\n                lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\ndef insertion_sort(lst):\n    \"\"\"\n    Insertion sort is a simple sorting algorithm that is used to sort a list of\n    elements by insertion.\n    \"\"\"\n    for i in range(1, len(lst)):\n        j = i - 1\n        while j >= 0 and lst[j] > lst[j + 1]:\n            lst[j + 1], lst[j] = lst[j], lst[j + 1]\n            j = j - 1\n    return lst\n\ndef selection_sort(lst):\n    \"\"\"\n    Selection sort is a simple sorting algorithm that is used to sort a list of\n    elements using the selection sort.\n    \"\"\"\n    for i in range(1, len(lst)):\n        j = i - 1\n        while j >= 0 and lst[j] > lst[i]:\n            lst[j + 1], lst[j] = lst[j], lst[j + 1]\n            j = j - 1\n    return lst\n\ndef main():\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Initial list: {}\".format(lst))\n    print(\"Sorted using comb sort: {}\".format(comb_sort(lst)))\n    print(\"Sorted using insertion sort: {}\".format(insertion_sort(lst)))\n    print(\"Sorted using selection sort: {}\".format(selection_sort(lst)))\n    \n    shuffle(lst)\n    print(\"Sh",
      -2.12890625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort is a sorting algorithm that sorts the elements of an array in\n    place. It is a variation of insertion sort and the elements of the array\n    are rearranged in order of increasing value.\n    :param arr: list of elements\n    :return: None\n    \"\"\"\n    if not arr:\n        return\n\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n\nif __name__ == '__main__':\n    arr = [2, 4, 1, 3, 5, 7, 6]\n    comb_sort(arr)\n    print arr\n    print \"sorted\"\n    arr = [3, 6, 4, 1, 2, 5, 7]\n    comb_sort(arr)\n    print arr",
      -2.29296875
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sort a list using comb sort.\n    :type arr: List[int]\n    :rtype: None\n    \"\"\"\n    if len(arr) < 2:\n        return\n\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[i]:\n                arr[i], arr[j] = arr[j], arr[i]\n\n    comb_sort(arr[:i + 1])\n    comb_sort(arr[i + 1:])",
      -2.4375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort is the fastest sorting algorithm for lists of size 1 to n.\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    else:\n        for i in range(len(arr)):\n            min_val = arr[i]\n            j = i\n            while j > 0 and arr[j - 1] > min_val:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                j -= 1\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [6, 3, 5, 1, 4, 2]\n    print(comb_sort(arr))\n    arr = [6, 5, 3, 1, 4, 2]\n    print(comb_sort(arr))\n    arr = [1, 2, 3, 4, 5, 6]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))\n    arr = [2, 5, 6, 1, 3, 4]\n    print(comb_sort(arr))",
      -2.728515625
    ],
    [
      "from collections import deque\n\n\ndef comb_sort(list_of_elements):\n    \"\"\"\n    Sort the elements using comb sort.\n\n    :param list_of_elements: List of elements to be sorted\n    :return: Sorted list of elements\n    \"\"\"\n    length = len(list_of_elements)\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            if list_of_elements[i] < list_of_elements[j]:\n                list_of_elements[i], list_of_elements[j] = list_of_elements[j], list_of_elements[i]\n    return list_of_elements\n\n\ndef test_comb_sort():\n    \"\"\"\n    Test the comb sort function.\n    \"\"\"\n    test_list = [8, 1, 5, 2, 7, 3, 4, 6]\n    expected_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    assert expected_list == comb_sort(test_list)\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    expected_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    assert expected_list == comb_sort(test_list)\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    expected_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    assert expected_list == comb_sort(test_list)\n\n\ndef test_comb_sort_with_deque():\n    \"\"\"\n    Test the comb sort function with deque.\n    \"\"\"\n    test_list = [8, 1, 5, 2, 7, 3, 4, 6]\n    expected_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    assert expected_list == comb_sort(test_list)\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8]\n    expected_list = [1, 2, 3, 4, 5, 6, 7, 8",
      -2.875
    ],
    [
      "def comb_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    arr = sorted(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[j] < arr[j - 1]:\n                arr[j], arr[j - 1] = arr[j - 1], arr[j]\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [5, 3, 6, 1, 9, 8, 2, 4, 7, 0]\n    print(arr)\n    print(comb_sort(arr))\n    arr = [5, 3, 6, 1, 9, 8, 2, 4, 7, 0]\n    print(arr)\n    print(comb_sort(arr))",
      -2.88671875
    ],
    [
      "def comb_sort(lst):\n    \"\"\"\n    Sort a list using comb sort algorithm.\n\n    :param lst: List of integers.\n    :return: None\n    \"\"\"\n    # Sort is a list of lists.\n    # List of lists is sorted as list of lists.\n    for i in range(len(lst)):\n        # Sort each list.\n        for j in range(len(lst[i])):\n            # Get the element from each list and sort it.\n            # If the element is smaller than the first element in\n            # the list, swap the elements.\n            while lst[i][j] < lst[i][0]:\n                lst[i][0], lst[i][j] = lst[i][j], lst[i][0]\n                # Swap elements.\n                lst[i][j], lst[i][0] = lst[i][0], lst[i][j]\n    # Return the sorted list.\n    return lst\n\nif __name__ == '__main__':\n    lst = [5, 4, 3, 2, 1, 6, 7, 8, 9, 10, 11]\n    # Print the list.\n    print(lst)\n    # Sort the list using comb sort algorithm.\n    lst = comb_sort(lst)\n    # Print the list.\n    print(lst)",
      -3.041015625
    ],
    [
      "def sort(elements):\n    for i in range(len(elements) - 1):\n        for j in range(len(elements) - 1):\n            if elements[j] < elements[j + 1]:\n                elements[j], elements[j + 1] = elements[j + 1], elements[j]\n    return elements\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5], \"1st example\"\n    assert sort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5], \"2nd example\"\n    assert sort([5, 3, 1, 4, 2, 0]) == [0, 1, 2, 3, 4, 5], \"3rd example\"\n    assert sort([-3, -1, -2, -4, -5]) == [-5, -4, -3, -2, -1], \"4th example\"\n    assert sort([-5, -4, -3, -2, -1]) == [-1, -2, -3, -4, -5], \"5th example\"\n    assert sort([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5], \"6th example\"\n    assert sort([]) == [], \"7th example\"\n    assert sort([-4, -3, -2, -1, 0]) == [0, -1, -2, -3, -4], \"8th example\"\n    assert sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1], \"9th example\"",
      -3.138671875
    ],
    [
      "def comb_sort(arr, n):\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(arr)\n    print(\"Sorted using comb sort:\")\n    print(comb_sort(arr, len(arr)))",
      -3.154296875
    ],
    [
      "class CombSort:\n    def sort(self, arr):\n        if len(arr) < 2:\n            return arr\n        pivot = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] < pivot:\n                arr[i], arr[i - 1] = arr[i - 1], arr[i]\n            else:\n                arr[i - 1], arr[i] = arr[i], arr[i - 1]\n        return arr\n\n    def sort_recursive(self, arr, low, high):\n        if low < high:\n            pivot = arr[low]\n            mid = low + ((high - low) >> 1)\n            arr[low], arr[mid] = arr[mid], arr[low]\n            self.sort_recursive(arr, low, mid - 1)\n            self.sort_recursive(arr, mid + 1, high)\n            arr[low], arr[high] = arr[high], arr[low]\n        return arr\n\n    def sort(self, arr):\n        low = 0\n        high = len(arr) - 1\n        arr = self.sort_recursive(arr, low, high)\n        return arr\n\n\nif __name__ == \"__main__\":\n    s = CombSort()\n    arr = [10, 5, 3, 6, 8, 1, 4, 9, 7, 2]\n    print(s.sort(arr))",
      -3.275390625
    ],
    [
      "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/comb-sort/problem\n\ndef sort(a):\n    if not a:\n        return a\n    l = len(a)\n    if l == 1:\n        return a\n    if l == 2:\n        if a[0] > a[1]:\n            a[0], a[1] = a[1], a[0]\n        return a\n    mid = l / 2\n    left = sort(a[:mid])\n    right = sort(a[mid:])\n    for i in range(l):\n        if i < mid:\n            if left[i] < right[i]:\n                a[i], a[mid+i] = a[mid+i], a[i]\n            elif left[i] > right[i]:\n                a[i], a[mid+i] = a[mid+i], a[i]\n        else:\n            if left[i] < right[i]:\n                a[i], a[l-1-i] = a[l-1-i], a[i]\n            elif left[i] > right[i]:\n                a[i], a[l-1-i] = a[l-1-i], a[i]\n    return a\n\n# test cases\n\ndef test_case_1():\n    a = [5, 4, 7, 2, 1, 3, 6, 8]\n    print(\"Test case 1:\", sort(a))\n\ndef test_case_2():\n    a = [0, -1, 1, 2, 3, 4, 5, 6]\n    print(\"Test case 2:\", sort(a))\n\ndef test_case_3():\n    a = [3, 2, 1, 6, 5, 4, 7, 8]\n    print(\"Test case 3:\", sort(a))\n\ndef test_case_4():\n    a = [4, 3, 2, 1, 0]\n    print(\"Test case 4:\", sort(a))\n\ndef test_case_5():\n    a = [2, 1, 4, 3]\n    print(\"Test case 5",
      -3.435546875
    ],
    [
      "from random import randint\n\n\ndef comb_sort(arr):\n    \"\"\"\n    Sorts arr using comb sort.\n\n    Time Complexity: O(n^2)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[j] > arr[i]:\n                arr[j], arr[i] = arr[i], arr[j]\n        if arr[i]!= arr[i-1]:\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n\n    return comb_sort(arr)\n\n\ndef main():\n    \"\"\"\n    For testing\n    \"\"\"\n    arr = [randint(0, 100) for _ in range(100)]\n    print(arr)\n    print(\"sorted: \" + str(comb_sort(arr)))\n    print(\"unsorted: \" + str(arr))\n\n\nif __name__ == \"__main__\":\n    main()",
      -3.513671875
    ],
    [
      "#!/usr/bin/env python\n\nclass Solution(object):\n    def combSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n\n        n = len(nums)\n        for i in range(n-2):\n            for j in range(i+1, n-1):\n                if nums[j] > nums[j+1]:\n                    temp = nums[j+1]\n                    nums[j+1] = nums[j]\n                    nums[j] = temp\n        self.combSort(nums)\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6]\n    Solution().combSort(nums)\n    print(nums)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Solution().combSort(nums)\n    print(nums)",
      -3.57421875
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sorts the list using comb sort.\n    \n    Input:\n        arr: List of integers.\n    Output:\n        None.\n    Explanation:\n        Use a recursive function to sort the list.\n    \"\"\"\n\n    if len(arr) < 2:\n        return arr\n\n    mid = len(arr) // 2\n\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left_sorted = comb_sort(left)\n    right_sorted = comb_sort(right)\n\n    return left_sorted + right_sorted\n\n# Test Cases\n\ndef test_comb_sort_1():\n    \"\"\"\n    Input:\n        [1,2,3,4]\n    Output:\n        [1,2,3,4]\n    Explanation:\n        The input list is already sorted.\n    \"\"\"\n\n    arr = [1,2,3,4]\n    assert comb_sort(arr) == arr\n\n\ndef test_comb_sort_2():\n    \"\"\"\n    Input:\n        [1,2,3,4]\n    Output:\n        [1,2,3,4]\n    Explanation:\n        The input list is already sorted.\n    \"\"\"\n\n    arr = [4,3,2,1]\n    assert comb_sort(arr) == arr\n\n\ndef test_comb_sort_3():\n    \"\"\"\n    Input:\n        [1,2,3,4]\n    Output:\n        [1,2,3,4]\n    Explanation:\n        The input list is already sorted.\n    \"\"\"\n\n    arr = [4,3,2,1]\n    assert comb_sort(arr) == arr\n\n\ndef test_comb_sort_4():\n    \"\"\"\n    Input:\n        [1,2,3,4]\n    Output:\n        [1,2,3,4]\n    Explanation:\n        The input list is already sorted.\n    \"\"\"\n\n    arr = [4,3,2,1]\n    assert comb_sort(arr) == arr\n\n\ndef test_comb_sort_5():\n    \"\"\"\n    Input:",
      -4.1875
    ],
    [
      "from utils import comb_sort\n\n\ndef test_comb_sort():\n    \"\"\"Test comb sort\"\"\"\n    assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert comb_sort([3, 2, 1, 4, 5]) == [3, 1, 2, 4, 5]\n    assert comb_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert comb_sort([5, 4, 3, 2, 1, 8]) == [1, 2, 3, 4, 5, 8]\n    assert comb_sort([3, 2, 1, 4, 5, 8]) == [1, 2, 3, 4, 5, 8]\n    assert comb_sort([1, 2, 3, 4, 5, 8, 7]) == [1, 2, 3, 4, 5, 8, 7]",
      -4.80078125
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if not head or not head.next:\n            return head\n        current = head\n        previous = None\n        while current:\n            next = current.next\n            current.next = previous\n            previous = current\n            current = next\n        current = head\n        while current.next:\n            previous = current\n            current = current.next\n            current.next = previous.next\n            previous.next = None\n            current = self.combSort(current)\n        return current\n\n    def combSort(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        previous = head\n        current = head.next\n        while current:\n            next = current.next\n            current.next = previous\n            previous = current\n            current = next\n        current = head\n        while current:\n            previous = current\n            current = current.next\n            current.next = previous.next\n            previous.next = None\n            current = self.combSort(current)\n        return current",
      -5.04296875
    ],
    [
      "class Solution(object):\n    def combSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) == 1:\n            return\n\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n        self.combSort(nums[:len(nums) // 2])\n        self.combSort(nums[len(nums) // 2:])\n\n\nif __name__ == \"__main__\":\n    nums = [3, 2, 1, 5, 6]\n    Solution().combSort(nums)\n    print(nums)",
      -5.08984375
    ],
    [
      "import sys\nsys.path.append('..')\n\nfrom algorithms.sort_algorithms import CombSort\n\n\ndef comb_sort(arr):\n    \"\"\"\n    Comb sort is a simple sorting algorithm that is used to sort a list of elements\n    in place. It is a variation of the insertion sort that is used when a list\n    has to be sorted in place.\n    \"\"\"\n    arr = list(arr)\n    for i in range(len(arr)):\n        for j in range(i):\n            if arr[j] > arr[i]:\n                arr[j], arr[i] = arr[i], arr[j]\n    return arr\n\n\ndef main():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print(comb_sort(arr))\n\nif __name__ == '__main__':\n    main()",
      -5.1015625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sorting the list using comb sort.\n    :param arr: The list to be sorted.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        for i in range(len(arr) - 1):\n            for j in range(len(arr) - i):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [23, 3, 1, 7, 4, 21, 5, 6, 2, 12, 8, 10, 9, 15, 16, 14, 13, 17]\n    arr = sorted(arr)\n    print(arr)\n    print(\"Sorted using comb sort: \")\n    comb_sort(arr)\n    print(\"Sorted using insertion sort: \")\n    insertion_sort(arr)\n    print(\"Sorted using quick sort: \")\n    quick_sort(arr)",
      -5.6640625
    ],
    [
      "import sys\n\ndef comb_sort(A):\n    \"\"\"\n    A is a list of elements.\n    Return the sorted list.\n    \"\"\"\n    n = len(A)\n    for i in range(n):\n        j = i\n        while j > 0 and A[j - 1] > A[j]:\n            A[j] = A[j - 1]\n            j -= 1\n        A[j] = A[i]\n    return A\n\ndef main():\n    \"\"\"\n    Run the comb sort test.\n    \"\"\"\n    A = [5, 1, 4, 7, 3, 2]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [2, 4, 6, 1, 3, 5]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [1, 2, 3, 4, 5, 6]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(A))\n    print(\"---\")\n    A = [7, 6",
      -5.68359375
    ],
    [
      "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: void\n    \"\"\"\n    def combSort(self, nums):\n        if len(nums) < 2:\n            return\n\n        # first combine\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n            if i > 0 and nums[i] > nums[i - 1]:\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n\n        # now sort\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[j] > nums[i]:\n                    nums[i], nums[j] = nums[j], nums[i]\n            if i > 0 and nums[i] > nums[i - 1]:\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n\n    def sort(self, nums):\n        if len(nums) < 2:\n            return\n        self.combSort(nums)\n\n    def printList(self, nums):\n        for i in range(len(nums)):\n            print(nums[i], end=\" \")\n        print()\n\n    def test(self):\n        nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        self.combSort(nums)\n        self.sort(nums)\n        self.printList(nums)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.test()",
      -5.93359375
    ],
    [
      "from collections import deque\n\n\ndef comb_sort(list):\n    \"\"\"\n    Sorts a list using comb sort.\n    :param list: the list to be sorted\n    :return: the sorted list\n    \"\"\"\n    if not list:\n        return list\n\n    length = len(list)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if list[j] < list[i]:\n                list[j], list[i] = list[i], list[j]\n    return comb_sort(list)\n\n\ndef test_comb_sort():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    list = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n    assert comb_sort(list) == list\n    assert list == [10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n\ndef test_comb_sort_empty_list():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([]) == []\n\n\ndef test_comb_sort_list_with_one_element():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([1]) == [1]\n\n\ndef test_comb_sort_list_with_negative_element():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([-1]) == [-1]\n\n\ndef test_comb_sort_list_with_list_with_negative_element():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([-1, 2]) == [-1, 2]\n\n\ndef test_comb_sort_list_with_list_with_negative_and_positive_element():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([-1, 2, 4]) == [-1, 2, 4]\n\n\ndef test_comb_sort_list_with_list_with_negative_and_positive_and_negative_element():\n    \"\"\"\n    Tests the comb sort function\n    \"\"\"\n    assert comb_sort([-1, 2, 4, -1]) ==",
      -5.94921875
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head is None or head.next is None:\n            return head\n        pivot = head\n        curr = head.next\n        while curr is not None and curr.next is not None:\n            pivot = curr\n            curr = curr.next\n            while curr is not None and curr.val > pivot.val:\n                pivot = curr\n                curr = curr.next\n            pivot.next = curr\n            curr = pivot\n\n        pivot = head\n        curr = head.next\n        while curr is not None:\n            if curr.val < pivot.val:\n                curr.next = pivot.next\n                pivot.next = curr\n            else:\n                pivot.next = curr\n            pivot = curr\n            curr = curr.next\n        return head\n\nhead = ListNode(2)\nhead.next = ListNode(1)\nhead.next.next = ListNode(3)\n\nprint Solution().sortList(head)",
      -7.7265625
    ],
    [
      "def sort(list):\n    \"\"\"\n    Input:\n    list: A list of integers\n\n    Output:\n    A sorted list\n    \"\"\"\n    if len(list) < 2:\n        return list\n\n    mid = len(list) / 2\n\n    left = sort(list[:mid])\n    right = sort(list[mid:])\n\n    return merge(left, right)\n\n\ndef merge(left, right):\n    \"\"\"\n    Input:\n    left: A list of integers\n    right: A list of integers\n\n    Output:\n    A sorted list\n    \"\"\"\n    result = []\n\n    while len(left) > 0 and len(right) > 0:\n        if left[0] < right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n\n    result.extend(left)\n    result.extend(right)\n\n    return result\n\n\ndef test_sort():\n    \"\"\"\n    Test case 1:\n    Input:\n    [1,2,3,4,5,6,7,8,9,10]\n\n    Output:\n    [1,2,3,4,5,6,7,8,9,10]\n    \"\"\"\n    assert sort([1,2,3,4,5,6,7,8,9,10]) == [1,2,3,4,5,6,7,8,9,10]\n\n\ndef test_sort2():\n    \"\"\"\n    Test case 2:\n    Input:\n    [1,2,3,4,5,6,7,8,9,10]\n\n    Output:\n    [1,2,3,4,5,6,7,8,9,10]\n    \"\"\"\n    assert sort([1,2,3,4,5,6,7,8,9,10]) == [1,2,3,4,5,6,7,8,9,10]\n\n\ndef test_sort3():\n    \"\"\"\n    Test case 3:\n    Input:\n    [1,2,3,4,5,6,7,8,9,10]\n\n    Output:\n    [10,9,",
      -8.140625
    ],
    [
      "def comb_sort(alist):\n    \"\"\"\n    Comb sort is an algorithm which sorts a list in ascending order using the\n    following rules:\n\n    1. If the elements are already in ascending order, return the list.\n    2. Split the list into two sublists.\n    3. Recursively sort each sublist.\n    4. Merge the two sublists.\n    \"\"\"\n    def comb_sort_aux(alist, low, high):\n        if low < high:\n            pivot = partition(alist, low, high)\n            comb_sort_aux(alist, low, pivot-1)\n            comb_sort_aux(alist, pivot+1, high)\n            merge(alist, low, pivot-1, pivot, high)\n    def partition(alist, low, high):\n        pivot = alist[high]\n        pivot_index = low\n        for i in range(low, high):\n            if alist[i] < pivot:\n                alist[i], alist[pivot_index] = alist[pivot_index], alist[i]\n                pivot_index += 1\n        alist[pivot_index], alist[high] = alist[high], alist[pivot_index]\n        return pivot_index\n    def merge(alist, low, i, j, high):\n        while low < high:\n            if low == i:\n                low += 1\n            elif high == j:\n                high -= 1\n            else:\n                if alist[low] < alist[high]:\n                    alist[i] = alist[low]\n                    low += 1\n                else:\n                    alist[j] = alist[high]\n                    high -= 1\n    alist = list(alist)\n    comb_sort_aux(alist, 0, len(alist)-1)\n    return alist\n\nalist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(alist)\nprint(comb_sort(alist))",
      -8.34375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        node = head\n        while node.next and node.next.next:\n            node = node.next\n            if node.val < node.next.val:\n                node.next, node.next.next = node.next, node.next.next\n\n        node = head\n        while node:\n            if node.next:\n                node.next.next = node\n                node = node.next\n            else:\n                node.next = None\n                node = node.next\n        return head\n\n\ndef main():\n    solution = Solution()\n\n    head = ListNode(1)\n    head.next = ListNode(3)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(5)\n    head.next.next.next.next = ListNode(4)\n\n    solution.sortList(head)\n    while head.next:\n        print(head.val)\n        head = head.next\n\nif __name__ == '__main__':\n    main()",
      -8.5390625
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Author: Peter Corke\n# Created: Thu Apr  6 16:24:55 2015 -0400\n#\n# Copyright 2015 Peter Corke\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\ndef comb_sort(list):\n    \"\"\"\n    Sort a list using comb sort\n    \"\"\"\n    if len(list) < 2:\n        return list\n\n    pivot = list[0]\n    rest = list[1:]\n\n    pivot_position = 1\n    while pivot_position < len(rest):\n        if rest[pivot_position] <= pivot:\n            pivot_position += 1\n        else:\n            pivot = rest[pivot_position]\n            rest = rest[pivot_position:] + rest[:pivot_position]\n            pivot_position = 1\n\n    rest[0] = pivot\n    return comb_sort(rest)\n\ndef main():\n    \"\"\"\n    Main program\n    \"\"\"\n    test_cases = [\n        ([1,2,3,4,5,6,7,8,9,10],),\n        ([0,0,0,0,0,0,0,0,0,0],),\n        ([5,1,8,2,3,4,6,7,9,10],),\n        ([5,1,8,2,3,4,6,7,9,10],),\n        ([5,1,8,2,3,4,6,7,9,10],),\n        ([5,1,8,2,3,4",
      -9.1484375
    ],
    [
      "def comb_sort(alist):\n    \"\"\"\n    Comb sort is a simple sorting algorithm that uses the idea of moving\n    items from one position to another. The algorithm starts by moving the\n    first element to the end of the list. It then moves the rest of the\n    elements into the correct position, by swapping them with the first\n    element. The first element is then moved to the first position. This\n    process repeats until the list is sorted.\n\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    if len(alist) <= 1:\n        return alist\n    # Create a new list that will hold the sorted list.\n    new_alist = []\n    # Move the first element to the end of the list.\n    new_alist.append(alist[0])\n    # Move the rest of the elements into the correct position.\n    for i in range(1, len(alist)):\n        # Swap the first element with the current element.\n        new_alist.append(alist[i])\n        # Move the first element to the correct position.\n        # We need to do this because we need to move the second\n        # element to the correct position.\n        alist[i], alist[i-1] = alist[i-1], alist[i]\n    # Return the sorted list.\n    return new_alist\n\nif __name__ == '__main__':\n    alist = [2, 4, 8, 6, 7, 5, 3, 1]\n    print(comb_sort(alist))",
      -9.65625
    ],
    [
      "# comb sort\n# 1. sort the list\n# 2. for each element in the list\n# 3. swap the element with the first element\n# 4. swap the element with the second element\n# 5. swap the element with the third element\n# 6. swap the element with the fourth element\n# 7. swap the element with the fifth element\n# 8. swap the element with the sixth element\n# 9. swap the element with the seventh element\n# 10. swap the element with the eighth element\n# 11. swap the element with the ninth element\n# 12. swap the element with the tenth element\n# 13. swap the element with the eleventh element\n# 14. swap the element with the twelfth element\n# 15. swap the element with the thirteenth element\n# 16. swap the element with the fourteenth element\n# 17. swap the element with the fifteenth element\n# 18. swap the element with the sixteenth element\n# 19. swap the element with the seventeenth element\n# 20. swap the element with the eighteenth element\n# 21. swap the element with the nineteenth element\n# 22. swap the element with the nineteenth element\n# 23. swap the element with the twentieth element\n# 24. swap the element with the twenty-first element\n# 25. swap the element with the twenty-second element\n# 26. swap the element with the twenty-third element\n# 27. swap the element with the twenty-fourth element\n# 28. swap the element with the twenty-fifth element\n# 29. swap the element with the twenty-sixth element\n# 30. swap the element with the twenty-seventh element\n# 31. swap the element with the twenty-eighth element\n# 32. swap the element with the twenty-ninth element\n# 33. swap the element with the twenty-tenth element\n# 34. swap the element with the twenty-eleventh element\n# 35. swap the element with the twenty-twelfth element\n# 36. swap the element with the twenty-thirteenth element\n# 37. swap the element with the twenty-fourth element\n# 38. swap the element with the twenty-fifthth element\n# 39. swap the element with the twenty-sixth element\n# 40. swap the element with the twenty-seventh element\n# 41. swap the element with the twenty-eighth element\n# 42.",
      -9.828125
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Input: list of integers\n    Output: sorted list of integers\n    \"\"\"\n    # This function is a recursive solution\n    if len(arr) <= 1:\n        return arr\n    else:\n        # Recursive function\n        mid = len(arr) / 2\n        left_arr = arr[:mid]\n        right_arr = arr[mid:]\n        # Sort the left and right halves\n        left_arr = comb_sort(left_arr)\n        right_arr = comb_sort(right_arr)\n        # Merge the left and right halves\n        return merge(left_arr, right_arr)\n\n# Merge two sorted subarrays\ndef merge(left_arr, right_arr):\n    # Initialize the result array\n    result = [0] * len(left_arr)\n    # Iterate through the left and right subarrays\n    for i in range(0, len(left_arr)):\n        # Iterate through the left and right subarrays\n        for j in range(0, len(right_arr)):\n            # Left subarray is greater, so keep it\n            if left_arr[i] < right_arr[j]:\n                result[i] = left_arr[i]\n                i += 1\n            # Right subarray is greater, so keep it\n            elif left_arr[i] > right_arr[j]:\n                result[i] = right_arr[j]\n                j += 1\n            # Both subarrays are equal, so keep the smaller\n            else:\n                result[i] = left_arr[i]\n                i += 1\n                j += 1\n    # Return the merged result\n    return result\n\n# Test cases\narr = [2, 3, 1, 4, 5, 6]\nprint(comb_sort(arr))\narr = [1, 3, 5, 7, 9, 2]\nprint(comb_sort(arr))\narr = [1, 3, 5, 7, 9, 2, 6, 4, 8, 0]\nprint(comb_sort(arr))\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint",
      -9.8984375
    ],
    [
      "from collections import defaultdict\n\ndef sort(a):\n    \"\"\"\n    Sort a list of elements using comb sort.\n    \"\"\"\n    if len(a) <= 1:\n        return a\n\n    new_list = defaultdict(int)\n    for e in a:\n        new_list[e] += 1\n\n    sorted_list = []\n    for k in sorted(new_list):\n        sorted_list.append(new_list[k])\n\n    new_list = defaultdict(int)\n    for e in sorted_list:\n        new_list[e] += 1\n\n    sorted_list = []\n    for k in sorted(new_list):\n        sorted_list.append(new_list[k])\n\n    return sorted_list\n\nif __name__ == '__main__':\n    print(sort([1, 3, 4, 5, 6, 7]))",
      -10.390625
    ],
    [
      "from collections import deque\n\ndef comb_sort(arr):\n    \"\"\"\n    Sorting algorithm:\n    1. Build a sorted array.\n    2. Compare the first element in the array with the next element in the array.\n    3. If the first element is smaller than the next element, swap the elements.\n    4. Otherwise, go to step 2.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        # Build a sorted array.\n        sorted_arr = [arr[0]]\n        for i in range(1, len(arr)):\n            if arr[i-1] > arr[i]:\n                sorted_arr.append(arr[i])\n        return comb_sort(sorted_arr)\n\n\ndef main():\n    arr = [8, 7, 6, 5, 4, 3, 2, 1]\n    print(comb_sort(arr))\n\n\nif __name__ == '__main__':\n    main()",
      -10.46875
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sort a list using comb sort algorithm.\n\n    :param arr: List of integers\n    :return: None\n    \"\"\"\n\n    # Base case\n    if len(arr) <= 1:\n        return\n\n    # Create a new list\n    new_list = [arr[0]]\n\n    # Get the second element in the original list and start from there\n    for i in range(1, len(arr)):\n        # Get the second element in the original list and start from there\n        # Get the element from the original list which is greater than the current element\n        # and insert it in the new list\n        while arr[i] > arr[i - 1]:\n            # Get the element from the original list which is greater than the current element\n            # and insert it in the new list\n            new_list.insert(0, arr[i])\n\n        # Insert the element into the new list\n        new_list.insert(0, arr[i - 1])\n\n        # Swap the elements\n        arr[i - 1], arr[i] = arr[i], arr[i - 1]\n\n    # Copy the new list into the original list\n    arr[:] = new_list\n\n\nif __name__ == '__main__':\n    arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    comb_sort(arr)\n    print arr",
      -10.9375
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Comb sort is the simplest sorting algorithm.\n    It sorts the array by recursively sorting each subarray\n    and then combining the subarrays.\n    The complexity of comb sort is O(n2)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n    return comb_sort(arr[:]) + arr[:]\n\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 7, 6, 8, 4]\n    print comb_sort(arr)",
      -11.140625
    ],
    [
      "def comb_sort(arr):\n    \"\"\"\n    Sorts arr using comb sort.\n\n    Combo sort is a sort which is an interleaving of the smaller elements\n    in the array to the end of the array. The smaller elements are placed\n    in the front of the array and the larger elements are placed in the\n    end of the array.\n\n    Combo sort is one of the most efficient sorting algorithms. The\n    algorithm runs in time proportional to the size of the input\n    array and the number of comparisons.\n\n    Example:\n        Input: [1, 3, 5, 7, 8, 9]\n        Output: [1, 3, 5, 7, 8, 9]\n\n    Combo sort is a variation of insertion sort.\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    for i in range(len(left)):\n        curr = left[i]\n        for j in range(len(right)):\n            if curr < right[j]:\n                right[j - 1] = right[j]\n            else:\n                right[j - 1] = curr\n                break\n\n    for i in range(len(right)):\n        curr = right[i]\n        for j in range(len(left)):\n            if curr < left[j]:\n                left[j + 1] = left[j]\n            else:\n                left[j + 1] = curr\n                break\n\n    return left + right\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 7, 8, 9]\n    print(arr)\n    print(comb_sort(arr))",
      -11.296875
    ],
    [
      "def comb_sort(lst):\n    \"\"\"\n    >>> comb_sort([1,2,3,4,5,6])\n    [1, 2, 3, 4, 5, 6]\n    >>> comb_sort([1,6,4,5,2,3])\n    [1, 2, 3, 4, 5, 6]\n    >>> comb_sort([1,5,6,4,3,2])\n    [1, 2, 3, 4, 5, 6]\n    >>> comb_sort([3,5,4,6,2,1])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    length = len(lst)\n    if length <= 1:\n        return lst\n    mid = length/2\n    left = comb_sort(lst[:mid])\n    right = comb_sort(lst[mid:])\n    for i in range(length):\n        lst[i] = left[i]\n    for i in range(length):\n        lst[i] = right[i]\n    return lst\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -12.9609375
    ],
    [
      "from random import randint\n\n\ndef comb_sort(arr):\n    \"\"\"\n    Comb sort algorithm.\n\n    For each iteration, the array is split into two parts. The first part is\n    sorted using the next element in the array as the pivot. The second part\n    is sorted using the first element in the array as the pivot. The elements\n    in the first part are then sorted using the next element in the second\n    part as the pivot. The new pivot is then used to reorder the second part.\n    The second part is then sorted using the next element in the first part as\n    the pivot. This continues until the first part is empty.\n\n    Input: arr = [2, 4, 1, 3]\n    Output: [1, 2, 3, 4]\n\n    Input: arr = [2, 4, 1, 3, 6, 5, 9, 8]\n    Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Input: arr = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Input: arr = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n    Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    \"\"\"\n    if len(arr) < 2:\n        return arr\n    arr = list(arr)\n    pivot = randint(1, len(arr) - 1)\n    arr.insert(pivot, arr[0])\n    arr.insert(0, arr[pivot])\n    arr = arr[:len(arr) - 1]\n    arr.sort()\n    arr = arr[:len(arr) - 1]\n    arr.append(arr[0])\n    arr.sort()\n    return arr\n\n\ndef main():\n    arr = [2, 4, 1, 3]\n    print(arr)",
      -13.921875
    ],
    [
      "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nSort a list of integers using comb sort\n\nCombo sort is an algorithm that sorts a list of elements using the idea that\nelements that are commonly adjacent in the list are grouped together in a\nlinear order.\n\nCombo sort is a simple linear sorting algorithm, but it can be extended to\nrecursively sort sublists of the list, and to sort lists of different sizes.\n\nCombo sort is also known as the \"shuffling sort\".\n\nCombo sort is an O(n log n) algorithm.\n\nTime Complexity:\n- O(n log n) for sorting\n\"\"\"\n\n# TODO:\n# - add a sort for a list of integers\n# - add a sort for a list of strings\n\nimport time\n\n\ndef comb_sort(list):\n    \"\"\"\n    Sort a list using comb sort\n    \"\"\"\n    if len(list) < 2:\n        return list\n    mid = len(list) // 2\n    left = comb_sort(list[:mid])\n    right = comb_sort(list[mid:])\n    return sort_helper(list, left, right)\n\n\ndef sort_helper(list, left, right):\n    if left == right:\n        return list\n    if left > right:\n        return right + left * (right + left) // 2\n    return sort_helper(list[left:right], left, right - 1)\n\n\ndef test_comb_sort():\n    \"\"\"\n    Test the comb sort function\n    \"\"\"\n    assert sorted(range(10)) == range(10)\n    assert sorted(range(10)) == range(10)\n    assert sorted(range(10)) == range(10)\n    assert sorted(range(9, -1, -1)) == range(9, -1, -1)\n    assert sorted(range(9, -1, -1)) == range(9, -1, -1)\n    assert sorted(range(9, -1, -1)) == range(9, -1, -1)\n    assert sorted(range(10, -1, -1)) == range(10, -1, -1)",
      -14.5859375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n    def combSort(self, head):\n        if head is None or head.next is None:\n            return head\n        \n        if head.next is None:\n            return head\n        \n        curr = head\n        next = head.next\n        while next is not None:\n            curr.next = None\n            while next is not None:\n                if next.next is None:\n                    break\n                \n                next = next.next\n                if next.next is None:\n                    break\n                \n                next.next = curr\n                curr = next\n            \n            next = next.next\n            if next is None:\n                break\n            \n            curr.next = next\n            next = next.next\n            \n        return head\n\nif __name__ == \"__main__\":\n    head = ListNode(2)\n    head.next = ListNode(1)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    \n    print Solution().combSort(head)",
      -14.7734375
    ],
    [
      "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        if not head.next:\n            return head\n        n = head.next\n        while n:\n            n_p = n\n            n = n.next\n            while n and n_p:\n                if n_p.val < n.val:\n                    n_p.next = n\n                    n = n_p\n                else:\n                    n_p.next = n.next\n                    n.next = n_p\n                    n = n_p.next\n            if n:\n                n_p.next = n\n                n = n_p\n            head = n\n        return head",
      -15.265625
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}