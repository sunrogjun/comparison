{
  "problem": {
    "task_id": "MBPP/297",
    "prompt": "Write a function to flatten a given nested list structure.",
    "canonical_solution": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ",
    "test_list": [
      "assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]",
      "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]",
      "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"
    ],
    "challenge_test_list": [],
    "problem_id": 286
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def flatten(nested_list):\n    \"\"\"\n    :param nested_list: nested list structure\n    :return: flattened list\n    \"\"\"\n    flattened = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flattened.extend(flatten(element))\n        else:\n            flattened.append(element)\n\n    return flattened\n\n\ndef test_flatten():\n    assert flatten([1, [2, 3], [4, [5, 6]]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([1, [2, 3, [4, 5, [6]]]]) == [1, 2, 3, 4, 5, 6]\n\n\nif __name__ == '__main__':\n    test_flatten()",
      14.6953125
    ],
    [
      "# The output should be as follows:\n# flatten([1, 2, [3, 4], [5, [6, 7], 8], 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# def flatten(lst):\n#     flat = []\n#     for i in lst:\n#         if type(i) == list:\n#             flat.extend(flatten(i))\n#         else:\n#             flat.append(i)\n#     return flat\n\n\n# def flatten(lst):\n#     flat = []\n#     for i in lst:\n#         flat.extend(flatten(i) if type(i) == list else [i])\n#     return flat\n\n\ndef flatten(lst):\n    return sum([flatten(x) if type(x) == list else [x] for x in lst], [])\n\n\nprint(flatten([1, 2, [3, 4], [5, [6, 7], 8], 9]))",
      13.9921875
    ],
    [
      "from typing import List, Any\n\n\ndef flatten(input_list: List[Any]) -> List[Any]:\n    \"\"\"\n    Flatten a list.\n    \"\"\"\n    result = []\n\n    for item in input_list:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n\n    return result\n\n\ndef main():\n    \"\"\"\n    Test\n    \"\"\"\n    list1 = [1, 2, [3, 4, [5, 6, [7, 8, [9]]]]]\n    list2 = [1, 2, [3, 4, [5, 6, [7, 8, [9]]]]]\n    assert flatten(list1) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert flatten(list2) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nif __name__ == \"__main__\":\n    main()",
      13.390625
    ],
    [
      "def flatten(input_list):\n    result = []\n    for element in input_list:\n        if type(element) is list:\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\ndef flatten_2(input_list):\n    result = []\n    for element in input_list:\n        if type(element) is list:\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\nprint(flatten([1, 2, [3, 4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))\nprint(flatten([[1, 2, 3], [4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))\nprint(flatten([[[1, 2, 3], 4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))\nprint(flatten_2([1, 2, [3, 4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))\nprint(flatten_2([[1, 2, 3], [4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))\nprint(flatten_2([[[1, 2, 3], 4, 5, [6, 7, 8, [9, 10, 11], 12], 13], 14]))",
      10.6171875
    ],
    [
      "def flatten(lst):\n    # Time: O(n)\n    # Space: O(n)\n    if not lst:\n        return lst\n    if not isinstance(lst, list):\n        return [lst]\n    return flatten(lst[0]) + flatten(lst[1:])\n\n\ndef flatten_iterative(lst):\n    # Time: O(n)\n    # Space: O(n)\n    if not lst:\n        return lst\n    if not isinstance(lst, list):\n        return [lst]\n    return list(iter_flatten(lst))\n\n\ndef iter_flatten(lst):\n    if not lst:\n        return\n    if not isinstance(lst, list):\n        yield lst\n        return\n    for i in lst:\n        for j in iter_flatten(i):\n            yield j\n\n\nassert flatten([1, 2, [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]\nassert flatten_iterative([1, 2, [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]\nassert flatten([1, [2, [3, [4, [5, [6]]]]]]) == [1, 2, 3, 4, 5, 6]\nassert flatten_iterative([1, [2, [3, [4, [5, [6]]]]]]) == [1, 2, 3, 4, 5, 6]",
      10.140625
    ],
    [
      "from typing import List\n\n\n# Time complexity: O(n) where n is the number of elements in the list\n# Space complexity: O(n) where n is the number of elements in the list\ndef flatten_list(list_to_flatten: List[List[int]]) -> List[int]:\n    if not list_to_flatten:\n        return []\n    result = []\n\n    for item in list_to_flatten:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n\n\n# Time complexity: O(n) where n is the number of elements in the list\n# Space complexity: O(n) where n is the number of elements in the list\ndef flatten_list2(list_to_flatten: List[List[int]]) -> List[int]:\n    if not list_to_flatten:\n        return []\n    result = []\n\n    for item in list_to_flatten:\n        if isinstance(item, list):\n            result.extend(flatten_list2(item))\n        else:\n            result.append(item)\n    return result\n\n\nif __name__ == \"__main__\":\n    # Test 1\n    print(flatten_list([1, 2, 3, 4, 5, [1, 2, [1, 2]], 6, 7, 8]))\n    # Test 2\n    print(flatten_list2([1, 2, 3, 4, 5, [1, 2, [1, 2]], 6, 7, 8]))",
      9.09375
    ],
    [
      "def flatten(items):\n    flat = []\n\n    for i in items:\n        if type(i) == list:\n            flat.extend(flatten(i))\n        else:\n            flat.append(i)\n\n    return flat\n\n\nif __name__ == '__main__':\n    items = [[1, 2, 3], [4, [5], 6], 7, [8, 9]]\n    print(flatten(items))",
      5.2421875
    ],
    [
      "def flatten(l):\n    \"\"\"\n    :type l: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for item in l:\n        if item.isInteger():\n            result.append(item.getInteger())\n        else:\n            result.extend(flatten(item.getList()))\n    return result\n\n\nif __name__ == '__main__':\n    print(flatten([[1, 1], [2, 2], [3, [3, 3]]]))",
      3.9296875
    ],
    [
      "class Solution(object):\n    def flatten(self, lst):\n        \"\"\"\n        :type lst: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        return self.flatten_helper(lst)\n\n    def flatten_helper(self, lst):\n        if not lst:\n            return lst\n        result = []\n        for ele in lst:\n            if ele.isInteger():\n                result.append(ele.getInteger())\n            else:\n                result.extend(self.flatten_helper(ele.getList()))\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    lst = [\n        [1, [2, [3, [4, [5, [6, [7]]]]]]]\n    ]\n    print s.flatten(lst)",
      3.927734375
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        self.stack = [[nestedList, 0]]\n\n    def next(self):\n        self.hasNext()\n        nestedList, i = self.stack[-1]\n        self.stack[-1][1] += 1\n        return nestedList[i].getInteger()\n\n    def hasNext(self):\n        s = self.stack\n        while s:\n            nestedList, i = s[-1]\n            if i == len(nestedList):\n                s.pop()\n            else:\n                x = nestedList[i]\n                if x.isInteger():\n                    return True\n                s[-1][1] += 1\n                s.append([x.getList(), 0])\n        return False\n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())",
      3.591796875
    ],
    [
      "class Solution(object):\n    def flatten(self, l):\n        \"\"\"\n        :type l: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        # \u9012\u5f52\n        # if not l:\n        #     return []\n        # if l.isInteger():\n        #     return [l.getInteger()]\n        # else:\n        #     return self.flatten(l.getList()) + self.flatten(l.getList())\n\n        # \u8fed\u4ee3\n        if not l:\n            return []\n        stack = l[::-1]\n        res = []\n        while stack:\n            cur = stack.pop()\n            if cur.isInteger():\n                res.append(cur.getInteger())\n            else:\n                stack += cur.getList()[::-1]\n        return res",
      3.208984375
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\n\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        def flatten(nl):\n            for item in nl:\n                if item.isInteger():\n                    yield item.getInteger()\n                else:\n                    yield from flatten(item.getList())\n        self.list = list(flatten(nestedList))\n\n    def next(self) -> int:\n        return self.list.pop(0)\n\n    def hasNext(self) -> bool:\n        return len(self.list) > 0\n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())",
      2.109375
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, lst: List[int]) -> List[int]:\n        def dfs(l: List[int]):\n            if isinstance(l, int):\n                return [l]\n            else:\n                ret = []\n                for el in l:\n                    ret.extend(dfs(el))\n                return ret\n\n        return dfs(lst)\n\n\nif __name__ == '__main__':\n    lst = [[1,1],2,[1,1]]\n    ans = Solution().flatten(lst)\n    print(ans)",
      2.046875
    ],
    [
      "def flatten(l: list) -> list:\n    \"\"\"\n    >>> flatten([1,2,[3,4,[5,6],7],8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> flatten([1,2,[3,4,[5,6],7],8,[10,11]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]\n    >>> flatten([[1,2,[3,4,[5,6],7],8],[[10,11]]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]\n    >>> flatten([1,2,[3,4,[5,6],7],8,[10,11]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]\n    \"\"\"\n    if not isinstance(l, list):\n        return [l]\n    else:\n        return [item for sublist in l for item in flatten(sublist)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.767578125
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\nclass Solution:\n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        def flatten_helper(nestedList, flattened_list):\n            for item in nestedList:\n                if item.isInteger():\n                    flattened_list.append(item.getInteger())\n                else:\n                    flatten_helper(item.getList(), flattened_list)\n\n        flattened_list = []\n        flatten_helper(nestedList, flattened_list)\n        return flattened_list",
      1.685546875
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\n\ndef flatten(x: NestedInteger) -> List[int]:\n    if x.isInteger():\n        return [x.getInteger()]\n    else:\n        return sum([flatten(i) for i in x.getList()], [])",
      1.6826171875
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\nclass Solution:\n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        if not nestedList:\n            return\n\n        stack = nestedList[::-1]\n        while stack:\n            item = stack.pop()\n            if item.isInteger():\n                nestedList.append(item)\n            else:\n                stack.extend(item.getList()[::-1])\n\n        nestedList.remove(nestedList[0])",
      1.64453125
    ],
    [
      "class Solution(object):\n    def flatten(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not input:\n            return []\n        res = []\n        self.flatten_helper(input, res)\n        return res\n\n    def flatten_helper(self, input, res):\n        if isinstance(input, list):\n            for item in input:\n                self.flatten_helper(item, res)\n        else:\n            res.append(input.getInteger())",
      1.4404296875
    ],
    [
      "def flatten(nested_list):\n    \"\"\"\n    :param nested_list: list\n    :return: list\n    \"\"\"\n    return flatten_helper(nested_list)\n\n\ndef flatten_helper(nested_list):\n    \"\"\"\n    :param nested_list: list\n    :return: list\n    \"\"\"\n    if isinstance(nested_list, list):\n        nested_list = [flatten_helper(item) for item in nested_list]\n    return nested_list\n\n\ndef flatten_helper_2(nested_list):\n    \"\"\"\n    :param nested_list: list\n    :return: list\n    \"\"\"\n    if isinstance(nested_list, list):\n        nested_list = [item for sublist in nested_list for item in flatten_helper_2(sublist)]\n    return nested_list\n\n\ndef flatten_helper_3(nested_list):\n    \"\"\"\n    :param nested_list: list\n    :return: list\n    \"\"\"\n    if isinstance(nested_list, list):\n        nested_list = flatten_helper_3(nested_list[0]) + flatten_helper_3(nested_list[1:])\n    return nested_list\n\n\ndef main():\n    print(flatten([1, 2, 3, [4, [5, 6], 7], 8]))\n    print(flatten_helper([1, 2, 3, [4, [5, 6], 7], 8]))\n    print(flatten_helper_2([1, 2, 3, [4, [5, 6], 7], 8]))\n    print(flatten_helper_3([1, 2, 3, [4, [5, 6], 7], 8]))\n\n\nif __name__ == \"__main__\":\n    main()",
      1.384765625
    ],
    [
      "def flatten(nested_list):\n    \"\"\"\n    >>> flatten([1, 2, 3, [4, [5, 6], 7], 8, [9, 10], 11])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    >>> flatten([[[1], [2, 3]], 4])\n    [1, 2, 3, 4]\n    >>> flatten([1, 2, 3, [[[4]], 5, 6, 7], 8, [9, 10], 11])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    \"\"\"\n    flattened_list = []\n\n    def flatten_helper(lst):\n        for element in lst:\n            if isinstance(element, list):\n                flatten_helper(element)\n            else:\n                flattened_list.append(element)\n\n    flatten_helper(nested_list)\n    return flattened_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.70654296875
    ],
    [
      "def flatten(input_list):\n    return _flatten(input_list)\n\ndef _flatten(input_list):\n    result = []\n    for element in input_list:\n        if isinstance(element, list):\n            result.extend(_flatten(element))\n        else:\n            result.append(element)\n    return result\n\ndef flatten_2(input_list):\n    result = []\n    for element in input_list:\n        if isinstance(element, list):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\nif __name__ == '__main__':\n    print(flatten([1, 2, [3, [4, 5], 6], [7, 8], 9]))\n    print(flatten_2([1, 2, [3, [4, 5], 6], [7, 8], 9]))",
      0.70263671875
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        def helper(lst):\n            out = []\n            for item in lst:\n                if item.isInteger():\n                    out.append(item.getInteger())\n                else:\n                    out += helper(item.getList())\n            return out\n        return helper(nestedList)",
      0.5087890625
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n    def isInteger(self) -> bool:\n        \"\"\"\n        @return True if this NestedInteger holds a single integer, rather than a nested list.\n        \"\"\"\n\n    def getInteger(self) -> int:\n        \"\"\"\n        @return the single integer that this NestedInteger holds, if it holds a single integer\n        Return None if this NestedInteger holds a nested list\n        \"\"\"\n\n    def getList(self) -> [NestedInteger]:\n        \"\"\"\n        @return the nested list that this NestedInteger holds, if it holds a nested list\n        Return None if this NestedInteger holds a single integer\n        \"\"\"\n\n\ndef flatten(nestedList: [NestedInteger]) -> [int]:\n    result = []\n    for nested in nestedList:\n        if nested.isInteger():\n            result.append(nested.getInteger())\n        else:\n            result.extend(flatten(nested.getList()))\n    return result\n\n\ndef main():\n    print(flatten([1, [2], [[3]]]))\n\n\nif __name__ == '__main__':\n    main()",
      -0.46728515625
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, l: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify l in-place instead.\n        \"\"\"\n        if not l:\n            return\n\n        stack = [l]\n        while stack:\n            head = stack.pop()\n            if isinstance(head, list):\n                for i, e in enumerate(head):\n                    stack.append(e)\n            else:\n                l.append(head)\n\n\nif __name__ == \"__main__\":\n    l = [1, 2, [1, [5, 6], 3, 4], 5]\n    Solution().flatten(l)\n    print(l)",
      -0.57568359375
    ],
    [
      "from functools import reduce\n\n\ndef flatten(lists):\n    return reduce(lambda x, y: x + y, lists, [])\n\n\nprint(flatten([[1, [2], [3, [[[4]]]]], 5, 6, [7, [[[8]]]]]))",
      -0.65234375
    ],
    [
      "def flatten(lst):\n    if not lst:\n        return lst\n    if not isinstance(lst[0], list):\n        return [lst[0]] + flatten(lst[1:])\n    return flatten(lst[0]) + flatten(lst[1:])\n\n\ndef flatten_recursive(lst):\n    if not lst:\n        return lst\n    if not isinstance(lst[0], list):\n        return [lst[0]] + flatten_recursive(lst[1:])\n    return flatten_recursive(lst[0]) + flatten_recursive(lst[1:])",
      -0.71826171875
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n    def __init__(self, value=None):\n        self.value = value\n\n    def isInteger(self):\n        \"\"\"\n        @return True if this NestedInteger holds a single integer, rather than a nested list.\n        :rtype bool\n        \"\"\"\n\n    def getInteger(self):\n        \"\"\"\n        @return the single integer that this NestedInteger holds, if it holds a single integer\n        Return None if this NestedInteger holds a nested list\n        :rtype int\n        \"\"\"\n\n    def getList(self):\n        \"\"\"\n        @return the nested list that this NestedInteger holds, if it holds a nested list\n        Return None if this NestedInteger holds a single integer\n        :rtype List[NestedInteger]\n        \"\"\"\n\n\nclass Solution:\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: void Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n\n        def flatten_list(nested_list):\n            for item in nested_list:\n                if item.isInteger():\n                    yield item.getInteger()\n                else:\n                    for num in flatten_list(item.getList()):\n                        yield num\n\n        nestedList[:] = list(flatten_list(nestedList))",
      -0.73388671875
    ],
    [
      "from typing import List\n\n\ndef flatten(lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    >>> flatten([[1, 1], [2, 2], [3, 3]])\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    result = []\n\n    for l in lists:\n        for e in l:\n            if isinstance(e, list):\n                result.extend(flatten(e))\n            else:\n                result.append(e)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8115234375
    ],
    [
      "def flatten(l):\n    \"\"\"\n    :type l: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    if isinstance(l, int):\n        return [l]\n    else:\n        result = []\n        for item in l:\n            result.extend(flatten(item.getInteger()))\n        return result",
      -0.85595703125
    ],
    [
      "def flatten(lst):\n    result = []\n    for ele in lst:\n        if type(ele) is list:\n            result.extend(flatten(ele))\n        else:\n            result.append(ele)\n    return result\n\n\nif __name__ == \"__main__\":\n    lst = [1, 2, [3, [4, 5], 6, 7], 8]\n    print(flatten(lst))",
      -0.85595703125
    ],
    [
      "class Solution(object):\n    def flatten(self, input_list):\n        \"\"\"\n        :type input_list: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if input_list is None:\n            return None\n        result = []\n        self.flatten_helper(input_list, result)\n        return result\n\n    def flatten_helper(self, input_list, result):\n        for item in input_list:\n            if item.isInteger():\n                result.append(item.getInteger())\n            else:\n                self.flatten_helper(item.getList(), result)",
      -0.85693359375
    ],
    [
      "class Solution():\n    def flatten(self, nested_list):\n        \"\"\"\n        :type nested_list: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not nested_list:\n            return []\n        result = []\n        for i in nested_list:\n            if i.isInteger():\n                result.append(i.getInteger())\n            else:\n                result.extend(self.flatten(i.getList()))\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nested_list = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]\n    print(s.flatten(nested_list))",
      -0.85693359375
    ],
    [
      "def flatten(lst):\n    if not isinstance(lst, list):\n        return [lst]\n    return [item for sublist in lst for item in flatten(sublist)]\n\n\nif __name__ == \"__main__\":\n    print(flatten([1, [2, 3], [4, [5, 6], 7], 8]))",
      -0.85693359375
    ],
    [
      "def flatten(l):\n    result = []\n    for i in l:\n        if type(i) is list:\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result\n\n\nif __name__ == \"__main__\":\n    l = [1, 2, [3, [4, [5]]]]\n    print(flatten(l))",
      -0.85693359375
    ],
    [
      "def flatten(input):\n    result = []\n    for i in input:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result\n\n\nif __name__ == '__main__':\n    print(flatten([[1, [2, 3, [4, [5, 6], 7], 8], 9], 10]))",
      -0.85693359375
    ],
    [
      "def flatten(l):\n    \"\"\"\n    :type l: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for i in l:\n        res += i.getList() if i.isInteger() else flatten(i.getList())\n    return res\n\n\nif __name__ == '__main__':\n    print(flatten([[[1, 1], 2], 3]))",
      -0.85693359375
    ],
    [
      "def flatten(nested_list):\n    result = []\n    for element in nested_list:\n        if type(element) == list:\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\nif __name__ == '__main__':\n    print(flatten([1, 2, 3, 4, 5, [1, 2, 3, 4, 5, [1, 2, 3, 4, 5], 6, 7], 8, 9, [1, 2, 3, 4, 5], 10]))",
      -0.85693359375
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, input_list: List[List]) -> List[int]:\n        def flatten_helper(input_list: List[List], output_list: List[int]) -> None:\n            for i in input_list:\n                if isinstance(i, list):\n                    flatten_helper(i, output_list)\n                else:\n                    output_list.append(i)\n\n        output_list: List[int] = []\n        flatten_helper(input_list, output_list)\n        return output_list\n\n\nif __name__ == \"__main__\":\n    input_list = [[1, 1], [2, 2], [3, 3]]\n    output_list = [1, 1, 2, 2, 3, 3]\n    assert (\n        Solution().flatten(input_list) == output_list\n    ), \"The flattened list should be correct\"",
      -0.85693359375
    ],
    [
      "def flatten(nested_list):\n    flattened_list = []\n\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened_list.extend(flatten(item))\n        else:\n            flattened_list.append(item)\n\n    return flattened_list\n\n\nif __name__ == \"__main__\":\n    assert flatten([1, [2], [3, 4], 5]) == [1, 2, 3, 4, 5]\n    assert flatten([1, [2], [[3], [4]], 5]) == [1, 2, 3, 4, 5]\n    assert flatten([1, [2], [[3, 4], 5]]) == [1, 2, 3, 4, 5]",
      -0.85693359375
    ],
    [
      "def flatten(nested_list):\n    \"\"\"\n    :param nested_list: nested list\n    :return: flattened list\n    \"\"\"\n    if type(nested_list) is list:\n        result = []\n        for item in nested_list:\n            result.extend(flatten(item))\n        return result\n    else:\n        return [nested_list]",
      -0.85791015625
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, input: List[List[int]]) -> List[int]:\n        if not input:\n            return []\n        res = []\n\n        def dfs(input):\n            for i in input:\n                if isinstance(i, list):\n                    dfs(i)\n                else:\n                    res.append(i)\n\n        dfs(input)\n        return res\n\n\nif __name__ == \"__main__\":\n    inp = [[1, 1], 2, [3, [5, 6]]]\n    out = [1, 1, 2, 3, 5, 6]\n    res = Solution().flatten(inp)\n    assert out == res, (out, res)",
      -0.85791015625
    ],
    [
      "class NestedInteger(object):\n    def isInteger(self):\n        pass\n\n    def getInteger(self):\n        pass\n\n    def getList(self):\n        pass\n\n\ndef flatten(x):\n    if not isinstance(x, list):\n        return [x.getInteger()]\n    res = []\n    for item in x:\n        res.extend(flatten(item))\n    return res\n\n\nx = [1, [2, [3], 4], 5]\nprint(flatten(x))",
      -0.85791015625
    ],
    [
      "def flatten(nested_list):\n    result = []\n    for i in nested_list:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result",
      -0.85791015625
    ],
    [
      "def flatten(nested_list):\n    result = []\n    for i in nested_list:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result",
      -0.85791015625
    ],
    [
      "def flatten(lst):\n    \"\"\"\n    :type lst: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    if not lst:\n        return []\n    ret = []\n    for item in lst:\n        if item.isInteger():\n            ret.append(item.getInteger())\n        else:\n            ret.extend(flatten(item.getList()))\n    return ret\n\n\ndef main():\n    lst = [[1, 1], 2, [[[3]], 8], [[4, 4], 7], 1, 1]\n    ret = flatten(lst)\n    print(ret)\n\n\nif __name__ == '__main__':\n    main()",
      -0.85791015625
    ],
    [
      "from typing import List\n\n\ndef flatten(lst: List[int]) -> List[int]:\n    result: List[int] = []\n\n    for i in lst:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert flatten([1, 2, 3, 4, 5, [1, 2, [1, 2]], 6, 7, 8]) == [\n        1,\n        2,\n        3,\n        4,\n        5,\n        1,\n        2,\n        1,\n        2,\n        6,\n        7,\n        8,\n    ]",
      -0.85791015625
    ],
    [
      "def flatten(items):\n    \"\"\"\n    Flatten a nested list structure\n    \"\"\"\n    result = []\n    for i in items:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result\n\n\nif __name__ == \"__main__\":\n    print(flatten([1, 2, [3, [4, [5, 6], 7], 8], 9]))",
      -0.85791015625
    ],
    [
      "def flatten(l):\n    result = []\n    for element in l:\n        if isinstance(element, list):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result\n\n\nif __name__ == \"__main__\":\n    print(flatten([1, 2, [[3, 4], 5], [6, [7, 8]]]))",
      -0.85791015625
    ],
    [
      "def flatten(l):\n    for e in l:\n        if isinstance(e, list):\n            for ee in flatten(e):\n                yield ee\n        else:\n            yield e\n\n\nprint(list(flatten([1, 2, [3, 4, [5, 6, 7], 8], 9])))",
      -0.8583984375
    ],
    [
      "from typing import List\n\n\ndef flatten(nested_list: List) -> List:\n    result = []\n\n    for element in nested_list:\n        if isinstance(element, list):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert flatten([1, 2, 3, [4, 5], 6, [7, 8, [9, [10, 11], 12]]]) == [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n    ]",
      -0.8583984375
    ],
    [
      "def flatten(lst):\n    for element in lst:\n        if isinstance(element, list):\n            for item in flatten(element):\n                yield item\n        else:\n            yield element\n\n\nif __name__ == '__main__':\n    print(list(flatten([1, [2], [[3], 4], 5])))",
      -0.8583984375
    ],
    [
      "def flatten(lst):\n    flat_lst = []\n    for i in lst:\n        if isinstance(i, list):\n            flat_lst.extend(flatten(i))\n        else:\n            flat_lst.append(i)\n    return flat_lst\n\n\nif __name__ == '__main__':\n    nested_list = [[1, 2], [3, 4], [5, [6, 7], 8]]\n    print(flatten(nested_list))",
      -0.8583984375
    ],
    [
      "# This is the class of the input nested list\nclass NestedInteger(object):\n   def isInteger(self):\n       return False\n\n   def getInteger(self):\n       return 0\n\n   def getList(self):\n       return [NestedInteger()]\n\ndef flatten(x):\n    \"\"\"\n    :type x: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    ret = []\n    for i in x:\n        if i.isInteger():\n            ret.append(i.getInteger())\n        else:\n            ret.extend(flatten(i.getList()))\n    return ret\n\nif __name__ == '__main__':\n    x = [NestedInteger()]\n    print flatten(x)",
      -0.8583984375
    ],
    [
      "class Solution(object):\n    def flatten(self, nested_list):\n        \"\"\"\n        :type nested_list: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not nested_list:\n            return []\n        res = []\n        self.dfs(nested_list, res)\n        return res\n\n    def dfs(self, nested_list, res):\n        for item in nested_list:\n            if item.isInteger():\n                res.append(item.getInteger())\n            else:\n                self.dfs(item.getList(), res)",
      -0.8583984375
    ],
    [
      "def flatten(nested_list):\n    for item in nested_list:\n        if isinstance(item, list):\n            flatten(item)\n        else:\n            nested_list.append(item)\n\n\nif __name__ == \"__main__\":\n    a = [1, 2, [3, 4], [5, [6, 7], 8], 9, 10]\n    flatten(a)\n    print(a)",
      -0.85888671875
    ],
    [
      "class Solution():\n    def flatten(self, l):\n        \"\"\"\n        :type l: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        stack = l[::-1]\n        flat = []\n        while stack:\n            node = stack.pop()\n            if node.isInteger():\n                flat.append(node.getInteger())\n            else:\n                stack += node.getList()[::-1]\n        return flat\n\n\nif __name__ == \"__main__\":\n    l = [1, [2, [3, [4, [5, [6, [7]]]]]]]\n    l = [1, [2, [3, [4, [5, [6, [7]]]]]]]\n    s = Solution()\n    print(s.flatten(l))",
      -0.85888671875
    ],
    [
      "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        flatten_list = []\n        for item in nestedList:\n            flatten_list.append(item)\n            if item.isInteger():\n                flatten_list.append(item.getInteger())\n            else:\n                flatten_list.extend(self.flatten(item.getList()))\n        return flatten_list\n\n\ndef main():\n    s = Solution()\n    nested_list = [\n        [1, 1],\n        [2, 2],\n        [1, [1, 1]],\n        [1, [1, [1, 1]]],\n        [[[1, 1], 2, 2], 2, 2],\n        [[[1, [1, 1]], 2, 2], 2, 2]\n    ]\n    print(s.flatten(nested_list))\n\n\nif __name__ == '__main__':\n    main()",
      -0.85888671875
    ],
    [
      "from typing import List\n\n\ndef flatten(l: List) -> List:\n    \"\"\"\n    >>> flatten([1, 2, [3, [4, [5, 6]]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    result: List = []\n    for i in l:\n        if isinstance(i, list):\n            result.extend(flatten(i))\n        else:\n            result.append(i)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.86083984375
    ],
    [
      "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        # Runtime: 24 ms\n        # Memory: 13.4 MB\n        stack = nestedList[::-1]\n        ans = []\n        while stack:\n            item = stack.pop()\n            if item.isInteger():\n                ans.append(item.getInteger())\n            else:\n                stack.extend(item.getList()[::-1])\n        return ans",
      -0.86083984375
    ],
    [
      "def flatten(lst):\n    if lst == []:\n        return lst\n    elif not isinstance(lst, list):\n        return [lst]\n    else:\n        return flatten(lst[0]) + flatten(lst[1:])\n\n\nif __name__ == \"__main__\":\n    print(flatten([1, 2, [3, [4, 5]]]))",
      -0.86083984375
    ],
    [
      "def flatten(l):\n    if not isinstance(l, list):\n        return [l]\n    else:\n        return [i for sl in l for i in flatten(sl)]\n\nif __name__ == '__main__':\n    l = [1, 2, [3, 4, [5, 6], 7], 8]\n    print(flatten(l))",
      -0.86083984375
    ],
    [
      "def flatten(nested):\n    flat = []\n    for item in nested:\n        if isinstance(item, list):\n            flat += flatten(item)\n        else:\n            flat.append(item)\n    return flat\n\n\nif __name__ == \"__main__\":\n    nested = [1, [2, 3], [4, [5, [6, 7], 8], 9], 10]\n    print(flatten(nested))",
      -0.86083984375
    ],
    [
      "def flatten(l: list) -> list:\n    res = []\n\n    for i in l:\n        if type(i) == list:\n            res.extend(flatten(i))\n        else:\n            res.append(i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    l = [1, 2, [3, 4, [5, 6], 7], 8]\n    print(flatten(l))",
      -0.86083984375
    ],
    [
      "def flatten(l):\n    \"\"\"\n    :type l: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    if not l:\n        return []\n    if l.isInteger():\n        return [l]\n    else:\n        return flatten(l.getList())\n\n    # while l:\n    #     if l.isInteger():\n    #         return [l]\n    #     else:\n    #         return flatten(l.getList())",
      -0.86083984375
    ],
    [
      "def flatten(nested_list):\n    \"\"\"\n    :param nested_list: nested list\n    :return: flatten list\n    \"\"\"\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n\n\nif __name__ == '__main__':\n    nested_list = [1, [2, 3, [4, [5, 6]]]]\n    print(flatten(nested_list))",
      -0.86083984375
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\nclass Solution:\n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify NestedInteger.\n        \"\"\"\n        if not nestedList: return\n        stk = nestedList[::-1]\n        while stk:\n            curr = stk.pop()\n            if curr.isInteger():\n                self.flattened.append(curr.getInteger())\n            else:\n                stk.extend(curr.getList()[::-1])\n\n    def flatten2(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify NestedInteger.\n        \"\"\"\n        if not nestedList: return\n        flattened = []\n        def flatten(nested):\n            for item in nested:\n                if item.isInteger():\n                    flattened.append(item.getInteger())\n                else:\n                    flatten(item.getList())\n        flatten(nestedList)\n        for i in range(len(flattened)-1, -1, -1):\n            nestedList.append(NestedInteger(flattened[i]))\n\n    def flatten3(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify NestedInteger.\n        \"\"\"\n        if not nestedList: return\n        flattened = []\n        def flatten(nested):",
      -0.9697265625
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, lst: List[int]) -> List[int]:\n        # stack to track the nested list\n        stack = [lst]\n        # result list to be returned\n        result = []\n\n        while stack:\n            curr = stack.pop()\n            if isinstance(curr, list):\n                for elem in curr[::-1]:\n                    if isinstance(elem, list):\n                        stack.append(elem)\n                    else:\n                        result.append(elem)\n            else:\n                result.append(curr)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    lst = [1, [2], [3, [[4]]]]\n    out = [1, 2, 3, 4]\n    res = Solution().flatten(lst)\n    assert out == res, (out, res)\n\n    lst = [1, [2, 3, 4, 5, [6, [7]]]]\n    out = [1, 2, 3, 4, 5, 6, 7]\n    res = Solution().flatten(lst)\n    assert out == res, (out, res)",
      -1.099609375
    ],
    [
      "class Solution(object):\n    def flatten(self, l):\n        \"\"\"\n        :type l: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not l:\n            return l\n        res = []\n        for item in l:\n            if item.isInteger():\n                res.append(item.getInteger())\n            else:\n                res.extend(self.flatten(item.getList()))\n        return res\n\n\n\"\"\"\nTime: O(N)\nSpace: O(N)\n\nFlatten the list.\n\"\"\"",
      -1.1298828125
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\nclass Solution:\n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        def flatten_recursive(nestedList: [NestedInteger], index: int) -> None:\n            if index == len(nestedList):\n                return\n            if nestedList[index].isInteger():\n                flatten_recursive(nestedList, index + 1)\n            else:\n                nestedList[index + 1:] = nestedList[index].getList()\n                flatten_recursive(nestedList, index + 1)\n\n        flatten_recursive(nestedList, 0)",
      -1.287109375
    ],
    [
      "from typing import List\n\n\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n    def isInteger(self) -> bool:\n        \"\"\"\n        @return True if this NestedInteger holds a single integer, rather than a nested list.\n        \"\"\"\n\n    def getInteger(self) -> int:\n        \"\"\"\n        @return the single integer that this NestedInteger holds, if it holds a single integer\n        Return None if this NestedInteger holds a nested list\n        \"\"\"\n\n    def getList(self) -> List[\"NestedInteger\"]:\n        \"\"\"\n        @return the nested list that this NestedInteger holds, if it holds a nested list\n        Return None if this NestedInteger holds a single integer\n        \"\"\"\n\n\nclass Solution:\n    def flatten(self, nestedList: List[NestedInteger]) -> List[int]:\n        if not nestedList:\n            return []\n\n        result = []\n        stack = []\n        for i in nestedList:\n            stack.append(i)\n            while stack:\n                node = stack.pop()\n                if node.isInteger():\n                    result.append(node.getInteger())\n                else:\n                    for j in reversed(node.getList()):\n                        stack.append(j)\n\n        return result",
      -1.30859375
    ],
    [
      "def flatten(items):\n    result = []\n\n    def flatten_items(items):\n        for item in items:\n            if isinstance(item, list):\n                flatten_items(item)\n            else:\n                result.append(item)\n\n    flatten_items(items)\n    return result\n\n\ndef test_flatten():\n    assert flatten([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert flatten([1, [2, 3], 4, 5]) == [1, 2, 3, 4, 5]\n    assert flatten([1, [2, [3, [4, 5]]]]) == [1, 2, 3, 4, 5]\n    assert flatten([[1], [2], [3], [4], [5]]) == [1, 2, 3, 4, 5]\n\n\nif __name__ == '__main__':\n    test_flatten()",
      -1.345703125
    ],
    [
      "def flatten(nested_list):\n    \"\"\"\n    :param nested_list: nested list of integers\n    :return: flattened list of integers\n    \"\"\"\n    return flatten_helper(nested_list, [])\n\n\ndef flatten_helper(nested_list, result):\n    for item in nested_list:\n        if type(item) is list:\n            flatten_helper(item, result)\n        else:\n            result.append(item)\n    return result\n\n\nif __name__ == '__main__':\n    print(flatten([1, 2, [3, 4, [5, 6], 7], 8, [9, 10], 11, 12]))",
      -1.4501953125
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, input: List[int]) -> List[int]:\n        result = []\n        self.helper(input, result)\n        return result\n\n    def helper(self, input: List[int], result: List[int]):\n        for i in input:\n            if isinstance(i, list):\n                self.helper(i, result)\n            else:\n                result.append(i)\n\n\nif __name__ == \"__main__\":\n    input_list = [1, 2, [3]]\n    # input_list = [1, [2, 3], [4, [5, 6], 7]]\n    # input_list = [1, [2, [3], [4, 5], 6, 7, [8, 9]], 10, 11]\n    # input_list = [1, [2, [3], [4, 5], 6, 7, [8, 9, [10, [11, [12, 13]]]]]]\n    # input_list = [1, [2, [3, [4, [5, [6, [7, [8, [9, [10, [11, [12, [13, [14, [15, [16, [17, [18, [19, [20, [21, [22, [23, [24, [25, [26, [27, [28, [29, [30, [31, [32, [33, [34, [35, [36, [37, [38, [39, [40, [41, [42, [43, [44, [45, [46, [47, [48, [49, [50, [51, [52, [53, [54, [55, [56, [57, [58, [59, [60, [61, [62, [63, [64",
      -1.470703125
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        self.stack = nestedList[::-1]\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack.pop().getInteger()\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        while self.stack:\n            top = self.stack[-1]\n            if top.isInteger():\n                return True\n            self.stack.pop()\n            for i in top.getList()[::-1]:\n                self.stack.append(i)\n        return False\n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())",
      -1.66015625
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# class NestedInteger(object):\n#    def isInteger(self):\n#        # @return {boolean} True if this NestedInteger holds a single integer,\n#        # rather than a nested list.\n#\n#    def getInteger(self):\n#        # @return {int} the single integer that this NestedInteger holds,\n#        # if it holds a single integer\n#        # Return None if this NestedInteger holds a nested list\n#\n#    def getList(self):\n#        # @return {NestedInteger[]} the nested list that this NestedInteger\n#        # holds, if it holds a nested list\n#        # Return None if this NestedInteger holds a single integer\n\n\nclass NestedInteger(object):\n    def __init__(self, val):\n        self.val = val\n\n    def isInteger(self):\n        return isinstance(self.val, int)\n\n    def getInteger(self):\n        return self.val\n\n    def getList(self):\n        return self.val\n\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        self.helper(nestedList, result)\n        return result\n\n    def helper(self, nestedList, result):\n        for item in nestedList:\n            if item.isInteger():\n                result.append(item.getInteger())\n            else:\n                self.helper(item.getList(), result)\n\n\ns = Solution()\nprint(s.flatten([1, [2, 3], [[4]]]))\nprint(s.flatten([1, [2, [3], 4], 5]))\nprint(s.flatten([[[1], [2, [3], [4]]]]))\nprint(s.flatten([1, [4, [2, [3], 4], 5]]))",
      -1.71484375
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, input: List[List[int]]) -> List[int]:\n        \"\"\"\n        Recursion\n        Time complexity: O(n)\n        Space complexity: O(n)\n        \"\"\"\n        result = []\n\n        def dfs(input: List[List[int]]):\n            for i in input:\n                if isinstance(i, list):\n                    dfs(i)\n                else:\n                    result.append(i)\n\n        dfs(input)\n        return result\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    test_list = [[1, 1], [2, 2], [3, 3]]\n    result = solution.flatten(test_list)\n    print(result)",
      -2.046875
    ],
    [
      "from typing import List, Any\n\n\nclass Solution:\n    def flatten(self, input: List[Any]) -> List[Any]:\n        if not input:\n            return input\n\n        output = []\n        for i in input:\n            if isinstance(i, list):\n                output += self.flatten(i)\n            else:\n                output.append(i)\n\n        return output\n\n\nif __name__ == '__main__':\n    s = Solution()\n\n    a = [1, [2, 3], [[[4]]]]\n    b = [1, [2, 3], [[[4]]], 5]\n    c = [1, [2, 3], [[[4]]], 5, [6, 7]]\n    d = [[[1, 1], [2, 2], [3, 3]], 4, [5, 5]]\n\n    assert s.flatten(a) == [1, 2, 3, 4]\n    assert s.flatten(b) == [1, 2, 3, 4, 5]\n    assert s.flatten(c) == [1, 2, 3, 4, 5, 6, 7]\n    assert s.flatten(d) == [1, 1, 2, 2, 3, 3, 4, 5, 5]",
      -2.103515625
    ],
    [
      "from typing import List, Optional\n\n\nclass Solution:\n    def flatten(self, N: Optional[List[int]]) -> List[int]:\n        \"\"\"\n        Runtime: 44 ms, faster than 89.40% of Python3\n        Memory Usage: 14.1 MB, less than 78.16% of Python3\n        Time complexity: O(n) where n is the number of nodes in the input list\n        Space complexity: O(n)\n        \"\"\"\n        res = []\n\n        def flatten_helper(node: Optional[List[int]]):\n            if not node:\n                return\n            if isinstance(node, int):\n                res.append(node)\n            for n in node:\n                flatten_helper(n)\n\n        flatten_helper(N)\n        return res\n\n\nclass Solution2:\n    \"\"\"\n    Runtime: 36 ms, faster than 99.50% of Python3\n    Memory Usage: 14.2 MB, less than 28.29% of Python3\n    \"\"\"\n\n    def flatten(self, N: Optional[List[int]]) -> List[int]:\n        if not N:\n            return []\n        return self.flatten(N[0]) + self.flatten(N[1:]) if isinstance(N, list) else [N]\n\n\nif __name__ == '__main__':\n    def get_tc():\n        return [\n            ([[1, 1], [2, 2], [3, 3]], [1, 1, 2, 2, 3, 3]),\n            ([[1, 1], [2, [2, 2]], [3, 3]], [1, 1, 2, 2, 3, 3]),\n            ([[1, [1, [1]]]], [1, 1, 1]),\n            ([[[[[1, 2, 3]]]]], [1, 2, 3]),\n        ]\n\n\n    solutions = (Solution(), Solution2())\n    for s in solutions:\n        for N, exp in get_tc():\n            res = s.",
      -2.11328125
    ],
    [
      "from typing import List\n\n\ndef flatten(ls: List) -> List:\n    \"\"\"Return flattened list.\n\n    :param ls: nested list\n    :return: flattened list\n    \"\"\"\n    flattened: List = []\n\n    for i in ls:\n        if isinstance(i, list):\n            flattened.extend(flatten(i))\n        else:\n            flattened.append(i)\n\n    return flattened\n\n\nif __name__ == \"__main__\":\n    print(flatten([1, 2, [3, 4, [5, 6], 7], 8, [9, 10], 11, 12]))\n    print(flatten([[1, 2, [3, 4, [5, 6], 7], 8, [9, 10], 11, 12]]))\n    print(flatten([[1, 2, [3, 4, [5, 6], 7], 8, [9, 10], 11, 12],\n                   [1, 2, [3, 4, [5, 6], 7], 8, [9, 10], 11, 12]]))",
      -3.13671875
    ],
    [
      "from typing import List\n\n\n# This is the interface that allows for creating nested lists.\nclass NestedInteger:\n  def __init__(self, value=None):\n    self.value = value\n\n  def isInteger(self) -> bool:\n    return isinstance(self.value, int)\n\n  def add(self, elem) -> None:\n    self.value.append(elem)\n\n  def setInteger(self, value) -> None:\n    self.value = value\n\n  def getInteger(self) -> int:\n    return self.value\n\n  def getList(self) -> List['NestedInteger']:\n    return self.value\n\n\n# The actual implementation of the recursive solution\ndef flatten(input_list: List[NestedInteger]) -> List[int]:\n    return flatten_helper(input_list, [])\n\n\ndef flatten_helper(input_list: List[NestedInteger], output_list: List[int]) -> List[int]:\n    for elem in input_list:\n        if elem.isInteger():\n            output_list.append(elem.getInteger())\n        else:\n            flatten_helper(elem.getList(), output_list)\n    return output_list\n\n\n# The actual implementation of the iterative solution\ndef flatten_iter(input_list: List[NestedInteger]) -> List[int]:\n    output_list = []\n    stack = []\n    stack.append(input_list)\n    while stack:\n        elem = stack.pop()\n        if elem.isInteger():\n            output_list.append(elem.getInteger())\n        else:\n            stack.extend(elem.getList())\n    return output_list\n\n\ndef main() -> None:\n    # nested = [NestedInteger([NestedInteger(1), NestedInteger(2)]), NestedInteger([NestedInteger(1), NestedInteger(2)])]\n    # nested = [NestedInteger(1), NestedInteger(2)]\n    nested = [NestedInteger([NestedInteger(1), NestedInteger(2), NestedInteger([NestedInteger(3), NestedInteger(4), NestedInteger(5)])]), Nested",
      -3.408203125
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, lst: List[int]) -> List[int]:\n        \"\"\"\n        :type lst: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not lst:\n            return lst\n        stack = [lst]\n        result = []\n        while stack:\n            current = stack.pop()\n            if isinstance(current, int):\n                result.append(current)\n            else:\n                stack.extend(reversed(current))\n        return result\n\n\nclass Solution2:\n    def flatten(self, lst: List[int]) -> List[int]:\n        \"\"\"\n        :type lst: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not lst:\n            return lst\n        result = []\n        stack = [lst]\n        while stack:\n            current = stack.pop()\n            if isinstance(current, int):\n                result.append(current)\n            else:\n                stack.extend(reversed(current))\n        return result\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    lst = [[1, 1], 2, [3, [5, 8]]]\n    print(solution.flatten(lst))",
      -3.62890625
    ],
    [
      "class Solution(object):\n    def flatten(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(input):\n            result = []\n            for item in input:\n                if item.isInteger():\n                    result.append(item.getInteger())\n                else:\n                    result.extend(dfs(item.getList()))\n            return result\n        return dfs(input)\n\n    def flatten2(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(input):\n            result = []\n            for item in input:\n                if item.isInteger():\n                    result.append(item.getInteger())\n                else:\n                    result.extend(dfs(item.getList()))\n            return result\n        return dfs(input)\n\n    def flatten3(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(input):\n            result = []\n            for item in input:\n                if item.isInteger():\n                    result.append(item.getInteger())\n                else:\n                    result.extend(dfs(item.getList()))\n            return result\n        return dfs(input)\n\n\n# 2018\nclass Solution(object):\n    def flatten(self, N):\n        \"\"\"\n        :type N: NestedInteger\n        :rtype: None Do not return anything, modify N in-place instead.\n        \"\"\"\n        if not N.isInteger():\n            N.list = N.getList()\n            while len(N.list) > 1:\n                N.list.append(N.list.pop(0))\n            for i in range(len(N.list)):\n                self.flatten(N.list[i])\n\n\n# 2018\nclass Solution(object):\n    def flatten(self, N):\n        \"\"\"\n        :type N: NestedInteger\n        :rtype: None",
      -3.953125
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: void Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        if not nestedList:\n            return\n        stack = nestedList[::-1]\n        nestedList[:] = []\n        while stack:\n            curr = stack.pop()\n            if curr.isInteger():\n                nestedList.append(curr)\n            else:\n                stack.extend(curr.getList()[::-1])",
      -4.171875
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        stack = []\n        for l in nestedList:\n            self.dfs(l, stack)\n        return stack\n\n    def dfs(self, nestedList, stack):\n        if nestedList.isInteger():\n            stack.append(nestedList.getInteger())\n        else:\n            for l in nestedList.getList():\n                self.dfs(l, stack)\n\n# Time: O(N)\n# Space: O(N)\n\n\n# DFS\n\n\"\"\"\nTime: O(N)\nSpace: O(N)\n\"\"\"\n# Definition for a NestedInteger\nclass NestedInteger(object):\n    def isInteger(self):\n        \"\"\"\n        @return True if this NestedInteger holds a single integer, rather than a nested list.\n        :rtype bool\n        \"\"\"\n\n    def getInteger(self):\n        \"\"\"\n        @return the single integer that this NestedInteger holds, if it holds a single integer\n        Return None if this NestedInteger holds a nested list\n        :rtype int\n        \"\"\"\n\n    def getList(self):\n        \"\"\"\n        @return the nested list that this NestedInteger holds, if it holds a nested list",
      -4.26953125
    ],
    [
      "from typing import List, Optional\n\n\ndef flatten_list(input_list: List) -> Optional[List]:\n    \"\"\"\n    :param input_list: nested list\n    :return: flattened list\n    >>> flatten_list([1, [2, 3, 4], 5, [6, [7, 8, [9, 10], 11], 12]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    >>> flatten_list([1, [2, 3, [4, [5, 6, 7], 8], 9], 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> flatten_list([1, [2, 3, [4, [5, 6, 7], 8], 9], 10, [11, 12, 13]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    >>> flatten_list([1, [2, 3, [4, [5, 6, 7], 8], 9], 10, [11, 12, 13], [14, 15]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    >>> flatten_list([1, [2, 3, [4, [5, 6, 7], 8], 9], 10, [11, 12, 13], [14, 15], [16]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,",
      -4.53125
    ],
    [
      "# Recursive solution\n# O(n)t | O(n)s\ndef flatten(lst):\n    result = []\n    for elem in lst:\n        if type(elem) == list:\n            result.extend(flatten(elem))\n        else:\n            result.append(elem)\n    return result\n\n\n# Iterative solution\n# O(n)t | O(n)s\ndef flatten(lst):\n    result = []\n    stack = [lst]\n    while stack:\n        current = stack.pop()\n        for elem in current:\n            if type(elem) == list:\n                stack.append(elem)\n            else:\n                result.append(elem)\n    return result[::-1]\n\n# O(n)t | O(n)s\ndef flatten(lst):\n    result = []\n    stack = [lst]\n    while stack:\n        current = stack.pop()\n        if type(current) == list:\n            for elem in reversed(current):\n                stack.append(elem)\n        else:\n            result.append(current)\n    return result\n\n\n\n# O(n)t | O(n)s\ndef flatten(lst):\n    result = []\n    stack = [lst]\n    while stack:\n        current = stack.pop()\n        if type(current) == list:\n            stack.extend(current)\n        else:\n            result.append(current)\n    return result",
      -4.71484375
    ],
    [
      "class Solution(object):\n    def flatten(self, input_list):\n        \"\"\"\n        :type input_list: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not input_list:\n            return []\n        if not input_list[0].isInteger():\n            return self.flatten(input_list[0].getList()) + self.flatten(input_list[1:])\n        else:\n            return [input_list[0].getInteger()] + self.flatten(input_list[1:])\n\n\nclass NestedInteger(object):\n    def __init__(self, val):\n        self.val = val\n\n    def isInteger(self):\n        return isinstance(self.val, int)\n\n    def getInteger(self):\n        return self.val\n\n    def getList(self):\n        return self.val\n\n\ninput_list = [NestedInteger([NestedInteger(1), NestedInteger(2)]), NestedInteger([NestedInteger([NestedInteger(1), NestedInteger(2), NestedInteger(3)]), NestedInteger(2)])]\ns = Solution()\nprint(s.flatten(input_list))",
      -4.75
    ],
    [
      "class Solution(object):\n    def flatten(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        \"\"\"\n        Method 1:\n        Your runtime beats 98.31 % of python submissions.\n        \"\"\"\n        def flatten_helper(nested_list):\n            res = []\n            for ele in nested_list:\n                if ele.isInteger():\n                    res.append(ele.getInteger())\n                else:\n                    res.extend(flatten_helper(ele.getList()))\n            return res\n\n        return flatten_helper(input)",
      -5.0078125
    ],
    [
      "from functools import reduce\nfrom collections import deque\n\n\ndef flatten(l):\n    def _flatten(l):\n        for x in l:\n            if isinstance(x, list):\n                yield from _flatten(x)\n            else:\n                yield x\n\n    return list(_flatten(l))\n\n\ndef flatten_2(l):\n    return reduce(lambda x, y: x + y, l)\n\n\ndef flatten_3(l):\n    return sum(l, [])\n\n\ndef flatten_4(l):\n    return list(flatten_iter(l))\n\n\ndef flatten_iter(l):\n    for x in l:\n        if isinstance(x, list):\n            yield from flatten_iter(x)\n        else:\n            yield x\n\n\ndef flatten_5(l):\n    return deque(flatten_iter(l), maxlen=0)\n\n\ndef flatten_6(l):\n    return [item for sublist in l for item in sublist]\n\n\ndef flatten_7(l):\n    return sum(l, [])\n\n\ndef flatten_8(l):\n    return reduce(lambda a, b: a + b, l, [])\n\n\ndef flatten_9(l):\n    return reduce(lambda a, b: a + b, l, [])\n\n\nif __name__ == '__main__':\n    a = [[1, [2, 3]], 4, [5, 6]]\n    print(flatten_2(a))\n    print(flatten_3(a))\n    print(flatten_4(a))\n    print(flatten_5(a))\n    print(flatten_6(a))\n    print(flatten_7(a))\n    print(flatten_8(a))\n    print(flatten_9(a))",
      -5.02734375
    ],
    [
      "# [1, [2, [3]], 4]\n# [1, 2, 3, 4]\n#\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n#\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n\n# 1. 1\n# 2. 2\n# 3. 3\n# 4. 4\n\n\ndef flatten(nested_list):\n    def inner(lst):\n        for item in lst:\n            if isinstance(item, list):\n                yield from inner(item)\n            else:\n                yield item\n\n    return list(inner(nested_list))\n\n\ndef flatten_recursive(nested_list):\n    result = []\n\n    def inner(lst):\n        for item in lst:\n            if isinstance(item, list):\n                inner(item)\n            else:\n                result.append(item)\n\n    inner(nested_list)\n    return result\n\n\n# test\nassert flatten([1, [2, [3]], 4]) == [1, 2, 3, 4]\nassert flatten([1, [2, [3]], [4, 5]]) == [1, 2, 3, 4, 5]\nassert flatten([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5]\nassert flatten([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5]\nassert flatten([1, [2, [3, [4, [5]]]]]) == [1, 2",
      -5.05078125
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, input: List[List[List[List[int]]]]) -> List[int]:\n        return self.flatten_helper(input, 0)\n\n    def flatten_helper(self, input: List[List[List[List[int]]]], index: int) -> List[int]:\n        if index >= len(input):\n            return []\n\n        if isinstance(input[index], int):\n            return [input[index]]\n\n        return self.flatten_helper(input[index], 0) + self.flatten_helper(input, index + 1)\n\n\nif __name__ == \"__main__\":\n    input = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]\n    out = Solution().flatten(input)\n    print(out)",
      -5.0859375
    ],
    [
      "class Solution:\n    def flatten(self, input):\n        \"\"\"\n        :type input: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n\n        \"\"\"\n        Method 1: Recursion\n\n        * If the nested list has only one integer, then return the integer\n        * If the nested list has more than one integer, then concatenate the\n        result of each integer\n        \"\"\"\n        # def flatten(self, input):\n        #     if isinstance(input, int):\n        #         return [input]\n        #     return [i for num in input for i in flatten(num)]\n\n\n        \"\"\"\n        Method 2: Stack\n\n        * If the nested list has only one integer, then return the integer\n        * If the nested list has more than one integer, then concatenate the\n        result of each integer\n        \"\"\"\n        # def flatten(self, input):\n        #     if isinstance(input, int):\n        #         return [input]\n        #\n        #     stack = [input]\n        #     res = []\n        #     while stack:\n        #         cur = stack.pop()\n        #         if isinstance(cur, int):\n        #             res.append(cur)\n        #         else:\n        #             stack.extend(cur)\n        #     return res\n\n        \"\"\"\n        Method 3: Iteration\n\n        * If the nested list has only one integer, then return the integer\n        * If the nested list has more than one integer, then concatenate the\n        result of each integer\n        \"\"\"\n        def flatten(self, input):\n            if isinstance(input, int):\n                return [input]\n\n            res = []\n            for num in input:\n                res.extend(flatten(num))\n            return res",
      -5.3828125
    ],
    [
      "# Recursive\n# def flatten(input_list):\n#     result = []\n#     for i in input_list:\n#         if type(i) == list:\n#             result += flatten(i)\n#         else:\n#             result.append(i)\n#     return result\n\n\n# Iterative\ndef flatten(input_list):\n    result = []\n    stack = input_list[::-1]\n    while stack:\n        current = stack.pop()\n        if type(current) == list:\n            stack.extend(current)\n        else:\n            result.append(current)\n    return result[::-1]\n\n\n# Test\nprint(flatten([1, 2, 3, 4, 5, [1, 2, [3, 4], 5], 6, 7, [8, 9]]))\nprint(flatten([1, [2, 3, [4, 5], 6, 7], 8, [9, 10]]))\nprint(flatten([[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]], 13, [14, [15, 16]]]))\nprint(flatten([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]]))",
      -5.90625
    ],
    [
      "# This is the class of the input nested list\nclass NestedInteger:\n    def __init__(self, value=None):\n        self.value = value\n\n    def isInteger(self):\n        return isinstance(self.value, int)\n\n    def getInteger(self):\n        return self.value\n\n    def isList(self):\n        return isinstance(self.value, list)\n\n    def getList(self):\n        return self.value\n\n\ndef flatten(x):\n    \"\"\"\n    :type nestedList: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    if x.isInteger():\n        return [x.getInteger()]\n\n    result = []\n    for item in x.getList():\n        result.extend(flatten(item))\n    return result\n\n\nnestedList = [1, [4, [6]], 7, 8, [[2, 9, 10], 5]]\nnestedList = [1, [4, [6, [7, 8, 9]]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [4, [6]]]\nnestedList = [1, [",
      -6.3359375
    ],
    [
      "from collections import deque\n\n\nclass NestedList(object):\n    def __init__(self, nums):\n        self.nums = nums\n\n    def flatten(self):\n        result = []\n        for num in self.nums:\n            if isinstance(num, NestedList):\n                result.extend(num.flatten())\n            else:\n                result.append(num)\n        return result\n\n    def flatten2(self):\n        result = []\n        stack = deque()\n        stack.append(self)\n        while stack:\n            obj = stack.pop()\n            if isinstance(obj, NestedList):\n                stack.extend(obj.nums)\n            else:\n                result.append(obj)\n        return result\n\n\ndef flatten(nested):\n    \"\"\"\n    :type nested: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    if not nested:\n        return []\n    result = []\n    stack = deque()\n    stack.append(nested)\n    while stack:\n        obj = stack.pop()\n        if isinstance(obj, list):\n            stack.extend(obj)\n        else:\n            result.append(obj.getInteger())\n    return result\n\n\ndef main():\n    ll = NestedList([1, 2, 3, NestedList([4, 5, 6, NestedList([7, 8, 9])])])\n    print(ll.flatten())\n    print(ll.flatten2())\n    print(flatten(ll.nums))\n\n\nif __name__ == '__main__':\n    main()",
      -6.4375
    ],
    [
      "from typing import List\n\n\nclass Solution:\n    def flatten(self, nestedList: List[int]) -> List[int]:\n        if not nestedList:\n            return []\n        ans = []\n        for item in nestedList:\n            if item.isInteger():\n                ans.append(item.getInteger())\n            else:\n                ans += self.flatten(item.getList())\n        return ans\n\n\nif __name__ == \"__main__\":\n    nestedList = [1, [2, 1], [[3], [4, 5]]]\n    out = [1, 2, 1, 3, 4, 5]\n    res = Solution().flatten(nestedList)\n    assert out == res, (out, res)\n\n    nestedList = [1, [2, 1], [[3], [4, 5]]]\n    out = [1, 2, 1, 3, 4, 5]\n    res = Solution().flatten(nestedList)\n    assert out == res, (out, res)\n\n    nestedList = [1, [2, 1], [[3], [4, 5]]]\n    out = [1, 2, 1, 3, 4, 5]\n    res = Solution().flatten(nestedList)\n    assert out == res, (out, res)\n\n    nestedList = [1, [2, 1], [[3], [4, 5]]]\n    out = [1, 2, 1, 3, 4, 5]\n    res = Solution().flatten(nestedList)\n    assert out == res, (out, res)\n\n    nestedList = [1, [2, 1], [[3], [4, 5]]]\n    out = [1, 2, 1, 3, 4, 5]\n    res = Solution().flatten(nestedList)\n    assert out == res, (out, res)",
      -7.99609375
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger(object):\n    def __init__(self, value=None):\n        \"\"\"\n        If value is not specified, initializes an empty list.\n        Otherwise, initializes a single integer equal to value.\n        \"\"\"\n\n    def isInteger(self):\n        \"\"\"\n        @return True if this NestedInteger holds a single integer, rather than a nested list.\n        :rtype bool\n        \"\"\"\n\n    def add(self, elem):\n        \"\"\"\n        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n        :rtype void\n        \"\"\"\n\n    def setInteger(self, value):\n        \"\"\"\n        Set this NestedInteger to hold a single integer equal to value.\n        :rtype void\n        \"\"\"\n\n    def getInteger(self):\n        \"\"\"\n        @return the single integer that this NestedInteger holds, if it holds a single integer\n        Return None if this NestedInteger holds a nested list\n        :rtype int\n        \"\"\"\n\n    def getList(self):\n        \"\"\"\n        @return the nested list that this NestedInteger holds, if it holds a nested list\n        Return None if this NestedInteger holds a single integer\n        :rtype List[NestedInteger]\n        \"\"\"\n\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: None Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        # \u4f7f\u7528\u9012\u5f52\n        # \u9012\u5f52\u7684\u505c\u6b62\u6761\u4ef6\n        if not nestedList:\n            return\n        for i in nestedList:\n            if i.isInteger():\n                print(i.getInteger())\n            else:\n                self.flatten(i.getList())\n        return nestedList\n\n\nif __name__ == '__main__':\n    s = Solution()\n    s.flatten(nestedList=[[1, 1], 2, [3, 4, [5]]])",
      -8.53125
    ],
    [
      "# def flatten(l):\n#     \"\"\"\n#     :type l: List[NestedInteger]\n#     :rtype: List[int]\n#     \"\"\"\n#     # return list(flatten_helper(l))\n#     return [x for x in flatten_helper(l)]\n\n# def flatten_helper(l):\n#     for i in l:\n#         if not i.isInteger():\n#             for x in flatten_helper(i.getList()):\n#                 yield x\n#         else:\n#             yield i.getInteger()\n\n# def flatten(l):\n#     \"\"\"\n#     :type l: List[NestedInteger]\n#     :rtype: List[int]\n#     \"\"\"\n#     return list(flatten_helper(l))\n\n# def flatten_helper(l):\n#     if not l:\n#         return\n#     for i in l:\n#         if not i.isInteger():\n#             for x in flatten_helper(i.getList()):\n#                 yield x\n#         else:\n#             yield i.getInteger()\n\n# def flatten(l):\n#     \"\"\"\n#     :type l: List[NestedInteger]\n#     :rtype: List[int]\n#     \"\"\"\n#     return list(flatten_helper(l))\n\n# def flatten_helper(l):\n#     if not l:\n#         return\n#     for i in l:\n#         if not i.isInteger():\n#             for x in flatten_helper(i.getList()):\n#                 yield x\n#         else:\n#             yield i.getInteger()\n\ndef flatten(l):\n    \"\"\"\n    :type l: List[NestedInteger]\n    :rtype: List[int]\n    \"\"\"\n    return list(flatten_helper(l))\n\ndef flatten_helper(l):\n    if not l:\n        return\n    for i in l:\n        if not i.isInteger():\n            for x in flatten_helper(i.getList()):\n                yield x\n        else:\n            yield i.getInteger()",
      -8.59375
    ],
    [
      "# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\nclass NestedInteger:\n   def isInteger(self) -> bool:\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       \"\"\"\n\n   def getInteger(self) -> int:\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       \"\"\"\n\n   def getList(self) -> [NestedInteger]:\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       \"\"\"\n\n\nclass Solution:\n    def flatten(self, nestedList: [NestedInteger]) -> None:\n        \"\"\"\n        Do not return anything, modify nestedList in-place instead.\n        \"\"\"\n        if not nestedList:\n            return\n\n        for i, ni in enumerate(nestedList):\n            if ni.isInteger():\n                nestedList[i] = ni.getInteger()\n            else:\n                nestedList[i] = ni.getList()\n\n        nestedList[:] = [item for sublist in nestedList for item in sublist]\n        self.flatten(nestedList)",
      -8.7265625
    ],
    [
      "# # Definition for a Node.\n# class Node(object):\n#     def __init__(self, val, children):\n#         self.val = val\n#         self.children = children\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        if root is None:\n            return None\n        stack = [root]\n        prev = None\n        while stack:\n            node = stack.pop()\n            if prev is not None:\n                prev.next = node\n            prev = node\n            while node.children:\n                node = node.children.pop()\n                stack.append(node)\n        return root",
      -10.8046875
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}