{
  "problem": {
    "task_id": "MBPP/367",
    "prompt": "Write a function to check if a binary tree is balanced or not.",
    "canonical_solution": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False",
    "test_list": [
      "assert is_tree_balanced(root) == False",
      "assert is_tree_balanced(root1) == True",
      "assert is_tree_balanced(root2) == False "
    ],
    "challenge_test_list": [],
    "problem_id": 356
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root):\n    return helper(root)[0]\n\ndef helper(root):\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = helper(root.left)\n    right_balanced, right_height = helper(root.right)\n\n    return left_balanced and right_balanced and abs(left_height - right_height) <= 1, 1 + max(left_height, right_height)\n\nif __name__ == \"__main__\":\n    #     0\n    #    / \\\n    #   1   2\n    #  /\n    # 3\n    root = Node(0, Node(1, Node(3)), Node(2))\n    assert is_balanced(root) == True\n\n    #     0\n    #    / \\\n    #   2   2\n    #  /\n    # 1\n    root = Node(0, Node(2, Node(1)), Node(2))\n    assert is_balanced(root) == False",
      12.3203125
    ],
    [
      "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef is_balanced(root):\n    return check_balanced(root)[0]\n\n\ndef check_balanced(root):\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = check_balanced(root.left)\n    right_balanced, right_height = check_balanced(root.right)\n\n    if not left_balanced or not right_balanced:\n        return False, max(left_height, right_height) + 1\n\n    return abs(left_height - right_height) <= 1, max(left_height, right_height) + 1\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(3)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.right.left = TreeNode(1)\n    root.right.right = TreeNode(4)\n    print(is_balanced(root))\n\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.right.right = TreeNode(3)\n    print(is_balanced(root))\n\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    print(is_balanced(root))",
      6.49609375
    ],
    [
      "class TreeNode:\n  def __init__(self, value, left=None, right=None):\n    self.left = left\n    self.right = right\n    self.value = value\n\ndef is_balanced(root):\n  return is_balanced_helper(root)[0]\n\ndef is_balanced_helper(root):\n  if not root:\n    return True, 0\n\n  left_balanced, left_height = is_balanced_helper(root.left)\n  right_balanced, right_height = is_balanced_helper(root.right)\n\n  if not left_balanced or not right_balanced:\n    return False, max(left_height, right_height) + 1\n\n  return abs(left_height - right_height) <= 1, max(left_height, right_height) + 1\n\nif __name__ == \"__main__\":\n  root = TreeNode(1, TreeNode(2), TreeNode(3))\n  print(is_balanced(root))\n\n  root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4))\n  print(is_balanced(root))",
      5.48828125
    ],
    [
      "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef balanced_binary_tree(root):\n    if root is None:\n        return True\n\n    def check_balanced(root):\n        if root is None:\n            return 0, True\n\n        left_height, is_left_balanced = check_balanced(root.left)\n        right_height, is_right_balanced = check_balanced(root.right)\n\n        is_balanced = (\n            is_left_balanced\n            and is_right_balanced\n            and abs(left_height - right_height) <= 1\n        )\n\n        return max(left_height, right_height) + 1, is_balanced\n\n    return check_balanced(root)[1]\n\n\ndef test(node, expected_answer):\n    answer = balanced_binary_tree(node)\n\n    if answer != expected_answer:\n        raise Exception(\n            f\"Answer {answer} is wrong. Expected answer is {expected_answer}\"\n        )\n\n\nif __name__ == \"__main__\":\n    test(Node(2, Node(1), Node(3)), True)\n    test(Node(2, Node(1), Node(4, Node(3))), True)\n    test(Node(2, Node(1), Node(4, Node(4))), False)\n    test(Node(2, Node(1), Node(4, Node(4), Node(5))), True)\n    test(Node(2, Node(1), Node(4, Node(4), Node(5, Node(6), Node(7)))), True)\n    test(Node(2, Node(1), Node(4, Node(4), Node(5, Node(6), Node(7), Node(8)))), False)\n    print(\"All tests passed!\")",
      5.17578125
    ],
    [
      "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef check_balanced(root):\n    return check_balanced_helper(root)[0]\n\n\ndef check_balanced_helper(root):\n    if not root:\n        return True, 0\n\n    left_balanced, left_depth = check_balanced_helper(root.left)\n    if not left_balanced:\n        return False, 0\n\n    right_balanced, right_depth = check_balanced_helper(root.right)\n    if not right_balanced:\n        return False, 0\n\n    return abs(left_depth - right_depth) <= 1, 1 + max(left_depth, right_depth)\n\n\nif __name__ == '__main__':\n    root = Node(1, Node(2, Node(3)), Node(4, Node(5), Node(6)))\n    print(check_balanced(root))\n\n    root = Node(1, Node(2, Node(3, Node(4), Node(5))), Node(6, Node(7), Node(8)))\n    print(check_balanced(root))",
      4.92578125
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def height(root: Node) -> int:\n        if root is None:\n            return 0\n\n        return 1 + max(height(root.left), height(root.right))\n\n    def is_balanced_helper(root: Node) -> bool:\n        if root is None:\n            return True\n\n        left_height = height(root.left)\n        right_height = height(root.right)\n\n        if abs(left_height - right_height) > 1:\n            return False\n\n        return is_balanced_helper(root.left) and is_balanced_helper(root.right)\n\n    return is_balanced_helper(root)\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n    print(is_balanced(root))",
      4.84375
    ],
    [
      "class TreeNode:\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef is_balanced(root):\n    if root is None:\n        return True\n\n    return helper(root) != -1\n\n\ndef helper(root):\n    if root is None:\n        return 0\n\n    left = helper(root.left)\n    right = helper(root.right)\n\n    if left == -1 or right == -1 or abs(left - right) > 1:\n        return -1\n\n    return 1 + max(left, right)\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(\"a\", TreeNode(\"b\", TreeNode(\"d\"), TreeNode(\"e\")), TreeNode(\"c\", TreeNode(\"f\"), TreeNode(\"g\")))\n    print(is_balanced(root))",
      4.82421875
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def helper(node: Node) -> tuple:\n        if not node:\n            return True, 0\n\n        balanced, left_height = helper(node.left)\n\n        if not balanced:\n            return False, 0\n\n        balanced, right_height = helper(node.right)\n\n        if not balanced:\n            return False, 0\n\n        return abs(left_height - right_height) <= 1, 1 + max(left_height, right_height)\n\n    return helper(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.right.right = Node(8)\n    print(is_balanced(root))",
      4.484375
    ],
    [
      "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass BinaryTree:\n    def __init__(self, root=None):\n        self.root = root\n\n    def is_balanced(self):\n        \"\"\"\n        Checks if the binary tree is balanced\n        :return: bool\n        \"\"\"\n        return self._is_balanced(self.root)\n\n    def _is_balanced(self, node):\n        if node is None:\n            return True\n\n        left_height = self._get_height(node.left)\n        right_height = self._get_height(node.right)\n\n        if abs(left_height - right_height) > 1:\n            return False\n        return self._is_balanced(node.left) and self._is_balanced(node.right)\n\n    def _get_height(self, node):\n        if node is None:\n            return 0\n        return 1 + max(self._get_height(node.left), self._get_height(node.right))\n\n\nif __name__ == \"__main__\":\n    tree = BinaryTree()\n\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    tree.root.left.left = Node(4)\n    tree.root.left.right = Node(5)\n\n    print(tree.is_balanced())",
      3.751953125
    ],
    [
      "class TreeNode:\n  def __init__(self, value, left=None, right=None):\n    self.value = value\n    self.left = left\n    self.right = right\n\n\ndef is_balanced(root):\n    return helper(root) != -1\n\n\ndef helper(root):\n    if not root:\n        return 0\n    left = helper(root.left)\n    right = helper(root.right)\n    if left == -1 or right == -1 or abs(left - right) > 1:\n        return -1\n    return 1 + max(left, right)\n\n\ndef main():\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.right.right = TreeNode(5)\n  root.left.right = TreeNode(6)\n  root.right.left = TreeNode(7)\n  root.left.right.left = TreeNode(8)\n  root.right.left.left = TreeNode(9)\n  root.right.left.right = TreeNode(10)\n  root.right.left.right.left = TreeNode(11)\n  root.right.left.right.right = TreeNode(12)\n  root.right.left.right.right.left = TreeNode(13)\n  root.right.left.right.right.right = TreeNode(14)\n  root.right.left.right.right.right.left = TreeNode(15)\n\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()",
      3.408203125
    ],
    [
      "# This is the class of the input binary tree\nclass Tree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_balanced(root):\n    if root is None:\n        return True\n    if abs(height(root.left) - height(root.right)) > 1:\n        return False\n    return is_balanced(root.left) and is_balanced(root.right)\n\ndef height(root):\n    if root is None:\n        return -1\n    return 1 + max(height(root.left), height(root.right))",
      3.208984375
    ],
    [
      "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef is_balanced(root):\n    return _is_balanced(root)[0]\n\n\ndef _is_balanced(root):\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = _is_balanced(root.left)\n    if not left_balanced:\n        return False, 0\n\n    right_balanced, right_height = _is_balanced(root.right)\n    if not right_balanced:\n        return False, 0\n\n    return abs(left_height - right_height) <= 1, 1 + max(left_height, right_height)\n\n\nif __name__ == '__main__':\n    root = Node(4, Node(2, Node(1), Node(3)), Node(6, Node(5), Node(7)))\n    print(is_balanced(root))",
      3.064453125
    ],
    [
      "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef is_balanced(root):\n    if root is None:\n        return True\n    return is_balanced_helper(root)\n\n\ndef is_balanced_helper(root):\n    if root is None:\n        return 0\n    left = is_balanced_helper(root.left)\n    right = is_balanced_helper(root.right)\n    if left == -1 or right == -1:\n        return -1\n    if abs(left - right) > 1:\n        return -1\n    return 1 + max(left, right)\n\n\nif __name__ == \"__main__\":\n    root = Node(1, Node(2, Node(3), Node(4)), Node(2, Node(4), Node(4)))\n    print(is_balanced(root))",
      2.78125
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inOrder  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    if root is None:\n        return True\n\n    def helper(node: Node) -> tuple:\n        if node is None:\n            return True, 0\n\n        balanced, left_height = helper(node.left)\n        if not balanced:\n            return False, 0\n\n        balanced, right_height = helper(node.right)\n        if not balanced:\n            return False, 0\n\n        if abs(left_height - right_height) > 1:\n            return False, 0\n\n        return True, 1 + max(left_height, right_height)\n\n    return helper(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n\n    print(is_balanced(root))\n    print(inOrder(root))",
      2.611328125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root):\n        # if root is None, return true.\n        if root is None:\n            return True\n\n        # if root is not None, return the max depth - min depth <= 1.\n        return self.maxDepth(root) - self.minDepth(root) <= 1\n\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n    def minDepth(self, root):\n        if root is None:\n            return 0\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n\nif __name__ == \"__main__\":\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    result = Solution().isBalanced(root)\n    print(result)",
      2.015625
    ],
    [
      "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root):\n    if root is None:\n        return True\n    if abs(get_height(root.left) - get_height(root.right)) <= 1:\n        return is_balanced(root.left) and is_balanced(root.right)\n    return False\n\ndef get_height(root):\n    if root is None:\n        return 0\n    return 1 + max(get_height(root.left), get_height(root.right))\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n    root.left.right.right = Node(10)\n    print(is_balanced(root))\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n    root.left.right.right = Node(10)\n    root.left.right.left = Node(11)\n    print(is_balanced(root))\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(",
      1.6123046875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef is_balanced(root: TreeNode) -> bool:\n\n    def helper(node: TreeNode) -> int:\n        if not node:\n            return 0\n\n        left_height = helper(node.left)\n        right_height = helper(node.right)\n\n        if abs(left_height - right_height) > 1:\n            nonlocal is_balanced\n            is_balanced = False\n\n        return 1 + max(left_height, right_height)\n\n    is_balanced = True\n    helper(root)\n    return is_balanced\n\n\n\"\"\"\nTime complexity: O(N) where N is the number of nodes in the tree. We traverse each node exactly once.\nSpace complexity: O(N) for the recursion stack.\n\"\"\"",
      1.44140625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def get_depth(root):\n    nonlocal is_balanced\n    if root is None:\n      return 0\n    left = get_depth(root.left)\n    right = get_depth(root.right)\n    if abs(left - right) > 1:\n      is_balanced = False\n    return max(left, right) + 1\n  is_balanced = True\n  get_depth(root)\n  return is_balanced\n\n\ndef main():\n  # [2, 1, 3, null, null, 5]\n  root = TreeNode(2)\n  root.left = TreeNode(1)\n  root.right = TreeNode(3)\n  root.right.right = TreeNode(5)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\"",
      1.4033203125
    ],
    [
      "from gfg.trees.binary_tree import Node, inorder\nfrom typing import Optional\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    def is_balanced_helper(node: Optional[Node]) -> Optional[tuple]:\n        if not node:\n            return True, 0\n\n        left_balanced, left_height = is_balanced_helper(node.left)\n        right_balanced, right_height = is_balanced_helper(node.right)\n\n        if not left_balanced or not right_balanced:\n            return False, max(left_height, right_height) + 1\n\n        return abs(left_height - right_height) <= 1, max(left_height, right_height) + 1\n\n    return is_balanced_helper(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n\n    print(is_balanced(root))",
      1.283203125
    ],
    [
      "# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\ndef balancedBinaryTree(root):\n    def isBalanced(root):\n        if root is None:\n            return True, 0\n        left_is_balanced, left_height = isBalanced(root.left)\n        right_is_balanced, right_height = isBalanced(root.right)\n        return left_is_balanced and right_is_balanced and abs(left_height - right_height) <= 1, max(left_height, right_height) + 1\n\n    return isBalanced(root)[0]\n\n# https://www.youtube.com/watch?v=l0YHlJ-tQyE\n# https://www.youtube.com/watch?v=EeFq8rEybqI",
      1.064453125
    ],
    [
      "class Node:\n  def __init__(self, value, left=None, right=None):\n    self.value = value\n    self.left = left\n    self.right = right\n\n\ndef balanced(root):\n    return helper(root) != -1\n\n\ndef helper(root):\n    if not root:\n        return 0\n    left = helper(root.left)\n    right = helper(root.right)\n    if left == -1 or right == -1 or abs(left - right) > 1:\n        return -1\n    return 1 + max(left, right)\n\n\nif __name__ == '__main__':\n    root = Node(4, Node(2, Node(1), Node(3)), Node(7, Node(6), Node(9)))\n    assert balanced(root) == True\n    root = Node(1, Node(2, Node(3)))\n    assert balanced(root) == False",
      0.80810546875
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef is_balanced(root):\n  # TODO: Write your code here\n  pass\n\ndef main():\n  root = TreeNode(5)\n  root.left = TreeNode(4)\n  root.right = TreeNode(2)\n  root.right.left = TreeNode(1)\n  root.right.right = TreeNode(3)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\nmain()\n\n\"\"\"\nTime complexity: O(N)\nSpace complexity: O(1)\n\"\"\"",
      0.80322265625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def get_height(root):\n    if not root:\n      return 0\n    return max(get_height(root.left), get_height(root.right)) + 1\n  if not root:\n    return True\n  return abs(get_height(root.left) - get_height(root.right)) <= 1 and \\\n      is_balanced(root.left) and is_balanced(root.right)\n\n\ndef main():\n  # 4\n  # | \\\n  # 2   3\n  # |\n  # 1\n  root = TreeNode(4)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(1)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n  root.right.right = TreeNode(5)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\"",
      0.72265625
    ],
    [
      "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef isBalanced(root):\n    def check(root):\n        if not root:\n            return 0\n\n        left_height = check(root.left)\n        if left_height == -1:\n            return -1\n\n        right_height = check(root.right)\n        if right_height == -1:\n            return -1\n\n        if abs(left_height - right_height) > 1:\n            return -1\n\n        return 1 + max(left_height, right_height)\n\n    return check(root) != -1\n\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.right.left.right = TreeNode(8)\n    print(isBalanced(root))\n    root.right.left.right.right = TreeNode(9)\n    print(isBalanced(root))",
      0.70703125
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def get_depth(root):\n            if not root:\n                return 0\n            return max(get_depth(root.left), get_depth(root.right)) + 1\n        if not root:\n            return True\n        left_depth = get_depth(root.left)\n        right_depth = get_depth(root.right)\n        return abs(left_depth - right_depth) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n\n\n\"\"\"\nTime complexity: O(N) where N is the number of nodes in the tree.\nSpace complexity: O(logN) in the best case and O(N) in the worst case.\n\"\"\"",
      0.634765625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def dfs(node):\n    if node is None:\n      return (True, 0)\n\n    l_balanced, l_depth = dfs(node.left)\n    r_balanced, r_depth = dfs(node.right)\n\n    if not l_balanced or not r_balanced:\n      return (False, 0)\n\n    return (abs(l_depth - r_depth) <= 1, 1 + max(l_depth, r_depth))\n\n  return dfs(root)[0]\n\n\ndef main():\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.left = TreeNode(6)\n  root.right.right = TreeNode(7)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.right = TreeNode(7)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()",
      0.59375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root: TreeNode) -> bool:\n    return helper(root)[1]\n\n\ndef helper(root: TreeNode) -> (int, bool):\n    if not root:\n        return 0, True\n    lh, lb = helper(root.left)\n    rh, rb = helper(root.right)\n    if not lb or not rb:\n        return 0, False\n    return max(lh, rh) + 1, abs(lh - rh) <= 1\n\n\n\"\"\"\nTime complexity: O(N)\nSpace complexity: O(N)\n\"\"\"",
      0.383056640625
    ],
    [
      "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass Tree:\n    def __init__(self):\n        self.root = None\n\n\ndef is_balanced(root):\n    return helper(root)[1]\n\n\ndef helper(node):\n    if not node:\n        return True, 0\n    left_balanced, left_height = helper(node.left)\n    right_balanced, right_height = helper(node.right)\n    if not left_balanced or not right_balanced:\n        return False, max(left_height, right_height) + 1\n    return abs(left_height - right_height) <= 1, max(left_height, right_height) + 1\n\n\nif __name__ == \"__main__\":\n    t = Tree()\n    t.root = Node(1)\n    t.root.left = Node(2)\n    t.root.right = Node(3)\n    t.root.left.left = Node(4)\n    t.root.left.right = Node(5)\n    print(is_balanced(t.root))\n    t.root.right.right = Node(6)\n    print(is_balanced(t.root))",
      0.296875
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        return self.helper(root) != -1\n\n    def helper(self, root):\n        if not root:\n            return 0\n        left = self.helper(root.left)\n        right = self.helper(root.right)\n        if left == -1 or right == -1 or abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1",
      0.2415771484375
    ],
    [
      "def is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    return check_balance(root)[1]\n\n\ndef check_balance(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: (int, bool)\n    \"\"\"\n    if not root:\n        return 0, True\n    l_height, l_balance = check_balance(root.left)\n    r_height, r_balance = check_balance(root.right)\n    return max(l_height, r_height) + 1, l_balance and r_balance and abs(l_height - r_height) <= 1\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()",
      0.2215576171875
    ],
    [
      "class TreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return f\"Tree Node: {self.value}\"\n\n\ndef check_balance(root: TreeNode) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(h)\n    \"\"\"\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return check_balance(root.left) and check_balance(root.right)\n\n\ndef get_height(root: TreeNode) -> int:\n    if root is None:\n        return 0\n\n    return 1 + max(get_height(root.left), get_height(root.right))\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    print(check_balance(root))",
      0.2001953125
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isBalanced(self, root: TreeNode) -> bool:\n    def helper(root: TreeNode) -> (bool, int):\n        if not root:\n            return True, 0\n        l_balanced, l_height = helper(root.left)\n        r_balanced, r_height = helper(root.right)\n        if not l_balanced or not r_balanced:\n            return False, 0\n        return abs(l_height - r_height) <= 1, 1 + max(l_height, r_height)\n\n    return helper(root)[0]\n\n\n\"\"\"\nTime complexity: O(N) where N is the number of nodes in the tree.\nSpace complexity: O(N) to keep the call stack.\n\"\"\"",
      0.140869140625
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        \n        return self.is_balanced(root)\n        \n    def is_balanced(self, root):\n        if not root:\n            return 0\n        \n        left = self.is_balanced(root.left)\n        right = self.is_balanced(root.right)\n        \n        if abs(left - right) > 1:\n            return False\n        else:\n            return 1 + max(left, right)",
      0.1358642578125
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root):\n  # TODO: Write your code here\n\n  def check_balance(root):\n    if not root:\n      return 0\n    left_height = check_balance(root.left)\n    right_height = check_balance(root.right)\n    if left_height == -1 or right_height == -1:\n      return -1\n    if abs(left_height - right_height) > 1:\n      return -1\n    return 1 + max(left_height, right_height)\n\n  return check_balance(root) != -1",
      0.0335693359375
    ],
    [
      "from typing import Tuple\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef check_balanced(root: Node) -> Tuple[bool, int]:\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = check_balanced(root.left)\n    right_balanced, right_height = check_balanced(root.right)\n\n    if not (left_balanced and right_balanced):\n        return False, 0\n\n    return abs(left_height - right_height) <= 1, 1 + max(left_height, right_height)\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n    root.right.left.right.left = Node(9)\n    root.right.left.right.right = Node(10)\n\n    print(check_balanced(root))\n    print(inorder(root))",
      0.03240966796875
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef get_depth(root):\n  if root is None:\n    return 0\n\n  return 1 + max(get_depth(root.left), get_depth(root.right))\n\ndef is_balanced(root):\n  if root is None:\n    return True\n\n  left_depth = get_depth(root.left)\n  right_depth = get_depth(root.right)\n\n  if abs(left_depth - right_depth) > 1:\n    return False\n\n  return is_balanced(root.left) and is_balanced(root.right)\n\n\nt = TreeNode(1)\nt.left = TreeNode(2)\nt.right = TreeNode(3)\nt.left.left = TreeNode(4)\nt.left.right = TreeNode(5)\nt.right.left = TreeNode(6)\nt.right.right = TreeNode(7)\n\nprint(is_balanced(t))",
      0.01568603515625
    ],
    [
      "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def check(root):\n            if root is None:\n                return 0\n            left = check(root.left)\n            right = check(root.right)\n            if left == -1 or right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        return check(root) != -1",
      -0.20849609375
    ],
    [
      "def is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    # if root is None:\n    #     return True\n    #\n    # left_height = get_height(root.left)\n    # right_height = get_height(root.right)\n    #\n    # if abs(left_height - right_height) > 1:\n    #     return False\n    #\n    # return is_balanced(root.left) and is_balanced(root.right)\n\n    if root is None:\n        return True\n\n    return (abs(get_height(root.left) - get_height(root.right)) <= 1) and \\\n           is_balanced(root.left) and \\\n           is_balanced(root.right)\n\n\ndef get_height(root):\n    if root is None:\n        return 0\n\n    return max(get_height(root.left), get_height(root.right)) + 1",
      -0.2685546875
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def helper(node: Node) -> int:\n        if not node:\n            return 0\n\n        left = helper(node.left)\n        right = helper(node.right)\n\n        if abs(left - right) > 1:\n            nonlocal balanced\n            balanced = False\n\n        return 1 + max(left, right)\n\n    balanced: bool = True\n\n    helper(root)\n\n    return balanced\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.left = Node(8)\n    root.right.left.right = Node(9)\n    root.right.right.left = Node(10)\n    root.right.right.right = Node(11)\n    root.right.right.right.left = Node(12)\n    root.right.right.right.right = Node(13)\n    root.right.right.right.right.right = Node(14)\n    print(is_balanced(root))",
      -0.300537109375
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def helper(node: Node) -> int:\n        nonlocal balanced\n\n        if not node:\n            return 0\n\n        left = helper(node.left)\n        right = helper(node.right)\n\n        if abs(left - right) > 1:\n            balanced = False\n\n        return max(left, right) + 1\n\n    balanced = True\n    helper(root)\n\n    return balanced\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n    root.right.left.left = Node(9)\n    root.right.left.left.left = Node(10)\n\n    print(is_balanced(root))",
      -0.321533203125
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef check_balanced(root):\n    if not root:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    return abs(left_height - right_height) <= 1 and check_balanced(root.left) and check_balanced(root.right)\n\ndef get_height(root):\n    if not root:\n        return 0\n    return 1 + max(get_height(root.left), get_height(root.right))\n\n\nif __name__ == \"__main__\":\n  root = TreeNode(5)\n  root.left = TreeNode(3)\n  root.right = TreeNode(7)\n  root.left.left = TreeNode(2)\n  root.left.right = TreeNode(4)\n  root.right.right = TreeNode(8)\n  print(check_balanced(root))",
      -0.393798828125
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef check_balanced(root: Node) -> bool:\n    def is_balanced(node: Node) -> bool:\n        if not node:\n            return True, 0\n\n        left, left_height = is_balanced(node.left)\n        right, right_height = is_balanced(node.right)\n\n        if left and right and abs(left_height - right_height) <= 1:\n            return True, max(left_height, right_height) + 1\n\n        return False, max(left_height, right_height) + 1\n\n    return is_balanced(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.right.right = Node(8)\n    root.right.left.left = Node(9)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(11)\n    root.right.right.left = Node(12)\n    root.right.right.right = Node(13)\n    root.right.right.right.right = Node(14)\n\n    assert not check_balanced(root)",
      -0.458984375
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def get_depth(node: Node) -> int:\n        nonlocal balanced\n\n        if not node:\n            return 0\n\n        if balanced:\n            return max(get_depth(node.left), get_depth(node.right)) + 1\n\n        balanced = False\n        return 0\n\n    balanced = True\n\n    return balanced if get_depth(root) > 0 else balanced\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.left.right.left = Node(6)\n    root.left.right.right = Node(7)\n\n    assert is_balanced(root)",
      -0.467041015625
    ],
    [
      "from typing import Tuple\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root_node: Node) -> Tuple[bool, int]:\n    if not root_node:\n        return True, 0\n\n    is_balanced, left_height = is_balanced(root_node.left)\n\n    if not is_balanced:\n        return False, 0\n\n    is_balanced, right_height = is_balanced(root_node.right)\n\n    if not is_balanced:\n        return False, 0\n\n    return (\n        abs(left_height - right_height) <= 1,\n        max(left_height, right_height) + 1,\n    )\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n    root.right.left.left = Node(10)\n    root.right.left.right = Node(11)\n\n    print(is_balanced(root))",
      -0.5009765625
    ],
    [
      "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef is_balanced(root):\n    return helper(root)[1]\n\n\ndef helper(root):\n    if not root:\n        return 0, True\n\n    left_height, left_balanced = helper(root.left)\n    right_height, right_balanced = helper(root.right)\n\n    if not left_balanced or not right_balanced:\n        return 0, False\n\n    if abs(left_height - right_height) > 1:\n        return 0, False\n\n    return max(left_height, right_height) + 1, True\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    assert is_balanced(root)\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    assert not is_balanced(root)\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    assert not is_balanced(root)",
      -0.63037109375
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    if root is None:\n        return True\n\n    def is_balanced_util(root: Node) -> int:\n        if root is None:\n            return 0\n\n        left = is_balanced_util(root.left)\n        if left == -1:\n            return -1\n\n        right = is_balanced_util(root.right)\n        if right == -1:\n            return -1\n\n        if abs(left - right) > 1:\n            return -1\n\n        return 1 + max(left, right)\n\n    return is_balanced_util(root) != -1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n\n    print(is_balanced(root))",
      -0.70703125
    ],
    [
      "class TreeNode:\n  def __init__(self, value, left=None, right=None):\n    self.value = value\n    self.left = left\n    self.right = right\n\n\ndef is_balanced(root):\n  # TODO: Write your code here\n\n\nprint(is_balanced(None))",
      -0.85595703125
    ],
    [
      "def is_balanced(root):\n    return is_balanced_helper(root) != -1\n\n\ndef is_balanced_helper(root):\n    if not root:\n        return 0\n\n    left_height = is_balanced_helper(root.left)\n    if left_height == -1:\n        return -1\n\n    right_height = is_balanced_helper(root.right)\n    if right_height == -1:\n        return -1\n\n    if abs(left_height - right_height) > 1:\n        return -1\n\n    return max(left_height, right_height) + 1",
      -0.85693359375
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def helper(node: Optional[Node]) -> tuple:\n        if not node:\n            return True, 0\n\n        left_balanced, left_height = helper(node.left)\n        right_balanced, right_height = helper(node.right)\n\n        return (\n            left_balanced\n            and right_balanced\n            and abs(left_height - right_height) <= 1,\n            max(left_height, right_height) + 1,\n        )\n\n    return helper(root)[0]",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n\n        return dfs(root) != -1",
      -0.85791015625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if root is None:\n            return True\n\n        def check(node):\n            if node is None:\n                return 0\n\n            left = check(node.left)\n            right = check(node.right)\n\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            else:\n                return max(left, right) + 1\n\n        return check(root) != -1",
      -0.8583984375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root: TreeNode) -> bool:\n    return check_balance(root)[0]\n\n\ndef check_balance(root: TreeNode) -> tuple:\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = check_balance(root.left)\n    right_balanced, right_height = check_balance(root.right)\n\n    balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n    height = 1 + max(left_height, right_height)\n    return balanced, height\n\n\ndef main():\n  pass\n\n\nif __name__ == '__main__':\n  main()",
      -0.8583984375
    ],
    [
      "def is_balanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    def get_height(root):\n        if not root:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1\n\n    def check(root):\n        if not root:\n            return True\n        if abs(get_height(root.left) - get_height(root.right)) > 1:\n            return False\n        return check(root.left) and check(root.right)\n\n    return check(root)",
      -0.86083984375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        return self.isBalanced(root.left) and self.isBalanced(root.right)",
      -0.86083984375
    ],
    [
      "from project.tree import Node, Tree\n\n\ndef is_balanced(tree):\n    \"\"\"\n        Checks if a binary tree is balanced or not.\n    \"\"\"\n    def _is_balanced(tree):\n        if not tree:\n            return True, 0\n        is_left_balanced, left_height = _is_balanced(tree.left)\n        is_right_balanced, right_height = _is_balanced(tree.right)\n        is_balanced = is_left_balanced and is_right_balanced\n        height = max(left_height, right_height) + 1\n        return is_balanced, height\n    return _is_balanced(tree)[0]\n\n\nif __name__ == '__main__':\n    tree = Tree()\n    tree.root = Node(1)\n    tree.root.left = Node(2)\n    tree.root.right = Node(3)\n    print(is_balanced(tree))",
      -0.90869140625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef isBalanced(root):\n    return isBalancedHelper(root) != -1\n\ndef isBalancedHelper(root):\n    if root is None:\n        return 0\n    left_height = isBalancedHelper(root.left)\n    if left_height == -1:\n        return -1\n    right_height = isBalancedHelper(root.right)\n    if right_height == -1:\n        return -1\n    if abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nprint(isBalanced(root))\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint(isBalanced(root))",
      -0.97705078125
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef get_height(root):\n  if not root:\n    return 0\n  return max(get_height(root.left), get_height(root.right)) + 1\n\n\ndef check_balanced(root):\n  if not root:\n    return True\n  left_height = get_height(root.left)\n  right_height = get_height(root.right)\n  if abs(left_height - right_height) <= 1:\n    return check_balanced(root.left) and check_balanced(root.right)\n  return False\n\n\ndef main():\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.left = TreeNode(6)\n  root.right.right = TreeNode(7)\n  root.left.left.left = TreeNode(8)\n  root.left.left.right = TreeNode(9)\n  root.left.right.left = TreeNode(10)\n  root.left.right.right = TreeNode(11)\n  root.right.left.left = TreeNode(12)\n  root.right.left.right = TreeNode(13)\n  root.right.right.left = TreeNode(14)\n  root.right.right.right = TreeNode(15)\n  print(check_balanced(root))\n\n\nmain()",
      -1.1552734375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root):\n    def dfs(root):\n        if not root:\n            return 0, True\n\n        left_height, left_balanced = dfs(root.left)\n        right_height, right_balanced = dfs(root.right)\n\n        if not left_balanced or not right_balanced:\n            return -1, False\n\n        return max(left_height, right_height) + 1, abs(left_height - right_height) <= 1\n\n    return dfs(root)[1]\n\n\ndef main():\n  # 2\n  # |  \\\n  # 1   3\n  #    /\n  #   4\n  root = TreeNode(2)\n  root.right = TreeNode(3)\n  root.right.left = TreeNode(4)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n  # 2\n  # |  \\\n  # 1   3\n  #    / \\\n  #   4   5\n  root = TreeNode(2)\n  root.right = TreeNode(3)\n  root.right.left = TreeNode(4)\n  root.right.right = TreeNode(5)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n  # 2\n  # |  \\\n  # 1   3\n  #    /\n  #   4\n  #   |\n  #   5\n  root = TreeNode(2)\n  root.right = TreeNode(3)\n  root.right.left = TreeNode(4)\n  root.right.left.left = TreeNode(5)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n\nmain()",
      -1.216796875
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def height(node: Node) -> int:\n        if not node:\n            return 0\n\n        left_height = height(node.left)\n        right_height = height(node.right)\n\n        if left_height == -1 or right_height == -1:\n            return -1\n\n        if abs(left_height - right_height) > 1:\n            return -1\n\n        return max(left_height, right_height) + 1\n\n    return height(root) != -1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(9)\n    root.right.right.left.right = Node(10)\n    root.right.right.right.right = Node(11)\n    root.right.right.right.right.right = Node(12)\n    root.right.right.right.right.left = Node(13)\n    root.right.right.right.left.left = Node(14)\n    print(is_balanced(root))",
      -1.2353515625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def _is_balanced(root):\n    if root is None:\n      return True, 0\n\n    left_balanced, left_height = _is_balanced(root.left)\n    right_balanced, right_height = _is_balanced(root.right)\n\n    balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n    return balanced, 1 + max(left_height, right_height)\n\n  return _is_balanced(root)[0]\n\n\ndef main():\n  # [3, 9, 20, null, null, 15, 7]\n  root = TreeNode(3)\n  root.left = TreeNode(9)\n  root.right = TreeNode(20)\n  root.right.left = TreeNode(15)\n  root.right.right = TreeNode(7)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # [1, 2, 2, 3, 3, null, null, 4, 4]\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(2)\n  root.left.left = TreeNode(3)\n  root.left.right = TreeNode(3)\n  root.right.left = TreeNode(4)\n  root.right.right = TreeNode(4)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()",
      -1.279296875
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root_node: Optional[Node]) -> bool:\n    if not root_node:\n        return True\n\n    def is_balanced_recursive(node: Node) -> tuple[bool, int]:\n        if not node:\n            return True, 0\n\n        left_balanced, left_height = is_balanced_recursive(node.left)\n        right_balanced, right_height = is_balanced_recursive(node.right)\n\n        if not left_balanced or not right_balanced:\n            return False, max(left_height, right_height) + 1\n\n        return True, max(left_height, right_height) + 1\n\n    return is_balanced_recursive(root_node)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.right.left = Node(8)\n    root.right.right.right = Node(9)\n    root.right.right.left.right = Node(10)\n    print(inorder(root))\n    print(is_balanced(root))",
      -1.3251953125
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def check_balanced(root):\n    if not root:\n      return True, 0\n    left_balanced, left_height = check_balanced(root.left)\n    right_balanced, right_height = check_balanced(root.right)\n    return (left_balanced and right_balanced\n            and abs(left_height - right_height) <= 1,\n            max(left_height, right_height) + 1)\n\n  return check_balanced(root)[0]\n\n\ndef main():\n  # [1, 2, 3, 4, 5, 6, 7]\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.right.left = TreeNode(5)\n  root.right.right = TreeNode(6)\n  root.left.left.left = TreeNode(7)\n  print(\"Tree is balanced \" + str(is_balanced(root)))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\"",
      -1.5517578125
    ],
    [
      "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef check_balanced(root):\n    balanced = True\n\n    def check_balanced_helper(root):\n        nonlocal balanced\n        if not root:\n            return 0\n        l_height = check_balanced_helper(root.left)\n        r_height = check_balanced_helper(root.right)\n        if abs(l_height - r_height) > 1:\n            balanced = False\n        return max(l_height, r_height) + 1\n\n    check_balanced_helper(root)\n    return balanced\n\n\ndef test(root, expected_answer):\n    answer = check_balanced(root)\n\n    if answer != expected_answer:\n        raise Exception(\n            f\"Answer {answer} is wrong. Expected answer is {expected_answer}\"\n        )\n\n\nif __name__ == \"__main__\":\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(5)\n    root.right.left = Node(1)\n    root.right.right = Node(3)\n    test(root, True)\n    print(\"All tests passed!\")",
      -1.69140625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isBalanced(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    if root is None:\n        return True\n    return helper(root) != -1\n\ndef helper(root):\n    if root is None:\n        return 0\n    left = helper(root.left)\n    if left == -1:\n        return -1\n    right = helper(root.right)\n    if right == -1:\n        return -1\n    return max(left, right) + 1 if abs(left - right) <= 1 else -1\n\n# The isBalanced() function can be implemented recursively, but a\n# non-recursive implementation is also possible. We can use a stack to\n# keep track of the nodes we have visited so far, and use it to check\n# whether the subtree rooted at the current node is balanced.\n\ndef isBalancedNonRecursive(root):\n    stack = [(root, 1)]\n    while stack:\n        node, height = stack.pop()\n        left_height = right_height = height\n        if node.left is not None:\n            left_height = height + 1\n            stack.append((node.left, left_height))\n        if node.right is not None:\n            right_height = height + 1\n            stack.append((node.right, right_height))\n        if abs(left_height - right_height) > 1 or left_height == -1 or right_height == -1:\n            return False\n    return True\n\n# Time: O(n)\n# Space: O(n) in the worst case of skewed tree.",
      -1.8037109375
    ],
    [
      "from project.tree import Node, Tree\n\n\ndef balanced_tree(tree: Tree) -> bool:\n    \"\"\"\n    Check if a binary tree is balanced or not.\n    >>> t = Tree()\n    >>> t.add(1)\n    >>> t.add(2)\n    >>> t.add(3)\n    >>> t.add(4)\n    >>> t.add(5)\n    >>> t.add(6)\n    >>> t.add(7)\n    >>> balanced_tree(t)\n    True\n    >>> t.add(8)\n    >>> balanced_tree(t)\n    False\n    \"\"\"\n    return check_balanced(tree.root, 0)[0]\n\n\ndef check_balanced(node: Node, depth: int) -> (bool, int):\n    \"\"\"\n    Check if a binary tree is balanced or not.\n    >>> check_balanced(Node(1), 0)\n    (True, 0)\n    >>> check_balanced(Node(1, Node(2), Node(3)), 0)\n    (True, 1)\n    >>> check_balanced(Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))), 0)\n    (True, 2)\n    >>> check_balanced(Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7), Node(8))), 0)\n    (False, 2)\n    \"\"\"\n    if node is None:\n        return True, 0\n\n    left_balanced, left_depth = check_balanced(node.left, depth + 1)\n    if not left_balanced:\n        return False, left_depth\n\n    right_balanced, right_depth = check_balanced(node.right, depth + 1)\n    if not right_balanced:\n        return False, right_depth\n\n    return abs(left_depth - right_depth) <= 1, max(left_depth, right_depth)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    do",
      -1.8037109375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef is_balanced(root):\n  return helper(root)[0]\n\ndef helper(root):\n  if not root:\n    return True, 0\n\n  is_left_balanced, left_height = helper(root.left)\n  if not is_left_balanced:\n    return False, 0\n\n  is_right_balanced, right_height = helper(root.right)\n  if not is_right_balanced:\n    return False, 0\n\n  if abs(left_height - right_height) > 1:\n    return False, 0\n\n  return True, 1 + max(left_height, right_height)\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nprint(is_balanced(root))",
      -1.869140625
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        else:\n            return self.isBalancedRecur(root)\n\n    def isBalancedRecur(self, root):\n        if root is None:\n            return True, 0\n        else:\n            left_is_balanced, left_depth = self.isBalancedRecur(root.left)\n            right_is_balanced, right_depth = self.isBalancedRecur(root.right)\n            if not left_is_balanced or not right_is_balanced or abs(left_depth - right_depth) > 1:\n                return False, max(left_depth, right_depth) + 1\n            else:\n                return True, max(left_depth, right_depth) + 1",
      -1.880859375
    ],
    [
      "class Node:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root: Node) -> bool:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    def check(root: Node) -> (bool, int):\n      if not root: return True, 0\n      \n      l_balanced, l_height = check(root.left)\n      r_balanced, r_height = check(root.right)\n      \n      if not l_balanced or not r_balanced:\n        return False, 0\n      \n      return abs(l_height - r_height) <= 1, 1 + max(l_height, r_height)\n    \n    return check(root)[0]\n\n\nif __name__ == \"__main__\":\n  root = Node(1)\n  root.left = Node(2)\n  root.right = Node(3)\n  root.left.left = Node(4)\n  root.left.right = Node(5)\n  root.right.left = Node(6)\n  root.right.right = Node(7)\n  print(is_balanced(root))\n\n  root = Node(1)\n  root.left = Node(2)\n  root.right = Node(3)\n  root.left.left = Node(4)\n  root.left.right = Node(5)\n  root.right.right = Node(6)\n  print(is_balanced(root))",
      -1.890625
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def is_balanced_helper(node: Optional[Node]):\n        nonlocal balanced\n\n        if not node:\n            return 0\n\n        left_height = is_balanced_helper(node.left)\n        right_height = is_balanced_helper(node.right)\n\n        if abs(left_height - right_height) > 1:\n            balanced = False\n\n        return max(left_height, right_height) + 1\n\n    balanced: bool = True\n    is_balanced_helper(root)\n\n    return balanced\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.left.right = Node(9)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(11)\n    root.right.left.left = Node(12)\n    root.right.left.right = Node(13)\n    root.right.right.left = Node(14)\n    root.right.right.right = Node(15)\n\n    inorder(root)\n    print(is_balanced(root))",
      -2.021484375
    ],
    [
      "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return True\n        return self.getHeight(root) != -1\n\n    def getHeight(self, root):\n        if root is None:\n            return 0\n        left = self.getHeight(root.left)\n        if left == -1:\n            return -1\n        right = self.getHeight(root.right)\n        if right == -1:\n            return -1\n        if abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1\n\nA = Solution()\na = TreeNode(1)\nb = TreeNode(2)\nc = TreeNode(3)\nd = TreeNode(4)\ne = TreeNode(5)\na.left = b\na.right = c\nc.left = d\nc.right = e\nprint(A.isBalanced(a))",
      -2.119140625
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    def is_balanced_helper(node: Optional[Node]) -> tuple[bool, int]:\n        if not node:\n            return True, 0\n\n        left_balanced, left_depth = is_balanced_helper(node.left)\n        if not left_balanced:\n            return False, 0\n\n        right_balanced, right_depth = is_balanced_helper(node.right)\n        if not right_balanced:\n            return False, 0\n\n        if abs(left_depth - right_depth) > 1:\n            return False, 0\n\n        return True, 1 + max(left_depth, right_depth)\n\n    return is_balanced_helper(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    print(inorder(root))\n    print(is_balanced(root))",
      -2.130859375
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def check_balanced(node: Optional[Node], depth: int) -> bool:\n        if not node:\n            return True\n\n        left = check_balanced(node.left, depth + 1)\n        right = check_balanced(node.right, depth + 1)\n\n        if left and right and abs(depth(node.left) - depth(node.right)) <= 1:\n            return True\n\n        return False\n\n    def depth(node: Optional[Node]) -> int:\n        if not node:\n            return 0\n\n        return max(depth(node.left), depth(node.right)) + 1\n\n    return check_balanced(root, 0)\n\n\nif __name__ == \"__main__\":\n    root_node = Node(1)\n    root_node.left = Node(2)\n    root_node.right = Node(3)\n    root_node.left.left = Node(4)\n    root_node.left.right = Node(5)\n    root_node.right.left = Node(6)\n    root_node.right.right = Node(7)\n    root_node.right.left.right = Node(8)\n    print(inorder(root_node))\n    print(is_balanced(root_node))",
      -2.134765625
    ],
    [
      "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Tree:\n    def __init__(self, val):\n        self.root = Node(val)\n\n    def insert(self, val):\n        curr = self.root\n        while True:\n            if val < curr.val:\n                if curr.left:\n                    curr = curr.left\n                else:\n                    curr.left = Node(val)\n                    break\n            else:\n                if curr.right:\n                    curr = curr.right\n                else:\n                    curr.right = Node(val)\n                    break\n\n    def is_balanced(self, root):\n        if not root:\n            return True\n        return self.height(root.left) - self.height(root.right) < 2\n\n    def height(self, root):\n        if not root:\n            return 0\n        return 1 + max(self.height(root.left), self.height(root.right))\n\n\ndef main():\n    tree = Tree(1)\n    tree.insert(2)\n    tree.insert(3)\n    tree.insert(4)\n    tree.insert(5)\n    tree.insert(6)\n    print(tree.is_balanced(tree.root))\n    tree.insert(7)\n    print(tree.is_balanced(tree.root))\n\n\nif __name__ == '__main__':\n    main()",
      -2.140625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root: TreeNode) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(h)\n    \"\"\"\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_balanced(root.left) and is_balanced(root.right)\n\n\ndef get_height(root: TreeNode) -> int:\n    if root is None:\n        return 0\n\n    return 1 + max(get_height(root.left), get_height(root.right))\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    print(is_balanced(root))",
      -2.423828125
    ],
    [
      "# This is the class of the input binary tree.\n\nclass Tree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef check_balanced(root):\n    # Write your code here.\n    def check(root):\n        if root is None:\n            return 0\n        left = check(root.left)\n        right = check(root.right)\n        if left == -1 or right == -1 or abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1\n\n    return check(root) != -1\n\n\nroot = Tree(10)\nroot.left = Tree(7)\nroot.right = Tree(20)\nroot.right.left = Tree(15)\nroot.right.right = Tree(25)\nprint(check_balanced(root))",
      -2.482421875
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    def is_balanced_helper(node: Node) -> bool:\n        if not node:\n            return True, 0\n\n        l_balanced, l_height = is_balanced_helper(node.left)\n        r_balanced, r_height = is_balanced_helper(node.right)\n\n        return l_balanced and r_balanced and abs(l_height - r_height) <= 1, max(l_height, r_height) + 1\n\n    return is_balanced_helper(root)[0]\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    print(is_balanced(root))\n    root.left.left.left = Node(6)\n    print(is_balanced(root))",
      -2.533203125
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    if root is None:\n        return True\n\n    def check_balance(node: Optional[Node]) -> int:\n        if node is None:\n            return 0\n\n        left = check_balance(node.left)\n        right = check_balance(node.right)\n\n        if left == -1 or right == -1 or abs(left - right) > 1:\n            return -1\n\n        return 1 + max(left, right)\n\n    return check_balance(root) != -1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n\n    print(is_balanced(root))\n    print(inorder(root))",
      -2.578125
    ],
    [
      "class TreeNode:\n  def __init__(self, value, left=None, right=None):\n    self.value = value\n    self.left = left\n    self.right = right\n\ndef is_balanced(root):\n  def get_height(root):\n    nonlocal is_balanced\n    is_balanced = False\n    if not root:\n      return 0\n    left_height = get_height(root.left)\n    if not is_balanced:\n      return -1\n    right_height = get_height(root.right)\n    if abs(left_height - right_height) > 1:\n      is_balanced = False\n    return max(left_height, right_height) + 1\n  get_height(root)\n  return is_balanced\n\n\ndef test():\n  root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n  assert is_balanced(root) == True\n\n  root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), TreeNode(7))))\n  assert is_balanced(root) == False\n\n  root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(5))))\n  assert is_balanced(root) == True\n\n  root = TreeNode(1, TreeNode(2, TreeNode(3)))\n  assert is_balanced(root) == False\n\n  root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4, TreeNode(5, TreeNode(6))))))\n  assert is_balanced(root) == False\n\n  print 'passed'\n\n\nif __name__ == '__main__':\n  test()",
      -2.716796875
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  def get_height(node):\n    if not node:\n      return 0\n    return 1 + max(get_height(node.left), get_height(node.right))\n\n  def is_balanced_helper(node):\n    if not node:\n      return True\n    left_height = get_height(node.left)\n    right_height = get_height(node.right)\n    if abs(left_height - right_height) > 1:\n      return False\n    return is_balanced_helper(node.left) and is_balanced_helper(node.right)\n\n  return is_balanced_helper(root)\n\n\ndef main():\n  # [10, 5, 15, 1, 8, null, 7]\n  root = TreeNode(10)\n  root.left = TreeNode(5)\n  root.right = TreeNode(15)\n  root.left.left = TreeNode(1)\n  root.left.right = TreeNode(8)\n  root.right.right = TreeNode(7)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  root = TreeNode(5)\n  root.left = TreeNode(4)\n  root.right = TreeNode(7)\n  root.left.left = TreeNode(2)\n  root.left.right = TreeNode(6)\n  root.left.right.left = TreeNode(5)\n  root.left.right.right = TreeNode(7)\n  root.right.right = TreeNode(8)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\"",
      -2.826171875
    ],
    [
      "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass Tree:\n    def __init__(self, root):\n        self.root = Node(root)\n\n    def insert(self, data, root=None):\n        root = self.root\n        if root is None:\n            root = Node(data)\n        else:\n            if data <= root.data:\n                cur = self.insert(data, root.left)\n                root.left = cur\n            else:\n                cur = self.insert(data, root.right)\n                root.right = cur\n        return root\n\n    def check_balanced(self, root):\n        if root is None:\n            return True\n        if abs(self.height(root.left) - self.height(root.right)) > 1:\n            return False\n        return self.check_balanced(root.left) and self.check_balanced(root.right)\n\n    def height(self, root):\n        if root is None:\n            return 0\n        return 1 + max(self.height(root.left), self.height(root.right))\n\n\ndef main():\n    tree = Tree(10)\n    tree.insert(15)\n    tree.insert(12)\n    tree.insert(8)\n    tree.insert(16)\n    tree.insert(20)\n    tree.insert(13)\n    tree.insert(17)\n    tree.insert(19)\n    tree.insert(3)\n    tree.insert(7)\n    tree.insert(6)\n    tree.insert(2)\n    tree.insert(4)\n    tree.insert(5)\n\n    print(tree.check_balanced(tree.root))\n\n\nif __name__ == '__main__':\n    main()",
      -3.412109375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root):\n  # TODO: Write your code here\n  if not root:\n    return True\n\n  def height(root):\n    if not root:\n      return 0\n    return max(height(root.left), height(root.right)) + 1\n\n  def is_balanced_helper(root):\n    if not root:\n      return True\n    if abs(height(root.left) - height(root.right)) <= 1:\n      return is_balanced_helper(root.left) and is_balanced_helper(root.right)\n    return False\n\n  return is_balanced_helper(root)\n\n\ndef main():\n  # 1\n  # 2 3\n  # 4 5\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # 2\n  # 3 4\n  # 5 6\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.left = TreeNode(6)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # 2 3\n  # 4\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # 2 3\n  # 4",
      -3.5
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\ndef is_balanced(root):\n    return helper(root)[0]\n\ndef helper(root):\n    if not root:\n        return True, 0\n\n    left_balanced, left_height = helper(root.left)\n    right_balanced, right_height = helper(root.right)\n\n    balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n    height = max(left_height, right_height) + 1\n    return balanced, height\n\ndef main():\n  # [3,9,20,null,null,15,7]\n  root = TreeNode(3)\n  root.left = TreeNode(9)\n  root.right = TreeNode(20)\n  root.right.left = TreeNode(15)\n  root.right.right = TreeNode(7)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(2)\n  root.right.left = TreeNode(3)\n  root.right.right = TreeNode(3)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n\nmain()\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\"",
      -3.904296875
    ],
    [
      "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef balanced_binary_tree(root):\n    return balanced_tree_helper(root) >= 0\n\n\ndef balanced_tree_helper(root):\n    if root is None:\n        return 0\n    left_height = balanced_tree_helper(root.left)\n    if left_height < 0:\n        return -1\n    right_height = balanced_tree_helper(root.right)\n    if right_height < 0:\n        return -1\n    return max(left_height, right_height) + 1\n\n\nif __name__ == '__main__':\n    balanced_tree = Node(1, Node(2), Node(3))\n\n    unbalanced_tree = Node(1, Node(2, Node(4)), Node(3))\n\n    print(balanced_binary_tree(balanced_tree))\n    print(balanced_binary_tree(unbalanced_tree))",
      -3.93359375
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef check_balanced(root: Node) -> bool:\n    def get_balance(node: Node) -> int:\n        if not node:\n            return 0\n\n        left = get_balance(node.left)\n        right = get_balance(node.right)\n\n        if left < 0 or right < 0:\n            return -1\n\n        return max(left, right) + 1\n\n    return get_balance(root) != -1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n\n    print(check_balanced(root))",
      -4.1015625
    ],
    [
      "# A balanced tree is a tree in which difference between heights of left and right subtrees is not more than 1.\n# A tree is balanced if all its nodes are balanced.\n\nclass TreeNode:\n  def __init__(self, value):\n    self.value = value\n    self.left = None\n    self.right = None\n\ndef is_balanced(root):\n    if root is None:\n        return True\n    return abs(height(root.left) - height(root.right)) < 2 and is_balanced(root.left) and is_balanced(root.right)\n\ndef height(root):\n    if root is None:\n        return 0\n    return 1 + max(height(root.left), height(root.right))\n\ndef main():\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  print(\"Is balanced: \" + str(is_balanced(root)))\n\n\nmain()\n\n\n\"\"\"\nTime complexity: O(N) where N is the number of nodes in the tree.\nSpace complexity: O(N)\n\"\"\"",
      -4.30859375
    ],
    [
      "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.right = None\n        self.left = None\n\n\nclass Solution:\n    def isBalanced(self, root):\n        if root is None:\n            return True\n\n        return self.isBalancedHelper(root) != -1\n\n    def isBalancedHelper(self, root):\n        if root is None:\n            return 0\n\n        left_height = self.isBalancedHelper(root.left)\n        if left_height == -1:\n            return -1\n\n        right_height = self.isBalancedHelper(root.right)\n        if right_height == -1:\n            return -1\n\n        if abs(left_height - right_height) <= 1:\n            return max(left_height, right_height) + 1\n\n        return -1\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n    root.right.left.left = Node(9)\n    root.right.right.right = Node(10)\n    root.right.right.left = Node(11)\n    root.right.right.left.right = Node(12)\n    root.right.right.left.left = Node(13)\n    root.left.left.right = Node(14)\n    root.left.left.right.right = Node(15)\n    root.left.left.right.left = Node(16)\n    root.left.left.left = Node(17)\n    root.left.left.left.right = Node(18)\n\n    sol = Solution()\n    print(sol.isBalanced(root))",
      -4.33984375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  _, is_balanced = is_balanced_helper(root)\n  return is_balanced\n\n\ndef is_balanced_helper(root):\n  if not root:\n    return 0, True\n  left_height, left_is_balanced = is_balanced_helper(root.left)\n  right_height, right_is_balanced = is_balanced_helper(root.right)\n  if not left_is_balanced or not right_is_balanced:\n    return max(left_height, right_height) + 1, False\n  return max(left_height, right_height) + 1, abs(left_height - right_height) <= 1\n\n\ndef main():\n  # 1\n  # 2 3\n  # 4 5\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # 2\n  # 3 4\n  # 5\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # 2 3\n  # 4\n  # 5\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  print(\"Tree balanced: \" + str(is_balanced(root)))",
      -4.4609375
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef get_height(root):\n  if not root:\n    return 0\n  return 1 + max(get_height(root.left), get_height(root.right))\n\n\ndef is_balanced(root):\n  if not root:\n    return True\n  left = get_height(root.left)\n  right = get_height(root.right)\n  if abs(left - right) > 1:\n    return False\n  return is_balanced(root.left) and is_balanced(root.right)\n\n\ndef main():\n  # 1 2 3 4 5 6 7 8 9\n  # 1 2 3 4 5 6 7 8\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.left = TreeNode(6)\n  root.right.right = TreeNode(7)\n  root.left.left.left = TreeNode(8)\n  root.left.left.right = TreeNode(9)\n  print(\"Tree balanced: \" + str(is_balanced(root)))\n\n\nmain()",
      -4.76171875
    ],
    [
      "class TreeNode:\n  def __init__(self, value, left=None, right=None):\n    self.value = value\n    self.left = left\n    self.right = right\n\n  def __repr__(self):\n    return f\"TreeNode({self.value})\"\n\n\ndef is_balanced(root):\n    return is_balanced_helper(root)[1]\n\ndef is_balanced_helper(root):\n    if root is None:\n        return 0, True\n\n    left_height, left_balanced = is_balanced_helper(root.left)\n    right_height, right_balanced = is_balanced_helper(root.right)\n\n    if not left_balanced or not right_balanced:\n        return 0, False\n\n    return max(left_height, right_height) + 1, abs(left_height - right_height) <= 1\n\n\ndef test():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    assert is_balanced(root) == True\n\n    root.left.right = TreeNode(4)\n    assert is_balanced(root) == False\n\n    root.left.right.left = TreeNode(5)\n    assert is_balanced(root) == True\n\n    root.left.right.right = TreeNode(6)\n    assert is_balanced(root) == False\n\n    root.left.right.right.left = TreeNode(7)\n    assert is_balanced(root) == True\n\n    root.left.right.right.right = TreeNode(8)\n    assert is_balanced(root) == False\n\n    root.left.right.right.right.right = TreeNode(9)\n    assert is_balanced(root) == True\n\n    root.left.right.right.right.left = TreeNode(10)\n    assert is_balanced(root) == False\n\n    root.left.right.right.right.left.right = TreeNode(11)\n    assert is_balanced(root) == True",
      -5.42578125
    ],
    [
      "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef check_balanced_tree(root: TreeNode) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    Recursive approach\n    \"\"\"\n    def check_balanced(root: TreeNode) -> bool:\n        if root is None:\n            return True\n\n        left_height = get_height(root.left)\n        right_height = get_height(root.right)\n\n        if abs(left_height - right_height) > 1:\n            return False\n\n        return check_balanced(root.left) and check_balanced(root.right)\n\n    def get_height(root: TreeNode) -> int:\n        if root is None:\n            return 0\n\n        return 1 + max(get_height(root.left), get_height(root.right))\n\n    return check_balanced(root)\n\ndef check_balanced_tree_2(root: TreeNode) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    Iterative approach\n    \"\"\"\n    if root is None:\n        return True\n\n    stack = [root]\n    heights = []\n    while stack:\n        node = stack.pop()\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n        if stack:\n            heights.append(get_height(node, stack[-1]))\n        else:\n            heights.append(0)\n\n    for i in range(1, len(heights)):\n        if abs(heights[i] - heights[i-1]) > 1:\n            return False\n\n    return True\n\ndef get_height(node: TreeNode, parent: TreeNode) -> int:\n    height = 0\n    while node is not None:\n        if node is parent:\n            break",
      -5.4765625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root: TreeNode) -> bool:\n    \"\"\"\n    time: O(n)\n    space: O(n)\n    \"\"\"\n    def check_balanced(root):\n        nonlocal balanced\n        if not root:\n            return 0\n        left_depth = check_balanced(root.left) + 1\n        right_depth = check_balanced(root.right) + 1\n        if abs(left_depth - right_depth) > 1:\n            balanced = False\n        return max(left_depth, right_depth)\n\n    balanced = True\n    check_balanced(root)\n    return balanced\n\n\ndef main():\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.left.left = TreeNode(4)\n  root.left.right = TreeNode(5)\n  root.right.left = TreeNode(6)\n  root.right.right = TreeNode(7)\n  root.left.left.left = TreeNode(8)\n  root.left.left.right = TreeNode(9)\n  root.left.left.right.left = TreeNode(10)\n  root.left.left.right.right = TreeNode(11)\n  root.right.right.left = TreeNode(12)\n  root.right.right.right = TreeNode(13)\n  root.right.right.left.left = TreeNode(14)\n  root.right.right.left.right = TreeNode(15)\n\n  print(is_balanced(root))\n\n\nmain()",
      -5.78125
    ],
    [
      "from gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Node) -> bool:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def get_height(node: Node) -> int:\n        if not node:\n            return 0\n\n        return max(get_height(node.left), get_height(node.right)) + 1\n\n    def is_balanced_helper(node: Node) -> bool:\n        if not node:\n            return True\n\n        left_height = get_height(node.left)\n        right_height = get_height(node.right)\n\n        return abs(left_height - right_height) < 2 and is_balanced_helper(node.left) and is_balanced_helper(node.right)\n\n    return is_balanced_helper(root)\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.left.left.left = Node(8)\n    root.left.right.left = Node(9)\n    root.right.right.right = Node(10)\n    root.left.right.right.left = Node(11)\n    root.left.right.right.right = Node(12)\n    root.right.left.left = Node(13)\n    root.right.left.right = Node(14)\n    root.right.left.left.left = Node(15)\n    root.right.left.left.right = Node(16)\n    root.right.left.right.left = Node(17)\n    root.right.left.right.right = Node(18)\n    print(inorder",
      -6.34375
    ],
    [
      "# Tree Node class is defined at problem_1.py\n\n# First we check if a tree is balanced. Then we do inorder traversal.\n# The first condition is if the tree is balanced.\n# The second condition is if the tree is balanced.\ndef check_balanced(root):\n    if not root:\n        return True\n    return check_balanced(root.left) and check_balanced(root.right)\n\ndef check_balanced_inorder(root):\n    if check_balanced(root):\n        inorder_traversal(root)\n    else:\n        print(\"Tree is not balanced\")\n\ndef inorder_traversal(root):\n    if not root:\n        return\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)\n\n# Time complexity is O(n). We need to visit every node.\n# Space complexity is O(log n). We are creating a stack for the recursion.\n\n# A better approach is to use preorder traversal.\n\n# 1. Check if tree is balanced or not\n# 2. If tree is balanced, do inorder traversal\ndef check_balanced_inorder_preorder(root):\n    if check_balanced(root):\n        inorder_traversal_preorder(root)\n    else:\n        print(\"Tree is not balanced\")\n\ndef inorder_traversal_preorder(root):\n    if not root:\n        return\n    print(root.val)\n    inorder_traversal_preorder(root.left)\n    inorder_traversal_preorder(root.right)\n\n# Time complexity is O(n). We need to visit every node.\n# Space complexity is O(log n). We are creating a stack for the recursion.",
      -7.08203125
    ],
    [
      "from project.tree import Node, Tree\n\n\ndef check_balanced(tree):\n    \"\"\"Check if tree is balanced.\"\"\"\n    return _check_balanced(tree.root)[0]\n\n\ndef _check_balanced(node):\n    \"\"\"Check if node is balanced.\"\"\"\n    if not node:\n        return True, 0\n    if not node.left and not node.right:\n        return True, 1\n    if not node.left:\n        balanced, height = _check_balanced(node.right)\n        return balanced and height == 1, 1 + height\n    if not node.right:\n        balanced, height = _check_balanced(node.left)\n        return balanced and height == 1, 1 + height\n    balanced, height = _check_balanced(node.left)\n    if not balanced:\n        return False, 1\n    balanced, height = _check_balanced(node.right)\n    return balanced and height == 1, 1 + height\n\n\ndef test_check_balanced():\n    \"\"\"Test check_balanced.\"\"\"\n    tree = Tree()\n    assert check_balanced(tree) is True\n\n    tree = Tree()\n    tree.insert(Node(1))\n    assert check_balanced(tree) is True\n\n    tree = Tree()\n    tree.insert(Node(1))\n    tree.insert(Node(2))\n    assert check_balanced(tree) is True\n\n    tree = Tree()\n    tree.insert(Node(1))\n    tree.insert(Node(2))\n    tree.insert(Node(3))\n    assert check_balanced(tree) is True\n\n    tree = Tree()\n    tree.insert(Node(1))\n    tree.insert(Node(2))\n    tree.insert(Node(3))\n    tree.insert(Node(4))\n    assert check_balanced(tree) is True\n\n    tree = Tree()\n    tree.insert(Node(1))\n    tree.insert(Node(2))\n    tree.insert(Node(3))\n    tree.insert(Node(4))\n    tree.insert(",
      -7.5625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left = None\n    self.right = None\n\n\ndef is_balanced(root):\n  def get_height(root):\n    if not root:\n      return 0\n    return max(get_height(root.left), get_height(root.right)) + 1\n\n  def is_balanced_helper(root):\n    if not root:\n      return True\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    if abs(left_height - right_height) > 1:\n      return False\n    return is_balanced_helper(root.left) and is_balanced_helper(root.right)\n\n  return is_balanced_helper(root)\n\n\ndef main():\n  # 0\n  # |\n  # 1\n  # |\n  # 2\n  # |\n  # 3\n  # |\n  # 4\n  # |\n  # 5\n  # |\n  # 6\n  root = TreeNode(0)\n  root.left = TreeNode(1)\n  root.left.left = TreeNode(2)\n  root.left.left.left = TreeNode(3)\n  root.left.left.left.left = TreeNode(4)\n  root.left.left.left.left.left = TreeNode(5)\n  root.left.left.left.left.left.left = TreeNode(6)\n\n  # 0\n  # |\n  # 1\n  # |\n  # 2\n  # |\n  # 3\n  # |\n  # 4\n  # |\n  # 5\n  # |\n  # 6\n  # |\n  # 7\n  root2 = TreeNode(0)\n  root2.left = TreeNode(1)\n  root2.left.left = TreeNode(2)\n  root2.left.left.left = TreeNode(3)\n  root2.left.left.left.left = TreeNode(4)",
      -9.640625
    ],
    [
      "from collections import deque\n\n\nclass TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\ndef is_balanced(root):\n\n    def get_height(root):\n        if not root:\n            return 0\n\n        return max(get_height(root.left), get_height(root.right)) + 1\n\n    def check(root):\n        if not root:\n            return True\n\n        left = get_height(root.left)\n        right = get_height(root.right)\n        if abs(left - right) > 1:\n            return False\n\n        return check(root.left) and check(root.right)\n\n    return check(root)\n\n\ndef main():\n  # 2\n  # |\n  # 2\n  # |\n  # 3\n  root = TreeNode(2)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 2\n  # |\n  # 2\n  # |\n  # 2\n  root = TreeNode(2)\n  root.left = TreeNode(2)\n  root.right = TreeNode(2)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # |\n  # 2\n  # |\n  # 3\n  # |\n  # 4\n  # |\n  # 4\n  root = TreeNode(1)\n  root.left = TreeNode(2)\n  root.right = TreeNode(3)\n  root.right.left = TreeNode(4)\n  root.right.right = TreeNode(4)\n  print(\"Tree is balanced: \" + str(is_balanced(root)))\n\n  # 1\n  # |\n  # 2\n  # |\n  # 3\n  # |\n  # 4\n  # |\n  # 5\n  root = TreeNode(1)\n  root",
      -9.890625
    ],
    [
      "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Tree:\n    def __init__(self):\n        self.root = None\n\n    def add(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n            return\n\n        q = [(self.root, 1)]\n\n        while q:\n            node, level = q.pop(0)\n\n            if not node.left:\n                node.left = TreeNode(val)\n                break\n            else:\n                q.append((node.left, level + 1))\n\n            if not node.right:\n                node.right = TreeNode(val)\n                break\n            else:\n                q.append((node.right, level + 1))\n\n    def is_balanced(self):\n        def _is_balanced(root):\n            if not root:\n                return (True, 0)\n\n            bal, lh = _is_balanced(root.left)\n            if not bal:\n                return (False, 0)\n\n            rh = _is_balanced(root.right)\n            if not rh:\n                return (False, 0)\n\n            return (abs(lh - rh) <= 1, 1 + max(lh, rh))\n\n        return _is_balanced(self.root)\n\n\nif __name__ == \"__main__\":\n    # fmt: off\n    test_cases = [\n        [],\n        [1, 2, 2, 3, 4, 4],\n        [1, 2, 2, 3, 4, 4, 5],\n    ]\n    results = [\n        (True, 0),\n        (True, 2),\n        (False, 0),\n    ]\n    # fmt: on\n\n    app = Tree()\n    for test_case, correct_result in zip(test_cases, results):\n        for num in test_case:\n            app.add(num)\n        assert app.is_balanced() ==",
      -10.2265625
    ],
    [
      "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef is_balanced(root):\n    if root is None:\n        return True\n    return is_balanced_helper(root) != -1\n\ndef is_balanced_helper(root):\n    if root is None:\n        return 0\n\n    left_height = is_balanced_helper(root.left)\n    if left_height == -1:\n        return -1\n\n    right_height = is_balanced_helper(root.right)\n    if right_height == -1:\n        return -1\n\n    if abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\ndef is_balanced_queue(root):\n    if root is None:\n        return True\n\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n        if node.left and node.left.val <= node.val:\n            return False\n        if node.right and node.right.val >= node.val:\n            return False\n    return True\n\n# Tests\na = TreeNode(1)\nb = TreeNode(2)\nc = TreeNode(3)\nd = TreeNode(4)\ne = TreeNode(5)\nf = TreeNode(6)\ng = TreeNode(7)\na.left = b\na.right = c\nb.left = d\nb.right = e\nc.left = f\nc.right = g\nassert is_balanced(a)\nassert not is_balanced_queue(a)",
      -10.890625
    ],
    [
      "from typing import Optional\n\nfrom gfg.trees.binary_tree_node import Node  # type: ignore\nfrom gfg.trees.tree_traversal import inorder  # type: ignore\n\n\ndef is_balanced(root: Optional[Node]) -> bool:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n\n    def _is_balanced(node: Optional[Node]) -> tuple[bool, int, int]:\n        if not node:\n            return True, 0, 0\n\n        is_left_balanced, left_height, left_width = _is_balanced(node.left)\n        if not is_left_balanced:\n            return False, 0, 0\n\n        is_right_balanced, right_height, right_width = _is_balanced(node.right)\n        if not is_right_balanced:\n            return False, 0, 0\n\n        height = max(left_height, right_height) + 1\n        width = left_width + right_width + 1\n        is_balanced = abs(left_width - right_width) <= 1\n\n        return is_balanced, height, width\n\n    _, _, width = _is_balanced(root)\n\n    return width > 0\n\n\nif __name__ == \"__main__\":\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    root.right.left.right = Node(8)\n    root.right.right.right = Node(9)\n    root.right.right.right.right = Node(10)\n\n    print(is_balanced(root))",
      -10.9140625
    ],
    [
      "class TreeNode:\n  def __init__(self, val):\n    self.val = val\n    self.left, self.right = None, None\n\n\ndef is_balanced(root):\n  return height(root) != -1\n\n\ndef height(root):\n  if not root:\n    return 0\n  lh = height(root.left)\n  if lh == -1:\n    return -1\n  rh = height(root.right)\n  if rh == -1:\n    return -1\n  if abs(lh - rh) > 1:\n    return -1\n  return max(lh, rh) + 1\n\n\ndef is_balanced_iter(root):\n  if not root:\n    return True\n  stack = [(root, 0)]\n  while stack:\n    node, depth = stack.pop()\n    left_depth = depth + 1\n    if not node.left and not node.right:\n      continue\n    if node.left and node.right:\n      stack.append((node.left, left_depth))\n      stack.append((node.right, left_depth))\n      continue\n    if node.left:\n      if depth + 1 != height(node.left):\n        return False\n      stack.append((node.left, left_depth))\n      continue\n    if node.right:\n      if depth + 1 != height(node.right):\n        return False\n      stack.append((node.right, left_depth))\n  return True\n\n\nimport pdb\n\npdb.set_trace()",
      -11.84375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}