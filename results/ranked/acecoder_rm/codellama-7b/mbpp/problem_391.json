{
  "problem": {
    "task_id": "MBPP/402",
    "prompt": "Write a function to compute the value of ncr%p.",
    "canonical_solution": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ",
    "test_list": [
      "assert ncr_modp(10,2,13)==6",
      "assert ncr_modp(15,12,43)==25",
      "assert ncr_modp(17,9,18)==10"
    ],
    "challenge_test_list": [],
    "problem_id": 391
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r == 1 or r == n - 1:\n        return n\n\n    return (ncr(n - 1, r - 1, p) % p) * (n - 1) % p\n\n\nprint(ncr(50, 25, 1000000007))",
      3.859375
    ],
    [
      "def calculate_ncr(n, r, p):\n    if r > n or r < 0 or n < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if r > n - r:\n        r = n - r\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = numerator * (n - r + i + 1)\n        denominator = denominator * (i + 1)\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nprint(calculate_ncr(10, 2, 3))\nprint(calculate_ncr(30, 10, 3))\nprint(calculate_ncr(1000, 100, 101))",
      3.2109375
    ],
    [
      "def compute(n, r, p):\n    if r == 0:\n        return 1\n    return compute(n - 1, r - 1, p) * (n - r + 1) % p\n\n\nif __name__ == \"__main__\":\n    print(compute(10, 3, 100))",
      2.451171875
    ],
    [
      "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return (ncr(n-1, r-1, p) % p) * (n-r+1) % p\n\nif __name__ == '__main__':\n    print(ncr(1000, 100, 13))",
      2.06640625
    ],
    [
      "import math\n\n\ndef factorial(n):\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact\n\n\ndef nCr(n, r):\n    ncr = factorial(n) // (factorial(r) * factorial(n - r))\n    return ncr\n\n\ndef modular_exponentiation(a, b, p):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return (modular_exponentiation(a, b / 2, p) ** 2) % p\n    else:\n        return ((a % p) * (modular_exponentiation(a, b / 2, p) ** 2)) % p\n\n\ndef nCr_mod_p(n, r, p):\n    return nCr(n, r) % p\n\n\nif __name__ == \"__main__\":\n    print(modular_exponentiation(2, 5, 13))\n    print(nCr_mod_p(10, 5, 13))",
      1.708984375
    ],
    [
      "def combination_mod_p(n, r, p):\n    return (\n        fact(n - r + 1, p) * fact(r, p) * fact(n + 1, p)\n    ) % p\n\n\ndef fact(n, p):\n    return (\n        (\n            (n % p) *\n            fact(n - 1, p)\n        ) % p\n    ) if n else 1\n\n\ndef main():\n    print(combination_mod_p(4, 2, 13))\n\n\nif __name__ == '__main__':\n    main()",
      1.5654296875
    ],
    [
      "def ncr(n,r,p):\n    if r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)%p*n%p)%p\n\nprint(ncr(5,2,13))",
      1.455078125
    ],
    [
      "import math\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n: int, r: int, p: int) -> int:\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    return ncr(n - 1, r - 1, p) * n // r % p\n\n\nif __name__ == \"__main__\":\n    mod = 1000000007\n    print(ncr(40, 20, mod))",
      1.330078125
    ],
    [
      "def compute_ncr(n, r, p):\n    ncr = (fact(n)//(fact(r)*fact(n-r)))%p\n    return ncr\n\ndef fact(n):\n    fact = 1\n    for i in range(1, n+1):\n        fact *= i\n    return fact\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    result = compute_ncr(n, r, p)\n    print(result)",
      1.3037109375
    ],
    [
      "def ncr(n,r,p):\n    return int((fact(n,p)//(fact(r,p)*fact(n-r,p))))\n\ndef fact(n,p):\n    if n<0:\n        return 0\n    if n==0:\n        return 1\n    return fact(n-1,p)*n%p",
      1.162109375
    ],
    [
      "def ncr(n, r, p):\n    if r>n or r<0:\n        return -1\n    elif r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)*n//r)%p",
      1.1171875
    ],
    [
      "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      0.90673828125
    ],
    [
      "def ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n    return ncr(n - 1, r - 1, p) * n / r % p\n\n\ndef test_ncr():\n    assert ncr(5, 2, 1000) == 100\n    assert ncr(5, 2, 500) == 20",
      0.3486328125
    ],
    [
      "def factorial(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    else:\n        return factorial(n - 1) * n\n\ndef nCr(n, r, p):\n    return (factorial(n)//(factorial(r)*factorial(n-r)))%p\n\nn,r,p = map(int, input().split())\nprint(nCr(n, r, p))",
      0.18115234375
    ],
    [
      "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\ndef main():\n    print(ncr(10, 2, 7))\n\n\nif __name__ == \"__main__\":\n    main()",
      0.1563720703125
    ],
    [
      "def ncr_mod_p(n, r, p):\n    \"\"\"\n    Calculate nCr%p\n    \"\"\"\n    # nCr%p = (n!%p * r!%p)%p / (n-r)!%p\n    n_factorial = factorial_mod_p(n, p)\n    r_factorial = factorial_mod_p(r, p)\n    n_minus_r_factorial = factorial_mod_p(n-r, p)\n\n    return (n_factorial * r_factorial) % p // n_minus_r_factorial\n\n\ndef factorial_mod_p(n, p):\n    \"\"\"\n    Calculate n!%p\n    \"\"\"\n    result = 1\n    for i in range(1, n+1):\n        result = (result * i) % p\n\n    return result",
      0.052215576171875
    ],
    [
      "from math import factorial\n\n\ndef ncr_mod_p(n, r, p):\n    n_fact = factorial(n)\n    r_fact = factorial(r)\n    n_min_r_fact = factorial(n - r)\n    return (n_fact * r_fact) % p * n_min_r_fact % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod_p(10, 5, 1000000007))",
      -0.06365966796875
    ],
    [
      "class Solution:\n    def nCrModp(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        MOD = 10 ** 9 + 7\n\n        def ncr(n, r):\n            if r == 0:\n                return 1\n            if r == n:\n                return 1\n            if r > n:\n                return 0\n            if r == 1 or r == n - 1:\n                return n\n\n            return ncr(n - 1, r - 1) + ncr(n - 1, r)\n\n        return ncr(n, r) % MOD\n\n\nif __name__ == \"__main__\":\n    n = 24\n    r = 10\n    p = 1000000007\n    print(Solution().nCrModp(n, r, p))",
      -0.166748046875
    ],
    [
      "def nCrmodp(n,r,p):\n    if n < 0 or r < 0 or p == 0:\n        return 0\n    if n-r < r:\n        return nCrmodp(n,n-r,p)\n    a = 1\n    b = 1\n    for i in range(r):\n        a = a*(n-i)\n        b = b*(r-i)\n    return (a%p*pow(b%p,p-2,p)%p)%p\n\nn = 1000\nr = 400\np = 13\nprint(nCrmodp(n,r,p))",
      -0.2080078125
    ],
    [
      "def ncr(n, r, p):\n    # Write your code here\n    num = fact(n) // (fact(r) * fact(n - r))\n    den = fact(p) // (fact(p - r) * fact(r))\n    return num % den\n\n\ndef fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)",
      -0.2587890625
    ],
    [
      "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n - r == 1:\n        return n % p\n    return (ncr(n - 1, r - 1, p) * n % p) // r % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      -0.333251953125
    ],
    [
      "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(ncr(n, r, p))",
      -0.376220703125
    ],
    [
      "def compute(n, r, p):\n    return (ncr(n, r) % p)\n\n\ndef ncr(n, r):\n    if n < r:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    return ncr(n-1, r-1) + ncr(n-1, r)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(compute(n, r, p))",
      -0.4150390625
    ],
    [
      "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    elif n - r < r:\n        return ncr(n, n - r, p)\n    else:\n        return (ncr(n - 1, r - 1, p) % p) * (n % p)\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      -0.599609375
    ],
    [
      "def compute_ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    Return ncr%p.\n    \"\"\"\n    if n == 0 or r == 0 or r == n:\n        return 1\n\n    if n - r == 1:\n        return (n % p) * (r % p)\n\n    return (n % p) * compute_ncr(n - 1, r - 1, p) % p\n\n\nif __name__ == \"__main__\":\n    print(compute_ncr(5, 2, 100))",
      -0.6171875
    ],
    [
      "from math import factorial\n\n\ndef nCr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    fact = factorial(n)\n    nPr = factorial(r) * factorial(n - r)\n    return nPr % p\n\n\nif __name__ == \"__main__\":\n    print(nCr(10, 2, 5))",
      -0.833984375
    ],
    [
      "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if (n - r) < r:\n        return ncr(n, n - r, p)\n    return ncr(n - 1, r - 1, p) * n // (r + 1) % p\n\n\nprint(ncr(500, 2, 13))",
      -0.85693359375
    ],
    [
      "from math import factorial\n\n\ndef compute_ncr_mod_p(n: int, r: int, p: int) -> int:\n    \"\"\"\n    This function computes nCr%p.\n    \"\"\"\n    if n < 0 or r < 0 or p < 2:\n        raise ValueError(\"All inputs should be positive\")\n\n    if n < r:\n        raise ValueError(\"n should be greater than or equal to r\")\n\n    if n < p or r < p:\n        raise ValueError(\"n and r should be greater than or equal to p\")\n\n    if r == 0 or r == n:\n        return 1\n\n    result = factorial(n) // (factorial(r) * factorial(n - r))\n    if result >= p:\n        result %= p\n    return result",
      -0.85693359375
    ],
    [
      "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(r) * factorial(n - r)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      -0.85693359375
    ],
    [
      "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n\n    d = n - r\n\n    if d == 0:\n        return 1\n\n    if d == 1:\n        return n\n\n    return (ncr(n - 1, r - 1, p) * n // (d)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = [int(x) for x in input().split()]\n    print(ncr(n, r, p))",
      -0.85693359375
    ],
    [
      "def ncr(n, r, p):\n    return ncr_aux(n, r, p, 1)\n\n\ndef ncr_aux(n, r, p, acc):\n    if n < r:\n        return 0\n    if r == 0:\n        return acc\n    return ncr_aux(n - 1, r - 1, p, (acc * (n - 1) // r) % p)\n\n\nprint(ncr(100000, 10000, 1000000007))",
      -0.85693359375
    ],
    [
      "def find_ncr(n, r, p):\n    \"\"\"\n    >>> find_ncr(3, 2, 10)\n    3\n    >>> find_ncr(4, 2, 10)\n    8\n    >>> find_ncr(5, 2, 10)\n    15\n    \"\"\"\n    if r == 0 or n == r:\n        return 1\n\n    if r > n or r < 0 or p < 0:\n        return 0\n\n    return (find_ncr(n-1, r-1, p) * n) % p\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "def ncr(n, r, p):\n    if r==0:\n        return 1\n    if r==n:\n        return 1\n    else:\n        return (ncr(n-1, r-1, p)*n//r)%p",
      -0.85791015625
    ],
    [
      "def ncr(n, r, p):\n    # n, r, p are positive integers\n    # n \u2265 r\n    # p is a prime number\n    # ncr%p = ncr\n    if n < 0 or r < 0 or p < 0 or n < r:\n        return -1\n    if n == 0 or r == 0:\n        return 1\n    if r == 1:\n        return 1\n    return ncr(n - 1, r - 1, p) * n // r % p\n\n\nif __name__ == \"__main__\":\n    print(ncr(5, 3, 13))",
      -0.85791015625
    ],
    [
      "def modular_ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if n - r == 1:\n        return n\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\nn, r, p = map(int, input().split())\nprint(modular_ncr(n, r, p))",
      -0.85791015625
    ],
    [
      "def nCrmodp(n,r,p):\n    n = n%p\n    r = r%p\n    if n==0 or r==0:\n        return 1%p\n    result = 1\n    for i in range(1,r+1):\n        result = (result*((n-i+1)%p))%p\n        result = (result*(i%p))%p\n    return result%p\n\nn = 100\nr = 10\np = 13\nprint(nCrmodp(n,r,p))",
      -0.85791015625
    ],
    [
      "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    return (ncr(n - 1, r - 1, p) * n) % p\n\n\nprint(ncr(3, 3, 1000))",
      -0.85791015625
    ],
    [
      "def ncr(n, r, p):\n    if r > n:\n        return -1\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r)\n    return (numerator / denominator) % p\n\n\ndef factorial(n):\n    if n < 2:\n        return 1\n    return factorial(n - 1) * n\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      -0.8583984375
    ],
    [
      "def nCrmodp(n,r,p):\n    n,r,p = n%p,r%p,p%n\n    if r==0: return 1\n    if r==n: return 1\n    if r==1: return n\n    return n*nCrmodp(n-1,r-1,p)%p\n\nn,r,p = 10**12,10**12,10**9\nprint(nCrmodp(n,r,p))",
      -0.8583984375
    ],
    [
      "from math import factorial\n\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if r > n:\n        return 0\n    return (factorial(n) * factorial(r) * factorial(n - r)) % p\n\n\nprint(ncr(50, 25, 1000000007))",
      -0.8583984375
    ],
    [
      "import math\n\n\ndef nCr(n, r, p):\n    r = min(r, n - r)\n    numerator = math.factorial(n)\n    denominator = math.factorial(r) * math.factorial(n - r)\n    return (numerator // denominator) % p\n\n\nif __name__ == \"__main__\":\n    n = 10\n    r = 5\n    p = 13\n    print(nCr(n, r, p))",
      -0.8583984375
    ],
    [
      "def ncr(n, r, p):\n    if r>n or r<0:\n        return -1\n    elif r==0:\n        return 1\n    else:\n        numerator = fact(n)\n        denominator = fact(r)*fact(n-r)\n        return (numerator//denominator)%p\n\ndef fact(n):\n    if n<0:\n        return -1\n    elif n==0:\n        return 1\n    else:\n        return n*fact(n-1)\n\ndef main():\n    # Get user input\n    n = int(input(\"Enter n: \"))\n    r = int(input(\"Enter r: \"))\n    p = int(input(\"Enter p: \"))\n\n    # Print result\n    print(ncr(n, r, p))\n\nmain()",
      -0.8583984375
    ],
    [
      "def ncr_mod(n, r, p):\n    return ncr(n, r) % p\n\n\ndef ncr(n, r):\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return ncr(n - 1, r - 1) + ncr(n - 1, r)\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(1000, 300, 1000000007))",
      -0.85888671875
    ],
    [
      "def ncr_mod_p(n, r, p):\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r should be non-negative\")\n\n    if n == 0 or r == 0:\n        return 1\n\n    if n - r < r:\n        r = n - r\n\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n-r)\n\n    return (numerator // denominator) % p\n\ndef factorial(n):\n    if n <= 1:\n        return 1\n\n    return n * factorial(n-1)\n\nprint(ncr_mod_p(20, 10, 1000000007))",
      -0.85888671875
    ],
    [
      "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if (n - r) < r:\n        temp = n\n        n = r\n        r = temp\n    result = 1\n    for i in range(r, n + 1):\n        result = (result * i) % p\n        i -= 1\n        result = (result * i) % p\n    return result\n\n\nprint(ncr(50, 25, 13))",
      -0.85888671875
    ],
    [
      "def nCrmodp(n,r,p):\n    ncr = nCr(n,r)\n    return ncr%p\n\ndef nCr(n,r):\n    if n == r or r == 0:\n        return 1\n    return nCr(n-1, r-1) + nCr(n-1, r)\n\nprint(nCrmodp(1000000, 100000, 1000000007))",
      -0.86083984375
    ],
    [
      "from math import factorial\n\n\ndef ncr_mod(n, r, p):\n    \"\"\"Returns the value of nCr % p.\n\n    Args:\n        n (int): n\n        r (int): r\n        p (int): p\n\n    Returns:\n        int: nCr % p\n    \"\"\"\n    return (\n        factorial(n) * factorial(r) * factorial(n - r)\n    ) % p // factorial(p)\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(30, 15, 13))",
      -0.86083984375
    ],
    [
      "def ncr_mod_p(n, r, p):\n    C = ncr_mod_p_recursive(n, r, p)\n    return C % p\n\n\ndef ncr_mod_p_recursive(n, r, p):\n    if n == r or r == 0:\n        return 1\n    if r == 1:\n        return n\n    return ncr_mod_p_recursive(n - 1, r - 1, p) * n % p",
      -0.86083984375
    ],
    [
      "import math\n\n\ndef ncr_mod_p(n, r, p):\n    \"\"\"\n    Return nCr % p.\n    \"\"\"\n    npr = math.factorial(n) // math.factorial(r) % p\n    npr = npr % p\n    npr = npr * math.factorial(n - r) % p\n    npr = npr % p\n    return npr % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_mod_p(n, r, p))",
      -0.88671875
    ],
    [
      "class Solution(object):\n    def nCrModp(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1: Brute Force\n        Your runtime beats 63.44 % of python submissions.\n\n        The idea is to use the formula: n! / (n-r)! * r! = ncr\n        \"\"\"\n        res = 1\n        for i in range(n - r + 1, n + 1):\n            res = res * i % p\n        for i in range(1, r + 1):\n            res = res * i % p\n        return res",
      -0.90380859375
    ],
    [
      "def nCr(n, r, p):\n    # if nCr is out of range, return 0\n    if (r > n) or (n < 0) or (r < 0) or (p <= 0) or (p > (10**9)+7):\n        return 0\n    # if nCr is within range, compute nCr%p\n    if (n == 0) or (r == 0) or (n == r):\n        return 1\n    # if nCr is within range, compute nCr%p\n    return (nCr(n-1, r, p) + nCr(n-1, r-1, p)) % p",
      -0.96044921875
    ],
    [
      "def ncr_mod_p(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    n_over_r = n - r\n    r_over_n = r - n_over_r\n    return n_over_r * ncr_mod_p(n - 1, r - 1, p) % p * r_over_n % p\n\n\nprint(ncr_mod_p(5, 2, 13))",
      -0.986328125
    ],
    [
      "def ncr_modp(n, r, p):\n    C = (n * (n - 1)) // 2\n    r = min(r, n - r)\n    numerator = C - (n - r) * (n - r - 1) // 2\n    return (numerator * pow(r, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_modp(n, r, p))",
      -0.99755859375
    ],
    [
      "# Solution\ndef nCrModp(n, r, p):\n    \"\"\"\n    The value of nCr%p is calculated using nCr = (nCr0%p + nCr1%p)%p.\n    \"\"\"\n    if(n < 0 or r < 0 or r > n):\n        return -1\n    # Base Case\n    if r == 0 or r == n:\n        return 1\n    \n    # Recursive Case\n    ncr = nCrModp(n-1, r-1, p) * n // r\n    return ncr % p\n\n\n# Test Cases\nprint(\"Enter values of n, r, p:\")\nn = int(input())\nr = int(input())\np = int(input())\nprint(nCrModp(n, r, p))\n\n# Run time complexity: O(n)",
      -1.1669921875
    ],
    [
      "def ncr(n, r, p):\n    if n < r:\n        return 0\n    a = fact(n)\n    b = fact(r)\n    c = fact(n-r)\n    return (a*b) % p // c\n\n\ndef fact(n):\n    ans = 1\n    for i in range(2, n+1):\n        ans *= i\n    return ans\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(ncr(n, r, p))",
      -1.236328125
    ],
    [
      "def ncr_mod_p(n, r, p):\n    C = ncr(n, r)\n    return C % p\n\n\ndef ncr(n, r):\n    if r == 0:\n        return 1\n    if r > n:\n        return 0\n    r = min(r, n - r)\n    numerator = [1]\n    denominator = [1]\n    for i in range(1, r + 1):\n        numerator.append(numerator[-1] * (n - r + i) // i)\n        denominator.append(denominator[-1] * (i) // (n - r + i))\n    return (numerator[-1] * denominator[-1]) % (10**9 + 7)",
      -1.3232421875
    ],
    [
      "def compute_ncr(n, r, p):\n    # Write your code here.\n    npr = ncr(n, r)\n    return npr % p\n\n\ndef ncr(n, r):\n    if r == n:\n        return 1\n    if r == 0:\n        return 1\n    return ncr(n - 1, r) + ncr(n - 1, r - 1)",
      -1.3271484375
    ],
    [
      "def ncr_mod_p(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n == 0:\n        return 0\n    return (ncr_mod_p(n - 1, r - 1, p) % p) * ncr_mod_p(n - 1, r, p) % p\n\n\nif __name__ == '__main__':\n    n, r, p = map(int, input().split())\n    print(ncr_mod_p(n, r, p))",
      -1.42578125
    ],
    [
      "from math import factorial\n\n\ndef ncr(n, r, p):\n    r = min(r, n - r)\n    numerator = factorial(n) // factorial(r) // factorial(n - r)\n    denominator = pow(factorial(r), p - 2, p)\n    return numerator * denominator % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))",
      -1.91015625
    ],
    [
      "# This is the recursive solution\n\n\ndef ncr(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr(n-1, r-1, p) % p * n % p) % p\n\n\n# This is the iterative solution\n\n\ndef ncr2(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        fact = [0] * (r+1)\n        fact[0] = 1\n        for i in range(1, r+1):\n            fact[i] = (fact[i-1] * i) % p\n        return (fact[r] * pow(fact[r-1], p-2, p)) % p\n\n\nprint(ncr(10, 5, 100))\nprint(ncr2(10, 5, 100))",
      -2.33984375
    ],
    [
      "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    if r == n:\n        return 1\n    return (ncr(n-1, r-1, p) * n % p * (n-r+1) % p) % p\n\n\nif __name__ == \"__main__\":\n    n = 1000000007\n    r = 2500000000\n    p = 1000000009\n    print(ncr(n, r, p))",
      -2.4765625
    ],
    [
      "class Solution:\n    def ncr(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if r > n:\n            return 0\n\n        if r == 0:\n            return 1\n\n        if r == 1:\n            return n % p\n\n        # n!/r!(n-r)!\n        numerator = 1\n        denominator = 1\n\n        for i in range(min(r, n - r)):\n            numerator *= (n - i)\n            denominator *= (r - i)\n\n        return numerator / denominator % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n\n    n = 50\n    r = 25\n    p = 13\n    print(solution.ncr(n, r, p))",
      -2.54296875
    ],
    [
      "def ncr(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr(n - 1, r - 1, p) % p) * (n - 1) % p\n\n\ndef ncr_mod(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr_mod(n - 1, r - 1, p) * (n - 1) % p) % p",
      -2.595703125
    ],
    [
      "class Solution(object):\n    def getModulo(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n < 0 or r < 0 or p < 0:\n            return -1\n\n        if n - r < r:\n            r = n - r\n\n        res = 1\n        for i in range(r):\n            res = res * (n - i) % p\n            res = res * (i + 1) % p\n\n        return res % p\n\n\na = Solution()\nprint(a.getModulo(1000000007, 382, 499999937))",
      -2.740234375
    ],
    [
      "def ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    >>> ncr(5, 2, 10)\n    2\n    >>> ncr(5, 3, 10)\n    1\n    \"\"\"\n    if n == r or r == 0:\n        return 1\n\n    numerator = fact(n)\n    denominator = fact(r) * fact(n - r)\n\n    return pow(numerator / denominator, p, p)\n\n\ndef fact(n: int) -> int:\n    \"\"\"\n    >>> fact(5)\n    120\n    \"\"\"\n    ans = 1\n\n    while n > 0:\n        ans *= n\n        n -= 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -2.8046875
    ],
    [
      "class Solution(object):\n    def find_ncr(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or r == 0:\n            return 1\n        if n == r:\n            return 1\n        if n < r:\n            return 0\n        if n - r < r:\n            return self.find_ncr(n - 1, r - 1, p)\n        return self.find_ncr(n - 1, r, p) * self.find_ncr(n - 1, r - 1, p) % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.find_ncr(100, 10, 3)",
      -2.986328125
    ],
    [
      "def compute_ncr(n, r, p):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    a = 1\n    for i in range(r):\n        a = (a * (n - i)) % p\n    b = 1\n    for i in range(r):\n        b = (b * (r - i)) % p\n    return (a * pow(b, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(compute_ncr(n, r, p))",
      -2.990234375
    ],
    [
      "def ncr_mod(n, r, p):\n    \"\"\"\n    ncr%p = (n!%p * r!%p * (n-r)!%p)%p\n    \"\"\"\n    if n < 0 or r < 0 or p < 0:\n        return -1\n    if r > n:\n        return 0\n\n    # factorial % p\n    def factorial(n):\n        res = 1\n        for i in range(2, n+1):\n            res = (res * i) % p\n        return res\n\n    return (factorial(n) * factorial(r) * factorial(n - r) % p) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_mod(n, r, p))",
      -3.099609375
    ],
    [
      "def ncr(n, r, p):\n    if r>n or n<0 or r<0 or p<=0:\n        return -1\n    elif r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)%p*n%p)%p*(ncr(n-1,r,p)%p)%p\n\n\nt = int(input())\nfor _ in range(t):\n    n,r,p = map(int, input().split())\n    ans = ncr(n,r,p)\n    print(ans)",
      -3.40234375
    ],
    [
      "def combination_mod_p(n, r, p):\n    return combination_mod_p_helper(n, r, p, 1, 1)\n\n\ndef combination_mod_p_helper(n, r, p, n_factorial, r_factorial):\n    if r == 0:\n        return 1\n    if r == 1:\n        return n_factorial % p\n    if (n - r) < r:\n        return combination_mod_p_helper(n, n - r, p, n_factorial, r_factorial)\n    return (\n        combination_mod_p_helper(n, r - 1, p, n_factorial, r_factorial) *\n        (n / r) % p\n    )\n\n\ndef test(n, r, p, expected_answer):\n    if expected_answer != combination_mod_p(n, r, p):\n        raise AssertionError(\n            f\"Expected {expected_answer}; got {combination_mod_p(n, r, p)}\"\n        )\n\n\nif __name__ == \"__main__\":\n    test(10, 5, 100, 252)\n    test(10, 7, 100, 45)\n    test(20, 10, 100, 184756)\n    print(\"OK\")",
      -3.447265625
    ],
    [
      "# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef nCrModP(n, r, p):\n    # If n < r, return 0\n    if n < r:\n        return 0\n    # If n = r or r = 0, return 1\n    if n == r or r == 0:\n        return 1\n    \n    # Compute nCr and return the value\n    ncr = 1\n    rcr = 1\n    for i in range(r):\n        ncr = (ncr * (n - i)) % p\n        rcr = (rcr * (r - i)) % p\n    \n    return (ncr * pow(rcr, p - 2, p)) % p\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef nCrModP2(n, r, p):\n    # If n < r, return 0\n    if n < r:\n        return 0\n    # If n = r or r = 0, return 1\n    if n == r or r == 0:\n        return 1\n\n    # Compute nCr and return the value\n    ncr = [0] * (r + 1)\n    ncr[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            ncr[j] = (ncr[j] + ncr[j - 1]) % p\n    return ncr[r]\n\n# Tests\nt = {\n    \"Basic\": [\n        {\n            \"input\": [5, 2, 13],\n            \"answer\": 1\n        },\n        {\n            \"input\": [10, 2, 13],\n            \"answer\": 4\n        },\n        {\n            \"input\": [50, 25, 13],\n            \"answer\": 4\n        },\n        {\n            \"input\": [50, 25, 7],\n            \"answer\": 1\n        },\n        {\n            \"",
      -3.5703125
    ],
    [
      "def ncr(n, r, p):\n    if r > n:\n        return 0\n    r = min(r, n - r)\n    a = 1\n    for i in range(r + 1, n + 1):\n        a *= i\n        a %= p\n    b = 1\n    for i in range(1, n - r + 1):\n        b *= i\n        b %= p\n    return a * pow(b, p - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr(40, 20, 13))",
      -3.728515625
    ],
    [
      "def nCrmodp(n, r, p):\n    # Write your code here\n    n_factorial = 1\n    r_factorial = 1\n    p_factorial = 1\n    for i in range(1, n+1):\n        n_factorial = (n_factorial * i) % p\n    for i in range(1, r+1):\n        r_factorial = (r_factorial * i) % p\n    for i in range(1, n-r+1):\n        p_factorial = (p_factorial * i) % p\n    return (n_factorial * pow(r_factorial, p-2, p) * p_factorial) % p",
      -3.732421875
    ],
    [
      "# Recursion + Memoization\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    if (n, r) in memo:\n        return memo[(n, r)]\n\n    memo[(n, r)] = ncr(n-1, r, p) + ncr(n-1, r-1, p)\n    return memo[(n, r)] % p\n\n# Dynamic Programming\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    memo = [0] * (n+1)\n\n    for i in range(n+1):\n        memo[i] = [0] * (r+1)\n\n    for i in range(n+1):\n        memo[i][0] = 1\n\n    for i in range(1, r+1):\n        memo[0][i] = 0\n\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            memo[i][j] = (memo[i-1][j] + memo[i-1][j-1]) % p\n\n    return memo[n][r]\n\n# Iterative\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    res = 1\n    for i in range(1, min(n - r, r) + 1):\n        res = (res * n) // i\n        n -= 1\n\n    return res % p\n\n# Recursion\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    return (ncr(n-1, r-1, p) * n",
      -3.796875
    ],
    [
      "def nCr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = 25, 10, 13\n    print(nCr(n, r, p))",
      -3.869140625
    ],
    [
      "def combination_mod_p(n, r, p):\n    # n, r, p all in range [0, 1000000007]\n    n = min(n, r)\n    if n == 0:\n        return 1\n    if n == 1 or r == 1:\n        return 1\n    numerator = combination_mod_p(n - 1, r - 1, p)\n    denominator = combination_mod_p(n, r, p)\n    return (numerator * denominator) % p\n\n\nif __name__ == \"__main__\":\n    print(combination_mod_p(4, 2, 1000000007))",
      -4.0234375
    ],
    [
      "def compute(n, r, p):\n    \"\"\"\n    Compute ncr%p.\n    :param n: Number of elements.\n    :param r: Number of combinations.\n    :param p: Modulo value.\n    :return: ncr%p\n    \"\"\"\n    ncr = n\n    for i in range(1, r):\n        ncr = (ncr * (n - i)) % p\n    return ncr",
      -4.05859375
    ],
    [
      "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\ndef ncr_modp(n, r, p):\n    return factorial(n) * pow(factorial(r), p - 2, p) * pow(factorial(n - r), p - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_modp(100, 50, 1000000007))",
      -4.1640625
    ],
    [
      "def nCr(n, r, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if n < r:\n        return -1\n\n    if r == 0 or r == n:\n        return 1\n\n    fact = [1] * (n + 1)\n    fact[0] = fact[1] = 1\n\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i\n\n    numerator = fact[n]\n    for i in range(1, r + 1):\n        numerator = numerator // fact[i]\n\n    denominator = fact[r]\n    for i in range(1, n - r + 1):\n        denominator = denominator // fact[i]\n\n    return numerator * denominator % p",
      -4.203125
    ],
    [
      "def ncr_mod(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    if (n-r) < r:\n        return ncr_mod(n, n-r, p)\n    return (ncr_mod(n-1, r-1, p) * (n-1) % p) % p\n\nncr_mod(100, 40, 1000000007)",
      -5.30078125
    ],
    [
      "def nCrmodp(n,r,p):\n    n_fact = 1\n    r_fact = 1\n    p_fact = 1\n    i = 1\n    while i<=n:\n        n_fact = (n_fact*i)%p\n        i+=1\n    i = 1\n    while i<=r:\n        r_fact = (r_fact*i)%p\n        i+=1\n    i = 1\n    while i<=n-r:\n        p_fact = (p_fact*i)%p\n        i+=1\n    return (n_fact*((r_fact%p)*(p_fact%p))%p)%p\n\n\nif __name__ == '__main__':\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(nCrmodp(n,r,p))",
      -5.65625
    ],
    [
      "def find_ncr_p(n, r, p):\n    if r > n:\n        return -1\n    return find_ncr_p_rec(n, r, p, {})\n\n\ndef find_ncr_p_rec(n, r, p, memo):\n    if (n, r) in memo:\n        return memo[(n, r)]\n    if n == 0 or r == 0:\n        return 1\n    if r == 1:\n        return 1\n    if n == r:\n        return 1\n    if n == r + 1:\n        return 1\n    memo[(n, r)] = (find_ncr_p_rec(n-1, r-1, p, memo) % p * n) % p\n    return memo[(n, r)]\n\n\nprint(find_ncr_p(5, 2, 13))\nprint(find_ncr_p(5, 3, 13))\nprint(find_ncr_p(5, 4, 13))\nprint(find_ncr_p(5, 5, 13))\nprint(find_ncr_p(5, 6, 13))\nprint(find_ncr_p(5, 7, 13))",
      -6.15234375
    ],
    [
      "def compute_value(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    :param n: The number of elements in the set\n    :param r: The number of elements to choose\n    :param p: The prime number\n    :return: The value of ncr%p\n    \"\"\"\n    return _compute_value_helper(n, r, p) % p\n\n\ndef _compute_value_helper(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p recursively.\n\n    :param n: The number of elements in the set\n    :param r: The number of elements to choose\n    :param p: The prime number\n    :return: The value of ncr%p\n    \"\"\"\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    if n - r == 1:\n        return n\n    if n - r == 2:\n        return n * (n - 1) // 2\n\n    return _compute_value_helper(n - 1, r - 1, p) * n // (n - r)\n\n\nif __name__ == \"__main__\":\n    assert compute_value(20, 10, 13) == 12210",
      -6.1875
    ],
    [
      "def compute_ncr(n, r, p):\n    \"\"\"Compute the value of ncr%p.\n\n    Args:\n        n (int): The number of items.\n        r (int): The number of items to choose.\n        p (int): The modulo value.\n\n    Returns:\n        int: The value of ncr%p.\n    \"\"\"\n    if r > n:\n        return 0\n\n    # n! = (n - 1)! * n\n    n_factorial = 1\n    for i in range(1, n + 1):\n        n_factorial *= i\n\n    # r! = (r - 1)! * r\n    r_factorial = 1\n    for i in range(1, r + 1):\n        r_factorial *= i\n\n    # (n - r)! = (n - r - 1)! * (n - r)\n    n_minus_r_factorial = 1\n    for i in range(1, n - r + 1):\n        n_minus_r_factorial *= i\n\n    return (n_factorial * n_minus_r_factorial) // (r_factorial * p)\n\ndef main():\n    \"\"\"Print the results of computing the value of ncr%p.\"\"\"\n    print(compute_ncr(50, 25, 1000000007))\n\nif __name__ == '__main__':\n    main()",
      -6.72265625
    ],
    [
      "def find_ncr(n, r, p):\n    if r > n or n < 0 or r < 0 or p <= 0:\n        return -1\n    if r == 0:\n        return 1\n    if r == n:\n        return 1\n    if r == 1:\n        return n\n    return (find_ncr(n-1, r-1, p) % p) * (n % p)\n\n\nif __name__ == \"__main__\":\n    print(find_ncr(10, 2, 7))",
      -6.984375
    ],
    [
      "# O(n) time | O(1) space\ndef nCrModP(n, r, p):\n    if r > n:\n        return 0\n    n_choose_r = 1\n    r_choose_r = 1\n    for i in range(r):\n        n_choose_r = n_choose_r * (n - i)\n        r_choose_r = r_choose_r * (r - i)\n        n_choose_r = n_choose_r // (i + 1)\n        r_choose_r = r_choose_r // (i + 1)\n    return n_choose_r * r_choose_r % p",
      -7.421875
    ],
    [
      "def ncr(n, r, p):\n    if r == 0 or n == r:\n        return 1\n    return (ncr(n-1, r-1, p) * n % p) % p\n\n\nn, r, p = 21, 11, 1000000007\nprint(ncr(n, r, p))\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr % p\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p",
      -7.4453125
    ],
    [
      "class Solution:\n    def modulo(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if r == 0:\n            return 1\n        if r > n:\n            return 0\n\n        return self.modulo(n, n - r, p) * self.modulo(r, r - 1, p) % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.modulo(12, 6, 5))",
      -7.61328125
    ],
    [
      "# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef ncr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    elif r == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(n - r + 1, n + 1):\n            numerator *= i\n            denominator *= r\n        return numerator % p // denominator % p\n\n\nprint(ncr_mod_p(3, 2, 13))\nprint(ncr_mod_p(50, 25, 13))\nprint(ncr_mod_p(100, 50, 13))",
      -7.65625
    ],
    [
      "def ncr_mod_p(n, r, p):\n    if r == 0:\n        return 1\n    return ncr_mod_p(n, r-1, p) * (n-r+1) * pow(10, 9) * (pow(10, 9) - n + r) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod_p(10, 1, 1000000007))",
      -7.9375
    ],
    [
      "def ncr_mod(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    n_ = n - r\n    r_ = r - 1\n    n_r_ = n - r_\n    ncr_ = n_ * ncr_mod(n_, r_, p)\n    ncr__ = r_ * ncr_mod(n_, r_, p)\n    return ncr_ % p - ncr__ % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(50, 20, 13))",
      -8.015625
    ],
    [
      "def ncr_p(n, r, p):\n    # n! = n*(n-1)*(n-2)*...*1\n    # ncr = n*(n-1)*...*(n-r+1)/(r!*1*2*...*r)\n    # ncr%p = n*(n-1)*...*(n-r+1)%p * (r!*1*2*...*r)%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * r!%p)%p * (1%p*2%p*...*r%p)%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n\n    if r > n:\n        return 0\n    if r == n:\n        return 1\n    if r == 0:\n        return 1\n\n    # compute n!\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = factorial[i - 1] * i % p\n\n    # compute ncr\n    ncr = [1] * (n + 1)\n    for i in range(1, n + 1):\n        ncr[i] = ncr[i - 1] * (n - i + 1) % p\n\n    return (ncr[r] * (factorial[r] * factorial[n - r]) % p) % p\n\nif __name__ == \"__main__\":\n    print(ncr_p(10,",
      -8.53125
    ],
    [
      "# Solution\ndef combination_mod(n, r, p):\n    r = min(r, n - r)\n    if r == 0:\n        return 1\n    numerator, denominator = 1, 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\n# Tests\ndef test_combination_mod():\n    assert combination_mod(5, 2, 13) == 10\n    assert combination_mod(5, 2, 20) == 4\n    assert combination_mod(5, 3, 10) == 10\n    assert combination_mod(5, 4, 2) == 4\n    assert combination_mod(5, 3, 3) == 0\n    assert combination_mod(7, 3, 1000000007) == 316078578\n\n\nif __name__ == \"__main__\":\n    test_combination_mod()",
      -8.9453125
    ],
    [
      "def ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    >>> ncr(10, 2, 1000000007)\n    499999995\n    >>> ncr(33, 18, 1000000007)\n    618455421\n    \"\"\"\n    if r > n or r < 0:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -10.046875
    ],
    [
      "def ncr_p(n, r, p):\n    if r>n or r<0 or n<0:\n        return -1\n    if r==n:\n        return 1\n    if r==0 or n==r:\n        return 1\n    if r>n-r:\n        r = n-r\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num*n)%p\n        den = (den*(i+1))%p\n    return (num*pow(den, p-2, p))%p\n\nn, r, p = map(int, input().split())\nprint(ncr_p(n, r, p))",
      -10.3984375
    ],
    [
      "# O(n) time | O(n) space\ndef combinationModP(n, r, p):\n    # n = 10, r = 5, p = 13\n    # n - r = 5\n    # n - r = 5 - 1 = 4\n    # n - r = 4 - 2 = 2\n    # n - r = 2 - 3 = -1\n    # n - r = -1 - 4 = -5\n    # n - r = -5 - 5 = -10\n    # n - r = -10 - 6 = -16\n    # n - r = -16 - 7 = -23\n    # n - r = -23 - 8 = -31\n    # n - r = -31 - 9 = -39\n    # n - r = -39 - 10 = -49\n    # n - r = -49 - 11 = -59\n    # n - r = -59 - 12 = -71\n    # n - r = -71 - 13 = -84\n\n    # 10C5 = 10! / (5! * 10 - 5!)\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / (5! * 10 - 5!)\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5! * 10\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 *",
      -11.140625
    ],
    [
      "def nCrmodp(n, r, p):\n    if n < 0 or r < 0 or p <= 0 or n - r < r:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    num = [0 for i in range(n + 1)]\n    den = [0 for i in range(n + 1)]\n    num[0] = 1\n    num[1] = 1\n    den[0] = 1\n    den[1] = 1\n    for i in range(2, n + 1):\n        num[i] = (num[i - 1] * (n - i + 1)) % p\n        den[i] = (den[i - 1] * i) % p\n    result = ((num[n] * pow(den[r], p - 2, p)) % p)\n    return result\n\n\nif __name__ == \"__main__\":\n    n = 2\n    r = 2\n    p = 13\n    print(nCrmodp(n, r, p))",
      -11.6875
    ],
    [
      "def ncr(n, r, p):\n    # We will use ncr = ncr1(n,r) * ncr1(n,r-1)\n    # ncr1(n,r) = ncr1(n-1,r-1) * n/r\n\n    # First we will calculate ncr1(n,r)\n    # We will use DP to solve this sub-problem\n    ncr1 = [[0 for _ in range(r+1)] for _ in range(n+1)]\n\n    # Base Case\n    for i in range(r+1):\n        ncr1[0][i] = 1\n\n    # Induction Step\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            ncr1[i][j] = ncr1[i-1][j] * (i-1)//j\n\n    # Now we will calculate ncr1(n,r-1)\n    ncr1_r_minus_1 = [[0 for _ in range(r)] for _ in range(n+1)]\n\n    # Base Case\n    for i in range(r):\n        ncr1_r_minus_1[0][i] = 1\n\n    # Induction Step\n    for i in range(1, n+1):\n        for j in range(1, r):\n            ncr1_r_minus_1[i][j] = ncr1_r_minus_1[i-1][j-1] * (i-1)//j\n\n    # Calculate ncr%p\n    ans = 1\n    for i in range(r+1):\n        ans = (ans * ncr1[n][i] * ncr1_r_minus_1[n][i]) % p\n\n    return ans\n\n\nprint(ncr(25, 10, 13))",
      -13.5
    ],
    [
      "def nCrmodp(n, r, p):\n    if r > n:\n        return -1\n\n    n_fact = 1\n    r_fact = 1\n    p_fact = 1\n\n    while n > 0:\n        n_fact *= n\n        p_fact *= p\n        n -= 1\n\n    while r > 0:\n        r_fact *= r\n        p_fact *= p\n        r -= 1\n\n    while n_fact * r_fact % p_fact != 0:\n        n_fact *= n\n        p_fact *= p\n\n    return n_fact * r_fact % p_fact\n\n\ndef main():\n    print(nCrmodp(10, 2, 3))\n    print(nCrmodp(10, 3, 3))\n    print(nCrmodp(10, 4, 3))\n    print(nCrmodp(10, 5, 3))\n    print(nCrmodp(10, 6, 3))\n    print(nCrmodp(10, 7, 3))\n    print(nCrmodp(10, 8, 3))\n    print(nCrmodp(10, 9, 3))\n    print(nCrmodp(10, 10, 3))\n\n\nmain()",
      -14.046875
    ],
    [
      "# This is the solution I came up with, but it's not very good.\n# I'm sure there's a way to use modular exponentiation.\n\n# For this problem, I was able to come up with a solution that was much\n# faster than my original solution. This is because I didn't need to\n# compute n! or r! at all.\n\ndef ncr_modp(n, r, p):\n    if r > n:\n        return 0\n\n    if r == 0:\n        return 1\n\n    if n == r:\n        return 1\n\n    # This is the part that makes it much faster.\n    # It's much easier to compute ncr%p than it is to compute n!%p or r!%p.\n    # ncr%p = n!%p * (n-r)!%p / r!%p\n    return (ncr_modp(n-1, r-1, p) * n % p) * pow(n-r, p-2, p) % p\n\ndef main():\n    n = int(input(\"Enter n: \"))\n    r = int(input(\"Enter r: \"))\n    p = int(input(\"Enter p: \"))\n\n    print(ncr_modp(n, r, p))\n\nif __name__ == \"__main__\":\n    main()",
      -14.3359375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}