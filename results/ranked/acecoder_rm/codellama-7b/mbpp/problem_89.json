{
  "problem": {
    "task_id": "MBPP/100",
    "prompt": "Write a function to find the next smallest palindrome of a specified number.",
    "canonical_solution": "import sys\r\ndef next_smallest_palindrome(num):\r\n    numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i",
    "test_list": [
      "assert next_smallest_palindrome(99)==101",
      "assert next_smallest_palindrome(1221)==1331",
      "assert next_smallest_palindrome(120)==121"
    ],
    "challenge_test_list": [],
    "problem_id": 89
  },
  "model_name": "codellama-7b",
  "dataset": "mbpp",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "def is_palindrome(number):\n    return str(number) == str(number)[::-1]\n\n\ndef next_palindrome(number):\n    \"\"\"\n    This is a brute force approach.\n    We start from the number and increment it until we find a palindrome.\n    \"\"\"\n    next_number = number + 1\n    while not is_palindrome(next_number):\n        next_number += 1\n    return next_number\n\n\ndef next_palindrome_2(number):\n    \"\"\"\n    This is a more efficient approach.\n    We first find the next palindrome using a method similar to the one we used for finding the next palindrome.\n    Then we compare the next palindrome with the given number.\n    If the next palindrome is greater than the given number, we return the next palindrome.\n    If the next palindrome is lesser than the given number, we find the next palindrome again but this time starting from\n    the next palindrome.\n    \"\"\"\n    def find_next_palindrome(number):\n        number += 1\n        while not is_palindrome(number):\n            number += 1\n        return number\n\n    next_palindrome = find_next_palindrome(number)\n    if next_palindrome > number:\n        return next_palindrome\n    else:\n        return find_next_palindrome(next_palindrome)\n\n\nif __name__ == \"__main__\":\n    print(next_palindrome_2(123))\n    print(next_palindrome_2(1234))\n    print(next_palindrome_2(12345))\n    print(next_palindrome_2(123456))\n    print(next_palindrome_2(1234567))\n    print(next_palindrome_2(12345678))\n    print(next_palindrome_2(123456789))\n    print(next_palindrome_2(1234567890))",
      3.5234375
    ],
    [
      "def next_smallest_palindrome(num):\n    # Convert the number to a string\n    num_str = str(num)\n    # Reverse the number\n    rev = num_str[::-1]\n    # If the number is a palindrome, return the number itself\n    if num_str == rev:\n        return num\n    # Find the first digit in the reversed number that is greater than the first digit in the original number\n    for i in range(len(num_str)):\n        if num_str[i] < rev[i]:\n            break\n    # Find the next digit in the reversed number that is equal to the first digit in the original number\n    for j in range(i+1, len(num_str)):\n        if num_str[j] == rev[j-i]:\n            break\n    # Add the digits between the two indices to the first index\n    return int(num_str[:i] + rev[j:] + rev[j-1:-i:-1])\n\nprint(next_smallest_palindrome(123))\nprint(next_smallest_palindrome(1020))\nprint(next_smallest_palindrome(10020))",
      2.4765625
    ],
    [
      "class Solution(object):\n    def getNextPalindrome(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        num = str(num)\n        nums = list(num)\n        for i in range(len(nums) // 2):\n            if nums[i] < nums[-i - 1]:\n                nums[i] = nums[-i - 1]\n            else:\n                break\n        nums[-i - 1] = nums[i]\n        if len(nums) % 2 == 0:\n            for i in range(i + 1, len(nums) // 2):\n                nums[i] = nums[-i - 1]\n        else:\n            for i in range(i + 1, len(nums) // 2 + 1):\n                nums[i] = nums[-i]\n        return int(''.join(nums))\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.getNextPalindrome(300))",
      2.33984375
    ],
    [
      "import sys\nfrom typing import Optional\n\n\ndef next_palindrome(number: int) -> Optional[int]:\n    \"\"\"Return the next palindrome of a specified number.\n\n    Args:\n        number (int): the specified number\n\n    Returns:\n        Optional[int]: the next palindrome\n    \"\"\"\n    number_str = str(number)\n    number_list = list(number_str)\n    number_list.reverse()\n    reversed_number_str = \"\".join(number_list)\n\n    if number_str == reversed_number_str:\n        return None\n    elif number_str > reversed_number_str:\n        return int(number_str) + 1\n    else:\n        return int(reversed_number_str) + 10 ** (len(number_str) - 1)\n\n\nif __name__ == \"__main__\":\n    try:\n        number = int(sys.argv[1])\n    except IndexError:\n        number = 123\n    next_palindrome_number = next_palindrome(number)\n    if next_palindrome_number:\n        print(next_palindrome_number)\n    else:\n        print(\"There is no palindrome number after the specified number.\")",
      2.060546875
    ],
    [
      "def find_next_palindrome(num):\n    str_num = str(num)\n    len_num = len(str_num)\n\n    if len_num % 2 == 0:\n        mid_num = len_num / 2\n    else:\n        mid_num = (len_num - 1) / 2\n\n    left_num = str_num[:mid_num]\n    right_num = str_num[mid_num:][::-1]\n\n    if left_num == right_num:\n        if len_num % 2 == 0:\n            return int(str_num + str_num[mid_num-1:][::-1])\n        else:\n            return int(str_num + str_num[mid_num:][::-1])\n\n    if left_num < right_num:\n        return int(str_num + str_num[mid_num-1:][::-1])\n\n    if left_num > right_num:\n        return int(str_num[:mid_num] + right_num)\n\n\nif __name__ == '__main__':\n    num = 325\n    result = find_next_palindrome(num)\n    print(result)",
      1.671875
    ],
    [
      "from typing import Optional\n\n\ndef next_palindrome(number: int) -> Optional[int]:\n    \"\"\"Returns next palindrome of a number.\n\n    Args:\n        number (int): input number.\n\n    Returns:\n        Optional[int]: next palindrome or None if input number is not palindrome.\n    \"\"\"\n    if is_palindrome(number):\n        return number\n\n    return find_next_palindrome(number)\n\n\ndef find_next_palindrome(number: int) -> Optional[int]:\n    \"\"\"Returns next palindrome of a number.\n\n    Args:\n        number (int): input number.\n\n    Returns:\n        Optional[int]: next palindrome or None if input number is not palindrome.\n    \"\"\"\n    n = number + 1\n\n    while not is_palindrome(n):\n        n += 1\n\n    return n\n\n\ndef is_palindrome(number: int) -> bool:\n    \"\"\"Checks if the number is palindrome.\n\n    Args:\n        number (int): input number.\n\n    Returns:\n        bool: True if the number is palindrome, False otherwise.\n    \"\"\"\n    return str(number) == str(number)[::-1]\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 131\n    assert next_palindrome(1331) == 1411\n    assert next_palindrome(1343) == 1441\n    assert next_palindrome(1234) == 1412\n    assert next_palindrome(1221) is None\n    assert next_palindrome(1000000000) == 1000000001",
      1.650390625
    ],
    [
      "def next_palindrome(number: int) -> int:\n    \"\"\"\n    Return the next smallest palindrome of a specified number.\n    Time Complexity: O(1)\n    Space Complexity: O(1)\n    \"\"\"\n    if number % 11 == 0:\n        return number + 11\n    return number + (11 - (number % 11))\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 121\n    assert next_palindrome(121) == 133\n    assert next_palindrome(999) == 1001\n    assert next_palindrome(1001) == 1011\n    assert next_palindrome(1011) == 1111\n    assert next_palindrome(1111) == 1112\n    assert next_palindrome(1112) == 1121",
      1.5009765625
    ],
    [
      "def next_palindrome(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    :param n: the number\n    :return: the next smallest palindrome\n    \"\"\"\n    n_str = str(n)\n    n_len = len(n_str)\n\n    if n_len % 2 == 0:\n        right = n_str[:(n_len // 2)]\n        left = right[::-1]\n    else:\n        right = n_str[:(n_len // 2) + 1]\n        left = right[1:][::-1]\n\n    if int(left + right) <= n:\n        left = str(int(left) + 1)\n\n    return int(left + left[::-1])\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 131\n    assert next_palindrome(121) == 130\n    assert next_palindrome(12) == 21\n    assert next_palindrome(1213) == 1312",
      0.98046875
    ],
    [
      "def next_palindrome(n):\n    if n % 10 == 0:\n        return n + 2\n    else:\n        return n + 1\n\n\ndef next_palindrome_v2(n):\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n    return n\n\n\ndef is_palindrome(n):\n    n_str = str(n)\n    i, j = 0, len(n_str) - 1\n    while i < j:\n        if n_str[i] != n_str[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\n\nif __name__ == \"__main__\":\n    print(next_palindrome(12345))\n    print(next_palindrome_v2(12345))",
      0.8427734375
    ],
    [
      "def next_palindrome(n):\n    n = str(n)\n    rev = n[::-1]\n    if int(n) >= int(rev):\n        return int(n) + int(rev[1:])\n    return int(n) + int(rev[0:len(n)])\n\n\nprint(next_palindrome(123))\nprint(next_palindrome(124))\nprint(next_palindrome(125))\nprint(next_palindrome(12345))\nprint(next_palindrome(123456789))",
      0.828125
    ],
    [
      "def next_palindrome(n):\n    n_str = str(n)\n    n_list = [int(i) for i in n_str]\n    i = len(n_list) - 1\n    j = 0\n    while i >= j:\n        if n_list[i] < n_list[j]:\n            n_list[i] += 1\n            break\n        i -= 1\n        j += 1\n    return int(\"\".join([str(i) for i in n_list]))\n\nprint(next_palindrome(36))",
      0.828125
    ],
    [
      "def next_palindrome(number):\n    \"\"\"Returns the next smallest palindrome of a specified number.\n\n    Time complexity: O(n).\n    Space complexity: O(1).\n    \"\"\"\n    if number <= 10:\n        return 11\n\n    # Iteratively construct the palindrome from the middle outwards.\n    n = number + 1\n    while True:\n        n += 1\n        if is_palindrome(n):\n            return n\n\n\ndef is_palindrome(number):\n    \"\"\"Checks if a number is palindrome.\n\n    Time complexity: O(n).\n    Space complexity: O(1).\n    \"\"\"\n    # Convert number to string.\n    n = str(number)\n\n    # Iteratively check if the first half is equal to the second half.\n    mid = len(n) // 2\n    for i in range(mid):\n        if n[i] != n[-1-i]:\n            return False\n\n    return True\n\n\ndef main():\n    number = 100001\n    print(f'Next smallest palindrome of {number}:')\n    print(next_palindrome(number))\n\n\nif __name__ == '__main__':\n    main()",
      0.58544921875
    ],
    [
      "def find_next_palindrome(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    num_str = str(num)\n    num_list = list(num_str)\n    rev_list = num_list[::-1]\n    for i in range(len(num_list)):\n        if num_list[i] != rev_list[i]:\n            num_list[i] = rev_list[i]\n            break\n    next_num = int(\"\".join(num_list))\n    if next_num <= num:\n        next_num = next_num + 1\n        next_num = int(\"\".join(list(str(next_num))[::-1]))\n    return next_num\n\n\nif __name__ == \"__main__\":\n    print(find_next_palindrome(123))\n    print(find_next_palindrome(1221))\n    print(find_next_palindrome(1021))\n    print(find_next_palindrome(123321))\n    print(find_next_palindrome(123210))\n    print(find_next_palindrome(1232101))\n    print(find_next_palindrome(1012321))",
      0.501953125
    ],
    [
      "def next_smallest_palindrome(number):\n    \"\"\"\n    Finds the next smallest palindrome of a number.\n\n    :param number: number\n    :type number: int\n    :return: next smallest palindrome\n    :rtype: int\n    \"\"\"\n    number_str = str(number)\n    for i in range(len(number_str), 0, -1):\n        if number_str[:i] == number_str[:i][::-1]:\n            return int(number_str[:i] + number_str[i:] + number_str[i::-1])\n\n\ndef test_next_smallest_palindrome():\n    \"\"\"Test\"\"\"\n    assert next_smallest_palindrome(123) == 1221\n    assert next_smallest_palindrome(1331) == 1341\n    assert next_smallest_palindrome(10101) == 11001\n    assert next_smallest_palindrome(102021) == 103031\n    assert next_smallest_palindrome(100100) == 102020\n    assert next_smallest_palindrome(999) == 1001",
      -0.0341796875
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    Finds the next smallest palindrome of a specified number.\n\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(122)\n    123\n    >>> next_palindrome(134)\n    141\n    >>> next_palindrome(144)\n    151\n    >>> next_palindrome(145)\n    152\n    >>> next_palindrome(155)\n    161\n    >>> next_palindrome(166)\n    171\n    >>> next_palindrome(177)\n    181\n    >>> next_palindrome(188)\n    191\n    >>> next_palindrome(199)\n    202\n    >>> next_palindrome(200)\n    202\n    >>> next_palindrome(201)\n    212\n    >>> next_palindrome(212)\n    222\n    >>> next_palindrome(223)\n    232\n    >>> next_palindrome(234)\n    242\n    >>> next_palindrome(244)\n    252\n    >>> next_palindrome(245)\n    253\n    >>> next_palindrome(255)\n    266\n    >>> next_palindrome(266)\n    277\n    >>> next_palindrome(278)\n    288\n    >>> next_palindrome(289)\n    299\n    >>> next_palindrome(299)\n    303\n    >>> next_palindrome(300)\n    303\n    >>> next_palindrome(301)\n    313\n    >>> next_palindrome(312)\n    322\n    >>> next_palindrome(323)\n    333\n    >>> next_palindrome(",
      -0.04412841796875
    ],
    [
      "def next_palindrome(n):\n    n = str(n)\n    n = n[::-1]\n    return n\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == \"1331\"\n    assert next_palindrome(124) == \"1331\"\n    assert next_palindrome(122) == \"122\"\n    assert next_palindrome(1234) == \"1234\"",
      -0.262451171875
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    >>> next_palindrome(123)\n    234\n    >>> next_palindrome(999)\n    1001\n    >>> next_palindrome(99)\n    101\n    >>> next_palindrome(11)\n    121\n    >>> next_palindrome(1221)\n    12321\n    >>> next_palindrome(100000)\n    100010\n    >>> next_palindrome(101010)\n    101110\n    \"\"\"\n    if num <= 10:\n        return 11\n    if num % 10 == 0:\n        return num + 1\n\n    while True:\n        num += 1\n        if is_palindrome(num):\n            return num\n\n\ndef is_palindrome(num: int) -> bool:\n    \"\"\"\n    >>> is_palindrome(12321)\n    True\n    >>> is_palindrome(12345)\n    False\n    \"\"\"\n    rev = 0\n    while num > rev:\n        rev = rev * 10 + num % 10\n        num //= 10\n    return num == rev or num == rev // 10\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.29150390625
    ],
    [
      "def find_next_palindrome(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    n_str = str(n)\n    len_n = len(n_str)\n    if len_n % 2 == 0:\n        mid_n = len_n / 2\n        left_n = n_str[:mid_n]\n        right_n = n_str[mid_n:]\n        right_n = right_n[::-1]\n        return int(left_n + right_n)\n    else:\n        mid_n = (len_n - 1) / 2\n        left_n = n_str[:mid_n]\n        right_n = n_str[mid_n + 1:]\n        right_n = right_n[::-1]\n        return int(left_n + right_n + right_n[0])\n\n\nif __name__ == \"__main__\":\n    print(find_next_palindrome(123))\n    print(find_next_palindrome(121))\n    print(find_next_palindrome(124))\n    print(find_next_palindrome(10))",
      -0.64013671875
    ],
    [
      "from typing import Union\n\n\ndef next_smallest_palindrome(number: int) -> Union[int, None]:\n    \"\"\"Return the next smallest palindrome of a specified number.\n\n    If number is not a palindrome, return the next smallest one.\n    If number is a palindrome, return the next smallest one that is not equal to number.\n    If no such palindrome exists, return None.\n\n    For example:\n    - For number = 123, the next smallest palindrome is 131.\n    - For number = 121, the next smallest palindrome is 131.\n    - For number = 135, the next smallest palindrome is 141.\n    - For number = 145, the next smallest palindrome is 151.\n    - For number = 155, the next smallest palindrome is 161.\n    - For number = 165, the next smallest palindrome is 171.\n    - For number = 175, the next smallest palindrome is 181.\n    - For number = 185, the next smallest palindrome is 191.\n    - For number = 195, the next smallest palindrome is 201.\n    - For number = 205, the next smallest palindrome is 211.\n    - For number = 215, the next smallest palindrome is 221.\n    - For number = 225, the next smallest palindrome is 231.\n    - For number = 235, the next smallest palindrome is 241.\n    - For number = 245, the next smallest palindrome is 251.\n    - For number = 255, the next smallest palindrome is 261.\n    - For number = 265, the next smallest palindrome is 271.\n    - For number = 275, the next smallest palindrome is 281.\n    - For number = 285, the next smallest palindrome is",
      -0.75634765625
    ],
    [
      "def next_palindrome(num):\n    if is_palindrome(num):\n        return num + 2\n    return next_palindrome(num + 1)\n\n\ndef is_palindrome(num):\n    return num == int(str(num)[::-1])\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 131\n    assert next_palindrome(122) == 131\n    assert next_palindrome(121) == 121\n    assert next_palindrome(120) == 122",
      -0.85595703125
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    The idea is to add 1 to the number, and if the number is odd, to add a\n    middle zero.\n    \"\"\"\n    # Add 1 to the number.\n    number += 1\n\n    # If the number is odd, add a middle zero.\n    if number % 2 == 1:\n        number = number * 10\n\n    # Reverse the number.\n    reversed_number = int(str(number)[::-1])\n\n    return number + reversed_number",
      -0.85693359375
    ],
    [
      "def next_smallest_palindrome(n):\n    s = str(n)\n    if s == s[::-1]:\n        return int(s)\n\n    for i in range(n+1, 1000000000):\n        s = str(i)\n        if s == s[::-1]:\n            return i\n\nif __name__ == \"__main__\":\n    print(next_smallest_palindrome(325))\n    print(next_smallest_palindrome(12345))",
      -0.85693359375
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    Returns the next smallest palindrome of a specified number.\n    \"\"\"\n    if number % 11 == 0:\n        return number + 1\n    else:\n        return number + 11 - (number % 11)\n\nif __name__ == '__main__':\n    print(next_palindrome(98765))",
      -0.85693359375
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    Find the next smallest palindrome of a specified number.\n\n    :param n: number\n    :type n: int\n    :return: next smallest palindrome\n    :rtype: int\n    \"\"\"\n    n = str(n)\n    for i in range(len(n) - 1, 0, -1):\n        if n[:i] >= n[i:]:\n            break\n    else:\n        n = n[::-1]\n    return int(n[:i] + n[i:][::-1])",
      -0.85693359375
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    n = str(n)\n    n = list(n)\n    i = 0\n    j = len(n) - 1\n\n    while i < j:\n        if n[i] >= n[j]:\n            j -= 1\n        else:\n            i += 1\n\n    if i == j:\n        return int(\"\".join(n[:i] + n[i:j:-1] + n[i:]))\n    else:\n        return int(\"\".join(n[:j] + n[j:i:-1] + n[i:]))",
      -0.85693359375
    ],
    [
      "def next_palindrome(num):\n    str_num = str(num)\n    if str_num == str_num[::-1]:\n        return num + 1\n\n    str_num_rev = str_num[::-1]\n    diff = 0\n\n    for i in range(len(str_num)):\n        if str_num[i] != str_num_rev[i]:\n            diff = i\n            break\n\n    return int(str_num[:diff] + str_num_rev[diff:]) + 1\n\n\nif __name__ == \"__main__\":\n    num = 213\n    print(next_palindrome(num))",
      -0.85693359375
    ],
    [
      "def next_palindrome(num):\n    if is_palindrome(num):\n        return get_next_palindrome(num)\n    else:\n        return get_next_palindrome(get_next_palindrome(num))\n\n\ndef is_palindrome(num):\n    if str(num) == str(num)[::-1]:\n        return True\n    return False\n\n\ndef get_next_palindrome(num):\n    return num + 1",
      -0.85693359375
    ],
    [
      "def next_smallest_palindrome(num):\n    if is_palindrome(num):\n        return next_palindrome(num)\n\n    return next_palindrome(num + 1)\n\n\ndef next_palindrome(num):\n    return num + 1\n\n\ndef is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\n\nif __name__ == \"__main__\":\n    num = 235\n    print(next_smallest_palindrome(num))",
      -0.85693359375
    ],
    [
      "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef next_palindrome(n):\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n    return n\n\ndef test(n):\n    print(n, \"->\", next_palindrome(n))\n\ntest(123)\ntest(1234)\ntest(12345)\ntest(123456)\ntest(1234567)\ntest(12345678)\ntest(123456789)\ntest(1234567891)",
      -0.85693359375
    ],
    [
      "def get_next_palindrome(n):\n    if n % 11 == 0:\n        return n + 2\n    else:\n        return n + (11 - (n % 11))\n\n\ndef main():\n    n = int(input(\"Enter a number: \"))\n    print(\"The next palindrome is:\", get_next_palindrome(n))\n\n\nif __name__ == '__main__':\n    main()",
      -0.85693359375
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(121)\n    133\n    >>> next_palindrome(124)\n    133\n    >>> next_palindrome(145)\n    151\n    \"\"\"\n    if number % 10 == 0:\n        number += 1\n    else:\n        number += 2\n    while True:\n        number_str = str(number)\n        if number_str == number_str[::-1]:\n            return number\n        number += 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "def next_palindrome(num):\n    num = str(num)\n    if num == num[::-1]:\n        return num\n    else:\n        for i in range(len(num)):\n            if num[i] != num[-i - 1]:\n                new_num = num[:i] + num[i + 1:]\n                if new_num == new_num[::-1]:\n                    return new_num\n                else:\n                    return next_palindrome(int(new_num) + 1)\n\nprint(next_palindrome(123))",
      -0.85693359375
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    Return the next smallest palindrome of n.\n    \"\"\"\n    if n % 10 == 0:\n        return n + 2\n    else:\n        return n + 1",
      -0.85693359375
    ],
    [
      "def next_palindrome(number: int) -> int:\n    \"\"\"\n    >>> next_palindrome(123)\n    234\n    >>> next_palindrome(999)\n    1001\n    >>> next_palindrome(121)\n    130\n    >>> next_palindrome(1001)\n    1001\n    \"\"\"\n    digits = [int(digit) for digit in str(number)]\n    digits.reverse()\n    num = 0\n    for i in range(len(digits)):\n        num += digits[i] * pow(10, i)\n    return num if num >= number else num * 10 + 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "class Solution():\n    def __init__(self, num):\n        self.num = num\n\n    def next_palindrome(self):\n        \"\"\"\n        Find the next palindrome\n\n        Args:\n            num (int): Number to find the next palindrome\n\n        Returns:\n            int: Next palindrome\n        \"\"\"\n        # Find the next palindrome\n        num = self.num\n        while True:\n            num += 1\n            if str(num) == str(num)[::-1]:\n                break\n\n        return num\n\n\nif __name__ == \"__main__\":\n    num = 32768\n    solution = Solution(num)\n    print(solution.next_palindrome())",
      -0.85693359375
    ],
    [
      "def next_palindrome(n):\n    if n % 10 == 0:\n        return n + 2\n\n    next_num = n + 1\n    while True:\n        if str(next_num) == str(next_num)[::-1]:\n            return next_num\n        next_num += 1\n\n\nif __name__ == \"__main__\":\n    print(next_palindrome(123))\n    print(next_palindrome(1223))\n    print(next_palindrome(1234))\n    print(next_palindrome(1223321))\n    print(next_palindrome(12345))",
      -0.85791015625
    ],
    [
      "from project.is_palindrome import is_palindrome\n\ndef next_palindrome(number):\n    if is_palindrome(number):\n        num_str = str(number)\n        num_list = [int(i) for i in num_str]\n        num_list.append(num_list[0])\n        return int(''.join(map(str, num_list)))\n    else:\n        num_str = str(number)\n        num_list = [int(i) for i in num_str]\n        for i in range(len(num_list)):\n            if num_list[i] < 9:\n                num_list[i] += 1\n                break\n            else:\n                num_list[i] = 0\n        return int(''.join(map(str, num_list)))",
      -0.85791015625
    ],
    [
      "def next_smallest_palindrome(num):\n    \"\"\"\n    Returns next smallest palindrome of a number.\n    \"\"\"\n    if num < 10:\n        return None\n    elif num % 11 == 0:\n        return num + 1\n    elif num % 10 == 0:\n        return num + 2\n    else:\n        return None\n\n\nprint(next_smallest_palindrome(123))",
      -0.85791015625
    ],
    [
      "def next_palindrome(num):\n    n = num + 1\n    while True:\n        if is_palindrome(n):\n            return n\n        n += 1\n\ndef is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\nprint(next_palindrome(123))",
      -0.8583984375
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    Get the next palindrome of a number.\n    \"\"\"\n    if number % 10 == 0:\n        return number + 2\n\n    digits = [int(digit) for digit in str(number)]\n\n    i = len(digits) - 1\n    while i > 0 and digits[i] >= digits[i - 1]:\n        i -= 1\n\n    if i == 0:\n        return None\n\n    j = len(digits) - 1\n    while digits[i - 1] <= digits[j]:\n        j -= 1\n\n    digits[i - 1], digits[j] = digits[j], digits[i - 1]\n\n    digits[i:] = digits[:i][::-1]\n    return int(\"\".join(str(digit) for digit in digits))",
      -0.8583984375
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    Next palindrome of a number.\n    \"\"\"\n    if num % 10 == 0:\n        return num + 2\n    elif num < 10:\n        return num + 1\n    else:\n        return num + 2 if num % 10 == 1 else num + 1\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 232\n    assert next_palindrome(122) == 222\n    assert next_palindrome(12) == 22\n    assert next_palindrome(121) == 222",
      -0.8583984375
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    n = str(n)\n    if n == n[::-1]:\n        return int(n)\n    else:\n        i = len(n) // 2\n        if int(n[:i]) > int(n[i:]):\n            return int(n[:i]) + str(int(n[:i]) - 1) + n[i:0:-1]\n        else:\n            return int(n[:i]) + str(int(n[:i]) + 1) + n[i:0:-1]\n\n\nif __name__ == '__main__':\n    print(next_palindrome(200))",
      -0.8583984375
    ],
    [
      "def next_palindrome(n):\n    n_str = str(n)\n    n_list = list(n_str)\n    rev_list = n_list[::-1]\n    if n_list == rev_list:\n        return n + 1\n    else:\n        while n_list != rev_list:\n            n_list.append(n_list.pop(0))\n            if n_list == rev_list:\n                return int(\"\".join(n_list))\n        return int(\"\".join(n_list)) + 1\n\n\nprint(next_palindrome(123))\nprint(next_palindrome(1221))\nprint(next_palindrome(1234))\nprint(next_palindrome(12345))\nprint(next_palindrome(123456))\nprint(next_palindrome(1234567))",
      -0.85888671875
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    Returns the next smallest palindrome of a specified number.\n    \"\"\"\n    # Add 1 to the number, convert to string, reverse and compare to original string.\n    # If the reversed string is greater than the original string, return the string.\n    # Otherwise, keep incrementing the number by 1 until the condition is met.\n    while True:\n        if str(number + 1) == str(number + 1)[::-1]:\n            return number + 1\n        number += 1\n\n\nif __name__ == '__main__':\n    print(next_palindrome(12345))\n    print(next_palindrome(12344))\n    print(next_palindrome(12343))\n    print(next_palindrome(12342))",
      -0.85888671875
    ],
    [
      "def next_smallest_palindrome(num):\n    if num % 11 == 0:\n        return num\n\n    if num % 10 == 0:\n        return num + 1\n\n    while True:\n        next_num = num + 1\n        if str(next_num) == str(next_num)[::-1]:\n            return next_num\n        num += 1\n\n\nif __name__ == '__main__':\n    print(next_smallest_palindrome(1234))",
      -0.90673828125
    ],
    [
      "from itertools import permutations\n\n\ndef next_palindrome(n):\n    n = str(n)\n    n_list = list(n)\n    n_perms = list(permutations(n_list))\n    for perm in n_perms:\n        if int(''.join(perm)) > int(n):\n            return ''.join(perm)\n    return None\n\n\ndef test_next_palindrome():\n    assert next_palindrome(123) == '131'\n    assert next_palindrome(101) == '111'\n    assert next_palindrome(100) == '111'\n    assert next_palindrome(111) == '121'\n    assert next_palindrome(121) == '131'\n    assert next_palindrome(122) == '132'\n    assert next_palindrome(1001) == '1111'\n    assert next_palindrome(1110) == '1211'\n    assert next_palindrome(10001) == '11111'\n    assert next_palindrome(11101) == '12111'\n    assert next_palindrome(11110) == '12211'\n    assert next_palindrome(11111) == '12221'\n    assert next_palindrome(1000000001) == '1000010001'\n    assert next_palindrome(1000000000) == '1010001000'\n    assert next_palindrome(9999999999) == '1010001000'",
      -1.3525390625
    ],
    [
      "def next_palindrome(n):\n    # Converts the number to a string\n    n = str(n)\n\n    # Flips the number backwards\n    n = n[::-1]\n\n    # Adds 1 to the number\n    n = int(n) + 1\n\n    # Checks if the number is a palindrome\n    while not is_palindrome(n):\n        n += 1\n\n    return n\n\n\ndef is_palindrome(n):\n    # Converts the number to a string\n    n = str(n)\n\n    # Checks if the number is a palindrome\n    if n == n[::-1]:\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    # Test 1\n    print(next_palindrome(123))\n\n    # Test 2\n    print(next_palindrome(121))\n\n    # Test 3\n    print(next_palindrome(1010))\n\n    # Test 4\n    print(next_palindrome(1221))\n\n    # Test 5\n    print(next_palindrome(12321))\n\n    # Test 6\n    print(next_palindrome(12345))",
      -1.4169921875
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    if num == 0:\n        return 1\n    if num == 1:\n        return 11\n    if num % 10 == 0:\n        return num * 10 + num\n    if num % 10 != 0:\n        last = num % 10\n        num = num // 10\n        while num != 0:\n            if num % 10 == 0:\n                return num * 10 + last + 1\n            else:\n                num = num // 10\n                last = num % 10\n        return last * 10 + 1\n\nprint(next_palindrome(10))\nprint(next_palindrome(0))\nprint(next_palindrome(123))\nprint(next_palindrome(121))",
      -1.4296875
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    If num is a palindrome, return the next palindrome.\n\n    >>> next_palindrome(123)\n    124\n    >>> next_palindrome(234)\n    323\n    >>> next_palindrome(345)\n    434\n    >>> next_palindrome(434)\n    543\n    >>> next_palindrome(543)\n    654\n    >>> next_palindrome(654)\n    765\n    >>> next_palindrome(765)\n    876\n    >>> next_palindrome(876)\n    988\n    >>> next_palindrome(999)\n    1001\n    >>> next_palindrome(1001)\n    1110\n    >>> next_palindrome(1110)\n    1211\n    >>> next_palindrome(1211)\n    1322\n    >>> next_palindrome(1322)\n    1433\n    \"\"\"\n    if is_palindrome(num):\n        return num + 2\n\n    num_str = str(num)\n    while not is_palindrome(num):\n        num += 1\n\n    return int(num_str + \"0\" + num_str[::-1])\n\n\ndef is_palindrome(num: int) -> bool:\n    \"\"\"\n    Check if num is a palindrome.\n    \"\"\"\n    return str(num) == str(num)[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -1.5556640625
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    :param num: int - number of which the next palindrome is to be found.\n    :return: int - next smallest palindrome.\n    \"\"\"\n    # Your code here\n    num_str = str(num)\n    num_len = len(num_str)\n    num_list = [int(num) for num in num_str]\n    i = 0\n    while i < num_len // 2:\n        if num_list[i] != num_list[-(i + 1)]:\n            if num_list[i] < num_list[-(i + 1)]:\n                num_list[i] += 1\n                num_list[-(i + 1)] -= 1\n            else:\n                num_list[i] -= 1\n                num_list[-(i + 1)] += 1\n            for j in range(i + 1, num_len // 2):\n                num_list[j] = num_list[-(j + 1)]\n            break\n        i += 1\n    return int(\"\".join(str(x) for x in num_list))\n\n\nif __name__ == '__main__':\n    print(next_palindrome(335))",
      -1.697265625
    ],
    [
      "def next_smallest_palindrome(n):\n    \"\"\"\n    Return the next smallest palindrome of a specified number n.\n\n    >>> next_smallest_palindrome(30)\n    323\n    >>> next_smallest_palindrome(123)\n    132\n    >>> next_smallest_palindrome(121)\n    130\n    >>> next_smallest_palindrome(135)\n    143\n    >>> next_smallest_palindrome(48)\n    57\n    >>> next_smallest_palindrome(57)\n    66\n    >>> next_smallest_palindrome(100)\n    111\n    >>> next_smallest_palindrome(122)\n    131\n    >>> next_smallest_palindrome(123)\n    132\n    >>> next_smallest_palindrome(124)\n    133\n    >>> next_smallest_palindrome(125)\n    141\n    >>> next_smallest_palindrome(141)\n    150\n    >>> next_smallest_palindrome(142)\n    151\n    >>> next_smallest_palindrome(151)\n    160\n    >>> next_smallest_palindrome(152)\n    161\n    >>> next_smallest_palindrome(153)\n    162\n    >>> next_smallest_palindrome(162)\n    171\n    >>> next_smallest_palindrome(163)\n    172\n    >>> next_smallest_palindrome(172)\n    181\n    >>> next_smallest_palindrome(173)\n    182\n    >>> next_smallest_palindrome(182)\n    191\n    >>> next_smallest_palindrome(183)\n    192\n    >>> next_smallest_palindrome(192)\n    201",
      -2.091796875
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    O(n) & O(n)\n    \"\"\"\n\n    # get the number of digits in the number\n    n = len(str(num))\n\n    # find the middle number\n    middle = int(str(num)[(n // 2)])\n\n    # find the next middle number\n    if middle == 9:\n        middle = 0\n    else:\n        middle += 1\n\n    # find the next palindrome\n    if n % 2 == 0:\n        # even\n        next_palindrome = int(str(num)[:n // 2] + str(middle) + str(num)[n // 2:])\n    else:\n        # odd\n        next_palindrome = int(str(num)[: n // 2] + str(middle) + str(middle) + str(num)[n // 2 + 1 :])\n\n    return next_palindrome\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123456789) == 123465789\n    assert next_palindrome(12345678) == 12346578\n    assert next_palindrome(1234567) == 1234657\n    assert next_palindrome(123456) == 123465\n    assert next_palindrome(12345) == 12354\n    assert next_palindrome(1234) == 1235\n    assert next_palindrome(123) == 124\n    assert next_palindrome(12) == 13\n    assert next_palindrome(1) == 2",
      -2.10546875
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :param n: int - number of which to find the next palindrome.\n    :return: int - next palindrome.\n    \"\"\"\n    n_str = str(n)\n    for i in range(len(n_str)):\n        if n_str[i] != n_str[-(i + 1)]:\n            n_str = n_str[:i] + n_str[i:].zfill(i + 1)\n            break\n    return int(n_str)\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    if next_palindrome(test_input) == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function((123, 1331))\ntest_function((1333, 1433))\ntest_function((1343, 1434))\ntest_function((1445, 1544))\ntest_function((1454, 1545))\ntest_function((1556, 1656))\ntest_function((1565, 1655))\ntest_function((1666, 1666))\ntest_function((1667, 1676))\ntest_function((1676, 1676))\ntest_function((12223221, 12223322))\ntest_function((123221, 123232))\ntest_function((12345678, 12345778))",
      -2.349609375
    ],
    [
      "def is_palindrome(number):\n    number = str(number)\n    return number == number[::-1]\n\n\ndef next_palindrome(number):\n    \"\"\"\n    Finds the next palindrome from the given number.\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(122)\n    123\n    >>> next_palindrome(134)\n    141\n    >>> next_palindrome(135)\n    141\n    >>> next_palindrome(145)\n    151\n    >>> next_palindrome(155)\n    161\n    \"\"\"\n\n    if is_palindrome(number):\n        return int(str(number) + str(number)[::-1])\n\n    number = str(number)\n    length = len(number)\n    if length % 2 == 0:\n        first = number\n        second = number[::-1]\n    else:\n        first = number[:length // 2]\n        second = number[length // 2:]\n\n    for index in range(len(first) - 1, -1, -1):\n        if first[index] < second[index]:\n            first = first[:index] + chr(ord(first[index]) + 1) + first[index + 1 :]\n            second = (\n                second[:index] + chr(ord(second[index]) - 1) + second[index + 1 :]\n            )\n            return int(first + second[::-1])\n\n    return int(second + first[::-1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -2.767578125
    ],
    [
      "def next_palindrome(num):\n    num = str(num)\n    num_rev = num[::-1]\n    if num < num_rev:\n        return next_palindrome(int(num_rev) + 1)\n    elif num == num_rev:\n        return int(num_rev) + 1\n    else:\n        return next_palindrome(int(num_rev) + 1)\n\n\ndef test_next_palindrome():\n    \"\"\"\n    >>> next_palindrome(123)\n    232\n    >>> next_palindrome(1223)\n    2322\n    >>> next_palindrome(1234)\n    2343\n    >>> next_palindrome(1244)\n    2442\n    >>> next_palindrome(12345)\n    23454\n    >>> next_palindrome(123456)\n    234565\n    >>> next_palindrome(1234567)\n    2345677\n    >>> next_palindrome(12345678)\n    23456788\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -2.833984375
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :param n: int - number\n    :return: int - next smallest palindrome.\n    \"\"\"\n    n = str(n)\n    # check if it is an even palindrome\n    if n == n[::-1]:\n        # if it is an even number\n        if len(n) % 2 == 0:\n            return int(n[:len(n) // 2] + str(int(n[len(n) // 2]) + 1) + n[len(n) // 2:][::-1])\n        # if it is an odd number\n        else:\n            return int(n[:len(n) // 2] + str(int(n[len(n) // 2]) + 1) + n[len(n) // 2 + 1:][::-1])\n    # check if it is an odd palindrome\n    else:\n        # if it is an even number\n        if len(n) % 2 == 0:\n            return int(n[:len(n) // 2] + str(int(n[len(n) // 2]) + 1) + n[len(n) // 2:][::-1])\n        # if it is an odd number\n        else:\n            return int(n[:len(n) // 2 + 1] + str(int(n[len(n) // 2 + 1]) + 1) + n[len(n) // 2 + 1:][::-1])\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = next_palindrome(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function((1977, 1978))\ntest_function((12321, 12322))\ntest_function((100001, 100010))\ntest_function((12345, 12346))",
      -3.033203125
    ],
    [
      "def next_smallest_palindrome(number: int) -> int:\n    \"\"\"\n    Find the next smallest palindrome of a specified number.\n\n    >>> next_smallest_palindrome(123)\n    121\n    >>> next_smallest_palindrome(121)\n    133\n    >>> next_smallest_palindrome(199)\n    202\n    >>> next_smallest_palindrome(222)\n    232\n    >>> next_smallest_palindrome(1011)\n    1111\n    >>> next_smallest_palindrome(1256)\n    1331\n    >>> next_smallest_palindrome(1257)\n    1333\n    >>> next_smallest_palindrome(1000001)\n    100110\n    >>> next_smallest_palindrome(1000000)\n    101001\n    >>> next_smallest_palindrome(999999)\n    100000\n    >>> next_smallest_palindrome(10000000)\n    1101001\n    >>> next_smallest_palindrome(10000100)\n    1101110\n    \"\"\"\n    if number <= 10:\n        return number\n\n    if number % 11 == 0:\n        return number + 1\n\n    if number % 10 == 0:\n        return number + 2\n\n    return number + 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -3.033203125
    ],
    [
      "def next_smallest_palindrome(number: int) -> int:\n    \"\"\"\n    Time Complexity: O(1)\n    Space Complexity: O(1)\n    \"\"\"\n    digits = list(str(number))\n    half = len(digits) // 2\n    left = digits[:half]\n    right = digits[half:]\n    right.reverse()\n\n    if digits == left + right:\n        return int(str(number) + \"1\" + \"0\" * (len(digits) % 2))\n\n    i = half - 1\n    while i >= 0 and digits[i] == \"9\":\n        digits[i] = \"0\"\n        i -= 1\n\n    if i < 0:\n        return int(\"1\" + \"0\" * half + \"1\" + \"0\" * half)\n\n    digits[i] = str(int(digits[i]) + 1)\n    return int(\"\".join(digits))\n\nif __name__ == \"__main__\":\n    assert next_smallest_palindrome(123) == 124\n    assert next_smallest_palindrome(121) == 130\n    assert next_smallest_palindrome(999) == 1020",
      -3.435546875
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    Next Palindrome.\n\n    :param num: number\n    :type num: int\n    :return: next palindrome\n    :rtype: int\n    \"\"\"\n    str_num = str(num)\n    if len(str_num) == 1:\n        return 11\n    if int(str_num[-1]) == 9:\n        return 10 * int(\"\".join([x for x in str_num[:-1]])) + int(\"\".join([x for x in str_num[:-1][::-1]])) + 1\n    else:\n        return int(\"\".join([x for x in str_num[:-1]])) + int(\"\".join([x for x in str_num[:-1][::-1]])) + 1\n\n\ndef test_function(test_case):\n    num = test_case[0]\n    solution = test_case[1]\n    output = next_palindrome(num)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_case_1 = [123, 131]\ntest_function(test_case_1)\n\ntest_case_2 = [135, 151]\ntest_function(test_case_2)\n\ntest_case_3 = [121, 122]\ntest_function(test_case_3)\n\ntest_case_4 = [9, 11]\ntest_function(test_case_4)\n\ntest_case_5 = [199, 202]\ntest_function(test_case_5)",
      -3.453125
    ],
    [
      "def next_smallest_palindrome(n):\n    if n % 11 == 0:\n        return n\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n    return n\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\n# test\nassert next_smallest_palindrome(123) == 131\nassert next_smallest_palindrome(121) == 121\nassert next_smallest_palindrome(105) == 111\nassert next_smallest_palindrome(135) == 141\nassert next_smallest_palindrome(134) == 140\nassert next_smallest_palindrome(10000) == 10101",
      -3.546875
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"Return the next smallest palindrome of a specified number.\n\n    Args:\n        num (int): the number to find the next palindrome of\n\n    Returns:\n        int: the next smallest palindrome of num\n    \"\"\"\n    num_str = str(num)\n    num_len = len(num_str)\n    mid = num_len // 2\n\n    if num_len % 2 == 0:\n        left, right = num_str[:mid], num_str[mid:]\n    else:\n        left, right = num_str[:mid], num_str[mid + 1:]\n\n    if left == right[::-1]:\n        return num + 10\n\n    for i in range(mid - 1, -1, -1):\n        if left[i] < right[i]:\n            left = left[:i] + str(int(left[i]) + 1) + left[i:]\n            return int(left + left[::-1][1:])\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 132\n    assert next_palindrome(121) == 130\n    assert next_palindrome(135) == 143\n    assert next_palindrome(105) == 115\n    assert next_palindrome(136) == 146\n    assert next_palindrome(1000) == 1021\n    assert next_palindrome(1001) == 1020\n    assert next_palindrome(999) == 1001",
      -3.57421875
    ],
    [
      "def next_palindrome(num):\n    num_str = str(num)\n    if len(num_str) == 1:\n        return num\n\n    mid_index = len(num_str)//2\n    left, right = num_str[:mid_index], num_str[mid_index:]\n    right = right[::-1]\n\n    if left > right:\n        return int(right + left + right[::-1])\n    else:\n        return int(left + right + left[::-1])\n\n\nif __name__ == \"__main__\":\n    print(next_palindrome(123))\n    print(next_palindrome(1221))\n    print(next_palindrome(1234))",
      -3.734375
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    Given a number, find the next smallest palindrome\n\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(121)\n    133\n    >>> next_palindrome(146)\n    153\n    >>> next_palindrome(199)\n    202\n    >>> next_palindrome(222)\n    232\n    >>> next_palindrome(333)\n    343\n    >>> next_palindrome(444)\n    455\n    >>> next_palindrome(555)\n    666\n    >>> next_palindrome(777)\n    888\n    \"\"\"\n    num = str(num)\n    if int(num) % 11 == 0:\n        return int(num) + 11\n    else:\n        return int(num) + (11 - (int(num) % 11))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -3.748046875
    ],
    [
      "def next_smallest_palindrome(number):\n    number_as_string = str(number)\n    if len(number_as_string) == 1:\n        return 0\n    if len(number_as_string) == 2:\n        if number_as_string[0] == number_as_string[1]:\n            return int(number_as_string[0]) + 10\n        return int(number_as_string[0]) + int(number_as_string[1])\n\n    mid = len(number_as_string) // 2\n\n    if number_as_string[mid] != number_as_string[~mid]:\n        return next_palindrome(number_as_string, mid, 1, int(number_as_string[~mid]))\n\n    for i in range(mid, len(number_as_string)):\n        if number_as_string[i] < number_as_string[~i]:\n            return next_palindrome(number_as_string, mid, i, int(number_as_string[~i]))\n\n    return next_palindrome(number_as_string, mid, mid, int(number_as_string[~mid]))\n\n\ndef next_palindrome(number_as_string, mid, start, last_digit):\n    for i in range(start, len(number_as_string)):\n        if number_as_string[i] < number_as_string[~i]:\n            return int(number_as_string[:mid]) + int(number_as_string[i]) + 10 ** (len(number_as_string) - mid) * last_digit\n\n    return int(number_as_string[:mid]) + 10 ** (len(number_as_string) - mid) * last_digit\n\n\nprint(next_smallest_palindrome(123))\nprint(next_smallest_palindrome(1234))\nprint(next_smallest_palindrome(12345))\nprint(next_smallest_palindrome(123456))\nprint(next_smallest",
      -3.76953125
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    Return the next palindrome of num.\n    \"\"\"\n    str_num = str(num)\n    rev_num = str_num[::-1]\n    # If num is a palindrome, add 1 to the first digit and make the rest 0.\n    # If num is not a palindrome, find the index where num and reverse are\n    # different, and replace the first digit after that with 0 and make the\n    # rest of the digits 9.\n    if str_num == rev_num:\n        return int(str(int(str_num[0]) + 1) + \"0\" * (len(str_num) - 1))\n    else:\n        for i in range(len(str_num)):\n            if str_num[i] != rev_num[i]:\n                return int(str_num[:i] + \"0\" * (len(str_num) - i) + str(9 * (i + 1) + int(str_num[i])))\n\n\nif __name__ == \"__main__\":\n    print(next_palindrome(123))\n    print(next_palindrome(110))\n    print(next_palindrome(121))\n    print(next_palindrome(124))",
      -3.7734375
    ],
    [
      "def next_palindrome(num):\n    \"\"\"Return the next smallest palindrome of a specified number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        The next smallest palindrome of num.\n    \"\"\"\n    num_str = str(num)\n    num_str_rev = num_str[::-1]\n    for i in range(len(num_str)):\n        if num_str[i] != num_str_rev[i]:\n            return int(num_str[:i] + num_str_rev[i:])\n    return int(num_str + num_str_rev)\n\n\ndef test_next_palindrome():\n    \"\"\"Test next_palindrome().\"\"\"\n    assert next_palindrome(123) == 122\n    assert next_palindrome(122) == 133\n    assert next_palindrome(1234) == 1323\n    assert next_palindrome(12345) == 13243\n    assert next_palindrome(12345678) == 13234568\n    assert next_palindrome(123456789) == 132345689\n    assert next_palindrome(1234567890) == 1323456890\n    assert next_palindrome(1000000000) == 1100000001\n    assert next_palindrome(1000000001) == 1100000001\n    assert next_palindrome(1000000002) == 1100000003",
      -4.16796875
    ],
    [
      "from itertools import chain\n\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\n\ndef next_palindrome(n):\n    if not is_palindrome(n):\n        n += 1\n        while not is_palindrome(n):\n            n += 1\n    return n\n\n\ndef next_palindrome_2(n):\n    if not is_palindrome(n):\n        n += 1\n    else:\n        n += 1\n        while not is_palindrome(n):\n            n += 1\n    return n\n\n\ndef next_palindrome_3(n):\n    if is_palindrome(n):\n        return n + 1\n\n    def is_odd(n):\n        return n % 2 == 1\n\n    def is_even(n):\n        return n % 2 == 0\n\n    def digits(n):\n        return list(map(int, str(n)))\n\n    def odd_digits(n):\n        return list(filter(is_odd, digits(n)))\n\n    def even_digits(n):\n        return list(filter(is_even, digits(n)))\n\n    def odd_digits_sum(n):\n        return sum(odd_digits(n))\n\n    def even_digits_sum(n):\n        return sum(even_digits(n))\n\n    def odd_digits_sum_inc(n):\n        return odd_digits_sum(n) + (even_digits_sum(n) // 10)\n\n    def odd_digits_sum_inc_odd(n):\n        return odd_digits_sum_inc(n) + (1 if odd_digits_sum_inc(n) % 2 == 0 else 0)\n\n    def reverse(n):\n        return int(\"\".join(map(str, reversed(digits(n)))))\n\n    def reverse_odd(n):\n        return int(\"\".join(chain(odd_digits(n), reversed(odd_digits(n)))))",
      -4.37890625
    ],
    [
      "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\n\ndef next_palindrome(n: int) -> int:\n    s = str(n)\n    if is_palindrome(s):\n        s = s[:-1]\n        s += str(int(s[-1]) + 1)\n        return int(s + s[::-1])\n    else:\n        for i in range(len(s)):\n            if s[i] < s[-1]:\n                s = s[:i] + str(int(s[i]) + 1) + s[i:]\n                break\n        return int(s + s[::-1])\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 1332\n    assert next_palindrome(1221) == 1232\n    assert next_palindrome(1223) == 1333\n    assert next_palindrome(1222) == 1333\n    assert next_palindrome(12) == 13\n    assert next_palindrome(123321) == 1234321\n    assert next_palindrome(101) == 111",
      -4.50390625
    ],
    [
      "from project.find_next_palindrome import next_palindrome\nimport pytest\n\n\n@pytest.mark.parametrize(\"test_input, test_output\", [\n    (123, 131),\n    (121, 131),\n    (131, 131),\n    (132, 213),\n    (222, 222),\n    (1211, 1121),\n    (11111, 11111),\n    (11211, 11211),\n    (11101, 11111),\n    (11121, 11121),\n    (11122, 1211),\n    (11123, 11211),\n    (11133, 11133),\n    (11134, 11311),\n    (11135, 11331),\n    (11136, 11341),\n    (11137, 11351),\n    (11138, 11361),\n    (11139, 11371),\n    (11141, 11411),\n    (11142, 11421),\n    (11143, 11431),\n    (11144, 11441),\n    (11145, 11451),\n    (11146, 11461),\n    (11147, 11471),\n    (11148, 11481),\n    (11149, 11491),\n    (11151, 11511),\n    (11152, 11521),\n    (11153, 1",
      -4.67578125
    ],
    [
      "def next_palindrome(number):\n    \"\"\"\n    Return the next palindrome after the number.\n    \"\"\"\n\n    # Convert the number to a string\n    number_string = str(number)\n    # Reverse the number\n    reverse_number = number_string[::-1]\n\n    # Check if the number is a palindrome\n    if number_string == reverse_number:\n        # If the number is a palindrome, we need to add one to the number and make a string\n        new_number = str(int(number) + 1)\n        # If the number has two digits, we need to add a zero\n        if len(new_number) == 2:\n            new_number += \"0\"\n        # Reverse the number\n        reverse_number = new_number[::-1]\n        return reverse_number\n    # If the number isn't a palindrome, we need to make a string of the number and add zeroes\n    else:\n        # If the number has two digits, we need to add a zero\n        if len(number_string) == 2:\n            number_string += \"0\"\n        # Reverse the number\n        reverse_number = number_string[::-1]\n        return reverse_number\n\n# TODO: Add more test cases",
      -4.7578125
    ],
    [
      "from typing import List\n\n\ndef next_palindrome(num: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if num <= 10:\n        return 11\n\n    num_list: List[int] = list(str(num))\n    len_num: int = len(num_list)\n    left: int = 0\n    right: int = len_num - 1\n\n    while left < right:\n        if num_list[left] < num_list[right]:\n            num_list[left] = num_list[right]\n            left += 1\n        else:\n            right -= 1\n\n    if len_num % 2 == 0:\n        num_list[left] = str(int(num_list[left]) + 1)\n        num_list[right] = str(int(num_list[left]))\n    else:\n        num_list[left] = str(int(num_list[left]) + 1)\n        num_list[right] = num_list[left]\n\n    return int(\"\".join(num_list))\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 131\n    assert next_palindrome(121) == 131\n    assert next_palindrome(135) == 151\n    assert next_palindrome(105) == 111\n    assert next_palindrome(100) == 111\n    assert next_palindrome(1000) == 1011\n    assert next_palindrome(1001) == 1011\n    assert next_palindrome(1234) == 1331\n    assert next_palindrome(12345) == 13441",
      -4.94140625
    ],
    [
      "def next_smallest_palindrome(n):\n    \"\"\"\n    Time complexity: O(1)\n    Space complexity: O(1)\n    \"\"\"\n    # Find next number that is bigger than n\n    n += 1\n\n    # Reverse n\n    rev = int(str(n)[::-1])\n\n    # Check if rev is a palindrome\n    if rev == n:\n        return rev\n\n    # Find the next palindrome\n    while True:\n        n += 1\n        rev = int(str(n)[::-1])\n        if rev == n:\n            return rev\n\n\nif __name__ == \"__main__\":\n\n    print(next_smallest_palindrome(98765))\n    print(next_smallest_palindrome(12345))\n    print(next_smallest_palindrome(99))\n    print(next_smallest_palindrome(123))\n    print(next_smallest_palindrome(1221))\n    print(next_smallest_palindrome(1234))\n    print(next_smallest_palindrome(123456))\n    print(next_smallest_palindrome(1234567))\n    print(next_smallest_palindrome(12345678))\n    print(next_smallest_palindrome(123456789))\n    print(next_smallest_palindrome(1234567890))\n    print(next_smallest_palindrome(12345678901))\n    print(next_smallest_palindrome(123456789012))",
      -4.94921875
    ],
    [
      "def next_palindrome(num):\n    num = str(num)\n    rev = num[::-1]\n    return num if num < rev else num + rev[1:]\n\n\nprint(next_palindrome(121))\nprint(next_palindrome(122))\nprint(next_palindrome(123))\nprint(next_palindrome(124))\nprint(next_palindrome(125))\nprint(next_palindrome(124421))\nprint(next_palindrome(124422))\nprint(next_palindrome(124423))\nprint(next_palindrome(124424))\nprint(next_palindrome(124425))\nprint(next_palindrome(124426))\nprint(next_palindrome(124427))\nprint(next_palindrome(124428))\nprint(next_palindrome(124429))\nprint(next_palindrome(124430))\nprint(next_palindrome(124431))\nprint(next_palindrome(124432))\nprint(next_palindrome(124433))\nprint(next_palindrome(124434))\nprint(next_palindrome(124435))\nprint(next_palindrome(124436))\nprint(next_palindrome(124437))\nprint(next_palindrome(124438))\nprint(next_palindrome(124439))\nprint(next_palindrome(124440))\nprint(next_palindrome(124441))\nprint(next_palindrome(124442))\nprint(next_palindrome(124443))\nprint(next_palindrome(124444))\nprint(next_palindrome(124445))",
      -5.05078125
    ],
    [
      "from typing import Tuple\n\n\ndef is_palindrome(n: int) -> bool:\n    \"\"\"Check if a number is palindrome.\n\n    Args:\n        n (int): input number\n\n    Returns:\n        bool: True if it is palindrome, False otherwise.\n    \"\"\"\n    return str(n) == str(n)[::-1]\n\n\ndef find_next_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"Find the next smallest palindrome of a specified number.\n\n    Args:\n        n (int): input number\n\n    Returns:\n        Tuple[int, int]: the next smallest palindrome and the number of digits\n    \"\"\"\n    if is_palindrome(n):\n        return n, len(str(n))\n\n    n_str = str(n)\n    n_len = len(n_str)\n\n    for i in range(n_len):\n        if n_str[i] != \"9\":\n            n_str = n_str[:i] + \"9\" * (n_len - i)\n            n = int(n_str)\n            return n, n_len\n\n    n_str = \"1\" + \"0\" * (n_len - 1)\n    n = int(n_str)\n    return n, n_len\n\n\nif __name__ == \"__main__\":\n    assert is_palindrome(121) is True\n    assert is_palindrome(123) is False\n    assert find_next_palindrome(9) == (10, 1)\n    assert find_next_palindrome(123) == (121, 2)\n    assert find_next_palindrome(1221) == (1222, 3)\n    assert find_next_palindrome(1001) == (1111, 3)\n    assert find_next_palindrome(1010) == (1111, 3)\n    assert find_next_palindrome(1000) == (1111, 3",
      -5.109375
    ],
    [
      "def next_palindrome(number):\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Number must be a positive integer\")\n    elif number < 10:\n        return 11\n\n    number_list = [int(x) for x in str(number)]\n    # If number is even, add a zero in the middle to make it odd\n    if len(number_list) % 2 == 0:\n        number_list.insert(len(number_list) // 2, 0)\n\n    # Find the middle of the list\n    middle = len(number_list) // 2\n    # Get the first half of the number in reverse order\n    first_half = number_list[:middle][::-1]\n    # Get the second half of the number\n    second_half = number_list[middle:]\n\n    # If the first half is greater than the second half, we need to increment the second half\n    # and add a zero to the first half\n    if first_half > second_half:\n        second_half[0] += 1\n        first_half = [0] + first_half[:-1]\n\n    return int(\"\".join([str(x) for x in first_half + second_half]))\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(123) == 132\n    assert next_palindrome(121) == 131\n    assert next_palindrome(11) == 111\n    assert next_palindrome(100) == 110\n    assert next_palindrome(1000) == 1010\n    assert next_palindrome(1221) == 1232\n    assert next_palindrome(123321) == 1234321\n    assert next_palindrome(123456789) == 123457000\n    assert next_palindrome(1000000000) == 1000000010",
      -5.14453125
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :param n: int - an integer representing the number to be checked if it is a palindrome\n    :return: int - the next palindrome after the given number\n    \"\"\"\n    # Your code here\n    n_str = str(n)\n    rev = n_str[::-1]\n    if n_str == rev:\n        return n + 1\n\n    for i in range(len(n_str) - 1, -1, -1):\n        if n_str[i] != rev[i]:\n            return int(n_str[:i] + rev[i:])\n\n\nprint(next_palindrome(123))\nprint(next_palindrome(121))\nprint(next_palindrome(122))\nprint(next_palindrome(124))\nprint(next_palindrome(125))\nprint(next_palindrome(1254))\nprint(next_palindrome(12543))\nprint(next_palindrome(1254321))",
      -5.1484375
    ],
    [
      "def next_palindrome(num):\n    # check if number is less than 10\n    if num < 10:\n        return 9\n    # get the number of digits\n    num_digits = len(str(num))\n    # get the number of digits for the next palindrome\n    num_digits_next = num_digits + 1\n    # get the next palindrome number\n    next_palindrome_num = get_next_palindrome(num, num_digits, num_digits_next)\n    # return the next palindrome number\n    return next_palindrome_num\n\n\ndef get_next_palindrome(num, num_digits, num_digits_next):\n    # get the digits of the number\n    num_str = str(num)\n    num_list = list(num_str)\n    # get the digits of the next palindrome\n    num_digits_next = str(num_digits_next)\n    next_palindrome_digits = list(num_digits_next)\n    # reverse the digits of the next palindrome\n    next_palindrome_digits.reverse()\n    # append the digits of the number and the digits of the next palindrome\n    next_palindrome_digits.extend(num_list)\n    # convert the digits of the next palindrome into a number\n    next_palindrome = int(\"\".join(next_palindrome_digits))\n    # return the next palindrome\n    return next_palindrome",
      -5.19921875
    ],
    [
      "def next_smallest_palindrome(number: int) -> int:\n    \"\"\"Return the next smallest palindrome of a specified number.\n\n    Args:\n        number (int): a specified number.\n\n    Examples:\n        >>> assert next_smallest_palindrome(123) == 122\n        >>> assert next_smallest_palindrome(1221) == 1230\n        >>> assert next_smallest_palindrome(1234) == 1242\n        >>> assert next_smallest_palindrome(1235) == 1242\n        >>> assert next_smallest_palindrome(1242) == 1252\n        >>> assert next_smallest_palindrome(1252) == 1262\n        >>> assert next_smallest_palindrome(1262) == 1272\n        >>> assert next_smallest_palindrome(1272) == 1282\n        >>> assert next_smallest_palindrome(1282) == 1292\n        >>> assert next_smallest_palindrome(1292) == 1302\n        >>> assert next_smallest_palindrome(1302) == 1312\n        >>> assert next_smallest_palindrome(1312) == 1322\n        >>> assert next_smallest_palindrome(1322) == 1332\n        >>> assert next_smallest_palindrome(1332) == 1342\n        >>> assert next_smallest_palindrome(1342) == 1352\n        >>> assert next_smallest_palindrome(1352) == 1362\n        >>> assert next_smallest_palindrome(1362) == 1372\n        >>> assert next_smallest_palindrome(1372) == 1382\n        >>> assert next_smallest_palindrome(1382) == 1392",
      -5.31640625
    ],
    [
      "from typing import Optional\n\n\ndef next_palindrome(number: int) -> Optional[int]:\n    \"\"\"\n    Return the next smallest palindrome of a specified number.\n\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(125)\n    133\n    >>> next_palindrome(133)\n    143\n    >>> next_palindrome(199)\n    202\n    >>> next_palindrome(1999)\n    2020\n    >>> next_palindrome(2020)\n    2120\n    >>> next_palindrome(2021)\n    2121\n    >>> next_palindrome(2121)\n    2221\n    >>> next_palindrome(2222)\n    2322\n    >>> next_palindrome(2223)\n    2332\n    >>> next_palindrome(2332)\n    2432\n    >>> next_palindrome(2333)\n    2442\n    >>> next_palindrome(2442)\n    2552\n    >>> next_palindrome(2443)\n    2553\n    >>> next_palindrome(2444)\n    2554\n    >>> next_palindrome(2445)\n    2555\n    >>> next_palindrome(2446)\n    2555\n    >>> next_palindrome(2447)\n    2556\n    >>> next_palindrome(2448)\n    2556\n    >>> next_palindrome(2449)\n    2557\n    >>> next_palindrome(2450)\n    2557\n    >>> next_palindrome(2451)\n    2558\n    >>> next_palindrome(2452)\n    2558\n    >>> next_palindrome(2453)\n    255",
      -5.61328125
    ],
    [
      "def next_palindrome(number):\n    \"\"\"Return the next palindrome after the given number.\n\n    Args:\n        number: An integer.\n\n    Returns:\n        The next palindrome after the given number.\n\n    Raises:\n        ValueError: If the given number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError('Number must be greater than or equal to zero.')\n\n    if is_palindrome(number):\n        return increment(number)\n    else:\n        return increment(increment(number))\n\ndef is_palindrome(number):\n    \"\"\"Return True if the given number is a palindrome, False otherwise.\n\n    Args:\n        number: An integer.\n\n    Returns:\n        True if the given number is a palindrome, False otherwise.\n    \"\"\"\n    string = str(number)\n    return string == string[::-1]\n\ndef increment(number):\n    \"\"\"Return the next palindrome after the given number.\n\n    Args:\n        number: An integer.\n\n    Returns:\n        The next palindrome after the given number.\n    \"\"\"\n    string = str(number)\n    string = string[::-1]\n    string = increment_string(string)\n    return int(string)\n\ndef increment_string(string):\n    \"\"\"Return the next palindrome after the given string.\n\n    Args:\n        string: A string.\n\n    Returns:\n        The next palindrome after the given string.\n    \"\"\"\n    length = len(string)\n    if length == 1:\n        return '1'\n\n    index = length - 1\n    while index >= 0:\n        if string[index] != '9':\n            string = string[:index] + chr(ord(string[index]) + 1) + '0' * (length - index - 1) + string[index:]\n            break\n        else:\n            string = string[:index] + '0' * (length - index - 1) + string[index:]\n        index -= 1\n\n    return string",
      -5.85546875
    ],
    [
      "def next_palindrome(n: int) -> int:\n    \"\"\"\n    >>> next_palindrome(123)\n    121\n    >>> next_palindrome(12)\n    131\n    >>> next_palindrome(122)\n    133\n    >>> next_palindrome(111)\n    121\n    >>> next_palindrome(1234)\n    1331\n    >>> next_palindrome(12345)\n    13441\n    \"\"\"\n    if n < 10:\n        return n\n    if n < 100:\n        return n + 1\n    if n < 1000:\n        return next_palindrome(str(n) + str(n)[::-1])\n\n    def _get_next_palindrome(n: int) -> int:\n        if n < 10000:\n            return n + 1\n        return int(str(n) + str(n)[-2::-1])\n\n    n_str = str(n)\n    if n_str[-1] == \"0\":\n        return int(n_str[:-1] + \"1\" + n_str[:-2:-1]) + 1\n    return _get_next_palindrome(int(n_str[:-1] + \"1\" + n_str[:-2:-1]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -6.6640625
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    Find the next smallest palindrome of a specified number.\n\n    :param num: int - number of digits\n    :return: int - next smallest palindrome of num\n    \"\"\"\n    str_num = str(num)\n    if str_num == str_num[::-1]:\n        return num\n    else:\n        new_num = num + 1\n        while new_num < 10**len(str(new_num)) or new_num < num:\n            str_num = str(new_num)\n            if str_num == str_num[::-1]:\n                return new_num\n            new_num += 1\n\n\ndef test_function(test_case):\n    num = test_case[0]\n    solution = test_case[1]\n    output = next_palindrome(num)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_case_1 = [2, 3]\ntest_case_2 = [13, 14]\ntest_case_3 = [1234, 1254]\ntest_function(test_case_1)\ntest_function(test_case_2)\ntest_function(test_case_3)",
      -6.71875
    ],
    [
      "def next_palindrome(number: int) -> int:\n    \"\"\"\n    Get the next palindrome of a specified number.\n    >>> next_palindrome(123)\n    1331\n    >>> next_palindrome(121)\n    1311\n    >>> next_palindrome(1022)\n    1023\n    >>> next_palindrome(121021)\n    1022211\n    >>> next_palindrome(12321)\n    133311\n    >>> next_palindrome(102210)\n    103311\n    >>> next_palindrome(102221)\n    102221\n    >>> next_palindrome(102222)\n    102222\n    \"\"\"\n    if number <= 9:\n        return number\n\n    num_str = str(number)\n    num_len = len(num_str)\n    if num_len % 2 == 0:\n        mid = num_len // 2\n        left, right = num_str[:mid], num_str[mid:]\n    else:\n        mid = num_len // 2 + 1\n        left, right = num_str[:mid], num_str[mid:]\n\n    if int(left) < int(right):\n        left = str(int(left) + 1)\n        right = left[::-1]\n    else:\n        right = str(int(right) + 1)\n        right = right[::-1]\n\n    if num_len % 2 == 0:\n        return int(left + right)\n    return int(right + left)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -7.09765625
    ],
    [
      "def next_palindrome(n):\n    # Time: O(n)\n    # Space: O(1)\n    if n < 10:\n        return n\n\n    str_n = str(n)\n    size = len(str_n)\n    if size % 2 == 0:\n        mid = size // 2\n    else:\n        mid = size // 2 + 1\n\n    left = str_n[:mid]\n    right = str_n[-mid:]\n    right = right[::-1]\n    if left == right:\n        return n\n\n    i = mid - 1\n    while i >= 0:\n        if left[i] < right[i]:\n            break\n        i -= 1\n\n    j = mid - 1\n    while j >= 0:\n        if left[j] > right[j]:\n            break\n        j -= 1\n\n    left = left[:i] + chr(ord(left[i]) + 1) + left[i + 1 :]\n    right = right[:j] + chr(ord(right[j]) + 1) + right[j + 1 :]\n    return int(left + right[::-1])\n\n\nassert next_palindrome(3) == 4\nassert next_palindrome(123) == 131\nassert next_palindrome(1010) == 1111\nassert next_palindrome(1001) == 1111\nassert next_palindrome(1000) == 2020",
      -7.98046875
    ],
    [
      "def next_smallest_palindrome(num):\n    \"\"\"\n    Time Complexity: O(1)\n    Space Complexity: O(1)\n    \"\"\"\n    str_num = str(num)\n    rev_num = str_num[::-1]\n    if len(str_num) % 2 == 0:\n        len_diff = len(str_num) - len(rev_num)\n        next_smallest = int(str_num + \"0\" * len_diff + rev_num[:len_diff])\n    else:\n        len_diff = len(str_num) - len(rev_num) - 1\n        next_smallest = int(str_num[:-1] + \"0\" * len_diff + rev_num[:len_diff + 1])\n    return next_smallest\n\n\nif __name__ == \"__main__\":\n    assert next_smallest_palindrome(123) == 124\n    assert next_smallest_palindrome(121) == 130\n    assert next_smallest_palindrome(135) == 143\n    assert next_smallest_palindrome(105) == 111\n    assert next_smallest_palindrome(136) == 140\n    assert next_smallest_palindrome(1000) == 1001\n    assert next_smallest_palindrome(1001) == 1010",
      -8.1953125
    ],
    [
      "def next_smallest_palindrome(number: int) -> int:\n    \"\"\"\n    Return the next smallest palindrome after the given number.\n\n    :param number: number\n    :return: next smallest palindrome\n    >>> next_smallest_palindrome(98)\n    102\n    >>> next_smallest_palindrome(123)\n    131\n    >>> next_smallest_palindrome(121)\n    130\n    >>> next_smallest_palindrome(999)\n    1020\n    >>> next_smallest_palindrome(1000)\n    1021\n    >>> next_smallest_palindrome(1020)\n    1030\n    \"\"\"\n    number_str = str(number)\n    if number_str == number_str[::-1]:\n        return int(str(number + 1) + \"0\" + str(number + 1)[:-1])\n    else:\n        return int(\n            \"\".join(\n                [\n                    number_str[: int(len(number_str) / 2)],\n                    str(int(number_str[int(len(number_str) / 2) :]) + 1),\n                ]\n            )\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(next_smallest_palindrome(98))\n    print(next_smallest_palindrome(123))\n    print(next_smallest_palindrome(121))\n    print(next_smallest_palindrome(999))\n    print(next_smallest_palindrome(1000))\n    print(next_smallest_palindrome(1020))",
      -8.25
    ],
    [
      "def next_palindrome(num):\n    \"\"\"\n    :param num: int - number of which the next palindrome is to be found.\n    :return: int - next smallest palindrome.\n    \"\"\"\n    if num < 10:\n        return num\n\n    if num < 100:\n        return 11\n\n    def is_palindrome(n):\n        return n == int(str(n)[::-1])\n\n    def is_palindrome_candidate(n):\n        return (n % 10 != 0) and (n % 10 != 1)\n\n    while not is_palindrome(num):\n        if is_palindrome_candidate(num):\n            return num\n        num += 1\n\n    return num\n\n\nprint(next_palindrome(123))\nprint(next_palindrome(121))\nprint(next_palindrome(11))\nprint(next_palindrome(1000001))\nprint(next_palindrome(101))\nprint(next_palindrome(1000000))\nprint(next_palindrome(1010101))\nprint(next_palindrome(1010102))\nprint(next_palindrome(10101021))",
      -9.171875
    ],
    [
      "class Solution(object):\n    def nextPalindrome(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if not num:\n            return 1\n        if num % 10 == 0:\n            return num + 1\n        digits = self.split(num)\n        digits = self.reverse(digits)\n        self.find(digits)\n        return self.combine(digits)\n\n    def split(self, num):\n        digits = []\n        while num:\n            digits.append(num % 10)\n            num //= 10\n        return digits\n\n    def reverse(self, digits):\n        return digits[::-1]\n\n    def find(self, digits):\n        left, right = 0, len(digits) - 1\n        while left < right:\n            if digits[left] < digits[right]:\n                break\n            left += 1\n        if left >= right:\n            right -= 1\n        while left < right:\n            if digits[left] < digits[right]:\n                break\n            left += 1\n        if left >= right:\n            return\n        digits[left], digits[right] = digits[right], digits[left]\n        left, right = left + 1, right - 1\n        while left < right:\n            if digits[left] <= digits[right]:\n                break\n            digits[left], digits[right] = digits[right], digits[left]\n            left += 1\n            right -= 1\n        if left >= right:\n            return\n        digits[left], digits[right] = digits[right], digits[left]\n        self.find(digits)\n\n    def combine(self, digits):\n        num = 0\n        for digit in digits:\n            num = num * 10 + digit\n        return num\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    num = 1234\n    print s.nextPalindrome(num)",
      -9.3046875
    ],
    [
      "def next_palindrome(num):\n    n = str(num)\n    l = len(n)\n    m = n.zfill(l + 1)\n    if l % 2 == 1:\n        mid = l // 2 + 1\n    else:\n        mid = l // 2\n\n    for i in range(mid - 1, -1, -1):\n        if m[i] != m[l - 1 - i]:\n            m = m[:i] + m[i + 1:]\n            break\n    return int(m)\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(23) == 242\n    assert next_palindrome(27) == 282\n    assert next_palindrome(35) == 363\n    assert next_palindrome(36) == 373\n    assert next_palindrome(123) == 131\n    assert next_palindrome(135) == 141\n    assert next_palindrome(136) == 1401\n    assert next_palindrome(137) == 141\n    assert next_palindrome(12356) == 12456\n    assert next_palindrome(12357) == 12456\n    assert next_palindrome(12358) == 12458\n    assert next_palindrome(12359) == 12459\n    assert next_palindrome(12360) == 12460\n    assert next_palindrome(12361) == 12462\n    assert next_palindrome(12362) == 12462\n    assert next_palindrome(12363) == 12464\n    assert next_palindrome(12364) == 12464\n    assert next_palindrome(12365) == 12466",
      -9.453125
    ],
    [
      "def next_palindrome(n):\n    n = str(n)\n    if len(n) % 2 == 0:\n        l, r = n[: len(n) // 2], n[len(n) // 2 :][::-1]\n    else:\n        l, r = n[: len(n) // 2 + 1], n[len(n) // 2 + 1 :][::-1]\n    for i in range(len(r)):\n        if l[i] > r[i]:\n            r[i] = chr(ord(r[i]) + 1)\n            if i != len(r) - 1:\n                l[i + 1] = chr(ord(l[i + 1]) - 1)\n            else:\n                l[i] = chr(ord(l[i]) - 1)\n            l = l[::-1]\n            break\n    return int(l + r)\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(12) == 22\n    assert next_palindrome(123) == 232\n    assert next_palindrome(1234) == 2343\n    assert next_palindrome(12345) == 23454\n    assert next_palindrome(123456) == 234565\n    assert next_palindrome(1234567) == 2345677\n    assert next_palindrome(12345678) == 23456787\n    assert next_palindrome(123456789) == 234567899\n    assert next_palindrome(1234567890) == 2345678990\n    assert next_palindrome(12345678901) == 23456789901\n    assert next_palindrome(1234567890",
      -9.5546875
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :param n: int - number of which the next palindrome is to be found.\n    :return: int - next palindrome.\n    \"\"\"\n    str_n = str(n)\n    str_n_reverse = str_n[::-1]\n    for i in range(len(str_n) + 1):\n        if str_n[:i] == str_n_reverse[:i]:\n            if len(str_n) - i == 0:\n                return n\n            else:\n                return int(str_n[:i] + str(int(str_n[i:]) + 1))\n    return n\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = next_palindrome(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function((123, 1331))\ntest_function((121, 1221))\ntest_function((1331, 14321))\ntest_function((1487, 15487))\ntest_function((1771, 18717))\ntest_function((1971, 19721))\ntest_function((1000021, 1000100))\ntest_function((12345, 12345))\ntest_function((1000000000, 1000000000))",
      -9.625
    ],
    [
      "import math\n\ndef next_palindrome(n):\n    if n % 10 == 0:\n        return n + 2\n\n    # count the number of digits\n    digits = int(math.log10(n)) + 1\n\n    # get the reversed number\n    rev = 0\n    while n > 0:\n        rev = rev * 10 + n % 10\n        n = n // 10\n\n    # check if the next palindrome is one digit bigger\n    if digits == 1 and rev + 1 <= n:\n        return rev + 1\n\n    # check if the next palindrome is two digits bigger\n    if digits == 1 and rev + 11 <= n:\n        return rev + 11\n\n    # check if the next palindrome is three digits bigger\n    if digits == 1 and rev + 111 <= n:\n        return rev + 111\n\n    # get the mid-point\n    mid = rev + (rev // 10 ** (digits // 2))\n\n    # check if the next palindrome is in the middle\n    if mid <= n:\n        mid += 1\n\n    # add the middle part\n    mid_str = str(mid)[::-1]\n    mid = int(mid_str[:digits // 2] + mid_str[(digits // 2) - 1::-1])\n\n    # add the rest of the number\n    return mid + rev\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert next_palindrome(123) == 131, \"321\"\n    assert next_palindrome(12131) == 1221, \"3311\"\n    assert next_palindrome(12) == 21, \"22\"\n    assert next_palindrome(1001) == 1101, \"1011\"\n    assert next_palindrome(122) == 132, \"323\"",
      -9.71875
    ],
    [
      "from functools import reduce\n\n\ndef next_palindrome(n):\n    if n % 11 == 0:\n        return n + 2\n    return n + (11 - n % 11)\n\n\ndef next_palindrome_naive(n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    s = str(n)\n\n    for i in range(len(s)):\n        p = s[:i] + s[i:][::-1]\n        if int(p) >= n:\n            break\n\n    return int(p)\n\n\ndef next_palindrome_easy(n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    s = str(n)\n    return int(reduce(lambda x, y: x + y, map(str, [int(s[i]) for i in range(len(s))])) + s[:0:-1])\n\n\ndef next_palindrome_medium(n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    s = str(n)\n    if n % 11 == 0:\n        return n + 2\n    return int(s + s[0:1:-1])\n\n\nif __name__ == \"__main__\":\n    num = 12345\n    assert next_palindrome(num) == 12346\n    assert next_palindrome_naive(num) == 12346\n    assert next_palindrome_easy(num) == 12346\n    assert next_palindrome_medium(num) == 12346\n\n    num = 12344\n    assert next_palindrome(num) == 12345\n    assert next_palindrome_naive(num) == 12345\n    assert next_palindrome_easy(num) == 12345\n    assert next_palindrome_medium",
      -9.9765625
    ],
    [
      "def next_palindrome(num):\n    # Convert to a string\n    num_str = str(num)\n\n    # Split it into two parts\n    left, right = num_str[:len(num_str) // 2], num_str[len(num_str) // 2:]\n\n    # Reverse the left part\n    left = left[::-1]\n\n    # If the left part is greater than right part, increment the number\n    if left > right:\n        # Increment the number\n        num += int(\"1\" + \"0\" * (len(num_str) // 2))\n\n    return num\n\n\nif __name__ == \"__main__\":\n    assert next_palindrome(321) == 322\n    assert next_palindrome(123) == 131\n    assert next_palindrome(12) == 22\n    assert next_palindrome(10) == 11\n    assert next_palindrome(11) == 22\n    assert next_palindrome(121) == 130\n    assert next_palindrome(122) == 131\n    assert next_palindrome(123) == 134\n    assert next_palindrome(124) == 135\n    assert next_palindrome(125) == 141\n    assert next_palindrome(126) == 142\n    assert next_palindrome(127) == 143\n    assert next_palindrome(128) == 144\n    assert next_palindrome(129) == 151\n    assert next_palindrome(130) == 141\n    assert next_palindrome(131) == 142\n    assert next_palindrome(132) == 143\n    assert next_palindrome(133) == 144\n    assert next_palindrome(134) == 145\n    assert next_palindrome(135)",
      -10.4609375
    ],
    [
      "def is_palindrome(string):\n    return string == string[::-1]\n\ndef next_palindrome(string):\n    length = len(string)\n\n    if length % 2 == 0:\n        mid = length // 2\n        left = string[:mid]\n        right = string[mid:]\n    else:\n        mid = length // 2 + 1\n        left = string[:mid]\n        right = string[mid + 1:]\n\n    # If we've already got a palindrome, just increment the middle digit\n    if is_palindrome(right):\n        i = length // 2\n        while i >= 0:\n            if string[i] < '9':\n                string = string[:i] + chr(string[i] + 1) + string[i+1:]\n                break\n            else:\n                string = string[:i] + chr(ord('0')) + string[i+1:]\n            i -= 1\n\n    # Otherwise, find the first digit in the left half that can be incremented\n    else:\n        i = mid - 1\n        while i >= 0:\n            if string[i] < '9':\n                string = string[:i] + chr(string[i] + 1) + string[i+1:]\n                string = string[:mid] + chr(ord('0')) + string[mid:]\n                break\n            else:\n                string = string[:i] + chr(ord('0')) + string[i+1:]\n            i -= 1\n\n    return string\n\nfor test in (\n        \"1\",\n        \"10\",\n        \"100\",\n        \"1000\",\n        \"10000\",\n        \"123456789\",\n        \"999999999\",\n        \"9999999999\",\n        \"99999999999\",\n        \"999999999999\",\n        \"9999999999999\",\n        \"99999999999999\",",
      -10.765625
    ],
    [
      "from typing import Tuple\n\n\ndef next_palindrome(number: int) -> Tuple[int, int]:\n    \"\"\"Find the next smallest palindrome of a specified number.\n\n    Args:\n        number (int): Specified number.\n\n    Returns:\n        Tuple[int, int]: Next smallest palindrome and the number of increments\n            required to reach it.\n    \"\"\"\n    number_str = str(number)\n    if not is_palindrome(number_str):\n        next_palindrome_str = increment_string(number_str)\n        return int(next_palindrome_str), len(next_palindrome_str) - len(str(number))\n    else:\n        return -1, -1\n\n\ndef is_palindrome(number: str) -> bool:\n    \"\"\"Check if a number is palindrome.\n\n    Args:\n        number (str): Number to check.\n\n    Returns:\n        bool: True if number is palindrome.\n    \"\"\"\n    return number == number[::-1]\n\n\ndef increment_string(number: str) -> str:\n    \"\"\"Increment a number in string format.\n\n    Args:\n        number (str): Number to increment.\n\n    Returns:\n        str: Incremented number.\n    \"\"\"\n    number = number.zfill(len(number) * 2)\n    output = \"\"\n    carry = 1\n    for i in range(len(number) - 1, -1, -1):\n        if i == len(number) - 1:\n            output = str(carry + int(number[i])) + output\n            carry = 0\n        elif int(number[i]) + carry <= 9:\n            output = str(int(number[i]) + carry) + output\n            carry = 0\n        else:\n            output = \"0\" + output\n            carry = 1\n    return output\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (203, (206, 2)),\n        (200000, (200010,",
      -10.8828125
    ],
    [
      "def next_palindrome(num: int) -> int:\n    \"\"\"\n    >>> next_palindrome(123)\n    224\n    >>> next_palindrome(135)\n    232\n    >>> next_palindrome(121)\n    131\n    >>> next_palindrome(999)\n    1020\n    >>> next_palindrome(1000)\n    1020\n    >>> next_palindrome(1221)\n    1331\n    >>> next_palindrome(1020)\n    1131\n    >>> next_palindrome(1331)\n    1441\n    >>> next_palindrome(9999)\n    10110\n    >>> next_palindrome(10110)\n    11121\n    >>> next_palindrome(10111)\n    11122\n    >>> next_palindrome(12345)\n    12354\n    >>> next_palindrome(12456)\n    12554\n    \"\"\"\n    str_num = str(num)\n    if len(str_num) == 1:\n        return int(str_num)\n\n    if str_num[0] == \"1\":\n        return int(str_num)\n\n    for i in range(len(str_num) // 2):\n        if str_num[i] != str_num[-(i + 1)]:\n            break\n    else:\n        return int(str_num)\n\n    new_num = (\n        str_num[: i + 1]\n        + str_num[i]\n        + str_num[i + 1 : len(str_num) - i]\n        + str_num[i]\n        + str_num[len(str_num) - i - 1 : len(str_num) - 1]\n    )\n    return int(new_num)\n\n\nif __name__ == \"__main__\":\n    import doctest",
      -10.96875
    ],
    [
      "def next_palindrome(n):\n    \"\"\"\n    :param n: int - number\n    :return: int - next smallest palindrome of n\n    \"\"\"\n    # Base cases\n    if n < 10:\n        return n\n    if n % 11 == 0:\n        return n\n    # Convert to string\n    string = str(n)\n    # If string is a palindrome, return the next palindrome\n    if string == string[::-1]:\n        return int(string) + 2\n    # If string is not a palindrome, return the next palindrome\n    # Split string into odd and even parts\n    odd = string[1::2]\n    even = string[0::2]\n    # If the length of odd is even, append the next odd character\n    if len(odd) % 2 == 0:\n        return int(even + odd + odd[::-1])\n    # If the length of odd is odd, append the next odd character\n    else:\n        return int(even + odd + odd[::-1][1:])\n\n\ndef test_function(test_case):\n    test_input, test_expected = test_case\n    test_actual = next_palindrome(test_input)\n    if test_actual == test_expected:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function((123, 121))\ntest_function((121321, 12212))\ntest_function((123021, 1331))\ntest_function((131021, 1331))\ntest_function((1234, 2342))\ntest_function((1242021, 133112))\ntest_function((123, 2232))\ntest_function((124321, 133112))\ntest_function((12321, 23212))\ntest_function((123321, 133212))\ntest_function((1",
      -11.1484375
    ],
    [
      "def find_next_palindrome(num):\n    if num < 10:\n        return None\n    elif num < 100:\n        return [num + 1, num + 2][num % 2 == 0]\n    else:\n        return next_palindrome(str(num))\n\n\ndef next_palindrome(num_str):\n    if num_str < 10:\n        return None\n    elif num_str < 100:\n        return [int(num_str) + 1, int(num_str) + 2][int(num_str) % 2 == 0]\n    elif num_str < 1000:\n        return next_palindrome_helper(num_str, 2)\n    elif num_str < 10000:\n        return next_palindrome_helper(num_str, 3)\n    else:\n        return None\n\n\ndef next_palindrome_helper(num_str, digits):\n    if digits == 1:\n        return int(num_str) + 1\n    else:\n        half = int(len(num_str) / 2)\n        if num_str[half - 1] == '9':\n            return next_palindrome_helper(num_str[:half - 1] + '0' + num_str[half:], digits - 1)\n        else:\n            return next_palindrome_helper(num_str[:half - 1] + str(int(num_str[half - 1]) + 1) + num_str[half:], digits - 1)\n\n\ndef test(num, expected_answer):\n    answer = find_next_palindrome(num)\n\n    if answer != expected_answer:\n        raise Exception(\n            f\"Answer {answer} is wrong. Expected answer is {expected_answer}\")\n\n\nif __name__ == '__main__':\n    test(123, 234)\n    test(124, 234)\n    test(133, 222)\n    test(125,",
      -11.359375
    ],
    [
      "class Solution(object):\n    def __init__(self):\n        self.result = 0\n        self.found = False\n\n    def getNextPalindrome(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # find the next palindrome\n        # 1. find the number of digits\n        # 2. for each digit, set the start and end to the same digit\n        # 3. increment the start and decrement the end until the two pointers meet\n        # 4. for the next digit, set the start and end to the same digit\n        # 5. increment the start and decrement the end until the two pointers meet\n        # 6. repeat 3 and 4 until the two pointers meet\n        # 7. if the two pointers meet, set the start and end to the same digit\n        # 8. increment the start and decrement the end until the two pointers meet\n        # 9. return the result\n        if num < 10:\n            return num\n        num_of_digits = len(str(num))\n        start = num\n        end = num\n        while not self.found:\n            if start % 10 == end % 10:\n                start = start // 10\n                end = end // 10\n            else:\n                break\n        while start >= end and not self.found:\n            self.result = self.result * 10 + start % 10\n            start = start // 10\n            self.result = self.result * 10 + end % 10\n            end = end // 10\n        if not self.found:\n            self.result = self.result * 10 + start % 10\n            self.result = self.result * 10 + end % 10\n            self.found = True\n        return self.result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.getNextPalindrome(1001))\n    print(s.getNextPalindrome(12345))\n    print(s.getNextPalindrome(123445",
      -12.828125
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}