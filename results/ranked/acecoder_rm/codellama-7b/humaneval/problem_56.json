{
  "problem": {
    "task_id": "HumanEval/56",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
    "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
    "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
    "entry_point": "correct_bracketing",
    "docstring": "",
    "problem_id": 56
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "# You can modify the code below\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"<\")\n    False\n    >>> correct_bracketing2(\"<>\")\n    True\n    >>> correct_bracketing2(\"<<><>>\")\n    True\n    >>> correct_bracketing2(\"><<>\")\n    False\n    \"\"\"\n    # You can modify the code below\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      4.01171875
    ],
    [
      "openings = brackets.count('<')\n    closings = brackets.count('>')\n    return openings == closings\n\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"<\")\n    False\n    >>> correct_bracketing2(\"<>\")\n    True\n    >>> correct_bracketing2(\"<<><>>\")\n    True\n    >>> correct_bracketing2(\"><<>\")\n    False\n    \"\"\"\n    openings = brackets.count('<')\n    closings = brackets.count('>')\n    stack = 0\n    for bracket in brackets:\n        if bracket == '<':\n            stack += 1\n        elif bracket == '>':\n            stack -= 1\n        if stack < 0:\n            return False\n    return stack == 0\n\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"<\")\n    False\n    >>> correct_bracketing3(\"<>\")\n    True\n    >>> correct_bracketing3(\"<<><>>\")\n    True\n    >>> correct_bracketing3(\"><<>\")\n    False\n    \"\"\"\n    openings = brackets.count('<')\n    closings = brackets.count('>')\n    stack = 0\n    for bracket in brackets:\n        if bracket == '<':\n            stack += 1\n        elif bracket == '>':\n            stack -= 1\n        if stack < 0:\n            return False\n    return stack == 0\n\n\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing4(\"<\")\n    False\n    >>> correct_bracketing4(\"<>\")\n    True\n    >>> correct_bracketing4(\"<<",
      3.8671875
    ],
    [
      "stack = []\n    for char in brackets:\n        if char == '>':\n            if stack == []:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return stack == []\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == '>':\n            if stack == []:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return stack == []\n\n\ndef correct_bracketing_stack_better(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack_better(\"<\")\n    False\n    >>> correct_bracketing_stack_better(\"<>\")\n    True\n    >>> correct_bracketing_stack_better(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack_better(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == '>':\n            if stack == []:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return stack == []\n\n\ndef correct_bracketing_stack_better_2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack_better_2(\"<\")\n    False\n    >>> correct_bracketing_stack_better_2(\"<>\")\n    True\n    >>> correct_",
      3.85546875
    ],
    [
      "if not brackets:\n        return True\n    bracket_stack = []\n    for b in brackets:\n        if b == '<':\n            bracket_stack.append(b)\n        if b == '>':\n            if bracket_stack:\n                bracket_stack.pop()\n            else:\n                return False\n    return not bracket_stack\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\")(\")\n    False\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"((())\")\n    False\n    \"\"\"\n    if not parens:\n        return True\n    paren_stack = []\n    for p in parens:\n        if p == '(':\n            paren_stack.append(p)\n        if p == ')':\n            if paren_stack:\n                paren_stack.pop()\n            else:\n                return False\n    return not paren_stack\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"][\")\n    False\n    >>> balanced_brackets(\"\")\n    True\n    >>> balanced_brackets(\"[[[]]\")\n    False\n    \"\"\"\n    if not brackets:\n        return True\n    bracket_stack = []\n    for b in brackets:\n        if b == '[':\n            bracket_stack.append(b)\n        if b == ']':\n            if bracket_stack:\n                bracket_stack.pop()\n            else:\n                return False\n    return not bracket_stack\n\n\ndef balanced_parentheses(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parent",
      2.537109375
    ],
    [
      "if len(brackets) % 2 == 1:\n        return False\n\n    opening_brackets = 0\n    for c in brackets:\n        if c == '<':\n            opening_brackets += 1\n        elif c == '>' and opening_brackets > 0:\n            opening_brackets -= 1\n        else:\n            return False\n\n    return opening_brackets == 0\n\n\ndef nested_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> nested_correct_bracketing(\"<\")\n    False\n    >>> nested_correct_bracketing(\"<>\")\n    True\n    >>> nested_correct_bracketing(\"<<><>>\")\n    True\n    >>> nested_correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    # if len(brackets) % 2 == 1:\n    #     return False\n\n    opening_brackets = 0\n    for c in brackets:\n        if c == '<':\n            opening_brackets += 1\n        elif c == '>' and opening_brackets > 0:\n            opening_brackets -= 1\n        else:\n            return False\n\n    return opening_brackets == 0\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n    # print(correct_bracketing('<><<>'))\n    # print(correct_bracketing('<>'))\n    # print(correct_bracketing('<<><>>'))\n    # print(correct_bracketing('><<>'))\n\n    print(nested_correct_bracketing('<><<>'))\n    print(nested_correct_bracketing('<>'))\n    print(nested_correct_bracketing('<<><>>'))\n    print(nested_correct_bracketing('><<>'))\n\nif __name__ == '__main__':\n    main()",
      2.0703125
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(\"<\")\n        elif b == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(\"<\")\n        elif b == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef correct_bracketing_list(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_list(\"<\")\n    False\n    >>> correct_bracketing_list(\"<>\")\n    True\n    >>> correct_bracketing_list(\"<<><>>\")\n    True\n    >>> correct_bracketing_list(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(\"<\")\n        elif b == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.8759765625
    ],
    [
      "\"*** YOUR CODE HERE ***\"\n\n\ndef contains_balanced_brackets(text: str):\n    \"\"\"Return whether text contains balanced brackets.\n\n    >>> contains_balanced_brackets('( ( ) )')\n    True\n    >>> contains_balanced_brackets('( ( ( ( ) ) ) )')\n    True\n    >>> contains_balanced_brackets('( ) ( ) ( ')\n    False\n    >>> contains_balanced_brackets('((((( ( ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )')\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n\ndef html_split(text: str):\n    \"\"\"Return a list of alternating tag and text portions of text.\n\n    >>> print_sequence(html_split('hello<p>this is a paragraph</p>goodbye<p>this is another</p>'))\n    hello\n    <p>this is a paragraph</p>\n    goodbye\n    <p>this is another</p>\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n\ndef print_sequence(sequence):\n    \"\"\"Print the items of sequence.\n\n    >>> print_sequence([4, 2, 3, 0, 1])\n    4\n    2\n    3\n    0\n    1\n    \"\"\"\n    for item in sequence:\n        print(item)\n\n\ndef print_in_order(a, b, c):\n    \"\"\"Print a b c in order.\n\n    >>> print_in_order(2, 4, 1)\n    1\n    2\n    4\n    >>> print_in_order('hello', 'world', '!')\n    !\n    hello\n    world\n    \"\"\"\n    print(c)\n    print(a)\n    print(b)\n\n\ndef is_palindrome(text: str):\n    \"\"\"Return whether text is a palindrome.\n\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('rover')\n    False\n    >>> is_palindrome('racecar')\n    True\n    \"\"\"\n    \"*** YOUR",
      1.8447265625
    ],
    [
      "# if brackets == '':\n    #     return True\n    # if brackets[0] == '<':\n    #     return correct_bracketing(brackets[1:])\n    # if brackets[0] == '>':\n    #     return False\n\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef correct_bracketing_list(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef correct_bracketing_loop(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a",
      1.6884765625
    ],
    [
      "openings = 0\n    for c in brackets:\n        if c == \"<\":\n            openings += 1\n        else:\n            openings -= 1\n        if openings < 0:\n            return False\n    return openings == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    openings = []\n    for c in brackets:\n        if c == \"<\":\n            openings.append(c)\n        else:\n            if len(openings) == 0:\n                return False\n            openings.pop()\n    return len(openings) == 0\n\n\ndef match_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> match_brackets(\"<\")\n    False\n    >>> match_brackets(\"<>\")\n    True\n    >>> match_brackets(\"<<><>>\")\n    True\n    >>> match_brackets(\"><<>\")\n    False\n    \"\"\"\n    openings = []\n    for c in brackets:\n        if c == \"<\":\n            openings.append(c)\n        else:\n            if len(openings) == 0:\n                return False\n            if openings.pop() != \"<\":\n                return False\n    return len(openings) == 0\n\n\ndef match_brackets_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> match_brackets_stack(\"<\")\n    False\n    >>> match_brackets_stack(\"<>\")\n    True\n    >>> match_brackets_stack(\"<<><>>\")",
      1.65234375
    ],
    [
      "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append('<')\n        elif c == '>':\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append('<')\n        elif c == '>':\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_stack_trace(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack_trace(\"<\")\n    False\n    >>> correct_bracketing_stack_trace(\"<>\")\n    True\n    >>> correct_bracketing_stack_trace(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack_trace(\"><<>\")\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append('<')\n        elif c == '>':\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_recursive(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_rec",
      1.5908203125
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_parens(\"(()())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    \"\"\"\n\n    stack = []\n    for b in parens:\n        if b == \"(\":\n            stack.append(b)\n        elif b == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"[\")\n    False\n    \"\"\"\n\n    stack = []\n    for b in brackets:\n        if b == \"[\":\n            stack.append(b)\n        elif b == \"]\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_curly(curly: str):\n    \"\"\" curly is a string of \"{\" and \"}\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_curly(\"{}\")\n    True\n    >>> balanced_curly(\"{\")\n    False\n    \"\"\"\n\n    stack = []\n    for b in curly:\n        if b == \"{\":\n            stack.append(b)\n        elif b == \"}\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_square(square",
      1.5908203125
    ],
    [
      "open_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            open_brackets += 1\n        elif c == \">\":\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n    return open_brackets == 0\n\n\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))\n\n\ndef is_valid_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> is_valid_bracketing(\"<>\")\n    True\n    >>> is_valid_bracketing(\"><<>\")\n    False\n    >>> is_valid_bracketing(\"<<><>>\")\n    True\n    >>> is_valid_bracketing(\"<<><>>>>\")\n    False\n    \"\"\"\n    open_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            open_brackets += 1\n        elif c == \">\":\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n    return open_brackets == 0\n\n\nprint(is_valid_bracketing(\"<>\"))\nprint(is_valid_bracketing(\"><<>\"))\nprint(is_valid_bracketing(\"<<><>>\"))\nprint(is_valid_bracketing(\"<<><>>>>\"))\n\n\ndef is_well_formed_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket\n    and if the brackets are paired correctly.\n\n    >>> is_well_formed_bracketing(\"<>\")\n    True\n    >>> is_well_formed_bracketing(\"><<>\")\n    False\n    >>> is_well_formed_bracketing(\"<<><>>\")\n    True\n    >>> is_well_formed_bracketing(\"<<><>>>>\")",
      1.458984375
    ],
    [
      "opening_brackets = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_brackets += 1\n        elif bracket == \">\":\n            opening_brackets -= 1\n        if opening_brackets < 0:\n            return False\n    return opening_brackets == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    opening_brackets = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_brackets.append(\"(\")\n        elif bracket == \">\":\n            if len(opening_brackets) > 0:\n                opening_brackets.pop()\n            else:\n                return False\n    return len(opening_brackets) == 0\n\n\ndef correct_bracketing_stack_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack_v2(\"<\")\n    False\n    >>> correct_bracketing_stack_v2(\"<>\")\n    True\n    >>> correct_bracketing_stack_v2(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack_v2(\"><<>\")\n    False\n    \"\"\"\n    opening_brackets = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_brackets.append(\"(\")\n        elif bracket == \">\":\n            if len(opening_brackets) > 0:\n                opening_brackets.pop()\n            else:\n                return False\n    return len(opening_brackets) == 0\n\n\ndef correct_bra",
      1.244140625
    ],
    [
      "if len(brackets) % 2 != 0:\n        return False\n    else:\n        count = 0\n        for i in range(len(brackets)):\n            if brackets[i] == \"<\":\n                count += 1\n            if brackets[i] == \">\":\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"<\")\n    False\n    >>> correct_bracketing_v2(\"<>\")\n    True\n    >>> correct_bracketing_v2(\"<<><>>\")\n    True\n    >>> correct_bracketing_v2(\"><<>\")\n    False\n    \"\"\"\n    if len(brackets) % 2 != 0:\n        return False\n    else:\n        count = 0\n        for i in range(len(brackets)):\n            if brackets[i] == \"<\":\n                count += 1\n            if brackets[i] == \">\":\n                count -= 1\n        return count == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      1.02734375
    ],
    [
      "if len(brackets) % 2 != 0:\n        return False\n    stack = []\n    for i in range(len(brackets)):\n        if brackets[i] == '<':\n            stack.append(i)\n        elif brackets[i] == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the set of all indices i such that brackets[i] == '>' and\n    brackets[i-1] == '<'.\n\n    >>> matching_brackets('<>')\n    set()\n    >>> matching_brackets('><')\n    {1}\n    >>> matching_brackets('<<><>>')\n    {1, 3, 4}\n    >>> matching_brackets('><<>')\n    {1}\n    \"\"\"\n    if len(brackets) % 2 != 0:\n        return False\n    stack = []\n    result = set()\n    for i in range(len(brackets)):\n        if brackets[i] == '<':\n            stack.append(i)\n        elif brackets[i] == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                result.add(stack.pop())\n    return result\n\n\ndef count_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of pairs of brackets, i.e.,\n    the number of indices i such that brackets[i] == '>' and\n    brackets[i-1] == '<'.\n\n    >>> count_matching_brackets('<>')\n    0\n    >>> count_matching_brackets('><')\n    1\n    >>> count_matching_brackets('<<><>>')\n    3\n    >>> count_matching_brackets('><<>')\n    1\n    \"\"\"\n    if len(brackets) % 2 != 0:\n        return False\n    stack = []\n    result = 0\n    for i in",
      0.59619140625
    ],
    [
      "stack = []\n    for char in brackets:\n        if char == '>':\n            if not stack:\n                return False\n            stack.pop()\n        elif char == '<':\n            stack.append(char)\n    return not stack\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == '>':\n            if not stack:\n                return False\n            stack.pop()\n        elif char == '<':\n            stack.append(char)\n    return not stack\n\n\ndef correct_bracketing_index(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_index(\"<\")\n    False\n    >>> correct_bracketing_index(\"<>\")\n    True\n    >>> correct_bracketing_index(\"<<><>>\")\n    True\n    >>> correct_bracketing_index(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for index, char in enumerate(brackets):\n        if char == '>':\n            if not stack:\n                return False\n            stack.pop()\n        elif char == '<':\n            stack.append(index)\n    return not stack\n\n\ndef correct_bracketing_index_reversed(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_index_reversed(\"<\")\n    False\n    >>> correct_bracketing_index_reversed(\"<>\")\n    True\n    >>> correct_bracketing_index_reversed(\"",
      0.468017578125
    ],
    [
      "if len(brackets) % 2 == 1:\n        return False\n    return len(brackets) == 2 * brackets.count('<')\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of the indices of the matching brackets.\n\n    >>> matching_brackets(\"<><>\")\n    [(0, 1), (2, 3)]\n    \"\"\"\n    indices = []\n    stack = []\n    for i, b in enumerate(brackets):\n        if b == '<':\n            stack.append(i)\n        elif b == '>':\n            indices.append((stack.pop(), i))\n    return indices\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    return correct_bracketing(brackets) and len(matching_brackets(brackets)) == len(brackets) / 2",
      0.2418212890625
    ],
    [
      "# You need to write this.\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    if not stack:\n        return True\n    return False\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"<\")\n    False\n    >>> correct_bracketing2(\"<>\")\n    True\n    >>> correct_bracketing2(\"<<><>>\")\n    True\n    >>> correct_bracketing2(\"><<>\")\n    False\n    \"\"\"\n    # You need to write this.\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append('<')\n        elif c == '>':\n            if stack and stack.pop() == '<':\n                continue\n            return False\n    return not stack\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"<\")\n    False\n    >>> correct_bracketing3(\"<>\")\n    True\n    >>> correct_bracketing3(\"<<><>>\")\n    True\n    >>> correct_bracketing3(\"><<>\")\n    False\n    \"\"\"\n    # You need to write this.\n    return brackets.count('<') == brackets.count('>')\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing4(\"<\")\n    False\n    >>> correct_bracketing4(\"<>\")\n    True\n    >>> correct_bracketing4(\"<<><>>\")\n    True\n    >>> correct_bracketing4(\"><<>\")\n    False\n    \"\"\"\n    # You need to write this.\n    if not brackets",
      0.2073974609375
    ],
    [
      "count = 0\n    for char in brackets:\n        if char == '<':\n            count += 1\n        elif char == '>':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for char in brackets:\n        if char == '<':\n            stack.append(char)\n        elif char == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      0.0556640625
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"<\")\n    False\n    >>> correct_bracketing2(\"<>\")\n    True\n    >>> correct_bracketing2(\"<<><>>\")\n    True\n    >>> correct_bracketing2(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"<\")\n    False\n    >>> correct_bracketing3(\"<>\")\n    True\n    >>> correct_bracketing3(\"<<><>>\")\n    True\n    >>> correct_bracketing3(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing4(\"<\")\n    False\n    >>> correct_bracketing4(\"<>\")\n    True\n    >>> correct_bracketing4(\"<<><>>\")\n    True\n    >>> correct_bra",
      -0.027496337890625
    ],
    [
      "# TODO: implement correct_bracketing function\n    return True\n\n\ndef contains_correct_bracketing(s: str):\n    \"\"\" s is a string of characters.\n    return True if s contains a substring that is a non-empty string of \"<\" and \">\"\n    such that correct_bracketing(s) is True.\n\n    >>> contains_correct_bracketing('<12341234>')\n    True\n    >>> contains_correct_bracketing('<12341234')\n    False\n    >>> contains_correct_bracketing('<>')\n    True\n    >>> contains_correct_bracketing('<><><><><><><><>')\n    True\n    >>> contains_correct_bracketing('<<><>>')\n    True\n    >>> contains_correct_bracketing('><<>')\n    False\n    \"\"\"\n    # TODO: implement contains_correct_bracketing function\n    return True\n\n\ndef count_bracketing_groups(s: str):\n    \"\"\" s is a string of characters.\n    return the number of non-empty strings of \"<\" and \">\" in s\n    such that correct_bracketing(s) is True.\n\n    >>> count_bracketing_groups('<12341234>')\n    1\n    >>> count_bracketing_groups('<12341234')\n    0\n    >>> count_bracketing_groups('<>')\n    1\n    >>> count_bracketing_groups('<><><><><><><><>')\n    1\n    >>> count_bracketing_groups('<<><>>')\n    2\n    >>> count_bracketing_groups('><<>')\n    0\n    \"\"\"\n    # TODO: implement count_bracketing_groups function\n    return 0\n\n\ndef correct_bracketing_interleaved(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket is immediately followed by a closing bracket\n    and if every closing bracket is immediately preceded by an opening bracket.\n\n    >>> correct_bracketing_interleaved(\"",
      -0.1795654296875
    ],
    [
      "# Your code here\n    # Hint: use a stack to keep track of the opening brackets\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append(c)\n        elif c == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n\n\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n    # Hint: use a stack to keep track of the opening brackets\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append(c)\n        elif c == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n\n\n\n\ndef correct_bracketing_faster(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_faster(\"<\")\n    False\n    >>> correct_bracketing_faster(\"<>\")\n    True\n    >>> correct_bracketing_faster(\"<<><>>\")\n    True\n    >>> correct_bracketing_faster(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n    # Hint: use a stack to keep track of the opening brackets\n    stack = []\n    for c in brackets:\n        if c == '<':\n            stack.append(c)\n        elif c == '>':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n\n\n\n\n\ndef correct_bracketing_faster_set(brackets: str):\n    \"\"\" brackets",
      -0.39306640625
    ],
    [
      "opening_brackets = 0\n    closing_brackets = 0\n\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_brackets += 1\n        if bracket == \">\":\n            closing_brackets += 1\n\n    return opening_brackets == closing_brackets\n\n\ndef nested_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> nested_correct_bracketing(\"<\")\n    False\n    >>> nested_correct_bracketing(\"<>\")\n    True\n    >>> nested_correct_bracketing(\"<<><>>\")\n    True\n    >>> nested_correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    opening_brackets = 0\n    closing_brackets = 0\n\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_brackets += 1\n        if bracket == \">\":\n            closing_brackets += 1\n        if closing_brackets > opening_brackets:\n            return False\n\n    return opening_brackets == closing_brackets\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n    print(nested_correct_bracketing(\"<<>>\"))\n    print(nested_correct_bracketing(\"<<><>>\"))\n    print(nested_correct_bracketing(\"<>\"))\n    print(nested_correct_bracketing(\"<><>\"))\n    print(nested_correct_bracketing(\"<<><>>\"))\n    print(nested_correct_bracketing(\"><<>\"))\n    print(nested_correct_bracketing(\"<><<>\"))\n\n\nif __name__ == \"__main__\":\n    main()",
      -0.69775390625
    ],
    [
      "# TODO: implement this function.\n\n\ndef bracket_depth(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the maximum depth of any nesting in brackets.\n\n    >>> bracket_depth(\">\")\n    1\n    >>> bracket_depth(\"<<><>>\")\n    2\n    >>> bracket_depth(\"><<>\")\n    1\n    \"\"\"\n    # TODO: implement this function.\n\n\ndef matching_pairs(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of (i, j) pairs such that brackets[i] matches brackets[j]\n    and i < j < len(brackets).\n\n    >>> matching_pairs(\">\")\n    []\n    >>> matching_pairs(\"<<><>>\")\n    [(1, 5), (3, 4)]\n    >>> matching_pairs(\"><<>\")\n    []\n    \"\"\"\n    # TODO: implement this function.\n\n\ndef matching_parentheses(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return a list of (i, j) pairs such that parens[i] matches parens[j]\n    and i < j < len(parens).\n\n    >>> matching_parentheses(\"(\")\n    []\n    >>> matching_parentheses(\"(((((((())\")\n    [(1, 10)]\n    \"\"\"\n    # TODO: implement this function.\n\n\ndef matching_square_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return a list of (i, j) pairs such that brackets[i] matches brackets[j]\n    and i < j < len(brackets).\n\n    >>> matching_square_brackets(\"[\")\n    []\n    >>> matching_square_brackets(\"[[[[[[[[]]]]]]]\")\n    [(1, 16)]\n    \"\"\"\n    # TODO: implement this function.\n\n\ndef matching_curly_brackets(brackets: str):\n    \"\"\" brackets is a string of \"{\" and \"}\".\n    return a list of (i, j",
      -0.74267578125
    ],
    [
      "bracket_stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            bracket_stack.append(bracket)\n        elif bracket == '>':\n            if len(bracket_stack) == 0:\n                return False\n            bracket_stack.pop()\n    return len(bracket_stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "# Your code here\n    if len(brackets) % 2 == 1:\n        return False\n\n    stack = []\n    for bracket in brackets:\n        if bracket == '>':\n            if not stack or stack[-1] != '<':\n                return False\n            stack.pop()\n        else:\n            stack.append(bracket)\n\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "if len(brackets) % 2 == 1:\n        return False\n    return brackets.count(\">\") == brackets.count(\"<\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "# Your code here!\n    if len(brackets) % 2 == 1:\n        return False\n    else:\n        return True\n\n\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))",
      -0.85791015625
    ],
    [
      "# Your code here!\n\n\ndef count_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of matching pairs of brackets.\n\n    >>> count_brackets(\">\")\n    0\n    >>> count_brackets(\"<>\")\n    0\n    >>> count_brackets(\"<<><>>\")\n    4\n    >>> count_brackets(\"><<>\")\n    0\n    \"\"\"\n    # Your code here!\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\">\")\n    False\n    >>> balanced_brackets(\"<>\")\n    True\n    >>> balanced_brackets(\"<<><>>\")\n    True\n    >>> balanced_brackets(\"><<>\")\n    False\n    \"\"\"\n    # Your code here!",
      -0.85791015625
    ],
    [
      "# Your code here\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nprint(correct_bracketing(\"><<>\"))",
      -0.85791015625
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef test_correct_bracketing():\n    assert correct_bracketing(\"<\") == False\n    assert correct_bracketing(\"<>\") == True\n    assert correct_bracketing(\"<<><>>\") == True\n    assert correct_bracketing(\"><<>\") == False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85791015625
    ],
    [
      "# 1. initialize a counter of open brackets\n    # 2. for each bracket\n    #      if it's open\n    #          increment counter\n    #      if it's close\n    #          decrement counter\n    # 3. if counter is 0, then brackets are correctly bracketed.\n    #     return True.\n    # 4. otherwise, return False.\n\n    counter = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            counter += 1\n        if bracket == \">\":\n            counter -= 1\n    return counter == 0\n\n\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))",
      -0.85791015625
    ],
    [
      "# Your code here\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))",
      -0.8583984375
    ],
    [
      "# stack = []\n    # for b in brackets:\n    #     if b == '<':\n    #         stack.append(b)\n    #     elif b == '>':\n    #         if stack == []:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return stack == []\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\nprint(correct_bracketing('<<><>>'))\nprint(correct_bracketing('><<>'))",
      -0.8583984375
    ],
    [
      "assert isinstance(brackets, str), \"input must be a string\"\n\n    # count the number of opening and closing brackets\n    opening = brackets.count(\"<\")\n    closing = brackets.count(\">\")\n\n    # return true if both counts are equal\n    return opening == closing\n\n\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))",
      -0.8583984375
    ],
    [
      "# Your code here\n    open = 0\n    for b in brackets:\n        if b == '<':\n            open += 1\n        else:\n            open -= 1\n            if open < 0:\n                return False\n    return open == 0\n\n\nprint(correct_bracketing('<<>>'))",
      -0.8583984375
    ],
    [
      "return check_bracketing(brackets, 0, 0)\n\ndef check_bracketing(brackets, open, close):\n    if open > close:\n        return close == 0\n    if brackets[open] == \"<\":\n        return check_bracketing(brackets, open + 1, close) and \\\n               check_bracketing(brackets, open + 1, close + 1)\n    else:\n        return check_bracketing(brackets, open + 1, close - 1)",
      -0.8583984375
    ],
    [
      "stack = []\n    for bracket in brackets:\n        if bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n        else:\n            stack.append(bracket)\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "# Count the number of opening and closing brackets\n    num_opening = 0\n    num_closing = 0\n    for c in brackets:\n        if c == \"<\":\n            num_opening += 1\n        if c == \">\":\n            num_closing += 1\n\n    # If the number of opening and closing brackets are equal, return True\n    return num_opening == num_closing\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "# Your code here\n\n    if \"<\" not in brackets and \">\" not in brackets:\n        return True\n    if \"<\" not in brackets:\n        return False\n    if \">\" not in brackets:\n        return False\n\n    count = 0\n    for i in range(len(brackets)):\n        if brackets[i] == \"<\":\n            count += 1\n        if brackets[i] == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    if count == 0:\n        return True\n    else:\n        return False",
      -0.8583984375
    ],
    [
      "opening = brackets.count(\"<\")\n    closing = brackets.count(\">\")\n    return opening == closing\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "# TODO: implement this function.\n    # Hint: use a stack\n    # if there are more opening brackets than closing brackets, return False\n    # otherwise, return True\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "open_brackets = 0\n\n    for bracket in brackets:\n        if bracket == '<':\n            open_brackets += 1\n        elif bracket == '>':\n            open_brackets -= 1\n\n        if open_brackets < 0:\n            return False\n\n    return open_brackets == 0\n\n\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<\"))",
      -0.8583984375
    ],
    [
      "if not brackets:\n        return True\n    if brackets[0] == '<':\n        return correct_bracketing(brackets[1:])\n    if brackets[0] == '>':\n        return False\n    return correct_bracketing(brackets[1:])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "open_brackets = 0\n    for c in brackets:\n        if c == '<':\n            open_brackets += 1\n        elif c == '>':\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "stack = []\n\n    for char in brackets:\n        if char == '<':\n            stack.append(char)\n        elif char == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))",
      -0.8583984375
    ],
    [
      "# your code here\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "stack = []\n    for i in brackets:\n        if i == '<':\n            stack.append(i)\n        elif i == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "# Your code here\n    stack = []\n    for b in brackets:\n        if b == '>':\n            if stack == []:\n                return False\n            if stack[-1] == '<':\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(b)\n    return len(stack) == 0",
      -0.8583984375
    ],
    [
      "# Your code here\n    return True\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\" return the number of ways to bracket the expression.\n\n    >>> count_correct_bracketings('a')\n    1\n    >>> count_correct_bracketings('ab')\n    2\n    >>> count_correct_bracketings('abc')\n    3\n    >>> count_correct_bracketings('abcabc')\n    7\n    >>> count_correct_bracketings('abcabcabc')\n    13\n    >>> count_correct_bracketings('abcabcabcabc')\n    27\n    \"\"\"\n    # Your code here\n    return 1\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "if brackets == '':\n        return True\n    if brackets[0] == '<':\n        return correct_bracketing(brackets[1:])\n    if brackets[0] == '>':\n        return False\n    return correct_bracketing(brackets[1:])\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "# YOUR CODE HERE\n    # Hint: Use a stack\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(correct_bracketing(input()))",
      -0.8583984375
    ],
    [
      "open_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            open_brackets += 1\n        elif c == \">\":\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print(correct_bracketing(\"<\"))\n\n\nif __name__ == \"__main__\":\n    main()",
      -0.8583984375
    ],
    [
      "depth = 0\n    for i in range(len(brackets)):\n        if brackets[i] == \">\":\n            depth -= 1\n        if brackets[i] == \"<\":\n            depth += 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return True if not stack else False\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return True if not stack else False\n\n\ndef correct_bracketing_re(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_re(\"<\")\n    False\n    >>> correct_bracketing_re(\"<>\")\n    True\n    >>> correct_bracketing_re(\"<<><>>\")\n    True\n    >>> correct_bracketing_re(\"><<>\")\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return not re.search(r'<[^>]*>', brackets)\n\n\ndef count_change(amount: int) -> int:\n    \"\"\"Return the minimum number of coins needed to change the amount,\n    using pennies, nickels, dimes, and quarters.\n\n    >>> count_change(16)\n    3\n    >>> count_change(10)\n    2\n    >>> count_change(20)\n    4\n    >>> count_change(100) # How many ways to make change for",
      -0.8916015625
    ],
    [
      "stack = []\n\n    for i, bracket in enumerate(brackets):\n        if bracket == \"<\":\n            stack.append(i)\n        elif bracket == \">\" and stack:\n            stack.pop()\n        else:\n            return False\n\n    return len(stack) == 0\n\n\ndef balanced_parens(s: str):\n    \"\"\"\n    >>> balanced_parens(\"((())\")\n    False\n    >>> balanced_parens(\"((()))\")\n    True\n    \"\"\"\n    stack = []\n\n    for i, c in enumerate(s):\n        if c == \"(\":\n            stack.append(i)\n        elif c == \")\" and stack:\n            stack.pop()\n        else:\n            return False\n\n    return len(stack) == 0\n\n\ndef balanced_brackets(s: str):\n    \"\"\"\n    >>> balanced_brackets(\"{{{[()]}}}\")\n    True\n    >>> balanced_brackets(\"{{{[(])]}}}\")\n    False\n    \"\"\"\n    stack = []\n\n    for i, c in enumerate(s):\n        if c == \"[\":\n            stack.append(i)\n        elif c == \"]\" and stack:\n            stack.pop()\n        else:\n            return False\n\n    return len(stack) == 0\n\n\ndef balanced_braces(s: str):\n    \"\"\"\n    >>> balanced_braces(\"{{{[()]}}}\")\n    True\n    >>> balanced_braces(\"{{{[(])]}}}\")\n    False\n    \"\"\"\n    stack = []\n\n    for i, c in enumerate(s):\n        if c == \"{\":\n            stack.append(i)\n        elif c == \"}\" and stack:\n            stack.pop()\n        else:\n            return False\n\n    return len(stack) == 0\n\n\ndef balanced_parentheses(s: str):\n    \"\"\"\n    >>> balanced_parentheses(\"((())\")\n    False\n    >>> balanced_parentheses(\"((()))\")\n    True\n    >>> balanced_parentheses(\"((((((()))))))\")\n    True\n    \"\"\"",
      -1.369140625
    ],
    [
      "return brackets.count('<') == brackets.count('>')\n\n\ndef compute_bracket_depths(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of integers, one for each opening bracket,\n    giving the depth of that bracket (starting at 0 for the outermost brackets).\n\n    >>> compute_bracket_depths('')\n    []\n    >>> compute_bracket_depths('<>')\n    [0, 0]\n    >>> compute_bracket_depths('<><>')\n    [0, 0, 0, 0]\n    >>> compute_bracket_depths('<<><>>')\n    [0, 1, 0, 0]\n    >>> compute_bracket_depths('><<>')\n    [1, 0, 1, 0]\n    \"\"\"\n    depths = []\n    for bracket in brackets:\n        if bracket == '<':\n            depths.append(len(depths))\n        else:\n            depths.pop()\n    return depths\n\n\ndef compute_maximum_depth(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the maximum depth of any opening bracket in brackets.\n\n    >>> compute_maximum_depth('')\n    0\n    >>> compute_maximum_depth('<>')\n    0\n    >>> compute_maximum_depth('<><>')\n    1\n    >>> compute_maximum_depth('<<><>>')\n    1\n    >>> compute_maximum_depth('><<>')\n    2\n    \"\"\"\n    return max(compute_bracket_depths(brackets))\n\n\ndef compute_minimum_depth(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the minimum depth of any opening bracket in brackets.\n\n    >>> compute_minimum_depth('')\n    0\n    >>> compute_minimum_depth('<>')\n    0\n    >>> compute_minimum_depth('<><>')\n    0\n    >>> compute_minimum_depth('<<><>>')\n    2\n    >>>",
      -1.37109375
    ],
    [
      "# Your code here\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        if b == '>':\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"<\")\n    False\n    >>> correct_bracketing_v2(\"<>\")\n    True\n    >>> correct_bracketing_v2(\"<<><>>\")\n    True\n    >>> correct_bracketing_v2(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n    # 1. count the number of opening and closing brackets\n    # 2. compare the number\n    opening = brackets.count('<')\n    closing = brackets.count('>')\n    return opening == closing\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -1.5556640625
    ],
    [
      "# TODO: implement correct_bracketing\n    return False\n\n\ndef count_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of matching pairs of brackets.\n\n    >>> count_brackets(\">\")\n    0\n    >>> count_brackets(\"<>\")\n    0\n    >>> count_brackets(\"<<><>>\")\n    4\n    >>> count_brackets(\"><<>\")\n    0\n    \"\"\"\n    # TODO: implement count_brackets\n    return 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"<<><>>\")\n    True\n    >>> balanced_brackets(\"><<>\")\n    False\n    \"\"\"\n    # TODO: implement balanced_brackets\n    return False",
      -1.55859375
    ],
    [
      "opening_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            opening_brackets += 1\n        elif c == \">\":\n            opening_brackets -= 1\n        if opening_brackets < 0:\n            return False\n    return opening_brackets == 0\n\n\ndef count_corner_corners(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of corner corners in brackets.\n    A corner corner is a pair of brackets \"<..>\" that opens and closes in the same line.\n\n    >>> count_corner_corners(\">\")\n    0\n    >>> count_corner_corners(\"<>\")\n    1\n    >>> count_corner_corners(\"<<>>\")\n    2\n    >>> count_corner_corners(\"><<>\")\n    1\n    >>> count_corner_corners(\"<<><>>\")\n    2\n    \"\"\"\n    opening_brackets = 0\n    corner_corners = 0\n    for c in brackets:\n        if c == \"<\":\n            opening_brackets += 1\n        elif c == \">\":\n            if opening_brackets > 0:\n                corner_corners += 1\n            opening_brackets -= 1\n    return corner_corners\n\n\ndef is_balanced(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if brackets is balanced, i.e. if it contains the same number of opening brackets as closing brackets.\n    >>> is_balanced(\"<\")\n    False\n    >>> is_balanced(\"<>\")\n    True\n    >>> is_balanced(\"<<><>>\")\n    True\n    >>> is_balanced(\"><<>\")\n    False\n    \"\"\"\n    opening_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            opening_brackets += 1\n        elif c == \">\":\n            opening_brackets -= 1\n    return opening_brackets == 0\n\n\ndef is_balanced_simple(brackets: str):\n    \"\"\" brackets is",
      -1.8369140625
    ],
    [
      "stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif len(stack) > 0 and stack[-1] == \"<\":\n            stack.pop()\n        else:\n            return False\n\n    return len(stack) == 0\n\n\ndef bracket_depth(brackets: str):\n    \"\"\" return the maximum depth of a correctly bracketed string.\n    return 0 for an empty string.\n    if brackets is not correctly bracketed, return None.\n\n    >>> bracket_depth(\"<>\")\n    1\n    >>> bracket_depth(\"<<><>>\")\n    2\n    >>> bracket_depth(\"><<>\")\n    \"\"\"\n    if not correct_bracketing(brackets):\n        return None\n\n    stack = []\n    max_depth = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n            max_depth = max(max_depth, len(stack))\n        elif len(stack) > 0 and stack[-1] == \"<\":\n            stack.pop()\n            max_depth = max(max_depth, len(stack))\n        else:\n            return None\n\n    return max_depth\n\n\ndef nested_expression_depth(expression: str):\n    \"\"\" return the maximum depth of a correctly nested expression.\n    return 0 for an empty string.\n    if expression is not correctly nested, return None.\n\n    >>> nested_expression_depth(\"1+2\")\n    0\n    >>> nested_expression_depth(\"1+2*3\")\n    1\n    >>> nested_expression_depth(\"1+2*3^4\")\n    2\n    \"\"\"\n    if len(expression) == 0:\n        return 0\n\n    if len(expression) == 1:\n        return None\n\n    stack = [expression[0]]\n    max_depth = 0\n    for char in expression[1:]:\n        if char == \"(\":\n            stack.append(char)\n            max_depth = max(max_depth, len(stack))\n        elif char == \")\":\n            if len(stack) == 0:",
      -1.9169921875
    ],
    [
      "stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append('<')\n        elif bracket == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> balanced_parens(\"(\")\n    False\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"()()(())\")\n    True\n    >>> balanced_parens(\"())\")\n    False\n    \"\"\"\n    stack = []\n    for paren in parens:\n        if paren == '(':\n            stack.append('(')\n        elif paren == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"[\")\n    False\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"[][][[][]]\")\n    True\n    >>> balanced_brackets(\"]][]\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append('[')\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_parentheses(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> balanced_parentheses(\"(\")\n    False\n    >>> balanced_parentheses(\"()\")\n    True\n    >>> balanced_parentheses(\"()()(())\")\n    True",
      -1.9443359375
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef find_bracketing_errors(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of (start, end) tuples such that:\n    - start is the index of the opening bracket\n    - end is the index of the first closing bracket that matches\n    - there is no bracketing error between start and end\n    - between each pair of indices there is a bracketing error\n    - the first index is 0 and the last index is len(brackets) - 1\n\n    >>> find_bracketing_errors(\"<>\")\n    []\n    >>> find_bracketing_errors(\"<<><>>\")\n    [(0, 3), (3, 6)]\n    >>> find_bracketing_errors(\"><<>\")\n    [(1, 2), (3, 4)]\n    \"\"\"\n    stack = []\n    errors = []\n    for i, b in enumerate(brackets):\n        if b == '<':\n            stack.append((i, b))\n        elif b == '>':\n            if stack == []:\n                errors.append((i, i))\n            else:\n                errors.append((stack.pop()[0], i))\n    return errors\n\n\ndef find_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of (start, end) tuples such that:\n    - start is the index of the opening bracket\n    - end is the index of the first closing bracket that matches\n    - there is no bracketing error between start and end\n    - between each pair of indices there is a bracketing error\n    - the first index is 0 and the last index is len(brackets) - 1\n\n    >>> find_matching_brackets(\"<>\")\n    [(0, 1), (1, 0)]\n    >>> find_matching_brackets(\"<<><",
      -1.9892578125
    ],
    [
      "# TODO: implement correct_bracketing\n    # BEGIN\n    stack = []\n    for c in brackets:\n        if c == \"<\":\n            stack.append(\"<\")\n        elif c == \">\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n    # END\n\n\ndef evaluate_postfix(postfix: str):\n    \"\"\" postfix is a string consisting of the digits 0-9, \"+\", \"-\", and \"*\",\n    in some order.\n    Returns the result of the computation.\n\n    >>> evaluate_postfix(\"2 3 + 4 5 + *\")\n    45\n    >>> evaluate_postfix(\"7 8 + 9 10 + *\")\n    121\n    \"\"\"\n    # TODO: implement evaluate_postfix\n    # BEGIN\n    stack = []\n    for c in postfix:\n        if c.isdigit():\n            stack.append(int(c))\n        else:\n            a = stack.pop()\n            b = stack.pop()\n            if c == \"+\":\n                stack.append(b + a)\n            elif c == \"-\":\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(b * a)\n    return stack.pop()\n    # END\n\n\ndef count_change(amount: float, denominations: list):\n    \"\"\"Return the number of ways to make change for amount.\n    denominations is a sorted list of distinct positive integers\n    \"\"\"\n    # TODO: implement count_change\n    # BEGIN\n    if amount == 0:\n        return 1\n    if amount < 0:\n        return 0\n    if len(denominations) == 0:\n        return 0\n    return count_change(amount, denominations[1:]) + count_change(amount - denominations[0], denominations)\n    # END\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -2.029296875
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == '>':\n            if stack and stack[-1] == '<':\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(b)\n    return len(stack) == 0\n\n\ndef correct_parenthesizing(parentheses: str):\n    \"\"\" parentheses is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> correct_parenthesizing(\"(\")\n    False\n    >>> correct_parenthesizing(\"()\")\n    True\n    >>> correct_parenthesizing(\"())\")\n    False\n    >>> correct_parenthesizing(\"((()))\")\n    True\n    >>> correct_parenthesizing(\"(((((((((((((((((()))))))))))))))))))\")\n    True\n    \"\"\"\n    stack = []\n    for b in parentheses:\n        if b == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(b)\n    return len(stack) == 0\n\n\ndef correct_braces(braces: str):\n    \"\"\" braces is a string of \"{\" and \"}\".\n    return True if every opening brace has a corresponding closing brace.\n\n    >>> correct_braces(\"{\")\n    False\n    >>> correct_braces(\"{}\")\n    True\n    >>> correct_braces(\"{}{}\")\n    True\n    >>> correct_braces(\"{{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{",
      -2.14453125
    ],
    [
      "open_brackets = 0\n    for b in brackets:\n        if b == \"<\":\n            open_brackets += 1\n        else:\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> matching_brackets(\"<>\")\n    True\n    >>> matching_brackets(\"<<><>>\")\n    True\n    >>> matching_brackets(\"><<>\")\n    False\n    \"\"\"\n    open_brackets = []\n    for b in brackets:\n        if b == \"<\":\n            open_brackets.append(b)\n        else:\n            if len(open_brackets) == 0:\n                return False\n            if b != \">\" or b != open_brackets[-1]:\n                return False\n            open_brackets.pop()\n    return len(open_brackets) == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    open_brackets = []\n    for b in brackets:\n        if b == \"<\":\n            open_brackets.append(b)\n        else:\n            if len(open_brackets) == 0:\n                return False\n            if b != \">\" or b != open_brackets[-1]:\n                return False\n            open_brackets.pop()\n    return len(open_brackets) == 0\n\n\ndef matching_brackets_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> matching_brackets_stack(\"<>",
      -2.26953125
    ],
    [
      "stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\ndef matching_pairs(s: str):\n    \"\"\"Returns a list of all matching pairs of parentheses in s.\n    >>> matching_pairs('abc')\n    []\n    >>> matching_pairs('a(b)c')\n    [(1, 3)]\n    >>> matching_pairs('a(b)(c)d')\n    [(1, 5), (2, 4)]\n    >>> matching_pairs('(a(b)c)(d(e)f)g')\n    [(0, 13), (1, 11), (2, 9), (3, 5), (8, 12)]\n    \"\"\"\n    stack = []\n    pairs = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')' and stack != []:\n            pairs.append((stack.pop(), i))\n    return pairs\n\n\ndef nested_expression_value(exp: str):\n    \"\"\"\n    >>> nested_expression_value('1 + 2')\n    3\n    >>> nested_expression_value('(1 + 2) * 3 + 4')\n    15\n    \"\"\"\n    pairs = matching_pairs(exp)\n    for start, end in pairs:\n        inner = nested_expression_value(exp[start + 1:end])\n        exp = exp[:start] + str(inner) + exp[end + 1:]\n    return eval(exp)\n\n\ndef unmatched_expression(exp: str):\n    \"\"\"\n    >>> unmatched_expression('(1 + 2) * 3 + 4')\n    '(1 + 2) * 3 + 4'\n    >>> unmatched_expression('(1 + 2) * (3 + (4))')\n    '(4)'\n    >>> unmatched_",
      -2.275390625
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append('<')\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket\n    and if the number of opening brackets equals the number of closing brackets.\n\n    >>> balanced_brackets(\"<\")\n    False\n    >>> balanced_brackets(\"<>\")\n    True\n    >>> balanced_brackets(\"<<><>>\")\n    True\n    >>> balanced_brackets(\"><<>\")\n    False\n    >>> balanced_brackets(\"<<<>>\")\n    True\n    >>> balanced_brackets(\"<><>\")\n    False\n    \"\"\"\n    if len(brackets) % 2 != 0:\n        return False\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append('<')\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every closing bracket has a corresponding opening bracket\n    and if the number of opening brackets equals the number of closing brackets.\n\n    >>> matching_brackets(\"<\")\n    False\n    >>> matching_brackets(\"<>\")\n    False\n    >>> matching_brackets(\"<<><>>\")\n    True\n    >>> matching_brackets(\"><<>\")\n    False\n    >>> matching_brackets(\"<<<>>\")\n    True\n    >>> matching_brackets(\"<><>\")\n    False\n    \"\"\"\n    if len(brackets) % 2 != 0:\n        return False\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append('<')\n        else:\n            if not stack:\n                return False\n            if stack[-1] != '<':\n                return False\n            stack.pop()\n    return not stack\n\n\ndef matching_",
      -2.279296875
    ],
    [
      "open_brackets = 0\n    for char in brackets:\n        if char == '<':\n            open_brackets += 1\n        elif char == '>' and open_brackets > 0:\n            open_brackets -= 1\n        elif char == '>' and open_brackets == 0:\n            return False\n    return open_brackets == 0\n\n\ndef count_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of pairs of brackets that correctly bracket a subsequence\n\n    >>> count_brackets(\"><<>\")\n    2\n    >>> count_brackets(\"<<><>>\")\n    1\n    >>> count_brackets(\"<>\")\n    0\n    \"\"\"\n    open_brackets = 0\n    count = 0\n    for char in brackets:\n        if char == '<':\n            open_brackets += 1\n        elif char == '>' and open_brackets > 0:\n            open_brackets -= 1\n        elif char == '>' and open_brackets == 0:\n            count += 1\n    return count\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"<\")\n    False\n    >>> correct_bracketing_v2(\"<>\")\n    True\n    >>> correct_bracketing_v2(\"<<><>>\")\n    True\n    >>> correct_bracketing_v2(\"><<>\")\n    False\n    \"\"\"\n    open_brackets = 0\n    for char in brackets:\n        if char == '<':\n            open_brackets += 1\n        elif char == '>' and open_brackets > 0:\n            open_brackets -= 1\n        elif char == '>' and open_brackets == 0:\n            return False\n    return open_brackets == 0\n\n\ndef count_brackets_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of pairs",
      -2.484375
    ],
    [
      "if not brackets:\n        return True\n    elif brackets[0] == \"<\":\n        return correct_bracketing(brackets[1:])\n    elif brackets[0] == \">\":\n        return correct_bracketing(brackets[1:]) and correct_bracketing(brackets[1:])\n    else:\n        return False\n\n\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"\"))\nprint(correct_bracketing(\"<\"))\nprint(correct_bracketing(\"<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"<<><>>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))\nprint(correct_bracketing(\"><<>\"))",
      -2.65234375
    ],
    [
      "open_brackets = 0\n    for c in brackets:\n        if c == '<':\n            open_brackets += 1\n        if c == '>' and open_brackets > 0:\n            open_brackets -= 1\n    return open_brackets == 0\n\n\ndef first_wrong_bracket(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return position of first bracket that is not balanced.\n    If all brackets are balanced, return -1.\n\n    >>> first_wrong_bracket(\"<<><>>\")\n    -1\n    >>> first_wrong_bracket(\"><<>\")\n    2\n    >>> first_wrong_bracket(\"<\")\n    0\n    >>> first_wrong_bracket(\">\")\n    0\n    \"\"\"\n    open_brackets = 0\n    for i, c in enumerate(brackets):\n        if c == '<':\n            open_brackets += 1\n        if c == '>' and open_brackets > 0:\n            open_brackets -= 1\n        if open_brackets == 0:\n            continue\n        if c == '>':\n            return i\n    return len(brackets)\n\n\ndef remove_outer_matching_brackets(s: str):\n    \"\"\" return s with outermost matching brackets removed.\n    If there are no matching brackets, return s.\n\n    >>> remove_outer_matching_brackets('abc')\n    'abc'\n    >>> remove_outer_matching_brackets('xyz')\n    'xyz'\n    >>> remove_outer_matching_brackets('(abc)')\n    'abc'\n    >>> remove_outer_matching_brackets('(abc')\n    '(abc'\n    >>> remove_outer_matching_brackets(')abc')\n    ')abc'\n    >>> remove_outer_matching_brackets('abc)')\n    'abc)'\n    >>> remove_outer_matching_brackets('ab(cd)ef')\n    'ab(cd)ef'\n    >>> remove_outer_matching_brackets('ab(c(d))ef')\n    '",
      -3.099609375
    ],
    [
      "# Your code here\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n\n\ndef correct_bracketing_re(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_re(\"<\")\n    False\n    >>> correct_bracketing_re(\"<>\")\n    True\n    >>> correct_bracketing_re(\"<<><>>\")\n    True\n    >>> correct_bracketing_re(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -3.185546875
    ],
    [
      "\"*** YOUR CODE HERE ***\"\n\n\ndef count_bracket_pairs(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of matching pairs of brackets.\n\n    >>> count_bracket_pairs(\"<\")\n    0\n    >>> count_bracket_pairs(\"<>\")\n    1\n    >>> count_bracket_pairs(\"<><><\")\n    3\n    >>> count_bracket_pairs(\"add some <brackets> here and <here> too.\")\n    4\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n\ndef nested_expression_value(exp: str):\n    \"\"\"Returns the value of the expression.\n\n    >>> nested_expression_value(\"(2)\")\n    2\n    >>> nested_expression_value(\"(2+3)\")\n    5\n    >>> nested_expression_value(\"((2+3))\")\n    5\n    >>> nested_expression_value(\"((2+3)*(5-1))\")\n    16\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n\ndef calculate_value(exp: str):\n    \"\"\"Returns the value of the expression.\n\n    >>> calculate_value(\"(2)\")\n    2\n    >>> calculate_value(\"(2+3)\")\n    5\n    >>> calculate_value(\"(2+3)*4\")\n    20\n    >>> calculate_value(\"(2+3)*(5-1)\")\n    16\n    >>> calculate_value(\"((2+3)*4)*5\")\n    100\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\n\ndef is_operator(char: str):\n    \"\"\"\n    >>> is_operator('+')\n    True\n    >>> is_operator('*')\n    True\n    >>> is_operator('(')\n    False\n    >>> is_operator('2')\n    False\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"",
      -3.240234375
    ],
    [
      "depth = 0\n    for char in brackets:\n        if char == '>':\n            depth -= 1\n        else:\n            depth += 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n\ndef balanced_brackets(s: str):\n    \"\"\"\n    s is a string.\n    return True if all brackets in s are balanced.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"([])\")\n    True\n    >>> balanced_brackets(\"([{])\")\n    False\n    \"\"\"\n    return correct_bracketing(s) and correct_bracketing(s[::-1])\n\n\ndef balanced_brackets_with_stack(s: str):\n    \"\"\"\n    s is a string.\n    return True if all brackets in s are balanced.\n\n    >>> balanced_brackets_with_stack(\"()\")\n    True\n    >>> balanced_brackets_with_stack(\"[]\")\n    True\n    >>> balanced_brackets_with_stack(\"([])\")\n    True\n    >>> balanced_brackets_with_stack(\"([{])\")\n    False\n    \"\"\"\n    stack = []\n    for char in s:\n        if char in \"({[\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            top = stack.pop()\n            if top + char not in [\"()\", \"[]\", \"{}\"]:\n                return False\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -3.306640625
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\" and stack:\n            stack.pop()\n        else:\n            return False\n    return not stack\n\n\ndef find_corresponding_bracket(brackets: str, i: int):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the index of the corresponding closing bracket of brackets[i].\n\n    >>> find_corresponding_bracket(\"<<><>>\", 0)\n    7\n    >>> find_corresponding_bracket(\"><<>\", 0)\n    None\n    \"\"\"\n    if brackets[i] == \"<\":\n        open_brackets = 1\n        for j in range(i+1, len(brackets)):\n            if brackets[j] == \"<\":\n                open_brackets += 1\n            elif brackets[j] == \">\" and open_brackets > 0:\n                open_brackets -= 1\n            elif brackets[j] == \">\" and open_brackets == 0:\n                return j\n    return None\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"<<><>>\")\n    True\n    >>> balanced_brackets(\"><<>\")\n    False\n    \"\"\"\n    return correct_bracketing(brackets)\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of ways to correctly bracket the expression.\n\n    >>> count_correct_bracketing(\"<<><>>\")\n    1\n    >>> count_correct_bracketing(\"><<>\")\n    0\n    \"\"\"\n    if not brackets:\n        return 1\n    if brackets[0] == \">\":\n        return 0\n    if len(brackets) == 1:\n        return 1\n    count = 0\n    for i in range(1, len(brackets)):\n        if find_corresponding_",
      -3.50390625
    ],
    [
      "# Your code here!\n    # Hint: You might want to use a stack.\n    pass\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")\")\n    False\n    >>> balanced_parens(\")(()\")\n    False\n    \"\"\"\n    # Your code here!\n    # Hint: You might want to use a stack.\n    pass\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"[[\")\n    False\n    >>> balanced_brackets(\"]\")\n    False\n    >>> balanced_brackets(\"][[\")\n    False\n    \"\"\"\n    # Your code here!\n    # Hint: You might want to use a stack.\n    pass\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      -3.564453125
    ],
    [
      "# TODO: implement this function.\n    # Hint: use a stack to keep track of opening brackets.\n    # Hint: a stack is a LIFO data structure, like a stack of plates.\n    # Hint: use the list function append to add to the end of a list.\n    # Hint: use the list function pop to remove an item from a list.\n    # Hint: you will need to pass through the string only once.\n    # Hint: remember that strings can be indexed!\n    # Hint: you can compare a string to a single character using ==.\n    # Hint: you will need a while loop.\n    pass\n\n\ndef matches(opening_bracket, closing_bracket):\n    \"\"\" Returns True if the two brackets match.\n    \"\"\"\n    # TODO: implement this function.\n    # Hint: a pair of brackets matches if one is '(' and the other is ')'.\n    # Hint: the relation is not symmetric!\n    pass\n\n\ndef nested_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> nested_correct_bracketing(\"<\")\n    False\n    >>> nested_correct_bracketing(\"<>\")\n    True\n    >>> nested_correct_bracketing(\"<<><>>\")\n    True\n    >>> nested_correct_bracketing(\"><<>\")\n    False\n    >>> nested_correct_bracketing(\"<<><>>>><<\")\n    False\n    >>> nested_correct_bracketing(\"<<><<>>>><\")\n    True\n    \"\"\"\n    # TODO: implement this function.\n    # Hint: use a stack to keep track of opening brackets.\n    # Hint: a stack is a LIFO data structure, like a stack of plates.\n    # Hint: use the list function append to add to the end of a list.\n    # Hint: use the list function pop to remove an item from a list.\n    # Hint: you will need to pass through the string only once.\n    # Hint: remember that strings can be indexed!\n    # Hint: you can compare a string",
      -3.705078125
    ],
    [
      "openings = brackets.count('<')\n    closings = brackets.count('>')\n    return openings == closings\n\n\n\ndef nested_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket\n    and all brackets are correctly nested.\n\n    >>> nested_correct_bracketing(\"<<<>>>\")\n    True\n    >>> nested_correct_bracketing(\"<<<>\")\n    False\n    \"\"\"\n    pass\n\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of pairs of the indices in brackets that match.\n    Assume that the brackets match.\n\n    >>> matching_brackets(\">><<\")\n    [(0, 1), (1, 2), (2, 3)]\n    >>> matching_brackets(\"<><>\")\n    [(0, 1), (2, 3)]\n    \"\"\"\n    pass\n\n\n\ndef all_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of all pairs of the indices in brackets that match.\n    Assume that the brackets match.\n\n    >>> all_matching_brackets(\">><<\")\n    [(0, 1), (1, 2), (2, 3)]\n    >>> all_matching_brackets(\"<<><>>\")\n    [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n    \"\"\"\n    pass\n\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the length of the longest prefix of brackets in which all brackets\n    are properly nested.\n\n    >>> balanced_brackets(\">><<\")\n    2\n    >>> balanced_brackets(\"<<><>>\")\n    6\n    \"\"\"\n    pass\n\n\n\ndef all_balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<",
      -4.12890625
    ],
    [
      "assert brackets.count(\"<\") == brackets.count(\">\")\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"<\")\n    False\n    >>> correct_bracketing_v2(\"<>\")\n    True\n    >>> correct_bracketing_v2(\"<<><>>\")\n    True\n    >>> correct_bracketing_v2(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -4.17578125
    ],
    [
      "opening_brackets = brackets.count(\"<\")\n    closing_brackets = brackets.count(\">\")\n    return opening_brackets == closing_brackets\n\n\ndef is_well_formed_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket\n    and also if the brackets are nested correctly.\n\n    >>> is_well_formed_bracketing(\"<\")\n    False\n    >>> is_well_formed_bracketing(\"<>\")\n    True\n    >>> is_well_formed_bracketing(\"<<><>>\")\n    True\n    >>> is_well_formed_bracketing(\"><<>\")\n    False\n    >>> is_well_formed_bracketing(\"<><>\")\n    False\n    >>> is_well_formed_bracketing(\"<><><>\")\n    False\n    >>> is_well_formed_bracketing(\"<><><><>\")\n    False\n    \"\"\"\n    # can you think of a better variable name than brackets?\n    # if brackets is empty, it's well-bracketed\n    if brackets == \"\":\n        return True\n\n    # if brackets is not well-bracketed, it has to have an unmatched closing bracket\n    if brackets[-1] == \">\" and not correct_bracketing(brackets):\n        return False\n\n    # if brackets is not well-bracketed, it has to have an unmatched opening bracket\n    if brackets[0] == \"<\" and not correct_bracketing(brackets):\n        return False\n\n    # if brackets is not well-bracketed, it has to have an unmatched closing bracket\n    if not correct_bracketing(brackets):\n        return False\n\n    # now we just need to check the prefix\n    return is_well_formed_bracketing(brackets[1:-1])",
      -4.2421875
    ],
    [
      "# Your code here\n\n    # this version is simpler, but less efficient\n    # return brackets.count(\"<\") == brackets.count(\">\")\n\n    # this version is more efficient\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef correct_bracketing_stack_with_function(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack_with_function(\"<\")\n    False\n    >>> correct_bracketing_stack_with_function(\"<>\")\n    True\n    >>> correct_bracketing_stack_with_function(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack_with_function(\"><<>\")\n    False\n    \"\"\"\n    # Your code here\n    return check_stack([])(brackets)\n\n\ndef check_stack(stack):\n    def func(b: str):\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack == []:\n                return False\n            stack.pop()\n        return stack == []\n    return func\n\n\ndef correct_bra",
      -4.60546875
    ],
    [
      "# your code here\n    count = 0\n    for b in brackets:\n        if b == '<':\n            count += 1\n        elif b == '>' and count > 0:\n            count -= 1\n        else:\n            return False\n    return count == 0\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\"Return the number of ways the brackets in the string can be bracketed.\n\n    >>> count_correct_bracketings('[][]')\n    1\n    >>> count_correct_bracketings('()(())')\n    2\n    >>> count_correct_bracketings('[[[[()]]]')\n    1\n    >>> count_correct_bracketings('[[[[([])]])]')\n    2\n    \"\"\"\n    if len(brackets) == 0:\n        return 0\n    if len(brackets) == 1:\n        return 1\n    if brackets[0] == '(':\n        return count_correct_bracketings(brackets[1:])\n    if brackets[0] == ')':\n        return 0\n    if brackets[0] == '[':\n        return count_correct_bracketings(brackets[1:]) + count_correct_bracketings(brackets[1:])\n    if brackets[0] == ']':\n        return 0\n    if brackets[0] == '<':\n        return count_correct_bracketings(brackets[1:]) + count_correct_bracketings(brackets[1:])\n    if brackets[0] == '>':\n        return 0",
      -4.703125
    ],
    [
      "# The number of opening and closing brackets are the same\n    return brackets.count('<') == brackets.count('>')\n\n\ndef matching_pairs(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a list of pairs of indices i,j such that\n    brackets[i] + brackets[j] is a string of matching brackets.\n\n    >>> matching_pairs('')\n    []\n    >>> matching_pairs('<>')\n    [(0, 1)]\n    >>> matching_pairs('<<>>')\n    [(0, 3), (1, 2)]\n    >>> matching_pairs('<<><>>')\n    [(0, 3), (1, 2), (4, 7)]\n    \"\"\"\n    pairs = []\n    while '<' in brackets:\n        for i in range(len(brackets)):\n            if brackets[i] == '<':\n                break\n        for j in range(i, len(brackets)):\n            if brackets[j] == '>':\n                pairs.append((i, j))\n                brackets = brackets[:i] + brackets[i+1:j] + brackets[j+1:]\n                break\n    return pairs\n\n\ndef match_parens(parens: str):\n    \"\"\" parens is a string of '(' and ')'.\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> match_parens('')\n    True\n    >>> match_parens('()')\n    True\n    >>> match_parens('()()(())')\n    True\n    >>> match_parens(')(')\n    False\n    >>> match_parens('(()')\n    False\n    \"\"\"\n    return parens.count('(') == parens.count(')')\n\n\ndef count_matching_parens(parens: str):\n    \"\"\" parens is a string of '(' and ')'.\n    return the number of (possibly empty) substrings consisting of matching pairs of parens.\n\n    >>> count_matching_parens('')\n    0\n    >>> count_matching_parens('()')\n    1\n    >>> count_matching_par",
      -4.8359375
    ],
    [
      "# return brackets.count(\">\") == brackets.count(\"<\")\n    # or, using a stack:\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\ndef remove_outer_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a string with the outermost matching brackets removed,\n    even if they are not balanced.\n\n    >>> remove_outer_matching_brackets(\"\")\n    ''\n    >>> remove_outer_matching_brackets(\"<>\")\n    '<>\n    >>> remove_outer_matching_brackets(\">><<\")\n    '><<>\n    >>> remove_outer_matching_brackets(\"<<><>>\")\n    '><<>\n    >>> remove_outer_matching_brackets(\"><<>\")\n    '><<>\n    \"\"\"\n    if not brackets:\n        return \"\"\n    if brackets[0] != \"<\":\n        return brackets[0] + remove_outer_matching_brackets(brackets[1:])\n    if brackets[-1] != \">\":\n        return brackets[-1] + remove_outer_matching_brackets(brackets[:-1])\n    if brackets[0] == \">\" or brackets[-1] == \"<\":\n        return remove_outer_matching_brackets(brackets[1:-1])\n\n\ndef remove_outer_matching_brackets_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a string with the outermost matching brackets removed,\n    even if they are not balanced.\n\n    >>> remove_outer_matching_brackets_stack(\"\")\n    ''\n    >>> remove_outer_matching_brackets_stack(\"<>\")\n    '<>\n    >>> remove_outer_matching_brackets_stack(\">><<\")\n    '><<>\n    >>> remove_outer_matching_brackets_stack(\"<<><>>\")\n    '><<>",
      -4.90625
    ],
    [
      "# Your code here\n\n\ndef count_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of pairs of brackets that can be removed to make\n    the string balanced.\n\n    >>> count_brackets(\">><<><>\")\n    2\n    >>> count_brackets(\"<<><>>\")\n    0\n    >>> count_brackets(\"><<>\")\n    4\n    \"\"\"\n    # Your code here\n\n\ndef remove_extra_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return brackets with the minimum number of pairs of brackets\n    that can be removed to make the string balanced.\n\n    >>> remove_extra_brackets(\"<<><>>\")\n    '><>'\n    >>> remove_extra_brackets(\">><<><>\")\n    '<><>'\n    >>> remove_extra_brackets(\"><<>\")\n    ''\n    \"\"\"\n    # Your code here\n\n\ndef remove_extra_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return brackets with the minimum number of pairs of brackets\n    that can be removed to make the string balanced.\n\n    >>> remove_extra_brackets(\"<<><>>\")\n    '><>'\n    >>> remove_extra_brackets(\">><<><>\")\n    '<><>'\n    >>> remove_extra_brackets(\"><<>\")\n    ''\n    \"\"\"\n    # Your code here\n\n\ndef remove_extra_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return brackets with the minimum number of pairs of brackets\n    that can be removed to make the string balanced.\n\n    >>> remove_extra_brackets(\"<<><>>\")\n    '><>'\n    >>> remove_extra_brackets(\">><<><>\")\n    '<><>'\n    >>> remove_extra_brackets(\"><<>\")\n    ''\n    \"\"\"\n    # Your code here\n\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket",
      -5.046875
    ],
    [
      "# TODO: implement this\n    pass\n\n\ndef count_bracket_pairs(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\"\n    return the number of matching pairs of brackets.\n\n    >>> count_bracket_pairs(\"<\")\n    0\n    >>> count_bracket_pairs(\"<>\")\n    1\n    >>> count_bracket_pairs(\"<<><>>\")\n    2\n    >>> count_bracket_pairs(\"><<>\")\n    0\n    \"\"\"\n    # TODO: implement this\n    pass\n\n\ndef contains_correct_bracketing(tokens: list):\n    \"\"\" tokens is a list of strings.\n    return True if every token is either a bracket or has a matching pair of brackets.\n    ignore whitespace\n\n    >>> contains_correct_bracketing([\"<\", \">\"])\n    True\n    >>> contains_correct_bracketing([\"<\", \"a\"])\n    False\n    >>> contains_correct_bracketing([\"<\", \"a\", \">\"])\n    True\n    >>> contains_correct_bracketing([\"<\", \"a\", \"b\", \">\"])\n    True\n    >>> contains_correct_bracketing([\"a\", \">\", \"b\"])\n    False\n    >>> contains_correct_bracketing([\"a\", \"b\"])\n    False\n    \"\"\"\n    # TODO: implement this\n    pass\n\n\ndef extract_tokens(bracketed_string: str):\n    \"\"\" bracketed_string is a string containing bracketing.\n    return a list of the tokens, ignoring brackets and extra whitespace\n\n    >>> extract_tokens(\"< a b >\")\n    ['a', 'b']\n    >>> extract_tokens(\"a b c\")\n    ['a', 'b', 'c']\n    >>> extract_tokens(\"a b c < d >\")\n    ['a', 'b', 'c', 'd']\n    \"\"\"\n    # TODO: implement this\n    pass\n\n\ndef extract_bracketed_tokens(bracketed_string: str):\n    \"\"\" bracketed_string is a string containing bracketing.\n    return a list of the tokens, including the brackets but excluding",
      -5.15625
    ],
    [
      "# 1. Count the opening and closing brackets\n    count_open = brackets.count('<')\n    count_close = brackets.count('>')\n\n    # 2. return true if they are equal\n    return count_open == count_close\n\n\ndef is_well_formed(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every closing bracket has a corresponding opening bracket.\n\n    >>> is_well_formed(\"<>\")\n    True\n    >>> is_well_formed(\"<><>\")\n    True\n    >>> is_well_formed(\"><<>\")\n    False\n    >>> is_well_formed(\"<<><>>\")\n    True\n    \"\"\"\n    # 1. Count the opening and closing brackets\n    count_open = brackets.count('<')\n    count_close = brackets.count('>')\n\n    # 2. return true if they are equal\n    return count_open == count_close\n\n\ndef contains_matching_pair(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if there are two consecutive opening or closing brackets.\n\n    >>> contains_matching_pair(\"<>\")\n    True\n    >>> contains_matching_pair(\"<><>\")\n    True\n    >>> contains_matching_pair(\"><<>\")\n    False\n    >>> contains_matching_pair(\"<<><>>\")\n    True\n    \"\"\"\n    # 1. Count the opening and closing brackets\n    count_open = brackets.count('<')\n    count_close = brackets.count('>')\n\n    # 2. return true if they are equal\n    return count_open == count_close\n\n\ndef is_nested(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if there are two consecutive opening or closing brackets.\n\n    >>> is_nested(\"<>\")\n    False\n    >>> is_nested(\"<><>\")\n    False\n    >>> is_nested(\"><<>\")\n    True\n    >>> is_nested(\"<<><>>\")\n    False\n    \"\"\"\n    # 1. Count the opening and closing brackets\n    count_open =",
      -5.75390625
    ],
    [
      "stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"<\")\n    False\n    >>> correct_bracketing_stack(\"<>\")\n    True\n    >>> correct_bracketing_stack(\"<<><>>\")\n    True\n    >>> correct_bracketing_stack(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"<\":\n            stack.append(b)\n        elif b == \">\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_recursive(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_recursive(\"<\")\n    False\n    >>> correct_bracketing_recursive(\"<>\")\n    True\n    >>> correct_bracketing_recursive(\"<<><>>\")\n    True\n    >>> correct_bracketing_recursive(\"><<>\")\n    False\n    \"\"\"\n    if len(brackets) == 0:\n        return True\n    elif brackets[0] == \"<\":\n        return correct_bracketing_recursive(brackets[1:])\n    elif brackets[0] == \">\":\n        return False\n\n\ndef correct_bracketing_recursive_stack(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_recursive_stack(\"<\")\n    False\n    >>> correct_bra",
      -5.78125
    ],
    [
      "open_brackets = 0\n    for b in brackets:\n        if b == \"<\":\n            open_brackets += 1\n        elif b == \">\":\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef max_nonoverlapping_segments(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the maximum number of non-empty, non-overlapping segments of the string.\n\n    >>> max_nonoverlapping_segments(\"<\")\n    0\n    >>> max_nonoverlapping_segments(\"<>\")\n    1\n    >>> max_nonoverlapping_segments(\"<><\")\n    2\n    >>> max_nonoverlapping_segments(\"<<><>>\")\n    3\n    >>> max_nonoverlapping_segments(\"><<>\")\n    0\n    \"\"\"\n    open_brackets = 0\n    max_segments = 0\n    for b in brackets:\n        if b == \"<\":\n            open_brackets += 1\n        elif b == \">\":\n            open_brackets -= 1\n        max_segments = max(max_segments, open_brackets)\n    return max_segments\n\n\ndef count_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return a pair of the numbers of opening and closing brackets.\n\n    >>> count_brackets(\"<\")\n    (1, 0)\n    >>> count_brackets(\"<>\")\n    (1, 1)\n    >>> count_brackets(\"<><\")\n    (2, 1)\n    >>> count_brackets(\"<<><>>\")\n    (3, 3)\n    >>> count_brackets(\"><<>\")\n    (0, 2)\n    \"\"\"\n    open_brackets = 0\n    for b in brackets:\n        if b == \"<\":\n            open_brackets += 1\n        elif b == \">\":\n            open_brackets -= 1\n    return open_brackets, open_brackets\n\n\ndef",
      -5.953125
    ],
    [
      "# Your code here\n    if len(brackets) % 2 == 1:\n        return False\n    else:\n        while len(brackets) != 0:\n            if brackets[0] == '<':\n                brackets = brackets[1:]\n                if brackets[0] == '>':\n                    brackets = brackets[1:]\n                else:\n                    return False\n            else:\n                brackets = brackets[1:]\n        return True\n\n\ndef contains_correct_bracketing(text: str):\n    \"\"\" text is a string that may or may not contain a correctly bracketed expression.\n    return True if there is such an expression and False otherwise.\n\n    >>> contains_correct_bracketing('<><>')\n    True\n    >>> contains_correct_bracketing('<<><>>')\n    True\n    >>> contains_correct_bracketing('><<>')\n    False\n    >>> contains_correct_bracketing('<<><>>><><<>')\n    True\n    >>> contains_correct_bracketing('<<><>>><><<>>')\n    False\n    \"\"\"\n    while len(text) != 0:\n        if text[0] == '<':\n            text = text[1:]\n            if text[0] == '>':\n                text = text[1:]\n            else:\n                return False\n        else:\n            text = text[1:]\n    return True\n\n\ndef count_correct_bracketing(text: str):\n    \"\"\" text is a string that may or may not contain some correctly bracketed expressions.\n    return the number of correctly bracketed expressions that appear in text.\n\n    >>> count_correct_bracketing('<>')\n    1\n    >>> count_correct_bracketing('<<><>>')\n    2\n    >>> count_correct_bracketing('><<>')\n    0\n    >>> count_correct_bracketing('<<><>>><><<>')\n    2\n    >>> count_correct_bracketing('<<><>>><><<>>')\n    1\n    \"\"\"\n    count = 0\n    while len(text) != 0:\n        if text[0] == '<':\n            text = text[1:]",
      -6.00390625
    ],
    [
      "# A stack to keep track of opening brackets.\n    # If at any point, the top element on the stack is a closing bracket\n    # with no matching opening bracket at the bottom of the stack,\n    # the bracket sequence is not correctly bracketed\n    # therefore return False\n    # otherwise keep pushing opening brackets to the stack\n    # and pop them when we see a closing bracket\n    # if at any point, the stack is empty and we haven't returned False,\n    # then the bracket sequence is correctly bracketed\n    # therefore return True\n\n    stack = []\n    for i in brackets:\n        if i == '>':\n            if not stack:\n                return False\n            stack.pop()\n        else:\n            stack.append(i)\n\n    return not stack\n\n\ndef reverse_string(string):\n    \"\"\"Reverses the order of characters in string.\n\n    >>> reverse_string('abc')\n    'cba'\n    >>> reverse_string('a')\n    'a'\n    >>> reverse_string('ab')\n    'ba'\n    >>> reverse_string('abcdefghij')\n    'jigfedcba'\n    \"\"\"\n    # A stack to keep track of characters.\n    # If at any point, the top element on the stack is a closing bracket\n    # with no matching opening bracket at the bottom of the stack,\n    # the bracket sequence is not correctly bracketed\n    # therefore return False\n    # otherwise keep pushing opening brackets to the stack\n    # and pop them when we see a closing bracket\n    # if at any point, the stack is empty and we haven't returned False,\n    # then the bracket sequence is correctly bracketed\n    # therefore return True\n    stack = []\n    for i in string:\n        stack.append(i)\n\n    return ''.join(stack[::-1])\n\n\ndef sort_last(x):\n    \"\"\"Return a tuple where the last element of x is first.\n\n    >>> sort_last([1, 2])\n    [2, 1]\n    >>> sort_last([1, 2, 4, 3])\n    [3, 4, 1,",
      -6.33203125
    ],
    [
      "# count the number of opening brackets\n    open_brackets = 0\n\n    for bracket in brackets:\n        if bracket == \"<\":\n            open_brackets += 1\n        elif bracket == \">\":\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                return False\n\n    return open_brackets == 0\n\n\ndef remove_outer_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the string with outer matching brackets removed, or the original string if no brackets match.\n\n    >>> remove_outer_matching_brackets(\"\")\n    ''\n    >>> remove_outer_matching_brackets(\"<A>B</A>\")\n    '<A>B</A>'\n    >>> remove_outer_matching_brackets(\"<<A>B</A>>\")\n    'A>B</A>'\n    >>> remove_outer_matching_brackets(\"<<<A>B</A>>>\")\n    'A>B</A>'\n    >>> remove_outer_matching_brackets(\"<<A>B</A>\")\n    'A>B</A>'\n    >>> remove_outer_matching_brackets(\"<A>B</A>>\")\n    'A>B</A>>'\n    \"\"\"\n    start = 0\n    end = len(brackets) - 1\n\n    # count the number of opening brackets\n    open_brackets = 0\n\n    while start < end:\n        if brackets[start] == \"<\":\n            open_brackets += 1\n        elif brackets[end] == \">\":\n            open_brackets -= 1\n\n        if open_brackets == 0:\n            break\n\n        start += 1\n        end -= 1\n\n    if start == end:\n        return \"\"\n\n    return brackets[start:end + 1]\n\n\ndef remove_middle_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the string with all middle matching brackets removed, or the original string if no brackets match.\n\n    >>> remove",
      -6.37109375
    ],
    [
      "# Your code here!\n    return '>' not in brackets or (brackets.count('<') == brackets.count('>'))\n\n\ndef other_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> other_correct_bracketing(\"<\")\n    False\n    >>> other_correct_bracketing(\"<>\")\n    True\n    >>> other_correct_bracketing(\"<<><>>\")\n    True\n    >>> other_correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    # Your code here!\n    stack = []\n    for b in brackets:\n        if b == '<':\n            stack.append(b)\n        elif b == '>':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef count_correct_bracketing(bracketed_sentences):\n    \"\"\" bracketed_sentences is a list of strings, some of which\n    contain correct bracketing, and others do not.\n\n    return the number of strings in bracketed_sentences that contain correct\n    bracketing.\n\n    >>> count_correct_bracketing(['<>', '<><>', '<>'])\n    2\n    >>> count_correct_bracketing(['<>', '<><>'])\n    2\n    >>> count_correct_bracketing(['<><', '<>'])\n    1\n    \"\"\"\n    # Your code here!\n    return sum(correct_bracketing(s) for s in bracketed_sentences)\n\n\ndef correct_brackets_aux(s: str, left: str, right: str):\n    \"\"\"\n    helper function for balanced_parens\n\n    s is a string\n    left and right are single characters\n\n    return a tuple of the form (i, j), where:\n    - s[i:j] is the longest balanced substring of s starting with left\n      and ending with right, and\n    - i + len(s[i:j]) is the earliest such substring in s\n\n    return (None",
      -6.3828125
    ],
    [
      "# TODO: implement this function.\n    return False\n\n\ndef match_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if the brackets are correctly ordered.\n\n    >>> match_brackets(\"<>\")\n    True\n    >>> match_brackets(\"<>\")\n    True\n    >>> match_brackets(\"<><>\")\n    False\n    \"\"\"\n    # TODO: implement this function.\n    return False\n\n\ndef match_brackets_count(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if the brackets are correctly ordered.\n\n    >>> match_brackets_count(\"<>\")\n    0\n    >>> match_brackets_count(\"<><>\")\n    2\n    \"\"\"\n    # TODO: implement this function.\n    return 0\n\n\ndef match_brackets_count_2(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if the brackets are correctly ordered.\n\n    >>> match_brackets_count_2(\"<>\")\n    0\n    >>> match_brackets_count_2(\"<><>\")\n    2\n    \"\"\"\n    # TODO: implement this function.\n    return 0\n\n\ndef match_brackets_count_3(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if the brackets are correctly ordered.\n\n    >>> match_brackets_count_3(\"<>\")\n    0\n    >>> match_brackets_count_3(\"<><>\")\n    2\n    \"\"\"\n    # TODO: implement this function.\n    return 0\n\n\ndef count_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return the number of correctly ordered substrings of brackets.\n\n    >>> count_matching_brackets(\"<>\")\n    1\n    >>> count_matching_brackets(\"<><>\")\n    2\n    >>> count_matching_brackets(\"<><<>\")\n    2\n    \"\"\"\n    # TODO: implement this function.\n    return 0\n\n\ndef count_matching_bra",
      -6.390625
    ],
    [
      "open_brackets = 0\n    for c in brackets:\n        if c == \"<\":\n            open_brackets += 1\n        elif c == \">\" and open_brackets > 0:\n            open_brackets -= 1\n        else:\n            return False\n    return open_brackets == 0\n\n\ndef is_balanced(s: str):\n    \"\"\"\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"(]\")\n    False\n    >>> is_balanced(\"((()\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    \"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef count_correct_bracketing(s: str):\n    \"\"\"\n    >>> count_correct_bracketing(\"(())\")\n    1\n    >>> count_correct_bracketing(\"(]\")\n    0\n    >>> count_correct_bracketing(\"((()\")\n    0\n    >>> count_correct_bracketing(\"([)]\")\n    0\n    >>> count_correct_bracketing(\"(())\")\n    1\n    >>> count_correct_bracketing(\"(())()()()\")\n    4\n    \"\"\"\n    if len(s) == 0:\n        return 1\n    if s[0] == '(':\n        return 0\n    if s[0] == ')':\n        return 0\n    return count_correct_bracketing(s[1:])\n\n\ndef count_correct_bracketing_recur(s: str):\n    \"\"\"\n    >>> count_correct_bracketing_recur(\"(())\")\n    1\n    >>> count_correct_bracketing_recur(\"(]\")\n    0\n    >>> count_correct_bracketing_recur(\"((()\")\n    0\n    >>> count_correct_bracketing_recur(\"([)]\")\n    0\n    >>> count_",
      -6.83203125
    ],
    [
      "# The stack holds the opening brackets we have seen.\n    stack = []\n    for b in brackets:\n        if b == '>':\n            # Found a closing bracket.\n            if stack == []:\n                # We have seen as many closing brackets as opening brackets.\n                return False\n            else:\n                # Pop the topmost opening bracket from the stack.\n                stack.pop()\n        else:\n            # Found an opening bracket.\n            stack.append(b)\n    return stack == []\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\"Return the number of ways the brackets in the given string can be\n    bracketed such that every opening bracket has a corresponding closing\n    bracket. Each bracketing consumes one bracket, and the bracketing\n    <AAAB>AAA is equivalent to <AAB>AA.\n    >>> count_correct_bracketings('<>')\n    1\n    >>> count_correct_bracketings('<A>')\n    1\n    >>> count_correct_bracketings('<AB>')\n    1\n    >>> count_correct_bracketings('<AAB>AA')\n    1\n    >>> count_correct_bracketings('<AAB>AA<C>AA')\n    1\n    >>> count_correct_bracketings('<AAB>A<C>AA')\n    2\n    >>> count_correct_bracketings('<AAB>A<CAB>AA')\n    2\n    >>> count_correct_bracketings('<AAB>A<CAB>AA<C>AA')\n    2\n    >>> count_correct_bracketings('<AAB>A<CAB>AA<CAB>AA<C>AA')\n    4\n    \"\"\"\n    # The number of possible bracketings is the number of ways we can place\n    # the first opening bracket, times the number of ways we can bracket the\n    # rest of the string.\n    if brackets == \"\":\n        return 1\n    elif brackets == \"<\":\n        return 0\n    elif brackets == \">\":\n        return 0\n    elif brackets[0] == '<':\n        return count_correct",
      -7.48828125
    ],
    [
      "# ------------------------------------------------------------------\n    # TODO: 2. Implement and test this function.\n    #     The TESTS provided are from the unit tests in\n    #     test-string-methods.\n    #\n    #  ** IMPORTANT: **\n    #   -- As best as you can without using additional modules (e.g., regex),\n    #      try to make this method *mutate* the string by calling its built-in\n    #      methods (like .replace) instead of returning a new string.\n    #      For example, try to make this method mutate the string\n    #        brackets\n    #      instead of returning a new value for brackets.\n    #\n    #      For example,\n    #        instead of returning\n    #          return brackets.replace('<', '').replace('>', '')\n    #        try to make it mutate the string\n    #          brackets\n    #        by using code like\n    #          brackets.replace('<', '').replace('>', '')\n    #        or\n    #          brackets.replace('<><', '')\n    # ------------------------------------------------------------------\n\n\ndef is_paired_and_correct_string(str: str):\n    \"\"\" Return True if the string is a correctly bracketed string,\n    False otherwise.\n\n    This method ignores whitespace, so a string like\n     '(hello) (world)'\n    is considered correctly bracketed.\n\n    See the test cases for examples of correctly bracketed strings.\n\n    Precondition: str is a string with only '<' and '>' characters.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # TODO: 3. Implement and test this function.\n    #     The TESTS provided are from the unit tests in\n    #     test-string-methods.\n    # ------------------------------------------------------------------\n\n\ndef contains_balanced_brackets(str: str):\n    \"\"\" Return True if the string contains balanced brackets,\n    False otherwise.\n\n    This method ignores whitespace, so a string like\n     '(hello) (world)'\n    is considered balanced.\n\n    See the test cases for examples of balanced strings.\n\n    Precondition: str is",
      -8.5703125
    ],
    [
      "# TODO: implement this function.\n    return\n\n\ndef matching_pairs(s, openers, closers):\n    \"\"\"s is a string, and openers and closers are lists of characters.\n    return a list of triples [i, j, k] where i and j are indices into s, and k is\n    in openers * closers.  The triple [i, j, k] means that s[i] and s[j] are a\n    matching pair: s[i] is in openers and s[j] is in closers.  The indices i and\n    j must be strictly increasing.\n\n    >>> matching_pairs(\"()[]{}\", \"()\", \"[]{}\")\n    [[0, 1, (), (), 0, 0], [2, 3, (), (), 1, 1]]\n    >>> matching_pairs(\"<\", \"()[]{}\", \"[]{}\")\n    []\n    \"\"\"\n    # TODO: implement this function.\n    return\n\n\ndef matching_pairs_with_gaps(s, openers, closers):\n    \"\"\"s is a string, and openers and closers are lists of characters.\n    return a list of triples [i, j, k] where i and j are indices into s, and k is\n    in openers * closers.  The triple [i, j, k] means that s[i] and s[j] are a\n    matching pair: s[i] is in openers and s[j] is in closers.  The indices i and\n    j may be anywhere in s, and they need not be strictly increasing.\n\n    >>> matching_pairs_with_gaps(\"a<b>c</d>e\", \"()\", \"[]{}\")\n    [[1, 2, (), (), 0, 0], [3, 4, (), (), 1, 1]]\n    >>> matching_pairs_with_gaps(\"<b>c</d>e\", \"()\", \"[]{}\")\n    [[0, 1, (), (), 0, 0]]\n    \"\"\"\n    # TODO: implement this function.\n    return\n\n\ndef matching_pairs",
      -8.78125
    ],
    [
      "# 1. count how many \"<\" and \">\" we have\n    # 2. if the number of \"<\" is smaller than the number of \">\", return False\n    # 3. if the number of \">\" is smaller than the number of \"<\", return False\n    # 4. else return True\n\n    # count the number of \"<\" and \">\"\n    n_opening = brackets.count(\"<\")\n    n_closing = brackets.count(\">\")\n\n    # if the number of \"<\" is smaller than the number of \">\", return False\n    if n_opening < n_closing:\n        return False\n    # if the number of \">\" is smaller than the number of \"<\", return False\n    if n_closing < n_opening:\n        return False\n    # else return True\n    return True\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"<<><>>\")\n    True\n    >>> balanced_brackets(\"><<>\")\n    False\n    \"\"\"\n    # 1. if the brackets is empty, return True\n    # 2. if the brackets is not empty, divide the brackets into two parts:\n    #       left part: all the left bracket (<)\n    #       right part: all the right bracket (>)\n    # 3. if the left part is smaller than the right part, return False\n    # 4. else, if the left part is not smaller than the right part,\n    #       recursively call balanced_brackets(left part) and balanced_brackets(right part)\n\n    if brackets == \"\":\n        return True\n\n    left_part = \"\"\n    right_part = \"\"\n\n    for i in brackets:\n        if i == \"<\":\n            left_part += i\n        else:\n            right_part += i\n\n    if len(left_part) > len(right_part):\n        return False\n    elif len(left_part) < len(right_part):\n        return False\n    else:\n        return balanced_brackets(",
      -9.515625
    ],
    [
      "\"*** YOUR CODE HERE ***\"\n    if len(brackets) == 1:\n        return False\n    count = 0\n    for b in brackets:\n        if b == \"<\":\n            count += 1\n        elif b == \">\":\n            count -= 1\n    return count == 0\n\n\ndef contains_substring(big: str, little: str):\n    \"\"\" Return whether little appears in the string big.\n\n    >>> contains_substring(\"hello\", \"ell\")\n    True\n    >>> contains_substring(\"hello\", \"hello\")\n    True\n    >>> contains_substring(\"hello\", \"he\")\n    True\n    >>> contains_substring(\"hello\", \"h\")\n    True\n    >>> contains_substring(\"hello\", \"o\")\n    True\n\n    >>> contains_substring(\"hello\", \"e\")\n    False\n    >>> contains_substring(\"hello\", \"l\")\n    False\n    >>> contains_substring(\"hello\", \"x\")\n    False\n    \"\"\"\n    assert len(little) <= len(big)\n    \"*** YOUR CODE HERE ***\"\n    return big.find(little) != -1\n\n\ndef raises_value_error(bad_function):\n    \"\"\"Return a string describing the TypeError raised by bad_function\n    when invoked with no arguments.\n\n    >>> f = raises_value_error(lambda: 1 + 2)\n    >>> print(f)\n    I will now try to add 1 and 2.\n    But it raised a TypeError with message: unsupported operand type(s) for +: 'int' and 'int'\n\n    >>> f = raises_value_error(lambda: int('hello'))\n    >>> print(f)\n    I will now try to convert the string 'hello' into an integer.\n    But it raised a TypeError with message: invalid literal for int() with base 10: 'hello'\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    try:\n        bad_function()\n    except TypeError as e:\n        return 'I will now try to ' + bad_function.__name__ + ' ' + str(bad_function.__code__.co_varnames) + '. But it raised a TypeError",
      -11.109375
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}