{
  "problem": {
    "task_id": "HumanEval/9",
    "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
    "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
    "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
    "entry_point": "rolling_max",
    "docstring": "",
    "problem_id": 9
  },
  "model_name": "codellama-7b",
  "dataset": "humaneval",
  "ranker_name": "acecoder_rm",
  "num_candidates": 100,
  "ranked_candidates": [
    [
      "if not numbers:\n        raise ValueError(\"List cannot be empty\")\n\n    result = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n\n    return result\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 1), (2, 2), (3, 3), (3, 3), (3, 3), (4, 4), (4, 4)]\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n\n    result = []\n    current_max = numbers[0]\n    for idx, number in enumerate(numbers):\n        current_max = max(current_max, number)\n        result.append((idx, current_max))\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      8.4140625
    ],
    [
      "if not numbers:\n        return []\n\n    rolling_max_list: List[int] = []\n\n    for i in range(len(numbers)):\n        max_number = max(numbers[:i + 1])\n        rolling_max_list.append(max_number)\n\n    return rolling_max_list\n\n\ndef rolling_max_with_stack(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_stack([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list: List[int] = []\n    stack: List[int] = []\n\n    for i in range(len(numbers)):\n        max_number = max(stack + [numbers[i]])\n        rolling_max_list.append(max_number)\n\n        if numbers[i] < max_number:\n            stack.append(numbers[i])\n\n    return rolling_max_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      5.06640625
    ],
    [
      "if not numbers:\n        return []\n    rolling_max_values = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_values.append(max(rolling_max_values[i - 1], numbers[i]))\n    return rolling_max_values\n\n\ndef rolling_max_v2(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    rolling_max_values = [numbers[0]]\n    for i in range(1, len(numbers)):\n        if numbers[i] > rolling_max_values[i - 1]:\n            rolling_max_values.append(numbers[i])\n        else:\n            rolling_max_values.append(rolling_max_values[i - 1])\n    return rolling_max_values\n\n\ndef rolling_max_v3(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    rolling_max_values = [numbers[0]]\n    for i in range(1, len(numbers)):\n        if numbers[i] > rolling_max_values[-1]:\n            rolling_max_values.append(numbers[i])\n        else:\n            rolling_max_values.append(rolling_max_values[-1])\n    return rolling_max_values\n\n\ndef rolling_max_v4(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found",
      4.44140625
    ],
    [
      "if not numbers:\n        return []\n    rolling_max_numbers: List[int] = []\n    rolling_max_numbers.append(numbers[0])\n    for index, number in enumerate(numbers[1:]):\n        if number >= rolling_max_numbers[index]:\n            rolling_max_numbers.append(number)\n        else:\n            rolling_max_numbers.append(rolling_max_numbers[index])\n    return rolling_max_numbers\n\n\ndef max_subarray_sum(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find the maximum subarray sum.\n    >>> max_subarray_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    (-5, 18)\n    \"\"\"\n    rolling_max_numbers = rolling_max(numbers)\n    return (max(rolling_max_numbers), min(rolling_max_numbers))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      3.47265625
    ],
    [
      "rolling_max: List[int] = []\n    current_max = 0\n\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        rolling_max.append(current_max)\n\n    return rolling_max\n\n\ndef max_sublist_sum(numbers: List[int]) -> int:\n    \"\"\" Given a list of integers, return the maximum sum of a contiguous sublist of the list.\n    >>> max_sublist_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n\n    for number in numbers:\n        current_sum += number\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\n\ndef max_sublist_sum_two_pointer(numbers: List[int]) -> int:\n    \"\"\" Given a list of integers, return the maximum sum of a contiguous sublist of the list.\n    >>> max_sublist_sum_two_pointer([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n\n    for number in numbers:\n        current_sum = max(current_sum + number, number)\n        max_sum = max(current_sum, max_sum)\n\n    return max_sum\n\n\ndef max_sublist_sum_prefix_sum(numbers: List[int]) -> int:\n    \"\"\" Given a list of integers, return the maximum sum of a contiguous sublist of the list.\n    >>> max_sublist_sum_prefix_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n\n    for number in numbers:\n        current_sum += number\n        max",
      3.376953125
    ],
    [
      "return [max(numbers[:i+1]) for i in range(len(numbers))]\n\n\ndef get_max_overlapping_in_intervals(intervals: List[Tuple[int, int]], max_length: int) -> int:\n    \"\"\" From a list of intervals, get the number of intervals that can be overlapping, with a given max length.\n    >>> get_max_overlapping_in_intervals([(1, 2), (2, 4), (3, 5), (7, 9)], max_length=2)\n    2\n    >>> get_max_overlapping_in_intervals([(1, 2), (2, 4), (3, 5), (7, 9)], max_length=3)\n    3\n    \"\"\"\n    rolling_max_list = rolling_max([interval[1] - interval[0] + 1 for interval in intervals])\n    return sum(i <= max_length for i in rolling_max_list)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      3.265625
    ],
    [
      "rolling_max_list = []\n    rolling_max_value = numbers[0]\n    for number in numbers:\n        rolling_max_value = max(rolling_max_value, number)\n        rolling_max_list.append(rolling_max_value)\n    return rolling_max_list\n\n\ndef max_sliding_window(numbers: List[int], size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element in a sliding window of given size.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    if size == 0 or len(numbers) == 0:\n        return []\n    sliding_window_max_list = []\n    for index in range(len(numbers)):\n        sublist = numbers[index : index + size]\n        if len(sublist) == size:\n            sliding_window_max_list.append(max(sublist))\n    return sliding_window_max_list\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the length of the longest increasing subsequence.\n    >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    6\n    \"\"\"\n    increasing_subsequence_lengths = [1 for _ in range(len(numbers))]\n    for index in range(len(numbers)):\n        for another_index in range(index):\n            if numbers[another_index] < numbers[index]:\n                increasing_subsequence_lengths[index] = max(\n                    increasing_subsequence_lengths[index], increasing_subsequence_lengths[another_index] + 1\n                )\n    return max(increasing_subsequence_lengths)\n\n\ndef longest_increasing_subsequence_bottom_up(numbers: List[int]) -> int",
      3.189453125
    ],
    [
      "if not numbers:\n        raise ValueError(\"Empty list\")\n    rolling_max_list = []\n    rolling_max_number = numbers[0]\n    for number in numbers:\n        rolling_max_number = max(number, rolling_max_number)\n        rolling_max_list.append(rolling_max_number)\n    return rolling_max_list\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples (element, rolling maximum element found until given\n    moment in the sequence).\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 1), (2, 2), (3, 3), (2, 3), (3, 3), (4, 4), (2, 4)]\n    \"\"\"\n    rolling_max_list = []\n    rolling_max_number = numbers[0]\n    for index, number in enumerate(numbers):\n        rolling_max_number = max(number, rolling_max_number)\n        rolling_max_list.append((number, rolling_max_number))\n    return rolling_max_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      2.609375
    ],
    [
      "rolling_max_list: List[int] = []\n    rolling_max_number: int = numbers[0]\n\n    for number in numbers:\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_list.append(rolling_max_number)\n\n    return rolling_max_list\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples. The first element of the tuple is a rolling maximum\n    element found until given moment in the sequence. The second element of the tuple is an index of the element in\n    the list.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    rolling_max_list: List[Tuple[int, int]] = []\n    rolling_max_number: int = numbers[0]\n\n    for index, number in enumerate(numbers):\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_list.append((rolling_max_number, index))\n\n    return rolling_max_list\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == '__main__':\n    main()",
      2.423828125
    ],
    [
      "rolling_max_so_far: List[int] = []\n\n    for i, num in enumerate(numbers):\n        if not rolling_max_so_far:\n            rolling_max_so_far.append(num)\n            continue\n\n        if num >= rolling_max_so_far[-1]:\n            rolling_max_so_far.append(num)\n        else:\n            rolling_max_so_far.append(rolling_max_so_far[-1])\n\n    return rolling_max_so_far\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples (index, max) of rolling maximum element found\n    until given moment in the sequence.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 3), (4, 3), (5, 4), (6, 4)]\n    \"\"\"\n    rolling_max_so_far: List[Tuple[int, int]] = []\n\n    for i, num in enumerate(numbers):\n        if not rolling_max_so_far:\n            rolling_max_so_far.append((i, num))\n            continue\n\n        if num >= rolling_max_so_far[-1][1]:\n            rolling_max_so_far.append((i, num))\n        else:\n            rolling_max_so_far.append(rolling_max_so_far[-1])\n\n    return rolling_max_so_far\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.9443359375
    ],
    [
      "# initialize max_num and result list\n    max_num = 0\n    result = []\n    # iterate over numbers\n    for num in numbers:\n        # update max_num\n        max_num = max(num, max_num)\n        # append max_num to result\n        result.append(max_num)\n    return result\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples (index, rolling maximum element) found\n    until given moment in the sequence.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 3), (4, 3), (5, 4), (6, 4)]\n    \"\"\"\n    # initialize max_num and result list\n    max_num = 0\n    result = []\n    # iterate over numbers\n    for i, num in enumerate(numbers):\n        # update max_num\n        max_num = max(num, max_num)\n        # append (index, max_num) to result\n        result.append((i, max_num))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.9248046875
    ],
    [
      "max_so_far = []\n    for number in numbers:\n        if len(max_so_far) == 0 or number >= max_so_far[-1]:\n            max_so_far.append(number)\n        else:\n            max_so_far.append(max_so_far[-1])\n    return max_so_far\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    min_so_far = []\n    for number in numbers:\n        if len(min_so_far) == 0 or number <= min_so_far[-1]:\n            min_so_far.append(number)\n        else:\n            min_so_far.append(min_so_far[-1])\n    return min_so_far\n\n\ndef max_sliding_window(sequence: List[int], window_size: int) -> List[int]:\n    \"\"\" Generate a list of max sliding window values for a given sequence.\n    >>> max_sliding_window([1, 2, 3, 2, 3, 4, 2], 3)\n    [3, 3, 4, 4]\n    \"\"\"\n    if window_size > len(sequence):\n        raise ValueError('Window size is bigger than sequence length')\n    sliding_max = []\n    for i in range(len(sequence)):\n        if i < window_size:\n            sliding_max.append(max(sequence[:i + 1]))\n        else:\n            sliding_max.append(max(sequence[i + 1 - window_size: i + 1]))\n    return sliding_max\n\n\ndef min_sliding_window(sequence: List[int], window_size: int) -> List[int]:\n    \"\"\" Generate a list of min sliding window values for a",
      1.8935546875
    ],
    [
      "rolling_max_values = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_values.append(max(rolling_max_values[i - 1], numbers[i]))\n    return rolling_max_values\n\n\ndef max_in_sliding_window(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum value found within given window.\n    >>> max_in_sliding_window([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 4, 5, 6, 7]\n    \"\"\"\n    window_max_values = []\n    for i in range(len(numbers) - window_size + 1):\n        window_max_values.append(max(numbers[i: i + window_size]))\n    return window_max_values\n\n\ndef max_in_window_linear(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum value found within given window.\n    >>> max_in_window_linear([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 4, 5, 6, 7]\n    \"\"\"\n    window_max_values = []\n    for i in range(window_size - 1, len(numbers)):\n        window_max_values.append(max(numbers[i - window_size + 1: i + 1]))\n    return window_max_values\n\n\ndef max_in_window_constant_space(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum value found within given window.\n    >>> max_in_window_constant_space([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 4, 5, 6, 7]\n    \"\"\"\n    max_value = numbers[0]\n    window",
      1.7080078125
    ],
    [
      "if not numbers:\n        return []\n    max_so_far: List[int] = []\n    max_so_far.append(max(numbers[0], 0))\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far[i - 1]:\n            max_so_far.append(numbers[i])\n        else:\n            max_so_far.append(max_so_far[i - 1])\n    return max_so_far\n\n\ndef rolling_max_v2(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far: List[int] = []\n    max_so_far.append(max(numbers[0], 0))\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far[i - 1]:\n            max_so_far.append(numbers[i])\n        else:\n            max_so_far.append(max_so_far[i - 1])\n    return max_so_far\n\n\ndef rolling_max_v3(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far: List[int] = []\n    max_so_far.append(max(numbers[0], 0))\n    for i in range(1, len(numbers)):\n        if numbers[i] > max",
      1.6845703125
    ],
    [
      "if not numbers:\n        return []\n\n    max_so_far = max(numbers)\n    rolling_max_numbers = [max_so_far] * len(numbers)\n\n    for i in range(len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        rolling_max_numbers[i] = max_so_far\n\n    return rolling_max_numbers\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[List[int], int]:\n    \"\"\" Find the longest increasing subsequence in a given sequence of numbers.\n    >>> longest_increasing_subsequence([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9, 4, 7, 2])\n    ([1, 2, 3, 4, 5, 6, 7, 9], 8)\n    \"\"\"\n    if not numbers:\n        return [], 0\n\n    lis_len = [1] * len(numbers)\n    lis_predecessor = [-1] * len(numbers)\n\n    for i in range(1, len(numbers)):\n        for j in range(0, i):\n            if numbers[i] > numbers[j]:\n                if lis_len[j] >= lis_len[i]:\n                    continue\n                lis_len[i] = lis_len[j] + 1\n                lis_predecessor[i] = j\n\n    current_index = lis_len.index(max(lis_len))\n    lis = []\n    while current_index >= 0:\n        lis.append(numbers[current_index])\n        current_index = lis_predecessor[current_index]\n    lis.reverse()\n    return lis, max(lis_len)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.5126953125
    ],
    [
      "return [max(numbers[:i]) for i in range(1, len(numbers) + 1)]\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples. Each tuple contains maximum element found until\n    given moment in the sequence and index of this element.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    return [(max(numbers[:i]), numbers[:i].index(max(numbers[:i]))) for i in range(1, len(numbers) + 1)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.4423828125
    ],
    [
      "if not numbers:\n        return []\n    output = [max(numbers)]\n    for index in range(1, len(numbers)):\n        current_max = max(numbers[index], output[-1])\n        output.append(current_max)\n    return output\n\n\ndef max_slice(sequence: List[int]) -> Tuple[int, int, int]:\n    \"\"\"From a given sequence of integers, find the maximum sum of a slice (contiguous sub-sequence) in the given\n    sequence.\n    >>> max_slice([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    (6, 4, 7)\n    \"\"\"\n    if not sequence:\n        return 0, 0, 0\n\n    max_sum = 0\n    start = end = 0\n    current_sum = 0\n    for index in range(0, len(sequence)):\n        current_sum += sequence[index]\n        if current_sum < 0:\n            current_sum = 0\n            start = index + 1\n        elif current_sum > max_sum:\n            max_sum = current_sum\n            end = index\n    return max_sum, start, end\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      1.1171875
    ],
    [
      "result = []\n    for i in range(len(numbers)):\n        result.append(max(numbers[:i + 1]))\n    return result\n\n\ndef sum_of_numbers(numbers: List[int]) -> int:\n    \"\"\" Calculate the sum of all numbers in the given list.\n    >>> sum_of_numbers([1, 2, 3, 4, 5])\n    15\n    \"\"\"\n    return sum(numbers)\n\n\ndef sum_of_numbers_by_fold(numbers: List[int]) -> int:\n    \"\"\" Calculate the sum of all numbers in the given list.\n    >>> sum_of_numbers_by_fold([1, 2, 3, 4, 5])\n    15\n    \"\"\"\n    return numbers[0] + numbers[-1]\n\n\ndef sum_of_numbers_by_reduce(numbers: List[int]) -> int:\n    \"\"\" Calculate the sum of all numbers in the given list.\n    >>> sum_of_numbers_by_reduce([1, 2, 3, 4, 5])\n    15\n    \"\"\"\n    return sum(numbers)\n\n\ndef find_max_number(numbers: List[int]) -> int:\n    \"\"\" Find the maximum number in the given list.\n    >>> find_max_number([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    return max(numbers)\n\n\ndef find_max_number_by_reduce(numbers: List[int]) -> int:\n    \"\"\" Find the maximum number in the given list.\n    >>> find_max_number_by_reduce([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    return max(numbers)\n\n\ndef find_max_number_by_fold(numbers: List[int]) -> int:\n    \"\"\" Find the maximum number in the given list.\n    >>> find_max_number_by_fold([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    return max(numbers)\n\n\ndef find_min_number(numbers: List[int]) -> int:\n    \"\"\" Find the minimum number in",
      0.95556640625
    ],
    [
      "if len(numbers) < 1:\n        return []\n    result: List[int] = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(result[i - 1], numbers[i]))\n    return result\n\n\ndef find_max_subarray(sequence: List[int]) -> Tuple[int, int]:\n    \"\"\" Find a maximum subarray of the given sequence.\n    >>> find_max_subarray([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    (11, 14)\n    \"\"\"\n    max_sum = 0\n    max_sum_start = 0\n    max_sum_end = 0\n    rolling_sum = 0\n    for i, x in enumerate(sequence):\n        rolling_sum += x\n        if rolling_sum > max_sum:\n            max_sum = rolling_sum\n            max_sum_start = max_sum_end\n            max_sum_end = i\n        if rolling_sum < 0:\n            rolling_sum = 0\n    return max_sum_start, max_sum_end\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.7568359375
    ],
    [
      "result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(result[i - 1], numbers[i]))\n    return result\n\n\ndef merge_overlapping(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\" Given a list of intervals, merge all overlapping intervals into one\n    >>> merge_overlapping([(1, 3), (2, 4), (5, 7), (6, 8)])\n    [(1, 4), (5, 8)]\n    \"\"\"\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    result = []\n    prev_interval = sorted_intervals[0]\n    for i in range(1, len(sorted_intervals)):\n        current_interval = sorted_intervals[i]\n        if current_interval[0] <= prev_interval[1]:\n            prev_interval = (\n                prev_interval[0],\n                max(prev_interval[1], current_interval[1]),\n            )\n        else:\n            result.append(prev_interval)\n            prev_interval = current_interval\n    result.append(prev_interval)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.71875
    ],
    [
      "max_so_far = [float('-inf')]\n    for i in numbers:\n        max_so_far.append(max(max_so_far[-1], i))\n    return max_so_far[1:]\n\n\ndef rolling_max_tuple(numbers: List[Tuple[int, str]]) -> List[Tuple[int, str]]:\n    \"\"\" From a given list of tuples (int, str), generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_tuple([(1, 'a'), (2, 'b'), (3, 'c'), (2, 'b'), (3, 'c'), (4, 'd'), (2, 'b')])\n    [(1, 'a'), (2, 'b'), (3, 'c'), (3, 'c'), (3, 'c'), (4, 'd'), (4, 'd')]\n    \"\"\"\n    max_so_far = [(float('-inf'), '')]\n    for i in numbers:\n        max_so_far.append(max(max_so_far[-1], i))\n    return max_so_far[1:]",
      0.7109375
    ],
    [
      "result = []\n    for i in range(len(numbers)):\n        max_element = max(numbers[:i + 1])\n        result.append(max_element)\n    return result\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples containing index and rolling maximum element found\n    until given moment in the sequence.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 3), (4, 3), (5, 4), (6, 4)]\n    \"\"\"\n    result = []\n    for i in range(len(numbers)):\n        max_element = max(numbers[:i + 1])\n        result.append((i, max_element))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.5302734375
    ],
    [
      "rolling_max_list = []\n    for i in range(len(numbers)):\n        if not i:\n            rolling_max_list.append(numbers[i])\n        else:\n            if numbers[i - 1] >= numbers[i]:\n                rolling_max_list.append(numbers[i - 1])\n            else:\n                rolling_max_list.append(numbers[i])\n    return rolling_max_list\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence along with its index.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    rolling_max_list = []\n    for i in range(len(numbers)):\n        if not i:\n            rolling_max_list.append((numbers[i], i))\n        else:\n            if numbers[i - 1] >= numbers[i]:\n                rolling_max_list.append((numbers[i - 1], i - 1))\n            else:\n                rolling_max_list.append((numbers[i], i))\n    return rolling_max_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.39404296875
    ],
    [
      "rolling_max_numbers: List[int] = []\n    rolling_max_number: int = numbers[0]\n    for number in numbers:\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_numbers.append(rolling_max_number)\n    return rolling_max_numbers\n\n\ndef rolling_max_alt(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_alt([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_numbers: List[int] = []\n    for number in numbers:\n        if not rolling_max_numbers:\n            rolling_max_numbers.append(number)\n        else:\n            rolling_max_numbers.append(max(rolling_max_numbers[-1], number))\n    return rolling_max_numbers\n\n\ndef max_in_sliding_window(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum elements in sliding window of given size.\n    >>> max_in_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    max_numbers: List[int] = []\n    for i in range(len(numbers) - window_size + 1):\n        max_numbers.append(max(numbers[i : i + window_size]))\n    return max_numbers\n\n\ndef max_in_sliding_window_alt(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum elements in sliding window of given size.\n    >>> max_in_sliding_window_alt([1, 3, -1, -3, 5,",
      0.2364501953125
    ],
    [
      "result: List[int] = []\n    max_so_far = numbers[0]\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n    return result\n\n\ndef partition_list(numbers: List[int], pivot: int) -> Tuple[List[int], List[int], List[int]]:\n    \"\"\" Partition a given list of integers around a given pivot.\n    >>> partition_list([1, 2, 3, 4, 5], 3)\n    ([1, 2], [3, 4, 5], [])\n    \"\"\"\n    left, right = [], []\n    for number in numbers:\n        if number < pivot:\n            left.append(number)\n        elif number > pivot:\n            right.append(number)\n    return left, right, []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      0.1470947265625
    ],
    [
      "rolling_max_vals = [None] * len(numbers)\n    rolling_max_vals[0] = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > rolling_max_vals[i - 1]:\n            rolling_max_vals[i] = numbers[i]\n        else:\n            rolling_max_vals[i] = rolling_max_vals[i - 1]\n    return rolling_max_vals\n\n\ndef max_profit(stock_prices: List[int]) -> int:\n    \"\"\" Given a list of daily stock prices, find the maximum profit that can be made by buying and selling one share\n    of that stock only once.\n    >>> max_profit([10, 7, 5, 8, 11, 9])\n    6\n    \"\"\"\n    max_profit_val = 0\n    for i in range(1, len(stock_prices)):\n        if stock_prices[i] - stock_prices[i - 1] > max_profit_val:\n            max_profit_val = stock_prices[i] - stock_prices[i - 1]\n    return max_profit_val\n\n\ndef max_profit_with_fees(stock_prices: List[int], fee: int) -> int:\n    \"\"\" Given a list of daily stock prices, find the maximum profit that can be made by buying and selling one share\n    of that stock only once. You can only buy and sell once each.\n    >>> max_profit_with_fees([10, 7, 5, 8, 11, 9], 1)\n    6\n    \"\"\"\n    max_profit_val = 0\n    for i in range(1, len(stock_prices)):\n        if stock_prices[i] - stock_prices[i - 1] - fee > max_profit_val:\n            max_profit_val = stock_prices[i] - stock_prices[i - 1] - fee\n    return max_profit_val",
      0.10174560546875
    ],
    [
      "res = []\n    for i, num in enumerate(numbers):\n        if i == 0:\n            res.append(num)\n        else:\n            if num >= res[-1]:\n                res.append(num)\n            else:\n                res.append(res[-1])\n    return res\n\n\ndef pair_sum(numbers: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\" Given a list of integers and a target integer, return a list of pairs of elements\n    which sum up to target integer.\n    >>> pair_sum([1, 2, 3, 4, 5, 6], 6)\n    [(1, 5), (2, 4), (3, 3)]\n    \"\"\"\n    res = []\n    for i, num in enumerate(numbers):\n        for num2 in numbers[i+1:]:\n            if num + num2 == target:\n                res.append((num, num2))\n    return res\n\n\ndef get_min_max(numbers: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a list of tuples with the minimum and maximum values\n    from given list.\n    >>> get_min_max([1, 2, 3, 4, 5, 6])\n    [(1, 6)]\n    \"\"\"\n    res = []\n    min_val = 0\n    max_val = 0\n    for i, num in enumerate(numbers):\n        if i == 0:\n            min_val = num\n            max_val = num\n        else:\n            if num < min_val:\n                min_val = num\n            elif num > max_val:\n                max_val = num\n    res.append((min_val, max_val))\n    return res\n\n\ndef get_sum_divisible_by(numbers: List[int], k: int) -> List[int]:\n    \"\"\" Given a list of integers and an integer k, return a list of integers which are divisible by k.\n    >>> get_sum_divisible_by([1, 2, 3, 4, 5, 6], 2)",
      0.072998046875
    ],
    [
      "if not numbers:\n        return []\n    rolling_max_numbers = [numbers[0]]\n    for number in numbers[1:]:\n        rolling_max_numbers.append(max(number, rolling_max_numbers[-1]))\n    return rolling_max_numbers\n\n\ndef max_subarray(sequence: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> max_subarray([1, 2, 3, 2, 3, 4, 2])\n    (5, 2)\n    \"\"\"\n    if not sequence:\n        raise ValueError(\"Sequence can not be empty.\")\n    max_sum = 0\n    current_sum = 0\n    for number in sequence:\n        current_sum += number\n        if current_sum < 0:\n            current_sum = 0\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum, sequence.index(max(sequence))\n\n\ndef main():\n    numbers = [1, 2, 3, 2, 3, 4, 2]\n    print(rolling_max(numbers))\n    print(max_subarray(numbers))\n\n\nif __name__ == \"__main__\":\n    main()",
      0.032135009765625
    ],
    [
      "max_so_far = [numbers[0]]\n    for number in numbers[1:]:\n        max_so_far.append(max(max_so_far[-1], number))\n    return max_so_far\n\n\ndef max_sliding_window(numbers: List[int], size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum elements found in a sliding window of given size\n    >>> max_sliding_window([1, 2, 3, 2, 3, 4, 2], 2)\n    [2, 3, 3, 4]\n    \"\"\"\n    return list(map(max, zip(*[numbers[i:] for i in range(size)])))\n\n\ndef find_missing_number(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find a missing number (the one not present in the list).\n    >>> find_missing_number([1, 2, 3, 2, 3, 4, 2])\n    4\n    \"\"\"\n    if not numbers:\n        return 1\n    return (1 + sum(numbers)) * numbers[-1] // sum(range(1, numbers[-1] + 1))\n\n\ndef find_first_occurrence_of_number(numbers: List[int], number: int) -> int:\n    \"\"\" From a given list of integers, find the index of the first occurrence of a given number.\n    >>> find_first_occurrence_of_number([1, 2, 3, 2, 3, 4, 2], 2)\n    0\n    \"\"\"\n    return numbers.index(number)\n\n\ndef find_last_occurrence_of_number(numbers: List[int], number: int) -> int:\n    \"\"\" From a given list of integers, find the index of the last occurrence of a given number.\n    >>> find_last_occurrence_of_number([1, 2, 3, 2, 3, 4, 2], 2)\n    6\n    \"\"\"\n    return len(numbers) - 1 - numbers[::-1].index(number)",
      -0.1058349609375
    ],
    [
      "max_num = 0\n    result = []\n    for number in numbers:\n        max_num = max(max_num, number)\n        result.append(max_num)\n    return result\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    min_num = 0\n    result = []\n    for number in numbers:\n        min_num = min(min_num, number)\n        result.append(min_num)\n    return result\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> int:\n    \"\"\" Generate the length of the longest increasing subsequence in a given list of integers.\n    >>> longest_increasing_subsequence([5, 4, 3, 2, 1])\n    1\n    >>> longest_increasing_subsequence([5, 4, 4, 3, 3, 2, 2, 1])\n    3\n    \"\"\"\n    result = []\n    for number in numbers:\n        if not result or number > result[-1]:\n            result.append(number)\n        else:\n            result[bisect(result, number)] = number\n    return len(result)\n\n\ndef longest_decreasing_subsequence(numbers: List[int]) -> int:\n    \"\"\" Generate the length of the longest decreasing subsequence in a given list of integers.\n    >>> longest_decreasing_subsequence([5, 4, 3, 2, 1])\n    1\n    >>> longest_decreasing_subsequence([5, 4, 4, 3, 3, 2, 2, 1])\n    3\n    \"\"\"\n    result = []\n    for number in numbers:\n        if not result or number < result[-1]:\n            result.append(number)\n        else:",
      -0.2449951171875
    ],
    [
      "rolling_max_numbers = []\n    for number in numbers:\n        if rolling_max_numbers and number < rolling_max_numbers[-1]:\n            rolling_max_numbers.append(rolling_max_numbers[-1])\n        else:\n            rolling_max_numbers.append(number)\n    return rolling_max_numbers\n\n\ndef get_histogram(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples. Each tuple has a number and count of this number\n    found in a given list.\n    >>> get_histogram([1, 2, 3, 2, 3, 4, 2])\n    [(1, 1), (2, 3), (3, 2), (4, 1)]\n    \"\"\"\n    histogram = {}\n    for number in numbers:\n        if number in histogram:\n            histogram[number] += 1\n        else:\n            histogram[number] = 1\n    return [(number, count) for number, count in histogram.items()]\n\n\ndef get_histogram_sorted_by_count(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples. Each tuple has a number and count of this number\n    found in a given list.\n    >>> get_histogram_sorted_by_count([1, 2, 3, 2, 3, 4, 2])\n    [(2, 3), (3, 2), (1, 1), (4, 1)]\n    \"\"\"\n    return sorted(get_histogram(numbers), key=lambda tup: tup[1], reverse=True)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.26025390625
    ],
    [
      "# Your code here\n    max_value = numbers[0]\n    result = []\n\n    for number in numbers:\n        max_value = max(number, max_value)\n        result.append(max_value)\n\n    return result\n\n\ndef max_sliding_window(numbers: List[int], k: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element found in a sliding window of\n    size k.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    # Your code here\n    result = []\n\n    for index in range(k - 1, len(numbers)):\n        max_value = max(numbers[index - k + 1:index + 1])\n        result.append(max_value)\n\n    return result\n\n\ndef get_histogram(string: str) -> List[Tuple[int, int]]:\n    \"\"\" From a given string generate a list of tuples (character, count of occurrences).\n    >>> get_histogram('aaabbc')\n    [('a', 4), ('b', 2), ('c', 1)]\n    \"\"\"\n    # Your code here\n    result = []\n    for character in string:\n        if character not in result:\n            result.append((character, 1))\n        else:\n            result[result.index((character, ))][1] += 1\n\n    return result\n\n\ndef get_histogram_sort(string: str) -> List[Tuple[int, int]]:\n    \"\"\" From a given string generate a list of tuples (character, count of occurrences).\n    >>> get_histogram('aaabbc')\n    [('a', 4), ('b', 2), ('c', 1)]\n    \"\"\"\n    # Your code here\n    result = {}\n    for character in string:\n        if character not in result:\n            result[character] = 1\n        else:\n            result[character]",
      -0.279296875
    ],
    [
      "return [max(numbers[:i]) for i in range(1, len(numbers) + 1)]\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    return [min(numbers[:i]) for i in range(1, len(numbers) + 1)]\n\n\ndef max_range(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find the first and last index of the maximum element found in the sequence.\n    >>> max_range([1, 2, 3, 2, 3, 4, 2])\n    (2, 5)\n    \"\"\"\n    max_idx = numbers.index(max(numbers))\n    return max_idx, max_idx + numbers[max_idx:].index(max(numbers[max_idx:])) + 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.38818359375
    ],
    [
      "if len(numbers) < 1:\n        raise ValueError(\"Empty list\")\n\n    result = [numbers[0]]\n    for number in numbers[1:]:\n        result.append(max(result[-1], number))\n    return result\n\n\ndef get_max_overlapping_segments(\n    segments: List[Tuple[int, int]],\n) -> List[Tuple[int, int]]:\n    \"\"\"From a given list of segments, return the segments that have maximum overlap\n    >>> get_max_overlapping_segments([(1, 2), (2, 4), (3, 5), (5, 7), (6, 8)])\n    [(1, 2), (2, 4), (3, 5), (5, 7)]\n    \"\"\"\n    segments.sort(key=lambda x: x[0])\n    if len(segments) < 1:\n        raise ValueError(\"Empty list\")\n\n    result: List[Tuple[int, int]] = []\n    for index, segment in enumerate(segments):\n        if segment[0] > segment[1]:\n            raise ValueError(\"Segment start should be smaller than end\")\n\n        if index == 0:\n            result.append(segment)\n        else:\n            if segment[0] <= result[-1][1]:\n                result[-1] = (result[-1][0], max(result[-1][1], segment[1]))\n            else:\n                result.append(segment)\n\n    return result",
      -0.46630859375
    ],
    [
      "result = []\n    for i in range(len(numbers)):\n        if not result:\n            result.append(numbers[i])\n        else:\n            result.append(max(result[-1], numbers[i]))\n    return result\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples of rolling maximum element found until given moment\n    in the sequence and the index of the element.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    result = []\n    for i in range(len(numbers)):\n        if not result:\n            result.append((numbers[i], i))\n        else:\n            if numbers[i] > result[-1][0]:\n                result.append((numbers[i], i))\n            else:\n                result.append(result[-1])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.5078125
    ],
    [
      "result = []\n    for i in range(len(numbers)):\n        if len(result) == 0:\n            result.append(numbers[i])\n        else:\n            result.append(max(numbers[i], result[-1]))\n    return result\n\n\ndef rolling_max_v2(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    maximum = 0\n    for i in range(len(numbers)):\n        maximum = max(maximum, numbers[i])\n        result.append(maximum)\n    return result\n\n\ndef max_subarray(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find the largest subarray with non-negative numbers.\n    >>> max_subarray([1, 2, -4, 5, 7, -3, -8, 9, -5, -2, 6, -7, -1])\n    (20, 7)\n    \"\"\"\n    current_sum = 0\n    max_sum = 0\n    start = 0\n    end = 0\n    for i in range(len(numbers)):\n        current_sum += numbers[i]\n        if current_sum < 0:\n            current_sum = 0\n            start = i + 1\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n    return max_sum, end\n\n\ndef max_subarray_v2(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find the largest subarray with non-negative numbers.\n    >>> max_subarray([1, 2, -4, 5, 7, -3, -8, 9, -5, -2, 6, -7, -1",
      -0.6005859375
    ],
    [
      "return [max(numbers[:n]) for n in range(1, len(numbers) + 1)]\n\n\ndef number_of_increasing_measurements(measurements: List[int]) -> int:\n    \"\"\" Count number of measurements that are higher than the previous one.\n    >>> number_of_increasing_measurements([2, 1, 3, 2, 5, 2, 6, 5])\n    2\n    \"\"\"\n    return sum(1 for i in range(len(measurements) - 1) if measurements[i] < measurements[i + 1])\n\n\ndef number_of_increasing_measurements_sliding_window(measurements: List[int]) -> int:\n    \"\"\" Count number of measurements that are higher than the previous one, using sliding window of size 3.\n    >>> number_of_increasing_measurements_sliding_window([2, 1, 3, 2, 5, 2, 6, 5])\n    3\n    \"\"\"\n    return sum(1 for i in range(len(measurements) - 3) if measurements[i] < measurements[i + 3])\n\n\ndef number_of_increasing_measurements_sliding_window_rolling_max(measurements: List[int]) -> int:\n    \"\"\" Count number of measurements that are higher than the previous one, using sliding window of size 3.\n    >>> number_of_increasing_measurements_sliding_window_rolling_max([2, 1, 3, 2, 5, 2, 6, 5])\n    3\n    \"\"\"\n    return sum(1 for i in range(len(measurements) - 3) if measurements[i] < measurements[i + 3])\n\n\ndef number_of_increasing_measurements_sliding_window_rolling_max_v2(measurements: List[int]) -> int:\n    \"\"\" Count number of measurements that are higher than the previous one, using sliding window of size 3.\n    >>> number_of_increasing_measurements_sliding_window_rolling_max_v2([2, 1, 3",
      -0.82275390625
    ],
    [
      "rolling_max_list = []\n    rolling_max_number = numbers[0]\n    for number in numbers:\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_list.append(rolling_max_number)\n    return rolling_max_list\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min_list = []\n    rolling_min_number = numbers[0]\n    for number in numbers:\n        rolling_min_number = min(rolling_min_number, number)\n        rolling_min_list.append(rolling_min_number)\n    return rolling_min_list\n\n\ndef rolling_sum(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling sum of elements in the sequence until given\n    moment in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 10, 14, 16]\n    \"\"\"\n    rolling_sum_list = []\n    rolling_sum_number = numbers[0]\n    for number in numbers:\n        rolling_sum_number += number\n        rolling_sum_list.append(rolling_sum_number)\n    return rolling_sum_list\n\n\ndef rolling_mean(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling mean of elements in the sequence until given\n    moment in the sequence.\n    >>> rolling_mean([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5, 2.0, 2.5, 3.0, 3.5, 3",
      -0.84130859375
    ],
    [
      "max_so_far = 0\n    result = []\n    for i in range(len(numbers)):\n        max_so_far = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "# TODO: implement me\n    return []\n\n\ndef rolling_max_fast(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_fast([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # TODO: implement me\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.85693359375
    ],
    [
      "rolling_max_numbers: List[int] = []\n\n    for index, number in enumerate(numbers):\n        if index == 0:\n            rolling_max_numbers.append(number)\n        else:\n            rolling_max_numbers.append(max(rolling_max_numbers[index - 1], number))\n\n    return rolling_max_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "if not numbers:\n        return []\n    rolling_max_values: List[int] = [numbers[0]]\n    for number in numbers[1:]:\n        if number > rolling_max_values[-1]:\n            rolling_max_values.append(number)\n        else:\n            rolling_max_values.append(rolling_max_values[-1])\n    return rolling_max_values\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "max_value: int = 0\n    result: List[int] = []\n    for i in numbers:\n        max_value = max(max_value, i)\n        result.append(max_value)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "return [max(numbers[:index + 1]) for index in range(len(numbers))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "result = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return result\n\n\ndef main():\n    print(rolling_max([1, 2, 3, 2, 3, 4, 2]))\n    print(rolling_max([1, 2, 3, 4, 5, 6, 7]))\n\n\nif __name__ == '__main__':\n    main()",
      -0.8583984375
    ],
    [
      "rolling_max_list = []\n    for index, number in enumerate(numbers):\n        if index == 0:\n            rolling_max_list.append(number)\n        else:\n            if number > rolling_max_list[index - 1]:\n                rolling_max_list.append(number)\n            else:\n                rolling_max_list.append(rolling_max_list[index - 1])\n    return rolling_max_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least 2 elements.\")\n\n    rolling_max_list: List[int] = []\n\n    for i in range(len(numbers)):\n        current_max_element = max(numbers[0:i + 1])\n        rolling_max_list.append(current_max_element)\n\n    return rolling_max_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -0.8583984375
    ],
    [
      "rolling_max_numbers = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_numbers.append(max(numbers[i], rolling_max_numbers[-1]))\n    return rolling_max_numbers\n\n\ndef running_median(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of median values found until given moment in the sequence.\n    >>> running_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5, 2, 2.5, 3, 3.5, 3]\n    \"\"\"\n    return [rolling_median(numbers[:i + 1])[-1] for i in range(len(numbers))]\n\n\ndef rolling_median(numbers: List[int]) -> List[float]:\n    \"\"\" From a given list of integers, generate a list of rolling median values found until given moment in the\n    sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 1.5, 2, 2.5, 3, 3.5, 3]\n    \"\"\"\n    rolling_median_numbers = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_median_numbers.append(median(numbers[:i + 1]))\n    return rolling_median_numbers\n\n\ndef median(numbers: List[int]) -> float:\n    \"\"\" Calculate median value from a given list of integers.\n    >>> median([1, 2, 3, 2, 3, 4, 2])\n    2.5\n    \"\"\"\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        return (numbers[len(numbers) // 2] + numbers[len(numbers) // 2 - 1]) / 2\n    return numbers[len(numbers) // 2]\n\n\ndef rolling_mean(numbers: List[int]) -> List[float]:\n    \"\"\" From a given list of integers, generate a list of",
      -0.91552734375
    ],
    [
      "result = []\n    max_number = None\n    for number in numbers:\n        if max_number is None or number > max_number:\n            max_number = number\n        result.append(max_number)\n    return result\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples (index, rolling maximum element found until given\n    moment in the sequence).\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 3), (4, 3), (5, 4), (6, 4)]\n    \"\"\"\n    result = []\n    max_number = None\n    for index, number in enumerate(numbers):\n        if max_number is None or number > max_number:\n            max_number = number\n        result.append((index, max_number))\n    return result\n\n\ndef rolling_max_optimized(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_optimized([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_number = None\n    result = []\n    for number in numbers:\n        if max_number is None or number > max_number:\n            max_number = number\n        result.append(max_number)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -0.9609375
    ],
    [
      "rolling_max_list = []\n    rolling_max_num = numbers[0]\n    for num in numbers:\n        if num > rolling_max_num:\n            rolling_max_num = num\n        rolling_max_list.append(rolling_max_num)\n    return rolling_max_list\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min_list = []\n    rolling_min_num = numbers[0]\n    for num in numbers:\n        if num < rolling_min_num:\n            rolling_min_num = num\n        rolling_min_list.append(rolling_min_num)\n    return rolling_min_list\n\n\ndef rolling_sum(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 10, 14, 16]\n    \"\"\"\n    rolling_sum_list = []\n    rolling_sum_num = numbers[0]\n    for num in numbers:\n        rolling_sum_num += num\n        rolling_sum_list.append(rolling_sum_num)\n    return rolling_sum_list\n\n\ndef rolling_avg(numbers: List[int]) -> List[float]:\n    \"\"\" From a given list of integers, generate a list of rolling average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1.0, 1.5, 2.5, 2.0, 2.5, 3.5,",
      -1.103515625
    ],
    [
      "result: List[int] = []\n\n    for i in range(len(numbers)):\n        if i == 0:\n            result.append(numbers[i])\n        else:\n            if numbers[i - 1] > numbers[i]:\n                result.append(result[-1])\n            else:\n                result.append(numbers[i])\n    return result\n\n\ndef rolling_max_tuple(numbers: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_tuple([(1, 2), (2, 3), (3, 2), (2, 3), (3, 4), (2, 3)])\n    [(1, 2), (2, 3), (3, 3), (3, 3), (3, 4), (4, 4)]\n    \"\"\"\n    result: List[Tuple[int, int]] = []\n\n    for i in range(len(numbers)):\n        if i == 0:\n            result.append(numbers[i])\n        else:\n            if numbers[i - 1][1] > numbers[i][1]:\n                result.append(result[-1])\n            else:\n                result.append(numbers[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -1.3642578125
    ],
    [
      "max_number = float(\"-inf\")\n    max_numbers: List[int] = []\n    for index, number in enumerate(numbers):\n        max_number = max(max_number, number)\n        max_numbers.append(max_number)\n    return max_numbers\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    min_number = float(\"inf\")\n    min_numbers: List[int] = []\n    for index, number in enumerate(numbers):\n        min_number = min(min_number, number)\n        min_numbers.append(min_number)\n    return min_numbers\n\n\ndef max_subarray(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    From a given list of integers, find a contiguous subarray with the largest sum.\n    Return the sum of integers and starting and ending indexes of the subarray.\n    >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    (6, 4, 6)\n    \"\"\"\n    max_sum = float(\"-inf\")\n    curr_sum = 0\n    for index, number in enumerate(numbers):\n        curr_sum += number\n        max_sum = max(max_sum, curr_sum)\n        if curr_sum < 0:\n            curr_sum = 0\n    return max_sum, 0, len(numbers) - 1\n\n\ndef max_subarray_optimized(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    From a given list of integers, find a contiguous subarray with the largest sum.\n    Return the sum of integers and starting and ending indexes of the subarray.\n    >>> max_subarray_optimized([",
      -1.3662109375
    ],
    [
      "max_so_far = [None]\n    max_so_far.extend(numbers)\n    for i in range(1, len(numbers) + 1):\n        if numbers[i - 1] > max_so_far[i - 1]:\n            max_so_far[i] = numbers[i - 1]\n        else:\n            max_so_far[i] = max_so_far[i - 1]\n    return max_so_far[1:]\n\n\ndef rolling_max_no_extra_space(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_no_extra_space([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_so_far = None\n    rolling_max = []\n    for num in numbers:\n        if max_so_far is None:\n            max_so_far = num\n        else:\n            if num > max_so_far:\n                max_so_far = num\n        rolling_max.append(max_so_far)\n    return rolling_max\n\n\ndef max_sublist_sum(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the sum of the largest sublist with the same sign.\n    >>> max_sublist_sum([1, -2, 3, -2, 3, 4, -2])\n    7\n    >>> max_sublist_sum([1, -1, 1, -1, 1])\n    3\n    \"\"\"\n    running_sum = 0\n    max_sum = 0\n    for num in numbers:\n        if running_sum > 0 and num > 0:\n            running_sum += num\n        elif running_sum < 0 and num < 0:\n            running_sum += num\n        else:\n            running_sum = num\n        if running_sum > max_sum:\n            max",
      -1.404296875
    ],
    [
      "max_so_far: List[int] = []\n    max_value = float(\"-inf\")\n    for value in numbers:\n        max_value = max(max_value, value)\n        max_so_far.append(max_value)\n    return max_so_far\n\n\ndef rolling_max_with_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples of rolling maximum element found until given moment\n    in the sequence and the index of the last element in the sequence which caused the max value.\n    >>> rolling_max_with_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    max_so_far: List[Tuple[int, int]] = []\n    max_value = float(\"-inf\")\n    last_index = 0\n    for index, value in enumerate(numbers):\n        if value > max_value:\n            max_value = value\n            last_index = index\n        max_so_far.append((max_value, last_index))\n    return max_so_far\n\n\ndef rolling_max_with_list_of_tuples(numbers: List[int]) -> List[List[Tuple[int, int]]]:\n    \"\"\" From a given list of integers, generate a list of lists of tuples of rolling maximum element found until given\n    moment in the sequence and the index of the last element in the sequence which caused the max value.\n    >>> rolling_max_with_list_of_tuples([1, 2, 3, 2, 3, 4, 2])\n    [[(1, 0)], [(2, 1)], [(3, 2)], [(3, 3)], [(3, 4)], [(4, 5)], [(4, 6)]]\n    \"\"\"\n    max_so_far: List[List[Tuple[int, int]]] =",
      -1.53125
    ],
    [
      "if not numbers:\n        raise ValueError('Empty list of numbers')\n\n    rolling_max_list = []\n    rolling_max_value = numbers[0]\n\n    for number in numbers:\n        if number > rolling_max_value:\n            rolling_max_value = number\n        rolling_max_list.append(rolling_max_value)\n\n    return rolling_max_list\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    if not numbers:\n        raise ValueError('Empty list of numbers')\n\n    rolling_min_list = []\n    rolling_min_value = numbers[0]\n\n    for number in numbers:\n        if number < rolling_min_value:\n            rolling_min_value = number\n        rolling_min_list.append(rolling_min_value)\n\n    return rolling_min_list\n\n\ndef generate_all_sublists(numbers: List[int]) -> List[List[int]]:\n    \"\"\" From a given list of integers, generate a list of all sublists found until given moment in the sequence.\n    >>> generate_all_sublists([1, 2, 3, 2, 3, 4, 2])\n    [[], [1], [2], [3], [2, 3], [2, 3, 4], [2], [3], [2, 3], [2, 3, 4], [2], [4], [2]]\n    \"\"\"\n    if not numbers:\n        raise ValueError('Empty list of numbers')\n\n    sublists = []\n    for i in range(len(numbers) + 1):\n        for j in range(i + 1):\n            sublists.append(numbers[j:i])\n    return sublists\n\n\ndef generate_all_substrings(string: str) -> List[str]:",
      -1.5625
    ],
    [
      "rolling_max = []\n    for i in range(len(numbers)):\n        rolling_max.append(max(numbers[:i+1]))\n    return rolling_max\n\n\ndef get_longest_substring(string: str) -> Tuple[str, int]:\n    \"\"\" Given a string, find the longest substring in it that consists of only one character.\n    >>> get_longest_substring(\"abbbbcc\")\n    ('b', 3)\n    >>> get_longest_substring(\"abbbbccde\")\n    ('b', 3)\n    >>> get_longest_substring(\"aabbccde\")\n    ('a', 2)\n    \"\"\"\n    longest_substring = \"\"\n    longest_substring_len = 0\n    current_substring = \"\"\n    for i in range(len(string)):\n        if string[i] == current_substring:\n            current_substring += string[i]\n        else:\n            current_substring = string[i]\n        if len(current_substring) > longest_substring_len:\n            longest_substring = current_substring\n            longest_substring_len = len(current_substring)\n    return longest_substring, longest_substring_len\n\n\ndef get_most_frequent_letter(string: str) -> Tuple[str, int]:\n    \"\"\" Given a string, find the most frequent letter in the string.\n    >>> get_most_frequent_letter(\"abbbbccde\")\n    ('b', 3)\n    >>> get_most_frequent_letter(\"abbbbccdeee\")\n    ('e', 3)\n    \"\"\"\n    letters_counter = {}\n    for letter in string:\n        if letter in letters_counter:\n            letters_counter[letter] += 1\n        else:\n            letters_counter[letter] = 1\n    return max(letters_counter, key=letters_counter.get)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -1.6494140625
    ],
    [
      "rolling_max_numbers = []\n    max_number = 0\n\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n\n        rolling_max_numbers.append(max_number)\n\n    return rolling_max_numbers\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples of rolling maximum element found until given moment\n    in the sequence and its index.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(1, 0), (2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (4, 6)]\n    \"\"\"\n    rolling_max_numbers = []\n    max_number = 0\n\n    for index, number in enumerate(numbers):\n        if number > max_number:\n            max_number = number\n            rolling_max_numbers.append((max_number, index))\n        else:\n            rolling_max_numbers.append((max_number, index - 1))\n\n    return rolling_max_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -1.748046875
    ],
    [
      "max_number = float(\"-inf\")\n    rolling_max_numbers = []\n    for number in numbers:\n        max_number = max(number, max_number)\n        rolling_max_numbers.append(max_number)\n    return rolling_max_numbers\n\n\ndef rolling_max_optimized(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_optimized([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:index + 1]) for index in range(len(numbers))]\n\n\ndef pairwise_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element from two consecutive numbers in the\n    sequence.\n    >>> pairwise_max([1, 2, 3, 2, 3, 4, 2])\n    [2, 3, 3, 4, 4]\n    \"\"\"\n    max_numbers = []\n    for index in range(len(numbers) - 1):\n        max_number = max(numbers[index], numbers[index + 1])\n        max_numbers.append(max_number)\n    return max_numbers\n\n\ndef pairwise_max_optimized(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element from two consecutive numbers in the\n    sequence.\n    >>> pairwise_max_optimized([1, 2, 3, 2, 3, 4, 2])\n    [2, 3, 3, 4, 4]\n    \"\"\"\n    return [max(pair) for pair in zip(numbers, numbers[1:])]\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> int:\n    \"\"\" Given a list of numbers, find the longest increasing subsequence of that list.\n    >>> longest_increasing",
      -1.869140625
    ],
    [
      "# We use a list comprehension to initialize the rolling_max with the first\n    # element in the given list.\n    rolling_max = [numbers[0]]\n\n    for index, value in enumerate(numbers):\n        # If we're on the first element, there is nothing to compare with, so we\n        # append the value to the rolling_max.\n        if index == 0:\n            rolling_max.append(value)\n            continue\n\n        # If the current value is higher than the last rolling_max element, we\n        # append the current value to the rolling_max.\n        if value > rolling_max[-1]:\n            rolling_max.append(value)\n            continue\n\n        # Otherwise, we append the last rolling_max element to the rolling_max.\n        rolling_max.append(rolling_max[-1])\n\n    return rolling_max\n\n\ndef rolling_max_v2(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # We use a list comprehension to initialize the rolling_max with the first\n    # element in the given list.\n    rolling_max = [numbers[0]]\n\n    for index, value in enumerate(numbers):\n        # If we're on the first element, there is nothing to compare with, so we\n        # append the value to the rolling_max.\n        if index == 0:\n            rolling_max.append(value)\n            continue\n\n        # If the current value is higher than the last rolling_max element, we\n        # append the current value to the rolling_max.\n        if value > rolling_max[-1]:\n            rolling_max.append(value)\n            continue\n\n        # Otherwise, we append the last rolling_max element to the rolling_max.\n        rolling_max.append(rolling_max[-1])\n\n    return rolling_max\n\n\ndef rolling_max_v",
      -1.8779296875
    ],
    [
      "result = []\n    for i in range(len(numbers)):\n        result.append(max(numbers[:i + 1]))\n    return result\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\" Merge two sorted lists into one sorted list.\n    >>> merge([1, 2, 3], [1, 2, 3])\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\n\ndef merge_sort(numbers: List[int]) -> List[int]:\n    \"\"\" Sort a list of integers using merge sort algorithm.\n    >>> merge_sort([4, 2, 3, 1, 0, 5])\n    [0, 1, 2, 3, 4, 5]\n    \"\"\"\n    if len(numbers) <= 1:\n        return numbers\n    mid = len(numbers) // 2\n    left = merge_sort(numbers[:mid])\n    right = merge_sort(numbers[mid:])\n    return merge(left, right)\n\n\ndef find_max_crossing_subarray(\n        arr: List[int], low: int, mid: int, high: int) -> Tuple[int, int, int]:\n    \"\"\" Find maximum subarray in given list of integers using divide and conquer strategy.\n    >>> find_max_crossing_subarray([1, 3, -1, 4, 5], 0, 2, 4)\n    (3, 1, 2)\n    \"\"\"\n    left_sum = float('-inf')\n    sum = 0\n    max_left = max_right = None\n    for i in range(mid - 1, low -",
      -1.9384765625
    ],
    [
      "max_so_far = []\n    for i in range(len(numbers)):\n        max_so_far.append(max(numbers[: i + 1]))\n    return max_so_far\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    min_so_far = []\n    for i in range(len(numbers)):\n        min_so_far.append(min(numbers[: i + 1]))\n    return min_so_far\n\n\ndef count_increases(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, count how many times the value of next element in the sequence\n    is larger than the previous.\n    >>> count_increases([1, 2, 3, 2, 3, 4, 2])\n    5\n    \"\"\"\n    count = 0\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] > numbers[i]:\n            count += 1\n    return count\n\n\ndef count_decreases(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, count how many times the value of next element in the sequence\n    is lower than the previous.\n    >>> count_decreases([1, 2, 3, 2, 3, 4, 2])\n    3\n    \"\"\"\n    count = 0\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] < numbers[i]:\n            count += 1\n    return count\n\n\ndef sliding_window_sum(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of sums of every 3 consecutive elements.\n    >>> sliding_window_sum([1, 2,",
      -2.041015625
    ],
    [
      "if not numbers:\n        return []\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(numbers[: i + 1]))\n    return result\n\n\ndef find_pair_with_max_sum(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find a pair with maximal sum.\n    >>> find_pair_with_max_sum([3, 7, 4, 5, 1])\n    (3, 7)\n    \"\"\"\n    max_sum = 0\n    pair = (0, 0)\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_sum = sum(numbers[i: j + 1])\n            if current_sum > max_sum:\n                pair = (numbers[i], numbers[j])\n                max_sum = current_sum\n    return pair\n\n\ndef find_first_missing_positive(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the first missing positive integer.\n    >>> find_first_missing_positive([3, 4, -1, 1])\n    2\n    \"\"\"\n    if not numbers:\n        return 1\n    for i in range(len(numbers)):\n        if numbers[i] <= 0:\n            continue\n        if abs(numbers[i]) > len(numbers) or abs(numbers[i]) == numbers[abs(numbers[i]) - 1]:\n            numbers[abs(numbers[i]) - 1] = -abs(numbers[abs(numbers[i]) - 1])\n    for i in range(len(numbers)):\n        if numbers[i] > 0:\n            return i + 1\n    return len(numbers) + 1\n\n\ndef find_all_pair_sum(numbers: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, find all pairs with a given sum.\n    >>> find_all_pair_sum([1, 2, 3, 4,",
      -2.2734375
    ],
    [
      "max_val = float('-inf')\n    rolling_max = []\n    for idx, num in enumerate(numbers):\n        max_val = max(max_val, num)\n        rolling_max.append(max_val)\n\n    return rolling_max\n\n\ndef max_sublist_sum(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find a sublist with maximum sum and return the sublist and the sum of the\n    sublist.\n    >>> max_sublist_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    (-5, -12)\n    \"\"\"\n    max_sum = float('-inf')\n    max_sublist = []\n    cur_sum = 0\n    for idx, num in enumerate(numbers):\n        cur_sum += num\n        if cur_sum > max_sum:\n            max_sum = cur_sum\n            max_sublist = numbers[0:idx+1]\n        elif cur_sum < 0:\n            cur_sum = 0\n\n    return max_sublist, max_sum\n\n\ndef find_minimum_index(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the index of the minimum element.\n    >>> find_minimum_index([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    0\n    \"\"\"\n    min_val = float('inf')\n    min_index = None\n    for idx, num in enumerate(numbers):\n        if num < min_val:\n            min_val = num\n            min_index = idx\n    return min_index\n\n\ndef find_maximum_index(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the index of the maximum element.\n    >>> find_maximum_index([-13, -3, -2",
      -2.296875
    ],
    [
      "if len(numbers) == 0:\n        return []\n    if len(numbers) == 1:\n        return [numbers[0]]\n    maximum = numbers[0]\n    rolling_max_numbers = [maximum]\n    for number in numbers[1:]:\n        maximum = max(maximum, number)\n        rolling_max_numbers.append(maximum)\n    return rolling_max_numbers\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    if len(numbers) == 0:\n        return []\n    if len(numbers) == 1:\n        return [numbers[0]]\n    minimum = numbers[0]\n    rolling_min_numbers = [minimum]\n    for number in numbers[1:]:\n        minimum = min(minimum, number)\n        rolling_min_numbers.append(minimum)\n    return rolling_min_numbers\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\" From a given list of integers, generate the length of the longest increasing subsequence\n    and the subsequence itself.\n    >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    (5, [1, 2, 3, 5, 7])\n    >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0])\n    (5, [1, 2, 3, 5, 7])\n    \"\"\"\n    if len(numbers) == 0:\n        return 0, []\n    if len(numbers) == 1:\n        return 1,",
      -2.330078125
    ],
    [
      "rolling_max_result: List[int] = []\n    rolling_max_number: int = 0\n\n    for number in numbers:\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_result.append(rolling_max_number)\n\n    return rolling_max_result\n\n\ndef max_sublist_sum(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, find the maximum sum of a sublist of consecutive numbers.\n    >>> max_sublist_sum([1, -2, 3, 10, -4, 7, 2, -5])\n    14\n    \"\"\"\n    sublist_sum: int = 0\n    max_sublist_sum: int = 0\n\n    for number in numbers:\n        sublist_sum = max(0, sublist_sum + number)\n        max_sublist_sum = max(max_sublist_sum, sublist_sum)\n\n    return max_sublist_sum\n\n\ndef sublist_sum_count(numbers: List[int], sublist_sum_target: int) -> int:\n    \"\"\" From a given list of integers, find the number of sublists of consecutive numbers that have given sum.\n    >>> sublist_sum_count([1, -2, 3, 1, 1, 1, 10, -4, 7, 2, -5], 3)\n    6\n    \"\"\"\n    sublist_sum: int = 0\n    sublist_count: int = 0\n\n    for number in numbers:\n        sublist_sum = max(0, sublist_sum + number)\n        if sublist_sum == sublist_sum_target:\n            sublist_count += 1\n\n    return sublist_count\n\n\ndef sublist_sum_count_optimized(numbers: List[int], sublist_sum_target: int) -> int:\n    \"\"\" From a given list of integers, find the number of sublists of consecutive numbers that have given sum.\n    >>> sublist_sum_count_optimized([1, -2, 3, 1, 1, 1",
      -2.365234375
    ],
    [
      "rolling_max_numbers: List[int] = []\n    rolling_max_number = float(\"-inf\")\n\n    for number in numbers:\n        rolling_max_number = max(number, rolling_max_number)\n        rolling_max_numbers.append(rolling_max_number)\n\n    return rolling_max_numbers\n\n\ndef rolling_max_with_stack(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_stack([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_numbers: List[int] = []\n    rolling_max_number = float(\"-inf\")\n\n    for number in numbers:\n        if number > rolling_max_number:\n            rolling_max_number = number\n        rolling_max_numbers.append(rolling_max_number)\n\n    return rolling_max_numbers\n\n\ndef rolling_max_with_sliding_window(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_sliding_window([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_numbers: List[int] = []\n    rolling_max_number = float(\"-inf\")\n\n    for index, number in enumerate(numbers):\n        rolling_max_number = max(number, rolling_max_number)\n        if index >= 1:\n            rolling_max_numbers[index - 1] = rolling_max_number\n        else:\n            rolling_max_numbers.append(rolling_max_number)\n\n    return rolling_max_numbers\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> int:",
      -2.400390625
    ],
    [
      "if not numbers:\n        return []\n    output = [max(numbers)]\n    for index in range(1, len(numbers)):\n        output.append(max(numbers[:index + 1]))\n    return output\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    if not numbers:\n        return []\n    output = [min(numbers)]\n    for index in range(1, len(numbers)):\n        output.append(min(numbers[:index + 1]))\n    return output\n\n\ndef max_subarray(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\" Return the maximum sum of a subarray in given list of integers.\n    >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    (6, 2, 6)\n    \"\"\"\n    output = 0\n    start = 0\n    end = 0\n    for i in range(len(numbers)):\n        output += numbers[i]\n        if output < 0:\n            output = 0\n            start = i + 1\n        if end < i:\n            end = i\n    return (output, start, end)\n\n\ndef max_subarray_divide_and_conquer(numbers: List[int], start: int, end: int) -> Tuple[int, int, int]:\n    \"\"\" Return the maximum sum of a subarray in given list of integers.\n    >>> max_subarray_divide_and_conquer([-2, 1, -3, 4, -1, 2, 1, -5, 4], 0, 8)\n    (6, 2, 6)\n    \"\"\"\n    if start == end:\n        return (numbers[start], start, end)",
      -2.453125
    ],
    [
      "rolling_max = []\n    for i, number in enumerate(numbers):\n        if not rolling_max:\n            rolling_max.append(number)\n        else:\n            rolling_max.append(max(rolling_max[i-1], number))\n    return rolling_max\n\n\ndef rolling_max_bruteforce(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max = []\n    for i, number in enumerate(numbers):\n        rolling_max.append(max(rolling_max[:i] + [number]))\n    return rolling_max\n\n\ndef rolling_max_optimized(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max = []\n    for i, number in enumerate(numbers):\n        if not rolling_max:\n            rolling_max.append(number)\n        else:\n            rolling_max.append(max(rolling_max[-1], number))\n    return rolling_max\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -2.560546875
    ],
    [
      "max_so_far = [numbers[0]]\n    for number in numbers[1:]:\n        max_so_far.append(max(number, max_so_far[-1]))\n    return max_so_far\n\n\ndef merge_sorted_lists(list_one: List[int], list_two: List[int]) -> List[int]:\n    \"\"\"Merge two sorted lists into one sorted list.\n\n    >>> merge_sorted_lists([1, 2, 3], [1, 2, 3])\n    [1, 1, 2, 2, 3, 3]\n\n    >>> merge_sorted_lists([1, 2, 3], [])\n    [1, 2, 3]\n\n    >>> merge_sorted_lists([], [1, 2, 3])\n    [1, 2, 3]\n    \"\"\"\n    i = 0\n    j = 0\n    result = []\n    while i < len(list_one) and j < len(list_two):\n        if list_one[i] < list_two[j]:\n            result.append(list_one[i])\n            i += 1\n        else:\n            result.append(list_two[j])\n            j += 1\n    result.extend(list_one[i:])\n    result.extend(list_two[j:])\n    return result\n\n\ndef merge_sorted_files(path_one: str, path_two: str, output_path: str) -> None:\n    \"\"\"Merge two sorted files into one sorted file.\n\n    >>> import os\n    >>> from shutil import copyfile\n    >>> import random\n    >>> def delete_file(path):\n    ...     try:\n    ...         os.remove(path)\n    ...     except OSError:\n    ...         pass\n    >>> path_one = 'file_one.txt'\n    >>> path_two = 'file_two.txt'\n    >>> output_path = 'output.txt'\n    >>> copyfile('test.txt', path_one)\n    >>> copyfile('test.txt', path_two)\n    >>> random.shuffle(open(",
      -2.634765625
    ],
    [
      "max_val = 0\n    rolling_max_numbers = []\n    for number in numbers:\n        max_val = max(max_val, number)\n        rolling_max_numbers.append(max_val)\n    return rolling_max_numbers\n\n\ndef rolling_max_efficient(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_efficient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_numbers = []\n    for index, number in enumerate(numbers):\n        if index == 0:\n            rolling_max_numbers.append(number)\n        else:\n            rolling_max_numbers.append(max(rolling_max_numbers[-1], number))\n    return rolling_max_numbers\n\n\ndef min_max_sum(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Calculate the sum of all the minimum elements and maximum elements in the given list.\n    >>> min_max_sum([1, 2, 3, 4])\n    (10, 10)\n    >>> min_max_sum([1, 2, 3, 4, 5])\n    (10, 15)\n    \"\"\"\n    min_sum = max_sum = 0\n    for number in numbers:\n        min_sum += number\n        max_sum += number\n\n    min_sum = max_sum = max(numbers)\n    for number in numbers:\n        min_sum = min(min_sum, number)\n        max_sum = max(max_sum, number)\n\n    return min_sum, max_sum\n\n\ndef min_max_sum_efficient(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Calculate the sum of all the minimum elements and maximum elements in the given list.\n    >>> min_max_sum_efficient([1, 2, 3, 4])\n    (1",
      -2.64453125
    ],
    [
      "rolling_max_vals = []\n    current_max = numbers[0]\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_vals.append(current_max)\n    return rolling_max_vals\n\n\ndef max_product_subarray(array: List[int]) -> Tuple[int, int, int]:\n    \"\"\" Given an array of integers, find the contiguous subarray of integers which has the largest product\n    >>> max_product_subarray([-10, -1, -2, 1, 2, 3])\n    (-2, 1, 2)\n    \"\"\"\n    if len(array) == 0:\n        raise ValueError('Array must be non-empty')\n\n    max_ending_here = max_so_far = array[0]\n    start = end = 0\n    for index, num in enumerate(array[1:]):\n        if num > 0:\n            max_ending_here = max_ending_here * num\n        else:\n            max_ending_here = 1\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n            start = end = index\n        elif max_ending_here == 1:\n            start = end = index\n        elif max_ending_here == 0:\n            start = end = index + 1\n        end += 1\n    return start, end, max_so_far\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()",
      -2.71484375
    ],
    [
      "if len(numbers) == 0:\n        return []\n    max_so_far = max(numbers)\n    result = [max_so_far]\n    for i in range(1, len(numbers)):\n        if numbers[i] > result[i - 1]:\n            result.append(numbers[i])\n        else:\n            result.append(max_so_far)\n    return result\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, generate a list of increasing subsequences of given sequence,\n    where each increasing subsequence is defined as a sequence of consecutive integers in which the elements\n    are in increasing order.\n    >>> longest_increasing_subsequence([1, 2, 3, 2, 3, 4, 2])\n    4\n    \"\"\"\n    if len(numbers) == 0:\n        return 0\n    max_so_far = 1\n    max_len = 1\n    for i in range(1, len(numbers)):\n        if numbers[i] > numbers[i - 1]:\n            max_so_far += 1\n            max_len = max(max_len, max_so_far)\n        else:\n            max_so_far = 1\n    return max_len\n\n\ndef longest_increasing_subsequence_recursive(numbers: List[int]) -> int:\n    \"\"\" From a given list of integers, generate a list of increasing subsequences of given sequence,\n    where each increasing subsequence is defined as a sequence of consecutive integers in which the elements\n    are in increasing order.\n    >>> longest_increasing_subsequence([1, 2, 3, 2, 3, 4, 2])\n    4\n    \"\"\"\n    if len(numbers) == 0:\n        return 0\n    max_so_far = 1\n    for i in range(1, len(numbers)):\n        if numbers[i] > numbers[i - 1]:\n            max_so_far += 1\n        else:\n            max_so_far = 1\n    return max_so_far\n\n\ndef",
      -2.71484375
    ],
    [
      "return [max(numbers[:i + 1]) for i in range(len(numbers))]\n\n\ndef rolling_max_optimized(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_optimized([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_number = numbers[0]\n    output = [max_number]\n    for number in numbers[1:]:\n        max_number = max(max_number, number)\n        output.append(max_number)\n    return output\n\n\ndef rolling_max_tuple(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples where each tuple contains index of the\n    maximum number found in the sequence at a given moment and the maximum number itself.\n    >>> rolling_max_tuple([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 2), (4, 3), (5, 4), (6, 2)]\n    \"\"\"\n    return [(i, max(numbers[:i + 1])) for i in range(len(numbers))]\n\n\ndef rolling_max_tuple_optimized(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" From a given list of integers, generate a list of tuples where each tuple contains index of the\n    maximum number found in the sequence at a given moment and the maximum number itself.\n    >>> rolling_max_tuple_optimized([1, 2, 3, 2, 3, 4, 2])\n    [(0, 1), (1, 2), (2, 3), (3, 2), (4, 3), (5, 4), (6, 2)]\n    \"\"\"\n    max_number = numbers[0]",
      -2.82421875
    ],
    [
      "if not numbers:\n        raise ValueError(\"Empty list\")\n\n    rolling_max_so_far: List[int] = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_so_far.append(max(numbers[i], rolling_max_so_far[i - 1]))\n\n    return rolling_max_so_far\n\n\ndef get_max_revenue(costs: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of costs, find a maximum revenue and the most optimal sequence of buying and selling.\n    >>> get_max_revenue([5, 2, 7, 3, 4, 6, 1])\n    (13, 5)\n    \"\"\"\n    if not costs:\n        raise ValueError(\"Empty list\")\n    if len(costs) < 2:\n        raise ValueError(\"List must have at least two elements\")\n\n    rolling_max_so_far = rolling_max(costs)\n    max_revenue = rolling_max_so_far[-1] - costs[0]\n    most_optimal_sequence_of_buying_and_selling: List[int] = [0]\n    for i in range(1, len(costs)):\n        if rolling_max_so_far[i] - costs[i] > max_revenue:\n            max_revenue = rolling_max_so_far[i] - costs[i]\n            most_optimal_sequence_of_buying_and_selling = [i]\n        elif rolling_max_so_far[i] - costs[i] == max_revenue:\n            most_optimal_sequence_of_buying_and_selling.append(i)\n\n    return max_revenue, most_optimal_sequence_of_buying_and_selling\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -2.91796875
    ],
    [
      "rolling_max = []\n    max_number = 0\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n        rolling_max.append(max_number)\n    return rolling_max\n\n\ndef rolling_max_stack(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_stack([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max = []\n    max_number = 0\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n        rolling_max.append(max_number)\n    return rolling_max\n\n\ndef max_sublist(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\" Find a sublist with the maximum sum in a given list of integers.\n    >>> max_sublist([1, -2, 3, 10, 4, -8, 2, -1])\n    (14, [3, 10, 4])\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    max_sum_start = 0\n    max_sum_end = 0\n    for index, number in enumerate(numbers):\n        current_sum += number\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_start = index\n            max_sum_end = index + 1\n        elif current_sum < 0:\n            current_sum = 0\n    return max_sum, numbers[max_sum_start:max_sum_end]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
      -2.935546875
    ],
    [
      "result = []\n    for i in range(0, len(numbers)):\n        max_value = numbers[i]\n        for j in range(i, len(numbers)):\n            if numbers[j] > max_value:\n                max_value = numbers[j]\n        result.append(max_value)\n    return result\n\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Check if a given string is palindrome.\n    >>> is_palindrome(\"aba\")\n    True\n    >>> is_palindrome(\"abba\")\n    False\n    \"\"\"\n    if len(string) == 0 or len(string) == 1:\n        return True\n    if string[0] == string[-1]:\n        return is_palindrome(string[1:-1])\n    else:\n        return False\n\n\ndef longest_palindrome(string: str) -> str:\n    \"\"\" Find longest palindrome in a given string.\n    >>> longest_palindrome(\"abaxyzzyxf\")\n    \"xyzzyx\"\n    \"\"\"\n    if len(string) == 0 or len(string) == 1:\n        return string\n    if string[0] == string[-1]:\n        return longest_palindrome(string[1:-1]) + string[0]\n    else:\n        return max(longest_palindrome(string[1:]), longest_palindrome(string[:-1]), key=len)\n\n\ndef longest_palindrome_with_center(string: str) -> str:\n    \"\"\" Find longest palindrome in a given string.\n    >>> longest_palindrome_with_center(\"abaxyzzyxf\")\n    \"xyzyx\"\n    \"\"\"\n    if len(string) == 0 or len(string) == 1:\n        return string\n    if string[0] == string[-1]:\n        return longest_palindrome_with_center(string[1:-1]) + string[0]\n    else:\n        return max(longest_palindrome_with_center(string[1:]), longest_palindrome_with_center(string[:-1]), key=len)\n\n\ndef",
      -2.970703125
    ],
    [
      "if not numbers:\n        raise ValueError(\"Cannot find max in empty list\")\n\n    rolling_max_list = []\n    rolling_max_num = max(numbers)\n\n    for num in numbers:\n        rolling_max_num = max(num, rolling_max_num)\n        rolling_max_list.append(rolling_max_num)\n\n    return rolling_max_list\n\n\ndef max_sliding_window(numbers: List[int], k: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element found in a sliding window\n    of given size k.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    if not numbers or k > len(numbers):\n        raise ValueError(\"Cannot find sliding max in empty list or list smaller than window size\")\n\n    sliding_max_list = []\n    sliding_max_num = max(numbers[0:k])\n\n    for index, num in enumerate(numbers):\n        if index + k > len(numbers):\n            break\n\n        sliding_max_num = max(sliding_max_num, max(numbers[index : index + k]))\n        sliding_max_list.append(sliding_max_num)\n\n    return sliding_max_list\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[List[int], int]:\n    \"\"\" From a given list of integers, find the longest subsequence of increasing numbers.\n    >>> longest_increasing_subsequence([3, 4, -1, 5, 8, 10, 1, 2, 4, 6, -2, 7, 9])\n    ([3, 4, 5, 8, 10], 5)\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Cannot find longest increasing subsequence in empty list\")\n\n    # this is a 2D array with row for every element in the",
      -3.193359375
    ],
    [
      "rolling_max_list = []\n    rolling_max_value = 0\n    for n in numbers:\n        rolling_max_value = max(rolling_max_value, n)\n        rolling_max_list.append(rolling_max_value)\n    return rolling_max_list\n\n\ndef max_ones_count(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" From a given list of integers, find longest sequence of 1's and the first position in the sequence.\n    >>> max_ones_count([1, 0, 1, 0, 1, 1, 1, 1])\n    (4, 2)\n    >>> max_ones_count([1, 1, 1, 1, 1, 1, 1, 1])\n    (8, 0)\n    \"\"\"\n    max_count = 0\n    max_count_start = 0\n    count = 0\n    for i in range(len(numbers)):\n        if numbers[i] == 1:\n            count += 1\n        else:\n            if count > max_count:\n                max_count = count\n                max_count_start = i - count\n            count = 0\n    if count > max_count:\n        max_count = count\n        max_count_start = len(numbers) - count\n    return max_count, max_count_start\n\n\ndef find_max_subarray(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\" From a given list of integers, find the largest subarray of contiguous integers which has the largest sum.\n    >>> find_max_subarray([-2, -5, 6, -2, -3, 1, 5, -6])\n    (7, 4, 6)\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    max_start = 0\n    max_end = 0\n    for i in range(len(numbers)):\n        current_sum += numbers[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start = i",
      -3.197265625
    ],
    [
      "rolling_max_list = []\n    for number in numbers:\n        if not rolling_max_list:\n            rolling_max_list.append(number)\n        else:\n            rolling_max_list.append(max(rolling_max_list[-1], number))\n    return rolling_max_list\n\n\ndef get_subsequences(numbers: List[int]) -> List[Tuple[int, ...]]:\n    \"\"\"From a given list of integers, generate all subsequences.\n    >>> get_subsequences([1, 2, 3, 4])\n    [(1, 2), (1, 2, 3), (1, 2, 3, 4), (1, 2, 4), (1, 3), (1, 3, 4), (1, 4), (2, 3), (2, 3, 4), (2, 4), (3, 4)]\n    \"\"\"\n    subsequences = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers) + 1):\n            subsequences.append(tuple(numbers[i:j]))\n    return subsequences\n\n\ndef get_permutations(numbers: List[int]) -> List[Tuple[int, ...]]:\n    \"\"\"From a given list of integers, generate all permutations.\n    >>> get_permutations([1, 2, 3])\n    [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]\n    \"\"\"\n    permutations = []\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers) + 1):\n            for k in range(j + 1, len(numbers) + 1):\n                permutations.append(tuple(numbers[i:k]))\n    return permutations\n\n\ndef get_combinations(numbers: List[int], k: int) -> List[Tuple[int, ...]]:\n    \"\"\"From a given list",
      -3.326171875
    ],
    [
      "result = []\n    max_element = float(\"-inf\")\n    for index, element in enumerate(numbers):\n        max_element = max(max_element, element)\n        result.append(max_element)\n    return result\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    result = []\n    min_element = float(\"inf\")\n    for index, element in enumerate(numbers):\n        min_element = min(min_element, element)\n        result.append(min_element)\n    return result\n\n\ndef count_negatives(matrix: List[List[int]]) -> int:\n    \"\"\" Count the number of negative elements in a given matrix.\n    >>> count_negatives([[3, 2, -1], [0, 3, 2], [2, 3, 3]])\n    3\n    \"\"\"\n    return sum([1 for row in matrix for element in row if element < 0])\n\n\ndef count_positives(matrix: List[List[int]]) -> int:\n    \"\"\" Count the number of positive elements in a given matrix.\n    >>> count_positives([[3, 2, -1], [0, 3, 2], [2, 3, 3]])\n    7\n    \"\"\"\n    return sum([1 for row in matrix for element in row if element > 0])\n\n\ndef sum_of_all_elements(matrix: List[List[int]]) -> int:\n    \"\"\" Calculate the sum of all elements in a given matrix.\n    >>> sum_of_all_elements([[3, 2, -1], [0, 3, 2], [2, 3, 3]])\n    -2\n    \"\"\"\n    return sum([sum(row) for row in matrix])\n\n\ndef sum_of_all_elements_except_minimum",
      -3.44140625
    ],
    [
      "if not numbers:\n        return []\n    max_so_far = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_so_far.append(max(max_so_far[i - 1], numbers[i]))\n    return max_so_far\n\n\ndef max_sliding_window(numbers: List[int], k: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of max elements in rolling window of given size.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    if not numbers or k > len(numbers):\n        return []\n    max_so_far = []\n    for i in range(len(numbers)):\n        max_so_far.append(max(numbers[i : i + k]))\n    return max_so_far\n\n\ndef max_crossing_subarray(numbers: List[int], low: int, mid: int, high: int) -> Tuple[int, int, int]:\n    \"\"\" Find max subarray of a given list of integers within [low, high] range.\n    >>> max_crossing_subarray([13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7], 0, 5, 9)\n    (20, 4, 8)\n    \"\"\"\n    left_sum = -float(\"inf\")\n    sum_so_far = 0\n    for i in reversed(range(low, mid)):\n        sum_so_far += numbers[i]\n        if sum_so_far > left_sum:\n            left_sum = sum_so_far\n            max_left = i\n    right_sum = -float(\"inf\")\n    sum_so_far = 0\n    for j in range(mid, high):\n        sum_so_far",
      -3.451171875
    ],
    [
      "# initialize the output with the first element\n    result = [numbers[0]]\n    # iterate over the remaining elements\n    for index in range(1, len(numbers)):\n        # if the current element is larger than the last element, update the last element in the output\n        if numbers[index] > result[-1]:\n            result.append(numbers[index])\n        # otherwise, just keep the last element in the output\n        else:\n            result.append(result[-1])\n    return result\n\n\ndef max_rolling_window(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found within given window\n    in the sequence.\n    >>> max_rolling_window([1, 2, 3, 2, 3, 4, 2], 3)\n    [2, 3, 3, 4, 4, 4, 4]\n    \"\"\"\n    # initialize the output with the first window_size elements\n    result = numbers[:window_size]\n    # iterate over the remaining elements\n    for index in range(window_size, len(numbers)):\n        # get the current window\n        window = numbers[index - window_size : index + 1]\n        # get the maximum value in the current window\n        window_max = max(window)\n        # if the maximum value in the current window is larger than the last element in the output,\n        # update the last element in the output\n        if window_max > result[-1]:\n            result.append(window_max)\n        # otherwise, just keep the last element in the output\n        else:\n            result.append(result[-1])\n    return result\n\n\ndef get_max_profit(stock_prices: List[int]) -> int:\n    \"\"\" From a given list of integers representing stock prices, find the maximum profit that can be made by\n    buying at the minimum price and selling at the maximum price.\n    >>> get_max_profit([10, 7, 5, 8, 11, 9])\n    6\n    \"\"\"\n    # initialize the output to 0\n    max_profit =",
      -3.470703125
    ],
    [
      "result: List[int] = []\n    max_so_far: int = float(\"-inf\")\n    for index, number in enumerate(numbers):\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    return result\n\n\ndef merge_sorted_lists(list_a: List[int], list_b: List[int]) -> List[int]:\n    \"\"\"Merge two sorted lists into one sorted list.\n    >>> merge_sorted_lists([1, 2, 4], [3, 5])\n    [1, 2, 3, 4, 5]\n    >>> merge_sorted_lists([1, 2, 4, 5], [3, 5])\n    [1, 2, 3, 4, 5]\n    >>> merge_sorted_lists([1, 2, 4, 5], [3, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    result: List[int] = []\n    index_a: int = 0\n    index_b: int = 0\n    while index_a < len(list_a) and index_b < len(list_b):\n        if list_a[index_a] < list_b[index_b]:\n            result.append(list_a[index_a])\n            index_a += 1\n        else:\n            result.append(list_b[index_b])\n            index_b += 1\n    if index_a == len(list_a):\n        result.extend(list_b[index_b:])\n    else:\n        result.extend(list_a[index_a:])\n    return result\n\n\ndef merge_sorted_files(file_names: List[str]) -> List[int]:\n    \"\"\"Merge two sorted files into one sorted file.\n    >>> merge_sorted_files([\"test_data/merge_file_1.txt\", \"test_data/merge_file_2.txt\"])\n    [1, 2, 3, 4, 5,",
      -3.609375
    ],
    [
      "rolling_max_list: List[int] = []\n    current_max: int = 0\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list\n\n\ndef find_pairs_with_given_sum(numbers: List[int], target_sum: int) -> List[Tuple[int, int]]:\n    \"\"\" Find pairs of integers in a given list of numbers with a given sum.\n    >>> find_pairs_with_given_sum([1, 2, 3, 4, 5, 6, 7], 6)\n    [(1, 5), (2, 4), (3, 3), (4, 2)]\n    \"\"\"\n    pairs: List[Tuple[int, int]] = []\n    numbers_dict = {number: index for index, number in enumerate(numbers)}\n    for index, number in enumerate(numbers):\n        target_number = target_sum - number\n        if target_number in numbers_dict and index < numbers_dict[target_number]:\n            pairs.append((number, target_number))\n    return pairs\n\n\ndef find_max_crossing_subarray(\n    numbers: List[int], low: int, mid: int, high: int\n) -> Tuple[int, int, int]:\n    \"\"\" Find maximum sum subarray in the given list of numbers between given indexes.\n    >>> find_max_crossing_subarray([-2, -5, 6, -2, -3, 1, 5, -6], 0, 3, 7)\n    (-2, 4, 6)\n    \"\"\"\n    left_sum = -float(\"inf\")\n    sum_ = 0\n    max_left, max_right = low, -1\n    for index in range(mid, low - 1, -1):\n        sum_ += numbers[index]\n        if sum_ > left_sum:\n            left_sum = sum_\n            max_left = index\n\n    right_sum = -float(\"inf\")\n    sum_ = 0\n    for index",
      -4.08984375
    ],
    [
      "rolling_max_values: List[int] = []\n    current_max = float(\"-inf\")\n\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_values.append(current_max)\n\n    return rolling_max_values\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min_values: List[int] = []\n    current_min = float(\"inf\")\n\n    for num in numbers:\n        current_min = min(current_min, num)\n        rolling_min_values.append(current_min)\n\n    return rolling_min_values\n\n\ndef rolling_sum(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling sum until given moment in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 6, 8, 10, 14, 16]\n    \"\"\"\n    rolling_sum_values: List[int] = []\n    current_sum = 0\n\n    for num in numbers:\n        current_sum += num\n        rolling_sum_values.append(current_sum)\n\n    return rolling_sum_values\n\n\ndef rolling_median(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling median until given moment in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 2, 2, 2, 3, 3]\n    \"\"\"\n    rolling_median_values: List[int] = []\n    numbers_len",
      -4.3984375
    ],
    [
      "rolling_max_numbers = []\n    rolling_max_number = max(numbers)\n    for number in numbers:\n        rolling_max_number = max(rolling_max_number, number)\n        rolling_max_numbers.append(rolling_max_number)\n\n    return rolling_max_numbers\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min_numbers = []\n    rolling_min_number = min(numbers)\n    for number in numbers:\n        rolling_min_number = min(rolling_min_number, number)\n        rolling_min_numbers.append(rolling_min_number)\n\n    return rolling_min_numbers\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> List[int]:\n    \"\"\" Find longest increasing subsequence in a given sequence.\n    >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    previous_numbers = [0] * len(numbers)\n    longest_length = 0\n    longest_subsequence_index = 0\n    for index, number in enumerate(numbers):\n        previous_number = previous_numbers[longest_subsequence_index]\n        if number > previous_number:\n            longest_length = longest_length + 1\n            previous_numbers[index] = previous_number\n        else:\n            previous_numbers[index] = index\n            longest_subsequence_index = previous_numbers[index]\n            longest_length = longest_length - 1\n\n    longest_subsequence = numbers[:longest_length]\n    return longest_subsequence",
      -4.59765625
    ],
    [
      "max_value = 0\n    result = []\n    for number in numbers:\n        max_value = max(max_value, number)\n        result.append(max_value)\n    return result\n\n\ndef count_substring(string: str = \"\", substring: str = \"\") -> int:\n    \"\"\" Counts how many times given substring is found in given string.\n    >>> count_substring(\"ABCDCDC\", \"CDC\")\n    2\n    \"\"\"\n    count = 0\n    for index in range(len(string) - len(substring) + 1):\n        if string[index : index + len(substring)] == substring:\n            count += 1\n    return count\n\n\ndef count_substring_regex(string: str = \"\", substring: str = \"\") -> int:\n    \"\"\" Counts how many times given substring is found in given string.\n    >>> count_substring(\"ABCDCDC\", \"CDC\")\n    2\n    \"\"\"\n    import re\n\n    pattern = re.compile(f\"{substring}\")\n    return len(pattern.findall(string))\n\n\ndef count_substring_kmp(string: str = \"\", substring: str = \"\") -> int:\n    \"\"\" Counts how many times given substring is found in given string.\n    >>> count_substring(\"ABCDCDC\", \"CDC\")\n    2\n    \"\"\"\n    count = 0\n    start = 0\n    substring_length = len(substring)\n    string_length = len(string)\n\n    if string_length == 0 or substring_length == 0:\n        return count\n\n    failure_table = build_failure_table(substring)\n\n    while start <= string_length - substring_length:\n        i = 0\n        while i < substring_length and substring[i] == string[start + i]:\n            i += 1\n        if i == substring_length:\n            count += 1\n            start += i - failure_table[i - 1]\n        else:\n            start += i\n\n    return count\n\n\ndef build_failure_table(substring: str) -> List[int]:\n    substring_length = len(substring)\n    if substring_length == 1:",
      -4.6171875
    ],
    [
      "rolling_max_numbers: List[int] = []\n    for index in range(len(numbers)):\n        if index == 0:\n            rolling_max_numbers.append(numbers[0])\n        else:\n            rolling_max_numbers.append(max(rolling_max_numbers[index - 1], numbers[index]))\n    return rolling_max_numbers\n\n\ndef get_k_closest_numbers(numbers: List[int], k: int) -> Tuple[List[int], List[int]]:\n    \"\"\" From a given list of integers and a given integer k, return two lists, one containing the k closest\n    numbers to 0, sorted in ascending order, and the other containing the k furthest numbers to 0, sorted in\n    descending order.\n    >>> get_k_closest_numbers([4, 5, 1, 2, 3], 2)\n    ([1, 2], [4, 5])\n    \"\"\"\n    closest_numbers: List[int] = []\n    furthest_numbers: List[int] = []\n    for number in numbers:\n        if len(closest_numbers) < k:\n            closest_numbers.append(number)\n        elif len(closest_numbers) == k:\n            if number < closest_numbers[0]:\n                furthest_numbers.append(closest_numbers[0])\n                closest_numbers[0] = number\n            else:\n                furthest_numbers.append(number)\n        else:\n            if number < closest_numbers[0]:\n                furthest_numbers.pop()\n                closest_numbers.append(number)\n            else:\n                furthest_numbers.append(number)\n    return closest_numbers, furthest_numbers\n\n\ndef generate_primes(n: int) -> List[int]:\n    \"\"\" From a given integer n, generate a list of all primes smaller than or equal to n.\n    >>> generate_primes(10)\n    [2, 3, 5, 7]\n    \"\"\"\n    primes: List[int] = []\n    for number in range(2, n + 1):\n        if all(number",
      -5.11328125
    ],
    [
      "max_number = 0\n    rolling_max_numbers = []\n\n    for number in numbers:\n        max_number = max(max_number, number)\n        rolling_max_numbers.append(max_number)\n\n    return rolling_max_numbers\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    From a given list of integers, find a longest increasing subsequence.\n    >>> longest_increasing_subsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])\n    (6, [0, 2, 6, 9, 11, 15])\n    >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6])\n    (6, [1, 2, 3, 4, 5, 6])\n    >>> longest_increasing_subsequence([1, 3, 4, 7, 6, 8])\n    (4, [1, 3, 4, 7])\n    \"\"\"\n    previous_indexes = [0]\n    max_length = 0\n    current_index = 0\n\n    for number in numbers:\n        current_index += 1\n        for previous_index in previous_indexes:\n            if numbers[current_index] > numbers[previous_index]:\n                if max_length < current_index - previous_index + 1:\n                    max_length = current_index - previous_index + 1\n                    previous_indexes = [previous_index]\n                elif max_length == current_index - previous_index + 1:\n                    previous_indexes.append(previous_index)\n                break\n        else:\n            previous_indexes.append(current_index)\n\n    return max_length, [numbers[index] for index in previous_indexes]\n\n\ndef longest_decreasing_subsequence(numbers: List[int]) ->",
      -5.15234375
    ],
    [
      "rolling_max_list = []\n    rolling_max_value = float(\"-inf\")\n    for num in numbers:\n        rolling_max_value = max(num, rolling_max_value)\n        rolling_max_list.append(rolling_max_value)\n    return rolling_max_list\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\" From a given list of integers, find the longest increasing subsequence in the list and return\n    both the length of the longest increasing subsequence and the list of integers.\n    >>> longest_increasing_subsequence([3, 5, 2, 7, 1, 9, 4, 8, 12])\n    (5, [3, 2, 1, 4, 8])\n    \"\"\"\n    max_sequence_length = 0\n    max_sequence = []\n    subsequence_length = 0\n    subsequence = []\n\n    for num in numbers:\n        if subsequence_length == 0:\n            subsequence.append(num)\n            subsequence_length += 1\n        else:\n            if num > subsequence[-1]:\n                subsequence.append(num)\n                subsequence_length += 1\n            else:\n                subsequence_length = 1\n                subsequence = [num]\n        if subsequence_length > max_sequence_length:\n            max_sequence = subsequence.copy()\n            max_sequence_length = subsequence_length\n\n    return max_sequence_length, max_sequence\n\n\ndef longest_decreasing_subsequence(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\" From a given list of integers, find the longest decreasing subsequence in the list and return\n    both the length of the longest decreasing subsequence and the list of integers.\n    >>> longest_decreasing_subsequence([3, 5, 2, 7, 1, 9, 4, 8, 12])\n    (5, [1, 2, 3, 4, 7])\n    \"\"\"\n    max_sequence_length =",
      -5.17578125
    ],
    [
      "return [max(numbers[:i + 1]) for i in range(len(numbers))]\n\n\ndef rolling_max_divide_and_conquer(numbers: List[int], start: int, end: int) -> int:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_divide_and_conquer([1, 2, 3, 2, 3, 4, 2], 0, 6)\n    4\n    \"\"\"\n    if start == end:\n        return numbers[start]\n    mid = (start + end) // 2\n    left_max = rolling_max_divide_and_conquer(numbers, start, mid)\n    right_max = rolling_max_divide_and_conquer(numbers, mid + 1, end)\n    return max(left_max, right_max)\n\n\ndef find_max_crossing_subarray(\n    numbers: List[int], low: int, mid: int, high: int\n) -> Tuple[int, int, int]:\n    \"\"\" Find the maximum subarray crossing the middle element in a given list of integers.\n    >>> find_max_crossing_subarray([13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7], 0, 7, 14)\n    (-25, 2, 6)\n    \"\"\"\n    left_sum = 0\n    left_start, left_end = 0, 0\n    for i in range(mid + 1, high + 1):\n        left_sum += numbers[i]\n        if left_sum > left_start:\n            left_start = left_sum\n            left_end = i\n    right_sum = 0\n    right_start, right_end = 0, 0\n    for j in range(mid, low - 1, -1):\n        right_sum += numbers[j]\n        if right_sum > right",
      -5.36328125
    ],
    [
      "rolling_max = [0] * len(numbers)\n    rolling_max[0] = numbers[0]\n    for i in range(1, len(numbers)):\n        rolling_max[i] = max(rolling_max[i - 1], numbers[i])\n    return rolling_max\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min = [0] * len(numbers)\n    rolling_min[0] = numbers[0]\n    for i in range(1, len(numbers)):\n        rolling_min[i] = min(rolling_min[i - 1], numbers[i])\n    return rolling_min\n\n\ndef max_subarray(sequence: List[int]) -> Tuple[int, int, int]:\n    \"\"\" Find a subarray with maximal sum in a given sequence of integers.\n    >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    (-5, 6, 16)\n    \"\"\"\n    rolling_max_sum = rolling_max([0] + sequence)\n    rolling_min_sum = rolling_min([0] + sequence)\n    max_sum = rolling_max_sum[-1]\n    min_sum = rolling_min_sum[-1]\n    max_sum_start = 0\n    max_sum_end = 0\n    for i in range(len(rolling_max_sum)):\n        if rolling_max_sum[i] == max_sum:\n            max_sum_end = i\n        if rolling_min_sum[i] == min_sum:\n            max_sum_start = i\n    return min_sum, max_sum_start, max_sum_end\n\n\nif __name__ == \"__main__\":\n    import do",
      -5.4375
    ],
    [
      "max_element = float('-inf')\n    rolling_max_list = []\n    for index, element in enumerate(numbers):\n        if element > max_element:\n            max_element = element\n        rolling_max_list.append(max_element)\n    return rolling_max_list\n\n\ndef count_pairs_larger_than_sum(numbers: List[int], target: int) -> int:\n    \"\"\" From a given list of integers, count how many pairs of numbers from the list sum to a value larger\n    than a given target.\n    >>> count_pairs_larger_than_sum([1, 2, 3, 2, 3, 4, 2], 5)\n    3\n    \"\"\"\n    rolling_max_list = rolling_max(numbers)\n    pairs_count = 0\n    for index, element in enumerate(rolling_max_list):\n        if element > target:\n            pairs_count += 1\n    return pairs_count\n\n\ndef generate_n_primes(n: int) -> List[int]:\n    \"\"\" From a given number n, generate a list of n prime numbers.\n    >>> generate_n_primes(5)\n    [2, 3, 5, 7, 11]\n    \"\"\"\n    primes = []\n    for number in range(2, 2 * n):\n        if all(number % i != 0 for i in range(2, number)):\n            primes.append(number)\n        if len(primes) == n:\n            break\n    return primes\n\n\ndef count_distinct_k_mers_with_mismatches(text: str, k: int, d: int) -> int:\n    \"\"\" From a given string and k and d, generate a list of k-mers with at most d mismatches.\n    >>> count_distinct_k_mers_with_mismatches('ACTG', 3, 1)\n    8\n    \"\"\"\n    text_list = list(text)\n    k_mer_list = []\n    for index, letter in enumerate(text_list):\n        for index2, letter2 in enumerate(text_list[index +",
      -5.98828125
    ],
    [
      "# We can assume that the rolling maximum is always at least as big as the first element in the list\n    rolling_max_list = [numbers[0]] * len(numbers)\n    for index in range(1, len(numbers)):\n        if numbers[index] > rolling_max_list[index - 1]:\n            rolling_max_list[index] = numbers[index]\n        else:\n            rolling_max_list[index] = rolling_max_list[index - 1]\n    return rolling_max_list\n\n\ndef max_sublist_sum(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Given a list of integers, generate the maximum sum of consecutive numbers in the sequence and a list of\n    indexes for the first and last element of the sublist with the maximum sum.\n    >>> max_sublist_sum([1, 2, 3, -2, 5, 7, 8, 9, -10, 1, 2, 3, 4])\n    (14, 3, 9)\n    \"\"\"\n    max_sum = 0\n    for index in range(0, len(numbers)):\n        max_sum += numbers[index]\n    max_sum_indexes = (0, len(numbers) - 1)\n\n    for index in range(1, len(numbers)):\n        current_sum = numbers[index - 1] + numbers[index]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_indexes = (index - 1, index)\n\n    for index in range(len(numbers) - 1, 0, -1):\n        current_sum = numbers[index - 1] + numbers[index]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_indexes = (index - 1, index)\n\n    return max_sum, max_sum_indexes[0], max_sum_indexes[1]\n\n\ndef max_sublist_sum_optimized(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\"",
      -6.0625
    ],
    [
      "rolling_max_result = []\n    for i in range(len(numbers)):\n        if i == 0:\n            rolling_max_result.append(numbers[0])\n        else:\n            rolling_max_result.append(max(numbers[i], rolling_max_result[i - 1]))\n    return rolling_max_result\n\n\ndef max_in_window(numbers: List[int], k: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of maximum element found in next k elements of a given list.\n    >>> max_in_window([1, 3, 2, 4, 2, 3, 1], 3)\n    [3, 3, 4, 4, 4, 3, 3]\n    \"\"\"\n    rolling_max_result = []\n    for i in range(len(numbers)):\n        if i < k:\n            rolling_max_result.append(max(numbers[0:i + 1]))\n        else:\n            rolling_max_result.append(max(numbers[i - k + 1:i + 1]))\n    return rolling_max_result\n\n\ndef max_sub_list_sum(numbers: List[int]) -> Tuple[int, int, int]:\n    \"\"\" From a given list of integers, generate a list of maximum element found in next k elements of a given list.\n    >>> max_sub_list_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    (-3, 3, 14)\n    \"\"\"\n    max_sum = 0\n    max_start = 0\n    max_end = 0\n    for i in range(len(numbers)):\n        max_sum += numbers[i]\n        if max_sum < 0:\n            max_sum = 0\n            max_start = i + 1\n        else:\n            max_end = i\n    return max_sum, max_start, max_end\n\n\nif __name__ == '__main__",
      -6.421875
    ],
    [
      "rolling_max = []\n    for i, num in enumerate(numbers):\n        if i == 0:\n            rolling_max.append(num)\n        else:\n            rolling_max.append(max(rolling_max[i - 1], num))\n\n    return rolling_max\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 1, 1, 2, 2, 2, 2]\n    \"\"\"\n    rolling_min = []\n    for i, num in enumerate(numbers):\n        if i == 0:\n            rolling_min.append(num)\n        else:\n            rolling_min.append(min(rolling_min[i - 1], num))\n\n    return rolling_min\n\n\ndef longest_increasing_subsequence(numbers: List[int]) -> Tuple[List[int], int]:\n    \"\"\" Given a list of integers, return a list of all elements of the longest increasing subsequence\n    in that list and the length of that subsequence.\n    >>> longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3])\n    ([3, 4, 6, 2, 3], 5)\n    >>> longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3, 1])\n    ([3, 4, 6, 2, 3, 1], 6)\n    \"\"\"\n    lis = []\n    length = 0\n    for i, num in enumerate(numbers):\n        if i == 0:\n            lis.append(num)\n        elif num > lis[-1]:\n            lis.append(num)\n            length += 1\n        else:\n            if length == 0:\n                lis.append(num)\n                length += 1\n            else:\n                for j, l",
      -6.7578125
    ],
    [
      "result = []\n    maximum = 0\n    for number in numbers:\n        maximum = max(number, maximum)\n        result.append(maximum)\n    return result\n\n\ndef max_rolling_window(numbers: List[int], k: int) -> List[int]:\n    \"\"\" Generate a list of maximum elements of rolling window of given size.\n    >>> max_rolling_window([1, 2, 3, 2, 3, 4, 2], 3)\n    [2, 3, 3, 4, 4, 4, 4]\n    \"\"\"\n    result = []\n    for i in range(len(numbers)):\n        result.append(max(numbers[i : i + k]))\n    return result\n\n\ndef max_subarray(numbers: List[int]) -> int:\n    \"\"\" Find the maximum subarray sum in a given list of integers.\n    >>> max_subarray([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    -3\n    \"\"\"\n    if len(numbers) == 0:\n        return 0\n    maximum = 0\n    current_sum = 0\n    for number in numbers:\n        current_sum = max(0, current_sum + number)\n        maximum = max(maximum, current_sum)\n    return maximum\n\n\ndef max_subarray_with_positions(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Find the maximum subarray sum and the position of the first and the last element of the subarray\n    in a given list of integers.\n    >>> max_subarray_with_positions([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])\n    (-3, 1, 6)\n    \"\"\"\n    if len(numbers) == 0:\n        return 0, 0, 0\n    maximum = 0\n    current_sum = 0",
      -6.89453125
    ],
    [
      "return list(map(max, zip(*(iter(numbers),) * 2)))\n\n\ndef max_sliding_window(sequence: List[int], window_size: int) -> List[int]:\n    \"\"\" From a given list of integers and window size, generate a list of maximum elements found in a sliding window\n    of the given sequence.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    rolling_max_numbers = rolling_max(sequence)\n    return rolling_max_numbers[:window_size - 1] + rolling_max_numbers[window_size:]\n\n\ndef max_sum_subsequence(sequence: List[int], window_size: int) -> Tuple[int, int, int]:\n    \"\"\" From a given list of integers and window size, generate a tuple of maximum sum found in a sliding window,\n    the index of the first number in the subsequence, and the index of the last number in the subsequence.\n    >>> max_sum_subsequence([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    (8, 1, 4)\n    \"\"\"\n    rolling_sums = [sum(sequence[:i]) for i in range(1, len(sequence) + 1)]\n    rolling_sums = rolling_sums[:window_size - 1] + rolling_sums[window_size:]\n    max_sum = max(rolling_sums)\n    max_sum_index = rolling_sums.index(max_sum) + 1\n    return max_sum, max_sum_index, max_sum_index + window_size - 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
      -8.0078125
    ],
    [
      "rolling_max_list = []\n    rolling_max_value = numbers[0]\n\n    for number in numbers:\n        if number > rolling_max_value:\n            rolling_max_value = number\n        rolling_max_list.append(rolling_max_value)\n\n    return rolling_max_list\n\n\ndef running_maximum(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> running_maximum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:index + 1]) for index in range(len(numbers))]\n\n\ndef running_maximum_efficient(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> running_maximum_efficient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:index + 1]) for index in range(len(numbers))]\n\n\ndef running_maximum_with_stack(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> running_maximum_with_stack([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_stack = []\n    rolling_max_list = []\n\n    for number in numbers:\n        if rolling_max_stack and rolling_max_stack[-1] < number:\n            rolling_max_stack.append(number)\n        else:\n            rolling_max_stack.clear()\n            rolling_max_stack.",
      -8.890625
    ],
    [
      "return [max(numbers[:index + 1]) for index in range(len(numbers))]\n\n\ndef rolling_max_with_stack(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_stack([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    stack = []\n    result = []\n\n    for index, number in enumerate(numbers):\n        while stack and number > stack[-1]:\n            stack.pop()\n        stack.append(number)\n        result.append(stack[-1])\n\n    return result\n\n\ndef max_sliding_window(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a window size, generate a list of maximum values found in the sliding window\n    of the given size.\n    >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"\n    max_numbers = []\n    window = numbers[:window_size]\n\n    for index in range(window_size, len(numbers)):\n        window.pop(0)\n        window.append(numbers[index])\n        max_numbers.append(max(window))\n\n    return max_numbers\n\n\ndef max_sliding_window_with_stack(numbers: List[int], window_size: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a window size, generate a list of maximum values found in the sliding window\n    of the given size.\n    >>> max_sliding_window_with_stack([1, 3, -1, -3, 5, 3, 6, 7], 3)\n    [3, 3, 5, 5, 6, 7]\n    \"\"\"",
      -8.953125
    ]
  ],
  "original_generation_params": {
    "num_candidates": 100,
    "num_seqs_per_iter": 50,
    "inference_batch_size": 256,
    "temperature": 0.6,
    "top_p": 0.95,
    "max_new_tokens": 512,
    "do_sample": true,
    "pad_token_id": null,
    "eos_token_id": null
  }
}