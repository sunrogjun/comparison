{
  "timestamp": "2025-09-14T16:17:24.799096",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "humaneval",
  "problem_number": 21,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "assert len(numbers) > 1\n    min_value = min(numbers)\n    max_value = max(numbers)\n    scaled_numbers = [n / max_value for n in numbers]\n    return scaled_numbers\n\n\ndef rescale_to_unit_with_one_number(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_one_number([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) > 1\n    min_value = min(numbers)\n    max_value = max(numbers)\n    scaled_numbers = [n / max_value for n in numbers]\n    return [n - min_value for n in scaled_numbers]\n\n\ndef rescale_to_unit_with_one_number_and_one_number(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_one_number_and_one_number([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) > 1\n    min_value = min(numbers)\n    max_value = max(numbers)\n    scaled_numbers = [n / max_value for n in numbers]\n    return [n - min_value for n in scaled_numbers]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    scale = max_number / (max_number - min_number)\n    return [n * scale for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    # Unit tests\n    assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert rescale_to_unit([0.0, 0.25, 0.5, 0.75, 1.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "if len(numbers) == 0:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Scale the numbers so that the smallest is 0 and the largest is 1\n    scaled_numbers = [x / max_value for x in numbers]\n\n    # Scale the numbers back to the original range\n    return [x * max_value for x in scaled_numbers]"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "if len(numbers) == 0:\n        return numbers\n    if len(numbers) == 1:\n        return [numbers[0], 1.0]\n    n = max(numbers)\n    m = min(numbers)\n    return [m, 1.0 / (m - m * n)] + rescale_to_unit(numbers[1:])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        raise ValueError('List must contain at least two elements.')\n    min_value = min(numbers)\n    max_value = max(numbers)\n    scale = 1.0 / (max_value - min_value)\n    return [scale * (x - min_value) for x in numbers]"
    },
    {
      "rank": 7,
      "score": 8.444444444444445,
      "candidate": "max_number = max(numbers)\n    min_number = min(numbers)\n    if min_number == max_number:\n        return [0.0] * len(numbers)\n    else:\n        return [float(x) / float(max_number - min_number) for x in numbers]"
    },
    {
      "rank": 8,
      "score": 8.444444444444445,
      "candidate": "# We have at least two numbers, so we can scale the list\n    scale = 1.0 / max(numbers)\n    return [scale * x for x in numbers]"
    },
    {
      "rank": 9,
      "score": 8.444444444444445,
      "candidate": "# First, find the maximum value\n    max_val = max(numbers)\n    # Then, find the minimum value\n    min_val = min(numbers)\n    # Then, calculate the scale factor\n    scale_factor = (max_val - min_val) / (len(numbers) - 1)\n    # Finally, apply the linear transform\n    return [x * scale_factor for x in numbers]"
    },
    {
      "rank": 10,
      "score": 8.444444444444445,
      "candidate": "return [x / max(numbers) for x in numbers]"
    },
    {
      "rank": 11,
      "score": 8.444444444444445,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    scale_factor = max_val / min_val\n    return [scale_factor * number for number in numbers]"
    },
    {
      "rank": 12,
      "score": 8.444444444444445,
      "candidate": "numbers = sorted(numbers)\n    # find the largest number\n    largest = numbers[-1]\n    # find the smallest number\n    smallest = numbers[0]\n    # find the difference between smallest and largest\n    diff = largest - smallest\n    # find the maximum difference between largest and smallest\n    max_diff = max(diff, 0.0)\n    # rescale the numbers\n    rescaled_numbers = [x / max_diff for x in numbers]\n    return rescaled_numbers"
    },
    {
      "rank": 13,
      "score": 8.444444444444445,
      "candidate": "min_number = numbers[0]\n    max_number = numbers[-1]\n    scale = 1.0 / (max_number - min_number)\n    return [min_number + (n - min_number) * scale for n in numbers]"
    },
    {
      "rank": 14,
      "score": 8.444444444444445,
      "candidate": "numbers = sorted(numbers)\n    rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / sum(numbers))\n    return rescaled_numbers"
    },
    {
      "rank": 15,
      "score": 8.444444444444445,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled = []\n    for n in numbers:\n        rescaled.append((n - min_val) / (max_val - min_val))\n    return rescaled\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 8.444444444444445,
      "candidate": "# make sure numbers are sorted\n    numbers.sort()\n    # find the smallest and largest number\n    min_val = numbers[0]\n    max_val = numbers[-1]\n    # rescale to [0,1]\n    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - min_val) / (max_val - min_val)\n    return numbers"
    },
    {
      "rank": 17,
      "score": 8.444444444444445,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 8.444444444444445,
      "candidate": "assert len(numbers) >= 2, \"List must have at least two elements\"\n    return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()"
    },
    {
      "rank": 19,
      "score": 8.444444444444445,
      "candidate": "if len(numbers) < 2:\n        raise ValueError('List must have at least two elements')\n    return [x / max(numbers) for x in numbers]"
    },
    {
      "rank": 20,
      "score": 8.444444444444445,
      "candidate": "# Make sure numbers are floats, and have at least two elements\n    if not all(isinstance(x, float) for x in numbers):\n        raise TypeError('Numbers must be of type float.')\n    if len(numbers) < 2:\n        raise ValueError('Numbers must have at least two elements.')\n\n    # Calculate the min and max of the numbers\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    # Scale the numbers to be between 0 and 1\n    numbers_scaled = [(x - min_number) / (max_number - min_number) for x in numbers]\n\n    return numbers_scaled"
    },
    {
      "rank": 21,
      "score": 8.444444444444445,
      "candidate": "return [x / max(numbers) for x in numbers]"
    },
    {
      "rank": 22,
      "score": 8.444444444444445,
      "candidate": "return [x / max(numbers) for x in numbers]"
    },
    {
      "rank": 23,
      "score": 8.444444444444445,
      "candidate": "max_number = max(numbers)\n    min_number = min(numbers)\n    scale_factor = 1.0 / (max_number - min_number)\n    return [scale_factor * i for i in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 3.926139092254469,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [n / max_number for n in numbers]\n\n\ndef rescale_to_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [n / min_number for n in numbers]\n\n\ndef rescale_to_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [n / max_number for n in numbers]"
    },
    {
      "rank": 25,
      "score": 3.7896064077536957,
      "candidate": "assert len(numbers) >= 2, \"List must contain at least two numbers\"\n    rescaled = []\n    rescaled.append(0.0)\n    for number in numbers:\n        rescaled.append(rescaled[-1] + (number - numbers[-1]) / (numbers[-1] - numbers[-2]))\n    return rescaled\n\n\ndef rescale_to_unit_list(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"List must contain at least two numbers\"\n    rescaled = []\n    rescaled.append(0.0)\n    for number in numbers:\n        rescaled.append(rescaled[-1] + (number - numbers[-1]) / (numbers[-1] - numbers[-2]))\n    return rescaled\n\n\ndef rescale_to_unit_list_and_rearrange(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list_and_rearrange([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"List must contain at least two numbers\"\n    rescaled = []\n    rescaled.append(0.0)\n    for number in numbers:\n        rescaled.append(rescaled[-1] + (number - numbers[-1]) / (numbers[-1] - numbers["
    },
    {
      "rank": 26,
      "score": 3.782321827907003,
      "candidate": "return [float(x) / max(numbers) for x in numbers]\n\n\ndef rescale_to_range(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [float(x) / (max_value - min_value) + min_value for x in numbers]\n\n\ndef rescale_to_range_and_unit(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_range_and_unit([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [float(x) / (max_value - min_value) + min_value / max(numbers) for x in numbers]"
    },
    {
      "rank": 27,
      "score": 3.7690182832329846,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_and_clip(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_clip([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [x / sum(numbers) for x in numbers if x >= 0 and x <= 1]\n\n\ndef rescale_to_unit_and_clip_and_round(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_clip_and_round([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [round(x / sum(numbers), 2) for x in numbers if x >= 0 and x <= 1]"
    },
    {
      "rank": 28,
      "score": 3.761514928204013,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [min_value / max_value] + [n / max_value for n in numbers]\n\n\ndef rescale_to_range(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers, apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 5.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n * (max_value - min_value) + min_value for n in numbers]\n\n\ndef rescale_to_unit_and_range(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the range will become [0, 1]\n    >>> rescale_to_unit_and_range([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return rescale_to_unit(rescale_to_range(numbers, 0.0, 1.0))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 3.732824384460777,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers[:] = rescale_to_unit(numbers)\n    return numbers"
    },
    {
      "rank": 30,
      "score": 3.6781200142854114,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_with_zero_as_middle(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1,\n    but the middle number will remain the same\n    >>> rescale_to_unit_with_zero_as_middle([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\nif __name__ == '__main__':\n    numbers = [0.1, 0.2, 0.3, 0.4, 0.5]\n    print(rescale_to_unit(numbers))\n    print(rescale_to_unit_with_zero_as_middle(numbers))"
    },
    {
      "rank": 31,
      "score": 3.5285611131094576,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_from_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [x * max(numbers) for x in numbers]\n\n\ndef rescale_from_unit_and_clip(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_unit_and_clip([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [min(max(x, 0.0), 1.0) for x in numbers]"
    },
    {
      "rank": 32,
      "score": 3.5154997612479755,
      "candidate": "assert len(numbers) >= 2\n    scalar = numbers[0]\n    for n in numbers:\n        if n < 0:\n            raise ValueError('negative numbers are not allowed')\n        scalar = min(scalar, n)\n    return [scalar] + list(numbers[1:])\n\n\ndef rescale_to_unit_numpy(numbers: List[float]) -> np.ndarray:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_numpy([1.0, 2.0, 3.0, 4.0, 5.0])\n    array([ 0.,  0.25,  0.5,  0.75,  1. ])\n    \"\"\"\n    assert len(numbers) >= 2\n    scalar = numbers[0]\n    for n in numbers:\n        if n < 0:\n            raise ValueError('negative numbers are not allowed')\n        scalar = min(scalar, n)\n    return np.array([scalar] + list(numbers[1:]))"
    },
    {
      "rank": 33,
      "score": 3.501766448946012,
      "candidate": "return [n / max(numbers) for n in numbers]\n\n\ndef rescale_from_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [n * max(numbers) for n in numbers]"
    },
    {
      "rank": 34,
      "score": 3.4877725635611796,
      "candidate": "return [min(numbers) / max(numbers), max(numbers) / min(numbers)]\n\n\ndef rescale_to_unit_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [min(numbers), max(numbers)]\n\n\ndef rescale_to_unit_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [max(numbers), min(numbers)]\n\n\ndef rescale_to_unit_max_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [max(numbers), min(numbers)]\n\n\ndef rescale_to_unit_max_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max_min_max"
    },
    {
      "rank": 35,
      "score": 3.4656400595580994,
      "candidate": "return [x * 1.0 / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> print(numbers)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x * 1.0 / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_fast(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_fast([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x * 1.0 / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_fast_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_fast_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> print(numbers)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x * 1.0 / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_fast_inplace_and_print(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,"
    },
    {
      "rank": 36,
      "score": 3.4112724560515946,
      "candidate": "assert len(numbers) >= 2, \"Need at least two numbers to rescale\"\n    # find max number\n    max_number = numbers[-1]\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n    # rescale the numbers\n    new_numbers = []\n    for number in numbers:\n        new_numbers.append(number * (1.0 / max_number))\n    return new_numbers\n\n\ndef rescale_to_unit_and_mean(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the mean will be the average of the numbers\n    >>> rescale_to_unit_and_mean([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"Need at least two numbers to rescale\"\n    # find max number\n    max_number = numbers[-1]\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n    # rescale the numbers\n    new_numbers = []\n    for number in numbers:\n        new_numbers.append(number * (1.0 / max_number))\n    # find mean\n    mean = sum(new_numbers) / len(new_numbers)\n    return new_numbers, mean\n\n\ndef rescale_to_unit_and_mean_and_median(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the mean will be the average of the numbers\n    and the median will be the median of the numbers\n    >>> rescale_to_unit_and_mean_and_median([1.0, 2.0, 3.0, 4.0, 5.0"
    },
    {
      "rank": 37,
      "score": 3.410951252187612,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_normalized(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x * max(numbers) for x in numbers]\n\n\ndef rescale_to_standard(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\ndef normalize_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\ndef normalize_to_normalized(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0."
    },
    {
      "rank": 38,
      "score": 3.406262911197099,
      "candidate": "if len(numbers) == 0:\n        return numbers\n\n    lowest = numbers[0]\n    highest = numbers[0]\n    for n in numbers[1:]:\n        if n < lowest:\n            lowest = n\n        elif n > highest:\n            highest = n\n\n    scale = highest - lowest\n    if scale == 0:\n        return numbers\n\n    for n in numbers:\n        n = (n - lowest) / scale\n        n = max(0.0, min(1.0, n))\n        numbers.append(n)\n\n    return numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 3.3837173645764542,
      "candidate": "min_n = min(numbers)\n    max_n = max(numbers)\n    scaler = (max_n - min_n) / (max_n + min_n)\n    return [n * scaler for n in numbers]\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scaled_numbers = rescale_to_unit(numbers)\n    return [n / sum(scaled_numbers) for n in scaled_numbers]\n\n\ndef rescale_to_unit_and_normalize_to_sum(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize_to_sum([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scaled_numbers = rescale_to_unit(numbers)\n    return [n / sum(scaled_numbers) for n in scaled_numbers]"
    },
    {
      "rank": 40,
      "score": 3.3692332899977053,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_and_zero(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_zero([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers] + [0.0]\n\n\ndef rescale_to_unit_and_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_one([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers] + [1.0]\n\n\ndef rescale_to_unit_and_zero_and_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_zero_and_one([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers] + [0.0, 1.0]\n\n\ndef rescale_to_unit_and_zero_and_one_with_zero_fraction(numbers: List[float"
    },
    {
      "rank": 41,
      "score": 3.3238442690503462,
      "candidate": "scaled = [float(n) / n for n in numbers]\n    return [n * (1.0 / max(scaled)) for n in scaled]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scaled = [float(n) / n for n in numbers]\n    return [n * (1.0 / max(scaled)) for n in scaled]\n\n\ndef rescale_to_unit_inplace_if_smaller(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_if_smaller([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scaled = [float(n) / n for n in numbers]\n    return [n * (1.0 / max(scaled)) for n in scaled]\n\n\ndef rescale_to_unit_if_smaller(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_if_smaller([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scaled = [float(n) / n for n in numbers]"
    },
    {
      "rank": 42,
      "score": 3.305838144420434,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    scale = 1.0 / (max_number - min_number)\n    return [x * scale for x in numbers]\n\n\ndef rescale_to_linear(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_linear([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scale = 1.0 / (max_number - min_number)\n    return [x * scale for x in numbers]\n\n\ndef rescale_to_log(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a log transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_log([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.1, 0.2, 0.3, 0.4]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scale = min_number\n    for x in numbers:\n        if x > scale:\n            scale = x\n    return [scale * x for x in numbers]\n\n\ndef rescale_to_power(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a power transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_power([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min"
    },
    {
      "rank": 43,
      "score": 3.2712800217929825,
      "candidate": "assert len(numbers) >= 2, \"must have at least two numbers\"\n    smallest = min(numbers)\n    largest = max(numbers)\n    scale = (largest - smallest) / (numbers[-1] - smallest)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_and_reverse(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_reverse([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 0.5, 0.25, 0.125, 0.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"must have at least two numbers\"\n    smallest = min(numbers)\n    largest = max(numbers)\n    scale = (largest - smallest) / (numbers[-1] - smallest)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_and_reverse_and_round(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_reverse_and_round([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 0.5, 0.25, 0.125, 0.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"must have at least two numbers\"\n    smallest = min(numbers)\n    largest = max(numbers)\n    scale = (largest - smallest) / (numbers[-1] - smallest)\n    return [round(n * scale, 2) for n in numbers]\n\n\ndef rescale_to_unit_and_reverse_and_round_and_scale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers ("
    },
    {
      "rank": 44,
      "score": 3.2483570765056164,
      "candidate": "result = []\n    for n in numbers:\n        result.append(n / max(numbers))\n    return result\n\n\ndef rescale_to_unity(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unity([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    result = []\n    for n in numbers:\n        result.append(n * (1.0 / max(numbers)))\n    return result\n\n\ndef rescale_to_quantized(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_quantized([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.125, 0.25, 0.375, 0.5]\n    \"\"\"\n    result = []\n    for n in numbers:\n        result.append(n * (1.0 / max(numbers)))\n    return result\n\n\ndef rescale_to_percentile(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_percentile([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.125, 0.25, 0.375, 0.5]\n    \"\"\"\n    result = []\n    for n in numbers:\n        result.append(n * (1.0 / max(numbers)))\n    return result\n\n\ndef rescale_to_percentile_and_quantize(numbers: List[float]) -> List[float]:"
    },
    {
      "rank": 45,
      "score": 3.1878490091728358,
      "candidate": "return [x/max(numbers) for x in numbers]\n\n\ndef rescale_to_minmax(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_minmax([1.0, 2.0, 3.0, 4.0, 5.0])\n    (0.0, 1.0)\n    \"\"\"\n    return min(numbers), max(numbers)\n\n\ndef rescale_to_minmax_unit(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_minmax_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    (0.0, 1.0)\n    \"\"\"\n    return min(numbers), max(numbers) / max(numbers)\n\n\ndef rescale_to_minmax_unit_with_zeros(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_minmax_unit_with_zeros([1.0, 2.0, 3.0, 4.0, 5.0])\n    (0.0, 1.0)\n    \"\"\"\n    return min(numbers), max(numbers) / max(numbers)\n\n\ndef rescale_to_unit_with_zeros(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_zeros([1.0, 2.0, 3.0, 4.0, 5.0])"
    },
    {
      "rank": 46,
      "score": 3.180818012523817,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to unit if at least two numbers are provided\")\n    scale = 1.0 / (max(numbers) - min(numbers))\n    return [x * scale for x in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to unit if at least two numbers are provided\")\n    scale = 1.0 / (max(numbers) - min(numbers))\n    numbers[:] = [x * scale for x in numbers]\n\n\ndef rescale_to_unit_inplace_list(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to unit if at least two numbers are provided\")\n    scale = 1.0 / (max(numbers) - min(numbers))\n    numbers[:] = [x * scale for x in numbers]\n\n\ndef rescale_to_unit_inplace_list_2d(numbers: List[List[float]]) -> None:\n    \"\"\" Given list of lists of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1"
    },
    {
      "rank": 47,
      "score": 3.180697802754207,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [min_val / max_val if min_val!= 0.0 else 0.0,\n            max_val / min_val if max_val!= 1.0 else 1.0]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    numbers[:] = [min_val / max_val if min_val!= 0.0 else 0.0,\n                  max_val / min_val if max_val!= 1.0 else 1.0]"
    },
    {
      "rank": 48,
      "score": 3.1718091447842305,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"You need at least two numbers to rescale\")\n    return [x / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_range(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes the range\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"You need at least two numbers to rescale\")\n    return [x * (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_unit_with_range(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_unit_with_range([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"You need at least two numbers to rescale\")\n    return [x / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_range_with_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes the range\n    >>> rescale_to_range_with_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n    \"\"\"\n    if"
    },
    {
      "rank": 49,
      "score": 3.165631715701782,
      "candidate": "assert len(numbers) >= 2, \"Expected at least two numbers\"\n    max_val = numbers[-1]\n    min_val = numbers[0]\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / max_val\n        if numbers[i] < 0:\n            numbers[i] = 0\n        elif numbers[i] > 1:\n            numbers[i] = 1\n    return numbers\n\n\ndef rescale_to_unit_norm(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_norm([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"Expected at least two numbers\"\n    max_val = numbers[-1]\n    min_val = numbers[0]\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / max_val\n        if numbers[i] < 0:\n            numbers[i] = 0\n        elif numbers[i] > 1:\n            numbers[i] = 1\n    return numbers\n\n\ndef rescale_to_unit_norm_abs(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_norm_abs([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"Expected at least two numbers\"\n    max_val = numbers[-1]\n    min_val = numbers[0]\n    for i in"
    },
    {
      "rank": 50,
      "score": 3.1620419846973977,
      "candidate": "return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and then normalize it to sum to 1.0\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_normalize_to_zero_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and then normalize it to sum to 1.0\n    >>> rescale_to_unit_and_normalize_to_zero_one([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_normalize_to_zero_one_and_normalize_to_zero_one(\n    numbers: List[float]\n) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and then normalize it to sum to 1.0\n    >>> rescale_to_unit_and_normalize_to_zero_one_and_normalize_to_zero_one(\n    [1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1."
    },
    {
      "rank": 51,
      "score": 3.157123666297637,
      "candidate": "return [x/sum(numbers) for x in numbers]\n\n\ndef rescale_to_max_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_max_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x/max(numbers) for x in numbers]\n\n\ndef rescale_to_min_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_min_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x/min(numbers) for x in numbers]\n\n\ndef rescale_to_max_min_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_max_min_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x/max(numbers) for x in numbers] + [x/min(numbers) for x in numbers]\n\n\ndef rescale_to_max_min_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale"
    },
    {
      "rank": 52,
      "score": 3.1209811357830173,
      "candidate": "return [1 - (n / max(numbers)) for n in numbers]\n\n\ndef rescale_to_logspace(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_logspace([1.0, 2.0, 3.0, 4.0, 5.0], 1, 5)\n    [0.25, 0.5, 0.75, 1.0, 1.25]\n    \"\"\"\n    return [min_value + (max_value - min_value) * n / (numbers[-1] - numbers[0]) for n in numbers]"
    },
    {
      "rank": 53,
      "score": 3.104431797502378,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    min_number = numbers[0]\n    max_number = numbers[0]\n    for number in numbers[1:]:\n        if min_number > number:\n            min_number = number\n        if max_number < number:\n            max_number = number\n    return [min_number / max_number, 1.0 / max_number]\n\n\ndef rescale_to_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    min_number = numbers[0]\n    max_number = numbers[0]\n    for number in numbers[1:]:\n        if min_number > number:\n            min_number = number\n        if max_number < number:\n            max_number = number\n    return [min_number, 1.0 / max_number]\n\n\ndef rescale_to_scale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_scale([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    min_number = numbers[0]\n    max_number = numbers[0]\n    for number in numbers[1:]:\n        if min_number > number:\n            min_number"
    },
    {
      "rank": 54,
      "score": 3.0984306179345618,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_round(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the numbers will be rounded to the nearest integer\n    >>> rescale_to_unit_and_round([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [round(n / max(numbers), 0) for n in numbers]\n\n\ndef rescale_to_unit_and_round_and_clip(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the numbers will be rounded to the nearest integer\n    and the numbers will be clamped to the range [0.0, 1.0]\n    >>> rescale_to_unit_and_round_and_clip([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [min(max(0.0, n), 1.0) for n in numbers]"
    },
    {
      "rank": 55,
      "score": 3.085684140594985,
      "candidate": "if len(numbers) < 2:\n        raise ValueError('List must contain at least two elements')\n\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_log(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_log([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('List must contain at least two elements')\n\n    return [math.log(x + 1) for x in numbers]\n\n\ndef rescale_to_unit_pow(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_pow([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('List must contain at least two elements')\n\n    return [x ** (1 / len(numbers)) for x in numbers]\n\n\ndef rescale_to_unit_sqrt(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_sqrt([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('List must contain at least"
    },
    {
      "rank": 56,
      "score": 3.055461294854933,
      "candidate": "scale = max(numbers) - min(numbers)\n    return [scale * (x - min(numbers)) / scale for x in numbers]\n\n\ndef rescale_from_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    scale = 1.0 / max(numbers) - 1.0 / min(numbers)\n    return [scale * (x - min(numbers)) for x in numbers]"
    },
    {
      "rank": 57,
      "score": 3.043523534119086,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Can't rescale_to_unit a list of length < 2\")\n\n    min_num = numbers[0]\n    max_num = numbers[-1]\n\n    if min_num == max_num:\n        return numbers\n\n    # Compute the scaling factor between the smallest and largest value\n    scale = 1.0 / (max_num - min_num)\n\n    # Scale the list\n    numbers = [number * scale for number in numbers]\n\n    return numbers\n\n\ndef rescale_to_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers, apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can't rescale_to_max a list of length < 2\")\n\n    # Compute the scaling factor between the smallest and largest value\n    scale = 1.0 / (numbers[-1] - numbers[0])\n\n    # Scale the list\n    numbers = [number * scale for number in numbers]\n\n    return numbers\n\n\ndef rescale_to_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers, apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can't rescale_to_min a list of length < 2\")\n\n    # Compute the scaling factor between the smallest and largest value\n    scale = 1.0 / (numbers[0] - numbers[-1])\n\n    # Scale the list\n    numbers = [number * scale for number in"
    },
    {
      "rank": 58,
      "score": 3.033764102343962,
      "candidate": "# TODO: add in the possibility of having more than one element in the input list\n    if len(numbers) <= 1:\n        return numbers\n    return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_vector(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_vector([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # TODO: add in the possibility of having more than one element in the input list\n    if len(numbers) <= 1:\n        return numbers\n    return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_vector_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_vector_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # TODO: add in the possibility of having more than one element in the input list\n    if len(numbers) <= 1:\n        return numbers\n    return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25"
    },
    {
      "rank": 59,
      "score": 2.993251387631033,
      "candidate": "return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_3(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_3([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_4(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_4([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 2.982086980445024,
      "candidate": "numbers = [float(num) for num in numbers]\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return [0.0, max_number]\n    else:\n        return [min_number, max_number]\n\n\ndef rescale_to_unit_no_nan(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_no_nan([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers = [float(num) for num in numbers]\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return [0.0, max_number]\n    else:\n        return [min_number, max_number]\n\n\ndef rescale_to_unit_no_nan_no_nan(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_no_nan_no_nan([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers = [float(num) for num in numbers]\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return [0.0, max_number]\n    else:\n        return [min_number, max_number]\n\n\ndef rescale_to_unit_no_nan_no_nan_no_nan(numbers: List[float])"
    },
    {
      "rank": 61,
      "score": 2.963994939209833,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    unit = max_number - min_number\n    rescaled = [min_number + (x - min_number) / unit for x in numbers]\n    return rescaled\n\ndef rescale_to_unit_with_offset(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_offset([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    unit = max_number - min_number\n    rescaled = [min_number + (x - min_number) / unit for x in numbers]\n    return rescaled"
    },
    {
      "rank": 62,
      "score": 2.94217585880588,
      "candidate": "return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_max_length(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max_length([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_max_length_with_zero_padding(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max_length_with_zero_padding([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0]\n    \"\"\"\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_max_length_with_zero_padding_and_max_length(numbers: List[float], max_length: int) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_max_length_with_zero_padding_and_max_length([1.0, 2.0, 3.0, 4.0, 5.0], 3)\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0, 0.0, 0.0]\n    \"\"\"\n    return [x / sum(numbers) for x in numbers]"
    },
    {
      "rank": 63,
      "score": 2.930867849414408,
      "candidate": "return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_range(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_range([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (sum(numbers) - 1) for n in numbers]\n\n\ndef rescale_to_unit_range_and_average(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_range_and_average([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (sum(numbers) - 1) for n in numbers] + [n / sum(numbers) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 64,
      "score": 2.9071705116680913,
      "candidate": "if len(numbers) < 2:\n        raise ValueError('list must have at least two elements')\n    return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('list must have at least two elements')\n    max_numbers = max(numbers)\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / max_numbers\n\n\ndef rescale_to_unit_inplace_and_return(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_and_return([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('list must have at least two elements')\n    max_numbers = max(numbers)\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / max_numbers\n    return numbers\n\n\ndef rescale_to_unit_inplace_and_return_new(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_in"
    },
    {
      "rank": 65,
      "score": 2.887111849756732,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    scaled_numbers = [n / max_value for n in numbers]\n    return scaled_numbers\n\n\ndef rescale_to_unit_sorted(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_sorted([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    scaled_numbers = [n / max_value for n in numbers]\n    return sorted(scaled_numbers)\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return\n    scaled_numbers = [n / max_value for n in numbers]\n    numbers[:] = scaled_numbers"
    },
    {
      "rank": 66,
      "score": 2.8829315215254097,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Need at least two numbers to rescale\")\n    smallest = numbers[0]\n    largest = numbers[0]\n    for n in numbers:\n        if n < smallest:\n            smallest = n\n        if n > largest:\n            largest = n\n    return [n / largest for n in numbers]\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_and_normalize([0.1, 0.2, 0.3, 0.4, 0.5])\n    [0.1, 0.2, 0.3, 0.4, 0.5]\n    \"\"\"\n    return rescale_to_unit(numbers)\n\n\ndef rescale_to_unit_and_normalize_and_scale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize_and_scale([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_and_normalize_and_scale([0.1, 0.2, 0.3, 0.4, 0.5])\n    [0.1, 0.2, 0.3, 0.4, 0.5]\n    \"\"\"\n    return rescale_to_unit_and_normalize(numbers)\n\n\ndef rescale_to_unit_and_scale(n"
    },
    {
      "rank": 67,
      "score": 2.882923312638332,
      "candidate": "return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_list(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / sum(numbers) for n in numbers]\n\n\ndef rescale_to_unit_vector(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_vector([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / sum(numbers) for n in numbers]"
    },
    {
      "rank": 68,
      "score": 2.8541531251033616,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n\n    return [n / max_num for n in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    for i, number in enumerate(numbers):\n        numbers[i] = number / max_num\n\n\ndef rescale_to_unit_inplace_v2(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_v2([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    for i, number in enumerate(numbers):\n        numbers[i] = number / max_num"
    },
    {
      "rank": 69,
      "score": 2.8494481522053556,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Expected at least two numbers, got {}\".format(len(numbers)))\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_bounds(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_bounds([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Expected at least two numbers, got {}\".format(len(numbers)))\n    return [x * (1.0 / sum(numbers)) for x in numbers]"
    },
    {
      "rank": 70,
      "score": 2.8453938120743927,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Need at least two elements to rescale\")\n    min_value = numbers[0]\n    max_value = numbers[0]\n    for n in numbers:\n        if n < min_value:\n            min_value = n\n        elif n > max_value:\n            max_value = n\n    scale = 1.0 / (max_value - min_value)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_and_scale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_scale([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Need at least two elements to rescale\")\n    min_value = numbers[0]\n    max_value = numbers[0]\n    for n in numbers:\n        if n < min_value:\n            min_value = n\n        elif n > max_value:\n            max_value = n\n    scale = 1.0 / (max_value - min_value)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_and_scale_and_clip(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_scale_and_clip([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Need at least two elements to rescale\")"
    },
    {
      "rank": 71,
      "score": 2.8074588597918417,
      "candidate": "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number * (1.0 / max(numbers)))\n    return rescaled_numbers\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    rescaled_numbers = numbers[:]\n    for number in numbers:\n        rescaled_numbers[-1] = number * (1.0 / max(numbers))\n    rescaled_numbers[-1] = 1.0\n    return rescaled_numbers\n\n\ndef rescale_to_unit_and_center(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_center([1.0, 2.0, 3.0, 4.0, 5.0])\n    [-0.25, 0.5, 0.75, 1.0, 1.0]\n    \"\"\"\n    rescaled_numbers = rescale_to_unit(numbers)\n    rescaled_numbers[0] = 0.0\n    rescaled_numbers[-1] = 1.0\n    return rescaled_numbers\n\n\ndef rescale_to_unit_and_center_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_center_inplace([1.0, 2.0, 3.0,"
    },
    {
      "rank": 72,
      "score": 2.769680614520106,
      "candidate": "assert len(numbers) >= 2, \"list must have at least 2 elements\"\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_from_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 1 and the largest will become 0\n    >>> rescale_from_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"list must have at least 2 elements\"\n    return [x * sum(numbers) for x in numbers]\n\n\ndef rescale_to_normal(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_normal([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"list must have at least 2 elements\"\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_from_normal(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 1 and the largest becomes 0\n    >>> rescale_from_normal([0.0, 0.5, 1.0, 1.5, 2.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"list must have at least 2 elements\"\n    return [x * sum(numbers) for x in numbers]\n\n\ndef rescale_to_normal_and_unit(numbers: List[float]) -> List[float"
    },
    {
      "rank": 73,
      "score": 2.768291153593769,
      "candidate": "assert len(numbers) >= 2, \"Rescale needs at least two numbers\"\n    n = numbers[-1]\n    for i in range(len(numbers) - 1):\n        numbers[i] /= n\n        n *= numbers[i]\n    return numbers\n\n\ndef rescale_to_unit_with_zeros(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_zeros([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"Rescale needs at least two numbers\"\n    n = numbers[-1]\n    for i in range(len(numbers) - 1):\n        numbers[i] /= n\n        n *= numbers[i]\n        if numbers[i] == 0:\n            numbers[i] = 0.0\n    return numbers\n\n\ndef rescale_to_unit_with_zeros_and_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_zeros_and_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0, 0.0]\n    \"\"\"\n    assert len(numbers) >= 2, \"Rescale needs at least two numbers\"\n    n = numbers[-1]\n    for i in range(len(numbers) - 1):\n        numbers[i] /= n\n        n *= numbers[i]\n        if numbers[i] == 0:\n            numbers[i] = 0.0\n            n"
    },
    {
      "rank": 74,
      "score": 2.7671351232148718,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    scale = 1.0 / (max_num - min_num)\n    return [min_num + (n - min_num) * scale for n in numbers]\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n    scale = 1.0 / (max_num - min_num)\n    return [min_num + (n - min_num) * scale for n in numbers]\n\n\ndef rescale_to_unit_3(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_3([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n    scale = 1.0 / (max_num - min_num)\n    return [min_num + (n - min_num) * scale for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 2.765262807032524,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    rescaled = [x / max_value for x in numbers]\n    rescaled = [0 if x == 0 else 1 for x in rescaled]\n    return rescaled\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    rescaled = [x / max_value for x in numbers]\n    rescaled = [0 if x == 0 else 1 for x in rescaled]\n    numbers[:] = rescaled"
    },
    {
      "rank": 76,
      "score": 2.760412881077355,
      "candidate": "numbers = sorted(numbers)\n    return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_percentage(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 100\n    >>> rescale_to_percentage([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.01, 0.05, 0.10, 0.20]\n    \"\"\"\n    numbers = sorted(numbers)\n    return [n * 100.0 / max(numbers) for n in numbers]\n\n\ndef rescale_to_percentage_with_zero(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 100\n    >>> rescale_to_percentage_with_zero([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.01, 0.05, 0.10, 0.20]\n    \"\"\"\n    numbers = sorted(numbers)\n    return [n * 100.0 / max(numbers) for n in numbers]\n\n\ndef rescale_to_percentage_with_zero_and_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 100\n    >>> rescale_to_percentage_with_zero_and_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.01, 0.05, 0.10, 0.20]\n    \"\"\"\n    numbers = sorted(numbers)\n    return [n * 100.0 / max(numbers) for n in numbers]\n\n\ndef rescale_to_percentage_with_zero_and_unit_"
    },
    {
      "rank": 77,
      "score": 2.7278086377374087,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Must have at least two elements\")\n    min_ = min(numbers)\n    max_ = max(numbers)\n    if max_ - min_ == 0.0:\n        return numbers\n    return [x / max_ for x in numbers]\n\n\ndef rescale_to_standard(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_standard([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Must have at least two elements\")\n    min_ = min(numbers)\n    max_ = max(numbers)\n    if max_ - min_ == 0.0:\n        return numbers\n    return [x / (max_ - min_) for x in numbers]\n\n\ndef rescale_to_scale(numbers: List[float], scale: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_to_scale([1.0, 2.0, 3.0, 4.0, 5.0], 2.0)\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Must have at least two elements\")\n    min_ = min(numbers)\n    max_ = max(numbers)\n    if max_ - min_ == 0.0:\n        return numbers\n    return [x / scale for x in numbers]\n\n\ndef rescale_to_unit_and_scale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such"
    },
    {
      "rank": 78,
      "score": 2.718856235379514,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to unit values if there are at least two numbers\")\n    min_n = numbers[0]\n    max_n = numbers[-1]\n    max_n -= min_n\n    for n in numbers:\n        n -= min_n\n        n /= max_n\n    return numbers\n\n\ndef rescale_to_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 1 and the largest becomes the max of the list\n    >>> rescale_to_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to max values if there are at least two numbers\")\n    max_n = numbers[-1]\n    for n in numbers:\n        n /= max_n\n    return numbers\n\n\ndef rescale_to_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes the min of the list\n    >>> rescale_to_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.0, 0.0, 0.0, 0.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Can only rescale to min values if there are at least two numbers\")\n    min_n = numbers[0]\n    for n in numbers:\n        n *= min_n\n    return numbers\n\n\ndef rescale_to_zero_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number becomes 0 and the largest becomes 1\n    >>> rescale_"
    },
    {
      "rank": 79,
      "score": 2.6996806550405976,
      "candidate": "assert len(numbers) > 1, 'At least two numbers must be provided'\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return numbers\n    scale = (max_number - min_number) / (max_number + min_number)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    \"\"\"\n    assert len(numbers) > 1, 'At least two numbers must be provided'\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return\n    scale = (max_number - min_number) / (max_number + min_number)\n    numbers[:] = [n * scale for n in numbers]\n\n\ndef rescale_to_unit_inplace_and_print(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_and_print([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    \"\"\"\n    assert len(numbers) > 1, 'At least two numbers must be provided'\n    min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return\n    scale = ("
    },
    {
      "rank": 80,
      "score": 2.6991466938853015,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_with_min_max(numbers: List[float], min: float = 0, max: float = 1) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min and the largest will become max\n    >>> rescale_to_unit_with_min_max([1.0, 2.0, 3.0, 4.0, 5.0], 1, 5)\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [x * (max - min) + min for x in numbers]\n\n\ndef rescale_to_unit_with_min_max_and_zero_to_one(numbers: List[float], min: float = 0, max: float = 1, zero: float = 0, one: float = 1) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min and the largest will become max,\n    and the zero to one mapping will be applied\n    >>> rescale_to_unit_with_min_max_and_zero_to_one([1.0, 2.0, 3.0, 4.0, 5.0], 1, 5, 0, 1)\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [x * (max - min) + min for x in numbers] + [zero, one]"
    },
    {
      "rank": 81,
      "score": 2.677440122697438,
      "candidate": "scale = 1.0 / max(numbers)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_list(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scale = 1.0 / max(numbers)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_list_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scale = 1.0 / max(numbers)\n    return [n * scale for n in numbers]\n\n\ndef rescale_to_unit_list_3(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list_3([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    scale = 1.0 / max(numbers)\n    return [n * scale for n in numbers]"
    },
    {
      "rank": 82,
      "score": 2.6615389998470205,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    scaled_numbers = [min_number / max_number]\n    for i in range(len(numbers) - 1):\n        scaled_numbers.append(scaled_numbers[-1] * (numbers[i + 1] / max_number))\n    return scaled_numbers\n\n\ndef rescale_to_unit_and_round(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_round([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scaled_numbers = [min_number / max_number]\n    for i in range(len(numbers) - 1):\n        scaled_numbers.append(scaled_numbers[-1] * (numbers[i + 1] / max_number))\n    return [round(x, 4) for x in scaled_numbers]\n\n\ndef rescale_to_unit_and_round_with_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_round_with_min_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scaled_numbers = [min_number / max_number]\n    for i in range(len(numbers) - 1):"
    },
    {
      "rank": 83,
      "score": 2.6400778958026456,
      "candidate": "if len(numbers) < 2:\n        raise ValueError('Not enough numbers to rescale')\n    min_number = numbers[0]\n    max_number = numbers[-1]\n    if min_number > 0:\n        min_number = 0\n    elif max_number < 1:\n        max_number = 1\n    return [min_number + (max_number - min_number) * i / (len(numbers) - 1) for i in range(len(numbers) - 1)]\n\n\ndef rescale_to_unit_list(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / max(1.0, abs(x)) for x in numbers]\n\n\ndef rescale_to_unit_list_with_inverse(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list_with_inverse([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x * max(1.0, abs(x)) for x in numbers]"
    },
    {
      "rank": 84,
      "score": 2.580391238388681,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Must have at least 2 elements\")\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scale = max_number / (max_number - min_number)\n    return [x * scale for x in numbers]\n\n\nif __name__ == \"__main__\":\n    print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))"
    },
    {
      "rank": 85,
      "score": 2.5459879622393946,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    min_number = min(numbers)\n    max_number = max(numbers)\n    new_list = []\n    for number in numbers:\n        new_list.append(number - min_number)\n    new_list = [n / max_number for n in new_list]\n    return new_list\n\n\ndef rescale_to_unit_with_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    min_number = min(numbers)\n    max_number = max(numbers)\n    new_list = []\n    for number in numbers:\n        new_list.append(number - min_number)\n    new_list = [n / max_number for n in new_list]\n    return new_list\n\n\ndef rescale_to_unit_with_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    min_number = min(numbers)\n    max_number = max(numbers)\n    new_list = []\n    for number in numbers:\n        new_list.append(number - min_number)\n    new_list = [n / max_number for n in new_list]"
    },
    {
      "rank": 86,
      "score": 2.493584439832788,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Need at least two numbers\")\n\n    max_number = numbers[-1]\n    min_number = numbers[0]\n\n    if max_number == min_number:\n        return numbers\n\n    new_numbers = []\n    for number in numbers:\n        new_number = (number - min_number) / (max_number - min_number)\n        new_numbers.append(new_number)\n\n    return new_numbers\n\n\ndef rescale_to_unit_with_zeros(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_zeros([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Need at least two numbers\")\n\n    max_number = numbers[-1]\n    min_number = numbers[0]\n\n    if max_number == min_number:\n        return numbers\n\n    new_numbers = []\n    for number in numbers:\n        new_number = (number - min_number) / (max_number - min_number)\n        new_numbers.append(new_number)\n\n    return new_numbers\n\n\ndef rescale_to_unit_with_zeros_and_zeros(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_zeros_and_zeros([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\""
    },
    {
      "rank": 87,
      "score": 2.4711445355220496,
      "candidate": "# scale the smallest number to 0\n    scaled = [float(n) / min(numbers) for n in numbers]\n    # scale the largest number to 1\n    return [float(n) / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    # scale the smallest number to 0\n    scaled = [float(n) / min(numbers) for n in numbers]\n    # scale the largest number to 1\n    return [float(n) / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_and_normalize_and_clip(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize_and_clip([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_and_normalize_and_clip([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 1.0, 1.5, 2.0]\n    \"\"\"\n    # scale the smallest number to 0\n    scaled = [float("
    },
    {
      "rank": 88,
      "score": 2.446832512996986,
      "candidate": "# First, compute the sum of all the numbers\n    sum_of_numbers = sum(numbers)\n    # Then compute the difference between the sum of all the numbers and the number of elements\n    # (the number of elements is the number of numbers minus one)\n    difference = sum_of_numbers - len(numbers)\n    # If difference is negative, we need to reverse the numbers\n    if difference < 0:\n        numbers = numbers[::-1]\n        difference = -difference\n    # Now multiply the number by a factor which will make the difference be 0\n    factor = 1.0 / difference\n    # Apply the factor\n    numbers = [n * factor for n in numbers]\n    # Return the rescaled list\n    return numbers\n\n\ndef rescale_to_unit_with_min(min_number: float, numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_number and the largest will become 1\n    >>> rescale_to_unit_with_min(2.0, [1.0, 2.0, 3.0, 4.0, 5.0])\n    [2.0, 1.0, 1.0, 1.0, 1.0]\n    \"\"\"\n    # First, compute the sum of all the numbers\n    sum_of_numbers = sum(numbers)\n    # Then compute the difference between the sum of all the numbers and the number of elements\n    # (the number of elements is the number of numbers minus one)\n    difference = sum_of_numbers - len(numbers)\n    # If difference is negative, we need to reverse the numbers\n    if difference < 0:\n        numbers = numbers[::-1]\n        difference = -difference\n    # Now multiply the number by a factor which will make the difference be 0\n    factor = min_number / difference\n    # Apply the factor\n    numbers = [n * factor for n in numbers]\n    # Return the rescaled list\n    return numbers\n\n\ndef rescale_to_unit_with_max(max_number: float, numbers: List[float"
    },
    {
      "rank": 89,
      "score": 2.4245032112888487,
      "candidate": "assert len(numbers) > 1\n    assert all(n >= 0.0 for n in numbers)\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # rescale the numbers to the range [0, 1]\n    # note that numbers are already in the range [0, 1]\n    scaled_values = [(n / max_value) for n in numbers]\n    # the scaled values should now be in the range [0, 1]\n\n    # rescale the numbers to the range [0, 1]\n    # note that numbers are already in the range [0, 1]\n    rescaled_values = [(n * (max_value - min_value) + min_value) for n in scaled_values]\n    # the rescaled values should now be in the range [0, 1]\n\n    return rescaled_values\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) > 1\n    assert all(n >= 0.0 for n in numbers)\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # rescale the numbers to the range [0, 1]\n    # note that numbers are already in the range [0, 1]\n    scaled_values = [(n / max_value) for n in numbers]\n    # the scaled values should now be in the range [0, 1]\n\n    # rescale the numbers to the range [0, 1]\n    # note that numbers are already in the range [0, 1]\n    rescaled_values = [(n * (max_value - min_value) + min_value) for n in scaled_values]\n    # the rescaled values should now be in the range ["
    },
    {
      "rank": 90,
      "score": 2.4018966879596646,
      "candidate": "return [x/sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_and_round(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_round([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [round(x/sum(numbers), 1) for x in numbers]\n\n\ndef rescale_to_unit_and_round_and_mean(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_round_and_mean([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [round(x/sum(numbers), 1) for x in numbers]\n    # return [round(x/sum(numbers), 1) for x in numbers]\n    # return [x/sum(numbers) for x in numbers]\n    # return [x/sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_and_mean(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_mean([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x/sum(numbers) for x in numbers]\n\n\ndef rescale_"
    },
    {
      "rank": 91,
      "score": 2.389578175014489,
      "candidate": "scale = max(numbers) - min(numbers)\n    if scale == 0:\n        return numbers\n    return [i/scale for i in numbers]\n\n\ndef rescale_to_range(numbers: List[float], min_: float, max_: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_ and the largest will become max_\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 1.0, 5.0)\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    scale = (max_ - min_) / (max(numbers) - min(numbers))\n    return [min_ + scale * i for i in numbers]\n\n\ndef rescale_to_unit_and_range(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    and the smallest will be in the range [0, 1]\n    >>> rescale_to_unit_and_range([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return rescale_to_unit(numbers) + [0.5]\n\n\nif __name__ == \"__main__\":\n    # print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n    print(rescale_to_unit_and_range([1.0, 2.0, 3.0, 4.0, 5.0]))\n    # print(rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 1.0, 5.0))"
    },
    {
      "rank": 92,
      "score": 2.3359069755507846,
      "candidate": "n = len(numbers)\n    if n < 2:\n        return numbers\n    min_n = min(numbers)\n    max_n = max(numbers)\n    n1 = 1.0 / (max_n - min_n)\n    n2 = min_n / (max_n - min_n)\n    return [n1 * n1 * n1 * n2 * x for x in numbers]\n\n\ndef rescale_to_linear(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_linear([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 1.0, 3.0, 5.0, 7.5]\n    \"\"\"\n    n = len(numbers)\n    if n < 2:\n        return numbers\n    min_n = min(numbers)\n    max_n = max(numbers)\n    n1 = (max_n - min_n) / (max_n - min_n)\n    n2 = min_n / (max_n - min_n)\n    return [n1 * x for x in numbers]\n\n\ndef rescale_to_log(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a log transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_log([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.1, 0.2, 0.4, 0.5]\n    \"\"\"\n    n = len(numbers)\n    if n < 2:\n        return numbers\n    min_n = min(numbers)\n    max_n = max(numbers)\n    n1 = math.log(max_n / min_n) / math.log(2)\n    n2 = min_n / (max_n - min_n)"
    },
    {
      "rank": 93,
      "score": 2.293848149332354,
      "candidate": "# make sure there are at least two numbers in the list\n    assert len(numbers) >= 2, \"need at least two numbers in the list\"\n    # find the smallest and largest numbers\n    min_n = min(numbers)\n    max_n = max(numbers)\n    # find the difference between the smallest and the largest number\n    delta_n = max_n - min_n\n    # if the difference is 0, then the numbers are all the same\n    if delta_n == 0:\n        return numbers\n    # divide the numbers by the difference\n    rescaled_numbers = [x / delta_n for x in numbers]\n    return rescaled_numbers\n\n\ndef rescale_to_unit_list(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_list([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # make sure there are at least two numbers in the list\n    assert len(numbers) >= 2, \"need at least two numbers in the list\"\n    # find the smallest and largest numbers\n    min_n = min(numbers)\n    max_n = max(numbers)\n    # find the difference between the smallest and the largest number\n    delta_n = max_n - min_n\n    # if the difference is 0, then the numbers are all the same\n    if delta_n == 0:\n        return numbers\n    # divide the numbers by the difference\n    rescaled_numbers = [x / delta_n for x in numbers]\n    return rescaled_numbers\n\n\ndef rescale_to_unit_array(numbers: List[float]) -> np.ndarray:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_array(["
    },
    {
      "rank": 94,
      "score": 2.287625906893272,
      "candidate": "if not numbers:\n        return numbers\n    if len(numbers) == 1:\n        return numbers\n    smallest = numbers[0]\n    largest = numbers[-1]\n    scaling = 1.0 / (largest - smallest)\n    return [smallest + scaling * (n - smallest) for n in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> print(numbers)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if not numbers:\n        return numbers\n    if len(numbers) == 1:\n        return numbers\n    smallest = numbers[0]\n    largest = numbers[-1]\n    scaling = 1.0 / (largest - smallest)\n    numbers[:] = [smallest + scaling * (n - smallest) for n in numbers]\n\n\ndef rescale_to_unit_inplace_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> print(numbers)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if not numbers:\n        return numbers\n    if len(numbers) == 1:\n        return numbers\n    smallest = numbers[0]\n    largest = numbers[-1]\n    scaling = 1.0 / (largest - smallest)\n    numbers[:] = [smallest + scaling * (n - smallest) for n in numbers]"
    },
    {
      "rank": 95,
      "score": 2.260739004816286,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List of numbers must have at least 2 elements\")\n    return [numbers[0] / numbers[-1] for numbers in numbers]\n\n\ndef rescale_to_unit_no_overflow(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_no_overflow([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List of numbers must have at least 2 elements\")\n    return [min(numbers) / max(numbers) for numbers in numbers]\n\n\ndef rescale_to_unit_no_underflow(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_no_underflow([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List of numbers must have at least 2 elements\")\n    return [max(numbers) / min(numbers) for numbers in numbers]"
    },
    {
      "rank": 96,
      "score": 2.137541083743484,
      "candidate": "return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_from_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [x * sum(numbers) for x in numbers]\n\n\ndef rescale_to_zero_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_zero_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [x / sum(numbers) for x in numbers]\n\n\ndef rescale_from_zero_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_from_zero_to_unit([0.0, 0.25, 0.5, 0.75, 1.0])\n    [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    return [x * sum(numbers) for x in numbers]\n\n\ndef rescale_to_unit_sqrt(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_sqrt([1.0, 2.0, 3"
    },
    {
      "rank": 97,
      "score": 2.118479922318633,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x / max_value) for x in numbers]\n\n\ndef rescale_to_zero_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_zero_one([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x / (max_value - min_value)) for x in numbers]\n\n\ndef rescale_to_max_min(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_max_min([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\ndef rescale_to_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_min_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x"
    },
    {
      "rank": 98,
      "score": 2.043359877671101,
      "candidate": "min_n = min(numbers)\n    max_n = max(numbers)\n    n_unit = (max_n - min_n) / (max_n + min_n)\n    rescaled_numbers = [n * n_unit for n in numbers]\n    return rescaled_numbers\n\n\ndef rescale_to_unit_minmax(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_minmax([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_n = min(numbers)\n    max_n = max(numbers)\n    n_unit = (max_n - min_n) / (max_n + min_n)\n    rescaled_numbers = [min_n + n * n_unit for n in numbers]\n    return rescaled_numbers\n\n\ndef rescale_to_unit_maxmin(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_maxmin([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_n = min(numbers)\n    max_n = max(numbers)\n    n_unit = (max_n - min_n) / (max_n + min_n)\n    rescaled_numbers = [max_n - n * n_unit for n in numbers]\n    return rescaled_numbers\n\n\ndef rescale_to_unit_minmax_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of"
    },
    {
      "rank": 99,
      "score": 2.020164938060112,
      "candidate": "result = []\n    for n in numbers:\n        result.append(n / sum(numbers))\n    return result\n\n\ndef rescale_to_unit_and_normalize(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_and_normalize([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    result = rescale_to_unit(numbers)\n    result = [r / sum(result) for r in result]\n    return result"
    },
    {
      "rank": 100,
      "score": 1.6901274479551278,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_bounds(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_bounds([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [min(numbers), max(numbers)]\n\n\ndef rescale_to_unit_bounds_2d(numbers: List[List[float]]) -> List[List[float]]:\n    \"\"\" Given list of lists of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_bounds_2d([[1.0, 2.0, 3.0, 4.0, 5.0], [6.0, 7.0, 8.0, 9.0, 10.0]])\n    [[0.0, 0.25, 0.5, 0.75, 1.0], [0.0, 0.25, 0.5, 0.75, 1.0]]\n    \"\"\"\n    return [rescale_to_unit_bounds(numbers_in_row) for numbers_in_row in numbers]\n\n\ndef rescale_to_unit_bounds_3d(numbers: List[List[List[float]]]) -> List[List[List[float]]]:\n    \"\"\" Given list of lists of lists of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_bounds_3d([[[1.0, 2.0, 3.0, 4.0, 5.0], [6.0, 7.0, 8.0, 9.0, 10.0]], [[11.0, 12.0, 13.0"
    }
  ]
}