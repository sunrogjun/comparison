{
  "timestamp": "2025-09-14T19:28:08.359354",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 283,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def maxNode(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n\n        n = head\n        while n.next:\n            n = n.next\n        return n.val\n\n\nif __name__ == '__main__':\n    s = Solution()\n    n = Node(1, Node(2, Node(3)))\n    n.next.next = Node(4, Node(5, Node(6, Node(7))), Node(8, Node(9)))\n    n.next.next.next = Node(10)\n    print(s.maxNode(n))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxNodeValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.maxNodeValueRecur(root)\n    \n    def maxNodeValueRecur(self, root):\n        if not root:\n            return 0\n        left = self.maxNodeValueRecur(root.left)\n        right = self.maxNodeValueRecur(root.right)\n        \n        if left > right:\n            return left\n        if left < right:\n            return right\n        return root.val"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\nif __name__ == \"__main__\":\n    n1 = Node(1, [])\n    n2 = Node(2, [n1])\n    n3 = Node(3, [n2])\n    n4 = Node(4, [n3])\n    n5 = Node(5, [n4])\n    n6 = Node(6, [n5])\n    n7 = Node(7, [n6])\n    n8 = Node(8, [n7])\n    n9 = Node(9, [n8])\n    n10 = Node(10, [n9])\n    n11 = Node(11, [n10])\n    n12 = Node(12, [n11])\n    n13 = Node(13, [n12])\n    n14 = Node(14, [n13])\n    n15 = Node(15, [n14])\n    n16 = Node(16, [n15])\n    n17 = Node(17, [n16])\n    n18 = Node(18, [n17])\n    n19 = Node(19, [n18])\n    n20 = Node(20, [n19])\n    n21 = Node(21, [n20])\n    n22 = Node(22, [n21])\n    n23 = Node(23, [n22])\n    n24 = Node(24, [n23])\n    n25 = Node(25, [n24])\n    n26 = Node(26, [n25])\n    n27 = Node(27, [n26])\n    n28 = Node(28, [n27])\n    n29 = Node(29, [n28])\n    n30 = Node(30, [n29])\n    n31 = Node"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {integer}\n\n    def maxNodeValue(self, head):\n        if not head:\n            return 0\n        max_node_value = head.val\n        pre = head\n        while pre.next:\n            pre = pre.next\n            if pre.val > max_node_value:\n                max_node_value = pre.val\n            if pre.val < max_node_value:\n                pre = pre.next\n        return max_node_value\n\nif __name__ == \"__main__\":\n    # n1 = ListNode(1)\n    # n2 = ListNode(2)\n    # n3 = ListNode(3)\n    # n4 = ListNode(4)\n    # n5 = ListNode(5)\n    # n6 = ListNode(6)\n    # n7 = ListNode(7)\n    # n8 = ListNode(8)\n    # n9 = ListNode(9)\n    # n10 = ListNode(10)\n    # n11 = ListNode(11)\n    # n12 = ListNode(12)\n    # n13 = ListNode(13)\n    # n14 = ListNode(14)\n    # n15 = ListNode(15)\n    # n16 = ListNode(16)\n    # n17 = ListNode(17)\n    # n18 = ListNode(18)\n    # n19 = ListNode(19)\n    # n20 = ListNode(20)\n    # n21 = ListNode(21)\n    # n22 = ListNode(22)\n    # n23 = ListNode(23)\n    # n24 = ListNode(24)\n    # n25 = ListNode(25)\n    # n26 = ListNode(26)\n    # n27 = ListNode(27)\n    # n28 = ListNode(28)\n    # n29 = ListNode(29)\n    # n30 = ListNode(30)\n    # n31 = ListNode(31)\n    # n32 = ListNode(32)\n    # n33 = ListNode(33)\n    # n34 = ListNode(34)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-of-two-arrays\n\ndef max_of_two_arrays(arr):\n    # Write your code here\n    max_val = max(arr[0], arr[1])\n    for i in range(2, len(arr)):\n        if arr[i] > max_val:\n            max_val = arr[i]\n    return max_val"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def max(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        \n        cur = head\n        max = cur.val\n        while cur.next:\n            cur = cur.next\n            if cur.val > max:\n                max = cur.val\n            \n        return max"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "#!/usr/bin/python\n\n# Write your code here\ndef max_value(arr):\n    if not arr:\n        return 0\n    else:\n        return max(arr)\n\n# Your code here\n\ndef main():\n    arr = [1,2,3]\n    print max_value(arr)\n    arr = [1,2]\n    print max_value(arr)\n    arr = [1,2,3,4,5,6,7]\n    print max_value(arr)\n    arr = [1,2,3,4,5]\n    print max_value(arr)\n    arr = [1,2,3,4,5,6]\n    print max_value(arr)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def maxNodeVal(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        left, right = head, head\n        while right and right.next:\n            left = left.next\n            right = right.next.next\n        left_max = self.maxNodeVal(left)\n        right_max = self.maxNodeVal(right)\n        if left_max > right_max:\n            return left_max\n        return right_max\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.maxNodeVal(head)"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def max_heterogeneous_list(list_of_tuples):\n    \"\"\"\n    :param list_of_tuples: A list of tuples.\n    :return: The maximum value in the list.\n    \"\"\"\n    max_value = -1\n    for element in list_of_tuples:\n        if element[0] > max_value:\n            max_value = element[0]\n    return max_value\n\n# Your code here"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def max(self, num):\n        res = num[0]\n        for num in num:\n            if res < num:\n                res = num\n        return res"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nFind the maximum value in a given heterogeneous list.\n\nExample:\nInput:\n[\n  {1: 10},\n  {2: 3},\n  {2: 4}\n]\n\nOutput:\n10\n\nExplanation:\nThe list is a heterogeneous list with two lists inside it.\nThe first list has two elements: [1, 10].\nThe second list has two elements: [2, 3] and [2, 4].\nThe maximum value in the list is 10.\n\"\"\"\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass Solution(object):\n    def maxNodeVal(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: int\n        \"\"\"\n        if not head:\n            return None\n        max_node = head\n        while max_node.next:\n            max_node = max_node.next\n        return max_node.val\n\n\nif __name__ == \"__main__\":\n    head = Node(1)\n    head.next = Node(10)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    print Solution().maxNodeVal(head)"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        if not root: return 0\n        return max(self.maxNodeValue(root.left), self.maxNodeValue(root.right)) + root.val\n\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        if not root: return 0\n        if root.left and root.right:\n            return max(self.maxNodeValue(root.left), self.maxNodeValue(root.right)) + root.val\n        elif root.left:\n            return max(self.maxNodeValue(root.left), root.val)\n        else:\n            return max(self.maxNodeValue(root.right), root.val)\n\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        if not root: return 0\n        if root.left:\n            return max(self.maxNodeValue(root.left), root.val)\n        else:\n            return max(self.maxNodeValue(root.right), root.val)\n\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        if not root: return 0\n        if root.left:\n            return max(self.maxNodeValue(root.left), root.val)\n        else:\n            return max(self.maxNodeValue(root.right), root.val) + root.val\n\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        if not root: return 0\n        if root.left:\n            return max(self.maxNodeValue(root.left), root.val)\n        else:\n            return max(self.maxNodeValue(root.right), root.val) + root.val\n\n    # @param root,"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-in-heterogeneous-list/\n# \n# \n#  Given a list of non-negative integers, you can choose k numbers\n#  from the list at any time. Each number you choose is summed with the\n#  previous one. For example, if the list is [3, 2, 4, 1, 3, 5, 1, 4, 2],\n#  and you choose 2, you get [3, 5, 1, 1, 2].\n# \n#  Return the maximum total.\n# \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#  \n#"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def maxNode(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        pivot = head\n        max_value = 0\n        while pivot:\n            max_value = max(max_value, pivot.val)\n            pivot = pivot.next\n        return max_value"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        ans = root.val\n        max_val = root.val\n        max_left = max_val\n        max_right = max_val\n        if root.left:\n            max_left = max(self.maxHeterogeneity(root.left), max_left)\n        if root.right:\n            max_right = max(self.maxHeterogeneity(root.right), max_right)\n        ans = max(max_val, max(max_left, max_right))\n        return ans"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def findMax(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    maxVal = max(nums)\n    return maxVal\n\n# Your FindMax object will be instantiated and called as such:\n# obj = FindMax(nums)\n# param_1 = obj.findMax(nums)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def getMax(node):\n            if not node:\n                return 0\n            max_left = getMax(node.left)\n            max_right = getMax(node.right)\n            max_self = max(max_left, max_right)\n            return max(max_self, node.val)\n\n        return getMax(root)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    print sol.maxHeterogeneity(root)"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/max-heap-1/problem\n\nfrom collections import namedtuple\n\n# Node: A node in the heap\nclass Node(namedtuple('Node', 'data key')):\n    pass\n\nclass MaxHeap(object):\n    \"\"\"\n    A max heap implementation\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the heap\n        \"\"\"\n        self.heap = []\n\n    def insert(self, element):\n        \"\"\"\n        Insert an element into the heap\n        :param element: The element to insert\n        \"\"\"\n        self.heap.append(Node(element, len(self.heap) - 1))\n\n    def extract_max(self):\n        \"\"\"\n        Extract the largest element from the heap\n        \"\"\"\n        return self.heap.pop().data\n\n    def is_empty(self):\n        \"\"\"\n        Check if the heap is empty\n        :return: True if empty, False otherwise\n        \"\"\"\n        return len(self.heap) == 0\n\n    def size(self):\n        \"\"\"\n        Get the size of the heap\n        :return: The size of the heap\n        \"\"\"\n        return len(self.heap)\n\n    def is_max_heap(self):\n        \"\"\"\n        Check if the heap is a max heap\n        :return: True if the heap is a max heap, False otherwise\n        \"\"\"\n        if self.is_empty():\n            return True\n        else:\n            return all(self.heap[i].key > self.heap[i + 1].key for i in range(len(self.heap) - 1))\n\n    def build_max_heap(self, arr):\n        \"\"\"\n        Build a max heap from the given array\n        :param arr: The array to build the max heap from\n        \"\"\"\n        for i in range(len(arr)):\n            self.insert(arr[i])\n\n    def build_max_heap_from_list(self, arr):\n        \"\"\"\n        Build a max heap from a list of integers\n        :param arr: The list of integers to build the max heap from"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children or []\n\n    def __repr__(self):\n        return 'Node(val={}, children={})'.format(self.val, self.children)\n\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        ans = 0\n        max_ans = 0\n        for i in range(len(root.children)):\n            cur_ans = self.maxHeterogeneity(root.children[i])\n            ans = max(ans, cur_ans)\n            max_ans = max(max_ans, cur_ans)\n        return ans\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = Node(1, [Node(2), Node(3), Node(4), Node(5)])\n    print(sol.maxHeterogeneity(root))\n    root = Node(1, [Node(2), Node(3), Node(4), Node(5)])\n    print(sol.maxHeterogeneity(root))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        max = 0\n        max_node = root\n        if root.left is not None:\n            max_node = root.left\n        if root.right is not None:\n            max_node = root.right\n        max = self.maxHeterogeneity(root.left)\n        max = max + self.maxHeterogeneity(root.right)\n        if max_node.val > max:\n            max = max_node.val\n        return max\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxHeterogeneity([1,2,3,4,5]))"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode[]} nodes\n    # @return {integer}\n    def maxNodeVal(self, nodes):\n        if not nodes:\n            return 0\n        if not nodes[0].left:\n            return nodes[0].val\n        return max(self.maxNodeVal(nodes[0].left), self.maxNodeVal(nodes[0].right))"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        max_val = nums[0]\n        for val in nums:\n            if val > max_val:\n                max_val = val\n        return max_val\n\n\nif __name__ == \"__main__\":\n    print Solution().max([4, 2, 7, 3, 5, 6])\n    print Solution().max([1, 2, 3, 4])\n    print Solution().max([1, 1, 1, 1, 1, 1])"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num = nums[0]\n        for num in nums:\n            if num > max_num:\n                max_num = num\n        return max_num"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "def max_in_list(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n    return max_val\n\n# Your Max in List solution goes here\n# print max_in_list([-1, 2, 3, -4, 1, 1])"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def maxInList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n\n        return max(nums) if len(nums) == 1 else max(nums) + max(nums[1:])\n\n    def maxInList2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        return max(nums) if len(nums) == 1 else max(nums) + max(nums[1:])\n\n\nif __name__ == \"__main__\":\n    print Solution().maxInList([1,2,3,4,5])\n    print Solution().maxInList2([1,2,3,4,5])"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def findMaxNode(self, head):\n        if not head or not head.next:\n            return head\n        max_node = head\n        cur = head\n        while cur.next:\n            if cur.next.val > max_node.val:\n                max_node = cur.next\n            cur = cur.next.next\n        return max_node\n        \n    def maxNode(self, head):\n        if not head or not head.next:\n            return head\n        max_node = head\n        cur = head\n        while cur.next:\n            if cur.next.val > max_node.val:\n                max_node = cur.next\n            cur = cur.next.next\n        return max_node\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    list = [1,3,2,5,4]\n    print solution.maxNode(list)"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxNodeVal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def max(node, path):\n            if not node:\n                return 0\n            if node.left:\n                path.append(node.left)\n                return max(node.left, path)\n            else:\n                path.append(node)\n                return max(node.right, path)\n\n        path = []\n        return max(root, path)"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode[]} nodes\n    # @return {integer}\n    def maxNodeValue(self, nodes):\n        if not nodes:\n            return 0\n        left = self.maxNodeValue(nodes[:len(nodes)/2])\n        right = self.maxNodeValue(nodes[len(nodes)/2:])\n        return max(left, right) + nodes[0].val\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.maxNodeValue([1,2,3,4,5,6,7,8,9])\n    print solution.maxNodeValue([1,2,3,4,5,6])\n    print solution.maxNodeValue([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def maxNodeVal(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: int\n        \"\"\"\n        max_val = 0\n        if not head:\n            return 0\n        curr = head\n        while curr.next:\n            curr = curr.next\n            max_val = max(max_val, curr.val)\n        return max_val"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        max_val = -1\n        self.max_val = max_val\n        self.max_list = []\n        self.max_list_len = 0\n        self.build_max_list(root)\n        return self.max_list_len\n\n    def build_max_list(self, root):\n        if not root:\n            return\n        self.max_list.append(root.val)\n        self.max_list_len = max(self.max_list_len, len(self.max_list))\n        if root.left:\n            self.build_max_list(root.left)\n        if root.right:\n            self.build_max_list(root.right)\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.right = TreeNode(10)\n    root.left.right.right.left = TreeNode(11)\n    root.left.right.right.right = TreeNode(12)\n    root.right.left.left = TreeNode(13)\n    root.right.right.right = TreeNode(14)\n    root.right.right.right.left = TreeNode(15)\n    root.right.right.right.right = TreeNode(16)\n    root.right.right.right.right.left = TreeNode(17)\n    root.right"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\n\nclass Solution:\n\t# @param head, a list node\n\t# @return an integer\n\tdef maxNodeValue(self, head):\n\t\tif not head:\n\t\t\treturn 0\n\t\t\n\t\tmaxVal = head.val\n\t\tcurr = head\n\t\twhile curr.next:\n\t\t\tcurr = curr.next\n\t\t\tmaxVal = max(maxVal, curr.val)\n\t\t\n\t\treturn maxVal"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        max = head.val\n        max_index = 0\n        while head.next:\n            if head.next.val > max:\n                max = head.next.val\n                max_index = 0\n            elif head.next.val == max:\n                max_index += 1\n            head = head.next\n        return max_index + 1"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return nums[-1]"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children else []\n\nclass Solution:\n    def maxHeterogeneousSubTree(self, root: 'Node') -> 'int':\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = dfs(node.children[0])\n            right = dfs(node.children[1])\n            return max(left, right) + node.val\n\n        return dfs(root)"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param head, a list node\n    # @return an integer\n    def findMaxNode(self, head):\n        if head is None:\n            return 0\n        elif head.next is None:\n            return head.val\n        elif head.next.next is None:\n            return max(head.val, head.next.val)\n        else:\n            node = head\n            while node.next.next is not None:\n                node = node.next\n            return max(node.val, node.next.val)"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def maxNodeVal(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if head is None:\n            return 0\n        max_val = 0\n        while head is not None:\n            max_val = max(max_val, head.val)\n            head = head.next\n        return max_val"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "class Solution:\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_val = max(nums)\n        max_idx = 0\n        for idx, val in enumerate(nums):\n            if val > max_val:\n                max_val = val\n                max_idx = idx\n        return max_val"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxHeterogeneity(self, root: TreeNode) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n\n        max_val = root.val\n        max_count = 1\n\n        def helper(node: TreeNode) -> int:\n            if node is None:\n                return 0\n            count = 1\n            if node.left is not None:\n                count += helper(node.left)\n            if node.right is not None:\n                count += helper(node.right)\n            if node.left is not None and node.right is not None:\n                count += 1\n            if count > max_count:\n                max_count = count\n                max_val = node.val\n            return count\n\n        return helper(root)\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.left = TreeNode(10)\n    root.left.right.right = TreeNode(11)\n    root.right.left.left = TreeNode(12)\n    root.right.left.right = TreeNode(13)\n    root.right.right.left = TreeNode(14)\n    root.right.right.right = TreeNode(15)\n\n    print(Solution().maxHeterogeneity(root))"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        if len(root.children) == 0:\n            return root.val\n        else:\n            return max(self.maxHeterogeneity(c) for c in root.children)"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def max(self, lst):\n        \"\"\"\n        :type lst: List[TreeNode]\n        :rtype: int\n        \"\"\"\n        res = lst[0].val\n        for i in lst:\n            if i.val > res:\n                res = i.val\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.max([TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4)])\n    print sol.max([TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4), TreeNode(5)])\n    print sol.max([TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4), TreeNode(5), TreeNode(6)])"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-in-a-list/problem\n\ndef max_in_list(my_list):\n    \"\"\"\n    :param my_list: A list of integers.\n    :return: The maximum value in the list.\n    \"\"\"\n\n    # My solution\n    max_in_list_solution = my_list[0]\n    for number in my_list:\n        if number > max_in_list_solution:\n            max_in_list_solution = number\n\n    return max_in_list_solution\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert max_in_list([1, 2, 3]) == 3, \"Example 1\"\n    assert max_in_list([2, 1, 3]) == 3, \"Example 2\"\n    assert max_in_list([2, 5, 2, 1, 3]) == 5, \"Example 3\"\n    assert max_in_list([1, 2, 3]) == 3, \"Example 4\"\n    assert max_in_list([3, 2, 1, 4]) == 4, \"Example 5\"\n    assert max_in_list([3, 3, 3, 3]) == 3, \"Example 6\"\n    assert max_in_list([5, 3, 3, 2, 1]) == 5, \"Example 7\"\n    assert max_in_list([3, 2, 3]) == 3, \"Example 8\"\n    assert max_in_list([3, 3, 2, 2, 2]) == 3, \"Example 9\"\n    assert max_in_list([3, 3, 3, 3, 3]) == 3, \"Example 10\""
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def maxInList(self, list):\n        \"\"\"\n        :type list: List[TreeNode]\n        :rtype: int\n        \"\"\"\n        if len(list) == 0:\n            return 0\n        maxval = list[0].val\n        for i in range(len(list)):\n            maxval = max(maxval, list[i].val)\n        return maxval\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    # list = [3,1,2,2,3,4,4,5,3,4,3,5,5,4,4,5,5,4,3,2]\n    # print(sol.maxInList(list))\n    list = [1, 2, 3, 4, 5]\n    print(sol.maxInList(list))"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-in-heterogeneous-array/description/\n\nclass Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        m = max(nums)\n        for i in range(len(nums)):\n            if nums[i] > m:\n                m = nums[i]\n        return m\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print(s.findMax(nums))"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        \n        left = self.maxHeterogeneity(root.left)\n        right = self.maxHeterogeneity(root.right)\n        \n        max_val = root.val\n        \n        if left > right:\n            max_val = left\n        else:\n            max_val = right\n            \n        return max(max_val, root.val)"
    },
    {
      "rank": 45,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.max([1,2,3,4])\n    print sol.max([1,2,3])\n    print sol.max([1,2])\n    print sol.max([1])\n    print sol.max([])"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def max_window(nums, k):\n            n = len(nums)\n            if n <= k:\n                return nums\n            elif k == 1:\n                return max(nums)\n            else:\n                start = 0\n                end = k - 1\n                while start < n:\n                    max_so_far = max(nums[start:end])\n                    start += 1\n                    end -= 1\n                    while start < end and nums[start] == max_so_far:\n                        start += 1\n                    if start == end:\n                        return max_so_far\n        return max_window(nums, k)\n\nif __name__ == \"__main__\":\n    nums = [1, 3, -1, -3, 5, 3, 6, 7]\n    k = 2\n    print Solution().maxSlidingWindow(nums, k)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def findMaxNode(self, head):\n        if not head:\n            return None\n\n        maxNode = head\n        while head:\n            if head.val > maxNode.val:\n                maxNode = head\n            head = head.next\n        return maxNode"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def max_heapify(root, size):\n            if root is None:\n                return\n            if root.left is None and root.right is None:\n                return\n            if root.left is None:\n                heapq.heappush(max_heap, root.val)\n            elif root.right is None:\n                heapq.heappush(max_heap, root.val)\n            else:\n                if root.left.val < root.right.val:\n                    heapq.heappush(max_heap, root.left.val)\n                else:\n                    heapq.heappush(max_heap, root.right.val)\n            max_heapify(root.left, size)\n            max_heapify(root.right, size)\n\n        max_heap = []\n        max_heapify(root, len(max_heap))\n        return heapq.heappop(max_heap)"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def max_value(values):\n    \"\"\"\n    :type values: List[int]\n    :rtype: int\n    \"\"\"\n    if not values:\n        return 0\n\n    max_value = values[0]\n    for i in range(len(values)):\n        if values[i] > max_value:\n            max_value = values[i]\n\n    return max_value"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def max(self, l):\n        \"\"\"\n        :type l: List[TreeNode]\n        :rtype: int\n        \"\"\"\n        if len(l) == 0:\n            return 0\n        elif len(l) == 1:\n            return l[0].val\n        else:\n            max_node = l[0]\n            for i in range(1, len(l)):\n                max_node = max(max_node.val, l[i].val)\n            return max_node.val\n\n\nif __name__ == '__main__':\n    l = [TreeNode(0), TreeNode(1), TreeNode(3), TreeNode(2), TreeNode(4)]\n    print Solution().max(l)\n    l = [TreeNode(0)]\n    print Solution().max(l)\n    l = [TreeNode(0), TreeNode(1)]\n    print Solution().max(l)\n    l = [TreeNode(0), TreeNode(1)]\n    print Solution().max(l)"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.maxDepth(root.right) + 1\n        if root.right is None:\n            return self.maxDepth(root.left) + 1\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\nroot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\nroot.left.left = TreeNode(0, TreeNode(1, TreeNode(2), TreeNode(3)), TreeNode(4, TreeNode(5), TreeNode(6)))\nroot.left.right.left = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\nroot.left.right.right = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\nroot.right.left.left = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\nroot.right.left.right = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\nroot.right.right.left = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\nroot.right.right.right = TreeNode(0, TreeNode(1), TreeNode(2, TreeNode(3), TreeNode(4)))\n\n# root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "import sys\n\ndef max_value(nums):\n    \"\"\"\n    Returns the maximum value in a list of integers.\n\n    Example\n    >>> max_value([1,2,3,4])\n    4\n    >>> max_value([-1,2,-3,4])\n    4\n    >>> max_value([-1,2,-3,0])\n    3\n    >>> max_value([0,0,0,0,0,0])\n    0\n    >>> max_value([])\n    >>> max_value([-1,2,-3,0,0,0])\n    3\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n    return max_value\n\nif __name__ == '__main__':\n    nums = [1,2,3,4]\n    print max_value(nums)\n    nums = [-1,2,-3,4]\n    print max_value(nums)\n    nums = [-1,2,-3,0]\n    print max_value(nums)\n    nums = [0,0,0,0,0,0]\n    print max_value(nums)\n    nums = []\n    print max_value(nums)\n    nums = [-1,2,-3,0,0,0]\n    print max_value(nums)"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "import collections\n\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution(object):\n    def maxHeterogeneity(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        max_val = 0\n        max_child = None\n        cur_max = 0\n        cur_max_child = None\n\n        if not root:\n            return 0\n\n        def max_child_val(node):\n            if not node.children:\n                return 0\n            return max(max_child_val(child) for child in node.children)\n\n        def max_val_from_node(node):\n            if not node:\n                return 0\n            return max(max_val_from_node(child) for child in node.children)\n\n        def max_val_from_list(nodes):\n            if not nodes:\n                return 0\n            return max(max_val_from_list(child) for child in nodes)\n\n        def max_val_from_list_rec(nodes):\n            if not nodes:\n                return 0\n            if len(nodes) == 1:\n                return nodes[0].val\n            else:\n                return max(max_val_from_list_rec(child) for child in nodes)\n\n        def max_val_from_list_rec_child(node):\n            if not node:\n                return 0\n            if len(node.children) == 1:\n                return node.children[0].val\n            else:\n                return max(max_val_from_list_rec_child(child) for child in node.children)\n\n        def max_val_from_list_rec_child_child(node):\n            if not node:\n                return 0\n            if len(node.children) == 1:\n                return node.children[0].val\n            else:\n                return max(max_val_from_list_rec_child_child(child) for child in node.children)\n\n        def max_val_from_list_rec_child_child_child(node):\n            if"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef max_heap(arr):\n    \"\"\"\n    Find the maximum value in a list of values\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return arr[0] if n else 0\n    \n    max_val = arr[0]\n    heap_max = [max_val]\n    heap_max.append(0)\n    \n    for i in range(1, n):\n        val = arr[i]\n        if val > max_val:\n            max_val = val\n        heap_max[0] = val\n        heap_max.append(max_val)\n        \n        # swap the two max elements\n        max_val = heap_max[0]\n        heap_max[0] = heap_max[1]\n        heap_max[1] = max_val\n        \n        # heapify\n        j = 2\n        while j < len(heap_max):\n            if heap_max[j] < heap_max[j/2]:\n                heap_max[j] = heap_max[j/2]\n            j = j*2 + 1\n        \n    return max_val\n\ndef test_max_heap():\n    arr = [2, 1, 3]\n    print(max_heap(arr))\n    \n    arr = [1, 2, 3, 4]\n    print(max_heap(arr))\n\nif __name__ == '__main__':\n    test_max_heap()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-in-a-list/problem\n\ndef max_in_list(list_of_numbers):\n    max_number = None\n    for number in list_of_numbers:\n        if max_number is None or number > max_number:\n            max_number = number\n    return max_number\n\nif __name__ == '__main__':\n    list_of_numbers = [2, 1, 3, 4]\n    print(max_in_list(list_of_numbers))\n    list_of_numbers = [1, 2, 2, 3, 4, 5]\n    print(max_in_list(list_of_numbers))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "class Solution:\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        max_value = nums[0]\n        max_index = 0\n        for index in range(1, len(nums)):\n            if nums[index] > max_value:\n                max_value = nums[index]\n                max_index = index\n        return max_value"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "def max_heapify(arr, i, arr_size):\n    \"\"\"\n    :param arr: A list of integers.\n    :param i: The index of the current node to be maximized.\n    :param arr_size: The size of the list.\n    :return: The maximum value in the list.\n    \"\"\"\n    if i >= arr_size:\n        return arr[i]\n    else:\n        max_heap = arr[i]\n        parent = (i - 1) // 2\n        while parent >= 0 and arr[parent] > arr[i]:\n            max_heap = arr[parent]\n            arr[parent] = arr[i]\n            arr[i] = max_heap\n            i = parent\n            parent = (i - 1) // 2\n\n        return max_heap\n\n\ndef max_heapify_recursive(arr, i, arr_size):\n    \"\"\"\n    :param arr: A list of integers.\n    :param i: The index of the current node to be maximized.\n    :param arr_size: The size of the list.\n    :return: The maximum value in the list.\n    \"\"\"\n    if i >= arr_size:\n        return arr[i]\n    else:\n        max_heap = arr[i]\n        largest = i\n        child = 2 * i + 1\n        while child < arr_size:\n            if child + 1 < arr_size and arr[child + 1] > arr[child]:\n                largest = child\n                child = child + 1\n            elif child + 1 == arr_size or arr[child + 1] < arr[largest]:\n                largest = child\n            child = 2 * child + 1\n\n        if largest!= i:\n            arr[largest] = arr[i]\n            arr[i] = max_heap\n        return max_heapify_recursive(arr, largest, arr_size)\n\n\ndef max_heap_recursive(arr, arr_size):\n    \"\"\"\n    :param arr: A list of integers.\n    :param arr_size: The size of the list.\n    :return: The maximum value in the list.\n    \"\"\"\n    if arr_size == 0"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def max_value(l):\n    \"\"\"\n    :param l: A list of integers\n    :return: The maximum value in the list\n    \"\"\"\n\n    # if l is empty, return 0\n    if len(l) == 0:\n        return 0\n\n    # if l is a single number, return it\n    if len(l) == 1:\n        return l[0]\n\n    # if l is a list of numbers, return the max in the list\n    return max(max_value(l[1:]), l[0])"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param head, a list node\n    # @return an integer\n    def maxNodeValue(self, head):\n        max_node = None\n        curr_max_node = None\n\n        while head is not None:\n            if max_node is None:\n                curr_max_node = head\n                max_node = head\n            else:\n                if head.val > curr_max_node.val:\n                    curr_max_node = head\n                if head.val < curr_max_node.val:\n                    max_node = curr_max_node\n            head = head.next\n        return max_node.val"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxHeterogeneousTree(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return root.val\n        res = root.val\n        if root.left is not None:\n            res = max(res, self.maxHeterogeneousTree(root.left))\n        if root.right is not None:\n            res = max(res, self.maxHeterogeneousTree(root.right))\n        return res\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.left.right.left = TreeNode(7)\n    root.left.right.right = TreeNode(8)\n    root.right.right.left = TreeNode(9)\n    root.right.right.right = TreeNode(10)\n    root.left.right.right.left = TreeNode(11)\n    root.left.right.right.right = TreeNode(12)\n    root.right.right.right.left = TreeNode(13)\n    root.right.right.right.right = TreeNode(14)\n    root.left.right.right.right.left = TreeNode(15)\n    root.left.right.right.right.right = TreeNode(16)\n    root.right.right.right.right.left = TreeNode(17)\n    root.right.right.right.right.right = TreeNode(18)\n    root.left.right.right.right.right.left = TreeNode(19)\n    root.left.right.right.right.right.right = TreeNode(20)\n    root.right.right.right.right"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "# Your code here\n\ndef max_in_list(l):\n    if len(l) == 0:\n        return None\n    elif len(l) == 1:\n        return l[0]\n    else:\n        return max(max_in_list(sublist) for sublist in l)\n\ndef test_max_in_list():\n    assert max_in_list([1,2,3,4]) == 4\n    assert max_in_list([3,4,5]) == 4\n    assert max_in_list([2,3,4,5,6,7,8]) == 7\n    assert max_in_list([1,2,3,4,5,6,7,8,9]) == 9\n\ntest_max_in_list()"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def max_in_list(list_of_numbers):\n    \"\"\"\n    :type list_of_numbers: List[int]\n    :rtype: int\n    \"\"\"\n    return max(list_of_numbers)\n\n\nif __name__ == '__main__':\n    assert(max_in_list([1, 3, 5, 1, 2]) == 5)\n    assert(max_in_list([3, 2, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1]) == 3)\n    assert(max_in_list([1, 1, 2, 2, 2, 3, 2, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1, 1, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1, 1]) == 3)\n    assert(max_in_list([1, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1, 1, 1]) == 3)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import sys\nimport collections\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print('Please provide a filename.')\n        sys.exit(1)\n    filename = sys.argv[1]\n    with open(filename) as f:\n        data = [int(x) for x in f.read().split()]\n    max_value = max(data)\n    print(max_value)"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def find_max(my_list):\n    \"\"\"\n    Find the maximum value in a given list.\n\n    :type my_list: List[int]\n    :rtype: int\n    \"\"\"\n    # My implementation\n    max_val = 0\n    for i in range(len(my_list)):\n        if my_list[i] > max_val:\n            max_val = my_list[i]\n    return max_val\n\n\ndef test():\n    my_list = [1, 2, 3, 4]\n    assert(find_max(my_list) == 4)\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def max_heapify(arr, i):\n    \"\"\"\n    Recursively find the maximum element of arr[i],\n    and put it in the root of a max-heap.\n    \"\"\"\n    if i >= 0 and arr[i] > arr[(i + 1) / 2]:\n        max_heapify(arr, (i + 1) / 2)\n    else:\n        return\n\ndef max_heap_max(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,\n    and put it in the root of a max-heap.\n    \"\"\"\n    if arr == []:\n        return None\n    else:\n        return max_heap_max(arr[:]) + arr[0]\n\ndef max_heap_max_2(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,\n    and put it in the root of a max-heap.\n    \"\"\"\n    if arr == []:\n        return None\n    else:\n        max_heap_max_2(arr[:])\n        return arr[0]\n\ndef max_heap_max_3(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,\n    and put it in the root of a max-heap.\n    \"\"\"\n    if arr == []:\n        return None\n    else:\n        arr.sort()\n        return arr[0]\n\ndef max_heap_max_4(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,\n    and put it in the root of a max-heap.\n    \"\"\"\n    if arr == []:\n        return None\n    else:\n        arr.sort()\n        return arr[0]\n\ndef max_heap_max_5(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,\n    and put it in the root of a max-heap.\n    \"\"\"\n    if arr == []:\n        return None\n    else:\n        arr.sort()\n        return arr[0]\n\ndef max_heap_max_6(arr):\n    \"\"\"\n    Recursively find the maximum element of arr,"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        max_node = None\n        max_value = -1\n        while head:\n            if not max_node:\n                max_node = head\n            else:\n                if head.val > max_value:\n                    max_node = head\n                    max_value = head.val\n            head = head.next\n        return max_value\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    print Solution().findMax(head)"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        max_val = root.val\n        max_tree = root\n        if root.left:\n            max_tree = self.max_tree(root.left)\n        if root.right:\n            max_tree = self.max_tree(root.right)\n        if max_tree.val > max_val:\n            max_val = max_tree.val\n        return max_val\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint Solution().maxTree(root)"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def maxNode(self, head):\n        if not head:\n            return None\n        \n        max_node = None\n        for node in head:\n            if max_node is None:\n                max_node = node\n            else:\n                if node.val > max_node.val:\n                    max_node = node\n        return max_node"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def max(self, arr):\n        \"\"\"\n        :type arr: List[TreeNode]\n        :rtype: int\n        \"\"\"\n        max_val = -1\n        cur_max = 0\n        for i in range(len(arr)):\n            if arr[i] is None:\n                continue\n            cur_max = max(cur_max, arr[i].val)\n            if cur_max > max_val:\n                max_val = cur_max\n        return max_val\n\nif __name__ == '__main__':\n    arr = [None, None, 1, None, None, None, 2, 3]\n    sol = Solution()\n    print(sol.max(arr))"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def find_max(lst):\n    \"\"\"\n    >>> find_max([3, 4, 5, 1])\n    5\n    >>> find_max([3, 5, 4, 1, 6])\n    6\n    >>> find_max([3, 5, 4, 1, 6, 7])\n    7\n    \"\"\"\n    max_value = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] > max_value:\n            max_value = lst[i]\n    return max_value\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxHeterogeneity(self, root: TreeNode) -> int:\n        maxH = 0\n        if not root:\n            return 0\n        stack = [root]\n        while stack:\n            current = stack.pop()\n            if not current.left and not current.right:\n                maxH = max(maxH, current.val)\n                continue\n            if current.left:\n                stack.append(current.left)\n            if current.right:\n                stack.append(current.right)\n        return maxH\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nprint(Solution().maxHeterogeneity(root))"
    },
    {
      "rank": 72,
      "score": 7.0,
      "candidate": "def max(myList):\n    \"\"\"\n    :type myList: List[int]\n    :rtype: int\n    \"\"\"\n    max_val = -1\n    for i in myList:\n        if i > max_val:\n            max_val = i\n    return max_val\n\n\nif __name__ == \"__main__\":\n    myList = [1, 2, 3, 4, 5, 6]\n    print(max(myList))"
    },
    {
      "rank": 73,
      "score": 7.0,
      "candidate": "#!/usr/bin/python\n\n# https://www.hackerrank.com/challenges/max-value/problem\n\nimport sys\n\ndef maxValue(A):\n    maxValue = 0\n    for i in A:\n        if i > maxValue:\n            maxValue = i\n    return maxValue\n\nif __name__ == \"__main__\":\n    A = map(int, raw_input().strip().split(' '))\n    print maxValue(A)"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass Solution:\n    # @param head, a list node\n    # @return an integer\n    def maxNodeValue(self, head):\n        if not head:\n            return 0\n        # max value\n        max_val = -sys.maxsize\n        # max node\n        max_node = None\n        # current node\n        curr_node = head\n        while curr_node:\n            if curr_node.val > max_val:\n                max_val = curr_node.val\n                max_node = curr_node\n            curr_node = curr_node.next\n        # reverse list\n        curr_node = head\n        while curr_node:\n            if curr_node.val > max_val:\n                max_val = curr_node.val\n                max_node = curr_node\n            curr_node = curr_node.next\n        return max_val\n\n\nif __name__ == \"__main__\":\n    # [1, 2, 3]\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    print Solution().maxNodeValue(head)"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "def max_value(values):\n    \"\"\"\n    :type values: List[int]\n    :rtype: int\n    \"\"\"\n    if len(values) == 0:\n        return 0\n    elif len(values) == 1:\n        return values[0]\n    else:\n        return max(values[0], max_value(values[1:]))\n\nif __name__ == '__main__':\n    assert max_value([1, 2, 3, 4, 5]) == 5\n    assert max_value([1, 2, 3, 4, 5, 6]) == 6\n    assert max_value([1, 2, 3, 4, 5, 6, 7]) == 7\n    assert max_value([1, 2, 3, 4, 5, 6, 7, 8]) == 8\n    assert max_value([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven a list of non-negative integers, arrange them such that\nevery element appears exactly once and every pair of numbers\ncontains at least one common element.\n\nFor example,\nGiven [1, 2, 3, 4, 5, 6],\nreturn [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5].\n\"\"\"\n\n\nclass Solution(object):\n    def maxHomogeneous(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # DP\n        # dp = [[0 for i in range(len(nums)+1)] for j in range(len(nums)+1)]\n        # for i in range(len(nums)+1):\n        #     for j in range(len(nums)+1):\n        #         if i == j:\n        #             dp[i][j] = 1\n        #         elif i == 0 or j == 0:\n        #             dp[i][j] = 0\n        #         elif nums[i-1] == nums[j-1]:\n        #             dp[i][j] = dp[i-1][j-1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # return dp[len(nums)][len(nums)]\n\n        # DP\n        dp = [[0 for i in range(len(nums)+1)] for j in range(len(nums)+1)]\n        for i in range(len(nums)+1):\n            for j in range(len(nums)+1):\n                if i == j:\n                    dp[i][j] = 1\n                elif i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif nums[i-1] == nums[j-1]:\n                    dp[i][j] = dp[i-1][j"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def max_hets(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return max(nums)\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print(max_hets(nums))"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def findMaxNode(self, head):\n        # Write your code here\n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        \n        while slow:\n            if slow.next:\n                slow = slow.next\n            else:\n                break\n            \n        return slow\n        \n    def maxNode(self, head):\n        # Write your code here\n        if not head or not head.next:\n            return head\n        \n        # max_node = head.next.next if head.next else head\n        max_node = self.findMaxNode(head.next)\n        \n        while max_node.next:\n            max_node = self.findMaxNode(max_node.next)\n        \n        return max_node"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return nums[0]\n        # max_nums = []\n        # max_nums.append(nums[0])\n        # max_nums.append(max(nums[1:]))\n        # return max(max_nums)\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        max_nums = defaultdict(int)\n        for num in nums:\n            max_nums[num] = max(max_nums[num], num)\n        return max(max_nums.values())"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# TODO:\n# - Add in tests for the function\n# - Add in unit tests\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests for the function\n# - Add in unit tests for the function\n\n# TODO:\n# - Add in unit tests"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def max_in_list(list):\n    \"\"\"\n    Return the maximum value in a given heterogeneous list.\n\n    For example, given [3,2,2,1], the maximum value is 3.\n\n    Note:\n    You may assume all elements in the list are non-negative integers and fit in the 32-bit signed integer range.\n    \"\"\"\n    if not list:\n        return 0\n    max_value = list[0]\n    for i in range(1, len(list)):\n        if list[i] > max_value:\n            max_value = list[i]\n    return max_value\n\nclass Solution(object):\n    def maxInList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        max_value = nums[0]\n        for i in range(1, n):\n            if nums[i] > max_value:\n                max_value = nums[i]\n        return max_value"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "from collections import deque\n\nclass Solution:\n    # @param head, a list node\n    # @return an integer\n    def maxNodeValue(self, head):\n        if not head: return 0\n        curr = head\n        left = deque()\n        right = deque()\n        while curr:\n            if curr.next:\n                if curr.next.val > curr.val:\n                    curr.val = curr.next.val\n                    curr = curr.next\n                else:\n                    left.append(curr)\n                    curr = curr.next\n            else:\n                right.appendleft(curr)\n                curr = curr.next\n        if left:\n            curr = left.pop()\n            while curr.next:\n                curr = curr.next\n                if curr.next:\n                    curr.val = curr.next.val\n                    curr = curr.next\n                else:\n                    curr = left.pop()\n        else:\n            curr = right.popleft()\n            while curr.next:\n                curr = curr.next\n                if curr.next:\n                    curr.val = curr.next.val\n                    curr = curr.next\n                else:\n                    curr = right.popleft()\n        return curr.val\n\n\nif __name__ == \"__main__\":\n    head = None\n    head = Node(2)\n    head.next = Node(4)\n    head.next.next = Node(3)\n    head.next.next.next = Node(5)\n    print Solution().maxNodeValue(head)"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxHeterogeneity(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        max_h = 0\n        max_h_l = 0\n        max_h_r = 0\n        max_h_l_r = 0\n        max_h_r_l = 0\n        max_h_l_r_r = 0\n        max_h_r_l_r_r = 0\n        max_h_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max_h_r_l_r_r_r = 0\n        max"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "def max_value(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    max_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n    return max_val\n\n\n# Your MaxValue object will be instantiated and called as such:\n# obj = MaxValue()\n# param_1 = obj.max_value(arr)"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef find_max(list_of_values):\n    \"\"\"\n    :type list_of_values: List[int]\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    max_index = 0\n    for i, value in enumerate(list_of_values):\n        if value > max_value:\n            max_value = value\n            max_index = i\n    return max_index\n\n\ndef main():\n    \"\"\"\n    Add your code here.\n    \"\"\"\n    list_of_values = [1, 2, 3, 4, 5, 6]\n    print(find_max(list_of_values))\n    list_of_values = [1, 2, 3, 4, 5, 6, 7]\n    print(find_max(list_of_values))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums.sort()\n        return max(nums[0], self.max(nums[1:]))\n\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums.sort()\n        return max(nums[0], self.max(nums[1:]))\n\nif __name__ == \"__main__\":\n    nums = [4, 2, 1, 3, 5]\n    print(Solution().max(nums))"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxValue(self, root: TreeNode) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        return max(self.maxValue(root.left), self.maxValue(root.right)) + root.val\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(val=1, left=TreeNode(val=2), right=TreeNode(val=3))\n    print(sol.maxValue(root))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums)\n\n    def max_recursive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        return max(self.max_recursive(nums[1:]), nums[0])\n\n\nif __name__ == \"__main__\":\n    assert Solution().max([1, 2, 3, 4]) == 4\n    assert Solution().max([-2, -1, -3, -4]) == 4\n    assert Solution().max([-2, -1, 1, 3]) == 3\n    assert Solution().max_recursive([-2, -1, -3, -4]) == 4\n    assert Solution().max_recursive([-2, -1, 1, 3]) == 3"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n        \nclass Solution(object):\n    def maxVal(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        res = root.val\n        max_child = self.maxVal(root.children[0])\n        for child in root.children[1:]:\n            max_child = max(max_child, self.maxVal(child))\n        return max(res, max_child)"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-in-heterogeneous-array/\n# Given an array of objects, find the maximum value in the array.\n#\n# The objects in the array are either Integers, Doubles, or Strings.\n#\n# Example 1:\n# Input: [1, 2, 3, 1, 5, 9]\n# Output: 9\n# Explanation: The maximum in the array is 9, and the value of 9 is the string \"9\".\n#\n# Example 2:\n# Input: [2, 5, 1, 4, 8, 10, 13]\n# Output: 10\n# Explanation: The maximum in the array is 10, and the value of 10 is the string \"10\".\n#\n# Example 3:\n# Input: [2, 5, 9, 6, 1, 4, 8, 10]\n# Output: 10\n# Explanation: The maximum in the array is 10, and the value of 10 is the string \"10\".\n#\n# Example 4:\n# Input: [2, 9, 10, 8, 4]\n# Output: 9\n# Explanation: The maximum in the array is 9, and the value of 9 is the string \"9\".\n#\n# Note:\n# The length of the array won't exceed 1000.\n# The integers in the array are in the range of [-1000, 1000].\n# The strings in the array are in the range of [-10000, 10000].\n#\n\n# https://leetcode.com/problems/maximum-in-heterogeneous-array/discuss/108770/Python-O(N)-Time-Solution\nclass Solution(object):\n    def maxInArray(self, arr):\n        \"\"\"\n        :type arr: List[Any]\n        :rtype: int\n        \"\"\"\n        if not arr:\n            return 0\n        max_ = arr[0]\n        for i in arr:\n            if i > max_:\n                max_ = i\n            elif i < max_:\n                return max_\n        return max_\n\n# Time:  O(N)\n# Space: O(1)\n# Two pointers\nclass Solution2(object):\n    def maxInArray(self, arr):\n        \"\"\""
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxNodeValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        left = self.maxNodeValue(root.left)\n        right = self.maxNodeValue(root.right)\n        if left > right:\n            return left\n        return right\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    print(sol.maxNodeValue(root))"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {integer}\n\n    def maxNodeValue(self, head):\n        if not head:\n            return 0\n        max = head.val\n        max_node = head\n        while max_node.next:\n            max_node = max_node.next\n            if max_node.val > max:\n                max = max_node.val\n        return max"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution:\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        max_x = max_y = 0\n        max_count = 0\n        for p in points:\n            if p.x > max_x:\n                max_x = p.x\n            if p.y > max_y:\n                max_y = p.y\n            if p.x == max_x and p.y == max_y:\n                max_count += 1\n            else:\n                max_count = 1\n        return max_count"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def maxNodeVal(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: int\n        \"\"\"\n        max_node = None\n        max_val = 0\n        while head:\n            if max_node is None:\n                max_node = head\n                max_val = head.val\n            else:\n                if head.val > max_val:\n                    max_val = head.val\n                    max_node = head\n                elif head.val == max_val:\n                    max_node = max_node.next\n            head = head.next\n        return max_val"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n# https://leetcode.com/problems/maximum-in-heterogeneous-list/discuss/76654/C%2B%2B-Python-Solution-with-explanation\n\nclass Solution(object):\n    def max(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_val = 0\n        for num in nums:\n            if num > max_val:\n                max_val = num\n        return max_val\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.max([5, 1, 2, 3, 4]))\n    print(s.max([1, 2, 3, 4, 5]))\n    print(s.max([1, 2"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:ts=4:sw=4:softtabstop=4:smarttab:expandtab\n\n# Copyright (c) 2014 Kevin Breen (http://kevinbreen.com)\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport sys\nimport random\nimport collections\n\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxSumSubtree(self, root: Node) -> int:\n        if root is None:\n            return 0\n        max_sum = 0\n        left_max = self.maxSumSubtree(root.left)\n        right_max = self.maxSumSubtree(root.right)\n        if left_max > right_max:\n            max_sum = left_max\n        else:\n            max_sum = right_max\n        if root.val > 0:"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n    def maxValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        return max(root.val, max(self.maxValue(root.left), self.maxValue(root.right)))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import collections\n\ndef find_max(lst):\n    \"\"\"\n    :type lst: List\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for value in lst:\n        if value > max_value:\n            max_value = value\n    return max_value\n\n\ndef find_max_2(lst):\n    \"\"\"\n    :type lst: List\n    :rtype: int\n    \"\"\"\n    max_value = 0\n    for value in lst:\n        if value > max_value:\n            max_value = value\n    return max_value\n\n\ndef find_max_3(lst):\n    \"\"\"\n    :type lst: List\n    :rtype: int\n    \"\"\"\n    max_value = collections.defaultdict(int)\n    for value in lst:\n        max_value[value] += 1\n    return max(max_value.values())"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums: A list of integers\n    # @return: A integer indicate the answer\n    def maxValue(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        min_val = nums[0]\n        max_val = nums[0]\n\n        for num in nums:\n            if num > max_val:\n                max_val = num\n            elif num < min_val:\n                min_val = num\n\n        return max_val\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxValue([1, 2, 3])\n    print s.maxValue([2, 2, 3, 3])\n    print s.maxValue([3, 3, 3, 3])\n    print s.maxValue([3, 3, 2, 2, 2])"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {integer}\n    def maxNodeValue(self, head):\n        if not head:\n            return 0\n        cur = head\n        max_val = head.val\n        while cur.next:\n            if cur.next.val > max_val:\n                max_val = cur.next.val\n                cur = cur.next\n            else:\n                cur = cur.next\n        return max_val"
    }
  ]
}