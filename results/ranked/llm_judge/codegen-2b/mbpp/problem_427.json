{
  "timestamp": "2025-09-14T20:32:23.570662",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 427,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a bidirectional tuple.\nclass Tuple(object):\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __lt__(self, other):\n        return self.first < other.first\n\n    def __gt__(self, other):\n        return self.first > other.first\n\n    def __le__(self, other):\n        return self.first <= other.first\n\n    def __ge__(self, other):\n        return self.first >= other.first\n\n    def __eq__(self, other):\n        return self.first == other.first\n\n    def __ne__(self, other):\n        return self.first!= other.first\n\n    def __str__(self):\n        return str(self.first) + \":\" + str(self.second)\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for first, second in tuples:\n            first_ok = second_ok = False\n            for first_ok, second_ok in [(first < second, second > first),\n                                        (second < first, first > second)]:\n                if first_ok and second_ok:\n                    result += 2\n                elif first_ok:\n                    result += 1\n                elif second_ok:\n                    result += 2\n        return result"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def countBip(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum(tup.y for tup in tuples)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidir(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        d = {}\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    d[(i, j)] = d.get((i, j), 0) + 1\n                    d[(j, i)] = d.get((j, i), 0) + 1\n\n        return sum(d.values())\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    nums = []\n    for line in f:\n        nums.append(int(line))\n    print solution.countBidir(nums)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/count-and-say/\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        count = 0\n        stack = []\n        stack.append((root, 1))\n        while stack:\n            node, times = stack.pop()\n            if node.left is not None:\n                stack.append((node.left, times + 1))\n            if node.right is not None:\n                stack.append((node.right, times + 1))\n            if times == 1:\n                count += 1\n        return count\n\n# Note:\n# 1. the tree is assumed to be a binary tree\n# 2. the root is the left-most node of the tree"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in xrange(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                return i + 1\n        return 0"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __str__(self):\n        return str(self.x) +'' + str(self.y)\n\n\nclass Solution(object):\n    def countBipartite(self, root):\n        \"\"\"\n        :type root: Tuple\n        :rtype: int\n        \"\"\"\n        return self.countBipartite_rec(root, [])\n\n    def countBipartite_rec(self, root, counts):\n        if not root:\n            return 0\n        if not counts:\n            counts.append(0)\n        if root.x!= root.y:\n            counts[0] += 1\n            counts[1] += 1\n        else:\n            counts[0] += 1\n        counts[0] += self.countBipartite_rec(root.y, counts)\n        counts[1] += self.countBipartite_rec(root.x, counts)\n        return counts[0] + counts[1]\n\nif __name__ == '__main__':\n    root = Tuple(1, 2)\n    root.x = Tuple(2, 1)\n    root.y = Tuple(1, 2)\n    root.x.y = Tuple(2, 1)\n    root.y.x = Tuple(1, 2)\n    s = Solution()\n    print s.countBipartite(root)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def numBidirTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        pairs = 0\n        stack = []\n        stack.append(root)\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            if node.left and node.right:\n                pairs += 1\n        return pairs"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second step is\n# the same as the first step.\n# A more efficient solution is:\n# def count_bidirectional_pairs(tuples):\n#     return sum(count_pairs(tuples))\n\ndef count_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second step is\n# the same as the first step.\n# A more efficient solution is:\n# def count_bidirectional_pairs(tuples):\n#     return sum(count_pairs(tuples))\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for t in tuples:\n        for i in range(len(t)):\n            for j in range(i):\n                count[t[i], t[j]] += 1\n    return sum(count.values())\n\n# Note:\n# The following solution is similar to the one below but is more efficient.\n# The reason is that the count is computed in two steps, the second"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([1 for n1, n2 in zip(nums, nums[1:]) if n1 < n2])"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef count_bidirectional_tuples(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    t = defaultdict(int)\n    for tup in tuples:\n        t[tup] += 1\n        if tup[0]!= tup[1]:\n            t[tup[1]][tup[0]] += 1\n    return sum(t.values())\n\n\nif __name__ == '__main__':\n    tuples = [(1, 2), (1, 3), (2, 3), (1, 4), (2, 4), (3, 4)]\n    print(count_bidirectional_tuples(tuples))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def count_bidi(tup):\n    \"\"\"\n    :type tup: tuple\n    :rtype: int\n    \"\"\"\n    if len(tup) < 2:\n        return 0\n    cnt = 0\n    for i in range(len(tup) - 1):\n        if tup[i] == tup[i + 1]:\n            cnt += 1\n    return cnt\n\n\ndef count_bidi2(tup):\n    \"\"\"\n    :type tup: tuple\n    :rtype: int\n    \"\"\"\n    if len(tup) < 2:\n        return 0\n    cnt = 0\n    for i in range(len(tup) - 1):\n        if tup[i] == tup[i + 1]:\n            cnt += 1\n            i += 1\n    return cnt\n\n\nif __name__ == '__main__':\n    tup = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "import collections\n\n\nclass BidirectionalTuple(collections.namedtuple('BidirectionalTuple', ['first','second'])):\n    pass\n\n\ndef count_bidirectional_tuples(tuples):\n    \"\"\"\n    :type tuples: List[BidirectionalTuple]\n    :rtype: int\n    \"\"\"\n    # O(n^2)\n    count = 0\n    for tup in tuples:\n        if tup.first < tup.second:\n            count += 1\n    return count\n\n\ndef count_bidirectional_tuples2(tuples):\n    \"\"\"\n    :type tuples: List[BidirectionalTuple]\n    :rtype: int\n    \"\"\"\n    # O(n^2)\n    count = 0\n    for tup in tuples:\n        if tup.first < tup.second:\n            count += 1\n        elif tup.first > tup.second:\n            count += 1\n    return count"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def count_bidirectional_tuple(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    result = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            if tuples[i] == tuples[j]:\n                result += 1\n\n    return result\n\n\nif __name__ == '__main__':\n    tuples = [\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab', 'cd'),\n        ('ab',"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidir(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return sum(1 for i, j in zip(nums, nums[1:]) if i > j)\n\n    def countBidir_1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for i in nums if i > nums[i])\n\n\nif __name__==\"__main__\":\n    print(Solution().countBidir([3,3,1,2,2,3]))\n    print(Solution().countBidir_1([3,3,1,2,2,3]))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for i, j in zip(nums[::-1], nums[1::-1]) if i == j)"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(list)\n        for word in words:\n            for i in range(len(word)):\n                d[word[:i]].append(word[i:])\n        return sum(len(v) for v in d.values())\n\n\nif __name__ == \"__main__\":\n    words = [\"ab\", \"de\", \"cd\", \"d\", \"e\"]\n    print Solution().countBidirectionalPairs(words)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def countBipartite(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        count = 0\n        self.dfs(root, 0, 0, count)\n        return count\n\n    def dfs(self, root, depth, num, count):\n        if not root:\n            return\n        if depth == 2:\n            num += 1\n        if depth % 2:\n            self.dfs(root.left, depth + 1, num, count)\n        else:\n            self.dfs(root.right, depth + 1, num, count)\n        count += 1\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().countBipartite(root)"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\ndef count_bidirectional_tuple_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # key: (a, b) -> val = 1\n    # value: (b, a) -> val = 1\n    d = defaultdict(int)\n    for a, b in tuples:\n        d[(b, a)] += 1\n        d[(a, b)] += 1\n    return sum(d.values())\n\ndef main():\n    \"\"\"\n    Example:\n        >>> tuple_pairs = [(1, 2), (2, 1), (3, 4)]\n        >>> print(count_bidirectional_tuple_pairs(tuple_pairs))\n        2\n    \"\"\"\n    tuples = [(1, 2), (2, 1), (3, 4)]\n    print(count_bidirectional_tuple_pairs(tuples))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        m = [0] * (n + 1)\n        for i in range(1, n + 1):\n            m[i] = m[i - 1] + (nums[i - 1] < nums[i] and 1 or 0)\n        return m[n]"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def numBip(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for n in nums:\n            if n > 0:\n                count += 1\n        return count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, -1, 1, -1, 1, -1]\n    print s.numBip(nums)"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectional(self, nums):\n        return sum(1 for t1, t2 in zip(nums, nums[1:]))"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBipartitionPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return i+1\n        return 0\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.numBipartitionPairs([1,1,1])\n    print sol.numBipartitionPairs([1,2,3])\n    print sol.numBipartitionPairs([1,2,3,2])\n    print sol.numBipartitionPairs([1,2,3,4,5,6,7])"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        DP\n        :param nums: list\n        :return: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n + 1)\n        for i in xrange(1, n + 1):\n            for j in xrange(i):\n                if i == j:\n                    dp[i] += 1\n                elif j == nums[i - 1]:\n                    dp[i] += 1\n                elif j == nums[i]:\n                    dp[i] += 1\n                else:\n                    dp[i] += dp[j]\n\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.countBidirectionalPairs([1,2,2,3,1,4])\n    print sol.countBidirectionalPairs([1,2,3])\n    print sol.countBidirectionalPairs([1,2,3,4,5])"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/count-pairs/\n# tags: medium, array, bidirectional, hash\n\n\"\"\"\nGiven an array of integers, return the number of\ntuple pairs (a,b) such that a < b and a + b > 0.\n\"\"\"\n\n# O(n^2) solution\ndef count_pairs(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_2(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_3(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_4(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_5(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_6(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_7(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_8(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_9(nums):\n    return sum(i * (j - 1) for i, j in enumerate(nums))\n\n# O(n^2) solution\ndef count_pairs_10(nums):\n    return sum(i * (j - 1) for i, j in"
    },
    {
      "rank": 25,
      "score": 9.0,
      "candidate": "from collections import namedtuple\n\nPair = namedtuple('Pair', 'a b')\n\ndef count(seq):\n    count = 0\n    for i in range(len(seq)):\n        for j in range(i):\n            count += seq[i] == seq[j]\n    return count\n\nif __name__ == '__main__':\n    assert count((1, 2)) == 2\n    assert count((1, 2, 3)) == 3\n    assert count((1, 2, 3, 4)) == 4"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\n\ndef count_pairs(points):\n    \"\"\"\n    :type points: List[Point]\n    :rtype: int\n    \"\"\"\n    if not points:\n        return 0\n\n    def has_same_y(p1, p2):\n        return p1.y == p2.y\n\n    def has_same_x(p1, p2):\n        return p1.x == p2.x\n\n    def is_same_point(p1, p2):\n        return has_same_y(p1, p2) and has_same_x(p1, p2)\n\n    def get_same_point_count(points):\n        return sum(1 for p1 in points if is_same_point(p1, p2) for p2 in points if is_same_point(p1, p2))\n\n    return get_same_point_count(points)"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def count_bidir_tuples(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    if not tuple_list:\n        return 0\n    result = 0\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i][0] < tuple_list[j][0]:\n                result += 1\n            elif tuple_list[i][0] > tuple_list[j][0]:\n                result += 1\n    return result\n\nif __name__ == '__main__':\n    tuple_list = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 4), (2, 1)]\n    print(count_bidir_tuples(tuple_list))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "class TuplePairs:\n\n    def __init__(self, num_pairs):\n        self.num_pairs = num_pairs\n        self.count = 0\n\n    def count_pairs(self, tup1, tup2):\n        self.count += 1\n\n    def solve(self):\n        return self.count\n\nif __name__ == '__main__':\n    tup1, tup2 = (1, 2), (2, 1)\n    tup_pairs = TuplePairs(2)\n    tup_pairs.count_pairs(tup1, tup2)\n    print tup_pairs.solve()"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for word in words:\n            word_list = list(word)\n            for i in range(len(word_list) - 1):\n                if word_list[i] == word_list[i+1]:\n                    count += 1\n            for i in range(1, len(word_list)):\n                if word_list[i-1] == word_list[i]:\n                    count += 1\n        return count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssdd\"]\n    print s.countBidirectional(words)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        dic = {}\n        for word in words:\n            for i in range(len(word)):\n                j = i + 1\n                if j < len(word):\n                    if word[i] == word[j]:\n                        dic[word[i]] += 1\n        return sum(dic.values())\n\n\nif __name__ == \"__main__\":\n    words = [\"hello\", \"leetcode\"]\n    print Solution().countBidirectional(words)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for (i, j) in zip(nums, nums[1:] + nums[:1]))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([1 for i in range(len(nums)) if nums[i] == nums[i + 1]])"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef count_bidirectional_pairs(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    count = defaultdict(int)\n    for tup in tuples:\n        for i in range(len(tup)):\n            for j in range(i+1, len(tup)):\n                if tup[i] == tup[j]:\n                    count[tup[i]] += 1\n    return sum(count.values())\n\nif __name__ == '__main__':\n    tuples = [\n        [1, 2, 3, 4],\n        [1, 2, 4, 5],\n        [2, 3, 4, 5],\n        [1, 3, 4, 5],\n        [1, 4, 4, 5],\n        [4, 4, 4, 5],\n        [3, 4, 4, 5],\n    ]\n    print(count_bidirectional_pairs(tuples))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for word in words if word[::-1] == word[1:])"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def count_bidi_tuple_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    return sum(1 for t1, t2 in combinations(tuples, 2))\n\nif __name__ == \"__main__\":\n    tuples = [(1, 2), (2, 3), (1, 3), (1, 4), (2, 4), (3, 4)]\n    print(count_bidi_tuple_pairs(tuples))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "class TuplePair:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\ndef count_bidir_tuples(tuples):\n    \"\"\"\n    :type tuples: List[TuplePair]\n    :rtype: int\n    \"\"\"\n    return sum(1 for t in tuples if t.a == t.b)\n\nif __name__ == '__main__':\n    tuples = [TuplePair(1, 2), TuplePair(2, 1), TuplePair(2, 3), TuplePair(3, 2), TuplePair(3, 4)]\n    print(count_bidir_tuples(tuples))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "class Tuple:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __eq__(self, other):\n        return self.first == other.first and self.second == other.second\n\ndef count(tup1, tup2):\n    return tup1.first == tup2.second and tup1.second == tup2.first\n\nif __name__ == '__main__':\n    tups = [Tuple(1, 2), Tuple(2, 1), Tuple(1, 3), Tuple(3, 1), Tuple(1, 4), Tuple(4, 1)]\n    print(count(tups[0], tups[2]))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(nums[i]!= nums[j] for i in range(len(nums)) for j in range(i+1, len(nums)))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        return sum(sum(i < j for i in nums) for j in nums)"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "class TuplePairCounter:\n    def __init__(self):\n        self.pair_counts = {}\n\n    def count_pairs(self, t1, t2):\n        if t1 not in self.pair_counts:\n            self.pair_counts[t1] = {}\n        if t2 not in self.pair_counts[t1]:\n            self.pair_counts[t1][t2] = 0\n        self.pair_counts[t1][t2] += 1\n\n    def get_pairs(self, t1):\n        if t1 not in self.pair_counts:\n            return []\n        return self.pair_counts[t1].keys()\n\n    def get_count(self, t1, t2):\n        return self.pair_counts[t1][t2]\n\n\ndef main():\n    tuple_counter = TuplePairCounter()\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    tuple_counter.count_pairs(t1, t2)\n    print tuple_counter.get_pairs(t1)\n    print tuple_counter.get_pairs(t2)\n    print tuple_counter.get_count(t1, t2)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def countBipartitie(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(1 for _ in range(len(nums)) if nums[-1] < nums[-2])"
    },
    {
      "rank": 42,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution(object):\n    def countBidirectionalPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        if not tuples:\n            return 0\n\n        return sum([1 if (t1 == t2) else 0 for t1, t2 in zip(tuples[:-1], tuples[1:])])"
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * (n * (n + 1))\n        for i in range(n):\n            dp[i * (i + 1) // 2] += nums[i]\n\n        return sum(dp[j] for j in range(n + 1))"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        return sum(1 for i in range(len(nums)) if i > 0 and nums[i] < nums[i - 1])"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __str__(self):\n        return str(self.x) + ',' + str(self.y)\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum([1 for t1 in tuples if t1[0] == t1[1]])"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "class Solution:\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        \n        nums.sort()\n        \n        return sum(1 for x,y in zip(nums[1:], nums[:-1]) if x == y)"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "import collections\n\nclass Solution:\n    # @return an integer\n    def numBidirectionalPairs(self, words):\n        if not words:\n            return 0\n        word_set = collections.defaultdict(int)\n        for w in words:\n            word_set[w] += 1\n        word_set = {k: v for k, v in word_set.items() if v > 1}\n        result = 0\n        for word, count in word_set.items():\n            for i in range(count):\n                for j in range(i + 1, count):\n                    result += 1\n        return result"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if not words:\n            return 0\n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n        return count"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return '({0}, {1})'.format(self.x, self.y)\n\nclass Solution(object):\n    def countBip(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for t1 in tuples:\n            for t2 in tuples:\n                if t1 == t2:\n                    continue\n                if t1.__eq__(t2):\n                    count += 1\n        return count\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBip(tuples)"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    count += 1\n                if nums[i] > nums[j]:\n                    count += 1\n        return count\n\nnums = [1, 2, 3, 3, 4, 5, 6, 7, 8, 8]\nprint(Solution().countBidirectionalPairs(nums))"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        dp = [[0 for j in range(n)] for i in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n            for j in range(i):\n                if j > i:\n                    break\n                dp[i][j] += dp[i-1][j]\n        return sum(dp[n-1])"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "# https://oj.leetcode.com/problems/count-bidirectional-tuple-pairs/\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            if node is None:\n                return 0\n            res = 0\n            if node.left is not None:\n                res += dfs(node.left)\n            if node.right is not None:\n                res += dfs(node.right)\n            return res + 1\n\n        return dfs(root)\n\n\nif __name__ == \"__main__\":\n    print(Solution().countBidirectionalTuplePairs(None))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1)))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1, TreeNode(2), TreeNode(3))))\n    print(Solution().countBidirectionalTuplePairs(TreeNode(1, TreeNode(2), TreeNode(3), TreeNode(4))))"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        # TODO\n        return 0\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.countBidirectionalPairs([\"hello\", \"world\"])"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[j][i] = 1\n        return sum(dp[0])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numBidirectionalPairs([1, 1, 1]))"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n# Forbid duplicates\ndef count_pairs(l):\n    c = Counter(l)\n    return sum(c.values())\n\nif __name__ == '__main__':\n    assert count_pairs([1, 2, 3, 4, 5, 6]) == 0\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 7]) == 6\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8]) == 15\n    assert count_pairs([1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 6, 7, 8, 8, 8, 9]) == 23"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        # write your code here\n        if not nums:\n            return 0\n\n        n = len(nums)\n        if n == 1:\n            return 1\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] == nums[j]:\n                    count += 1\n\n        return count\n\n\nif __name__ == '__main__':\n    print Solution().numBidirectionalPairs([1, 1])"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n*(n-1))\n        for i in range(n):\n            for j in range(i+1, n):\n                dp[i*n+j] = dp[j*n+i] + 1\n        return sum(dp[i*n+j-1] for i in range(1, n))"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "class TuplePairs:\n    def __init__(self, tup):\n        self.tup = tup\n        self.count = 0\n\n    def __iter__(self):\n        for i in range(len(self.tup) - 1):\n            for j in range(i + 1, len(self.tup)):\n                if (self.tup[i] == self.tup[j] and\n                    self.tup[i]!= self.tup[j]):\n                    self.count += 1\n                    yield (self.tup[i], self.tup[j])\n\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        tup = tuple(nums)\n        return sum(1 for _ in TuplePairs(tup))\n\n\nif __name__ == '__main__':\n    assert Solution().countBidirectionalPairs([1, 1]) == 2\n    assert Solution().countBidirectionalPairs([2, 2]) == 0"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * (n * (n - 1))\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[(i * (n - 1)) + j] = dp[(i * (n - 1)) + j - 1] + 1\n                if i == j - 1:\n                    dp[(i * (n - 1)) + j] += 1\n        return sum(dp)"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j] and i!= j:\n                    count += 1\n        \n        return count\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.numBidirectionalPairs([1,2,2,3,3,3,4,4,4,4])"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        return sum(1 for i in range(n - 1) if nums[i] > nums[i + 1])\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countBidirectionalPairs([1, 2, 3, 3, 1]))\n    print(sol.countBidirectionalPairs([1, 2, 3, 2, 1]))\n    print(sol.countBidirectionalPairs([1, 1, 2, 3]))\n    print(sol.countBidirectionalPairs([1, 1, 2, 2]))\n    print(sol.countBidirectionalPairs([1, 2, 3, 4, 5]))"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/discuss/703514/Python-Cython-solution-with-recursion-and-iteration\n\nclass Solution:\n    # @return an integer\n    def countBidirectionalTuplePairs(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not edges:\n            return 0\n        \n        # count the number of bidirectional tuple pairs\n        return self.countBidirectionalTuplePairs_rec(edges, 0, edges[0], 1)\n    \n    # recursion\n    def countBidirectionalTuplePairs_rec(self, edges, i, start, direction):\n        # base case\n        if i == len(edges):\n            return 1\n        \n        # get the next edge\n        end = edges[i][direction]\n        \n        # recursion\n        return self.countBidirectionalTuplePairs_rec(edges, i+1, end, direction^1) + self.countBidirectionalTuplePairs_rec(edges, i+1, start, direction^1)\n        \n    # iterative\n    def countBidirectionalTuplePairs_iter(self, edges):\n        # base case\n        if not edges:\n            return 0\n        \n        # iterate over all edges\n        count = 0\n        for i in range(len(edges)):\n            # get the next edge\n            end = edges[i][1]\n            \n            # iterate over all edges\n            for j in range(i+1, len(edges)):\n                # get the next edge\n                start = edges[j][0]\n                \n                # iterate over all edges\n                for k in range(j+1, len(edges)):\n                    # get the next edge\n                    start = edges[k][0]\n                    \n                    # iterate over all edges\n                    for l in range(k+1, len(edges)):\n                        # get the next edge\n                        end = edges[l][1]"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for word in words if word[::-1] == word[1::-1])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    words = [\"a\", \"a\", \"b\", \"ab\", \"ba\", \"b\", \"c\", \"cb\", \"cd\", \"cd\", \"da\", \"da\", \"dc\", \"dc\", \"d\", \"e\", \"ea\", \"eb\", \"ec\", \"ed\", \"e\"]\n    print s.countBidirectionalPairs(words)"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __repr__(self):\n        return str(self.x) + \",\" + str(self.y)\n\n\nclass Solution:\n    def countBip(self, t1, t2):\n        \"\"\"\n        :type t1: Tuple\n        :type t2: Tuple\n        :rtype: int\n        \"\"\"\n        if t1.x == t2.x:\n            return t1.y\n        elif t1.x > t2.x:\n            return self.countBip(t2, t1)\n        else:\n            return self.countBip(t1, t2)\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBip(t1,t2)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] < nums[j]:\n                    cnt += 1\n        return cnt"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution:\n    def countBidirectionalPairs(self, words: 'List[str]') -> 'int':\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(int)\n        for word in words:\n            for i in range(len(word)):\n                for j in range(i + 1, len(word)):\n                    d[(word[i], word[j])] += 1\n        return sum(d.values())\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.countBidirectionalPairs([\"abc\", \"de\", \"fgh\", \"ijk\", \"klm\"]))"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] == words[j]:\n                    cnt += 1\n        return cnt"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    res += 1\n                    if i > j:\n                        res += 1\n\n        return res"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def countBidirectionalTuplePairs(self, nums):\n        ans = 0\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] == nums[j]:\n                    ans += 1\n        return ans"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution(object):\n    def countBipartite(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        d = dict()\n        for x in nums:\n            d[x] = d.get(x, 0) + 1\n\n        dp = [0 for i in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                if (d[nums[i]] == 1 and d[nums[j]] == 1):\n                    dp[i] = dp[i] + dp[j]\n                    dp[j] = dp[i]\n        return dp[0]"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if len(words) < 2:\n            return 0\n        \n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n                    \n        return count"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: A integer\n    \"\"\"\n    def numBidirTuple(self, nums):\n        \"\"\"\n        @param nums: A list of integers\n        @return: A integer\n        \"\"\"\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] == nums[j] and i!= j:\n                    dp[i] += dp[j]\n        return dp[-1]"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        if n <= 1:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i-1] + dp[i-1]\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i] += dp[j]\n        return dp[n-1]"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBidirectionalPairs(self, nums):\n        if not nums:\n            return 0\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i+1]:\n                count += 1\n        return count"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/discuss/182637/Java-Python-Python-tuple-pair-count\n\nclass Solution:\n    # @param {List[Tuple[int]]} tuples\n    # @return {integer}\n    def countBidirectionalPairs(self, tuples):\n        return sum(1 for t in tuples if t[0] == t[1] and t[0] == t[2])\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.countBidirectionalPairs([(1,2),(2,3),(1,3),(1,2)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,2),(1,3),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,3)])\n    print s.countBidirectionalPairs([(1,2),(1,3),(2,3),(1,3),(1,2),(2,3),(1,2),(1,3),(2,3),(1,3),(1,2),(2"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(list)\n        for word in words:\n            d[word].append('<')\n            d[word].append('>')\n        return sum(d[word] for word in words)"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\nclass Solution:\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(int)\n        for word in words:\n            for i in range(len(word)):\n                d[word[:i]] += 1\n                d[word[i+1:]] += 1\n        return sum(d.values())"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution:\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j] and nums[i] < nums[j]:\n                    result += 1\n        return result"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] < nums[i+1]:\n                count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.countBidirectional([1,2,3,4,5])"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {List<List<Integer>>} grid\n    # @return {integer}\n    def numBidirectionalTuple(self, grid):\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        if m == 1:\n            return 0\n\n        grid = [[int(i) for i in str(grid[0][i])] for i in range(n)]\n        pairs = 0\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    pairs += 1\n                    grid[i][j] = '0'\n                    pairs += 1\n                    grid[i][j] = '1'\n        return pairs\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    grid = [['1', '1', '0', '1', '1'],\n            ['0', '0', '0', '0', '0'],\n            ['1', '0', '1', '1', '0']]\n    print(sol.numBidirectionalTuple(grid))\n    grid = [['1', '1', '1', '0', '0'],\n            ['0', '1', '0', '1', '1'],\n            ['1', '0', '0', '0', '0']]\n    print(sol.numBidirectionalTuple(grid))\n    grid = [['1', '1', '1', '1', '0'],\n            ['0', '1', '0', '1', '0'],\n            ['1', '0', '0', '0', '0']]\n    print(sol.numBidirectionalTuple(grid))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from collections import namedtuple\n\n\ndef count_bidirectional(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: int\n    \"\"\"\n    t = namedtuple('t', 'x y')\n    result = 0\n    for tup in tuples:\n        x, y = t(*tup)\n        if x!= y:\n            result += 1\n    return result\n\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 1),\n        (1, 2),\n        (1, 3),\n        (2, 1),\n        (2, 2),\n        (2, 3),\n        (3, 1),\n        (3, 2),\n        (3, 3),\n    ]\n    print(count_bidirectional(tuples))"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBipartitngPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_i = n - 1\n        sum = 0\n        for i in range(max_i):\n            sum += nums[i]\n            for j in range(i + 1, max_i):\n                sum += nums[j]\n                if i!= j and sum >= nums[i] + nums[j]:\n                    return sum - nums[i] - nums[j]\n        \n        return 0"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return str(self.x) +'' + str(self.y)\n\n\nclass Solution:\n    # @param {Tuple[]} tuples\n    # @return {int}\n    def countBidirectional(self, tuples):\n        count = 0\n        for i in range(len(tuples)):\n            for j in range(i):\n                if tuples[i] == tuples[j]:\n                    count += 1\n        return count\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.countBidirectional([(1, 2), (2, 3), (3, 1), (4, 5)])"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution:\n    def countBidir(self, t: List[Tuple]) -> int:\n        if not t:\n            return 0\n        num = 0\n        for i in range(len(t)):\n            for j in range(i+1, len(t)):\n                if t[i].x == t[j].x:\n                    num += 1\n        return num"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for a bidirectional tuple.\nclass Tuple:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution:\n    def countBidirectional(self, tuples: List[Tuple]) -> int:\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return sum(1 for t in tuples for _ in t)\n\n# TESTS\nfor tuples, expected in [\n    ([(1, 2), (3, 4)], 2),\n    ([(1, 2), (3, 4, 5)], 3),\n    ([(1, 2), (3, 4), (5, 6)], 3),\n    ([(1, 2, 3), (4, 5, 6)], 3),\n    ([], 0),\n    ([(1, 2), (3, 4, 5)], 3),\n    ([(1, 2), (3, 4, 5), (6, 7, 8)], 3),\n    ([(1, 2, 3), (4, 5, 6)], 3),\n    ([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 3),\n    ([(1, 2), (3, 4, 5)], 3),\n]:\n    sol = Solution()\n    actual = sol.countBidirectional(tuples)\n    print(\"The count of bidirectional tuple pairs is\", actual)\n    assert actual == expected"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        n = len(words)\n        m = {}\n        for w in words:\n            if w in m:\n                m[w] += 1\n            else:\n                m[w] = 1\n\n        return sum(m[a]*m[b] for a, b in m.items() if a!= b)"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {List<List<Integer>>} grid\n    # @return {integer}\n    def numBidirectionalTuple(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        ret = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i < m-1:\n                        if grid[i+1][j] == 1:\n                            ret += 1\n                    if j < n-1:\n                        if grid[i][j+1] == 1:\n                            ret += 1\n        return ret"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectional(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 for _ in words)\n        \n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.countBidirectional(words)"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def numBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        if not words:\n            return 0\n        return sum(1 for _ in words) // 2"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = x\n\n    def __lt__(self, other):\n        return self.x < other.x and self.y < other.y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return str(self.x) + str(self.y)\n\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        cnt = 0\n        for i in range(1, len(nums)):\n            if nums[i-1].y == nums[i].y:\n                cnt += 1\n            elif nums[i-1].y > nums[i].y:\n                cnt += (nums[i-1].x - nums[i].x + 1) * (nums[i-1].y - nums[i].y + 1)\n        return cnt"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer\n    \"\"\"\n    def countBidirectionalPairs(self, nums):\n        return self.count_pairs(nums, 0, len(nums) - 1)\n        \n    def count_pairs(self, nums, start, end):\n        if start == end:\n            return 1\n        count = 0\n        while start < end:\n            if nums[start] == nums[end]:\n                count += 1\n                start += 1\n                end -= 1\n            else:\n                start += 1\n        return count"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\nclass Solution(object):\n    def countBidir(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for t1, t2 in tuples:\n            if t1.y == t2.y:\n                count += 1\n            else:\n                count += 1\n                if t1.y!= None:\n                    count -= 1\n                if t2.y!= None:\n                    count -= 1\n        return count"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n# https://leetcode.com/problems/count-bidirectional-tuple-pairs/solution/\n# https://leetcode.com/problems/count-bidirectional-tuple-pairs/\n\nclass Solution(object):\n    def countBidirectionalTuplePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            for j in range(i):\n                if nums[i] < nums[j]:\n                    if nums[i] == nums[j] + 1:\n                        count += 2\n                    elif nums[i] == nums[j] - 1:\n                        count += 2\n                else:\n                    if nums[i] == nums[j] - 1:\n                        count += 2\n                    elif nums[i] == nums[j] + 1:\n                        count += 2\n        \n        return count"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        pairs = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i][::-1] == words[j][::-1]:\n                    pairs += 1\n        return pairs"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/count-bidirectional-tuple-pairs/description/\n\nclass Solution(object):\n    def countBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in xrange(len(words)):\n            for j in xrange(i+1, len(words)):\n                if words[i] == words[j]:\n                    count += 1\n        return count\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.countBidirectionalPairs(['a','b','c'])\n    print s.countBidirectionalPairs(['a','b','c','d'])"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def numBidirectionalPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        d = {}\n        for w in words:\n            d[w] = d.get(w, 0) + 1\n        for w in d:\n            d[w] = d[w] - 1\n        return sum(d.values())\n\nif __name__ == \"__main__\":\n    words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"abcdcdcdc\"]\n    sol = Solution()\n    print(sol.numBidirectionalPairs(words))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\n\nclass Solution(object):\n    def countBidirectional(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for t in tuples:\n            if t.y is None:\n                res += 1\n            else:\n                res += 2\n        return res"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numBip(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return self.bip(nums, 0, len(nums))\n\n    def bip(self, nums, start, end):\n        if start == end:\n            return 1\n        if start == end - 1:\n            return 2\n        if start == end - 2:\n            return 3\n        if start == end - 3:\n            return 4\n        return self.bip(nums, start + 1, end - 1) + self.bip(nums, start + 2, end - 2) + self.bip(nums, start + 3, end - 3) + self.bip(nums, start + 4, end - 4)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://oj.leetcode.com/problems/count-bidirectional-tuple-pairs/\n# Write an efficient algorithm that counts the number of bi-directional tuple\n# pairs.\n# The tuple (x, y) is bidirectional if y < x and x < y.\n# Example 1:\n# Input:\n# (2,1), (1,2)\n# Output: 1\n# Example 2:\n# Input:\n# (0, 1), (1, 2), (2, 3), (3, 4), (4, 5)\n# Output: 2\n# Example 3:\n# Input:\n# (0, 1), (2, 3), (4, 5)\n# Output: 0\n# Note:\n# The pairs (x, y) and (y, x) count as the same pair.\n# The input is always valid, each tuple is a valid pair of integers.\n# The input is sorted.\n#\n# Companies\n# Microsoft\n# Related Topics\n# Two Pointers\n# Similar Questions\n# Sort Two Pointers\n#\nimport unittest\nclass Solution(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                count += 1\n        return count\n\nclass Solution2(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                count += 1\n        return count\n\nclass Solution3(object):\n    def countBidirectionalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        count = 0\n        for i"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef bidir_pairs(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: int\n    \"\"\"\n    # store count of each pair\n    count = defaultdict(int)\n    for t1, t2 in tuples:\n        count[t1, t2] += 1\n        count[t2, t1] += 1\n    return sum(count.values())\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# BFS\n# 1. Traverse each tuple pair, find each pair and update count\n# 2. return sum of each pair\n# 3. each pair is a tuple pair\n# 4. sum of each pair\nclass Solution(object):\n    def bidirPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: int\n        \"\"\"\n        return bidir_pairs(tuples)"
    }
  ]
}