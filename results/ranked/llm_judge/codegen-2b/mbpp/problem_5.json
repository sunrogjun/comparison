{
  "timestamp": "2025-09-14T17:24:05.691407",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 5,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        if len(s) < len(p):\n            return []\n        ans = []\n        for i in range(len(s)):\n            curr = s[i:i + len(p)]\n            if curr in ans:\n                ans.remove(curr)\n            else:\n                ans.append(curr)\n        return ans"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        if len(s) == 0:\n            return res\n        if len(p) == 0:\n            return res\n        if len(p) > len(s):\n            return res\n        \n        for i in range(len(s)):\n            if s[i] not in p:\n                continue\n            if p[i] not in p:\n                continue\n            if p[i]!= s[i]:\n                continue\n            \n            if i + 1 < len(p) and p[i] == p[i + 1]:\n                continue\n            \n            res.append(s[:i + 1])\n        return res"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        s_lower = s.lower()\n        p_lower = p.lower()\n        res = []\n        for i in xrange(len(s_lower)):\n            for j in xrange(len(p_lower)):\n                if s_lower[i:i+j] == p_lower[j:j+1]:\n                    res.append(s[i:i+j])\n                    break\n        return res\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findAnagrams(\"anagram\", \"nagaram\")"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        anagrams = []\n        if not p:\n            return anagrams\n\n        p = p.lower()\n        s = s.lower()\n        # build hash table\n        table = {}\n        for c in p:\n            table[c] = table.get(c, 0) + 1\n        # count occurrences of each character\n        count = [0] * 256\n        for c in s:\n            count[ord(c)] += 1\n        # find all occurrences of each character in the string\n        for c in range(256):\n            if count[c] % table[c] == 0:\n                anagrams.append(s[:count[c]])\n        return anagrams\n\nif __name__ == \"__main__\":\n    assert Solution().findAnagrams(\"racecar\", \"abc\") == [\"abc\"]\n    assert Solution().findAnagrams(\"racecar\", \"racecar\") == []\n    assert Solution().findAnagrams(\"racecar\", \"racecarracecar\") == [\"racecarracecar\"]\n    assert Solution().findAnagrams(\"racecar\", \"racecarracecarracecar\") == [\"racecarracecar\"]"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.dict = {}\n        self.s = \"\"\n        self.n = 0\n\n    def findAnagrams(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: List[str]\n        \"\"\"\n        self.dict = dict()\n        self.s = str\n        self.n = len(str)\n        return self.findAnagrams_recursion()\n\n    def findAnagrams_recursion(self):\n        if self.n == 0:\n            return [self.s]\n        elif self.n == 1:\n            return []\n        else:\n            # find the first index of each character\n            # then find the first index of all the same character\n            # then remove the char\n            # repeat until the str is empty\n            ans = []\n            for i in range(self.n):\n                ch = self.s[i]\n                if ch not in self.dict:\n                    self.dict[ch] = []\n                self.dict[ch].append(i)\n            for c in self.dict:\n                if len(self.dict[c]) > 1:\n                    for i in range(self.n):\n                        if self.s[i] == c:\n                            for j in range(i, self.n):\n                                if self.s[j] == c:\n                                    self.s = self.s[:i] + self.s[j+1:]\n                                    ans.append(self.s)\n            return ans"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        #TODO\n        return []\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findAnagrams('banana', 'bana')\n    print s.findAnagrams('racecar', 'carrac')\n    print s.findAnagrams('abcdefg', 'defabc')"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import unittest\n\nclass Solution:\n    def findSequence(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: str\n        \"\"\"\n        return '_'.join(sorted(set(str)))\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# 1ms 100%\nclass Solution {\n    public String findSequence(String str) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) >= 'a' && str.charAt(i) <= 'z') {\n                sb.append('_');\n            }\n            sb.append(str.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public String findSequence(String str) {\n        char[] arr = str.toCharArray();\n        Arrays.sort(arr);\n        return new String(arr);\n    }\n}\n'''"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from collections import deque\n\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        if not s or not p:\n            return result\n        s = set(s)\n        p = set(p)\n        result.append(s.intersection(p))\n        p.remove(p.pop())\n        while p:\n            s = s & p\n            result.append(s.intersection(p))\n            p.remove(p.pop())\n        return result"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findRepeatedDnaSequences(self, s):\n        # write your code here\n        result = []\n        count = 1\n        seen = {}\n        for i in range(len(s)):\n            if s[i] not in seen:\n                seen[s[i]] = 1\n            else:\n                seen[s[i]] += 1\n            if seen[s[i]] > 1:\n                count += 1\n            else:\n                seen[s[i]] = 0\n                if seen[s[i]] == 0:\n                    result.append(s[i:i+count])\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findRepeatedDnaSequences(\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\")"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        # sort string in order of length\n        strs = sorted(strs, key=len, reverse=True)\n        result = []\n        for i in range(len(strs)):\n            # join first i strings\n            j = i\n            while j < len(strs):\n                # join next string\n                tmp = strs[j]\n                strs[j] = strs[i]\n                strs[i] = tmp\n                j += 1\n            result.append(strs[i])\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    strs = [\"abc\", \"cde\", \"def\"]\n    print(s.findAnagrams(strs))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSubsequences(self, s):\n        res = []\n        for i in range(len(s)):\n            if s[i] == '_':\n                res.append(s[:i])\n                s = s[i+1:]\n        return res\n\nif __name__ == '__main__':\n    print Solution().findSubsequences('abbbcddeeffg_')"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\ndef find_sequences(sentence):\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function that finds all the sequences of lowercase letters in a sentence\n    # TODO: write a function"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.ans = []\n        self.s = \"\"\n\n    def findAnagrams(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        self.s = s\n        self.ans = self.findAnagrams_aux(s)\n        return self.ans\n\n    def findAnagrams_aux(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        res = []\n        for c in s:\n            if c not in self.s:\n                self.s = self.s[:-1]\n                break\n            self.s = self.s[:-1]\n        for i in xrange(len(self.s)):\n            for j in xrange(len(self.s)):\n                if self.s[i:j+1] == self.s[j:i+1]:\n                    res.append(self.s[i:j+1])\n        return res"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def find_sequences(text):\n    def find_sequence(text, pos):\n        if pos == len(text):\n            return pos\n        if text[pos]!= '_':\n            return pos\n        return find_sequence(text, pos+1)\n    return find_sequence(text, 0)\n\ndef main():\n    text = '__'\n    print(find_sequences(text))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        #return self.findAnagrams(s, p, 0, 0)\n        return self.findAnagrams(s, p, 0, len(s))\n        \n    def findAnagrams(self, s, p, start, end):\n        if start == end:\n            yield s[start]\n        else:\n            for i in xrange(start, end):\n                if s[i] in p:\n                    s1 = s[start:i]\n                    s2 = s[i+1:end]\n                    s1 = s1.lower()\n                    s2 = s2.lower()\n                    if s1 == s2:\n                        yield s[start:i]\n                        yield s[i+1:end]\n                        return\n                    else:\n                        yield from self.findAnagrams(s, p, i+1, end)\n            return\n        \nif __name__ == '__main__':\n    s = Solution()\n    print s.findAnagrams('cabbd', 'abc')"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-the-duplicates-of-an-array-of-numbers/description/\n\n# For example, given:\n# nums = [1,2,3,1,2,3,3,2,3,4,3,4,3,5,5,6,7]\n# Return: [1,2,3,3,2,3,4,5,6,7]\n\n# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = []\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                result.append(nums[i])\n            else:\n                break\n        return result"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        p = p.lower()\n        s = s.lower()\n        if len(s) < len(p):\n            return result\n        for i in range(len(p)):\n            if p[i] in s:\n                if i == 0 or p[i]!= p[i-1]:\n                    result.append(s[i:])\n        return result\n\ns = Solution()\n\ns.findAnagrams(\"cbaebabacd\", \"abc\")"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/find-repeated-characters/\n\nclass Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findRepeatedDnaSequences(self, s):\n        if not s:\n            return []\n\n        seen = set()\n        res = []\n        for i in range(len(s)):\n            if s[i] in seen:\n                continue\n            seen.add(s[i])\n            res.append(s[:i] + \"_\" + s[i:])\n        return res\n\n\nif __name__ == \"__main__\":\n    print(Solution().findRepeatedDnaSequences(\"AAAAACACAA\"))\n    print(Solution().findRepeatedDnaSequences(\"AAAAATAAAAA\"))\n    print(Solution().findRepeatedDnaSequences(\"AAAA\"))\n    print(Solution().findRepeatedDnaSequences(\"\"))\n    print(Solution().findRepeatedDnaSequences(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))\n    print(Solution().findRepeatedDnaSequences(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))\n    print(Solution().findRepeatedDnaSequences(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-all-n-grams-of-a-string/discuss/162321/Python-solution-with-explanation\n\n# Definition for a  word:  `string`\n# class Word:\n#     def __init__(self, s: str):\n#         self.s = s\n#         self.n = len(s)\n#         self.words = []\n#         self.visited = set()\n#     def addWord(self, word: Word) -> None:\n#         self.words.append(word)\n#         self.visited.add(word.s)\n#         for i in range(2, len(word.s)):\n#             w = Word(word.s[:i])\n#             w.addWord(word)\n#             self.visited.add(w.s)\n#     def __str__(self):\n#         return self.s\n\n# @param s, a string\n# @return a list of strings, all the n-grams\n# def findNgrams(s: str) -> List[str]:\n#     n = len(s)\n#     result = []\n#     for i in range(2, n + 1):\n#         result.append(s[:i])\n#         for j in range(i, n + 1):\n#             result.append(s[j:i + 1])\n#     return result\n\n\n# @param s, a string\n# @return a list of strings, all the n-grams\ndef findNgrams(s: str) -> List[str]:\n    if len(s) == 0:\n        return []\n    if len(s) == 1:\n        return [s]\n    result = []\n    for i in range(2, len(s) + 1):\n        for j in range(i, len(s) + 1):\n            result.append(s[:i] + s[j:i + 1])\n    return result\n\n\nif __name__ == '__main__':\n    s = 'abc'\n    print(findNgrams(s))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-the-repeated-characters-in-an-email-address/discuss/106763/Python-solution-with-explanation-and-explaination\n\nclass Solution(object):\n    def findRepeatedDnaSequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # TODO: write a better solution\n        # https://leetcode.com/problems/find-the-repeated-characters-in-an-email-address/discuss/113600/Python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/813/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/8135/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/9061/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/8132/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/9084/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/9102/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/9106/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode.com/topic/8134/python-solution-with-explanation-and-explanation-and-explaination\n        # https://discuss.leetcode."
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    return [s]"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "import collections\n\n# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param root, a tree node\n\t# @return a list of lists of strings\n\tdef findSequences(self, root):\n\t\tresult = []\n\t\tdef dfs(node):\n\t\t\tif node is None:\n\t\t\t\treturn\n\t\t\tif node.left is None and node.right is None:\n\t\t\t\tresult.append(node.val)\n\t\t\telif node.left is not None:\n\t\t\t\tdfs(node.left)\n\t\t\telif node.right is not None:\n\t\t\t\tdfs(node.right)\n\t\tdfs(root)\n\t\treturn result\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.left.left = TreeNode(3)\nroot.left.right = TreeNode(4)\nroot.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\n\ns = Solution()\nprint(s.findSequences(root))"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: List[str]\n        \"\"\"\n        # use hashmap to store all the same chars\n        # use a hashmap to store all the same chars\n        # use a hashmap to store all the same chars\n        # use a hashmap to store all the same chars\n        hashmap = {}\n        for c in str1:\n            if c in hashmap:\n                hashmap[c] += 1\n            else:\n                hashmap[c] = 1\n\n        count = 0\n        ans = []\n        for c in str2:\n            if c in hashmap:\n                count += 1\n                if count == len(str2):\n                    ans.append(str1[:count])\n            hashmap.pop(c)\n        return ans"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "class Solution:\n\t# @param s, a string\n\t# @return a list of strings\n\tdef findSequence(self, s):\n\t\t# base case\n\t\tif len(s) == 0:\n\t\t\treturn []\n\t\t# base case\n\t\tif s[0]!= '_':\n\t\t\treturn [s]\n\n\t\t# recursive case\n\t\tl = []\n\t\tfor i in range(1, len(s)):\n\t\t\tif s[i]!= '_':\n\t\t\t\tl.append(s[:i])\n\t\t\t\tl.append(s[i:])\n\t\t\telse:\n\t\t\t\tl.append(s[:i])\n\t\treturn l\n\nif __name__ == '__main__':\n\ts = Solution()\n\tprint(s.findSequence(\"_\"))\n\tprint(s.findSequence(\"_abc_\"))\n\tprint(s.findSequence(\"_abc_def_\"))\n\tprint(s.findSequence(\"_abc_def_ghi_jkl_\"))\n\tprint(s.findSequence(\"_abc_def_ghi_jkl_mno_pqr_stu_vw_xyz_\"))"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "import os\nimport re\n\ndef find_sequence(word):\n    \"\"\"\n    :type word: str\n    :rtype: str\n    \"\"\"\n    pattern = re.compile(r\"([a-z])_([a-z])\")\n    result = pattern.findall(word)\n    return result\n\n\nif __name__ == '__main__':\n    with open(os.path.join(os.path.dirname(__file__), 'day5_input.txt')) as f:\n        lines = f.readlines()\n    for line in lines:\n        word = line.strip()\n        print find_sequence(word)"
    },
    {
      "rank": 26,
      "score": 9.0,
      "candidate": "import re\n\ndef sequence_lowercase_underscore(string):\n    return re.sub(r'[^a-z]', '', string).lower()\n\nif __name__ == \"__main__\":\n    string = \"Hello_world\"\n    print sequence_lowercase_underscore(string)"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        p = set(p)\n        return [s[i:j+1] for i, j in enumerate(zip(s.lower(), p)) if j]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findAnagrams('banana', 'banana')\n    print s.findAnagrams('abcd', 'abc')\n    print s.findAnagrams('a', 'a')"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    pattern = re.compile(r'[a-z]{2,}(_[a-z]{2,})*')\n    matches = re.findall(pattern, s)\n    return matches\n\nif __name__ == '__main__':\n    assert find_sequences('abcde_fghij') == ['abcde_fghij']\n    assert find_sequences('abcde_fghij_klmno') == ['abcde_fghij_klmno']\n    assert find_sequences('abcde_fghij_klmno_pqrst') == ['abcde_fghij_klmno_pqrst']\n    assert find_sequences('abcde_fghij_klmno_pqrst_u') == ['abcde_fghij_klmno_pqrst_u']\n    assert find_sequences('abcde_fghij_klmno_pqrst_u_wxyz') == ['abcde_fghij_klmno_pqrst_u_wxyz']"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-the-number-of-letters/problem\n\ndef find_number_of_letters(string):\n    letters = 0\n    for letter in string:\n        if letter.lower() == letter:\n            letters += 1\n    return letters\n\nif __name__ == \"__main__\":\n    string = input()\n    print(find_number_of_letters(string))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport string\n\ndef find_sequences(s):\n    return [list(sequence) for sequence in Counter(s).most_common() if sequence[0].islower()]\n\nif __name__ == \"__main__\":\n    s = \"a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z\"\n    print(find_sequences(s))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "def find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    for i in range(len(text)):\n        if text[i] == '_' and text[i-1]!= '_':\n            result.append(text[:i])\n            text = text[i+1:]\n    return result\n\nif __name__ == \"__main__\":\n    assert find_sequences(\"a_bc\") == ['a', 'bc']\n    assert find_sequences(\"_abc\") == ['abc']\n    assert find_sequences(\"a_bc_def\") == ['a', 'bc', 'def']\n    assert find_sequences(\"a_bc_def_ghi\") == ['a', 'bc', 'def', 'ghi']\n    assert find_sequences(\"a_bc_def_ghi_jkl_mno\") == ['a', 'bc', 'def', 'ghi', 'jkl','mno']\n    assert find_sequences(\"a_bc_def_ghi_jkl_mno_pqr_stu_vw_xyz\") == ['a', 'bc', 'def', 'ghi', 'jkl','mno', 'pqr','stu', 'vw', 'xyz']"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-the-dictionary-value/problem\n\ndef find_dictionary_value(dict):\n    \"\"\"\n    :type dict: List[str]\n    :rtype: int\n    \"\"\"\n    if not dict:\n        return 0\n\n    prev_key = dict[0]\n    prev_index = 0\n    result = 0\n\n    for i in range(1, len(dict)):\n        if dict[i] == prev_key:\n            result += 1\n        else:\n            prev_key = dict[i]\n            prev_index = i\n\n    return result\n\n\nif __name__ == '__main__':\n    dict = [x.lower() for x in input().split()]\n    print(find_dictionary_value(dict))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    return [x for x in string if x.islower()]"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def sequence_of_lowercase_letters(lowercase_letters):\n    \"\"\"\n    :type lowercase_letters: List[str]\n    :rtype: List[str]\n    \"\"\"\n    sequence = []\n    for i in range(len(lowercase_letters)):\n        if lowercase_letters[i] == lowercase_letters[i-1]:\n            sequence.append(lowercase_letters[i])\n        else:\n            sequence.append('_')\n    return sequence\n\nif __name__ == '__main__':\n    lowercase_letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    print(sequence_of_lowercase_letters(lowercase_letters))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for c in s:\n            if c.islower():\n                result.append(c)\n            else:\n                if len(result) > 0:\n                    result[-1] += c\n                else:\n                    result.append(c)\n        return result"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom functools import reduce\n\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = defaultdict(list)\n    for i, c in enumerate(text):\n        if c.islower():\n            sequences[c].append(text[:i])\n            if not sequences[c]:\n                del sequences[c]\n    return [s for s in sequences.values() if s]\n\n\ndef test():\n    assert find_sequences(\"abcabcdefg\") == [\"abc\", \"abcdefg\"]\n    assert find_sequences(\"a_b_c\") == [\"a\", \"b\", \"c\"]\n    assert find_sequences(\"a_b_c_d_e_f_g\") == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n    assert find_sequences(\"abc_def_ghi_jkl_mno_pqr_stu_vw_xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vw\", \"xyz\"]\n\n\nif __name__ == \"__main__\":\n    test()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def find_sequences(str):\n    \"\"\"\n    :type str: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    current_seq = []\n    for letter in str:\n        if letter.lower() == current_seq[-1].lower():\n            current_seq.append(letter)\n        else:\n            if current_seq:\n                sequences.append(\"\".join(current_seq))\n            current_seq = [letter]\n    if current_seq:\n        sequences.append(\"\".join(current_seq))\n    return sequences\n\nif __name__ == \"__main__\":\n    assert find_sequences(\"a_bc\") == [\"a\", \"b\", \"c\"]\n    assert find_sequences(\"aa_bb_cc\") == [\"aa\", \"bb\", \"cc\"]\n    assert find_sequences(\"a_b_c\") == [\"a\", \"b\", \"c\"]\n    assert find_sequences(\"aa_bb_cc_dd_ee\") == [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]\n    assert find_sequences(\"ab_cd\") == [\"ab\", \"cd\"]\n    assert find_sequences(\"ab_cd_ef\") == [\"ab\", \"cd\", \"ef\"]"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(input_string):\n    # Your code here\n    pattern = re.compile(r'([a-z]){3}')\n    result = []\n    for match in pattern.finditer(input_string):\n        if len(result) == 0:\n            result.append(match.group())\n        else:\n            if result[-1]!= match.group():\n                result.append(match.group())\n    return result"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/sequences-and-sequences/problem\n\ndef sequences(string):\n    \"\"\"\n    Args:\n        string: String to be checked\n\n    Returns:\n        List of tuples containing the sequence of lowercase letters\n    \"\"\"\n    # Initialize a list for the output\n    output = []\n\n    # Convert the string to a list of lowercase letters\n    lowercase_letters = list(string.lower())\n\n    # Loop through the list of letters, checking if they are consecutive\n    for index in range(len(lowercase_letters)):\n        if index == 0:\n            # If the first letter is in the list, append it\n            output.append(lowercase_letters[:index+1])\n        else:\n            # If the current letter is not the first, check if it's the same as the previous letter\n            if lowercase_letters[index] == lowercase_letters[index-1]:\n                # If they are the same, append it and increment the index\n                output.append(lowercase_letters[:index+1])\n                index += 1\n            else:\n                # Otherwise, reset the index\n                index = 0\n\n    return output\n\nprint(sequences(\"abcd\"))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def get_sequence(s):\n    sequence = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            if len(sequence) > 0:\n                sequence.append(s[i])\n            else:\n                sequence.append('')\n        else:\n            sequence.append(s[i])\n    return sequence\n\ndef get_sequence_length(s):\n    sequence = get_sequence(s)\n    return len(sequence)\n\ndef get_sequence_frequency(s):\n    sequence = get_sequence(s)\n    return len(sequence)\n\ndef get_sequence_string(s):\n    sequence = get_sequence(s)\n    return ''.join(sequence)\n\nif __name__ == \"__main__\":\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    print(get_sequence_length(s))\n    print(get_sequence_frequency(s))\n    print(get_sequence_string(s))\n\n    s = \"abcdefghijklmnopqrstuvwxyz_\"\n    print(get_sequence_length(s))\n    print(get_sequence_frequency(s))\n    print(get_sequence_string(s))\n\n    s = \"abcdefghijklmnopqrstuvwxyz_\"\n    print(get_sequence_length(s))\n    print(get_sequence_frequency(s))\n    print(get_sequence_string(s))\n\n    s = \"abcdefghijklmnopqrstuvwxyz_\"\n    print(get_sequence_length(s))\n    print(get_sequence_frequency(s))\n    print(get_sequence_string(s))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    return re.findall(r'[a-z]+', text)\n\nif __name__ == '__main__':\n    text = 'Hello_World'\n    print find_sequences(text)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSequence(self, s):\n        ret = []\n        s_len = len(s)\n        for i in range(s_len):\n            for j in range(i, s_len):\n                if s[i:j+1] == s[j:i+1]:\n                    ret.append(s[i:j+1])\n                    break\n        return ret\n\nif __name__ == \"__main__\":\n    assert Solution().findSequence(\"abcde\") == [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    assert Solution().findSequence(\"aaabbbbccccdddd\") == [\"a\", \"b\", \"c\", \"d\", \"e\"]"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        ret = []\n        p_len = len(p)\n        for i in range(len(s)):\n            if i + p_len > len(s):\n                break\n            p_part = p[:p_len]\n            s_part = s[i:i + p_len]\n            if p_part == s_part:\n                ret.append(s[i:i + p_len])\n        return ret\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findAnagrams('anagram', 'ragnag')"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    d = {ord(c): c for c in s}\n    res = []\n    for i in range(len(s)):\n        if i == 0:\n            res.append(s[i])\n        else:\n            if s[i] not in d:\n                res.append(s[i])\n            else:\n                if d[s[i]] == s[i]:\n                    res.append(s[i])\n    return res\n\n\nif __name__ == '__main__':\n    assert find_sequences('abcabc') == ['abc', 'abc']\n    assert find_sequences('abc') == ['abc']\n    assert find_sequences('abcabcabc') == ['abc', 'abc', 'abc']\n    assert find_sequences('abcd') == []\n    assert find_sequences('a') == []\n    assert find_sequences('abcdabc') == ['abc', 'abc']\n    assert find_sequences('abcdabcabc') == ['abc', 'abc']\n    assert find_sequences('abcdeabc') == ['abc', 'abc']\n    assert find_sequences('abcdeabcde') == ['abc', 'abc']\n    assert find_sequences('abcdeabcdeabcdeabcde') == ['abc', 'abc']\n    assert find_sequences('abcdabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabc"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findRepeatedDnaSequences(self, s):\n        result = []\n        if len(s) < 2:\n            return result\n        dna = []\n        for c in s:\n            if c.isupper():\n                dna.append(c)\n        for i in range(len(dna) - 1):\n            if dna[i] == dna[i + 1]:\n                result.append(dna[i] + '_')\n        return result"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(text):\n    pattern = re.compile('[a-z]+')\n    return [match.group() for match in pattern.finditer(text)]\n\nif __name__ == '__main__':\n    text = '''\n    aaa\n    bbb\n    ccc\n    ddd\n    eee\n    fff\n    ggg\n    hhh\n    iii\n    jjj\n    kkk\n    lll\n    mmm\n    nnn\n    ooo\n    ppp\n    qqq\n    rrr\n    sss\n    ttt\n    uuu\n    vvv\n    www\n    xxx\n    yyy\n    zzz\n    '''\n    sequences = find_sequences(text)\n    print(sequences)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "def find_sequences(input_str):\n    sequence_list = []\n    for c in input_str:\n        if c.isalpha() and c.islower():\n            sequence_list.append(c)\n        else:\n            sequence_list.append('_')\n    return sequence_list\n\nif __name__ == '__main__':\n    assert find_sequences(\"a_b_c_d\") == ['a', '_', 'b', '_', 'c', '_', 'd']\n    assert find_sequences(\"abc\") == ['a', 'b', 'c']\n    assert find_sequences(\"abcd\") == ['a', 'b', 'c', 'd']\n    assert find_sequences(\"abcde\") == ['a', 'b', 'c', 'd', 'e']"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "import re\n\ndef is_palindrome(s):\n    s = s.lower()\n    if s == '':\n        return True\n    return s[0] == s[-1]\n\ndef find_sequences(s):\n    sequences = []\n    for i in range(len(s) - 1):\n        if is_palindrome(s[i:i+2]):\n            sequences.append(s[i:i+2])\n    return sequences\n\nif __name__ == '__main__':\n    print(find_sequences('abbc'))\n    print(find_sequences('abbbbbc'))\n    print(find_sequences('bacd'))\n    print(find_sequences('abc'))\n    print(find_sequences('abcd'))\n    print(find_sequences('abcde'))\n    print(find_sequences('abcdef'))\n    print(find_sequences('aabbccdd'))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    for i in range(len(s)):\n        if s[i] == '_':\n            yield s[:i]\n            s = s[i+1:]\n    yield s\n\nfor s in find_sequences('abcdefghijklmnopqrstuvwxyz'):\n    print(s)"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def find_sequences(string):\n    # write your code here\n    # for example:\n    # for i in range(len(string)):\n    #     if string[i] == string[i+1]:\n    #         yield(string[i], string[i+1])\n    if not string:\n        return\n    for i in range(len(string)-1):\n        if string[i] == string[i+1]:\n            yield(string[i], string[i+1])\n        else:\n            break"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(data):\n    pattern = re.compile('[a-z]+')\n    sequences = []\n    for line in data:\n        match = pattern.search(line)\n        if match:\n            sequences.append(match.group())\n    return sequences\n\nif __name__ == '__main__':\n    with open('data.txt') as f:\n        data = f.read()\n    sequences = find_sequences(data)\n    for sequence in sequences:\n        print sequence"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    # +++your code here+++\n    s = s.lower()\n    result = []\n    \n    for i in range(len(s)):\n        if i == 0:\n            if s[i] in ['a', 'e', 'i', 'o', 'u']:\n                result.append(s[i])\n            else:\n                result.append('_')\n        else:\n            if s[i] in ['a', 'e', 'i', 'o', 'u']:\n                if s[i-1] in ['a', 'e', 'i', 'o', 'u']:\n                    result.append(s[i-1] + s[i])\n                else:\n                    result.append(s[i] + '_')\n            else:\n                if s[i-1] in ['a', 'e', 'i', 'o', 'u']:\n                    result.append(s[i-1] + '_')\n                else:\n                    result.append(s[i] + '_')\n    return result\n    \ndef find_sequences_v2(s):\n    # +++your code here+++\n    result = []\n    \n    for i in range(len(s)):\n        if s[i] in ['a', 'e', 'i', 'o', 'u']:\n            result.append(s[i])\n        else:\n            result.append('_')\n    return result"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    counter = Counter(s)\n    sequences = []\n    for letter in s:\n        if counter[letter] == 1:\n            sequences.append('_' + letter)\n            counter[letter] = 0\n    return sequences\n\nif __name__ == '__main__':\n    assert find_sequences('abcd') == ['_a', '_b', '_c', '_d']\n    assert find_sequences('abcd_') == ['_a', '_b', '_c', '_d_']\n    assert find_sequences('abcd_e') == ['_a', '_b', '_c', '_d_', '_e']\n    assert find_sequences('abcd_e_f') == ['_a', '_b', '_c', '_d_', '_e_', '_f']\n    assert find_sequences('abcd_e_f_g') == ['_a', '_b', '_c', '_d_', '_e_', '_f_', '_g']\n    assert find_sequences('abcd_e_f_g_') == ['_a', '_b', '_c', '_d_', '_e_', '_f_', '_g_']\n    assert find_sequences('abcd_e_f_g_h') == ['_a', '_b', '_c', '_d_', '_e_', '_f_', '_g_', '_h']\n    assert find_sequences('abcd_e_f_g_h_') == ['_a', '_b', '_c', '_d_', '_e_', '_f_', '_g_', '_h_']"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "import re\n\n\ndef find_sequences(string):\n    # Write your code here\n    pattern = re.compile('[a-z]{2,}')\n    sequences = []\n\n    for match in pattern.finditer(string):\n        # print(match.group())\n        # print(match.start())\n        # print(match.end())\n        sequences.append(match.group())\n\n    return sequences\n\n\nif __name__ == '__main__':\n    string = 'abcdefghijklmnopqrstuvwxyz'\n    sequences = find_sequences(string)\n\n    for sequence in sequences:\n        print(sequence)"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "import re\n\ndef is_list(s):\n    return isinstance(s, list)\n\n\ndef find_sequences(s):\n    # This is a generator function\n    if not is_list(s):\n        s = list(s)\n    \n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            yield s[i:j]\n\ndef main():\n    # Test cases\n    assert find_sequences(\"a_b_c\") == ['a', 'b', 'c']\n    assert find_sequences(\"abc_d_e\") == ['abc', 'd', 'e']\n    assert find_sequences(\"a_b_c_d_e\") == ['a', 'b', 'c', 'd', 'e']\n    assert find_sequences(\"abc_d_e_f\") == ['abc', 'd', 'e', 'f']\n    assert find_sequences(\"abcdef\") == ['abc', 'def']\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyz\") == ['abc', 'def', 'ghi', 'jkl','mnop', 'qrst', 'uvw', 'xyz']\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyz_\") == ['abc', 'def', 'ghi', 'jkl','mnop', 'qrst', 'uvw', 'xyz', '_']\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyz__\") == ['abc', 'def', 'ghi', 'jkl','mnop', 'qrst', 'uvw', 'xyz', '__']\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyz_abcdefghijklmnopqrstuvwxyz__\") == ['abc', 'def', 'ghi', 'jkl','mnop', 'qrst', 'uvw', 'xyz', 'abc', 'def', 'ghi', 'jkl','mnop', 'qrst', 'uvw', 'xyz',"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    d = defaultdict(list)\n    for c in text:\n        d[c].append(c)\n    return list(d.keys())\n\n\nif __name__ == '__main__':\n    assert find_sequences('abcd') == []\n    assert find_sequences('ab_cd') == ['a', 'b', '_', 'c', 'd']\n    assert find_sequences('abcd_') == ['a', 'b', 'c', 'd', '_']"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequence(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    pattern = re.compile('[a-z]')\n    result = []\n    for i in range(0, len(s)):\n        if s[i] == '_':\n            result.append(s[i:])\n        elif pattern.match(s[i:]) is not None:\n            result.append(s[i:])\n    return ''.join(result)\n\n\nif __name__ == '__main__':\n    s = '_abcdefghijk_lmnopqrstuvwxyz'\n    print(find_sequence(s))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            if i!= 0:\n                result.append(s[:i])\n            else:\n                result.append(s[:i+1])\n        else:\n            result.append(s[i:])\n    return result\n\n\ndef find_sequences_recursive(s):\n    if len(s) == 0:\n        return []\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            result.append(s[:i])\n            result.append(s[i:])\n        else:\n            result.append(s[:i])\n            result.append(s[i:])\n    return result\n\n\ndef find_sequences_iterative(s):\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            result.append(s[:i])\n        else:\n            result.append(s[i:])\n    return result\n\n\ndef find_sequences_backtracking(s):\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            result.append(s[:i])\n            result.append(s[i:])\n        else:\n            result.append(s[:i])\n            result.append(s[i:])\n    return result\n\n\ndef find_sequences_backtracking_iterative(s):\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            result.append(s[:i])\n        else:\n            result.append(s[:i])\n            result.append(s[i:])\n    return result\n\n\ndef find_sequences_backtracking_recursive(s):\n    if len(s) == 0:\n        return []\n    result = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            result"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "def find_sequences(data):\n    sequence_list = []\n    for line in data:\n        for letter in line:\n            if letter.lower() in sequence_list:\n                sequence_list.append(letter.lower())\n            else:\n                sequence_list.append(letter.lower())\n    return sequence_list\n\ndef test():\n    assert find_sequences([\"asdf\", \"asdf\", \"asdf\", \"asdf\", \"asdf\"]) == [\"asdf\", \"asdf\", \"asdf\", \"asdf\"]\n    assert find_sequences([\"asdf\", \"asdf\", \"asdf\"]) == [\"asdf\", \"asdf\", \"asdf\"]\n    assert find_sequences([\"asdf\", \"asdf\"]) == [\"asdf\", \"asdf\"]\n\ntest()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "import string\n\ndef sequence(word):\n    return [char for char in word if char.isalpha()]\n\ndef find_sequences(text):\n    sequences = []\n    for word in text.split():\n        if word:\n            sequences.append(sequence(word))\n    return sequences\n\nif __name__ == '__main__':\n    text = 'abbc'\n    sequences = find_sequences(text)\n    print(sequences)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "def find_sequences(string):\n    return [s for s in string.split('_') if s]\n\n\nif __name__ == '__main__':\n    assert find_sequences('abc') == ['abc']\n    assert find_sequences('a_b_c') == ['a_b_c']\n    assert find_sequences('ab_c_d') == ['ab_c_d']\n    assert find_sequences('a__b_c') == ['a__b_c']\n    assert find_sequences('a_b_c_') == ['a_b_c_']\n    assert find_sequences('a_b_c_d') == ['a_b_c_d']\n    assert find_sequences('_a_b_c_') == ['_a_b_c_']\n    assert find_sequences('_a_b_c_d') == ['_a_b_c_d']\n    assert find_sequences('ab_c') == ['ab_c']\n    assert find_sequences('a_b_c_d_') == ['a_b_c_d_']\n    assert find_sequences('a_b_c_d_e') == ['a_b_c_d_e']\n    assert find_sequences('abc_') == ['abc_']\n    assert find_sequences('abc_def_') == ['abc_def_']\n    assert find_sequences('abcdef_') == ['abcdef_']\n    assert find_sequences('a_bc_d_') == ['a_bc_d_']\n    assert find_sequences('ab_c_d_e') == ['ab_c_d_e']\n    assert find_sequences('a__b_c') == ['a__b_c']\n    assert find_sequences('a_b_c_') == ['a_b_c_']\n    assert find_sequences('a_b_c_d_e') == ['a_b_c_d_e']\n    assert find_sequences('a_b_c_d_e_') == ['a_b_c_d_e_']"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def is_valid_sequence(s):\n    for i in range(len(s)):\n        if s[i] >= 'a' and s[i] <= 'z':\n            return True\n    return False\n\ndef find_sequences(string):\n    result = []\n    for i in range(len(string) - 1):\n        if is_valid_sequence(string[i:]) and is_valid_sequence(string[i+1:]):\n            result.append(string[i:i+2])\n    return result\n\nif __name__ == \"__main__\":\n    string = \"a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z_1_2_3_4_5_6_7_8_9_0_1_2_3_4_5_6_7_8_9_0_1_2_3_4_5_6_7_8_9_0_1_2_3_4_5_6_7_8_9_0_1_2_3_4_5_6_7_8_9\"\n    print(find_sequences(string))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import re\n\n\ndef is_number(s):\n    return re.search(r'^[0-9]+$', s) is not None\n\n\ndef is_letter(s):\n    return re.search(r'^[a-z]+$', s) is not None\n\n\ndef is_valid(s):\n    return is_number(s) and is_letter(s)\n\n\ndef is_valid_sequence(s):\n    return all([is_valid(s), s.startswith('_')])\n\n\ndef get_valid_sequences(s):\n    return [s for s in s.split('_') if is_valid_sequence(s)]\n\n\ndef join_sequences(sequences):\n    return '_'.join(sequences)\n\n\ndef main():\n    sequences = get_valid_sequences('_A__B__C__D__E_')\n    print(join_sequences(sequences))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    for i in range(0, len(s)):\n        if s[i] == '_':\n            sequences.append(s[i + 1:])\n            continue\n        if s[i] == '_' or s[i] =='':\n            continue\n        sequences.append(s[i:])\n    return sequences\n\n# TODO: use list comprehension to optimize"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def __init__(self):\n        self.table = {}\n        self.last = \"\"\n\n    def is_palindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 1:\n            return False\n        if len(s) == 1:\n            return s.lower() == s.upper()\n        if len(s) == 2:\n            return s.lower() == s.upper() and s[0] == s[1]\n        s = s.lower()\n        if s in self.table:\n            return self.table[s]\n        self.table[s] = True\n        last = \"\"\n        for c in s:\n            if last == \"\":\n                last = c\n            else:\n                if last == c:\n                    last = \"\"\n                else:\n                    last = c\n        self.last = last\n        return self.is_palindrome(last)\n\n\nif __name__ == \"__main__\":\n    print Solution().is_palindrome(\"a_b_c_d_e\")\n    print Solution().is_palindrome(\"aaabbbccdde\")"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    s = \"\"\n    for i in string:\n        if i.islower():\n            if s:\n                seqs.append(s)\n                s = \"\"\n            s += i\n        else:\n            s += i\n    if s:\n        seqs.append(s)\n    return seqs\n\n\nif __name__ == '__main__':\n    print(find_sequences(\"abcde\"))\n    print(find_sequences(\"abbc\"))\n    print(find_sequences(\"bbc\"))\n    print(find_sequences(\"abcd\"))\n    print(find_sequences(\"abc\"))\n    print(find_sequences(\"bcd\"))\n    print(find_sequences(\"bcde\"))\n    print(find_sequences(\"bcde\"))\n    print(find_sequences(\"abcde\"))\n    print(find_sequences(\"abbcde\"))"
    },
    {
      "rank": 67,
      "score": 3.0,
      "candidate": "__author__ = 'Daniel'\n\nimport unittest\n\n\nclass Solution(object):\n    def __init__(self):\n        self.pattern = '_'\n\n    def generateAbbreviations(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: List[str]\n        \"\"\"\n        return self.__generateAbbreviations(str, [], [])\n\n    def __generateAbbreviations(self, str, cur, result):\n        if len(str) == 0:\n            return result\n        if self.pattern in str:\n            result.append(self.pattern)\n            return result\n        result.append(str)\n        for i in range(1, len(str) + 1):\n            cur.append(str[:i])\n            self.__generateAbbreviations(str[i:], cur, result)\n            cur.pop()\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-sequences-with-repeated-characters/solution/\n\n# DFS\n# Time:  O(n)\n# Space: O(n)\n\n# My solution:\n# Use a stack to track the current position\n# The stack keeps track of the current position of the current node in the current string\n# The stack keeps track of the previous position of the current node in the current string\n# The stack keeps track of the current string position\n# The stack keeps track of the current node in the current string\n# The stack keeps track of the previous node in the current string\n# The stack keeps track of the current string position\n# The stack keeps track of the current node in the current string\n# The stack keeps track of the previous node in the current string\n# The stack keeps track of the current string position\n# The stack keeps track of the current node in the current string\n# The stack keeps track of the previous node in the current string\n# The stack keeps track of the current string position\n# The"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": ""
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "def find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    # Write your code here\n    return [''.join(i) for i in groupby(string, lambda x: x.lower())]\n\nif __name__ == '__main__':\n    assert find_sequences(\"a_b_c_d\") == [\"a\", \"b\", \"c\", \"d\"]\n    assert find_sequences(\"a__b__c__d\") == [\"a\", \"b\", \"c\", \"d\"]\n    assert find_sequences(\"a_b_c_d_\") == [\"a\", \"b\", \"c\", \"d\"]\n    assert find_sequences(\"a_b_c_d_e\") == [\"a\", \"b\", \"c\", \"d\", \"e\"]"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_my_solution(self):\n        self.assertEqual(my_solution([1,2,3]), '1_2_3')\n        self.assertEqual(my_solution([1,2,3,4,5,6,7,8,9,10]), '1_2_3_4_5_6_7_8_9_10')\n        self.assertEqual(my_solution([]), '')\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/sequence-of-lower-case-words/discuss/63918/Python-Solution-with-explanation\n\nclass Solution(object):\n    def sequenceOfLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if i < len(s) - 1 and s[i] >= s[i+1]:\n                res.append(s[i:i+2])\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.sequenceOfLetters('a')"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        :type cipher: str\n        :rtype: str\n        \"\"\"\n        cipher = cipher.lower()\n        l = len(cipher)\n        count = 0\n        seq = []\n        for i in range(l):\n            if cipher[i] == cipher[i+1]:\n                count += 1\n            else:\n                seq.append(cipher[i:i+count])\n                count = 1\n        seq.append(cipher[l-1:])\n        return '_'.join(seq)\n\n\nif __name__ == '__main__':\n    #Solution().solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z')\n    s = Solution()\n    print s.solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z')\n    print s.solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z')\n    print s.solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z')\n    print s.solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z')\n    print s.solve('_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    current_sequence = []\n\n    for c in string:\n        if c.lower()!= c:\n            if current_sequence:\n                sequences.append(''.join(current_sequence))\n                current_sequence = []\n        else:\n            current_sequence.append(c.lower())\n    if current_sequence:\n        sequences.append(''.join(current_sequence))\n\n    return sequences\n\nif __name__ == '__main__':\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyz\") == ['abcdefghijklmnopqrstuvwxyz']\n    assert find_sequences(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\") == ['abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz']\n    assert find_sequences(\"abcd\") == ['abcd']\n    assert find_sequences(\"abcdabcd\") == ['abcdabcd']\n    assert find_sequences(\"abcdabcdabcd\") == ['abcdabcdabcd']\n    assert find_sequences(\"abcdabcdabcdabcd\") == ['abcdabcdabcdabcd']\n    assert find_sequences(\"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\") == ['abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd']\n\n    # Test with unicode\n    assert find_sequences(u\"abcdefghijklmnopqrstuvwxyz\") == ['abcdefghijklmnopqrstuvwxyz']\n    assert find_sequences(u\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": ""
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "import re\n\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    sequence = ''\n    for c in text:\n        if c.islower():\n            if sequence!= '':\n                sequences.append(sequence)\n            sequence = c\n        else:\n            if sequence!= '':\n                sequences.append(sequence)\n            sequence = ''\n    return sequences\n\n\ndef test():\n    assert find_sequences(\"Hello World\") == ['hello', 'world']\n    assert find_sequences(\"Hello World_and_the_rest\") == ['hello', 'world_and_the_rest']\n    assert find_sequences(\"Hello_World_and_the_rest\") == ['hello', 'world_and_the_rest']\n    assert find_sequences(\"Hello World\") == ['Hello', 'World']\n    assert find_sequences(\"Hello_World\") == ['Hello', 'World']\n    assert find_sequences(\"Hello_World_and_the_rest\") == ['Hello', 'World_and_the_rest']\n    assert find_sequences(\"Hello World and the rest\") == ['Hello', 'World and the rest']\n    assert find_sequences(\"Hello World and the rest\") == ['Hello', 'World and the rest']\n    assert find_sequences(\"Hello World and the rest\") == ['Hello', 'World and the rest']\n    assert find_sequences(\"Hello World and the rest\") == ['Hello', 'World and the rest']\n\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# Hash table\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        # Hash table\n        table = Counter(p)\n        # Two pointers\n        left = 0\n        right = len(s)\n        while left < right:\n            # Compare two characters\n            if table[s[left]] == table[s[right]]:\n                # Increment the pointers\n                left += 1\n                right -= 1\n            else:\n                # If the characters are not equal, move the pointers\n                if table[s[left]] < table[s[right]]:\n                    left += 1\n                else:\n                    right -= 1\n        return [s[left:]]\n\n# Time:  O(n)\n# Space: O(n)\n# Brute force\nclass Solution2(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[str]\n        \"\"\"\n        return [s[:i] for i in range(len(s)) if p.find(s[i:]) == i]"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "import re\nfrom collections import defaultdict\n\n\ndef find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    res = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            res.append(s[:i])\n    return res\n\n\nif __name__ == '__main__':\n    s = '_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z_'\n    res = find_sequences(s)\n    print(res)"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSequence(self, s):\n        seq = []\n        if len(s) == 0:\n            return seq\n        for i in range(1, len(s)):\n            if s[i] == s[i-1] and s[i-1] == '_':\n                seq.append(s[i-1])\n            else:\n                seq.append(s[i-1])\n                seq.append(s[i])\n        return seq\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-the-duplicates-of-a-string/solution/\n\n# Approach #1: Iterate\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n# 1. Create a map to store all the letters in the string.\n# 2. Initialize the map as an empty map.\n# 3. For each character in the string, update the map.\n# 4. If a value in the map is not empty, then the key is duplicated.\n# 5. Return the list of all the values that are not empty in the map.\n\n# 4. O(n) Time\n# 4. O(n) Space\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n# 4. O(n) Time\n# 4. O(n) Space\n\n# Approach #2: Recursive\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n# 4. O(n) Time\n# 4. O(n) Space\n\n# Approach #3: Two pointers\n# Complexity Analysis\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n# 4. O(n) Time\n# 4. O("
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def __init__(self, num):\n        \"\"\"\n        Initialize your data structure here.\n        :type num: int\n        \"\"\"\n        self.dict = {}\n        self.num = num\n        self.count = 0\n\n    def addToDict(self, char):\n        \"\"\"\n        :type char: str\n        :rtype: void\n        \"\"\"\n        if char in self.dict:\n            self.dict[char] += 1\n        else:\n            self.dict[char] = 1\n\n    def isWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if self.num == 0:\n            return False\n\n        for c in s:\n            self.addToDict(c)\n\n        return self.num == 0\n\n    def hasDuplicate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for c in s:\n            if c in self.dict:\n                return True\n        return False\n\n    def getDuplicates(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for c in s:\n            if c in self.dict:\n                res.append(c)\n        return res\n\n    def addSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: void\n        \"\"\"\n        for c in s:\n            self.addToDict(c)\n\n    def getSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for c in s:\n            if c in self.dict:\n                self.addToDict(c)\n                res.append(c)\n        return res\n\n    def hasAllDuplicates(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for c in s:\n            if c not in self.dict:\n                return False\n        return True"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "import string\nimport collections\n\n\ndef find_sequence(string):\n    \"\"\"\n    :type string: str\n    :rtype: collections.Iterable[str]\n    \"\"\"\n    return find_sequence_recursive(string)\n\n\ndef find_sequence_recursive(string):\n    if not string:\n        return []\n    else:\n        return string.split('_')\n\n\ndef find_sequence_recursive_test_case(string):\n    \"\"\"\n    :type string: str\n    :rtype: collections.Iterable[str]\n    \"\"\"\n    return find_sequence_recursive(string)\n\n\nif __name__ == '__main__':\n    assert find_sequence_recursive_test_case(\"\") == []\n    assert find_sequence_recursive_test_case(\"a\") == ['']\n    assert find_sequence_recursive_test_case(\"aa\") == ['', '']\n    assert find_sequence_recursive_test_case(\"aaa\") == ['', '', '']\n    assert find_sequence_recursive_test_case(\"aaaa\") == ['', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaa\") == ['', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaa\") == ['', '', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaaa\") == ['', '', '', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaaaa\") == ['', '', '', '', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaaaaa\") == ['', '', '', '', '', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaaaaaa\") == ['', '', '', '', '', '', '', '', '', '']\n    assert find_sequence_recursive_test_case(\"aaaaaaaaaaa\") == ['', '', '', '', '', '', '', '', '', '', '']\n    assert find_sequence_recursive_test"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSequence(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        self.findSequenceHelper(root, result)\n        return result\n\n    def findSequenceHelper(self, root, result):\n        if root is None:\n            return\n\n        if root.left is None and root.right is None:\n            result.append(root.val)\n            return\n\n        self.findSequenceHelper(root.left, result)\n        self.findSequenceHelper(root.right, result)"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import unittest\nimport sys\nimport io\n\nclass Solution(object):\n    def __init__(self, words):\n        \"\"\"\n        @param words: A list of strings\n        \"\"\"\n        self.words = words\n\n    def wordsToSeq(self):\n        \"\"\"\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for word in self.words:\n            if word:\n                result.append(word)\n            else:\n                result.append(\"_\")\n        return result\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        test_input = [\"ab2c\", \"a1b3\", \"1aa\"]\n        test_output = [\"a_b_c\", \"a_1_b_3\", \"1_a_a\"]\n        p = Solution(test_input)\n        self.assertSequenceEqual(p.wordsToSeq(), test_output)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/words-to-sequences-of-lower-case-letters/solution/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public List<String> wordsToSeq(String[] words) {\n        List<String> result = new ArrayList<>();\n        if (words == null || words.length == 0) {\n            return result;\n        }\n        TreeNode root = buildTree(words);\n        dfs(root, result);\n        return result;\n    }\n\n    private void dfs(TreeNode root, List<String"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n# @include\ndef find_sequences(word_list):\n    # Compute the frequency of each letter.\n    frequency = defaultdict(int)\n    for word in word_list:\n        for letter in word:\n            frequency[letter] += 1\n    # Build a list of pairs of letters.\n    sequences = []\n    for i in range(26):\n        for j in range(i + 1, 26):\n            sequence = ''.join([chr(i), chr(j)])\n            if sequence in frequency:\n                sequences.append(sequence)\n    return sequences\n# @exclude\n\n\ndef simple_test():\n    assert find_sequences(['a', 'b', 'c', 'd', 'e']) == [\n        'a_b_c_d_e', 'a_b_c_d_e', 'a_b_c_d_e', 'a_b_c_d_e']\n    assert find_sequences(['a', 'b', 'c', 'd', 'e', 'f']) == [\n        'a_b_c_d_e_f', 'a_b_c_d_e_f', 'a_b_c_d_e_f', 'a_b_c_d_e_f']\n    assert find_sequences(['a', 'b', 'c', 'd', 'e', 'f', 'g']) == [\n        'a_b_c_d_e_f_g', 'a_b_c_d_e_f_g', 'a_b_c_d_e_f_g', 'a_b_c_d_e_f_g']\n    assert find_sequences(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == [\n        'a_b_c_d_e_f_g_h', 'a_b_c_d_e_f_g_h', 'a_b_c_d_e_f_g_h',\n        'a_b_c_d_e_f_g_h']"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = defaultdict(list)\n    for i, j in enumerate(text):\n        if j.islower():\n            sequences[j].append(text[i:j+1])\n    return [sequence for sequence in sequences.values() if len(sequence) > 1]\n\n\nif __name__ == \"__main__\":\n    assert find_sequences('') == []\n    assert find_sequences('abbbcdd') == []\n    assert find_sequences('abbcde') == ['']\n    assert find_sequences('abbcdde') == ['_']\n    assert find_sequences('abbcddee') == ['_', '_']\n    assert find_sequences('abbcddeee') == ['_', '_', '_']\n    assert find_sequences('abbcddeeef') == ['_', '_', '_', '_']"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n# @include\ndef find_sequences(s):\n    counts = defaultdict(int)\n    for c in s:\n        counts[c] += 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None\n# @exclude\n\ndef find_sequences_DP(s):\n    \"\"\"\n    @param s: A string.\n    @return: A list of all sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    counts = defaultdict(int)\n    for c in s:\n        counts[c] += 1\n    res = []\n    for c in s:\n        if counts[c] == 1:\n            res.append(c)\n    return res\n\nif __name__ == '__main__':\n    assert find_sequences('aa') == 'a_a'\n    assert find_sequences('aa') == 'a_a'\n    assert find_sequences('aaa') == 'a_a_a'\n    assert find_sequences('aaabbcc') == 'a_a_b_c'\n    assert find_sequences('a') == 'a_'\n    assert find_sequences('ab') == 'a_b'\n    assert find_sequences('abbcc') == 'a_b_c_c'\n    assert find_sequences('abc') == 'a_b_c'\n    assert find_sequences('abcde') == 'a_b_c_d_e'\n    assert find_sequences('aabbcc') == 'a_a_b_c_c'\n    assert find_sequences('aabbccdd') == 'a_a_b_c_c_d_d'\n    assert find_sequences('abcde') == 'a_b_c_d_e'\n    assert find_sequences('abcde') == 'a_b_c_d_e'\n    assert find_sequences('abcde') == 'a_b_c_d_e'\n    assert find_sequences('abcde') == 'a_b_c_d_e'"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "import unittest\n\ndef find_sequences(word):\n    \"\"\"\n    :type word: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    word = word.lower()\n    for i in range(len(word)):\n        if word[i]!= word[i+1]:\n            if word[i] not in ['a', 'e', 'i', 'o', 'u']:\n                sequences.append(word[i:i+2])\n            else:\n                sequences.append(word[i:i+1])\n        else:\n            if word[i] == 'a':\n                sequences.append(word[i:i+2])\n            else:\n                sequences.append(word[i:i+1])\n    return sequences\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('bcd'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde'), [])\n        self.assertEqual(find_sequences('abcde"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sequences(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        self.find(ans, words, 0, [])\n        return ans\n\n    def find(self, ans, words, start, words_so_far):\n        if start == len(words):\n            ans.append(''.join(words_so_far))\n            return\n        for i in range(start, len(words)):\n            if words[i].islower():\n                self.find(ans, words, start + 1, words_so_far + [words[i]])\n            else:\n                self.find(ans, words, start + 1, words_so_far)"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findRepeatedDnaSequences(self, s):\n        # write your code here\n        # s is a string\n        # return a list of strings\n        #return\n        dna_seq = []\n        if s == '':\n            return dna_seq\n        seq = []\n        for i in range(len(s)):\n            if s[i] == s[i-1]:\n                seq.append(s[i-1])\n            else:\n                if seq:\n                    dna_seq.append(''.join(seq))\n                seq = [s[i]]\n        if seq:\n            dna_seq.append(''.join(seq))\n        return dna_seq\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/repeated-dna-sequences/solution/\n\n# 20ms 100%\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        Map<String, Integer> map = new HashMap<>();\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            String key = s.substring(i, i+1);\n            if (!map.containsKey(key)) {\n                map.put(key, 1);\n            } else {\n                map.put(key, map.get(key) + 1);\n            }\n            if (map.get(key) > 1) {\n                res.add(key);\n            }\n        }\n        return res;\n    }\n}\n\n# 0ms 100%\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        if (s == null || s.length() == 0) {\n            return new ArrayList<"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/solution-for-string-joining-1/problem\ndef solution(s):\n    \"\"\"\n    >>> solution(\"a_b_c_d\")\n    'a_b_c_d'\n    >>> solution(\"_a_b_c_d\")\n    '_a_b_c_d'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b_c_d_'\n    >>> solution(\"a_b_c_d_\")\n    'a_b_c_d_'\n    >>> solution(\"_a_b_c_d_\")\n    '_a_b"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import unittest\n\n# TESTS\ndef find_sequences(s):\n    return find_sequences_recursive(s)\n\ndef find_sequences_recursive(s):\n    if len(s) == 0:\n        return []\n    if len(s) == 1:\n        return [s]\n    result = []\n    for i in range(len(s)):\n        result.extend(find_sequences_recursive(s[:i] + s[i + 1:]))\n    return result\n\nclass Tests(unittest.TestCase):\n    def test_find_sequences(self):\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_e_f_g\"), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n        self.assertEqual(find_sequences(\"a_b_c_d_"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    for i in range(len(string)):\n        if string[i] == '_':\n            seqs.append(string[0:i+1])\n        else:\n            seqs.append(string[0:i])\n    return seqs\n\nif __name__ == '__main__':\n    assert find_sequences(\"abc_d\") == [\n        \"abc\",\n        \"_d\",\n    ]\n    assert find_sequences(\"_a_b_c\") == [\n        \"_a_b_c\",\n        \"_\",\n        \"a_b_c\",\n    ]\n    assert find_sequences(\"\") == []\n    assert find_sequences(\"abc_d_efgh_ijk_lmn_opqr_stu_vwx_yz\") == [\n        \"abc_d_efgh_ijk_lmn_opqr_stu_vwx_yz\",\n        \"_d_efgh_ijk_lmn_opqr_stu_vwx_yz\",\n        \"_efgh_ijk_lmn_opqr_stu_vwx_yz\",\n        \"_ijk_lmn_opqr_stu_vwx_yz\",\n        \"_lmn_opqr_stu_vwx_yz\",\n        \"_opqr_stu_vwx_yz\",\n        \"_stu_vwx_yz\",\n        \"_vwx_yz\",\n        \"_yz\",\n        \"yz\",\n        \"abc_d_efgh_ijk_lmn_opqr_stu_vwx_yz\",\n    ]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "import re\n\ndef find_sequences_of_lower_case_letters_joined_with_underscore(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    return [re.sub(r'[^a-z]', '', s) for s in text.split('_') if s]\n\nif __name__ == '__main__':\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('a_b_c') == ['a', 'b', 'c']\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('ab_cd') == ['ab', 'cd']\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('ab_cd_ef') == ['ab', 'cd', 'ef']\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('ab_cd_ef_gh') == ['ab', 'cd', 'ef', 'gh']\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('ab_cd_ef_gh_ij') == ['ab', 'cd', 'ef', 'gh', 'ij']\n    assert find_sequences_of_lower_case_letters_joined_with_underscore('ab_cd_ef_gh_ij_kl') == ['ab', 'cd', 'ef', 'gh', 'ij', 'kl']"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = []\n\n    def solve(self, cipher):\n        \"\"\"\n        :param cipher: the cipher\n        \"\"\"\n        self.ans = []\n        for i in range(0, len(cipher) - 1):\n            if cipher[i]!= cipher[i + 1]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1] and cipher[i] == cipher[i + 2]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1] and cipher[i] == cipher[i + 2] and cipher[i] == cipher[i + 3]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1] and cipher[i] == cipher[i + 2] and cipher[i] == cipher[i + 3] and cipher[i] == cipher[i + 4]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1] and cipher[i] == cipher[i + 2] and cipher[i] == cipher[i + 3] and cipher[i] == cipher[i + 4] and cipher[i] == cipher[i + 5]:\n                self.ans.append(cipher[i])\n                continue\n            if cipher[i] == cipher[i + 1] and cipher[i] == cipher[i + 2] and cipher[i] == cipher[i + 3] and cipher[i] == cipher[i + 4] and cipher[i] == cipher[i + 5] and cipher[i] == cipher[i + 6]:\n                self.ans.append(cipher[i])\n                continue\n        return self.ans\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys."
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef find_sequences(s, n):\n    if len(s) < n:\n        return []\n    if is_palindrome(s):\n        return [s]\n    if n == 0:\n        return []\n    if n == 1:\n        return [s[0]]\n    return [s[:i]+'_'+s[i:] for i in range(1, n)]\n\ndef find_sequences_2(s, n):\n    if len(s) < n:\n        return []\n    if n == 0:\n        return []\n    if n == 1:\n        return [s[0]]\n    return [s[:i]+'_'+s[i:] for i in range(1, n)]\n\ndef find_sequences_3(s, n):\n    if len(s) < n:\n        return []\n    if n == 0:\n        return []\n    if n == 1:\n        return [s[0]]\n    return [s[:i]+'_'+s[i:] for i in range(1, n)]\n\ndef find_sequences_4(s, n):\n    if len(s) < n:\n        return []\n    if n == 0:\n        return []\n    if n == 1:\n        return [s[0]]\n    return [s[:i]+'_'+s[i:] for i in range(1, n)]\n\ndef find_sequences_5(s, n):\n    if len(s) < n:\n        return []\n    if n == 0:\n        return []\n    if n == 1:\n        return [s[0]]\n    return [s[:i]+'_'+s[i:] for i in range(1, n)]\n\nif __name__ == \"__main__\":\n    s = \"abc\"\n    print(find_sequences(s, 2))\n    s = \"a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def find_sequences(text):\n\t\"\"\"\n\t:type text: str\n\t:rtype: List[str]\n\t\"\"\"\n\treturn []"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def _generate_words(self, string, word_count):\n        words = []\n        for i in range(0, len(string)):\n            if string[i] == '_':\n                word = \"\"\n                for j in range(i+1, len(string)):\n                    if string[j] == '_':\n                        words.append(word)\n                        word = \"\"\n                        break\n                    else:\n                        word += string[j]\n                words.append(word)\n        return words\n        \n    def find_sequence(self, s, word_count):\n        \"\"\"\n        :type s: str\n        :type word_count: int\n        :rtype: List[str]\n        \"\"\"\n        if word_count == 1:\n            return [s]\n        if word_count == 2:\n            return [s, s[::-1]]\n        \n        words = self._generate_words(s, word_count)\n        result = []\n        for word in words:\n            if word == \"\":\n                result.append(word)\n                continue\n            if word[0]!= word[-1]:\n                result.append(word)\n                continue\n            for i in range(1, len(word)):\n                sub_word = word[:i] + \"__\" + word[i:]\n                result.append(sub_word)\n        return result"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": ""
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1] and s[i] == '_':\n            seqs.append(s[i:])\n    return seqs\n\n\n# TESTS\nfor s, expected in [\n    (\"_\", []),\n    (\"_a\", [\"_\"]),\n    (\"_aa\", [\"_\"]),\n    (\"_aaa\", [\"_\"]),\n    (\"_aaaa\", [\"_\"]),\n    (\"_a_a\", [\"_\"]),\n    (\"_a_aa\", [\"_\"]),\n    (\"_a_aaa\", [\"_\"]),\n    (\"_a_aaaa\", [\"_\"]),\n    (\"_a_b_b\", [\"_\"]),\n    (\"_a_b_bb\", [\"_\"]),\n    (\"_a_b_bbb\", [\"_\"]),\n    (\"_a_b_bbbb\", [\"_\"]),\n    (\"_a_b_bb_b\", [\"_\"]),\n    (\"_a_b_bb_bb\", [\"_\"]),\n    (\"_a_b_bb_bbb\", [\"_\"]),\n    (\"_a_b_bb_bbbb\", [\"_\"]),\n    (\"_a_b_bb_bb_b\", [\"_\"]),\n    (\"_a_b_bb_bb_bb\", [\"_\"]),\n    (\"_a_b_bb_bb_bbb\", [\"_\"]),\n    (\"_a_b_bb_bb_bbbb\", [\"_\"]),\n    (\"_a_b_bb_bb_bb_b\", [\"_\"]),\n    (\"_a_b_bb_bb_bb_bb\", [\"_\"]),\n    (\"_a_b_bb_bb_bb_bbb\", [\"_\"]),\n    (\"_a_b_bb_bb_bb_bbbb\", [\"_\"]),\n    (\"_a_b_bb_bb_bb_bb_b\", [\"_\"]),\n    (\"_a_b_bb_"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-the-first-and-last-char-of-a-string\n\ndef find_first_and_last(string):\n    \"\"\"\n    Finds first and last character of a string.\n    :param string: string\n    :return: tuple of characters\n    \"\"\"\n\n    first = 0\n    last = 0\n\n    for i in range(len(string)):\n        if string[i] == string[i+1]:\n            first += 1\n        else:\n            first = 0\n\n        last += 1\n\n    return first, last\n\n\ndef find_first_and_last_with_underscore(string):\n    \"\"\"\n    Finds first and last character of a string.\n    :param string: string\n    :return: tuple of characters\n    \"\"\"\n\n    first = 0\n    last = 0\n\n    for i in range(len(string)):\n        if string[i] == string[i+1]:\n            first += 1\n        else:\n            first = 0\n\n        if string[i] == '_':\n            last += 1\n        else:\n            last = 0\n\n    return first, last\n\n\nif __name__ == '__main__':\n    string = input().strip()\n\n    first, last = find_first_and_last(string)\n    print(first, last)\n\n    first, last = find_first_and_last_with_underscore(string)\n    print(first, last)"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            sequences.append(s[:i])\n        else:\n            break\n    for i in range(len(s)):\n        if s[i] == '_':\n            sequences.append(s[:i])\n        else:\n            break\n    return sequences\n\nclass Solution(object):\n    def find_sequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return [s[:i]+'_'+s[i:] for i in range(len(s)) if s[i] == '_']"
    }
  ]
}