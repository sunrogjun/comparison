{
  "timestamp": "2025-09-14T17:46:42.422797",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 56,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Partition a set of numbers into a k-partition\ndef partition(set_of_nums, k):\n    # write your code here\n    if k == 1:\n        return len(set_of_nums)\n    else:\n        partitioned_nums = [0] * (k-1)\n        for num in set_of_nums:\n            partitioned_nums[k-1] += num\n        partitioned_nums[0] += 1\n        return partition(partitioned_nums, k-1)\n\ndef main():\n    # Partition the set of numbers into a k-partition\n    print(partition([1, 2, 3], 2))\n    print(partition([1, 2, 3, 4, 5], 2))\n    print(partition([1, 2, 3, 4, 5, 6], 2))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def count_ways(n, nums):\n    ways = 1\n    for i in range(n):\n        ways *= nums[i]\n    return ways\n\ndef main():\n    nums = [4, 3, 2, 7, 8]\n    print(count_ways(5, nums))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def num_ways(n):\n    return bin(n).count(\"1\")\n\nprint(\"Partition 1: \", num_ways(1))\nprint(\"Partition 2: \", num_ways(2))\nprint(\"Partition 3: \", num_ways(3))\nprint(\"Partition 4: \", num_ways(4))\nprint(\"Partition 5: \", num_ways(5))\nprint(\"Partition 6: \", num_ways(6))\nprint(\"Partition 7: \", num_ways(7))\nprint(\"Partition 8: \", num_ways(8))\nprint(\"Partition 9: \", num_ways(9))\nprint(\"Partition 10: \", num_ways(10))\nprint(\"Partition 11: \", num_ways(11))\nprint(\"Partition 12: \", num_ways(12))\nprint(\"Partition 13: \", num_ways(13))\nprint(\"Partition 14: \", num_ways(14))\nprint(\"Partition 15: \", num_ways(15))\nprint(\"Partition 16: \", num_ways(16))\nprint(\"Partition 17: \", num_ways(17))\nprint(\"Partition 18: \", num_ways(18))\nprint(\"Partition 19: \", num_ways(19))\nprint(\"Partition 20: \", num_ways(20))\nprint(\"Partition 21: \", num_ways(21))\nprint(\"Partition 22: \", num_ways(22))\nprint(\"Partition 23: \", num_ways(23))\nprint(\"Partition 24: \", num_ways(24))\nprint(\"Partition 25: \", num_ways(25))\nprint(\"Partition 26: \", num_ways(26))\nprint(\"Partition 27: \", num_ways(27))\nprint(\"Partition 28: \", num_ways(28))\nprint(\"Partition 29: \", num_ways(29))\nprint(\"Partition 30: \", num_ways(30))\nprint(\"Partition 31: \", num_ways(31))\nprint(\"Partition 32: \", num_ways(32))\nprint(\"Partition 33: \", num_ways(33))\nprint(\"Partition 34: \", num_ways(34))\nprint(\"Partition 35: \", num_ways(35))\nprint"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\ndef numberOfWaysToPartition(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    ways = defaultdict(int)\n    ways[0] = 1\n    for i in range(1, n+1):\n        ways[i] = ways[i-1] + ways[i-2]\n    return ways[n]\n\n\nif __name__ == '__main__':\n    print numberOfWaysToPartition(4)\n    print numberOfWaysToPartition(10)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import time\nstart_time = time.time()\n\ndef ways(n):\n    # Base case\n    if n == 1:\n        return 1\n\n    # Recursive case\n    return ways(n - 1) + ways(n - 2) + ways(n - 3) + ways(n - 4) + ways(n - 5) + ways(n - 6) + ways(n - 7) + ways(n - 8)\n\nprint(ways(7))\n\nend_time = time.time()\nprint(\"Total time taken: {}\".format(end_time - start_time))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def count_ways(n):\n    ways = [1]\n    for i in range(n):\n        ways.append(ways[i] + ways[i + 1])\n    return ways[-1]\n\nif __name__ == '__main__':\n    assert(count_ways(10) == 168)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/partition-the-number-into-two-parts/discuss/175568/Python-solution-with-more-explanation\n\nclass Solution(object):\n    def numWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # The idea is to generate all combinations of the bell numbers,\n        # and then find the number of combinations that are in a certain range.\n        # For example, there are 4 ways to partition a set of 3 numbers\n        # from 1 to 3, and the result is 6.\n        # The first two numbers are 1 and 2, so 6 ways to partition 1 to 2.\n        # The next two numbers are 2 and 3, so 6 ways to partition 2 to 3.\n        # The next two numbers are 3 and 4, so 6 ways to partition 3 to 4.\n        # The next two numbers are 4 and 5, so 6 ways to partition 4 to 5.\n        # The next two numbers are 5 and 6, so 6 ways to partition 5 to 6.\n        # The next two numbers are 6 and 7, so 6 ways to partition 6 to 7.\n        # The next two numbers are 7 and 8, so 6 ways to partition 7 to 8.\n        # The next two numbers are 8 and 9, so 6 ways to partition 8 to 9.\n        # The next two numbers are 9 and 10, so 6 ways to partition 9 to 10.\n        # The next two numbers are 10 and 11, so 6 ways to partition 10 to 11.\n        # The next two numbers are 11 and 12, so 6 ways to partition 11 to 12.\n        # The next two numbers are 12 and 13, so 6 ways to partition 12 to 13.\n        # The next two numbers are 13 and 14, so 6 ways to partition 13 to 14.\n        # The next two numbers are 14 and 15, so 6 ways to partition 14 to 15.\n        # The next two numbers are 15 and 16, so 6 ways to partition 15 to 16.\n        # The next two numbers are 16 and 17, so 6 ways to partition 16 to 17.\n        # The next two numbers are 17 and 18, so 6 ways to partition 17 to 18.\n        # The next two numbers are 18"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def partition(n):\n    \"\"\"\n    >>> partition(5)\n    4\n    >>> partition(6)\n    5\n    >>> partition(7)\n    6\n    >>> partition(8)\n    7\n    >>> partition(9)\n    8\n    >>> partition(10)\n    9\n    >>> partition(11)\n    10\n    >>> partition(12)\n    11\n    >>> partition(13)\n    12\n    >>> partition(14)\n    13\n    >>> partition(15)\n    14\n    >>> partition(16)\n    15\n    >>> partition(17)\n    16\n    >>> partition(18)\n    17\n    >>> partition(19)\n    18\n    >>> partition(20)\n    19\n    >>> partition(21)\n    20\n    >>> partition(22)\n    21\n    >>> partition(23)\n    22\n    >>> partition(24)\n    23\n    >>> partition(25)\n    24\n    >>> partition(26)\n    25\n    >>> partition(27)\n    26\n    >>> partition(28)\n    27\n    >>> partition(29)\n    28\n    >>> partition(30)\n    29\n    >>> partition(31)\n    30\n    >>> partition(32)\n    31\n    >>> partition(33)\n    32\n    >>> partition(34)\n    33\n    >>> partition(35)\n    34\n    >>> partition(36)\n    35\n    >>> partition(37)\n    36\n    >>> partition(38)\n    37\n    >>> partition(39)\n    38\n    >>> partition(40)\n    39\n    >>> partition(41)\n    40\n    >>> partition(42)\n    41\n    >>> partition(43)\n    42\n    >>> partition(44)\n    43\n    >>> partition(45)\n    44\n    >>> partition(46)\n    45\n    >>> partition(47)\n    46\n    >>> partition(48)\n    47\n    >>> partition(49)\n    48\n    >>> partition(50)\n    49\n    >>> partition(51)\n    50\n    >>> partition(52)\n    51\n    >>> partition(53)\n    52\n    >>> partition(54)\n    53\n    >>>"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def partition(n):\n    if n == 1:\n        return 1\n    partitioned = [0] * (n + 1)\n    partitioned[0] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            partitioned[i] += partitioned[i - j - 1]\n    return partitioned[n]\n\nprint(partition(6))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "import itertools\n\ndef partition(n):\n    ways = [0 for _ in range(n + 1)]\n    ways[0] = 1\n    ways[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            ways[i] += ways[j - 1]\n    return ways[-1]\n\n\ndef main():\n    n = int(input())\n    print(partition(n))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def partition(n):\n    if n == 1:\n        return 1\n    else:\n        return sum([partition(n - 1) for i in range(2, n + 1)])\n\n\ndef main():\n    n = int(input())\n    print(partition(n))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def partition(n):\n    count = 0\n    for i in range(1, n + 1):\n        if i == n or i % n == 0:\n            count += 1\n        else:\n            while i % n == 0:\n                i = i // n\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    print(partition(8))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://discuss.leetcode.com/topic/2326/java-solution-with-explanation\n# https://discuss.leetcode.com/topic/26962/java-solution-with-explanation\n\nclass Solution(object):\n    def numWays(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        ways = [1] * m\n        for i in xrange(n - 1, -1, -1):\n            for j in xrange(1, m + 1):\n                ways[j - 1] = ways[j - 1] * (i + 1)\n        return ways[0]"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# https://discuss.leetcode.com/topic/17984/python-solution-with-explanation-o-n-time-and-o-n-space-in-o-1-time\n# https://discuss.leetcode.com/topic/12118/o-1-time-o-n-space-solution-with-explanation\n# https://discuss.leetcode.com/topic/11138/o-1-time-o-n-space-solution-with-explanation\n# https://discuss.leetcode.com/topic/11138/o-1-time-o-n-space-solution-with-explanation\n# https://discuss.leetcode.com/topic/11138/o-1-time-o-n-space-solution-with-explanation\n\n# Approach:\n# 1. Using the idea of counting the number of ways to partition a set of numbers into two groups of the same size.\n#    Recursive:\n#    for each number in the set, find the number of ways to partition it into two groups of the same size.\n#    The idea is to build a 2D array, where the first row is the number, the second row is the number of ways to partition the number into two groups of the same size.\n#    The second row is the number of ways to partition the number into one group of the same size.\n#    Then, when we go to the next number, we can simply add the two numbers together and then multiply them.\n# 2. Using a dynamic programming approach, we can solve it in O(n) time and O(n) space.\n\n# Note:\n# The set of numbers can be any size.\n# The number of partitions can be any size.\n# Example:\n# Input:\n# [1, 2, 4, 7, 8, 9]\n# Output:\n# 6\n# Explanation:\n# There are 6 ways to partition 1 into two groups of the same size:\n# 1. [1, 1]\n# 2. [1, 2]\n# 3. [2, 2]\n# 4. [3, 3]\n# 5. [4, 4]\n# 6."
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def partition(n, k):\n    if n < k:\n        return 0\n    elif n == k:\n        return 1\n    elif n % k == 0:\n        return partition(n//k, k) + partition(n//k, k-1)\n    else:\n        return partition(n//k, k) + partition(n//k + 1, k)\n\nprint(partition(13, 5))\nprint(partition(13, 2))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def count_ways(n, k):\n    ways = [0]*(k+1)\n    ways[0] = 1\n    for i in range(1,k+1):\n        ways[i] = ways[i-1] + ways[i-1]\n    for i in range(2,k+1):\n        ways[i] = ways[i-1] + ways[i-2]\n    for i in range(k+1,n+1):\n        ways[i] = ways[i-1] + ways[i-2]\n    return ways[n]\n\ndef main():\n    print(count_ways(3, 3))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 17,
      "score": 9.994331165610069,
      "candidate": "import sys\nsys.setrecursionlimit(100000)\n\n\ndef partition(n, p, m):\n    if n == 1:\n        return 1\n    if p == 0:\n        return 0\n    if n == 2:\n        return m\n    if p == 1:\n        return partition(n - 1, p, m) + partition(n - 1, p - 1, m)\n    else:\n        return partition(n - 1, p - 1, m) + partition(n - 1, p, m) + partition(n - 1, p + 1, m)\n\n\ndef main():\n    print(partition(10, 5, 10))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 18,
      "score": 9.941928993508103,
      "candidate": "def count_ways(n):\n    count = [1] * n\n    for i in range(1, n):\n        for j in range(1, i):\n            count[i] += count[i-j] * count[j]\n    return count[n-1]\n\ndef main():\n    print(count_ways(3))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 19,
      "score": 9.922023229801196,
      "candidate": "class BellNumber:\n    def __init__(self):\n        self.bell_numbers = [1]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.bell_numbers:\n            self.bell_numbers.pop()\n            for i in range(len(self.bell_numbers)):\n                self.bell_numbers[i] = self.bell_numbers[i] * (self.bell_numbers[i - 1] + self.bell_numbers[i])\n            yield self.bell_numbers[-1]\n        else:\n            raise StopIteration\n\n\ndef main():\n    for n in range(2, 100):\n        nbr = BellNumber()\n        print(nbr.__next__())\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 20,
      "score": 9.907737807108244,
      "candidate": "def find_partitions(n):\n    \"\"\"\n    Write a function to find the number of ways to partition a set of bell numbers.\n\n    Example\n    =======\n\n    >>> find_partitions(10)\n    4\n    >>> find_partitions(15)\n    9\n    >>> find_partitions(20)\n    24\n    >>> find_partitions(100)\n    121649\n\n    Reference\n    =========\n\n   .. [1] https://www.hackerrank.com/challenges/partition-a-set-of-bell-numbers/problem\n    \"\"\"\n    ways = [1]\n    for i in range(2, n+1):\n        ways.append(ways[i-1] * (n//i))\n    return ways[n]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.901662478081343,
      "candidate": "# https://www.hackerrank.com/challenges/set-partitioning/problem\n\nimport sys\nimport collections\n\ndef partition(nums, start, end):\n    # base case\n    if start == end:\n        return 1\n\n    # recursive case\n    return sum(partition(nums, start, x) for x in range(start + 1, end + 1))\n\ndef set_partitioning(nums):\n    # print nums\n    return partition(nums, 0, len(nums))\n\nif __name__ == \"__main__\":\n    nums = list(map(int, sys.stdin.readline().split()))\n    print set_partitioning(nums)"
    },
    {
      "rank": 22,
      "score": 9.901655582616199,
      "candidate": "from collections import defaultdict\n\ndef ways(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    ways = defaultdict(lambda: defaultdict(lambda: 0))\n    ways[1] = [1]\n    for i in range(2, n+1):\n        for ways_i in ways[i]:\n            ways[i][i] = 1\n            for j in range(i, n+1):\n                if i <= j < n:\n                    ways[j][i] += ways[j][i-1]\n                if i < j < n:\n                    ways[j][i] += ways[i][j-1]\n    return ways[n][n]\n\nif __name__ == '__main__':\n    print(ways(6))"
    },
    {
      "rank": 23,
      "score": 9.877488625086825,
      "candidate": "def partition(n):\n    # partition(n)\n    if n <= 0:\n        return 0\n    else:\n        return 1 + partition(n - 1)\n\ndef partition2(n):\n    # partition2(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition2(n - 1)\n\ndef partition3(n):\n    # partition3(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition3(n - 1)\n\ndef partition4(n):\n    # partition4(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition4(n - 1)\n\ndef partition5(n):\n    # partition5(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition5(n - 1)\n\ndef partition6(n):\n    # partition6(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition6(n - 1)\n\ndef partition7(n):\n    # partition7(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition7(n - 1)\n\ndef partition8(n):\n    # partition8(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition8(n - 1)\n\ndef partition9(n):\n    # partition9(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition9(n - 1)\n\ndef partition10(n):\n    # partition10(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition10(n - 1)\n\ndef partition11(n):\n    # partition11(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition11(n - 1)\n\ndef partition12(n):\n    # partition12(n)\n    if n <= 1:\n        return 1\n    else:\n        return n * partition12(n - 1)"
    },
    {
      "rank": 24,
      "score": 9.874416912804335,
      "candidate": "# Definition for a Bell number\nclass BellNumber(object):\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.n = n\n\n    def get_bell_number(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.n == 0:\n            return 1\n        else:\n            return self.get_bell_number(self.n - 1) + self.get_bell_number(self.n - 2)\n\n\n# Your BellNumber object will be instantiated and called as such:\n# obj = BellNumber(n)\n# param_1 = obj.get_bell_number()"
    },
    {
      "rank": 25,
      "score": 9.873536447852498,
      "candidate": "def ways(n):\n    ways = [0] * (n+1)\n    ways[0] = 1\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            ways[i] += ways[i-j]\n    return ways[n]\n\ndef main():\n    print(ways(15))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 26,
      "score": 9.87013080214249,
      "candidate": "def find_ways(n):\n    ways = [1 for i in range(n + 1)]\n    ways[0] = 1\n    ways[1] = 1\n    for i in range(2, n + 1):\n        for j in range(2, i):\n            ways[i] += ways[i - j]\n    return ways[n]\n\ndef main():\n    n = int(input())\n    print(find_ways(n))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 27,
      "score": 9.862381898428938,
      "candidate": "def ways(n):\n    ways = [0] * (n + 1)\n    ways[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            ways[i] += ways[i - j]\n\n    return ways[-1]\n\nprint(ways(10))\nprint(ways(5))"
    },
    {
      "rank": 28,
      "score": 9.80282075790732,
      "candidate": "import math\n\n\ndef ways(n):\n    if n < 2:\n        return 0\n    return int(math.factorial(n) / math.factorial(n - 1))\n\n\ndef main():\n    for n in range(1, 20):\n        print(n, ways(n))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 29,
      "score": 9.798746820104979,
      "candidate": "from collections import defaultdict\n\n\ndef count_ways(n):\n    \"\"\"\n    >>> count_ways(5)\n    3\n    >>> count_ways(6)\n    12\n    \"\"\"\n    ways = defaultdict(int)\n    ways[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            ways[i] += ways[j - 1]\n    return ways[n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 9.782326508325069,
      "candidate": "import math\n\n\ndef partition(n):\n    return math.factorial(n) / math.factorial(n - 1)\n\n\ndef ways(n):\n    return int(math.factorial(n) / (partition(n) * partition(n)))\n\n\ndef main():\n    print(ways(4))\n    print(ways(5))\n    print(ways(6))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 31,
      "score": 9.771359255699423,
      "candidate": "def partition(n):\n    \"\"\"\n    >>> partition(5)\n    3\n    >>> partition(6)\n    2\n    >>> partition(7)\n    1\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    # n > 2\n    ways = 0\n    # n-1 = 3n-6\n    for i in range(3, n):\n        ways += partition(i)\n        # n-1 = (n-2)n-4\n        ways += partition(n-1)\n    ways += partition(n-2)\n    return ways\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 9.747731750234102,
      "candidate": "# Definition for a Bell number\nclass BellNumber:\n    def __init__(self, n):\n        self.n = n\n        self.bell_number = 1\n        self.set = set()\n        self.visited = set()\n\n    def __str__(self):\n        return str(self.bell_number) +'' + str(self.set)\n\n    def __repr__(self):\n        return str(self.bell_number) +'' + str(self.set)\n\n    def __iter__(self):\n        return iter(self.set)\n\n    def _bell_number(self, n):\n        if n < 0:\n            return 0\n        elif n in self.visited:\n            return self.visited[n]\n        else:\n            self.visited[n] = 1\n            self.set.add(n)\n            if n == 1:\n                return 1\n            else:\n                self.bell_number = self.bell_number + self._bell_number(n - 1)\n                self.set.remove(n)\n                return self.bell_number\n\n    def bell_number(self):\n        return self._bell_number(self.n)\n\n\ndef main():\n    # test cases\n    n = BellNumber(5)\n    n = BellNumber(1)\n    n = BellNumber(0)\n    n = BellNumber(4)\n    n = BellNumber(5)\n    n = BellNumber(6)\n    n = BellNumber(7)\n    n = BellNumber(8)\n    n = BellNumber(9)\n    n = BellNumber(10)\n    n = BellNumber(11)\n    n = BellNumber(12)\n    n = BellNumber(13)\n    n = BellNumber(14)\n    n = BellNumber(15)\n    n = BellNumber(16)\n    n = BellNumber(17)\n    n = BellNumber(18)\n    n = BellNumber(19)\n    n = BellNumber(20)\n    n = BellNumber(21)\n    n = BellNumber(22)\n    n = BellNumber(23)\n    n = BellNumber(24)\n    n"
    },
    {
      "rank": 33,
      "score": 9.747283222863654,
      "candidate": "import sys\nsys.setrecursionlimit(1000000)\n\ndef num_ways(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    return num_ways(n-1) + num_ways(n-2) + num_ways(n-3) + num_ways(n-4) + num_ways(n-5) + num_ways(n-6) + num_ways(n-7) + num_ways(n-8)\n\n\ndef main():\n    n = int(input())\n    print(num_ways(n))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 34,
      "score": 9.660432686784862,
      "candidate": "def num_ways(n, k):\n    ways = [0] * (n+1)\n    ways[0] = 1\n    for i in range(1, n+1):\n        ways[i] = ways[i-1]\n        for j in range(1, k+1):\n            ways[i] += ways[i-j]\n    return ways[n]\n\nif __name__ == \"__main__\":\n    n = 10\n    k = 5\n    print(num_ways(n, k))"
    },
    {
      "rank": 35,
      "score": 9.574610929459542,
      "candidate": "def partition(n):\n    \"\"\"\n    >>> partition(4)\n    3\n    >>> partition(5)\n    6\n    >>> partition(6)\n    1\n    >>> partition(7)\n    8\n    >>> partition(8)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return sum(partition(i) for i in range(1, n))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 9.555761409838523,
      "candidate": "def number_of_ways(n, m):\n    \"\"\"\n    :type n: int\n    :type m: int\n    :rtype: int\n    \"\"\"\n    ways = 1\n    for i in range(n, 0, -1):\n        ways *= i\n        for j in range(m, 0, -1):\n            ways /= i * (i - 1) / j\n    return ways\n\ndef test():\n    assert number_of_ways(3, 2) == 1\n    assert number_of_ways(3, 3) == 2\n    assert number_of_ways(3, 4) == 4\n    assert number_of_ways(3, 5) == 6\n    assert number_of_ways(3, 6) == 6\n    assert number_of_ways(3, 7) == 12\n    assert number_of_ways(3, 8) == 24\n    assert number_of_ways(3, 9) == 24\n    assert number_of_ways(3, 10) == 48\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 37,
      "score": 9.535339310917468,
      "candidate": "def count_partitions(n):\n    \"\"\"\n    >>> count_partitions(10)\n    4\n    >>> count_partitions(15)\n    5\n    >>> count_partitions(100)\n    8\n    >>> count_partitions(200)\n    12\n    >>> count_partitions(1000)\n    829\n    \"\"\"\n    n = int(n)\n    if n == 1:\n        return 1\n    if n == 2:\n        return 4\n    if n == 3:\n        return 16\n    if n == 4:\n        return 64\n    if n == 5:\n        return 256\n    if n == 6:\n        return 1024\n    if n == 7:\n        return 4096\n    if n == 8:\n        return 16384\n    if n == 9:\n        return 65536\n    if n == 10:\n        return 262144\n    if n == 11:\n        return 1048576\n    if n == 12:\n        return 4194304\n    if n == 13:\n        return 16777216\n    if n == 14:\n        return 67108864\n    if n == 15:\n        return 268435456\n    if n == 16:\n        return 1073741824\n    if n == 17:\n        return 4294967296\n    if n == 18:\n        return 16777216384\n    if n == 19:\n        return 67108864384\n    if n == 20:\n        return 268435456384\n    if n == 21:\n        return 1073741824384\n    if n == 22:\n        return 4194304064384\n    if n == 23:\n        return 16777216064384\n    if n == 24:\n        return 67108864064384\n    if n == 25:\n        return 2684354564064384\n    if n == 26:\n        return 10737418244064384\n    if n == 27:\n        return 41943040644064384\n    if n == 28:\n        return 167772160644064384\n    if n == 29:\n        return 671088640644064384\n    if n == 30:\n        return 268435456406440384"
    },
    {
      "rank": 38,
      "score": 9.516582697482633,
      "candidate": "def num_ways(n, m):\n    ways = [[0 for x in range(m)] for x in range(n)]\n    ways[0][0] = 1\n    for i in range(1, n):\n        for j in range(m):\n            if i == 0:\n                ways[i][j] = 1\n            else:\n                ways[i][j] = ways[i-1][j] + ways[i][j-1]\n    return ways[n-1][m-1]\n\ndef main():\n    print num_ways(4, 4)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 39,
      "score": 9.497593217886118,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def numWays(self, num):\n        if len(num) == 1:\n            return 1\n        n = len(num)\n        dp = [[0 for x in range(n+1)] for x in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            dp[i][i] = 1\n        for i in range(2, n+1):\n            for j in range(1, i):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        return dp[n][n]\n\n\nif __name__ == \"__main__\":\n    print Solution().numWays([1, 2, 3])"
    },
    {
      "rank": 40,
      "score": 9.401605761790348,
      "candidate": "class Solution:\n\t# @param {integer[]} nums\n\t# @return {integer}\n\tdef numWays(self, nums):\n\t\treturn self.solve(nums, 0, [])\n\n\tdef solve(self, nums, num, ways):\n\t\tif len(nums) == 0:\n\t\t\treturn 1\n\t\tfor i in range(num + 1):\n\t\t\tways += self.solve(nums[:i] + nums[i + 1:], i, ways)\n\t\treturn ways\n\n\nif __name__ == '__main__':\n\ts = Solution()\n\tprint(s.numWays([1,2,3,4,5,6]))"
    },
    {
      "rank": 41,
      "score": 9.196422297243725,
      "candidate": "def partition(n):\n    if n == 0:\n        return 1\n    return (partition(n-1) + partition(n-2)) * n\n\ndef test_partition():\n    assert partition(3) == 6\n    assert partition(4) == 8\n    assert partition(5) == 15\n    assert partition(6) == 24\n    assert partition(7) == 49\n    assert partition(8) == 132\n    assert partition(9) == 288\n\nif __name__ == '__main__':\n    test_partition()"
    },
    {
      "rank": 42,
      "score": 9.176938547970494,
      "candidate": "def find_ways(n, k):\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            ways[i] += ways[i - j]\n    return ways[-1]\n\nif __name__ == '__main__':\n    for n in range(1, 10):\n        for k in range(1, 10):\n            print(n, k, find_ways(n, k))"
    },
    {
      "rank": 43,
      "score": 8.934000417251736,
      "candidate": "def n_partitions(n):\n    if n < 2:\n        return 1\n\n    return (n + 1) * n_partitions(n - 1)\n\n\nif __name__ == '__main__':\n    print(n_partitions(3))\n    print(n_partitions(8))\n    print(n_partitions(12))"
    },
    {
      "rank": 44,
      "score": 8.929483977746786,
      "candidate": "import itertools\n\ndef partition(n):\n    return sum(itertools.starmap(lambda x: n//x, itertools.count(1)))\n\nprint(partition(10))"
    },
    {
      "rank": 45,
      "score": 8.898795562810127,
      "candidate": "def num_ways(n, nums):\n    \"\"\"\n    n is the number of bells\n    nums is the set of bells\n    return the number of ways to partition the set\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return nums[0] * nums[1]\n    ways = 0\n    for i in range(n):\n        for j in range(i+1):\n            if j == i:\n                ways += nums[i] * nums[j]\n            else:\n                ways += nums[i] * nums[j] * nums[i-j-1]\n    return ways\n\nif __name__ == '__main__':\n    n = 5\n    nums = [2, 3, 4, 5, 6]\n    print(num_ways(n, nums))"
    },
    {
      "rank": 46,
      "score": 8.634064093985113,
      "candidate": "def count_ways(n):\n    ways = [1 for i in range(n+1)]\n    ways[0] = 1\n    for i in range(1,n+1):\n        for j in range(i):\n            ways[i] += ways[j]\n    return ways[n]\n\nif __name__ == \"__main__\":\n    print(count_ways(5))\n    print(count_ways(7))\n    print(count_ways(12))"
    },
    {
      "rank": 47,
      "score": 8.612638057956094,
      "candidate": "def ways(n):\n    ways = [1] * n\n    for i in range(1, n):\n        ways[i] = ways[i - 1] * (n - i + 1)\n    return ways[-1]\n\nif __name__ == \"__main__\":\n    print(ways(10))"
    },
    {
      "rank": 48,
      "score": 8.598425831877927,
      "candidate": "def num_partitions(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n < 2:\n        return 1\n\n    num = [0] * (n+1)\n    for i in range(1, n+1):\n        num[i] = num[i-1] + 1\n    for i in range(2, n+1):\n        num[i] += num[i-1]\n    return num[n]\n\nif __name__ == '__main__':\n    n = int(input())\n    print(num_partitions(n))"
    },
    {
      "rank": 49,
      "score": 8.560910830131602,
      "candidate": "def num_ways(n, m):\n    ways = [1]\n    ways.append(1)\n    for i in range(m):\n        ways.append(ways[i] * ways[n-i-1])\n    return ways[-1]\n\nprint(num_ways(4, 3))"
    },
    {
      "rank": 50,
      "score": 8.556477082152053,
      "candidate": "import timeit\n\n\ndef ways(n):\n    ways = 0\n    for i in range(1, n+1):\n        if i == 1:\n            ways += 1\n        else:\n            if i % 2 == 0:\n                ways += ways(i/2)\n            else:\n                ways += ways(i/2) + 1\n    return ways\n\n\nprint(ways(5))\n\nprint(timeit.Timer(\"ways(5)\").timeit(number=1))"
    },
    {
      "rank": 51,
      "score": 8.555149341613086,
      "candidate": "def count_ways(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    ways = 0\n    for i in range(1, n+1):\n        ways += count_ways(n-i, k)\n    return ways\n\n\nif __name__ == \"__main__\":\n    print(count_ways(10, 2))\n    print(count_ways(10, 3))\n    print(count_ways(10, 5))\n    print(count_ways(10, 7))"
    },
    {
      "rank": 52,
      "score": 8.546357288438946,
      "candidate": "def partition(n):\n    \"\"\"\n    Partition a set of numbers into n disjoint subsets.\n\n    :param n: An integer\n    :return: An integer\n    \"\"\"\n    # Base cases\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 4\n    else:\n        return partition(n-1) + partition(n-2) + partition(n-3)\n\nprint(partition(5))"
    },
    {
      "rank": 53,
      "score": 8.544910474956831,
      "candidate": "from itertools import combinations\nimport re\n\ndef ways(n):\n    ways = [1] * n\n    for i in range(1, n):\n        for combo in combinations(ways, i):\n            ways[i] += sum(combo)\n    return ways[n-1]\n\nprint(ways(3))"
    },
    {
      "rank": 54,
      "score": 8.54186111754898,
      "candidate": "def ways(n):\n    ways = 0\n    for i in range(1, n+1):\n        ways += ways_of_partition(i, n)\n    return ways\n\ndef ways_of_partition(n, n_partitions):\n    \"\"\"\n    n: integer, n partions\n    n_partitions: integer, n_partitions\n    return: integer\n    \"\"\"\n    ways = 1\n    for i in range(1, n+1):\n        ways *= n_partitions - i\n        ways /= i\n    return ways\n\nif __name__ == '__main__':\n    assert(ways(4) == 6)\n    assert(ways(5) == 120)\n    assert(ways(10) == 5040)"
    },
    {
      "rank": 55,
      "score": 8.519452748629915,
      "candidate": "def partition(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # 1st stage\n    # we can use a set to keep track of the number of ways to partition\n    # each number into parts\n    # each number can be divided into 1 or 2 parts\n    # the number of ways to partition a set of bell numbers is the sum of the\n    # number of ways to partition each part\n    # 1st stage\n    # we need to sum up the number of ways to partition a set of bell numbers\n    # each part is the sum of the numbers of bell numbers in the set\n    # we need to use a set to keep track of the number of ways to partition\n    # each number into parts\n    # each number can be divided into 1 or 2 parts\n    # the number of ways to partition a set of bell numbers is the sum of the\n    # number of ways to partition each part\n    # 2nd stage\n    # we need to sum up the number of ways to partition a set of bell numbers\n    # each part is the sum of the numbers of bell numbers in the set\n    # we need to use a set to keep track of the number of ways to partition\n    # each number into parts\n    # each number can be divided into 1 or 2 parts\n    # the number of ways to partition a set of bell numbers is the sum of the\n    # number of ways to partition each part\n    # 3rd stage\n    # we need to sum up the number of ways to partition a set of bell numbers\n    # each part is the sum of the numbers of bell numbers in the set\n    # we need to use a set to keep track of the number of ways to partition\n    # each number into parts\n    # each number can be divided into 1 or 2 parts\n    # the number of ways to partition a set of bell numbers is the sum of the\n    # number of ways to partition each part\n    # 4th stage\n    # we need to sum up the number of ways to partition a set of bell numbers\n    # each part is the sum of the numbers of bell numbers in the set\n    # we need to use a set to keep track of the number of ways to partition\n    # each number into parts\n    # each number can be divided into 1 or 2 parts"
    },
    {
      "rank": 56,
      "score": 8.50919215889592,
      "candidate": "def partition(n, k):\n    \"\"\"\n    Return the number of ways to partition the set of bell numbers\n    n = the number of bells, k = the number of bells to be partitioned\n    \"\"\"\n    # Base cases\n    if n == 0 or k == 0:\n        return 1\n    elif n == 1 or k == 1:\n        return 2\n    elif n == 2 or k == 2:\n        return 4\n    else:\n        return (partition(n-1, k-1) +\n                partition(n-1, k) +\n                partition(n-1, k-2) +\n                partition(n-2, k-1))\n\nprint(partition(10, 10))"
    },
    {
      "rank": 57,
      "score": 8.474538484742338,
      "candidate": "#!/usr/bin/env python\n\ndef partition(n):\n\t'''\n\tPartition the set of bell numbers.\n\t'''\n\tways = [1] * n\n\tfor i in range(2, n+1):\n\t\tfor j in range(i):\n\t\t\tways[i] += ways[j]\n\treturn ways\n\nif __name__ == '__main__':\n\tn = 6\n\tprint partition(n)"
    },
    {
      "rank": 58,
      "score": 8.47289028517045,
      "candidate": "def partition(n):\n    if n <= 1:\n        return 1\n    \n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            if (i % j == 0) and (i / j <= (n / j)):\n                count += partition(n / j) * (j - 1)\n    return count\n\nif __name__ == '__main__':\n    print partition(5)"
    },
    {
      "rank": 59,
      "score": 8.471429035598277,
      "candidate": "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n\n    # The number of ways to partition a set of n numbers is 2^(n-1).\n    # Since the set of numbers is 1, 2, 3, 4, 5,..., n,\n    # we can calculate the number of ways to partition the set by using\n    # the following formula\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5) *...\n    # 2^(n-1) = 2^(n-1) * 2^(n-2) * 2^(n-3) * 2^(n-4) * 2^(n-5"
    },
    {
      "rank": 60,
      "score": 8.446029616003608,
      "candidate": "from collections import defaultdict\n\ndef ways(n, m):\n    ways = defaultdict(lambda: 0)\n    ways[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i >= j:\n                ways[i] += ways[i - j]\n    return ways[n]\n\nif __name__ == '__main__':\n    n = int(input())\n    m = int(input())\n    print(ways(n, m))"
    },
    {
      "rank": 61,
      "score": 8.43333837232036,
      "candidate": "import sys\nfrom collections import defaultdict\n\ndef ways(n):\n    \"\"\"\n    A function to compute the number of ways to partition a set of\n    bell numbers.\n    \"\"\"\n    ways = defaultdict(int)\n    ways[1] = 1\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            ways[i] += ways[i-j]\n    return ways[n]\n\nif __name__ == '__main__':\n    n = int(sys.argv[1])\n    print(ways(n))"
    },
    {
      "rank": 62,
      "score": 8.325068937515386,
      "candidate": "def num_partitions(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def dfs(n):\n        if n == 0:\n            return 1\n        if n == 1:\n            return 2\n        return dfs(n - 1) + dfs(n - 2)\n    return dfs(n)\n\nif __name__ == \"__main__\":\n    print(num_partitions(6))"
    },
    {
      "rank": 63,
      "score": 8.322890916973476,
      "candidate": "def count_ways(n):\n    ways = [0] * (n+1)\n    ways[0] = 1\n    for i in range(1, n+1):\n        ways[i] = ways[i-1] + ways[i-2]\n    return ways[n]\n\n\nif __name__ == '__main__':\n    print(count_ways(3))"
    },
    {
      "rank": 64,
      "score": 8.300784959672582,
      "candidate": "def partition(n):\n    \"\"\"\n    >>> partition(10)\n    9\n    >>> partition(20)\n    55\n    >>> partition(100)\n    3024\n    \"\"\"\n    if n < 2:\n        return 1\n    ways = 0\n    for i in range(2, n + 1):\n        ways += partition(n - i)\n    return ways\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 65,
      "score": 8.288899760933239,
      "candidate": "import sys\nimport collections\n\ndef num_ways(n):\n    ways = [1] * n\n    ways[0] = 0\n    ways[1] = 1\n    for i in range(2, n):\n        ways[i] = ways[i - 1] + ways[i - 2]\n    return ways[-1]\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        n = int(sys.argv[1])\n    else:\n        n = 6\n    print(\"%d\\t%d\" % (n, num_ways(n)))"
    },
    {
      "rank": 66,
      "score": 8.280218781276663,
      "candidate": "# Definition for a bell number\nclass BellNumber:\n    def __init__(self, n):\n        \"\"\"\n        Initialize your data structure here.\n        :type n: int\n        \"\"\"\n        self.n = n\n        self.d = [0] * (n+1)\n        for i in range(2, n+1):\n            self.d[i] = self.d[i-1] + self.d[i-2]\n        \n    def add(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        self.n += x\n        for i in range(2, self.n+1):\n            self.d[i] += self.d[i-1]\n            \n    def remove(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        self.n -= x\n        for i in range(2, self.n+1):\n            self.d[i] -= self.d[i-1]\n        \n    def getCount(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.d[self.n]\n        \n        \n# Your BellNumber object will be instantiated and called as such:\n# obj = BellNumber(n)\n# param_1 = obj.add(x)\n# param_2 = obj.remove(x)\n# param_3 = obj.getCount()"
    },
    {
      "rank": 67,
      "score": 8.226807985342466,
      "candidate": "from collections import defaultdict\n\ndef count_ways(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    ways = defaultdict(int)\n    ways[0] = 1\n    for i in range(1, n+1):\n        ways[i] = ways[i-1] + ways[i-1]\n    return ways[n]\n\nif __name__ == '__main__':\n    print(count_ways(6))\n    print(count_ways(5))\n    print(count_ways(10))\n    print(count_ways(5))\n    print(count_ways(100))"
    },
    {
      "rank": 68,
      "score": 8.065982912953428,
      "candidate": "def partition(n):\n    \"\"\"\n    Partition a set of bell numbers into n groups.\n    >>> partition(5)\n    [[1, 2, 3, 4], [1, 2, 5, 4], [1, 2, 3, 5], [1, 2, 3, 4], [1, 2, 3, 4]]\n    \"\"\"\n    return [[i] for i in range(1, n+1)]\n\ndef ways(n):\n    \"\"\"\n    Return the number of ways to partition a set of bell numbers into n groups.\n    >>> ways(5)\n    5\n    >>> ways(10)\n    9\n    \"\"\"\n    ways = 1\n    for i in range(1, n+1):\n        ways *= partition(i)\n    return ways\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 69,
      "score": 8.032706769285932,
      "candidate": "def num_ways(n):\n    return num_ways_recursive(n, 1)\n\ndef num_ways_recursive(n, ways):\n    if n == 1:\n        return 1\n    elif n == 0:\n        return 0\n    elif n == 2:\n        return ways\n    elif n == 3:\n        return ways + 1\n    else:\n        return num_ways_recursive(n-1, ways) + num_ways_recursive(n-2, ways)\n\nif __name__ == \"__main__\":\n    n = 5\n    print num_ways(n)"
    },
    {
      "rank": 70,
      "score": 8.006630297030505,
      "candidate": "# Part 1\ndef partition(n):\n    ways = 1\n    for i in range(1, n + 1):\n        ways *= (n - i + 1) / i\n        ways /= (i + 1)\n    return ways\n\n# Part 2\ndef partition2(n):\n    ways = 1\n    for i in range(1, n + 1):\n        ways *= (n - i + 1) / (i + 1)\n        ways /= i\n    return ways\n\nif __name__ == '__main__':\n    print partition(10)\n    print partition2(10)"
    },
    {
      "rank": 71,
      "score": 7.990754810523488,
      "candidate": "import collections\n\ndef ways(n):\n    \"\"\"\n    Returns the number of ways to partition a set of bell numbers.\n\n    :type n: int\n    :rtype: int\n    \"\"\"\n\n    # Base cases\n    if n <= 1:\n        return 1\n\n    # Recursive case\n    return ways(n-1) + ways(n-2) + ways(n-3)\n\nif __name__ == '__main__':\n    print(ways(10))"
    },
    {
      "rank": 72,
      "score": 7.909719916365405,
      "candidate": "def partition(n):\n    \"\"\"\n    Returns the number of ways to partition a set of n numbers\n    in the form of a permutation of integers.\n\n    n is a positive integer.\n    \"\"\"\n    ways = 1\n    for i in range(1, n + 1):\n        ways *= i\n    return ways\n\nprint(partition(5))"
    },
    {
      "rank": 73,
      "score": 7.828298080918168,
      "candidate": "def num_partitions(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    return bin(n).count('1')\n\nif __name__ == '__main__':\n    assert num_partitions(4) == 3\n    assert num_partitions(10) == 5\n    assert num_partitions(17) == 12"
    },
    {
      "rank": 74,
      "score": 3.500115109817413,
      "candidate": "def count_ways(n):\n    ways = 1\n    for i in xrange(2, n+1):\n        ways *= (n-i+1)\n        ways /= i\n    return ways\n\n\n# Time:  O(n)\n# Space: O(1)\n# DP\nclass Solution(object):\n    def countWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        ways = [0] * (n+1)\n        ways[0] = 1\n        for i in xrange(1, n+1):\n            for j in xrange(i+1):\n                ways[i] += ways[i-j]\n        return ways[n]\n\n\nif __name__ == \"__main__\":\n    print Solution().countWays(10)"
    },
    {
      "rank": 75,
      "score": 3.3990313920802095,
      "candidate": "def n_partitions(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    # n_partitions(n) = n!\n    return n * (n - 1) // 2\n\n\nif __name__ == '__main__':\n    n = int(input())\n    print(n_partitions(n))"
    },
    {
      "rank": 76,
      "score": 3.2854230010791072,
      "candidate": "def count_partitions(n):\n    \"\"\"\n    count the number of ways to partition a set of bell numbers.\n\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return count_partitions(n - 1) + count_partitions(n - 2)\n\n\nif __name__ == '__main__':\n    n = 5\n    print(count_partitions(n))"
    },
    {
      "rank": 77,
      "score": 3.278369871073907,
      "candidate": "# Definition for a bell number.\n# class BellNumber(object):\n#     def __init__(self, n):\n#         \"\"\"\n#         n: An integer\n#         \"\"\"\n#         self.n = n\n\nclass Solution(object):\n    def __init__(self):\n        self.count = 0\n\n    def numWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return 2\n        if n == 2:\n            return 4\n        self.count += 1\n        return self.numWays(n - 1) + self.numWays(n - 2) + self.numWays(n - 3)\n\n\nif __name__ == \"__main__\":\n    n = 0\n    s = Solution()\n    print s.numWays(n)"
    },
    {
      "rank": 78,
      "score": 3.2709538824308466,
      "candidate": "import os\nimport sys\nsys.path.append('.')\nfrom problems.problem04 import partition_set\n\n\ndef solution(n):\n    return partition_set(n)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    print(solution(n))"
    },
    {
      "rank": 79,
      "score": 3.263397184323037,
      "candidate": "def count(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        count += n-i+1\n        for j in range(1, i+1):\n            count += n/i-j+1\n    return count\n\nif __name__ == \"__main__\":\n    assert(count(2) == 1)\n    assert(count(3) == 4)\n    assert(count(4) == 8)\n    assert(count(5) == 15)\n    assert(count(6) == 24)\n    assert(count(7) == 49)\n    assert(count(8) == 128)\n    assert(count(9) == 384)\n    assert(count(10) == 1023)\n    assert(count(11) == 4095)\n    assert(count(12) == 16383)\n    assert(count(13) == 65535)\n    assert(count(14) == 262143)\n    assert(count(15) == 1048576)\n    assert(count(16) == 33554432)\n    assert(count(17) == 134217728)\n    assert(count(18) == 67108864)\n    assert(count(19) == 268435456)\n    assert(count(20) == 1099511628800)\n    assert(count(21) == 4194304096)\n    assert(count(22) == 16777216)\n    assert(count(23) == 67108864)\n    assert(count(24) == 268435456)\n    assert(count(25) == 1099511628800)\n    assert(count(26) == 4194304096)\n    assert(count(27) == 16777216)\n    assert(count(28) == 67108864)\n    assert(count(29) == 268435456)\n    assert(count(30) == 1099511628800)\n    assert(count(31) == 4194304096)\n    assert(count(32) == 16777216)\n    assert(count(33) == 67108864)"
    },
    {
      "rank": 80,
      "score": 3.26153414744388,
      "candidate": "from collections import defaultdict\n\ndef partition_bell_numbers(n):\n    \"\"\"\n    Write a function to find the number of ways to partition a set of bell numbers.\n\n    Example\n    >>> partition_bell_numbers(20)\n    15\n    \"\"\"\n    ways = defaultdict(int)\n    ways[0] = 1\n    for i in range(1, n+1):\n        for j in range(i+1):\n            ways[i] += ways[i-j]\n    return ways[n]\n\nif __name__ == \"__main__\":\n    assert partition_bell_numbers(20) == 15"
    },
    {
      "rank": 81,
      "score": 3.2193819720464334,
      "candidate": "# Partitioning a set of numbers into a subset of size n\n# http://blog.csdn.net/lmj62356579/article/details/48170874\n\n# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def numSubsetsWithReplacement(self, nums):\n        # Write your code here\n        if not nums:\n            return 0\n\n        nums.sort()\n        dp = [0] * (len(nums) + 1)\n\n        dp[0] = 1\n        for i in range(1, len(nums) + 1):\n            dp[i] = 1\n            for j in range(0, i):\n                if nums[j] == nums[i]:\n                    dp[i] += dp[i - j - 1]\n            dp[i] += dp[i - 1]\n\n        return dp[-1]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.numSubsetsWithReplacement([1, 1, 2, 2, 3]))"
    },
    {
      "rank": 82,
      "score": 3.207207376871285,
      "candidate": "from collections import defaultdict\n\ndef ways(n):\n    # Returns the number of ways to partition a set of n numbers\n    # from 0 to n-1.\n    #\n    # For example, if n = 3, the set {0, 1, 2} is partitioned into\n    # two groups {0, 1} and {2}.\n    #\n    # The input is a list of integers, which can be obtained by\n    # reading the problem statement.\n    #\n    # Assume that all the numbers in the input are positive.\n    #\n    # Hint:\n    #\n    # Use a dynamic programming algorithm to solve this problem.\n    #\n    # For example, given n = 3, the following are the ways to partition\n    # the set {0, 1, 2}.\n    #\n    # {0, 1, 2}\n    # {0, 1, 2}, {0, 2, 1}\n    # {0, 2, 1}, {1, 0, 2}\n    # {1, 0, 2}, {2, 0, 1}\n    # {2, 0, 1}, {1, 2, 0}\n    # {1, 2, 0}, {2, 1, 0}\n    # {2, 1, 0}, {0, 2, 2}\n    # {2, 1, 0}, {0, 1, 2}\n    # {0, 2, 2}, {0, 1, 2}\n    #\n    # Note:\n    #\n    # 1 <= n <= 1000\n    #\n    # NOTE:\n    #\n    # The set of integers is a set of positive integers.\n    #\n    # For example, the input [3, 2, 4] is a valid input.\n    #\n    # Answer: 7\n    #\n    # Explanation:\n    #\n    # The ways to partition the set {0, 1, 2} is:\n    #\n    # {0, 1, 2}\n    # {0, 1, 2}, {0, 2, 1}\n    # {0, 2, 1}, {1, 0, 2}\n    # {1, 0, 2}, {2, 0, 1}\n    # {2, 0, 1}, {"
    },
    {
      "rank": 83,
      "score": 3.0927769381834844,
      "candidate": "# The input will be an array of integers.\n# The array will have at least one number.\n# The output should be a list of lists.\n# For each list, the output should be a list of integers.\n# The list of integers will be sorted in descending order.\n# The output list will contain only one list.\n# The list will contain at least one number.\n# The number of lists will be less than or equal to 100.\n# The output list will contain at least one number.\n# The number of numbers in the output list will be equal to the number of numbers in the input list.\n\n# Example 1:\n# Input: [1,2,3]\n# Output: [[1,2,3]]\n# Explanation:\n# There are 4 ways to partition the set {1, 2, 3}.\n# 1) [1,2,3]\n# 2) [1,3,2]\n# 3) [2,1,3]\n# 4) [2,3,1]\n# Example 2:\n# Input: [4,6,8]\n# Output: [[4,6,8]]\n# Explanation:\n# There are 8 ways to partition the set {4, 6, 8}.\n# 1) [4,6,8]\n# 2) [6,4,8]\n# 3) [8,6,4]\n# 4) [8,4,6]\n# 5) [4,8,6]\n# 6) [4,6,8]\n# 7) [6,8,4]\n# 8) [6,4,8]\n\n# Note:\n# The set can have duplicates, and will not contain duplicates.\n# All numbers in the set will be positive.\n# The input set will have at least one number.\n# The output list will not have repeated numbers.\n# The output list will contain at least one number.\n# The number of lists will be less than or equal to 100.\n# The output list will contain at least one number.\n# The number of numbers in the output list will be equal to the number of numbers in the input list.\n\n\nclass Solution(object):\n    def numWays(self, nums):\n        \"\"\"\n        :type nums: List["
    },
    {
      "rank": 84,
      "score": 3.0799524748074356,
      "candidate": "def num_ways(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    res = 1\n    for i in range(1, n):\n        res *= (n - i) / i\n    return res\n\nif __name__ == '__main__':\n    n = 5\n    k = 3\n    print(num_ways(n, k))"
    },
    {
      "rank": 85,
      "score": 3.07048492348857,
      "candidate": "import unittest\n\ndef partition(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def dfs(n, k, res, p):\n        if n == 0:\n            res[k] += 1\n            return\n        if n < p:\n            dfs(n-1, k, res, p)\n        elif n == p:\n            res[k] += 1\n        else:\n            dfs(n-1, k, res, p)\n            res[k] += 1\n    p = 1\n    res = [0]*(k+1)\n    dfs(n, 0, res, p)\n    return res[k]\n\nclass TestCode(unittest.TestCase):\n    def test_partition(self):\n        self.assertEqual(partition(1), 1)\n        self.assertEqual(partition(2), 1)\n        self.assertEqual(partition(3), 2)\n        self.assertEqual(partition(4), 6)\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 86,
      "score": 2.98055726717331,
      "candidate": "import unittest\nfrom collections import Counter\n\ndef partition(n):\n    return sum(map(lambda x: (n + 1) // x, range(1, n + 1)))\n\n\ndef ways(n, m):\n    return partition(n) // partition(m)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_ways(self):\n        self.assertEqual(ways(4, 3), 1)\n        self.assertEqual(ways(4, 4), 2)\n        self.assertEqual(ways(4, 5), 6)\n        self.assertEqual(ways(4, 6), 24)\n        self.assertEqual(ways(4, 7), 120)\n        self.assertEqual(ways(4, 8), 720)\n        self.assertEqual(ways(4, 9), 4320)\n        self.assertEqual(ways(4, 10), 40320)\n        self.assertEqual(ways(4, 11), 40320)\n        self.assertEqual(ways(4, 12), 40320)\n        self.assertEqual(ways(4, 13), 40320)\n        self.assertEqual(ways(4, 14), 40320)\n        self.assertEqual(ways(4, 15), 40320)\n        self.assertEqual(ways(4, 16), 40320)\n        self.assertEqual(ways(4, 17), 40320)\n        self.assertEqual(ways(4, 18), 40320)\n        self.assertEqual(ways(4, 19), 40320)\n        self.assertEqual(ways(4, 20), 40320)\n        self.assertEqual(ways(4, 21), 40320)\n        self.assertEqual(ways(4, 22), 40320)\n        self.assertEqual(ways(4, 23), 40320)\n        self.assertEqual(ways(4, 24), 40320)\n        self.assertEqual(ways(4, 25), 40320)\n        self.assertEqual(ways(4, 26), 40320)\n        self.assertEqual(ways(4, 27), 40320)\n        self.assertEqual("
    },
    {
      "rank": 87,
      "score": 2.968774963755175,
      "candidate": "# Definition for a Bell number.\nclass BellNumber:\n    def __init__(self, n):\n        self.n = n\n\n    def get_bell_numbers(self):\n        # initialize the array\n        self.bell_numbers = [1] * self.n\n        self.bell_numbers[0] = 1\n\n        # for i in range(2, self.n + 1):\n        #     for j in range(0, i):\n        #         self.bell_numbers[i] += self.bell_numbers[j] * self.bell_numbers[i - j - 1]\n        #         self.bell_numbers[i] %= 1000000\n        #         self.bell_numbers[i] += self.bell_numbers[j] * self.bell_numbers[i - j - 1]\n        #         self.bell_numbers[i] %= 1000000\n\n        # for i in range(self.n + 1):\n        #     self.bell_numbers[i] += self.bell_numbers[i - 1] * self.bell_numbers[i - 1]\n        #     self.bell_numbers[i] %= 1000000\n\n        # for i in range(2, self.n + 1):\n        #     self.bell_numbers[i] += self.bell_numbers[i - 1] * self.bell_numbers[i - 1]\n        #     self.bell_numbers[i] %= 1000000\n\n        return self.bell_numbers\n\n\n# Your BellNumber object will be instantiated and called as such:\n# obj = BellNumber(n)\n# param_1 = obj.get_bell_numbers()\n\nclass Solution:\n    # @param {integer} n\n    # @return {integer}\n    def get_num_ways(self, n):\n        self.n = n\n        self.bell_numbers = [1] * self.n\n        self.bell_numbers[0] = 1\n\n        for i in range(2, self.n + 1):\n            for j in range(0, i):\n                self.bell_numbers[i] += self"
    },
    {
      "rank": 88,
      "score": 2.9390403988686353,
      "candidate": "# https://www.hackerrank.com/challenges/sudoku-solver/problem\n\ndef partition(n):\n    # n is the number of rows\n    # rows are the rows of the sudoku board\n    # cols are the columns of the sudoku board\n    # sudoku is the set of numbers\n    # return the number of ways to partition\n    # the sudoku board\n    # input: n, rows, cols, sudoku\n    # output: the number of ways to partition\n    # each row is a sudoku board\n    # each column is a sudoku board\n    # each cell is a sudoku number\n    # each sudoku number is in the range [1, n]\n    # each sudoku number is unique\n    # each sudoku number can appear in one row, one column, or one square\n\n    # each row is a sudoku board\n    # each column is a sudoku board\n    # each square is a sudoku board\n    # each sudoku number is in the range [1, n]\n    # each sudoku number is unique\n    # each sudoku number can appear in one row, one column, or one square\n\n    # each row is a sudoku board\n    # each column is a sudoku board\n    # each square is a sudoku board\n    # each sudoku number is in the range [1, n]\n    # each sudoku number is unique\n    # each sudoku number can appear in one row, one column, or one square\n\n    # each row is a sudoku board\n    # each column is a sudoku board\n    # each square is a sudoku board\n    # each sudoku number is in the range [1, n]\n    # each sudoku number is unique\n    # each sudoku number can appear in one row, one column, or one square\n\n    # each row is a sudoku board\n    # each column is a sudoku board\n    # each square is a sudoku board\n    # each sudoku number is in the range [1, n]\n    # each sudoku number is unique\n    # each sudoku number can appear in"
    },
    {
      "rank": 89,
      "score": 2.9366614739887105,
      "candidate": "from collections import Counter\nimport math\n\n\ndef partition(N, n):\n    return math.factorial(N) / math.factorial(n)\n\n\ndef ways(N, n):\n    return sum(partition(N, n) for i in range(2, n + 1))\n\n\ndef main():\n    N = int(input())\n    n = int(input())\n    print(ways(N, n))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 90,
      "score": 2.8756275318408573,
      "candidate": "# @include\ndef num_ways(n):\n    if n < 3:\n        return 1\n    return sum(num_ways(n - 2) for _ in range(3, n + 1))\n# @exclude\n\n\ndef main():\n    assert num_ways(3) == 1\n    assert num_ways(4) == 6\n    assert num_ways(5) == 25\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 91,
      "score": 2.8742529665360306,
      "candidate": "import collections\n\n\ndef ways(n):\n    \"\"\"\n    :param n: integer\n    :return: number of ways to partition a set of bell numbers\n    \"\"\"\n    return sum(collections.Counter(map(int, str(n))).values())\n\nif __name__ == \"__main__\":\n    assert ways(1) == 1\n    assert ways(2) == 2\n    assert ways(3) == 3\n    assert ways(4) == 6\n    assert ways(5) == 10\n    assert ways(6) == 15\n    assert ways(7) == 21\n    assert ways(8) == 28\n    assert ways(9) == 36\n    assert ways(10) == 45\n    assert ways(11) == 55\n    assert ways(12) == 70\n    assert ways(13) == 86\n    assert ways(14) == 102\n    assert ways(15) == 126\n    assert ways(16) == 153\n    assert ways(17) == 186\n    assert ways(18) == 216\n    assert ways(19) == 286\n    assert ways(20) == 362\n    assert ways(21) == 456\n    assert ways(22) == 576\n    assert ways(23) == 696\n    assert ways(24) == 828\n    assert ways(25) == 972\n    assert ways(26) == 1112\n    assert ways(27) == 1260\n    assert ways(28) == 1424\n    assert ways(29) == 1596\n    assert ways(30) == 1764\n    assert ways(31) == 1919\n    assert ways(32) == 2188\n    assert ways(33) == 2472\n    assert ways(34) == 2760\n    assert ways(35) == 3048\n    assert ways(36) == 3336\n    assert ways(37) == 3520\n    assert ways(38) == 3712\n    assert ways(39) == 3904\n    assert ways(40) == 4096"
    },
    {
      "rank": 92,
      "score": 2.8481823671049376,
      "candidate": "# Definition for a bell number.\n# class BellNumber(object):\n#     def __init__(self, n):\n#         \"\"\"\n#         :type n: int\n#         \"\"\"\n#         self.n = n\n#         self.bells = [0]*(n+1)\n#         self.bells[0] = 1\n#         self.bells[1] = 1\n#         for i in range(2, n+1):\n#             self.bells[i] = (self.bells[i-1] + self.bells[i-2]) % (i)\n#     def __str__(self):\n#         return \"{}\".format(self.bells)\n\n\nclass Solution(object):\n    def __init__(self):\n        self.count = 0\n\n    def countWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        self.count += 1\n        return self.countWays(n-1) + self.countWays(n-2)\n\n\nif __name__ == \"__main__\":\n    n = [1,2,3,4,5,6]\n    s = Solution()\n    print s.countWays(n)"
    },
    {
      "rank": 93,
      "score": 2.8258176662566163,
      "candidate": "class Solution(object):\n    def numWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        result = 0\n        for i in xrange(2, n):\n            if n % i == 0:\n                result += self.numWays(n // i)\n        return result\n\n\nif __name__ == '__main__':\n    assert Solution().numWays(3) == 6\n    assert Solution().numWays(4) == 16\n    assert Solution().numWays(5) == 25\n    assert Solution().numWays(10) == 23\n    assert Solution().numWays(100) == 3980\n\n    assert Solution().numWays(1) == 1"
    },
    {
      "rank": 94,
      "score": 2.817231059917391,
      "candidate": "from __future__ import annotations\n\nimport collections\nfrom typing import Optional\n\nimport pytest\n\n\n@pytest.mark.parametrize(\n    (\"n\", \"expected\"),\n    [\n        (1, 1),\n        (2, 2),\n        (3, 5),\n        (4, 12),\n        (5, 25),\n        (6, 50),\n        (7, 126),\n        (8, 250),\n        (9, 625),\n        (10, 1250),\n        (11, 2500),\n        (12, 6250),\n    ],\n)\ndef test_partition(n: int, expected: int) -> None:\n    assert partition(n) == expected\n\n\ndef partition(n: int) -> int:\n    \"\"\"\n    Returns the number of ways to partition a set of numbers.\n\n    :param n: The set of numbers to partition.\n    :return: The number of ways to partition the set.\n    \"\"\"\n    # Partition into a list of lists.\n    result: collections.Counter[int] = collections.Counter()\n    for i in range(1, n + 1):\n        result[i] += 1\n        for j in range(1, i + 1):\n            result[i] -= result[i - j]\n\n    return result.most_common()[0][1]"
    },
    {
      "rank": 95,
      "score": 2.8056420637334285,
      "candidate": "# https://www.hackerrank.com/challenges/partition-numbers/problem\n\n# Iterative solution\ndef partition(n):\n    ways = 0\n    for i in range(1, n+1):\n        if i == 1:\n            ways += 1\n        else:\n            for j in range(i):\n                ways += partition(i-j-1)\n    return ways\n\n# Recursive solution\ndef partition(n):\n    ways = 0\n    if n <= 1:\n        ways = 1\n    else:\n        for i in range(1, n+1):\n            ways += partition(i)\n    return ways\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative solution\ndef partition(n):\n    ways = 0\n    for i in range(1, n+1):\n        if i == 1:\n            ways += 1\n        else:\n            for j in range(i):\n                ways += partition(i-j-1)\n    return ways\n\n# Recursive solution\ndef partition(n):\n    ways = 0\n    if n <= 1:\n        ways = 1\n    else:\n        for i in range(1, n+1):\n            ways += partition(i)\n    return ways\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative solution\ndef partition(n):\n    ways = 0\n    for i in range(1, n+1):\n        if i == 1:\n            ways += 1\n        else:\n            for j in range(i):\n                ways += partition(i-j-1)\n    return ways\n\n# Recursive solution\ndef partition(n):\n    ways = 0\n    if n <= 1:\n        ways = 1\n    else:\n        for i in range(1, n+1):\n            ways += partition(i)\n    return ways\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\n# Iterative solution\ndef partition(n):\n    ways = 0\n    for i in range(1, n+1):\n        if i == 1:\n            ways += 1\n        else:"
    },
    {
      "rank": 96,
      "score": 2.7734112687298875,
      "candidate": "class Solution(object):\n    def ways(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 1:\n            return 1\n        return (self.ways(n - 1) + self.ways(n - 2) + self.ways(n - 3)) % 1000000007\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.ways(10))"
    },
    {
      "rank": 97,
      "score": 2.754833499609273,
      "candidate": "def ways(n, k):\n    return (k==0) and 1 or (ways(n-1, k-1) + ways(n-1, k))\n\nprint(ways(6, 3))\n\n\"\"\"\nInput: n = 6, k = 3\nOutput: 2\nExplanation:\nThere are two ways to partition the set:\n[2, 1, 1, 1, 1, 2].\n[1, 2, 1, 1, 1, 2].\n[1, 1, 2, 1, 1, 2].\n[1, 1, 1, 2, 1, 2].\n[1, 1, 1, 1, 2, 2].\n[2, 1, 1, 1, 1, 2].\n\"\"\""
    },
    {
      "rank": 98,
      "score": 2.6007990626007946,
      "candidate": "import unittest\n\n\ndef num_ways(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: int\n    \"\"\"\n    def dp(n):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 3\n        if n == 3:\n            return 6\n        return dp(n - 1) + dp(n - 2) + dp(n - 3)\n\n    return dp(len(numbers))\n\n\nclass TestCode(unittest.TestCase):\n    def test_num_ways(self):\n        self.assertEqual(num_ways([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 24)\n        self.assertEqual(num_ways([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), 1)\n        self.assertEqual(num_ways([1]), 1)\n        self.assertEqual(num_ways([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), 1)\n        self.assertEqual(num_ways([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), 1)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 99,
      "score": 2.523979158052062,
      "candidate": "# Definition for a Bell number.\nclass BellNumber:\n    def __init__(self, n):\n        self.n = n\n        self.bells = []\n\n    def add(self, b):\n        self.bells.append(b)\n\n    def __str__(self):\n        return str(self.bells)\n\n    def __repr__(self):\n        return self.bells\n\n    def __eq__(self, other):\n        if type(other) is type(self):\n            return self.bells == other.bells\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = 0\n\n    def partition(self, n):\n        self.ans += self.partition_rec(n, [])\n\n    def partition_rec(self, n, prev):\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return prev[0] + prev[1]\n        return prev[0] + self.partition_rec(n - 2, prev)\n\nif __name__ == \"__main__\":\n    n = 4\n    partition = Solution()\n    partition.partition(n)\n    print partition.ans"
    },
    {
      "rank": 100,
      "score": 2.292668821895769,
      "candidate": "from functools import reduce\n\n\ndef num_ways(n):\n    return reduce(lambda x, y: x + y, [int(n / i) for i in range(1, n + 1)])\n\n\ndef main():\n    print(num_ways(1))\n    print(num_ways(2))\n    print(num_ways(3))\n    print(num_ways(4))\n    print(num_ways(5))\n    print(num_ways(6))\n    print(num_ways(7))\n    print(num_ways(8))\n    print(num_ways(9))\n    print(num_ways(10))\n\n\nif __name__ == '__main__':\n    main()"
    }
  ]
}