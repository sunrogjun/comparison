{
  "timestamp": "2025-09-14T17:30:46.647931",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 20,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def top_k(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    heap = []\n    for i in range(len(arr)):\n        heap.append(arr[i])\n        while len(heap) > 1 and heap[0] < heap[1]:\n            temp = heap[0]\n            heap[0] = heap[1]\n            heap[1] = temp\n            heapq.heappop(heap)\n    return heapq.heappop(heap)\n\n# Your TopK solution here.\n# def top_k(arr, k):\n#     heap = []\n#     for i in range(len(arr)):\n#         heap.append(arr[i])\n#         while len(heap) > 1 and heap[0] < heap[1]:\n#             temp = heap[0]\n#             heap[0] = heap[1]\n#             heap[1] = temp\n#             heapq.heappop(heap)\n#     return heapq.heappop(heap)"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums1 or not nums2 or k < 1:\n            return []\n        heap = []\n        for i in range(len(nums1)):\n            heapq.heappush(heap, (nums1[i], nums2[i], i))\n        res = []\n        while k > 0:\n            # get top k elements\n            while len(heap) >= k and heap[0][0] < 0:\n                heapq.heappop(heap)\n            if len(heap) == 0:\n                break\n            res.append(heap[0][2])\n            heapq.heappop(heap)\n            k -= 1\n        return res"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "import heapq\n\n\ndef top_k(l, k):\n    heapq.heapify(l)\n    count = 0\n    result = []\n    while len(l) > 0 and count < k:\n        result.append(l.pop())\n        count += 1\n    return result\n\n\ndef main():\n    print(top_k([1, 1, 1, 1, 1, 2, 2, 3, 3, 4, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        # use heap queue to do the job\n        # heapq.heapify(nums2)\n        # result = []\n        # for i in range(k):\n        #     if nums2:\n        #         result.append(heapq.heappop(nums2))\n        # return result\n        # heapq.heapify(nums1)\n        # return heapq.nlargest(k, nums1)\n        # return sorted(nums1, reverse=True)[:k]\n        return sorted(nums1, reverse=True)[:k]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.topKFrequent([1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in range(len(nums1)):\n            heap.append((heapq.heappush(heap, (nums1[i], i)), i))\n        heapq.heapify(heap)\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1])\n        return result"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\ndef most_frequent_heap(k, nums, nums2):\n    '''\n    :type k: int\n    :type nums: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    '''\n    # build a dict of frequency\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # build a dict of nums2\n    freq2 = defaultdict(int)\n    for num in nums2:\n        freq2[num] += 1\n\n    # build a heap\n    heap = []\n    for i in range(len(nums)):\n        heap.append((freq[nums[i]], nums[i]))\n    heapq.heapify(heap)\n\n    # sort the list of elements\n    sorted_list = []\n    while len(heap) > 0:\n        sorted_list.append(heapq.heappop(heap))\n    sorted_list = sorted(sorted_list, reverse=True)\n\n    # find the top k elements\n    top_k = []\n    for i in range(len(sorted_list)):\n        top_k.append(sorted_list[i])\n        if len(top_k) == k:\n            break\n    return top_k\n\n# test cases\nk = 5\nnums = [1,2,3,4,5,6,7,8,9,10]\nnums2 = [1,2,3,4,5,6,7,8,9,10]\n\n# print most_frequent_heap(k, nums, nums2)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import collections\n\ndef find_topk(sorted_input, distinct_input, k):\n    \"\"\"\n    :type sorted_input: List[int]\n    :type distinct_input: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # create a dict to store frequency of each integer\n    freq = collections.defaultdict(int)\n    # create a dict to store the heap queue\n    heapq = collections.defaultdict(int)\n    # add all integers to the heap queue\n    for x in sorted_input:\n        heapq[x] = x\n    # iterate through the distinct integers\n    for x in distinct_input:\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency of x is greater than the max frequency, update the frequency\n        if freq[x] < k:\n            freq[x] = 1\n        # if the frequency"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[Interval]\n        \"\"\"\n        # Get the number of elements in nums1.\n        n1 = len(nums1)\n\n        # Get the number of elements in nums2.\n        n2 = len(nums2)\n\n        # Initialize the heap.\n        heap = []\n\n        # Set the size of heap to the number of elements in nums1.\n        for i in range(n1):\n            heap.append(Interval(nums1[i], nums1[i]))\n\n        # Keep track of the maximum number of elements in heap.\n        max_heap = 0\n\n        # Keep track of the number of elements in heap.\n        heap_size = 0\n\n        # Keep track of the number of elements in nums2 that occur more than k times.\n        occur_count = 0\n\n        # Keep track of the elements that occur most frequently.\n        heap_max = 0\n\n        # Keep track of the maximum number of elements in heap.\n        max_heap = 0\n\n        # Keep track of the number of elements in nums2 that occur more than k times.\n        occur_count = 0\n\n        # Keep track of the elements that occur most frequently.\n        heap_max = 0\n\n        # Keep track of the maximum number of elements in heap.\n        max_heap = 0\n\n        # Keep track of the number of elements in nums2 that occur more than k times.\n        occur_count = 0\n\n        # Keep track of the elements that occur most frequently.\n        heap_max = 0\n\n        # Keep track of the maximum number of elements in heap.\n        max_heap = 0\n\n        # Keep track of the number of elements in nums2 that occur more than k times.\n        occ"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/top-k-frequent-elements/problem\n\nimport heapq\n\n\ndef top_k_frequent(data, k):\n    # initialize a heap with the top k\n    heap = []\n    for num in data:\n        heap.append((num, 1))\n\n    # iterate over the input list and add the elements to the heap\n    # until the heap is full or the number of elements is less than k\n    for i in range(len(data)):\n        if len(heap) < k:\n            heapq.heappush(heap, (data[i], 1))\n        else:\n            # if the current element is already in the heap, then increment the count\n            if heap[0][0] == data[i]:\n                heapq.heappush(heap, (data[i], heap[0][1] + 1))\n            # otherwise, the current element is not in the heap and therefore should be inserted\n            else:\n                heapq.heappush(heap, (data[i], 1))\n\n    # return the top k\n    return heap[0:k]\n\n\nif __name__ == \"__main__\":\n    data = [3, 1, 2, 1, 1, 2, 3, 5, 1]\n    k = 2\n    print(top_k_frequent(data, k))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Heap Queue\n# https://www.geeksforgeeks.org/heap-queue-algorithm/\n#\n# Heap Queue is a binary tree which is used for storing the top k elements of a sorted and distinct list.\n#\n# The algorithm first constructs a Heap Queue using the array of distinct integers.\n# Then it populates the top k elements of the queue and returns the top k elements of the queue.\n#\n# The algorithm is implemented using a heap queue.\n#\n# Time Complexity: O(k log n)\n# Space Complexity: O(k)\n#\n#\n# Input:\n#   n = 4\n#   k = 2\n#   A = [1, 2, 3, 4]\n#   B = [3, 4, 5, 6]\n#   C = [1, 2, 3, 4]\n#\n# Output:\n#   [3, 4]\n#\n# Explanation:\n#\n# The input lists are sorted and distinct.\n# The heap queue is constructed using the input lists.\n# The top k elements of the queue is populated using the heap queue.\n# The top k elements of the queue is returned.\n#\n#\n#\n# Example 1:\n#\n# Input:\n#   n = 4\n#   k = 2\n#   A = [1, 2, 3, 4]\n#   B = [3, 4, 5, 6]\n#   C = [1, 2, 3, 4]\n#\n# Output:\n#   [3, 4]\n#\n#\n#\n#\n# Note:\n#   1 <= n <= 30\n#   1 <= k <= 30\n#   1 <= A.length <= 30\n#   1 <= B.length <= 30\n#   1 <= C.length <= 30\n#   A, B, C are sorted and distinct.\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from collections import Counter\nimport heapq\n\n# Your Solution here\n\ndef top_k_frequent(k, nums):\n    \"\"\"\n    :type k: int\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    c = Counter(nums)\n    max_key = max(c, key=c.get)\n    return sorted(c[max_key] for c in Counter(nums).values())[:k]\n\n# Time:  O(nlogk)\n# Space: O(k)\nclass Solution(object):\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # https://leetcode.com/discuss/41008/java-solution-using-heap-queue-with-dynamic-memory-usage\n        if k == 0:\n            return []\n        if len(nums) <= k:\n            return nums\n        heap = [(v, i) for i, v in enumerate(nums)]\n        heapq.heapify(heap)\n        while k > 0:\n            max_key, max_index = heapq.heappop(heap)\n            k -= 1\n            if max_index == len(nums) - 1:\n                return nums[:k]\n            heapq.heappush(heap, (nums[max_index + 1], max_index + 1))\n        return nums[:k]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a list node\n\t# @param k, an integer\n\t# @return a list node\n\tdef topKFrequent(self, head, k):\n\t\t# write your code here\n\t\theap = []\n\t\theapq.heapify(heap)\n\t\tres = []\n\t\twhile head:\n\t\t\theapq.heappop(heap)\n\t\t\theapq.heappush(heap, head)\n\t\t\thead = head.next\n\t\theapq.heapify(heap)\n\t\tfor i in range(len(heap)):\n\t\t\tif i < k:\n\t\t\t\tres.append(heap[i].val)\n\t\treturn res\n\n\na = ListNode(1)\na.next = ListNode(2)\na.next.next = ListNode(3)\na.next.next.next = ListNode(4)\na.next.next.next.next = ListNode(5)\na.next.next.next.next.next = ListNode(6)\na.next.next.next.next.next.next = ListNode(7)\na.next.next.next.next.next.next.next = ListNode(8)\na.next.next.next.next.next.next.next.next = ListNode(9)\na.next.next.next.next.next.next.next.next.next = ListNode(10)\na.next.next.next.next.next.next.next.next.next.next = ListNode(11)\na.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\na.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\na.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\na.next.next.next.next"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def topKFrequent(self, head: ListNode, k: int) -> ListNode:\n        heap = []\n        heapq.heapify(heap)\n\n        curr = head\n        curr_count = 1\n        while curr is not None:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (curr.val, curr_count))\n            curr_count += 1\n            curr = curr.next\n\n        # for i in range(k):\n        #     print(heapq.heappop(heap))\n\n        res = ListNode(-1)\n        curr = head\n        curr_count = 0\n        while curr is not None and curr_count < k:\n            heapq.heappop(heap)\n            curr_count += 1\n            res.next = curr\n            res = res.next\n            curr = curr.next\n\n        return res"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import heapq\nimport itertools\n\ndef top_k_frequent_numbers(k, lst1, lst2):\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, (lst1[0] + lst2[0], i))\n    res = []\n    while heap:\n        heapq.heappop(heap)\n        res.append(heap[0][1])\n    return res\n\ndef top_k_frequent_numbers_recur(k, lst1, lst2):\n    res = []\n    for i in range(k):\n        res.append(max(lst1[0] + lst2[0], lst1[0] + lst2[0]))\n    return res\n\ndef top_k_frequent_numbers_recur2(k, lst1, lst2):\n    res = []\n    for i in range(k):\n        res.append(max(lst1[0] + lst2[0], lst1[0] + lst2[0]))\n    return res\n\ndef top_k_frequent_numbers_recur3(k, lst1, lst2):\n    res = []\n    for i in range(k):\n        res.append(max(lst1[0] + lst2[0], lst1[0] + lst2[0]))\n    return res\n\nif __name__ == '__main__':\n    lst1 = [1, 3, 5, 7, 8]\n    lst2 = [9, 11, 12, 13, 15]\n    print top_k_frequent_numbers(3, lst1, lst2)\n    print top_k_frequent_numbers_recur(3, lst1, lst2)\n    print top_k_frequent_numbers_recur2(3, lst1, lst2)\n    print top_k_frequent_numbers_recur3(3, lst1, lst2)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Heap Queue\n# The basic idea is to use a heap queue to keep track of the frequency of each number.\n# Heap queue is a queue with two operations: push and pop.\n# push(x): insert x into the queue and increase the count of x by 1.\n# pop(): remove the maximum element from the queue.\n# The complexity of the algorithm is O(n).\n# The worst case runtime is O(n).\n# The best case runtime is O(log n).\n# Here are some examples.\n\n# Input:\n# [[1,2,3,4], [2,3,4,5], [3,4,5,6]]\n# k = 3\n# Output:\n# [2, 3, 4]\n# [3, 4, 5]\n# [3, 4, 6]\n# [4, 5, 6]\n\n# Input:\n# [[1,2,3,4], [2,3,4,5], [3,4,5,6], [1,2,3,4]]\n# k = 2\n# Output:\n# [2, 3]\n# [3, 4]\n# [3, 4]\n# [4, 5]\n# [4, 5]\n\n# Input:\n# [[1,2,3,4], [2,3,4,5], [3,4,5,6]]\n# k = 4\n# Output:\n# [1, 2, 3, 4]\n# [2, 3, 4, 5]\n# [3, 4, 5, 6]\n# [1, 2, 3, 4]\n\n# Input:\n# [[1,2,3,4], [2,3,4,5], [3,4,5,6], [1,2,3,4]]\n# k = 5\n# Output:\n# [1, 2, 3, 4]\n# [2, 3, 4, 5]\n# [3, 4, 5, 6]\n# [1, 2, 3, 4]\n\n# Input:\n# [[1,2,3,4], [2,3,4,5], [3,4,5,6], [1,2,3,4]]\n# k"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass Solution:\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i, val in enumerate(nums):\n            heapq.heappush(heap, (val, i))\n        heap = heap[:k]\n        ret = []\n        while heap:\n            ret.append(heapq.heappop(heap)[1])\n        return ret\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1, 1, 1, 2, 2, 3, 3, 4, 5]\n    print(sol.topKFrequent(2, nums))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        heap = []\n        for i, n in enumerate(nums):\n            heapq.heappush(heap, (n, i))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        for n, i in heap:\n            res.append(n)\n        return res"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# Heap queue implementation\n# O(n log n)\n# Time: O(n log n)\n# Space: O(n)\n\nclass Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Heap implementation\n        # O(n log n)\n        # Time: O(n log n)\n        # Space: O(n)\n        heap = []\n        for i in range(len(nums1)):\n            heapq.heappush(heap, (nums1[i], nums2[i]))\n        res = []\n        k = min(k, len(nums1))\n        for i in range(k):\n            res.append(heapq.heappop(heap)[1])\n        return res\n\n\n# Binary search solution\n# O(n log n)\n# Time: O(n log n)\n# Space: O(n)\n\nclass Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Binary search implementation\n        # O(n log n)\n        # Time: O(n log n)\n        # Space: O(n)\n        res = []\n        if not nums1 or not nums2:\n            return res\n        heap = []\n        for i in range(len(nums1)):\n            if nums1[i] in nums2:\n                heapq.heappush(heap, (nums1[i], nums2[i]))\n        k = min(k, len(nums1))\n        for i in range(k):\n            res.append(heapq.heappop(heap)[1])\n        return res"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "import heapq\n\ndef top_k_frequent(k, num_list, num_distinct_list):\n    \"\"\"\n    :type k: int\n    :type num_list: List[int]\n    :type num_distinct_list: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    queue = []\n    top_list = []\n    for i in range(k):\n        top_list.append(0)\n\n    for i in range(len(num_list)):\n        # print(num_list[i], num_distinct_list[i])\n        heapq.heappush(queue, (num_list[i], num_distinct_list[i]))\n\n        while len(queue) > 0:\n            heapq.heappop(queue)\n            top_list[0] = heapq.heappop(queue)[1]\n            top_list[1] += 1\n\n        for i in range(k):\n            if top_list[i] > top_list[0]:\n                top_list[0] = top_list[i]\n                top_list[1] = 1\n\n        heapq.heappush(queue, (num_list[i], num_distinct_list[i]))\n\n    return top_list\n\n\nif __name__ == '__main__':\n    print(top_k_frequent(2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(top_k_frequent(1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(top_k_frequent(2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(top_k_frequent(3, [1, 2"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "import time\nfrom collections import Counter\nfrom heapq import heappush, heappop, heapify\n\ndef find_top_k_from_sorted_and_distinct(input_list, k):\n    \"\"\"\n    :type input_list: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    count_list = Counter(input_list)\n    heap = []\n    for key in count_list.keys():\n        heappush(heap, (key, count_list[key], key))\n    heapify(heap)\n    k_top = []\n    while len(heap) > k:\n        top_key, top_count, top_index = heappop(heap)\n        k_top.append(top_index)\n        if top_index == len(input_list) - 1:\n            break\n    return k_top\n\nstart_time = time.time()\nprint(find_top_k_from_sorted_and_distinct([1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def find_top_k(array, k, topk_array):\n    \"\"\"\n    :type array: List[int]\n    :type k: int\n    :type topk_array: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    topk_array.append(array[0])\n    for i in range(1, len(array)):\n        heapq.heappush(heap, (array[i], i))\n        if len(heap) > k:\n            heapq.heappop(heap)\n            topk_array[len(topk_array) - 1] = array[heap[0][1]]\n    return topk_array\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        topk_array = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i], i))\n            if len(heap) > k:\n                heapq.heappop(heap)\n            topk_array.append(nums[heap[0][1]])\n        return topk_array\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4]\n    k = 3\n    topk_array = Solution().topKFrequent(nums, k)\n    print topk_array"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "# https://www.codewars.com/kata/516d8a9e6e6b0f7a0d8e8d/train/python\n\nimport heapq\n\ndef top_k_numbers(numbers, k):\n    heap = []\n    for i in range(0, k):\n        heapq.heappush(heap, numbers[i])\n    \n    while k > 0:\n        # pop the top element\n        top_element = heapq.heappop(heap)\n        k -= 1\n        # print top_element\n        # print heap\n        # print '---'\n        \n        # put the element back in the heap\n        heapq.heappush(heap, top_element)\n    return heap\n\n# Your code here!\nnumbers = [1,3,2,2,2,3,1,1,1,1,2,3,2,2,2,1]\nk = 5\n\n# print top_k_numbers(numbers, k)"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "def find_top_k_unique_elements(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for i in range(len(arr)):\n        heap.append((arr[i], i))\n    heapq.heapify(heap)\n    \n    output = []\n    for i in range(k):\n        output.append(heap[0][1])\n        heapq.heappop(heap)\n    \n    return output\n\ndef find_top_k_unique_elements_recursion(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    output = []\n    max_heap = []\n    for i in range(len(arr)):\n        if i < k:\n            heapq.heappush(max_heap, (arr[i], i))\n        else:\n            heapq.heappush(max_heap, (arr[i], i))\n            while len(max_heap) > 0 and arr[max_heap[0][1]] == arr[i]:\n                heapq.heappop(max_heap)\n            heapq.heappush(max_heap, (arr[i], i))\n        \n        if len(max_heap) > k:\n            heapq.heappop(max_heap)\n            output.append(arr[max_heap[0][1]])\n    \n    return output\n\nif __name__ == \"__main__\":\n    arr = [1,2,3,1,2,3,4,5,6,7,8,9]\n    k = 3\n    print(find_top_k_unique_elements(arr, k))\n    k = 4\n    print(find_top_k_unique_elements(arr, k))\n    k = 5\n    print(find_top_k_unique_elements(arr, k))\n    k"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# Heap Queue\n\nclass Solution:\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        freq = collections.Counter(nums1)\n        freq.update(nums2)\n        heap = collections.deque()\n        for i in range(k):\n            heapq.heappush(heap, -freq[nums1[i]])\n        res = []\n        while k > 0:\n            res.append(heapq.heappop(heap))\n            k -= 1\n        return res"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        heap = []\n        for i in range(len(nums1)):\n            heap.append(TreeNode(nums1[i], None, None))\n        for i in range(len(nums2)):\n            heap[i].val += nums2[i]\n        heapq.heapify(heap)\n        res = []\n        for i in range(k):\n            res.append(heap[0].val)\n            heap[0] = heap[0].left\n        res.sort()\n        return res"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        freq_dict = defaultdict(int)\n        for num in nums1:\n            freq_dict[num] += 1\n        for num in nums2:\n            freq_dict[num] += 1\n        top = [(freq_dict[num], num) for num in freq_dict.keys()]\n        top.sort()\n        top = top[:k]\n        ret = [x[1] for x in top]\n        return ret"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.left = None\n\t\tself.right = None\n\nclass Solution:\n\t# @param {integer[]} nums1\n\t# @param {integer[]} nums2\n\t# @param {integer} k\n\t# @return {integer[]}\n\tdef topKFrequent(self, nums1, nums2, k):\n\t\tif k == 0:\n\t\t\treturn []\n\n\t\tqueue = []\n\t\tfor i in range(len(nums1)):\n\t\t\tnode = TreeNode(nums1[i])\n\t\t\tnode.left = self.createQueue(queue, nums1, i, 0, len(nums1)-1)\n\t\t\tnode.right = self.createQueue(queue, nums2, i, 0, len(nums2)-1)\n\t\t\tqueue.append(node)\n\n\t\t# print(queue)\n\t\t# print(len(queue))\n\t\t# print(queue[0])\n\t\treturn heapq.nsmallest(k, queue)\n\n\tdef createQueue(self, queue, nums, idx, start, end):\n\t\tif start == end:\n\t\t\tnode = TreeNode(nums[idx])\n\t\t\tqueue.append(node)\n\t\t\treturn node\n\n\t\tmid = (start + end) // 2\n\t\tnode1 = TreeNode(nums[idx])\n\t\tnode1.left = self.createQueue(queue, nums, idx, start, mid)\n\t\tnode2 = TreeNode(nums[idx])\n\t\tnode2.right = self.createQueue(queue, nums, idx, mid+1, end)\n\t\treturn node1\n\n\nif __name__ == \"__main__\":\n\ts = Solution()\n\tnums1 = [1,2,1,3,2]\n\tnums2 = [1,2,3,1,2]\n\tk = 2\n\tprint(s.topKFrequent(nums1, nums2, k))\n\tprint(s.topKFrequent(nums2, nums1, k))"
    },
    {
      "rank": 28,
      "score": 9.0,
      "candidate": "# write your code here\n\ndef heap_sort(arr, k):\n    heap = []\n    for i in arr:\n        heap.append(i)\n        heapq.heappush(heap, i)\n        if len(heap) == k:\n            heapq.heappop(heap)\n    return heap\n\ndef top_k_int(arr, k):\n    heap = heap_sort(arr, k)\n    return [heap[i] for i in range(k)]\n\nif __name__ == \"__main__\":\n    arr = [1,1,2,2,2,3,3,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6"
    },
    {
      "rank": 29,
      "score": 9.0,
      "candidate": "def top_k_frequent_numbers(numbers, k):\n    \"\"\"\n    :type numbers: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    max_heap = []\n    for number in numbers:\n        heapq.heappush(max_heap, (-number, 1))\n    for number in numbers:\n        heapq.heappop(max_heap)\n        heapq.heappush(max_heap, (-number, 1))\n    return [x[0] for x in max_heap][:k]\n\n# Time:  O(nk)\n# Space: O(n)\n# Dynamic Programming\n# Using max heap\n# https://discuss.leetcode.com/topic/81244/java-solution-using-max-heap-with-dynamic-programming\ndef top_k_frequent_numbers_dp(numbers, k):\n    \"\"\"\n    :type numbers: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    max_heap = []\n    for number in numbers:\n        max_heap.append((-number, 1))\n    for number in numbers:\n        heapq.heappop(max_heap)\n        heapq.heappush(max_heap, (-number, 1))\n    return [x[0] for x in max_heap][:k]\n\n# Time:  O(nk)\n# Space: O(k)\n# Heap Sort\n# https://discuss.leetcode.com/topic/81244/java-solution-using-heap-sort-with-dynamic-programming\ndef top_k_frequent_numbers_hs(numbers, k):\n    \"\"\"\n    :type numbers: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    max_heap = []\n    for number in numbers:\n        heapq.heappush(max_heap, (-number, 1))\n    for number in numbers:"
    },
    {
      "rank": 30,
      "score": 9.0,
      "candidate": "# Heap Queue\n# First: build a heap from a list of integers\n# Second: use a heap queue to extract the top k elements from the heap\n# Return top k integers with most frequent elements\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def topKFrequent(self, nums, k):\n        heap = []\n        for i in range(len(nums)):\n            heap.append((nums[i], i))\n\n        heapq.heapify(heap)\n        return [heap[:k]]\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8]\n    k = 3\n    print(Solution().topKFrequent(nums, k))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "# Heap is a heap, and heap is a queue. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue, and heap is a heap. Heap is a queue,"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef top_k_int(lst, k):\n    heap = []\n    for v in lst:\n        heap.append((v, v in lst))\n\n    heapq.heapify(heap)\n\n    top_k_ints = []\n    while len(heap) > k:\n        heapq.heappop(heap)\n        top_k_ints.append(heap[0][1])\n\n    return top_k_ints\n\ndef top_k_int_dp(lst, k):\n    # write your code here\n    count = defaultdict(int)\n    for v in lst:\n        count[v] += 1\n    \n    heap = []\n    for v in lst:\n        heap.append((count[v], v in lst))\n        \n    heapq.heapify(heap)\n    \n    top_k_ints = []\n    while len(heap) > k:\n        heapq.heappop(heap)\n        top_k_ints.append(heap[0][1])\n    \n    return top_k_ints\n\nif __name__ == \"__main__\":\n    lst = [2, 4, 1, 3, 5, 7, 1, 1]\n    k = 2\n    print top_k_int(lst, k)\n    print top_k_int_dp(lst, k)"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef top_k_frequent(num_list, k):\n    # write your code here\n    if len(num_list) < k:\n        return 0\n    max_heap = []\n    heapq.heapify(max_heap)\n    for num in num_list:\n        heapq.heappush(max_heap, num)\n        if len(max_heap) > k:\n            heapq.heappop(max_heap)\n    return max_heap[:k]\n\n\nif __name__ == \"__main__\":\n    num_list = [1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]\n    k = 4\n    print top_k_frequent(num_list, k)"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "import heapq\n\n# https://www.geeksforgeeks.org/top-k-frequent-elements-set-2/\ndef top_k_frequent(sorted_nums, distinct_nums):\n    \"\"\"\n    :type sorted_nums: List[int]\n    :type distinct_nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = [(-sorted_nums.count(n), n) for n in distinct_nums]\n    heapq.heapify(heap)\n\n    k = len(sorted_nums)\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n\n    return res\n\n# Note:\n# Heap is a sorted array of pairs (index, value).\n# Heapq is a sorted array of pairs (value, index).\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library.\n# Heapq is a heap of pairs (value, index) from the heapq library"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorted-and-distinct-nums/problem\n\nimport collections\nimport heapq\n\n\ndef top_k(input_list, k):\n    # Create a dictionary that maps a number to its count\n    count_dict = collections.Counter(input_list)\n    # Create a heap from the dictionary\n    heap = heapq.heapdict(count_dict)\n    # Loop over the k numbers in the dictionary\n    for key in count_dict.keys():\n        # Remove the top k numbers\n        for _ in range(k):\n            heapq.heappop(heap)\n        # Add the top k numbers to the heap\n        heapq.heappush(heap, key)\n    # Return the top k numbers\n    return heapq.heappop(heap)\n\n\ndef main():\n    # Get input\n    n, k = map(int, input().strip().split())\n    # Get input\n    input_list = list(map(int, input().strip().split()))\n    # Run\n    print(top_k(input_list, k))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from collections import Counter\nfrom heapq import heappush, heappop\nfrom itertools import groupby\n\ndef topk(k, l):\n\theap = []\n\tfor i in l:\n\t\theappush(heap, (i, i))\n\t\tif len(heap) > k:\n\t\t\theappop(heap)\n\n\theap = sorted(heap, reverse=True)\n\treturn [heappop(heap)[1] for i in range(k)]\n\ndef test():\n\tl = [2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 3, 1, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "import heapq\n\ndef top_k_freq_list(k, lists, dist):\n    heap = []\n    for i in range(len(lists)):\n        heapq.heappush(heap, (dist[i], i))\n    count = 0\n    top_k_list = []\n    while count < k:\n        if len(heap) == 0:\n            break\n        else:\n            count += 1\n        top_k_list.append(heapq.heappop(heap))\n    return top_k_list\n\ndef main():\n    lists = [range(1,10), range(1,10), range(1,10), range(1,10)]\n    dist = [4, 3, 2, 1]\n    print top_k_freq_list(2, lists, dist)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import heapq\n\ndef top_k(input_list, k):\n    \"\"\"\n    :type input_list: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # heapq.heapify(input_list)\n    heapq.heapify(input_list)\n    result = []\n    while len(input_list) > 0 and len(result) < k:\n        heapq.heappop(input_list)\n        result.append(heapq.heappop(input_list))\n    return result\n\nif __name__ == '__main__':\n    print(top_k([2, 1, 3, 3, 2, 2, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # Use heap queue to store the top k elements in nums1.\n        # We only need to keep the heap in sorted order.\n        # Then we can just traverse the heap to get top k elements.\n        # Then we can do a heapify to get the top k elements in the heap.\n        # We can also just use a list to keep track of the top k elements.\n        # We can also use a map to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a dict to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a map to keep track of the top k elements.\n        # We can also use a list to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a dict to keep track of the top k elements.\n        # We can also use a list to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a dict to keep track of the top k elements.\n        # We can also use a list to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a dict to keep track of the top k elements.\n        # We can also use a list to keep track of the top k elements.\n        # We can also use a set to keep track of the top k elements.\n        # We can also use a dict to keep track of the top k elements"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer} k\n    # @return {integer[]}\n    def topKFrequent(self, nums1, nums2, k):\n        heap = []\n        for num in nums2:\n            heapq.heappush(heap, (nums1.count(num), num))\n        heapq.heappop(heap)\n        return heap[:k]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.topKFrequent([1, 1, 1, 2, 3, 4, 1, 1, 2, 2, 2, 3, 4], [1, 1, 2, 3, 4, 5, 6], 2)"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\ndef most_frequent_numbers(numbers, k):\n    \"\"\"\n    :type numbers: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    \n    counts = collections.Counter(numbers)\n    heap = [(-counts[num], num) for num in numbers]\n    heapq.heapify(heap)\n    \n    result = []\n    while len(heap) > k:\n        heappop(heap)\n        result.append(heappop(heap)[1])\n    \n    result.sort()\n    return result"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def top_k(n, k, arr):\n    heap = [0] * k\n    heapq.heapify(heap)\n    for i in range(n):\n        heapq.heappush(heap, arr[i])\n    count = 0\n    while len(heap) > k:\n        heapq.heappop(heap)\n        count += 1\n    return count\n\n#print top_k(n, k, arr)"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "# Heap Queue\nclass Heap(object):\n    def __init__(self, k):\n        self.k = k\n        self.heap = [0] * self.k\n\n    def insert(self, x):\n        self.heap[0] = x\n        self.heap[1] = -1\n        self.heap[2] = -1\n        for i in range(3, self.k):\n            if self.heap[i] < self.heap[i//2]:\n                tmp = self.heap[i]\n                self.heap[i] = self.heap[i//2]\n                self.heap[i//2] = tmp\n\n# Heap Queue\nclass Heap(object):\n    def __init__(self, k):\n        self.k = k\n        self.heap = [0] * self.k\n\n    def insert(self, x):\n        self.heap[0] = x\n        self.heap[1] = -1\n        self.heap[2] = -1\n        for i in range(3, self.k):\n            if self.heap[i] < self.heap[i//2]:\n                tmp = self.heap[i]\n                self.heap[i] = self.heap[i//2]\n                self.heap[i//2] = tmp\n\n    def min(self):\n        return self.heap[1]\n\n    def max(self):\n        return self.heap[0]\n\n\n# Heap Queue\nclass Heap(object):\n    def __init__(self, k):\n        self.k = k\n        self.heap = [0] * self.k\n\n    def insert(self, x):\n        self.heap[0] = x\n        self.heap[1] = -1\n        self.heap[2] = -1\n        for i in range(3, self.k):\n            if self.heap[i] < self.heap[i//2]:\n                tmp = self.heap[i]\n                self.heap[i] = self.he"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport heapq\n\n\ndef top_k_most_frequent(numbers, k):\n    # Write your code here\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, (number, 1))\n    heapq.heapify(heap)\n    counter = Counter(heap[:k])\n    return counter.most_common(k)\n\n\nif __name__ == '__main__':\n    numbers = [1, 2, 3, 1, 4, 1, 5, 6, 7, 8, 9, 10, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        heap = []\n        for i in nums1:\n            heapq.heappush(heap, (i, 1))\n        for i in nums2:\n            heapq.heappush(heap, (i, 1))\n        \n        while len(heap) > k:\n            heapq.heappop(heap)\n            res.append(heapq.heappop(heap)[0])\n        return res\n\nif __name__ == \"__main__\":\n    k = 3\n    nums1 = [1,2,2,1,3,2,1,3,2,2]\n    nums2 = [1,1,2,2,3,3,3,3,4,4]\n    res = Solution().topKFrequent(k, nums1, nums2)\n    print(res)"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop, heapify, heapreplace\nimport collections\n\ndef top_k_int(numbers, k):\n    heap = collections.deque(sorted(numbers))\n    for i in range(k):\n        heappop(heap)\n    result = []\n    while heap:\n        result.append(heappop(heap))\n        heappush(heap, sorted(heap)[0])\n    return result\n\ndef main():\n    numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport heapq\n\ndef topk(k, input_list):\n    input_list = list(input_list)\n    input_list.sort()\n    heap = [(-value, key) for key, value in Counter(input_list).most_common()]\n    heapq.heapify(heap)\n    heapq.heapreplace(heap, (len(input_list), len(input_list)))\n    return heap[:k]\n\nif __name__ == '__main__':\n    input_list = [1,1,2,2,3,3,3,4,4,5,5,6,6,7,8,9,10]\n    k = 3\n    print topk(k, input_list)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer[]} nums2\n    # @param {integer} k\n    # @return {integer[]}\n    def topKFrequent(self, nums1, nums2, k):\n        heap = []\n        for num in nums1:\n            heapq.heappush(heap, (nums2.count(num), num))\n        res = []\n        while len(heap) > 0:\n            if len(res) == k:\n                break\n            (count, val) = heapq.heappop(heap)\n            res.append(val)\n        return res"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "# Heap Queue\n# Time complexity: O(n log k)\n# Space complexity: O(k)\n# Source: https://www.geeksforgeeks.org/top-k-sorted-and-distinct-elements-heap-queue/\n\ndef top_k_frequent_elements(arr, k, visited):\n    heap = [0] * k\n    queue = []\n    for i in range(len(arr)):\n        if heap[0] < arr[i]:\n            heap[0] = arr[i]\n            queue.append(i)\n            while len(queue) > 0 and heap[0] == arr[queue[0]]:\n                heap[0] = arr[queue.pop(0)]\n                queue.pop(0)\n        else:\n            visited[i] = visited[queue[0]] = 1\n            while len(queue) > 0 and heap[0] == arr[queue[0]]:\n                heap[0] = arr[queue.pop(0)]\n                queue.pop(0)\n            if len(queue) == 0:\n                break\n            heap[0] = arr[queue[0]]\n            queue.append(queue[0])\n            while len(queue) > 0 and heap[0] == arr[queue[0]]:\n                heap[0] = arr[queue.pop(0)]\n                queue.pop(0)\n            if len(queue) == 0:\n                break\n\n    top_k_numbers = []\n    for i in range(k):\n        if visited[i] == 0:\n            top_k_numbers.append(arr[i])\n    return top_k_numbers\n\n# Heap Queue + Linked List\n# Time complexity: O(n log k)\n# Space complexity: O(k)\n# Source: https://www.geeksforgeeks.org/top-k-sorted-and-distinct-elements-heap-queue-linked-list/\n\ndef top_k_frequent_elements_linked_list(arr, k, visited):\n    heap = [0] * k\n    queue = []\n    for i"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def top_k_frequent_numbers(numbers, k):\n    heap = []\n    for number in numbers:\n        heapq.heappush(heap, number)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap\n\nnumbers = [2,2,2,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # construct a heap with nums1, then nums2\n        heap = []\n        for num in nums1:\n            heapq.heappush(heap, (num, -1))\n        heapq.heapify(heap)\n        # construct a heap with nums2\n        heap2 = []\n        for num in nums2:\n            heapq.heappush(heap2, (num, -1))\n        heapq.heapify(heap2)\n        # construct the result\n        result = []\n        for _ in range(k):\n            # pop the max value from heap\n            max_heap = heap.pop()\n            max_heap2 = heap2.pop()\n            # update heap\n            heap.append((max_heap[0], -1))\n            heapq.heapify(heap)\n            heap2.append((max_heap2[0], -1))\n            heapq.heapify(heap2)\n            result.append(max_heap[0])\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().topKFrequent([1, 1, 1, 2, 2, 3, 3], [1, 2, 3, 4, 5, 6, 7], 2) == [1, 2, 3]\n    assert Solution().topKFrequent([1, 1, 1, 2, 2, 3, 3], [1, 2, 3, 4, 5, 6, 7], 3) == [1, 2, 3, 4, 5]\n    assert Solution().topKFrequent([1, 1, 1, 2, 2, 3, 3], [1, 2, 3, 4, 5, 6, 7], 7) == [1, 2, 3, 4, 5, 6, 7]\n    assert Solution().topKF"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "# Heap queue\n# O(n log n)\ndef topk(n, k, a, b):\n    # write your code here\n    h = []\n    for i in range(n):\n        h.append(b[i])\n    heapq.heappush(h, a[i])\n    \n    # while heap is not empty\n    while k > 0:\n        # pop the top element\n        top = heapq.heappop(h)\n        # pop the last element\n        last = heapq.heappop(h)\n        # add the top element\n        heapq.heappush(h, top)\n        # add the last element\n        heapq.heappush(h, last)\n        # print the top element\n        print top\n        # print the last element\n        print last\n        # print the top k elements\n        print h[:k]\n        # decrease the k\n        k = k - 1\n\n# Heap queue\n# O(n log n)\ndef topk_min(n, k, a, b):\n    # write your code here\n    h = []\n    for i in range(n):\n        h.append(b[i])\n    heapq.heapify(h)\n    \n    # while heap is not empty\n    while k > 0:\n        # pop the top element\n        top = heapq.heappop(h)\n        # pop the last element\n        last = heapq.heappop(h)\n        # add the top element\n        heapq.heappush(h, top)\n        # add the last element\n        heapq.heappush(h, last)\n        # print the top element\n        print top\n        # print the last element\n        print last\n        # print the top k elements\n        print h[:k]\n        # decrease the k\n        k = k - 1\n\n# Heap queue\n# O(n log n)\ndef topk_max(n, k, a, b):\n    # write your code here\n    h = []\n    for i in range(n):\n        h.append(b[i])\n    heapq.he"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def top_k(n, k, l):\n\theap = []\n\tfor i in range(0, n):\n\t\theapq.heappush(heap, [l[i], i])\n\tk_occurrences = 0\n\twhile k_occurrences < k:\n\t\tk_occurrences += 1\n\t\twhile heapq.heappop(heap)[1] in l:\n\t\t\theapq.heappop(heap)\n\t\theapq.heappush(heap, [l[heapq.heappop(heap)[1]], heapq.heappop(heap)[1]])\n\treturn heapq.heappop(heap)[1]\n\nn = int(input())\nl = []\nfor i in range(0, n):\n\tl.append(int(input()))\nk = int(input())\nprint(top_k(n, k, l))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\nfrom collections import Counter\n\ndef topKFrequent(k, lst):\n    \"\"\"\n    Input:\n    k: An integer, k represents the top k integers that you want to find.\n    lst: A list of integers.\n    Output:\n    A list of top k integers that occurs most frequently from given list of sorted and distinct integers.\n    \"\"\"\n    cnt = Counter(lst)\n    heap = []\n    for i in range(k):\n        heappush(heap, (cnt[i], i))\n    res = []\n    while k > 0:\n        res.append(heappop(heap)[1])\n        k -= 1\n    return res\n\nif __name__ == '__main__':\n    lst = [1,2,3,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n    k = 5\n    lst = topKFrequent(k, lst)\n    print(lst)"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def build_heap(nums):\n            heap = []\n            for i in range(k):\n                heapq.heappush(heap, nums[i])\n            return heap\n\n        def pop_heap(heap):\n            return heapq.heappop(heap)\n\n        heap = build_heap(nums)\n        max_heap = []\n        while len(heap) > 0:\n            max_heap.append(pop_heap(heap))\n            heap = build_heap(nums)\n        return max_heap"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        heap = []\n        max_heap = []\n        for i in range(len(nums1)):\n            heap.append((nums1[i], i))\n        max_heap.append((nums1[0], 0))\n        while len(heap) > 0:\n            # print heap\n            # print max_heap\n            heap_num, heap_pos = heap[0]\n            max_heap[0] = (heap_num, heap_pos)\n            # print max_heap\n            heap[0] = heap[heap.pop(0)]\n            # print heap\n            max_heap.pop(0)\n            for i in range(len(heap)):\n                heap_num, heap_pos = heap[i]\n                if heap_num in nums2 and nums2[heap_num] > nums2[max_heap[0][0]]:\n                    max_heap[0] = (heap_num, heap_pos)\n                if max_heap[0][0] in nums2 and nums2[max_heap[0][0]] > nums2[heap_num]:\n                    max_heap[0] = (heap_num, heap_pos)\n        # print max_heap\n        return max_heap[:k]\n\na = Solution()\nprint a.topKFrequent([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6], 2)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "#!/usr/bin/python\n\nimport sys\n\ndef top_k(input_list, k):\n    heap_queue = []\n    heap_queue_size = 0\n    for i in range(len(input_list)):\n        heap_queue_size += 1\n        heap_queue.append((input_list[i], i))\n    heap_queue.sort()\n\n    #print heap_queue\n    #print heap_queue_size\n    #print heap_queue[0:k]\n    #print heap_queue[k:]\n    #print heap_queue_size\n    #print len(input_list)\n    #print input_list\n\n    #print input_list\n    for i in range(k):\n        #print heap_queue[i]\n        #print heap_queue_size\n        #print heap_queue[i+1]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print len(heap_queue[i+1:k])\n        #print len(heap_queue[i+1:k])\n        #print len(heap_queue[i+1:k])\n        #print len(heap_queue[i+1:k])\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]\n        #print heap_queue[i+1:k]"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def top_k_frequent(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = [0] * k\n    heapq.heapify(heap)\n    for i in range(len(nums)):\n        heapq.heappush(heap, nums[i])\n        while len(heap) > k:\n            heapq.heappop(heap)\n    return [i for i in range(k) if heapq.heappop(heap) == nums[i]]\n\nif __name__ == \"__main__\":\n    print(top_k_frequent([1, 1, 2, 3, 3, 4, 5, 5, 6, 7], 3))\n    print(top_k_frequent([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8], 4))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "def find_top_k(k, l1, l2, l3):\n    \"\"\"\n    Input:\n        k: the number of top items to be found.\n        l1: list of integers sorted by increasing frequency.\n        l2: list of integers distinct from l1.\n        l3: list of integers distinct from l1 and l2.\n    Output:\n        the k most frequently occurring top items.\n    \"\"\"\n    # create a heap with the first k elements.\n    heap = []\n    for i in range(k):\n        heap.append((l1[i], i))\n    heapq.heapify(heap)\n\n    # while the heap has more elements than the number of top k items.\n    while k < len(heap):\n        # get the top k items from the heap.\n        top_k_items = [heapq.heappop(heap) for i in range(k)]\n\n        # if the top k items are from the same list, remove them.\n        for i in range(k):\n            if top_k_items[i][0] == top_k_items[i+1][0]:\n                top_k_items.pop(i)\n                k -= 1\n\n        # get the list of distinct integers that occur more frequently.\n        distinct_items = [top_k_items[i][1] for i in range(k)]\n\n        # get the list of distinct integers that occur less frequently.\n        # the difference list is the difference between the distinct items\n        # and the distinct items in the current list.\n        diff_list = [l1[i] for i in range(len(l1)) if l1[i] not in distinct_items]\n        diff_list += [l2[i] for i in range(len(l2)) if l2[i] not in distinct_items]\n        diff_list += [l3[i] for i in range(len(l3)) if l3[i] not in distinct_items]\n\n        # sort the list of distinct integers in decreasing order.\n        diff_list.sort(reverse=True)\n\n        # append the distinct integers to the top k list.\n        for i in range("
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "def top_k_frequencies(input_list, k):\n    \"\"\"\n    :type input_list: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for i in range(len(input_list)):\n        heapq.heappush(heap, (input_list[i], i))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap\n\n\nif __name__ == '__main__':\n    input_list = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 9, 10, 11, 12, 12]\n    k = 3\n    print top_k_frequencies(input_list, k)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "# Heap Queue\n# Heap Queue is a very simple implementation of a queue.\n# Heap Queue is a data structure that can be used to store and access the elements of a queue.\n# This implementation is a minimal implementation.\n\n# Heap Queue is a queue that stores the elements in a heap structure.\n# The heap structure is a sorted array where the top element is at the top of the array.\n# The array is empty initially.\n# The elements in the heap are inserted in the bottom up manner, that is, the smallest element is at the bottom of the heap.\n# The heap is always sorted, and the elements are always inserted at the bottom up manner.\n# The heap structure is a heap that is sorted, and the elements are inserted at the bottom up manner.\n# The heap is a simple implementation of a queue.\n# Heap Queue is a data structure that can be used to store and access the elements of a queue.\n# This implementation is a minimal implementation.\n\n# Heap Queue is a queue that stores the elements in a heap structure.\n# The heap structure is a sorted array where the top element is at the top of the array.\n# The array is empty initially.\n# The elements in the heap are inserted in the bottom up manner, that is, the smallest element is at the bottom of the heap.\n# The heap is always sorted, and the elements are inserted at the bottom up manner.\n# The heap structure is a heap that is sorted, and the elements are inserted at the bottom up manner.\n# Heap Queue is a data structure that can be used to store and access the elements of a queue.\n# This implementation is a minimal implementation.\n\n# Heap Queue is a queue that stores the elements in a heap structure.\n# The heap structure is a sorted array where the top element is at the top of the array.\n# The array is empty initially.\n# The elements in the heap are inserted in the bottom up manner, that is, the smallest element is at the bottom of the heap.\n# The heap is always sorted, and the elements are inserted at the bottom up manner.\n# The heap structure is a heap that is sorted, and the elements are inserted at the bottom up manner.\n# Heap Queue is a data structure that can be used to store and access the elements of a"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Heap queue\n        h = []\n        # Set to keep the top k frequency\n        freq = set()\n        # For each element in nums1, add it to the heap and update the frequency\n        for i in nums1:\n            h.append((i, 1))\n            while len(h) > 0 and h[0][1] > k:\n                heapq.heappop(h)\n                if i in freq:\n                    freq.remove(i)\n                freq.add(i)\n        # For each element in nums2, add it to the heap and update the frequency\n        for i in nums2:\n            heapq.heappush(h, (i, 1))\n            while len(h) > 0 and h[0][1] > k:\n                heapq.heappop(h)\n                if i in freq:\n                    freq.remove(i)\n                freq.add(i)\n        # Return the top k frequency\n        return list(freq)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "def topk_heap(arr, k):\n    if len(arr) == 0:\n        return 0\n    heap = []\n    for i in range(len(arr)):\n        heapq.heappush(heap, (arr[i], i))\n    heapq.heappop(heap)\n    # print heap\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop(heap)\n    # print heapq.heappop"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "import heapq\n\nclass TopK:\n    def __init__(self, k):\n        self.k = k\n        self.num_list = []\n        self.max_val = -1\n\n    def add(self, val):\n        self.num_list.append(val)\n        if val > self.max_val:\n            self.max_val = val\n\n    def topk(self):\n        heap = []\n        for i in range(len(self.num_list)):\n            heapq.heappush(heap, (-self.num_list[i], i))\n        return heap[:self.k]\n\nif __name__ == \"__main__\":\n    t = TopK(3)\n    t.add(1)\n    t.add(2)\n    t.add(3)\n    t.add(4)\n    t.add(5)\n    t.add(6)\n    t.add(7)\n    t.add(8)\n    t.add(9)\n    t.add(10)\n    t.add(11)\n    t.add(12)\n    t.add(13)\n    t.add(14)\n    t.add(15)\n    t.add(16)\n    t.add(17)\n    t.add(18)\n    t.add(19)\n    t.add(20)\n    t.add(21)\n    t.add(22)\n    t.add(23)\n    t.add(24)\n    t.add(25)\n    t.add(26)\n    t.add(27)\n    t.add(28)\n    t.add(29)\n    t.add(30)\n    t.add(31)\n    t.add(32)\n    t.add(33)\n    t.add(34)\n    t.add(35)\n    t.add(36)\n    t.add(37)\n    t.add(38)\n    t.add(39)\n    t.add(40)\n    t.add(41)\n    t.add(42)\n    t"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "#!/usr/bin/python\n\nimport random\nimport heapq\n\ndef top_k_int(input_list, k):\n    counts = {}\n    for i in input_list:\n        counts[i] = counts.get(i, 0) + 1\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, sorted_counts[i][0])\n    top_k = []\n    for i in range(k):\n        top_k.append(heapq.heappop(heap))\n\n    return top_k\n\nif __name__ == '__main__':\n    input_list = [1, 2, 3, 1, 2, 3, 2, 3, 1, 2, 3, 3, 3, 4, 5]\n    k = 3\n    print(top_k_int(input_list, k))"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def top_k_frequent(num_list, k):\n    heap = []\n    for i in num_list:\n        heap.append((i, i))\n    heapq.heapify(heap)\n    while len(heap) > k:\n        heapq.heappop(heap)\n        print heap.pop(0)\n\ndef main():\n    num_list = [3,3,3,2,2,2,2,3,3,4,4,4,4]\n    top_k_frequent(num_list, 2)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        # dp[i]\u8868\u793anums1\u4e2d\u7b2ci\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\n        # dp[i][j]\u8868\u793anums2\u4e2d\u7b2cj\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\n        dp = [[0] * k for i in range(k)]\n        heap = []\n        for i in range(len(nums1)):\n            heap.append((nums1[i], nums2[i], i))\n            dp[0][0] = nums1[i]\n        for i in range(1, k):\n            for j in range(len(nums1)):\n                if dp[i-1][j] > dp[i][j]:\n                    dp[i][j] = dp[i-1][j]\n                if j == len(nums1) - 1:\n                    dp[i][j] += nums1[j]\n        # \u521d\u59cb\u5316dp[i][j]\n        for i in range(len(nums2)):\n            dp[0][i] = nums2[i]\n        for i in range(1, k):\n            for j in range(len(nums2)):\n                if dp[i-1][j] > dp[i][j]:\n                    dp[i][j] = dp[i-1][j]\n                if j == len(nums2) - 1:\n                    dp[i][j] += nums2[j]\n        return dp[k-1]\n\nnums1 = [3, 1, 4, 2, 3, 5, 3]\nnums2 = [1, 2, 3, 4, 5, 6, 7]\nn"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def topKFrequent(self, k, nums1, nums2):\n        # write your code here\n        heap = []\n        for i in xrange(len(nums1)):\n            heapq.heappush(heap, (nums1[i], nums2[i]))\n        heapq.heapify(heap)\n        result = []\n        while len(heap) >= k:\n            result.append(heapq.heappop(heap)[1])\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.topKFrequent(2, [2, 3, 1, 2, 2, 4, 5], [1, 1, 2, 3, 2, 2])\n    print s.topKFrequent(3, [2, 3, 1, 2, 2, 4, 5], [1, 1, 2, 3, 2, 2])\n    print s.topKFrequent(3, [2, 3, 1, 2, 2, 4, 5], [1, 1, 2, 3, 2, 2, 3])"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import heapq\n\ndef top_k_ints(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # use heapq to create a heap with the top k list\n    heapq.heapify(heapq.merge(map(heapq.heappop,\n                                  [heapq.heapify(nums),\n                                   heapq.heappop(nums)])))\n    # pop the top k list from the heap\n    top_k = map(lambda x: x[0], heapq.nsmallest(k, nums))\n    return top_k\n\nif __name__ == '__main__':\n    nums = [2, 1, 3, 1, 3, 2, 1, 3, 1, 1]\n    k = 4\n    print top_k_ints(nums, k)"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "# Heap queue\n# O(n) time\n# O(k log k) space\n\ndef topKFrequent(a, b, k):\n    heap = []\n    heapq.heapify(heap)\n    for i in range(len(a)):\n        heapq.heappush(heap, (a[i], i))\n    for i in range(len(b)):\n        heapq.heappush(heap, (b[i], i))\n    count = 0\n    result = []\n    while len(heap) > k:\n        count += 1\n        result.append(heapq.heappop(heap)[1])\n    return result\n\nif __name__ == '__main__':\n    a = [1,2,3,1,2,3,4,5,6,7,8,9]\n    b = [3,5,6,7,8,9,1,2,3,4,5,6,7,8,9]\n    print topKFrequent(a, b, 3)"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "import collections\n\ndef top_k(input_list, k):\n    # Create a heap queue with k items.\n    heap = collections.deque()\n    # Keep track of the number of times each element occurs in input_list.\n    element_count = collections.Counter(input_list)\n    # Keep track of the top k elements in the input_list.\n    top_k_elements = collections.Counter()\n    # Keep track of the index of the element in the input_list that is at the top of the queue.\n    top_element_index = 0\n    # Keep track of the number of elements in the input_list that have been added to the heap.\n    added_count = 0\n    # Keep track of the number of times a top_k element was added to the heap.\n    added_count_per_element = collections.Counter()\n    # Keep track of the number of times the top_k element was removed from the heap.\n    removed_count_per_element = collections.Counter()\n    # Keep track of the number of times a top_k element was updated in the heap.\n    updated_count_per_element = collections.Counter()\n    # Keep track of the number of times a top_k element was updated in the heap.\n    updated_count = 0\n    # Keep track of the number of times the heap was updated.\n    updated_count_per_element = collections.Counter()\n    # Keep track of the number of times the heap was updated.\n    updated_count = 0\n    # Add the top k elements from the input_list to the heap.\n    for element in input_list:\n        heap.append(element)\n        added_count += 1\n        added_count_per_element[added_count] += 1\n    # Remove the top k elements from the heap until the heap is empty.\n    while len(heap) > 0:\n        top_element = heap[0]\n        removed_count += 1\n        removed_count_per_element[removed_count] += 1\n        heap.popleft()\n        if added_count > 0:\n            updated_count += 1\n            updated_count_per_element[updated_count] += 1\n        if"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        from heapq import heappush, heappop, heapify, nlargest\n        heap = []\n        heapq.heappush(heap, (-nums2[0], 0))\n        for i in xrange(1, len(nums2)):\n            heapq.heappush(heap, (-nums2[i], i))\n        nlargest = []\n        while k > 0:\n            heappush(heap, (-heappop(heap)[0], -heappop(heap)[1]))\n            nlargest.append(heappop(heap)[1])\n            k -= 1\n        return nlargest"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-top-k/problem\n\n# Note:\n# The input array is a list of integers, and the output is an array of integers.\n# The input and output arrays will have the same size.\n# The input array will be sorted in ascending order.\n# The input integers will all be distinct.\n# You will not use any built-in library to help you solve this problem.\n# Time Complexity: O(nlog(n))\n# Space Complexity: O(k)\n\ndef top_k_appear(n, k, a, b, c):\n    # Your code here\n    # A heap queue.\n    # A tuple of (value, index)\n    # When the queue is empty, the queue is initialized to a tuple of (k, 0)\n    # We initialize a queue to a tuple of (k, 0) to start with\n    q = [(k, 0)]\n    # Keep track of the number of elements in the queue\n    count = 0\n    # Keep track of the minimum value in the queue\n    min = n\n    # Keep track of the maximum value in the queue\n    max = n\n    # Keep track of the number of elements in the queue\n    i = 0\n    while i < len(q):\n        # When we have an element in the queue, we can remove it\n        min, i = q.pop(0)\n        # Check if the element is in the list\n        if min in a:\n            # If the element is in the list, increment the count\n            count += 1\n            # Update the queue with the minimum element from the list\n            q.append((min, i))\n            # Update the maximum element from the list\n            if min < max:\n                max = min\n        elif min in b:\n            # If the element is not in the list, update the count and the minimum\n            # element from the list\n            count += 1\n            q.append((min, i))\n            # Update the maximum element from the list\n            if min < max:\n                max = min\n        elif min in c:\n            # If the element is not in the list, update the count and the minimum\n            # element from the list\n            count"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "import heapq\n\ndef find_topk(k, lists):\n    \"\"\"\n    :type k: int\n    :type lists: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = [(-heapq.heappop(lists[i]), i) for i in range(len(lists))]\n    heapq.heapify(heap)\n    result = []\n    while len(heap) > 0:\n        result.append(heapq.heappop(heap)[0])\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return result\n\n# Note: This solution is much faster than the one using a heapq.\ndef find_topk_slow(k, lists):\n    \"\"\"\n    :type k: int\n    :type lists: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for i, v in enumerate(lists):\n        if v > 0:\n            heapq.heappush(heap, (-v, i))\n    result = []\n    while len(heap) > 0:\n        result.append(heapq.heappop(heap)[0])\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return result"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom heapq import *\n\ndef top_k(arr, k):\n    counts = defaultdict(int)\n    for i in range(len(arr)):\n        counts[arr[i]] += 1\n    heapify(counts)\n\n    for i in range(len(arr)):\n        if counts[arr[i]] == k:\n            heappop(counts)\n            heappush(counts, arr[i])\n\n    return counts\n\ndef test():\n    arr = [2, 4, 4, 5, 7, 9, 2, 8, 2, 2, 1, 2]\n    k = 3\n    assert top_k(arr, k) == {2: 3, 4: 2, 5: 1, 7: 1, 8: 1, 9: 1}\n    k = 1\n    assert top_k(arr, k) == {2: 1, 4: 2, 5: 1, 7: 1, 8: 1, 9: 1}\n    k = 10\n    assert top_k(arr, k) == {2: 1, 4: 1, 5: 1, 7: 1, 8: 1, 9: 1}\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef top_k_frequent_ints(numbers, k):\n    \"\"\"\n    Input:\n        numbers - list of sorted and distinct integers\n        k - top k integers\n    Output:\n        a list of top k integers\n    \"\"\"\n\n    # create a heap queue with an initial size of 1\n    queue = [0]\n    queue.extend(numbers[:k])\n\n    # keep track of the most frequent number\n    max_freq = 0\n    max_freq_num = 0\n    # keep track of the index of the most frequent number\n    max_freq_index = 0\n\n    # keep track of the index of the next element to be inserted in the heap queue\n    next_index = 0\n\n    # keep track of the frequency of the most frequent number\n    freq_count = 0\n\n    # keep track of the number of elements in the heap queue\n    size = k\n\n    # keep track of the maximum number of elements in the heap queue\n    max_size = len(numbers)\n\n    # iterate through the list of numbers\n    for i in range(len(numbers)):\n        # if the most frequent number is already in the heap queue\n        if queue[0] == numbers[i]:\n            # increase the frequency of the most frequent number\n            freq_count += 1\n\n        # if the most frequent number is not in the heap queue\n        else:\n            # if the most frequent number is less than the current element in the heap queue\n            if queue[0] < numbers[i]:\n                # add the element to the heap queue\n                queue.append(numbers[i])\n\n                # keep track of the most frequent number\n                max_freq = max(max_freq, freq_count)\n                max_freq_num = numbers[i]\n                max_freq_index = i\n\n                # increase the frequency of the most frequent number\n                freq_count = 1\n            # if the most frequent number is greater than the current element in the heap queue\n            else:\n                # decrease the frequency of the most frequent number\n                freq_count -= 1\n\n                # if the frequency of the most frequent number is less than the current element in the heap queue\n                if fre"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef top_k_values(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for i in range(k):\n        heappush(heap, arr[i])\n    res = []\n    while len(heap) > 0:\n        res.append(heappop(heap))\n        if len(heap) > 0:\n            for j in range(k):\n                if j < k - 1 and arr[j] == arr[j + 1]:\n                    heappush(heap, arr[j + 1])\n        else:\n            break\n    return res\n\n\nif __name__ == '__main__':\n    print(top_k_values([1, 2, 3, 2, 1, 3, 2, 1, 3], 3))\n    print(top_k_values([1, 2, 3, 2, 1, 3, 2, 1, 3], 4))\n    print(top_k_values([1, 2, 3, 2, 1, 3, 2, 1, 3], 5))\n    print(top_k_values([1, 2, 3, 2, 1, 3, 2, 1, 3], 6))"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "import collections\nimport heapq\n\ndef top_k(k, l):\n    if len(l) <= k:\n        return l\n    else:\n        h = collections.defaultdict(int)\n        for num in l:\n            h[num] += 1\n        heap = [(num, h[num]) for num in h.keys() if h[num] == 1]\n        heapq.heapify(heap)\n        k_list = []\n        while len(heap) >= k:\n            num, val = heapq.heappop(heap)\n            k_list.append(val)\n        return k_list\n\n\n# Test cases\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])\nprint top_k(k=3, l=[5, 4, 2, 1, 3, 1, 5, 9, 5, 6, 3])"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        queue = []\n        nums1.sort()\n        nums2.sort()\n        max_heap = [0] * len(nums1)\n        for i in xrange(len(nums1)):\n            if nums1[i] not in max_heap:\n                max_heap[i] = nums1[i]\n            elif nums1[i] == max_heap[i]:\n                heapq.heappush(queue, nums1[i])\n            else:\n                heapq.heapreplace(queue, nums1[i])\n        heapq.heapify(queue)\n        max_heap[:k] = [max_heap[i] for i in xrange(k)]\n        return max_heap[:k]\n\n\nif __name__ == '__main__':\n    assert Solution().topKFrequent([1, 1, 2, 2, 3, 3, 3, 4], [1, 1, 1, 2, 2, 2, 3, 4, 4, 4], 3) == [4, 4, 4]\n    assert Solution().topKFrequent([1, 1, 2, 2, 3, 3, 3, 4], [1, 1, 1, 2, 2, 2, 3, 4, 4, 4], 3) == [4, 4, 4]\n    assert Solution().topKFrequent([1, 1, 2, 2, 3, 3, 3, 4], [1, 1, 1, 2, 2, 2, 3, 4, 4, 4], 3) == [4, 4, 4]"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def kthMaxNode(self, root, k):\n        heap = []\n        curr_heap = []\n        curr_heap_num = 0\n        curr_kth_node = None\n\n        while root is not None:\n            heap.append(root)\n            root = root.left\n            curr_heap.append(root)\n            curr_heap_num += 1\n            if curr_heap_num == k:\n                curr_heap_num = 0\n                curr_kth_node = heap.pop()\n                heap.append(curr_kth_node)\n                root = curr_kth_node.right\n\n        return curr_kth_node\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    print(sol.kthMaxNode(root, 4))\n    root = TreeNode(1, TreeNode(2), TreeNode(3))\n    print(sol.kthMaxNode(root, 2))\n    root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4))\n    print(sol.kthMaxNode(root, 2))"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "import heapq\n\ndef top_k(k, n, nums1, nums2):\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, (-1, nums1[i], nums2[i]))\n\n    # print heap\n    # print \"heap length is\", len(heap)\n    max_heap = []\n    for i in range(k):\n        if len(max_heap) == k:\n            break\n        elif len(max_heap) == 0:\n            max_heap.append(heapq.heappop(heap)[2])\n        else:\n            max_heap.append(heapq.heappop(heap)[2])\n            if heapq.heappop(heap)[0]!= -1:\n                max_heap.append(heapq.heappop(heap)[2])\n    return max_heap\n\ndef test():\n    nums1 = [1,1,1,2,2,2,3,3,3,4,4,4]\n    nums2 = [1,1,1,2,2,2,3,3,3,4,4,4]\n    print top_k(3, len(nums1), nums1, nums2)\n    print top_k(1, len(nums1), nums1, nums2)\n    print top_k(2, len(nums1), nums1, nums2)\n    print top_k(3, len(nums1), nums1, nums2)\n    print top_k(4, len(nums1), nums1, nums2)\n    print top_k(5, len(nums1), nums1, nums2)\n    print top_k(6, len(nums1), nums1, nums2)\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param m, an integer\n    # @param k, an integer\n    # @return a list of integers\n    def topKFrequent(self, A, m, k):\n        if not A: return []\n        heap = []\n        for i in A:\n            heap.append((i, i))\n        heapq.heapify(heap)\n        result = []\n        while len(heap) > k:\n            heapq.heappop(heap)\n            result.append(heapq.heappop(heap)[0])\n        return result"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "import collections\n\ndef topk(n, k, lst):\n    heapq.heapify(lst)\n    topk_list = []\n    for i in range(k):\n        topk_list.append(heapq.heappop(lst))\n    # sort the topk list\n    topk_list.sort(reverse=True, key=lambda x: x[1])\n    # convert the list into a list of tuples\n    topk_list = list(zip(topk_list[0:k], topk_list[1:]))\n    # convert the list into a list of sorted integers\n    topk_list = [x[0] for x in topk_list]\n    # return the list\n    return topk_list\n\n# Test cases\nn = 5\nk = 2\nlst = [1, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1, 2"
    },
    {
      "rank": 84,
      "score": 3.0,
      "candidate": "# Heap queue algorithm\n# https://en.wikipedia.org/wiki/Heap_%28computing%29\n# time complexity: O(n log k)\n# space complexity: O(k)\ndef topKFrequent(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # create a heap queue\n    heap = [i for i in arr]\n    heapq.heapify(heap)\n\n    # create a result list and store top k elements\n    result = []\n    for i in range(k):\n        result.append(heapq.heappop(heap))\n\n    # process the remaining elements\n    while len(heap) > 0:\n        result.append(heapq.heappop(heap))\n\n    return result\n\n# Note:\n# Time complexity is O(n log k)\n# Space complexity is O(k)\n\n# Example:\n# Input: arr = [1,2,1,3,2,1,2], k = 2\n# Output: [1,2]\n\n# Note:\n# arr and k will have a length of at least 1.\n# arr will have unique elements.\n# k will be less than or equal to the length of arr."
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if k > len(nums):\n            return []\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, (num, num))\n            if len(heap) == k:\n                heapq.heappop(heap)\n        return [num for (num, _) in heap]"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/top-k-frequent-elements/discuss/81896/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92429/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/94402/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/98503/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/95221/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/92953/Java-Python-Heap-Queue-Solution\n\nfrom collections import defaultdict\n\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        counts = defaultdict"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from collections import Counter\nimport heapq\n\ndef topk(k, l):\n    \"\"\"\n    :type k: int\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heapq.heapify(l)\n    res = []\n    cnt = Counter(l)\n    while len(res) < k:\n        res.append(heapq.heappop(l))\n        cnt = Counter(l)\n        for key in cnt:\n            if cnt[key] > cnt[res[-1]]:\n                res[-1] = key\n    return res\n\n\n# Your TopKIntegers object will be instantiated and called as such:\n# obj = TopKIntegers(k)\n# param_1 = obj.findTop(l)\n\nclass TopKIntegers(object):\n\n    def findTop(self, l):\n        \"\"\"\n        :type k: int\n        :type l: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        heapq.heapify(l)\n        cnt = Counter(l)\n        while len(res) < k:\n            res.append(heapq.heappop(l))\n            cnt = Counter(l)\n            for key in cnt:\n                if cnt[key] > cnt[res[-1]]:\n                    res[-1] = key\n        return res"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) == 0 or len(nums2) == 0:\n            return []\n        heap = []\n        for i in range(len(nums1)):\n            heap.append((nums1[i], i))\n        heapq.heapify(heap)\n        result = []\n        while k > 0:\n            if heapq.empty():\n                break\n            curr = heapq.heappop(heap)\n            result.append(curr[1])\n            k -= 1\n        return result"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import collections\nclass Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # O(NlogN) time\n        # O(N) space\n        # use min heap\n        # heap = collections.deque()\n        # for num in nums1:\n        #     heapq.heappush(heap, (num, 1))\n        # for num in nums2:\n        #     heapq.heappush(heap, (num, 1))\n        # while len(heap) > k:\n        #     heapq.heappop(heap)\n        # return heapq.heappop(heap)[0]\n        # O(N) time\n        # O(N) space\n        # use min heap\n        # heap = collections.deque()\n        # for num in nums1:\n        #     heap.append((num, 1))\n        # for num in nums2:\n        #     heap.append((num, 1))\n        # while len(heap) > k:\n        #     heap.pop()\n        # return heap[0]\n        # O(NlogN) time\n        # O(NlogN) space\n        # use min heap\n        # heap = collections.deque()\n        # for num in nums1:\n        #     heap.append((num, 1))\n        # for num in nums2:\n        #     heap.append((num, 1))\n        # while len(heap) > k:\n        #     heap.pop()\n        # return heap[0]\n        # O(N) time\n        # O(N) space\n        # use min heap\n        # heap = collections.deque()\n        # for num in nums1:\n        #     heap.append((num, 1))\n        # for num in nums2:\n        #     heap.append((num, 1))\n        # while"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import heapq\nfrom collections import Counter\n\ndef find_k_top_k_ints(input_list, k):\n    heap = []\n    for input_list_item in input_list:\n        heapq.heappush(heap, (input_list_item, input_list.count(input_list_item)))\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return Counter(heap[:k]).most_common(k)\n\ndef test_find_k_top_k_ints():\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == Counter([(10, 1), (9, 1), (8, 1)])\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) == Counter([(10, 1), (9, 1), (8, 1), (7, 1)])\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == Counter([(10, 1), (9, 1), (8, 1), (7, 1), (6, 1)])\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) == Counter([(10, 1), (9, 1), (8, 1), (7, 1), (6, 1), (5, 1)])\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == Counter([(10, 1), (9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1)])\n    assert find_k_top_k_ints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8) == Counter([(10, 1), (9, 1), (8, 1), (7, 1"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Your code should be self-contained and not rely on any other libraries.\n# The code should be structured in the following style:\n# 1) Define a function that takes two lists of integers and returns a list of top k integers.\n# 2) Test your function using different lists and k values.\n# 3) Add more functions that take two lists of integers and return a list of top k integers.\n\n# Example 1\n# Input: [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3], k = 3\n# Output: [3, 2, 1]\n# Explanation: The function returns a list of 3 integers: [3, 2, 1]\n# Example 2\n# Input: [1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9], k = 3\n# Output: [4, 3, 2]\n# Explanation: The function returns a list of 3 integers: [4, 3, 2]\n# Example 3\n# Input: [1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9], k = 4\n# Output: [4, 3, 2, 1]\n# Explanation: The function returns a list of 4 integers: [4, 3, 2, 1]\n# Example 4\n# Input: [1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9], k = 5\n# Output: [4, 3, 2, 1, 1]\n# Explanation: The function returns a list of 5 integers: [4, 3, 2, 1, 1]\n# Example 5\n# Input: [1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 6, 7, 8, 9], k = 10\n# Output: [4, 3, 2, 1, 1]\n# Explanation: The function returns a list of 10 integers: [4, 3, 2, 1, 1, 1, 1, 1, 1, 1]\n\n# Note:\n# 1 <= k <= 10000\n# The size of the input lists will be in the range of [1,"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from collections import Counter\n\nclass Solution:\n    def topKFrequent(self, k: int, nums1: List[int], nums2: List[int]) -> List[int]:\n        # write your code here\n        h = {}\n        for num in nums1:\n            if num in h:\n                h[num] += 1\n            else:\n                h[num] = 1\n\n        for num in nums2:\n            if num in h:\n                h[num] -= 1\n            else:\n                h[num] = -1\n\n        cnt = Counter(h)\n        kth = cnt.most_common(k)\n        return [num for num, _ in kth]"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from collections import Counter\nfrom heapq import heappush, heappop\n\n\ndef top_k_frequent_numbers(data, k):\n    \"\"\"\n    :type data: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for number in data:\n        heappush(heap, (Counter(data), number))\n\n    return [heappop(heap)[1] for i in range(k)]\n\n\nif __name__ == '__main__':\n    assert top_k_frequent_numbers([1, 2, 3, 2, 1, 1, 2, 3, 3], 2) == [1, 2]\n    assert top_k_frequent_numbers([1, 2, 3, 2, 1, 1, 2, 3, 3], 3) == [1, 2, 3]\n    assert top_k_frequent_numbers([1, 2, 3, 2, 1, 1, 2, 3, 3], 4) == [1, 2, 3, 3]\n    assert top_k_frequent_numbers([1, 2, 3, 2, 1, 1, 2, 3, 3], 5) == [1, 2, 3, 3, 3]"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for num in nums:\n            heappush(heap, (num, 1))\n            if len(heap) > k:\n                heappop(heap)\n                heappush(heap, (num, 1))\n        return [heappop(heap)[0] for _ in xrange(k)]\n\nclass Solution2(object):\n    def topKFrequent(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for num in nums:\n            heappush(heap, (num, 1))\n            if len(heap) > k:\n                heappop(heap)\n                heappush(heap, (num, 1))\n        return [heappop(heap)[0] for _ in xrange(k)]\n\n\nif __name__ == '__main__':\n    print Solution().topKFrequent(1, [1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5])\n    print Solution2().topKFrequent(1, [1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5])"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def topKFrequent(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # Write your code here\n        heap = []\n        for n in nums1:\n            heap.append((n, n, 0))\n        for n in nums2:\n            heap.append((n, n, 0))\n\n        while len(heap) > k:\n            heap.sort()\n            heap.pop(0)\n            heap.sort()\n            if heap[0][2] == 0:\n                heap[0][2] += 1\n                heap[0][1] = heap[0][0]\n                heap[0][0] = heap[-1][0]\n                heap.pop()\n        return heap[:k]"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, k, nums1, nums2):\n        \"\"\"\n        :type k: int\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Write your code here\n        # heap = [heap_node(item) for item in nums1]\n        heap = []\n        for item in nums1:\n            heap.append(heap_node(item))\n        heapq.heapify(heap)\n\n        # heap = [heap_node(item) for item in nums2]\n        heap = []\n        for item in nums2:\n            heap.append(heap_node(item))\n        heapq.heapify(heap)\n\n        result = []\n        heap_count = 0\n        while heap_count < k:\n            heap_node = heap.pop()\n            heap_count += 1\n            result.append(heap_node.item)\n            # heap_node.item = heap_node.item\n            # heap_node.count = heap_node.count + 1\n            heapq.heapreplace(heap, heap_node)\n        return result\n\nclass heap_node(object):\n    def __init__(self, item, count):\n        self.item = item\n        self.count = count\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.topKFrequent(2, [1,2,3,1,2,3,3,3,1,1], [1,2,3,4,5])\n    print solution.topKFrequent(2, [1,2,3,1,2,3,3,3,1,1], [1,2,3,4,5,6,7,8,9])\n    print solution.topKFrequent(2, [1,2,3,1,2,3,3,3,1,1], [1,2,3,4,5,6,7,8,9,"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from collections import Counter\nimport heapq\nimport operator\nimport random\n\n\ndef top_k(k, sorted_list, distinct_list):\n    \"\"\"\n    :param k: top k\n    :param sorted_list: list of sorted integers\n    :param distinct_list: list of distinct integers\n    :return: tuple of lists of top k integers from sorted and distinct lists\n    \"\"\"\n    counts = Counter(sorted_list)\n    top_k_list = []\n    for i in range(k):\n        top_k_list.append(heapq.heappop(counts.iteritems()))\n    top_k_list.append((sorted_list[0], 0))\n    top_k_list.append((distinct_list[0], 1))\n    for i in range(1, len(distinct_list)):\n        top_k_list.append((distinct_list[i], 0))\n        top_k_list.append((distinct_list[i], 1))\n    return top_k_list\n\n\ndef test_top_k():\n    assert top_k(1, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2, 3], [1, 2, 3, 4]]\n    assert top_k(2, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2], [1, 2, 3, 4]]\n    assert top_k(3, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2, 3], [1, 2, 3, 4]]\n    assert top_k(4, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2, 3, 4]]\n    assert top_k(5, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2, 3, 4]]\n    assert top_k(6, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2, 3, 4]]\n    assert top_k(7, [1, 2, 3], [1, 2, 3, 4]) == [[1, 2,"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import collections\n\ndef top_k_frequencies(sorted_list, distinct_list, k):\n    \"\"\"\n    :type sorted_list: List[int]\n    :type distinct_list: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    # create a heap with max size k\n    heap = collections.deque()\n    # create a dict with frequency of each integer\n    freq = collections.defaultdict(int)\n    for i in distinct_list:\n        freq[i] += 1\n    # populate the heap with the max frequency integers\n    for i in sorted_list:\n        if freq[i] > 0:\n            heap.append(i)\n            freq[i] -= 1\n    # heapify the heap\n    heap.sort(reverse=True)\n    # extract k integers\n    top_k = heap[:k]\n    return top_k\n\ndef test_top_k_frequencies():\n    assert top_k_frequencies([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3, 3, 3, 3, 3, 3, 3, 3], 3) == [3, 3, 3]\n    assert top_k_frequencies([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3, 3, 3, 3, 3, 3, 3, 3], 1) == [3]\n    assert top_k_frequencies([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3, 3, 3, 3, 3, 3, 3, 3], 10) == [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    assert top_k_frequencies([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 3, 3, 3, 3, 3, 3, 3, 3], 5) == [3, 3, 3, 3, 3]\n    assert top_k_frequencies([1, 2, 3, 4, 5, 6, 7, 8, 9], ["
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# This is a Java solution.\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/68126/Java-heap-queue-solution\nclass Solution:\n    # @param a, a list of integer\n    # @param m, an integer\n    # @param k, an integer\n    # @return an integer\n    def topKFrequent(self, a, m, k):\n        # write your code here\n        heap = []\n        for i in range(len(a)):\n            heapq.heappush(heap, (a[i], m[i]))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return heap[:k]\n\n# This is a Python solution.\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/68126/Python-heap-queue-solution\nclass Solution:\n    # @param a, a list of integer\n    # @param m, an integer\n    # @param k, an integer\n    # @return an integer\n    def topKFrequent(self, a, m, k):\n        # write your code here\n        heap = []\n        for i in range(len(a)):\n            heapq.heappush(heap, (a[i], m[i]))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return heap[:k]\n\n# This is a C++ solution.\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/68126/C-heap-queue-solution\nclass Solution:\n    # @param a, a list of integer\n    # @param m, an integer\n    # @param k, an integer\n    # @return an integer\n    def topKFrequent(self, a, m, k):\n        # write your code here\n        heap = []\n        for i in range(len(a)):\n            heapq.heappush(heap, (a[i],"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Heap queue solution\n\nclass Solution:\n    # @param num, a list of integers\n    # @param k, an integer\n    # @return an integer\n    def topKFrequent(self, num, k):\n        if k < 1 or k > len(num):\n            return 0\n        heap = []\n        for i in num:\n            heapq.heappush(heap, (i, i))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return heap[:k]\n\n\n# Union-find solution\n\nclass Solution:\n    # @param num, a list of integers\n    # @param k, an integer\n    # @return an integer\n    def topKFrequent(self, num, k):\n        if k < 1 or k > len(num):\n            return 0\n        num.sort()\n        uf = UnionFind(len(num))\n        heap = []\n        for i in num:\n            uf.union(i, i)\n            heapq.heappush(heap, (uf.count(i), i))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return heap[:k]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [0 for i in range(n)]\n        self.count = [1 for i in range(n)]\n        self.n = n\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.count[x] < self.count[y]:\n            self.parent[x] = y\n            self.count[y] += self.count[x]\n        else:\n            self.parent[y] = x\n            self.count[x] += self.count[y]\n\n    def find(self, x):\n        while self.parent[x]!= x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]"
    }
  ]
}