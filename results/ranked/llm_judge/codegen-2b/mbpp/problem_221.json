{
  "timestamp": "2025-09-14T19:00:13.731218",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 221,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def get_n_largest(data, n):\n    \"\"\"\n    :type data: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if not data or not n:\n        return []\n    res = []\n    for i in range(n):\n        res.append(data.pop())\n    res.sort(reverse=True)\n    return res\n\n# Your Solution\n# @return a list of length n with the n largest elements from data.\n# Note:\n# You may assume all inputs are non-empty and will not be zero.\n# The total number of elements in data is at most 1000."
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Your code here\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k > len(nums):\n            return []\n        if k == 0:\n            return []\n        nums.sort()\n        ret = [0] * k\n        for i, v in enumerate(nums):\n            ret[i] = v\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            while i < len(nums) - k + 1:\n                if nums[i + k - 1] < nums[i]:\n                    break\n                i += 1\n            if i == len(nums) - k + 1:\n                break\n        return ret\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.topKFrequent([1, 1, 1, 2, 2, 3], 2)\n    print solution.topKFrequent([1, 1, 1, 2, 2, 3, 3, 3], 3)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def getNLargest(self, numItems, numUsers):\n        \"\"\"\n        :type numItems: int\n        :type numUsers: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(numUsers):\n            res.append(0)\n        for i in range(numItems):\n            res.append(i)\n        for i in range(numUsers):\n            res.append(res[i] + 1)\n        res.sort()\n        return res[:numItems]\n\nclass Solution2(object):\n    def getNLargest(self, numItems, numUsers):\n        \"\"\"\n        :type numItems: int\n        :type numUsers: int\n        :rtype: List[int]\n        \"\"\"\n        res = [0] * numUsers\n        for i in range(numUsers):\n            res[i] = 0\n        for i in range(numItems):\n            res[i % numUsers] += 1\n        res.sort()\n        return res[:numItems]"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/nlargest/problem\n\n# TODO\n# - This is a very basic implementation of the algorithm.\n#   It does not take into account the case when the number of\n#   items in the dataset is greater than the number of items\n#   in the n largest items you wish to find.\n\ndef nlargest(n, items):\n    # TODO\n    # - Create a list of the elements in the dataset.\n    # - Create a list of the indices of the elements in the\n    #   dataset.\n    # - Create a list of the indices of the elements in the\n    #   largest items you wish to find.\n    # - Sort the indices of the elements in the dataset.\n    # - Sort the indices of the elements in the largest\n    #   items you wish to find.\n    # - Return the indices of the elements in the largest\n    #   items you wish to find.\n    # - Return the indices of the elements in the dataset.\n    # - Return the number of elements in the dataset.\n    \n    # TODO\n    # - Make sure the number of items is not greater than\n    #   the number of items you wish to find.\n    # - Make sure the number of items is greater than 0.\n    # - Make sure the number of items is less than or equal to\n    #   the number of items in the dataset.\n    # - Create a list of the elements in the dataset.\n    # - Create a list of the indices of the elements in the\n    #   dataset.\n    # - Create a list of the indices of the elements in the\n    #   largest items you wish to find.\n    # - Sort the indices of the elements in the dataset.\n    # - Sort the indices of the elements in the largest\n    #   items you wish to find.\n    # - Return the indices of the elements in the largest\n    #   items you wish to find.\n    # - Return the indices of the elements in the dataset.\n    # - Return the number of elements in the dataset.\n    \n    # TODO\n    # - Return the indices of the elements in the largest\n    #   items you wish to find.\n    # - Return the indices of the elements in"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param a list of integers\n    # @return a list of lists of integers\n    def topKFrequent(self, nums, k):\n        counts = [0] * len(nums)\n        for num in nums:\n            counts[num] += 1\n        sorted_counts = sorted(counts, reverse=True)\n        result = []\n        for index, count in enumerate(sorted_counts[:k]):\n            result.append([nums[index], count])\n        return result\n\nif __name__ == '__main__':\n    nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        dummy = ListNode(0)\n        dummy.next = head\n        p = dummy\n        while p.next:\n            if p.next.next:\n                p = p.next.next\n            else:\n                break\n        while p:\n            if p.next:\n                if p.next.val > p.val:\n                    p = p.next\n                else:\n                    break\n            else:\n                break\n        return dummy.next"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        p = head\n        while p.next:\n            if p.next.next:\n                p = p.next.next\n            else:\n                break\n        \n        res = head\n        while p:\n            if p.val < res.val:\n                res = p\n                p = p.next\n            else:\n                p = p.next\n        \n        return res"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k nums\n        # sort the input nums first, then find the top k"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param a, a list of integers\n    # @param m, an integer\n    # @return an integer\n    def getNLargest(self, a, m):\n        \"\"\"\n        :type a: List[int]\n        :type m: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in range(len(a)):\n            heapq.heappush(heap, (a[i], i))\n        heapq.heapify(heap)\n        \n        ans = []\n        while m > 0:\n            if not heap:\n                break\n            ans.append(heapq.heappop(heap)[1])\n            m -= 1\n        return ans\n\nif __name__ == '__main__':\n    s = Solution()\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    m = 5\n    print(s.getNLargest(a, m))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getLargest(self, head, k):\n        p = head\n        while p:\n            p = p.next\n            if k == 0:\n                break\n            k -= 1\n        if p:\n            q = p\n            while q.next:\n                q = q.next\n            return q\n        return head"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    Return the n largest items from a list.\n    \"\"\"\n\n    return sorted(items, key=items.__getitem__, reverse=True)[:n]\n\n\n# Your Least Recently Used (LRU) class\nclass LRU(object):\n    \"\"\"\n    Implement a first-in-first-out cache.\n    \"\"\"\n\n    def __init__(self, maxsize):\n        \"\"\"\n        Initialize the cache with maxsize capacity.\n        \"\"\"\n        self.maxsize = maxsize\n        self.lru = []\n        self.cache = {}\n\n    def get(self, key):\n        \"\"\"\n        Get an item from cache.\n        \"\"\"\n        if key in self.cache:\n            return self.cache[key]\n\n        else:\n            return None\n\n    def set(self, key, value):\n        \"\"\"\n        Set an item from cache.\n        \"\"\"\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n\n        if len(self.cache) > self.maxsize:\n            self.lru.pop(0)\n            del self.cache[self.lru[-1]]\n\n        self.lru.append(key)\n\n    def __len__(self):\n        return len(self.cache)\n\n    def __contains__(self, key):\n        return key in self.cache\n\n\n# Your LRUCache object.\nclass LRUCache(object):\n    \"\"\"\n    Implement LRU cache with O(1) extra space complexity.\n    \"\"\"\n\n    def __init__(self, capacity):\n        \"\"\"\n        Initialize LRU cache with capacity.\n        \"\"\"\n        self.capacity = capacity\n        self.cache = LRU(capacity)\n\n    def get(self, key):\n        \"\"\"\n        Get an item from cache.\n        \"\"\"\n        return self.cache.get(key)\n\n    def set(self, key, value):\n        \"\"\"\n        Set an item from cache.\n        \"\"\"\n        self.cache.set(key, value)\n\n        while len(self.cache) > self.capacity:\n            self.cache."
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "\"\"\"\nExample\nGiven [1, 2, 3, 4, 5], return [5, 4, 3, 2, 1].\n\"\"\"\n\n\"\"\"\nNote:\nThe returned list must not contain any duplicates.\nThe function executes in O(n) time and uses O(n) extra space.\n\"\"\"\n\n\ndef get_largest_n(n, items):\n    \"\"\"\n    :type n: int\n    :type items: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not items:\n        return []\n    largest = sorted(items)[:n]\n    return largest"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def get_n_largest(items, n):\n    return sorted(items, key=lambda x: x[1], reverse=True)[:n]\n\nif __name__ == '__main__':\n    items = [(1, 5), (2, 10), (3, 15), (4, 20), (5, 25), (6, 30), (7, 35), (8, 40)]\n    n = 5\n    print get_n_largest(items, n)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        heap = [head]\n        while heap:\n            cur = heap.pop()\n            next_heap = []\n            while cur:\n                next_heap.append(cur.next)\n                cur.next = cur.next.next\n            heap.extend(next_heap)\n        return heap[0]"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        \n        return slow"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "import collections\n\ndef get_n_largest(data, n):\n    \"\"\"\n    :type data: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if not data or not n:\n        return []\n\n    if n > len(data):\n        n = len(data)\n\n    n_max_values = collections.Counter(data).most_common(n)\n    return [item[0] for item in n_max_values]\n\n\nif __name__ == '__main__':\n    data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    n = 5\n    print(get_n_largest(data, n))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if head.next is None:\n            return head\n        \n        while head.next:\n            if head.val < head.next.val:\n                head = head.next\n            else:\n                head = head.next.next\n        return head"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getKthNode(self, head, k):\n        cur = head\n        while cur:\n            cur = cur.next\n            if k == 0:\n                return cur\n            k -= 1\n        return cur\n\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getKthNode2(self, head, k):\n        cur = head\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if k == 0:\n                return cur\n            k -= 1\n        if not fast:\n            return slow\n        while cur and cur.next:\n            cur = cur.next\n            fast = fast.next\n            if k == 0:\n                return cur\n            k -= 1\n        return fast\n\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getKthNode3(self, head, k):\n        cur = head\n        while cur:\n            cur = cur.next\n            if k == 0:\n                return cur\n            k -= 1\n        return None\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getLargestN(self, head, k):\n        if not head:\n            return None\n        dic = {}\n        p = head\n        while p:\n            dic[p.val] = p\n            p = p.next\n        \n        sorted_list = []\n        while dic:\n            if len(sorted_list) < k:\n                sorted_list.append(dic.pop(sorted_list[-1].val))\n            else:\n                break\n        \n        return sorted_list[-k:]\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    \n    print Solution().getLargestN(head, 3)\n    \n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next."
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getLargest(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        p = head\n        n = 0\n        while p:\n            p = p.next\n            n += 1\n        \n        p = head\n        while p and n > 0:\n            p = p.next\n            n -= 1\n        \n        if n == 0:\n            return head\n        \n        while p:\n            p = p.next\n            if p.next:\n                p.next = p.next.next\n            else:\n                p.next = None\n        \n        return head"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/nlargest/\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getNLargest(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        p = dummy\n        while p.next:\n            p = p.next\n            if k == 1:\n                return p\n            k -= 1\n        while p.next:\n            p = p.next\n            if k == 1:\n                return p\n            k -= 1\n        while p.next:\n            p = p.next\n            if k == 1:\n                return p\n            k -= 1\n        return p"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def topKFrequent(self, num):\n        dic = {}\n        for i in num:\n            dic[i] = dic.get(i, 0) + 1\n        sorted_dic = sorted(dic.items(), key=lambda x:x[1], reverse=True)\n        return sorted_dic[:k]"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/largest-number-in-an-array/\n\n\nclass Solution(object):\n    def get_largest(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return []\n        elif n == 1:\n            return [arr[0]]\n        else:\n            sorted_arr = sorted(arr)\n            return sorted_arr[:n]\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9,10]\n    sol = Solution()\n    print(sol.get_largest(arr))\n    arr = [1,2,3,4,5,6,7,8,9,10,11,12]\n    sol = Solution()\n    print(sol.get_largest(arr))"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        pivot = head\n        while pivot.next:\n            pivot = pivot.next\n            while pivot.next and pivot.val < pivot.next.val:\n                pivot = pivot.next\n            if pivot.next:\n                pivot = pivot.next\n            else:\n                break\n\n        # if pivot is None, head is the only node in the list\n        if pivot is None:\n            return head\n\n        # move pivot to the head\n        pivot.next = head\n        return pivot\n\n    def getLargest2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        pivot = head\n        while pivot.next:\n            pivot = pivot.next\n            while pivot.next and pivot.val < pivot.next.val:\n                pivot = pivot.next\n            if pivot.next:\n                pivot = pivot.next\n            else:\n                break\n\n        # if pivot is None, head is the only node in the list\n        if pivot is None:\n            return head\n\n        # move pivot to the head\n        pivot.next = None\n        return pivot"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        \n        p1 = head\n        p2 = head\n        while p2:\n            p1 = p1.next\n            p2 = p2.next\n        \n        smaller_list = p1\n        larger_list = p2\n        \n        while p1:\n            p1 = p1.next\n            if p1:\n                p1 = p1.next\n            else:\n                break\n        \n        while p2:\n            p2 = p2.next\n            if p2:\n                p2 = p2.next\n            else:\n                break\n        \n        smaller_list = smaller_list.next\n        larger_list = larger_list.next\n        \n        while p1 and p2:\n            if p1.val > p2.val:\n                smaller_list = p1\n                p1 = p1.next\n            else:\n                larger_list = p2\n                p2 = p2.next\n        \n        larger_list.next = p1\n        return smaller_list"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "\"\"\"\nExample:\n\nInput:\n[\n    [1,2,3,4,5],\n    [3,2,1,5,4],\n    [2,2,3,1,5],\n    [1,2,2,3,5]\n]\n\nOutput:\n[\n    [1,2,3,4,5],\n    [3,2,1,5,4],\n    [2,2,3,1,5]\n]\n\"\"\"\n\n\nclass Solution(object):\n    def getLargest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        n = len(nums)\n        ans = nums[0]\n        for i in range(1, n):\n            if nums[i] > ans:\n                ans = nums[i]\n        return [ans] + self.getLargest(nums[i + 1:])\n\n\nif __name__ == '__main__':\n    so = Solution()\n    print(so.getLargest([1, 2, 3, 4, 5]))"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "def get_n_largest(dataset, n):\n    \"\"\"\n    :type dataset: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(len(dataset)):\n        result.append(dataset[i])\n        if len(result) == n:\n            return result\n    return result\n\n# Your Codec object will be instantiated and called as such:\n# obj = Codec()\n# param_1 = obj.decode(codec_input)\n# param_2 = obj.encode(codec_input)"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        n = 0\n        while head:\n            n += 1\n            head = head.next\n        head = ListNode(-1)\n        head.next = head\n        \n        p = head.next\n        for i in range(n):\n            p = p.next\n        \n        while head.next:\n            if head.next.next:\n                p = head.next\n                while p.next and p.next.next:\n                    p = p.next\n                    head.next = p.next\n            else:\n                head.next = None\n        return head.next\n    \n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    print s.getLargest(head)"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return a list of lists\n    def getLargest(self, num):\n        if not num:\n            return []\n        max_len = 0\n        max_num = []\n        for i in range(len(num)):\n            if max_len < len(num[i]):\n                max_len = len(num[i])\n                max_num = num[i]\n        return max_num\n\n    # @param num, a list of integers\n    # @return a list of lists\n    def getLargest2(self, num):\n        if not num:\n            return []\n        max_len = 0\n        max_num = []\n        for i in range(len(num)):\n            if max_len < len(num[i]):\n                max_len = len(num[i])\n                max_num = num[i]\n        return max_num[:max_len]\n\n    # @param num, a list of integers\n    # @return a list of lists\n    def getLargest3(self, num):\n        if not num:\n            return []\n        max_len = 0\n        max_num = []\n        for i in range(len(num)):\n            if max_len < len(num[i]):\n                max_len = len(num[i])\n                max_num = num[i]\n        return max_num[:max_len]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.getLargest([1, 2, 3, 4, 5])\n    print s.getLargest([1, 2, 3, 4, 5])\n    print s.getLargest([1, 2, 3, 4, 5, 6])\n    print s.getLargest([1, 2, 3, 4, 5, 6, 7])"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/top-k-frequent-elements/discuss/108847/Python-implementation-using-a-map-and-a-priority-queue\n# https://leetcode.com/problems/top-k-frequent-elements/discuss/125093/Python-implementation-using-a-map-and-a-priority-queue\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        result = []\n        # count the frequency of each item\n        count = {}\n        for n in nums:\n            if n in count:\n                count[n] += 1\n            else:\n                count[n] = 1\n        # build a map for counting\n        map = {}\n        for n in count:\n            map[n] = map.get(n, 0) + 1\n        # build a priority queue\n        pq = []\n        for n in count:\n            pq.append((count[n], n))\n        pq.sort()\n        # get top k items\n        for _ in range(k):\n            result.append(pq.popleft()[1])\n        return result"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def getIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        ans = []\n        for i in xrange(len(intervals)):\n            if i == 0:\n                ans.append(intervals[i])\n            else:\n                ans.append(Interval(max(ans[-1].start, intervals[i].start), min(ans[-1].end, intervals[i].end)))\n        return ans"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def getLargest(self, root: TreeNode) -> TreeNode:\n        ans = None\n        while root:\n            if not ans or ans.val < root.val:\n                ans = root\n            root = root.left\n        return ans"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def getNLargest(self, num, k):\n        \"\"\"\n        :type num: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        from heapq import nlargest\n        res = []\n        heap = []\n        for i in range(num):\n            heap.append((i, i))\n        for i in range(num):\n            res.append(heap[0][1])\n            heapq.heapify(heap)\n            while len(heap) > k:\n                heap[0][1] = heapq.heappop(heap)[1]\n                res.append(heap[0][1])\n        return res\n\n\nif __name__ == \"__main__\":\n    print Solution().getNLargest(3, 3)\n    print Solution().getNLargest(3, 4)\n    print Solution().getNLargest(3, 1)"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "\"\"\"\n>>> get_n_largest(1, [1, 2, 3])\n[1]\n\n>>> get_n_largest(2, [1, 2, 3, 4, 5])\n[1, 5]\n\n>>> get_n_largest(2, [1, 2, 3, 4, 5, 6])\n[1, 2, 5]\n\"\"\"\n\ndef get_n_largest(n, a):\n    sorted_a = sorted(a)\n    return sorted_a[-n:]"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/largest-n-items-in-a-sorted-dataset\n\ndef get_n_largest(n):\n    \"\"\"\n    :param n: The number of items to get.\n    :return: The n largest items.\n    \"\"\"\n\n    # Initialize a list to store the largest items.\n    largest_items = []\n\n    # Iterate through the list of items and add each item to the list.\n    for i in range(len(items)):\n        # Check if the item is already in the list, if so, remove it.\n        if i not in largest_items:\n            # Add the item to the list if it is not already there.\n            largest_items.append(items[i])\n\n        # If the item is the largest in the list, remove it.\n        if items[i] == largest_items[-1]:\n            largest_items.pop()\n\n    # Return the list of n largest items.\n    return largest_items[:n]\n\n\ndef main():\n    \"\"\"\n    The main function.\n    \"\"\"\n\n    # Read the input.\n    items, n = map(int, input().split())\n\n    # Call the function.\n    print(get_n_largest(n))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "def get_n_largest(dataset, n):\n    \"\"\"\n    :type dataset: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if not isinstance(dataset, list):\n        dataset = list(dataset)\n    return sorted(dataset, key=lambda x: x, reverse=True)[:n]\n\n\nclass Solution(object):\n    def getLargest(self, dataset):\n        \"\"\"\n        :type dataset: List[int]\n        :rtype: int\n        \"\"\"\n        return get_n_largest(dataset, 1)[0]"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        \n        # find the first node\n        node = head\n        while node.next:\n            node = node.next\n        \n        # get the first node\n        first = node\n        \n        # get the last node\n        node = head\n        while node.next:\n            node = node.next\n        last = node\n        \n        # get the first node\n        node = head\n        while node.next:\n            node = node.next\n        first = node\n        \n        # get the last node\n        node = head\n        while node.next:\n            node = node.next\n        last = node\n        \n        # get the last node\n        node = head\n        while node.next:\n            node = node.next\n        last = node\n        \n        # sort\n        node = first\n        while node.next:\n            if node.next.val > last.val:\n                last.next = node.next\n                node.next = node.next.next\n            else:\n                node = node.next\n        last.next = node.next\n        \n        # get the last node\n        node = first\n        while node.next:\n            node = node.next\n        last = node\n        \n        # get the first node\n        node = first\n        while node.next:\n            node = node.next\n        first = node\n        \n        # get the last node\n        node = last\n        while node.next:\n            node = node.next\n        last = node\n        \n        # get the first node\n        node = first\n        while node.next:\n            node = node.next\n        first = node\n        \n        # get the last node\n        node = last\n        while node.next:\n            node = node.next\n        last = node\n        \n        # get the first node"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# https://oj.leetcode.com/problems/k-largest-element-in-a-sorted-matrix/\n# Given a matrix of m x n elements (m rows, n columns), return the k largest elements in the matrix.\n#\n# Note:\n# You may assume k is always small enough, and there is no duplicates in the input data set.\n#\n# Follow up:\n# What if the number of elements n is very large? How would you optimize your algorithm?\n#\n# For example,\n# Given a matrix of n = 5, m = 7,\n#\n# [\n#   [ 1, 1, 1, 1, 1 ],\n#   [ 1, 2, 3, 4, 5 ],\n#   [ 1, 3, 2, 3, 4 ],\n#   [ 1, 4, 3, 2, 3 ],\n#   [ 1, 4, 3, 2, 3 ]\n# ]\n#\n# For k = 3, you should return [1, 3, 4].\n# For k = 5, return [1, 1, 1, 2, 3].\n\nclass Solution(object):\n    def getKLargest(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k > mat[0]:\n            return []\n        if k == mat[0]:\n            return mat[0]\n        ret = []\n        ret.append(mat[0][0])\n        for i in xrange(1, mat[0][0]):\n            ret.append(max(ret[0], mat[0][i]))\n        for i in xrange(1, len(mat)):\n            ret.append(max(ret[-1], mat[i][0]))\n            for j in xrange(1, mat[i][0]):\n                if ret[j] < mat[i][j]:\n                    ret[j] = mat[i][j]\n        ret.sort()\n        return ret[-k:]"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param k, an integer\n\t# @return a ListNode\n\tdef getKthLargest(self, head, k):\n\t\t# write your code here\n\t\tif head == None:\n\t\t\treturn head\n\t\tif head.next == None:\n\t\t\tif k == 1:\n\t\t\t\treturn head\n\t\t\telse:\n\t\t\t\treturn head.val\n\t\tnode = head\n\t\twhile node.next!= None and node.next.next!= None:\n\t\t\tnode = node.next\n\t\tnode = node.next\n\t\tif k == 1:\n\t\t\treturn node\n\t\tnode = node.next\n\t\twhile k > 0:\n\t\t\tnode = node.next\n\t\t\tk -= 1\n\t\treturn node\n\t\t\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef getKthLargest2(self, head, k):\n\t\tif head == None or head.next == None:\n\t\t\treturn head\n\t\tif k == 1:\n\t\t\treturn head\n\t\tnode = head\n\t\twhile k > 0 and node!= None:\n\t\t\tnode = node.next\n\t\t\tk -= 1\n\t\tif node == None:\n\t\t\treturn head\n\t\tnode = node.next\n\t\twhile k > 0:\n\t\t\tnode = node.next\n\t\t\tk -= 1\n\t\treturn node\n\t\n\t# @param head, a ListNode\n\t# @param k, an integer\n\t# @return a ListNode\n\tdef getKthLargest3(self, head, k):\n\t\tif head == None or head.next == None:\n\t\t\treturn head\n\t\tif k == 1:\n\t\t\treturn head\n\t\tnode = head\n\t\twhile k > 0 and node.next!= None:\n\t\t\tnode = node.next\n\t\t\tk -= 1\n\t\tif k == 1:\n\t\t\treturn node\n\t\tnode = node.next\n\t\twhile k > 0:\n\t\t\tnode = node.next\n\t\t\tk -= 1\n\t\treturn node\n\t\t\n\nif __name__ == \"__main__\":\n\thead = ListNode"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getLargest(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        current = head\n        while current.next:\n            next = current.next\n            if next.val > current.val:\n                current.next = next.next\n            else:\n                current = next\n        return current"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if len(items) == 0:\n        return []\n\n    # The solution is to sort the dataset, then get the first n elements\n    # and then reverse the list.\n    sorted_items = sorted(items)\n    result = sorted_items[:n]\n    result.reverse()\n    return result\n\n\ndef test():\n    assert get_n_largest([1, 3, 2, 4, 5, 4, 3, 2, 1], 3) == [4, 5, 3]\n    assert get_n_largest([2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [3, 4, 5, 6, 7]\n    assert get_n_largest([], 0) == []\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "def nlargest(n, items):\n    \"\"\"\n    Write a function to get the n largest items from a dataset.\n\n    >>> nlargest(2, [10, 9, 2, 5, 3, 7])\n    [10, 9]\n    >>> nlargest(3, [10, 9, 2, 5, 3, 7])\n    [10, 9, 2]\n    >>> nlargest(4, [10, 9, 2, 5, 3, 7])\n    [10, 9, 2, 5]\n    \"\"\"\n    # write your code here\n    if len(items) <= n:\n        return items\n\n    d = sorted(items, key=lambda x: x, reverse=True)\n    return d[:n]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def getNlargest(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not k:\n            return head\n\n        p = head\n        p_prev = None\n        while p:\n            p_prev = p\n            p = p.next\n        p = head\n        while k > 0:\n            p = p.next\n            k -= 1\n\n        while p_prev:\n            p_prev = p_prev.next\n            p = p_prev.next\n        head = p\n        p = head\n        while p:\n            p = p.next\n            p_prev = p_prev.next\n        p = p_prev.next\n        head = p\n        p = head\n        while p:\n            p = p.next\n            p_prev = p_prev.next\n        p_prev.next = None\n        p = head\n        while p:\n            p = p.next\n            p_prev = p_prev.next\n        p_prev.next = None\n\n        return head"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def getLargest(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n    \n    def getLargestList(self, head):\n        if not head:\n            return None\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n        return slow.val"
    },
    {
      "rank": 45,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Get the end node of the list\n        end = head\n        while end.next!= None:\n            end = end.next\n        # Sort the list\n        end.next = None\n        head = self.sort(head)\n        # Get the n largest elements\n        ret = []\n        end = head\n        while end.next!= None and len(ret) < n:\n            end = end.next\n            ret.append(end.val)\n        return ret[-n:]\n\n    def sort(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Get the end node of the list\n        end = head\n        while end.next!= None:\n            end = end.next\n        # Sort the list\n        end.next = None\n        head = self.sortList(head)\n        return head\n\n    def sortList(self, head):\n        # If head is empty or it is a single node, return head\n        if head == None or head.next == None:\n            return head\n        # Get the middle node\n        middle = head\n        while middle.next!= None:\n            middle = middle.next\n        # Reverse the list\n        reverseList(middle)\n        # Get the end node of the list\n        end = head\n        while end.next!= None:\n            end = end.next\n        # Merge the list\n        end.next = None\n        head = self.mergeList(head, middle)\n        return head\n\n    def mergeList(self, head, middle):\n        # If head is empty or it is a single node, return head\n        if head == None or head.next == None:\n            return head\n        # If middle is empty or it is a single node, return head\n        if middle == None or middle.next == None:\n            return head\n        # If"
    },
    {
      "rank": 46,
      "score": 9.0,
      "candidate": "def get_n_largest(dataset, n):\n    \"\"\"\n    dataset: A list of integers\n    n: The number of items you want to get.\n    return: A list of integers.\n    \"\"\"\n    if len(dataset) < n:\n        return []\n\n    data_sorted = sorted(dataset)\n    result = data_sorted[:n]\n\n    return result"
    },
    {
      "rank": 47,
      "score": 9.0,
      "candidate": "import random\n\ndef get_n_largest_items(data_set, n):\n    # write your code here\n    if not isinstance(data_set, list):\n        data_set = list(data_set)\n    \n    # Sort the data_set\n    data_set.sort(key=lambda x:x[0])\n    \n    # Get the n largest items\n    return data_set[:n]\n\ndef get_n_largest_items_with_random(data_set, n):\n    # write your code here\n    if not isinstance(data_set, list):\n        data_set = list(data_set)\n    \n    # Sort the data_set\n    data_set.sort(key=lambda x:x[0])\n    \n    # Get the n largest items\n    return random.sample(data_set, n)\n\nif __name__ == \"__main__\":\n    data_set = [\n        (1, 3),\n        (2, 5),\n        (4, 8),\n        (3, 6)\n    ]\n    \n    print get_n_largest_items(data_set, 3)\n    print get_n_largest_items_with_random(data_set, 3)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    Get the n largest items from a list of items.\n\n    :param items: The items to sort\n    :param n: The number of items to return\n    :return: The n largest items from the list\n    \"\"\"\n    heap = []\n    for item in items:\n        heap.append((item, 0))\n    heapq.heapify(heap)\n    result = []\n    while len(heap) > n:\n        result.append(heap.pop(0)[0])\n        heapq.heapify(heap)\n    return result\n\nif __name__ == '__main__':\n    items = [10, 8, 6, 4, 1, 3, 2, 9, 7]\n    print(get_n_largest(items, 4))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    sorted_items = sorted(items)\n    return sorted_items[-n:]\n\nif __name__ == \"__main__\":\n    print(get_n_largest([1, 3, 6, 5, 3, 2, 4, 7, 5, 8], 3))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "import collections\n\ndef get_n_largest(n, items):\n    \"\"\"\n    :type n: int\n    :type items: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = collections.deque(items, n)\n    heap.extend([None] * (n - len(heap)))\n    return heap"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/n-largest-items/\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # heap = []\n        # result = []\n        # for i in range(len(nums)):\n        #     heap.append((nums[i], i))\n        #     while len(heap) > k:\n        #         min_heap_item = heap.pop()\n        #         if min_heap_item[1] == len(nums) - 1:\n        #             result.append(min_heap_item[0])\n        #             break\n        #         else:\n        #             heap.append((nums[min_heap_item[1]], min_heap_item[1]))\n        # return result\n        # use min heap\n        heap = []\n        result = []\n        for i in range(len(nums)):\n            heap.append((nums[i], i))\n            while len(heap) > k:\n                min_heap_item = heap.pop()\n                if min_heap_item[1] == len(nums) - 1:\n                    result.append(min_heap_item[0])\n                    break\n                else:\n                    heap.append((nums[min_heap_item[1]], min_heap_item[1]))\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().topKFrequent([3, 2, 4, 1, 3], 2) == [3, 4]\n    assert Solution().topKFrequent([3, 2, 4, 1, 3], 3) == [3, 2, 4]\n    assert Solution().topKFrequent([3, 2, 4, 1, 3], 4) == [3, 2, 4, 1]"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def get_n_largest(dataset, n):\n    \"\"\"\n    :type dataset: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if n < 1 or len(dataset) < n:\n        return []\n\n    sorted_dataset = sorted(dataset)\n    result = sorted_dataset[:n]\n    result.reverse()\n    return result\n\nif __name__ == \"__main__\":\n    dataset = [1, 2, 3, 4, 5]\n    print(get_n_largest(dataset, 3))\n    print(get_n_largest(dataset, 6))\n    print(get_n_largest(dataset, 5))\n    print(get_n_largest(dataset, 10))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "# Definition for an item.\nclass Item:\n    def __init__(self, id, timestamp, description):\n        self.id = id\n        self.timestamp = timestamp\n        self.description = description\n\nclass Solution(object):\n    def topN(self, items, n):\n        \"\"\"\n        :type items: List[Item]\n        :type n: int\n        :rtype: List[Item]\n        \"\"\"\n        heap = []\n        for item in items:\n            heap.append((item.timestamp, item))\n        heap.sort(reverse=True)\n        result = []\n        while len(heap) >= n:\n            result.append(heap.pop(0)[1])\n        return result"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def get_n_largest(n, items):\n    \"\"\"\n    :type n: int\n    :type items: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Write your code here\n    return sorted(items, reverse=True)[:n]\n\nif __name__ == '__main__':\n    assert get_n_largest(2, [1, 5, 6, -3, 0, 2, 2, 2]) == [-3, 2, 2, 2, 2, 2, 2, 0]\n    assert get_n_largest(3, [1, 5, 6, -3, 0, 2, 2, 2]) == [-3, 2, 2, 2, 2, 2, 0, 2]"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "import random\nimport time\n\nclass Solution(object):\n    def getLargest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        n = len(nums)\n        for i in range(n):\n            sorted_nums = sorted(nums)\n            result.append(sorted_nums[i])\n            nums[i] = sorted_nums[n - i - 1]\n        return result\n\nif __name__ == '__main__':\n    start_time = time.time()\n    print Solution().getLargest([3, 1, 4, 2, 5])\n    print Solution().getLargest([3, 1, 4, 2, 5])\n    print Solution().getLargest([3, 1, 4, 2, 5])\n    print time.time() - start_time"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        list = []\n        cur = head\n        while cur:\n            list.append(cur.val)\n            cur = cur.next\n        list.sort(reverse=True)\n        return head if len(list) == 0 else list[0]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    print solution.getLargest(head)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n\nclass Solution:\n    def getLargest(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: List[Point]\n        \"\"\"\n        heap = []\n        for point in points:\n            heapq.heappush(heap, (point.x, point.y, point))\n        ans = []\n        for _ in range(len(points)):\n            ans.append(heapq.heappop(heap)[2])\n        return ans\n\n\nif __name__ == \"__main__\":\n    points = [Point(x, y) for x, y in [(1, 1), (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 3), (3, 4)]]\n    print Solution().getLargest(points)"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/top-k-frequent-elements/\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n\n        for num in count:\n            if count[num] > k:\n                ans.append(num)\n                count[num] -= 1\n                if count[num] == 0:\n                    del count[num]\n\n        return ans\n\ns = Solution()\nprint s.topKFrequent([1,1,2,2,3,3,3], 2)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 2)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 4)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 5)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 6)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 7)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 8)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 9)\nprint s.topKFrequent([1,1,2,2,3,3,3,4,5], 10)"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        result = []\n        for key, value in counts.most_common():\n            result.append(value)\n            if len(result) == k:\n                break\n        return result"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "def get_n_largest(n, dataset):\n    \"\"\"\n    dataset is a list of lists, each element is a list of items\n    Return the n largest items from a dataset.\n    \"\"\"\n    ret = []\n    for item in dataset:\n        ret.append(item[0])\n        if len(ret) == n:\n            break\n    return ret\n\ndef get_n_largest_recur(n, dataset):\n    \"\"\"\n    dataset is a list of lists, each element is a list of items\n    Return the n largest items from a dataset.\n    \"\"\"\n    if len(dataset) == 0:\n        return []\n    if len(dataset) == 1:\n        return [dataset[0][0]]\n    else:\n        return get_n_largest_recur(n, get_n_largest(n, dataset)) + \\\n               get_n_largest_recur(n, get_n_largest(n, dataset[:-1]))"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for item in items:\n        heap.append((-item, item, len(heap)))\n    heap.sort()\n    heap = heap[-n:]\n    return heap\n\nif __name__ == '__main__':\n    print(get_n_largest([3, 1, 2, 5, 6, 7], 3))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import random\n\nclass Solution:\n    \"\"\"\n    @param nums: The integer array\n    @param k: As description\n    @return: The resutling largest items\n    \"\"\"\n    def getLargest(self, nums, k):\n        if not nums or k == 0:\n            return []\n        n = len(nums)\n        p = [0] * n\n        for i in range(n):\n            p[i] = i\n        \n        while n > k:\n            p = self.getMaxIndex(p, nums)\n            n -= 1\n        return nums[p[:k]]\n\n    def getMaxIndex(self, p, nums):\n        if not nums:\n            return []\n        \n        n = len(p)\n        for i in range(n):\n            if p[i] == n - 1:\n                continue\n            j = p[i] + 1\n            while j < n and nums[j] > nums[p[i]]:\n                p[i] = j\n                j += 1\n        return p\n\n# Test\nnums = [3, 2, 1, 6, 0]\nk = 4\nob = Solution()\nprint(ob.getLargest(nums, k))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from random import shuffle\n\ndef get_nlargest(items, n):\n    \"\"\"\n    Write a function that returns the n largest items in the list\n    items. The items should be in random order.\n    \"\"\"\n    shuffle(items)\n    return items[:n]\n\ndef test():\n    assert get_nlargest(items=[1,2,3,4,5], n=1) == [1]\n    assert get_nlargest(items=[1,2,3,4,5], n=2) == [1,2]\n    assert get_nlargest(items=[1,2,3,4,5], n=3) == [1,2,3]\n    assert get_nlargest(items=[1,2,3,4,5], n=4) == [1,2,3,4]\n    assert get_nlargest(items=[1,2,3,4,5], n=5) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=6) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=7) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=8) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=9) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=10) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=11) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=12) == [1,2,3,4,5]\n    assert get_nlargest(items=[1,2,3,4,5], n=13) == [1,2,3"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "import heapq\n\ndef get_n_largest(n, data):\n    \"\"\"\n    :type n: int\n    :type data: List[int]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    heapq.heapify(heap)\n    for item in data:\n        heapq.heappush(heap, item)\n        if len(heap) == n:\n            heapq.heappop(heap)\n        if len(heap) == 0:\n            break\n    return heap[:n]\n\nif __name__ == '__main__':\n    n = 3\n    data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print get_n_largest(n, data)"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef get_n_largest(dataset, n):\n    \"\"\"\n    :type dataset: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    if len(dataset) < n:\n        return []\n    queue = deque(sorted(dataset))\n    res = []\n    while queue:\n        res.append(queue.popleft())\n        if len(res) == n:\n            break\n    return res"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "\"\"\"\ndata = [1, 2, 3, 4, 5, 6, 7]\n\"\"\"\n\n# Your code here\n\ndef get_n_largest(n, data):\n    sorted_data = sorted(data)\n    return sorted_data[-n:]\n\ndef test_get_n_largest():\n    assert get_n_largest(3,[1,2,3]) == [1,2,3]\n    assert get_n_largest(5,[1,2,3]) == [1,2,3,1,2]\n    assert get_n_largest(6,[1,2,3]) == [1,2,3,1,2,3]\n    assert get_n_largest(7,[1,2,3]) == [1,2,3,1,2,3,1]\n\nif __name__ == \"__main__\":\n    test_get_n_largest()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # use a stack to keep track of the size of the largest element\n        # we can just use a stack to keep track of the largest element\n        # as we need to pop off the stack to get the new largest element\n        # and then push it back on the stack when we get the next largest element\n        stack = []\n        curr = head\n        while curr:\n            curr = curr.next\n            stack.append(curr)\n        largest = curr\n        while len(stack) > 0:\n            # pop off the stack and get the largest element\n            largest = stack.pop()\n            # print stack\n            # print largest\n            # print largest.val\n            # print largest.next\n            # print largest.next.val\n            # print largest.next.next\n            # print largest.next.next.val\n            # print largest.next.next.next\n            # print largest.next.next.next.val\n            # print largest.next.next.next.next\n            # print largest.next.next.next.next.val\n            # print largest.next.next.next.next.next\n            # print largest.next.next.next.next.next.val\n            # print largest.next.next.next.next.next.next\n            # print largest.next.next.next.next.next.next.val\n            # print largest.next.next.next.next.next.next.next\n            # print largest.next.next.next.next.next.next.next.val\n            # print largest.next.next.next.next.next.next.next.next\n            # print largest.next.next.next.next.next.next.next.next.val\n            # print largest.next.next.next.next.next.next.next.next.next\n            # print largest.next.next.next"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "import collections\n\ndef get_nlargest(items, n):\n    \"\"\"\n    Write a function get_nlargest that takes a list of items and a number\n    of items to return and returns the n largest items.\n    \"\"\"\n    # Create a dictionary of the items.\n    d = collections.OrderedDict(sorted(items))\n    # Create a list of the keys.\n    keys = d.keys()\n    # Create a list of the values.\n    values = d.values()\n    # Create a list of the indices of the keys in the values list.\n    indices = [i for i, val in enumerate(values) for key in val]\n    # Create a list of the keys in the values list.\n    keys_in_values = [key for val in values for key in val]\n    # Create a list of the values in the values list.\n    values_in_values = [val for val in values]\n    # Create a list of the indices in the values list.\n    indices_in_values = [i for val in values for i in val]\n    # Create a list of the indices in the values list.\n    indices_in_keys = [i for val in values for i in val]\n    # Create a list of the indices of the keys in the indices list.\n    indices_in_indices = [i for i, val in enumerate(indices) for key in val]\n    # Create a list of the keys in the indices list.\n    keys_in_indices = [key for val in indices for key in val]\n    # Create a list of the values in the indices list.\n    values_in_indices = [val for val in indices]\n    # Create a list of the indices of the keys in the values list.\n    indices_in_values = [i for val in values for i in val]\n    # Create a list of the values in the indices list.\n    values_in_indices = [val for val in indices]\n    # Create a list of the indices of the keys in the values list.\n    indices_in_values = [i for val in values for i in val]\n    # Create a list of the keys in the indices list.\n    keys"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import sys\nimport time\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # check if nums is empty\n        if not nums:\n            return []\n\n        # check if k is invalid\n        if k > len(nums):\n            k = len(nums)\n        \n        # create a dictionary for mapping numbers to their frequency\n        freq_dic = {}\n        for i in nums:\n            if i not in freq_dic:\n                freq_dic[i] = 1\n            else:\n                freq_dic[i] += 1\n\n        # sort dictionary by frequency\n        freq_dic = sorted(freq_dic.items(), key=lambda x: x[1], reverse=True)\n\n        # create a list for top k\n        top_k = []\n        for i in range(k):\n            top_k.append(freq_dic[0][0])\n            del freq_dic[0]\n\n        # create a list to store the top k\n        result = []\n        for i in range(len(nums)):\n            if nums[i] in top_k:\n                result.append(nums[i])\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1,1,1,2,2,3]\n    k = 2\n    start = time.clock()\n    print s.topKFrequent(nums, k)\n    end = time.clock()\n    print 'Time elapsed: {0:.6f}'.format(end - start)"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def get_n_largest(n, data):\n    \"\"\"\n    data: list of lists\n    n: int\n    return: list of lists\n    \"\"\"\n    return sorted(data, key=lambda x: x[-1], reverse=True)[:n]\n\ndef get_n_largest_2(n, data):\n    \"\"\"\n    data: list of lists\n    n: int\n    return: list of lists\n    \"\"\"\n    return sorted(data, key=lambda x: x[-1], reverse=True)[:n]\n\ndef get_n_largest_3(n, data):\n    \"\"\"\n    data: list of lists\n    n: int\n    return: list of lists\n    \"\"\"\n    return sorted(data, key=lambda x: x[-1], reverse=True)[:n]\n\nif __name__ == '__main__':\n    data = [\n            [1,3,4],\n            [2,3,5],\n            [3,4,5],\n            [4,5,6],\n            [5,6,7],\n            [6,7,8],\n            [7,8,9],\n            [8,9,10],\n            [9,10,11],\n            [10,11,12],\n            [11,12,13],\n            [12,13,14],\n            [13,14,15],\n            [14,15,16],\n            [15,16,17],\n            [16,17,18],\n            [17,18,19],\n            [18,19,20],\n            [19,20,21],\n            [20,21,22],\n            [21,22,23],\n            [22,23,24],\n            [23,24,25],\n            [24,25,26],\n            [25,26,27],\n            [26,27,28],\n            [27,28,29],\n            [28,29,30],\n            [29,30,31],\n            [30,31,32],\n            [31,32,33],\n            [32,33,34],\n            [33,34,35],\n            [34,35,36],"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport random\n\ndef get_n_largest_items(items, n):\n    c = Counter(items)\n    return [k for k, v in c.most_common(n) if v]\n\n\n\ndef test():\n    items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    n = 4\n    print get_n_largest_items(items, n)\n\n\nif __name__ == \"__main__\":\n    test()"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getLargest(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        l = []\n        while head:\n            l.append(head.val)\n            head = head.next\n        \n        l.sort()\n        \n        for i in range(len(l)):\n            l[i] = l[i].val\n        \n        return ListNode(l[-1])"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @param k, the size of subset\n    # @return a list of integer\n    def getLargestN(self, num, k):\n        return sorted(num, reverse=True)[:k]"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "def top_n(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    # Your Code Here\n    nums = sorted(items, reverse=True)\n    return [nums[i] for i in range(n)]\n\n\nif __name__ == '__main__':\n    nums = [3, 2, 5, 6, 1, 4]\n    print(top_n(nums, 3))"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "def get_nlargest(items, n):\n    \"\"\"\n    Write a function to get the n largest items from a dataset.\n    \"\"\"\n    result = []\n    for i in range(n):\n        result.append(items[0])\n        items.remove(items[0])\n    for item in items:\n        result.append(item)\n    return result\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Sample Input\n    {1,2,3,4,5,6}\n    Sample Output\n    [5,6,4,3,2,1]\n    \"\"\"\n    items = [1,2,3,4,5,6]\n    n = 5\n    print get_nlargest(items, n)"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "import random\n\n# You can use a dictionary to store the largest items in the dataset\n# and use it to get the n largest items.\n\ndef get_largest_items(dataset):\n    largest_items = []\n    for item in dataset:\n        if item not in largest_items:\n            largest_items.append(item)\n            if len(largest_items) == 10:\n                break\n    return largest_items\n\n# Your function will be called like this:\n# input = [[1,2,3],[4,5,6],[7,8,9]]\n# largest_items = get_largest_items(input)\n# print largest_items\n# >>> [4, 5, 6]\n# >>> [7, 8, 9]\n\nif __name__ == \"__main__\":\n    dataset = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n    largest_items = get_largest_items(dataset)\n    print largest_items"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport random\n\n\ndef get_n_largest(dataset, n):\n    \"\"\"\n    :type dataset: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    counter = Counter(dataset)\n    return sorted(counter.most_common(n))\n\n\ndef main():\n    dataset = [1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n    print(get_n_largest(dataset, 5))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, (num, k))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return [num for _, k in heap]"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getLargest(self, head, k):\n        if not head or not k:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        p = dummy\n        for i in range(k):\n            p = p.next\n        \n        q = dummy\n        while p:\n            p = p.next\n            q = q.next\n            \n        tail = dummy.next\n        dummy.next = None\n        \n        return q.next"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "import random\n\ndef get_n_largest(n, dataset):\n    \"\"\"\n    :type n: int\n    :type dataset: List[int]\n    :rtype: List[int]\n    \"\"\"\n    sorted_dataset = sorted(dataset, reverse=True)\n    return sorted_dataset[:n]\n\ndef get_n_largest_random(n, dataset):\n    \"\"\"\n    :type n: int\n    :type dataset: List[int]\n    :rtype: List[int]\n    \"\"\"\n    random.shuffle(dataset)\n    return dataset[:n]\n\ndef main():\n    print(get_n_largest(3, [3, 2, 1, 4, 5]))\n    print(get_n_largest_random(3, [3, 2, 1, 4, 5]))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Point(%d, %d)\" % (self.x, self.y)\n\nclass Solution:\n    def getLargestPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: List[Point]\n        \"\"\"\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (point.y, point))\n        \n        for i in range(len(points)):\n            heapq.heappop(max_heap)\n            yield max_heap[0][1]"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "from collections import Counter\n\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        c = Counter(nums)\n        c.most_common(k)\n        return [x[0] for x in c.most_common(k)]"
    },
    {
      "rank": 83,
      "score": 1.5,
      "candidate": "import random\n\ndef get_nlargest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for i in range(0, n):\n        res.append(random.choice(items))\n    res.sort()\n    return res\n\n\nif __name__ == '__main__':\n    items = [1, 3, 2, 2, 3, 1, 1]\n    print get_nlargest(items, 3)"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n\"\"\"\n@version: 0.1\n@author: nightwing\n@contact: bszdm2008@163.com\n@site: http://www.itcast.com/\n@software: PyCharm\n@time: 2017/5/14 \u4e0b\u53483:42\n\"\"\"\n\nimport collections\n\nclass Solution(object):\n    def getLargest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort(reverse=True)\n        return nums\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [4, 3, 2, 1, 5]\n    print(s.getLargest(nums))\n    nums = [4, 3, 2, 1, 5, 6]\n    print(s.getLargest(nums))\n    nums = [3, 1, 2, 4, 5, 6]\n    print(s.getLargest(nums))\n    nums = [3, 1, 2, 4, 5, 6, 7]\n    print(s.getLargest(nums))\n    nums = [3, 1, 2, 4, 5, 6, 7, 8]\n    print(s.getLargest(nums))\n    nums = [3, 1, 2, 4, 5, 6, 7, 8, 9]\n    print(s.getLargest(nums))\n    nums = [3, 1, 2, 4, 5, 6, 7, 8, 9, 10]\n    print(s.getLargest(nums))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def largestValues(self, root: TreeNode, k: int) -> List[int]:\n        \"\"\"\n        O(n)\n        \"\"\"\n        def largest(node, nums, k, res):\n            if node is None:\n                return\n            if nums[node.val] < k:\n                nums[node.val] = k\n                largest(node.left, nums, k, res)\n                largest(node.right, nums, k, res)\n            else:\n                res.append(node.val)\n                largest(node.left, nums, k, res)\n                largest(node.right, nums, k, res)\n\n        res = []\n        largest(root, [], k, res)\n        return res\n\nif __name__ == '__main__':\n    sol = Solution()\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.right = TreeNode(6)\n    root.right.left = TreeNode(7)\n    print(sol.largestValues(root, 2))"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Definition for an item.\nclass Item:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def topKFrequent(self, items, k):\n        \"\"\"\n        :type items: List[Item]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # Write your code here\n        if len(items) <= 0:\n            return []\n        if len(items) == 1:\n            return [items[0].x]\n        heap = [(item.x, item) for item in items]\n        heapq.heapify(heap)\n        res = []\n        while k > 0:\n            res.append(heapq.heappop(heap).y)\n            k -= 1\n        return res"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param a, a list of integers\n    # @return a list of integers\n    def getLargestN(self, a, n):\n        \"\"\"\n        :type a: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if len(a) <= n:\n            return a\n        start, end = 0, len(a) - 1\n        while start < end:\n            mid = (start + end) / 2\n            if a[mid] > a[end]:\n                end = mid\n            elif a[mid] < a[end]:\n                start = mid + 1\n            else:\n                break\n        return a[:n] + a[start + 1:end] + a[end + 1:]\n\nif __name__ == '__main__':\n    sol = Solution()\n    a = [1, 2, 3, 4, 5]\n    n = 3\n    print(sol.getLargestN(a, n))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param a: List[int]\n    @param k: int\n    @return: List[int]\n    \"\"\"\n    def getLargest(self, a, k):\n        # write your code here\n        \n        if not a or len(a) < k:\n            return a\n\n        ans = []\n        for i in xrange(k):\n            ans.append(a[0])\n\n        for i in xrange(1, len(a)):\n            if len(ans) >= k:\n                break\n            if a[i] > a[ans[-1]]:\n                ans.append(a[i])\n            else:\n                ans.append(a[ans[-1]])\n\n        return ans[:k]\n\n    def getLargest(self, a, k):\n        # write your code here\n        if not a or len(a) < k:\n            return a\n\n        ans = []\n        for i in xrange(k):\n            ans.append(a[0])\n\n        for i in xrange(1, len(a)):\n            if len(ans) >= k:\n                break\n            if a[i] > a[ans[-1]]:\n                ans.append(a[i])\n            else:\n                ans.append(a[ans[-1]])\n\n        return ans[:k]"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def get_n_largest(n, dataset):\n    \"\"\"\n    Returns a list of the n largest items in the dataset.\n    \"\"\"\n    data_sorted = sorted(dataset, key=lambda x: x[1], reverse=True)\n    return data_sorted[:n]\n\nif __name__ == '__main__':\n    data = [('a', 10), ('c', 9), ('b', 8), ('e', 7), ('d', 6), ('f', 5), ('g', 4), ('i', 3), ('h', 2), ('j', 1)]\n    print get_n_largest(5, data)"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    if n == 1:\n        return sorted(items, reverse=True)[:1]\n\n    if n == 2:\n        return sorted(items, reverse=True)[:2]\n\n    if n == 3:\n        return sorted(items, reverse=True)[:3]\n\n    if n == 4:\n        return sorted(items, reverse=True)[:4]\n\n    if n == 5:\n        return sorted(items, reverse=True)[:5]\n\n    if n == 6:\n        return sorted(items, reverse=True)[:6]\n\n    if n == 7:\n        return sorted(items, reverse=True)[:7]\n\n    if n == 8:\n        return sorted(items, reverse=True)[:8]\n\n    if n == 9:\n        return sorted(items, reverse=True)[:9]\n\n    if n == 10:\n        return sorted(items, reverse=True)[:10]\n\n    if n == 11:\n        return sorted(items, reverse=True)[:11]\n\n    if n == 12:\n        return sorted(items, reverse=True)[:12]\n\n    if n == 13:\n        return sorted(items, reverse=True)[:13]\n\n    if n == 14:\n        return sorted(items, reverse=True)[:14]\n\n    if n == 15:\n        return sorted(items, reverse=True)[:15]\n\n    if n == 16:\n        return sorted(items, reverse=True)[:16]\n\n    if n == 17:\n        return sorted(items, reverse=True)[:17]\n\n    if n == 18:\n        return sorted(items, reverse=True)[:18]\n\n    if n == 19:\n        return sorted(items, reverse=True)[:19]\n\n    if n == 20:\n        return sorted(items, reverse=True)[:20]\n\n    if n == 21:\n        return sorted(items, reverse=True)[:21]\n\n    if n == 22:\n        return sorted(items, reverse=True)[:"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def getLargest(self, head):\n        if not head or not head.next:\n            return head\n        fast = head\n        slow = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        \n        # reverse the list\n        # tail = slow.next\n        # slow.next = None\n        # while tail:\n        #     slow.next = tail\n        #     tail = tail.next\n        #     slow = slow.next\n        # \n        # reverse the list\n        slow = head\n        while slow.next and slow.next.next:\n            slow.next, slow.next.next = slow.next.next, slow.next\n            slow = slow.next\n        \n        # reverse the list\n        # tail = slow.next\n        # slow.next = None\n        # while tail:\n        #     slow.next = tail\n        #     tail = tail.next\n        #     slow = slow.next\n        # reverse the list\n        slow = head\n        while slow.next and slow.next.next:\n            slow.next, slow.next.next = slow.next.next, slow.next\n            slow = slow.next\n        \n        # reverse the list\n        # tail = slow.next\n        # slow.next = None\n        # while tail:\n        #     slow.next = tail\n        #     tail = tail.next\n        # reverse the list\n        slow = head\n        while slow.next and slow.next.next:\n            slow.next, slow.next.next = slow.next.next, slow.next\n            slow = slow.next\n        \n        # reverse the list\n        # tail = slow.next\n        # slow.next = None\n        # while tail:\n        #     slow.next = tail\n        #     tail = tail.next"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/nlargest/\nclass Solution(object):\n    def get_largest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(nums, reverse=True)[:num]\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.get_largest([1, 2, 3, 4, 5]))\n    print(sol.get_largest([3, 1, 2, 2, 3, 4, 5, 6]))\n    print(sol.get_largest([-1, -2, -3, -4]))\n    print(sol.get_largest([-1, -2, -3, -4, -5]))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # @yueguang\n        # @numba.jit\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba.unittest.skip(\"skip for now\")\n        # @numba."
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def get_n_largest(items, n):\n    \"\"\"\n    :type items: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    return sorted(items, reverse=True)[:n]"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import random\n\n# The data structure\n# [\n#     [1, 1, 1, 1, 1],\n#     [1, 1, 1, 1, 2],\n#     [1, 1, 1, 2, 3],\n#     [1, 1, 1, 2, 4],\n#     [1, 1, 1, 2, 3],\n#     [1, 1, 1, 2, 4],\n#     [1, 1, 1, 2, 5],\n#     [1, 1, 1, 2, 6],\n#     [1, 1, 1, 2, 7],\n#     [1, 1, 1, 2, 8],\n#     [1, 1, 1, 2, 9],\n#     [1, 1, 1, 2, 10],\n#     [1, 1, 1, 2, 11],\n#     [1, 1, 1, 2, 12],\n#     [1, 1, 1, 2, 13],\n#     [1, 1, 1, 2, 14],\n#     [1, 1, 1, 2, 15],\n#     [1, 1, 1, 2, 16],\n#     [1, 1, 1, 2, 17],\n#     [1, 1, 1, 2, 18],\n#     [1, 1, 1, 2, 19],\n#     [1, 1, 1, 2, 20],\n#     [1, 1, 1, 2, 21],\n#     [1, 1, 1, 2, 22],\n#     [1, 1, 1, 2, 23],\n#     [1, 1, 1, 2, 24],\n#     [1, 1, 1, 2, 25],\n#     [1, 1, 1, 2, 26],\n#     [1, 1, 1, 2, 27],\n#     [1, 1, 1, 2, 28],\n#     [1, 1, 1, 2, 29],\n#     [1, 1, 1, 2, 30],\n#     [1, 1, 1, 2, 31],\n#     [1, 1, 1, 2, 32],\n#     [1, 1, 1, 2, 33],\n#     [1, 1, 1,"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def getLargest(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums)\n        if n == 3:\n            return max(nums)\n        if n == 4:\n            return max(nums)\n        if n == 5:\n            return max(nums)\n        if n == 6:\n            return max(nums)\n        if n == 7:\n            return max(nums)\n        if n == 8:\n            return max(nums)\n        if n == 9:\n            return max(nums)\n        if n == 10:\n            return max(nums)\n        if n == 11:\n            return max(nums)\n        if n == 12:\n            return max(nums)\n        if n == 13:\n            return max(nums)\n        if n == 14:\n            return max(nums)\n        if n == 15:\n            return max(nums)\n        if n == 16:\n            return max(nums)\n        if n == 17:\n            return max(nums)\n        if n == 18:\n            return max(nums)\n        if n == 19:\n            return max(nums)\n        if n == 20:\n            return max(nums)\n        if n == 21:\n            return max(nums)\n        if n == 22:\n            return max(nums)\n        if n == 23:\n            return max(nums)\n        if n == 24:\n            return max(nums)\n        if n == 25:\n            return max(nums)\n        if n == 26:\n            return max(nums)\n        if n == 27:\n            return max(nums)\n        if n == 28:\n            return max(nums)\n        if n == 29:\n            return max(nums)\n        if n == 30:\n            return max(nums"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "import random\nfrom collections import Counter\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def getLargestN(self, nums, k):\n        c = Counter(nums)\n        k = k if k < len(nums) else len(nums)\n        res = sorted(nums, key=lambda x: c[x], reverse=True)[:k]\n        return res\n\nif __name__ == '__main__':\n    assert Solution().getLargestN([1, 2, 3, 4, 5], 3) == [5, 4, 3]"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n#\n\nclass Solution(object):\n    def getLargest(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        n = 1\n        while head.next:\n            n += 1\n            head = head.next\n        result = head\n        for i in range(n):\n            head = head.next\n        while head:\n            head.next = head.next.next\n            head = head.next\n        return result"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from collections import Counter\n\ndef get_n_largest(data, n):\n    \"\"\"\n    :type data: List[int]\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    counter = Counter(data)\n    return sorted(counter.most_common(n))\n\nif __name__ == '__main__':\n    assert get_n_largest([1, 2, 3, 4, 5], 2) == [5, 4]\n    assert get_n_largest([1, 2, 3, 4, 5], 3) == [5, 4, 3]\n    assert get_n_largest([1, 2, 3, 4, 5], 5) == [5, 4, 3, 2, 1]\n    assert get_n_largest([1, 2, 3, 4, 5], 6) == [5, 4, 3, 2, 1]\n    assert get_n_largest([1, 2, 3, 4, 5], 7) == [5, 4, 3, 2, 1]\n    assert get_n_largest([1, 2, 3, 4, 5], 8) == [5, 4, 3, 2, 1]\n    assert get_n_largest([1, 2, 3, 4, 5], 9) == [5, 4, 3, 2, 1]"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getLargest(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        p = head\n        while p.next:\n            p = p.next\n        q = head\n        while q.next:\n            if q.next.val > p.val:\n                p = q.next\n            q = q.next\n        return p\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    p = head\n    for i in range(3):\n        p.next = ListNode(i)\n        p = p.next\n    s = Solution()\n    head = s.getLargest(head)\n    print(head.val)\n    print(head.next.val)"
    }
  ]
}