{
  "timestamp": "2025-09-14T18:46:03.822847",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 189,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\n# Implement an algorithm to find all the indices where a given list of numbers is\n# missing.\n\n# For example, Given [1,2,3] and [2,3,4],\n# The output should be\n# [0,1]\n# The output should be\n# [0,1,2]\n# Note:\n# You may assume the list's length is in the range of [1, 10000].\n# Your algorithm's time complexity must be in the range of O(n).\n# If no solution is possible, return an empty list [].\n\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/184470/Java-Solution-with-O(n)-Time-and-Space-Complexity\n        # O(n) time\n        # O(1) space\n        # using two pointers to move through the list\n        # 1. find the first appearance of a number\n        # 2. find the second appearance of the number\n        # 3. if they are different, then the number is disappeared\n        # 4. if they are the same, then the number is appeared twice\n        # 5. if the number is appeared once, then it is not disappeared\n        # 6. if the number is appeared twice, then it is not appeared once\n        # 7. if the number is appeared three times, then it is not appeared once\n        # 8. if the number is appeared four times, then it is not appeared once\n        # 9. if the number is appeared five times, then it is not appeared once\n        # 10. if the number is appeared six times, then it is not appeared once\n        # 11. if the number is appeared seven times, then it is not appeared once\n        # 12. if the number is appeared eight times, then it is not appeared once\n        # 13. if the number is appeared nine times, then it is not appeared once"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\nimport numpy as np\n\n# this is a simple implementation of the problem\n# it will return an array of indices\n\n# this is a more advanced implementation\n# it will return an array of indices and the maximum value\n\ndef max_indices(lst):\n    max_val = -np.inf\n    max_idx = -1\n    for i, val in enumerate(lst):\n        if val > max_val:\n            max_val = val\n            max_idx = i\n    return [max_idx]\n\ndef main():\n    lst = [1,2,3,4,5,6]\n    print max_indices(lst)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-of-list/problem\n# https://www.hackerrank.com/challenges/max-of-list-ii/problem\n# https://www.hackerrank.com/challenges/max-of-list-iii/problem\n# https://www.hackerrank.com/challenges/max-of-list-iv/problem\n# https://www.hackerrank.com/challenges/max-of-list-v/problem\n# https://www.hackerrank.com/challenges/max-of-list-vi/problem\n# https://www.hackerrank.com/challenges/max-of-list-vii/problem\n# https://www.hackerrank.com/challenges/max-of-list-viii/problem\n# https://www.hackerrank.com/challenges/max-of-list-ix/problem\n# https://www.hackerrank.com/challenges/max-of-list-x/problem\n# https://www.hackerrank.com/challenges/max-of-list-xi/problem\n# https://www.hackerrank.com/challenges/max-of-list-xii/problem\n# https://www.hackerrank.com/challenges/max-of-list-xiii/problem\n# https://www.hackerrank.com/challenges/max-of-list-xiv/problem\n# https://www.hackerrank.com/challenges/max-of-list-xv/problem\n# https://www.hackerrank.com/challenges/max-of-list-xvi/problem\n# https://www.hackerrank.com/challenges/max-of-list-xvii/problem\n# https://www.hackerrank.com/challenges/max-of-list-xviii/problem\n# https://www.hackerrank.com/challenges/max-of-list-xix/problem\n# https://www.hackerrank.com/challenges/max-of-list-xx/problem\n# https://www.hackerrank.com/challenges/max-of-list-xx"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "import sys\nsys.path.append('..')\nfrom utils.sorting_and_searching import find_max_index\n\nif __name__ == '__main__':\n    arr = [6, 3, 2, 9, 1, 7, 5]\n    print(find_max_index(arr))\n\n    arr = [6, 3, 2, 9, 1, 7, 5, -1, -2, -3, -4]\n    print(find_max_index(arr))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-subarray-sum/discuss/263868/Python-DP-O(n^2)-time-and-space-complexity-in-Java\n# https://leetcode.com/problems/maximum-subarray-sum/discuss/263868/Python-DP-O(n^2)-time-and-space-complexity-in-Java\n\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        dp = [0] * n\n        max_dp = [0] * n\n        max_dp[0] = nums[0]\n        for i in range(1, n):\n            max_dp[i] = max(max_dp[i-1], nums[i])\n            for j in range(i):\n                max_dp[i] = max(max_dp[i], max_dp[j] + nums[i])\n        for i in range(n):\n            dp[i] = max_dp[i]\n        return dp"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-of-three/problem\n\ndef maxOfThree(nums):\n    # write your code here\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return [0]\n\n    max_value = max(nums)\n    max_index = nums.index(max_value)\n    return [max_index, max_index + 1, max_index + 2]\n\n\n# TEST\ninputs = [\n    ([1,2,3,4,5,6,7,8,9], [1,5,9]),\n    ([1,2,3,4,5,6,7,8,9], [9,5,1]),\n    ([1,2,3,4,5,6,7,8,9], [1,9,3]),\n    ([1,2,3,4,5,6,7,8,9], [2,6,8,4,1,3,7,5,9]),\n    ([1,2,3,4,5,6,7,8,9], [3,2,4,5,6,7,8,1,9]),\n    ([1,2,3,4,5,6,7,8,9], [7,6,5,4,3,2,1,8,9]),\n    ([1,2,3,4,5,6,7,8,9], [8,7,6,5,4,3,2,1,9]),\n    ([1,2,3,4,5,6,7,8,9], [5,4,3,2,1,8,7,6,9]),\n]\n\nfor case in inputs:\n    print(\"Case #{}: {}\".format(case[0], case[1]))\n    print(\"Expected: {}\".format(maxOfThree(case[1])))\n    print(\"Obtained: {}\".format(maxOfThree(case[1])))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-the-maximum-of-all-the-elements-of-an-array/\n\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def start_inclusive(self):\n        return self.start\n\n    def end_exclusive(self):\n        return self.end\n\nclass Solution(object):\n    def max(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        result.append(0)\n        for i in range(len(arr)):\n            result.append(max(arr[i:], key=lambda x: x.end))\n            result.append(max(arr[:i], key=lambda x: x.start))\n        return result\n\n    def maxIndex(self, arr):\n        \"\"\"\n        :type arr: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(len(arr)):\n            if arr[i].start_inclusive() >= arr[i].end_exclusive():\n                result.append(i)\n                continue\n            result.append(max(arr[i:], key=lambda x: x.end))\n            result.append(max(arr[:i], key=lambda x: x.start))\n        return result"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_values = [0] * len(nums)\n        max_values[0] = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                max_values[i] = nums[i]\n            elif nums[i] < nums[i-1]:\n                max_values[i] = max(nums[i-1], nums[i])\n        return max_values\n\nif __name__ == \"__main__\":\n    print Solution().findMax([1, 2, 3])\n    print Solution().findMax([1, 2, 1])\n    print Solution().findMax([1, 3, 4, 2])"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n\"\"\"\n@author: Peter Corke\n@date:   April 25, 2017\n@change:\n\"\"\"\n\nimport numpy as np\n\ndef max_values(n, list_to_check):\n    \"\"\"\n    @return: list of the indices of the maximum values in list_to_check\n    \"\"\"\n    \n    # initialize the list of max values\n    max_values = [0]\n    \n    # loop over list\n    for i in range(n):\n        \n        # get the maximum value\n        max_value = list_to_check[i]\n        \n        # loop over the remaining values\n        for j in range(i+1, n):\n            \n            # get the current value\n            current_value = list_to_check[j]\n            \n            # if the current value is greater than the max value, update max value\n            if current_value > max_value:\n                max_value = current_value\n            \n        # append the maximum value to the list of max values\n        max_values.append(max_value)\n    \n    # return the list of max values\n    return max_values\n\ndef main():\n    \"\"\"\n    @return:\n    \"\"\"\n    \n    # input number of elements and list to check\n    n = input(\"How many elements would you like to check? \")\n    list_to_check = [float(i) for i in input().split()]\n    \n    # print the maximum values\n    max_values = max_values(n, list_to_check)\n    \n    # print the maximum values\n    print(\"The maximum values are: \")\n    print(max_values)\n    \nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "import collections\n\ndef findMax(arr):\n    max_arr = [0]*arr.__len__()\n    max_pos = [0]*arr.__len__()\n    for i in xrange(arr.__len__()):\n        if arr[i] > max_arr[i]:\n            max_arr[i] = arr[i]\n            max_pos[i] = i\n    return max_arr, max_pos\n\ndef findMax2(arr):\n    max_arr = [0]*arr.__len__()\n    max_pos = [0]*arr.__len__()\n    for i in xrange(arr.__len__()):\n        if arr[i] > max_arr[i]:\n            max_arr[i] = arr[i]\n            max_pos[i] = i\n    return max_arr, max_pos\n\ndef findMax3(arr):\n    max_arr = [0]*arr.__len__()\n    max_pos = [0]*arr.__len__()\n    for i in xrange(arr.__len__()):\n        if arr[i] > max_arr[i]:\n            max_arr[i] = arr[i]\n            max_pos[i] = i\n    return max_arr, max_pos\n\ndef findMax4(arr):\n    max_arr = [0]*arr.__len__()\n    max_pos = [0]*arr.__len__()\n    for i in xrange(arr.__len__()):\n        if arr[i] > max_arr[i]:\n            max_arr[i] = arr[i]\n            max_pos[i] = i\n    return max_arr, max_pos\n\ndef findMax5(arr):\n    max_arr = [0]*arr.__len__()\n    max_pos = [0]*arr.__len__()\n    for i in xrange(arr.__len__()):\n        if arr[i] > max_arr[i]:\n            max_arr[i] = arr[i]\n            max_pos[i] = i\n    return max_"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from collections import Counter\n\n\nclass Solution(object):\n    def maxNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = Counter(nums)\n        return [i for i in range(len(nums)) if cnt[nums[i]] == max(cnt.values())]\n\n\nif __name__ == \"__main__\":\n    assert Solution().maxNumber([2, 3, 1, 4, 1, 3, 4]) == [3, 4]\n    assert Solution().maxNumber([1, 2, 2, 3, 4, 4, 5]) == [3, 5]\n    assert Solution().maxNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 4, 5, 7, 8, 9]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "import numpy as np\n\ndef max_positions(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list of indices\n    \"\"\"\n    max_positions = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_positions]:\n            max_positions.append(i)\n    return max_positions\n\n\ndef max_positions_2(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list of indices\n    \"\"\"\n    max_positions = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_positions]:\n            max_positions.append(i)\n    return max_positions\n\n\ndef max_positions_3(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list of indices\n    \"\"\"\n    max_positions = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_positions]:\n            max_positions.append(i)\n    return max_positions\n\n\ndef max_positions_4(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list of indices\n    \"\"\"\n    max_positions = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_positions]:\n            max_positions.append(i)\n    return max_positions\n\n\ndef max_positions_5(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list of indices\n    \"\"\"\n    max_positions = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_positions]:\n            max_positions.append(i)\n    return max_positions\n\n\ndef max_positions_6(lst):\n    \"\"\"\n    :param lst: a list of numbers\n    :return: a list"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integer\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.right.left = TreeNode(5)\nroot.right.right = TreeNode(6)\n\nprint Solution().maxDepth(root)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/maximum-in-a-matrix/problem\n\ndef max_in_matrix(arr):\n    if len(arr) == 0:\n        return -1\n    else:\n        return max(arr)\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(max_in_matrix(arr))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def find_index(list, value):\n    \"\"\"\n    >>> find_index([1, 2, 3], 3)\n    [0]\n    >>> find_index([1, 2, 3], 4)\n    [0, 1]\n    >>> find_index([1, 2, 3], 5)\n    [0, 1, 2]\n    >>> find_index([1, 2, 3], -1)\n    [0, 1, 2]\n    \"\"\"\n    for i in range(len(list)):\n        if list[i] > value:\n            return [i]\n    return []\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven a list of non-negative integers, you are initially positioned at the\nfirst index of the list.\n\nEach element in the list represents your maximum jump length at that position.\n\nDetermine the length of the shortest path from the position 0 to the last\nposition, where you are positioned at the last position yourself.\n\nFor example:\nGiven [3,2,1,4,3]\n\nThe shortest path is:\n[0, 1, 2, 3, 4]\n\nNote:\nThe length of the path is at most 1000.\n\n\"\"\"\n\n\nclass Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if len(nums) == 2:\n            return max(nums)\n\n        max_jump_len = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                continue\n            else:\n                max_jump_len += 1\n        return max_jump_len\n\n\nif __name__ == \"__main__\":\n    print Solution().jump([3,2,1,4,3])\n    print Solution().jump([3,2,1,4,3,6,7])"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # TODO: write a solution\n        nums.sort()\n        result = []\n        for i in range(len(nums) - k + 1):\n            if i == 0 or nums[i - 1] < nums[i]:\n                result.append(i)\n                if len(result) == k:\n                    return result\n        return result\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3)"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/maximum-in-a-list\n# Written by Pradeep Haridas,\n# Modified by Danyal G. Bouchas\n\ndef maximum_index(list):\n    max_index = 0\n    for i in range(0, len(list)):\n        if list[i] > list[max_index]:\n            max_index = i\n    return max_index\n\nif __name__ == '__main__':\n    n = int(input())\n    list = list(map(int, input().rstrip().split()))\n    print(maximum_index(list))"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-list/problem\n\ndef max_list(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            result.append(i)\n    return result\n\nif __name__ == '__main__':\n    n = int(input())\n    list_ = list(map(int, input().rstrip().split()))\n    print(\" \".join(map(str, max_list(list_))))"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "def max_positions(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not lst:\n        return []\n    res = []\n    for i in range(len(lst)):\n        if lst[i] > lst[0]:\n            res.append(i)\n    return res"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "def max_values(l):\n    \"\"\"\n    l: list\n    Return: a list of indexes of the maximum values in a given list.\n    \"\"\"\n\n    if len(l) == 0:\n        return []\n\n    max_values = []\n\n    for i in range(len(l)):\n        if l[i] > l[max_values[-1]]:\n            max_values.append(i)\n\n    return max_values\n\ndef main():\n    \"\"\"\n    main()\n    \"\"\"\n    l = [1, 2, 3, 4]\n    print(max_values(l))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef max_index(lst):\n    \"\"\"\n    Write a function to find all index positions of the maximum values in a given list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [2, 4]\n    \"\"\"\n    cnt = Counter(lst)\n    return [i for i, v in cnt.items() if v == max(cnt)]\n\nif __name__ == \"__main__\":\n    assert max_index([1, 2, 3, 4, 5]) == [2, 4]"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums: a list of integers\n    # @return: a list of lists of integer indices\n    def findMax(self, nums):\n        if len(nums) == 0:\n            return []\n\n        maxNums = sorted(nums)\n        maxNumsIndexes = []\n        for i in range(len(maxNums)):\n            if maxNums[i] == maxNums[-1]:\n                maxNumsIndexes.append(i)\n\n        return maxNumsIndexes\n\n\nif __name__ == '__main__':\n    print Solution().findMax([1, 2, 2, 3])\n    print Solution().findMax([2, 2, 2, 2])\n    print Solution().findMax([2, 2, 3, 2])\n    print Solution().findMax([2, 2, 3, 2, 2])\n    print Solution().findMax([2, 3, 2, 2, 2])"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-of-list/problem\n\nimport sys\n\n\ndef max_of_list(arr):\n    max_list = [arr[0]]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            max_list.append(arr[i])\n    return max_list\n\n\narr = list(map(int, sys.stdin.readline().split()))\nprint(max_of_list(arr))"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-list/problem\n\nn = int(input())\narr = []\nfor i in range(n):\n    arr.append(int(input()))\n\n# print(arr)\n# print(max(arr))\n\ndef max_list(arr):\n    max_arr = []\n    for i in range(len(arr)):\n        if arr[i] > max_arr[-1]:\n            max_arr.append(arr[i])\n    return max_arr\n\nprint(max_list(arr))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "import math\nfrom collections import Counter\n\ndef max_values(data):\n    \"\"\"\n    :type data: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_values = []\n    for i in range(len(data)):\n        if data[i] > max_values[-1]:\n            max_values.append(data[i])\n        else:\n            while data[i] > max_values[-1] and i > 0:\n                max_values[-1] = max_values[-1]\n                i -= 1\n    return max_values\n\nif __name__ == '__main__':\n    print max_values([3, 5, 6, 3, 4])\n    print max_values([4, 3, 1, 2, 3, 4])\n    print max_values([])"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "# https://www.hackerearth.com/practice/algorithms/data-structures/searching-and-searching-algorithms/practice-problems/algorithm/maximum-value-in-a-list/\n\ndef find_max(nums):\n    max_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > max_val:\n            max_val = nums[i]\n\n    return max_val\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 1, 4, 5, 6]\n    print(find_max(nums))"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def find_index_of_max(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_val = -1\n    max_idx = 0\n    for i in range(len(l)):\n        if l[i] > max_val:\n            max_val = l[i]\n            max_idx = i\n    return max_idx\n\nif __name__ == '__main__':\n    l = [1,2,3,4,5,6]\n    print(find_index_of_max(l))\n    l = [1,1,1,2,2,2]\n    print(find_index_of_max(l))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "from functools import reduce\nimport numpy as np\n\ndef max_index_positions(arr):\n    \"\"\"\n    Returns the indices of the maximum values in the given array.\n    \"\"\"\n    return np.argmax(arr, axis=0)\n\nif __name__ == '__main__':\n    arr = [3, 2, 1, 6, 0]\n    print(max_index_positions(arr))\n    print(max_index_positions(arr))\n    print(max_index_positions(arr))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "import numpy as np\n\n\ndef max_indices(arr):\n    \"\"\"\n    Given an array of numbers, return a list of indices of the maximum values.\n    \"\"\"\n    max_idx = [i for i in range(len(arr)) if arr[i] == arr[i].max()]\n    return max_idx\n\n\ndef main():\n    arr = np.array([4, 2, 8, 6, 1, 3, 7, 5])\n    print(max_indices(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def max_index(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_index = []\n    for i in range(len(nums)):\n        max_index.append(i)\n        while i < len(nums) and nums[i] == nums[max_index[i]]:\n            max_index[i] = max_index[i] + 1\n        if i < len(nums) and nums[i] > nums[max_index[i]]:\n            max_index[i] = max_index[i] + 1\n    return max_index"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "import numpy as np\n\ndef find_max_index(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return np.argmax(arr)\n\ndef find_max_index_with_index(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax()\n\ndef find_max_index_with_indices(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=0)\n\ndef find_max_index_with_indices_2(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=1)\n\ndef find_max_index_with_indices_3(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=2)\n\ndef find_max_index_with_indices_4(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=3)\n\ndef find_max_index_with_indices_5(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=4)\n\ndef find_max_index_with_indices_6(arr):\n    \"\"\"\n    Find the index of the max element of a given array.\n    :param arr:\n    :return:\n    \"\"\"\n    return arr.argmax(axis=5)\n\ndef find_max_index_with_indices_7(arr):\n    \"\"\"\n    Find the index of the max element of a given array."
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def findMaxIndex(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_val = -1\n    for i, num in enumerate(nums):\n        if num > max_val:\n            max_val = num\n    return [i for i, num in enumerate(nums) if num == max_val]"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def find_max_index(arr):\n    max_value = max(arr)\n    max_index = arr.index(max_value)\n    for i in range(0, len(arr)):\n        if max_value < arr[i]:\n            max_index = i\n    return max_index\n\nif __name__ == '__main__':\n    arr = [2, 1, 5, 6, 4, 7, 3]\n    print(find_max_index(arr))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "# https://www.geeksforgeeks.org/write-a-function-to-find-all-index-positions-of-the-maximum-values-in-a-given-list/\n\ndef max_index(arr):\n    max_index = 0\n    max_value = arr[0]\n    for i in range(len(arr)):\n        if arr[i] > max_value:\n            max_value = arr[i]\n            max_index = i\n    return max_index\n\ndef max_index_2(arr):\n    max_index = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef max_index_3(arr):\n    max_index = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef max_index_4(arr):\n    max_index = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5]\n    print max_index(arr)\n    print max_index_2(arr)\n    print max_index_3(arr)\n    print max_index_4(arr)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "import timeit\n\ndef max_positions(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    positions = []\n    start = 0\n    end = 0\n    while start < len(nums):\n        while end < len(nums) and nums[end] < nums[start]:\n            end += 1\n        positions.append(end)\n        start += 1\n    return positions\n\nif __name__ == '__main__':\n    print(timeit.timeit('max_positions(nums)', setup=\"from __main__ import max_positions, nums\", number=1000))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def find_max_index(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_val = 0\n    max_index = 0\n    for i in range(len(nums)):\n        if nums[i] > max_val:\n            max_val = nums[i]\n            max_index = i\n    return [max_index]\n\nif __name__ == '__main__':\n    nums = [2,3,1,4,5]\n    print(find_max_index(nums))\n    nums = [5, 4, 3, 2, 1]\n    print(find_max_index(nums))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "import collections\n\n\ndef find_max_values(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return find_max_values_recursive(lst)\n\n\ndef find_max_values_recursive(lst):\n    if not lst:\n        return []\n    max_val = max(lst)\n    max_index = lst.index(max_val)\n    return [max_index] + find_max_values_recursive(lst[:max_index] + lst[max_index+1:])\n\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_max_values(lst))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "import math\n\ndef max_positions(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_positions = []\n    for i in range(len(list_)):\n        if list_[i] > list_[max_positions[-1]]:\n            max_positions.append(i)\n    return max_positions\n\ndef main():\n    list_ = [3, 2, 1, 5, 6, 4]\n    print(max_positions(list_))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef max_index(nums):\n    # write your code here\n    max_values = defaultdict(int)\n    for i in range(len(nums)):\n        max_values[nums[i]] += 1\n    max_index = {}\n    for k, v in max_values.items():\n        if v > 0:\n            max_index[k] = i\n    return max_index"
    },
    {
      "rank": 42,
      "score": 4.0,
      "candidate": "import unittest\n\nclass Solution:\n    def maxNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        if not nums:\n            return []\n\n        max_nums = [0] * len(nums)\n        max_nums[0] = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] > max_nums[i-1]:\n                max_nums[i] = nums[i]\n\n        return [i for i in range(len(nums)) if max_nums[i] == nums[i]]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-number/solution/\n#\nApproach #1: Binary Search [Accepted]\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the input list.\nSpace Complexity: O(n)\n\n# 4ms 100%\nclass Solution {\n    public List<Integer> maxNumber(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums.length == 0) return res;\n\n        int min = nums[0];\n        int max = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            min = Math.min(min, nums[i]);\n            max = Math.max(max, nums[i]);\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == max) res.add(i + 1);\n        }\n        return res;\n    }\n}\n\nApproach #2: Sort + Binary Search [Accepted]\nComplexity Analysis"
    },
    {
      "rank": 43,
      "score": 3.0,
      "candidate": "# Approach 1: Brute force\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i])\n            result[i] = max_sum\n            for j in range(i+1, len(nums)):\n                max_sum = max(max_sum + nums[j], nums[i])\n                result[j] = max_sum\n\n        return result\n\n\n# Approach 2: Divide and Conquer\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i])\n            for j in range(i+1, len(nums)):\n                max_sum = max(max_sum + nums[j], nums[i])\n                if max_sum > result[j]:\n                    result[j] = max_sum\n        return result\n\n\n# Approach 3: DP\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(nums)\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i])\n            for j in range(i+1, len(nums)):\n                max_sum = max(max_sum + nums[j], nums[i])\n                if max_sum > result[j]:\n                    result[j] = max_sum\n\n        return result\n\n\n# Approach 4: DP\nclass Solution:\n    def maxSubArray("
    },
    {
      "rank": 44,
      "score": 3.0,
      "candidate": "# https://oj.leetcode.com/problems/find-maximum-average-pair-element-in-an-array/\n# tags: medium\n\n\"\"\"\nGiven a list of integers, find the maximum average pair and return its index.\n\nIf there are multiple answers, return any of them.\n\nExample 1:\n\nInput: [1,2,3,4]\nOutput: [1,3,4]\nExplanation: The maximum average pair is (2,3), so return [0,2]\n\nExample 2:\n\nInput: [2,2,3,3,4,4]\nOutput: [0,2]\nExplanation: The maximum average pair is (4,4), so return [0,1]\n\nExample 3:\n\nInput: [1,2,3,4,5,6]\nOutput: [0,1]\nExplanation: The maximum average pair is (2,3), so return [0,1]\n\"\"\"\n\nclass Solution(object):\n    def findMaximumAverage(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans, max_avg_pos = 0, 0\n        for i, v in enumerate(nums):\n            if max_avg_pos < i:\n                max_avg_pos = i\n            if ans < i:\n                ans = i\n            if ans == i and v > max_avg_pos:\n                ans = i\n        return ans\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    assert sol.findMaximumAverage([1,2,3,4]) == [0,2]\n    assert sol.findMaximumAverage([2,2,3,3,4,4]) == [0,1]\n    assert sol.findMaximumAverage([1,2,3,4,5,6]) == [0,1]"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def maxNumber(self, nums):\n        # write your code here\n        if len(nums) == 0:\n            return []\n        max_num = nums[0]\n        max_index = 0\n        for i in range(1, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n                max_index = i\n        return [max_index]\n\n\nif __name__ == '__main__':\n    nums = [1,2,3,4,5,6]\n    s = Solution()\n    print(s.maxNumber(nums))\n    print(s.maxNumber2(nums))\n    print(s.maxNumber3(nums))\n    print(s.maxNumber4(nums))\n    print(s.maxNumber5(nums))"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-of-all-elements-in-a-sorted-matrix/discuss/87316/C-Python-Solution\n\nclass Solution(object):\n    def maxOfMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        max_matrix = [[0]*len(matrix[0]) for _ in range(len(matrix))]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] > max_matrix[i][j]:\n                    max_matrix[i][j] = matrix[i][j]\n        return [i for i in range(len(matrix))]"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-the-maximum-of-all-the-elements-of-a-sorted-and-unsorted-array/\n\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        if len(nums) == 0:\n            return ans\n        ans.append(0)\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n            ans.append(max_sum)\n        return ans\n\n    def maxSubArray2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        if len(nums) == 0:\n            return ans\n        ans.append(0)\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n            ans.append(max_sum)\n        return ans"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n\nif __name__ == '__main__':\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\n    print(Solution().maxDepth(root))"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def maxNodeIndex(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head:\n            return -1\n        \n        max_val = 0\n        max_pos = 0\n        \n        while head:\n            if head.val > max_val:\n                max_pos = 0\n                max_val = head.val\n            elif head.val == max_val:\n                max_pos += 1\n            \n            head = head.next\n        \n        return max_pos"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "import collections\n\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    \"\"\"\n    @param: intervals: Given an integer array\n    @return: The index of the maximum number in the array\n    \"\"\"\n    def maxSubArray(self, intervals):\n        \"\"\"\n        @type: intervals: List[Interval]\n        @rtype: List[int]\n        \"\"\"\n        res = []\n        if len(intervals) == 0:\n            return res\n\n        max_interval = Interval(intervals[0].start, intervals[0].end)\n        res.append(max_interval.start)\n        res.append(max_interval.end)\n\n        for i in range(1, len(intervals)):\n            interval = Interval(intervals[i].start, intervals[i].end)\n            max_interval = max(max_interval, interval)\n            res.append(max_interval.start)\n            res.append(max_interval.end)\n        return res\n\n    def maxSubArray_recursive(self, intervals):\n        \"\"\"\n        @type: intervals: List[Interval]\n        @rtype: List[int]\n        \"\"\"\n        if len(intervals) == 0:\n            return []\n\n        max_interval = Interval(intervals[0].start, intervals[0].end)\n        res = [max_interval.start]\n        res.append(max_interval.end)\n\n        for i in range(1, len(intervals)):\n            interval = Interval(intervals[i].start, intervals[i].end)\n            max_interval = max(max_interval, interval)\n            res.append(max_interval.start)\n            res.append(max_interval.end)\n\n        return res\n\n\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution2:\n    \"\"\""
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def __init__(self):\n        self.max = 0\n        self.index = 0\n\n    def maxPositions(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        self.maxPositions_helper(head)\n        return self.index\n\n    def maxPositions_helper(self, head):\n        if head is None:\n            return 0\n        if head.next is None:\n            return 1\n\n        self.maxPositions_helper(head.next)\n        self.index += 1\n        self.max = max(self.max, head.val)\n\n        return self.index"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "# Approach:\n#  - Sort the list\n#  - Scan the sorted list to find the maximum value\n#  - Scan the list again to find the index position of the maximum value\n#  - Repeat the process for all values\n#  - Print the output\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)\n# Auxiliary Space: O(n)\n\ndef max_values(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    sorted_lst = sorted(lst)\n    max_value = sorted_lst[0]\n    index = 0\n    for i in range(len(sorted_lst)):\n        if sorted_lst[i] == max_value:\n            index = i\n    return [index] if index!= 0 else []\n\n\n# TESTS\nfor lst, expected in [\n    ([], []),\n    ([1, 2, 3, 4], [0]),\n    ([1, 2, 3, 4, 5, 6, 7], [0, 4]),\n]:\n    assert max_values(lst) == expected"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-of-list/problem\n# https://www.hackerearth.com/practice/algorithms/lists/max-of-list/practice-problems/algorithm/max-of-list/\n\n# Time complexity: O(n)\n# Space complexity: O(n)\n\ndef max_of_list(lst):\n    max_so_far = lst[0]\n    index = 0\n    for i in lst[1:]:\n        if i > max_so_far:\n            max_so_far = i\n            index = i\n    return index\n\n# Sample Input:\n# [1, 5, 6, 2, 3, 4]\n# Sample Output:\n# [1, 4, 6]\n\nlst = [1, 5, 6, 2, 3, 4]\nprint(max_of_list(lst))"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        max_left = self.maxDepth(root.left)\n        max_right = self.maxDepth(root.right)\n        return 1 + max(max_left, max_right)"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: A list of integers.\n    @return: A list of lists of integers includes the index positions of the maximum numbers and the maximum numbers themselves.\n    \"\"\"\n    def maxNumber(self, nums):\n        if not nums:\n            return []\n\n        max_num = nums[0]\n        max_index = 0\n\n        for i in range(1, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n                max_index = i\n\n        result = []\n\n        result.append([max_index])\n\n        for i in range(max_index + 1, len(nums)):\n            if nums[i] == max_num:\n                result.append([i])\n\n        return result\n\nif __name__ == \"__main__\":\n    print Solution().maxNumber([1,2,2,3,2,2])"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-of-two-integers/discuss/4515/Python-3-solution-O(n)-Time-O(1)-Space\ndef maxOfTwoIntegers(arr):\n    # write your code here\n    if len(arr) < 2:\n        return arr\n\n    mid = arr[len(arr) / 2]\n    left = []\n    right = []\n    for i in range(len(arr)):\n        if arr[i] <= mid:\n            left.append(i)\n        else:\n            right.append(i)\n    return maxOfTwoIntegers(left) + maxOfTwoIntegers(right)\n\ndef maxOfTwoIntegers_2(arr):\n    # write your code here\n    if len(arr) < 2:\n        return arr\n\n    max_left = arr[0]\n    max_right = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > max_right:\n            max_right = arr[i]\n            max_left = arr[0]\n        elif arr[i] > max_left:\n            max_left = arr[i]\n    return [max_left, max_right]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(maxOfTwoIntegers(arr))\n    print(maxOfTwoIntegers_2(arr))"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "import sys\n\nclass Solution(object):\n    def maxNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.max_num(nums, 0, len(nums)-1)\n\n    def max_num(self, nums, start, end):\n        if start > end:\n            return []\n\n        if start == end:\n            return [start]\n\n        mid = start + (end-start) / 2\n        max_num = nums[mid]\n        left = self.max_num(nums, start, mid-1)\n        right = self.max_num(nums, mid+1, end)\n\n        return left + right + [mid]\n\n\nif __name__ == '__main__':\n    print Solution().maxNumber([1, 2, 3, 4, 5, 6])"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-maximum-sum-of-two-lists/\n\nimport collections\n\nclass Solution(object):\n    def maxTwoSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        result = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if i + j > len(nums1) - 1:\n                    continue\n                if nums1[i] + nums2[j] > nums1[i + j]:\n                    result.append(i)\n                    result.append(j)\n                    break\n        return result"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# Write your code here\ndef max_index(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_val = 0\n    max_idx = 0\n    for i in range(len(nums)):\n        if nums[i] > max_val:\n            max_val = nums[i]\n            max_idx = i\n    return [max_idx]\n\n\nif __name__ == '__main__':\n    assert(max_index([4, 1, 2, 3, 3]) == [3])\n    assert(max_index([1, 2, 3, 4]) == [0])\n    assert(max_index([5, 1, 2, 3, 4]) == [2])"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "import collections\nimport heapq\n\n\nclass Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_heap = []\n        for i in range(len(nums)):\n            heapq.heappush(max_heap, (nums[i], i))\n\n        max_list = []\n        while max_heap:\n            max_value, max_index = heapq.heappop(max_heap)\n            max_list.append(max_index)\n            if i < len(nums) and nums[max_index] > nums[i]:\n                heapq.heappush(max_heap, (nums[i], i))\n        return max_list\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.findMax([-2, -3, -5, -6, -7])\n    print sol.findMax([-2, -3, -5, -6, -7, -1])"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMaximums(self, nums):\n        # write your code here\n        n = len(nums)\n        max_index = 0\n        max_val = -sys.maxint - 1\n        for i in xrange(n):\n            if nums[i] > max_val:\n                max_index = i\n                max_val = nums[i]\n        return [max_index] if max_index == 0 else [max_index] + self.findMaximums(nums[:max_index] + nums[max_index+1:])"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def findMax(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        max_node = None\n        result = []\n        self.findMaxHelper(root, result, max_node)\n        return result\n\n    def findMaxHelper(self, root, result, max_node):\n        if root is None:\n            return\n        if max_node is None:\n            max_node = root\n        elif root.val > max_node.val:\n            max_node = root\n        if root.left is not None:\n            self.findMaxHelper(root.left, result, max_node)\n        if root.right is not None:\n            self.findMaxHelper(root.right, result, max_node)\n        result.append(root.val)"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_index = 0\n        max_value = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > max_value:\n                max_index = i\n                max_value = nums[i]\n        return [max_index] if max_value == nums[0] else [max_index] + self.findMax(nums[:max_index+1])\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [3, 2, 1]\n    print sol.findMax(nums)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {integer}\n    def maxNodeIndex(self, head):\n        if not head: return 0\n        node, index = head, 0\n        while node:\n            if node.val > node.next.val:\n                index += 1\n            node = node.next\n        return index\n\nif __name__ == '__main__':\n    sol = Solution()\n    # for i in range(1, 10):\n    #     for j in range(i, 10):\n    #         print(i, j)\n    #         head = ListNode(i)\n    #         head.next = ListNode(j)\n    #         print(sol.maxNodeIndex(head))\n    #\n    # head = ListNode(5)\n    # head.next = ListNode(6)\n    # head.next.next = ListNode(3)\n    # head.next.next.next = ListNode(8)\n    # head.next.next.next.next = ListNode(9)\n    # head.next.next.next.next.next = ListNode(4)\n    # print(sol.maxNodeIndex(head))"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_val = max(nums)\n        max_idx = 0\n        for i in range(len(nums)):\n            if nums[i] == max_val:\n                max_idx = i\n        return [max_idx]\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3, 1, 2, 3, 4, 1, 2, 3]\n    print(sol.maxNumber(nums))"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums, a list of integer\n    # @return a list of integer\n    def findMax(self, nums):\n        if nums == None or len(nums) == 0:\n            return []\n        max_so_far = nums[0]\n        max_index = 0\n        for i in range(1, len(nums)):\n            if nums[i] > max_so_far:\n                max_so_far = nums[i]\n                max_index = i\n        return [max_index]\n\n    # @param nums, a list of integer\n    # @return a list of integer\n    def findMax2(self, nums):\n        if nums == None or len(nums) == 0:\n            return []\n        max_so_far = nums[0]\n        max_index = 0\n        for i in range(1, len(nums)):\n            if nums[i] > max_so_far:\n                max_so_far = nums[i]\n                max_index = i\n        return [max_index] + self.findMax2(nums[:max_index] + nums[max_index+1:])"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums, a list of integers\n    # @return a list of lists of integers\n    def findSubsequences(self, nums):\n        if len(nums) == 0:\n            return []\n\n        nums_len = len(nums)\n        max_len = 0\n        max_index = -1\n        max_val = nums[0]\n\n        # find max_len and max_index\n        for i in range(1, nums_len):\n            if nums[i] > nums[i-1]:\n                if nums[i] > max_val:\n                    max_len = i\n                    max_index = i - 1\n                    max_val = nums[i]\n            else:\n                if nums[i] > max_val:\n                    max_val = nums[i]\n                    max_len = i\n                    max_index = i\n        return [range(i, i+max_len) for i in range(0, nums_len)]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1,2,2,3,4,4,4]\n    print sol.findSubsequences(nums)"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        max_val = -sys.maxsize\n        max_pos = 0\n        max_node = None\n        curr = head\n        while curr:\n            if curr.val > max_val:\n                max_val = curr.val\n                max_pos = 0\n                max_node = curr\n            if curr.val > max_val:\n                max_val = curr.val\n                max_pos = 0\n                max_node = curr\n            curr = curr.next\n            max_pos += 1\n\n        return max_node"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a list of integers\n    def findMaxNode(self, head):\n        if not head: return\n        # max_node = head\n        max_node = head\n        while max_node.next:\n            if max_node.next.val > max_node.val:\n                max_node = max_node.next\n            else:\n                break\n        # max_node = head\n        max_node = head\n        while max_node.next:\n            if max_node.next.val > max_node.val:\n                max_node = max_node.next\n            else:\n                break\n        return max_node"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/256896/Python-and-2-8-Python-implementation-of-leetcode-problem-20-max-numbers-in-a-list\ndef findDisappearedNumbers(nums):\n  \"\"\"\n  :type nums: List[int]\n  :rtype: List[int]\n  \"\"\"\n  # https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/256896/Python-and-2-8-Python-implementation-of-leetcode-problem-20-max-numbers-in-a-list\n  if nums is None or len(nums) == 0:\n    return []\n\n  ret = []\n  n = len(nums)\n  for i in range(n):\n    if nums[i] == 0:\n      ret.append(i)\n      continue\n\n    j = i\n    while j < n and nums[j] == nums[i]:\n      j += 1\n    ret.append(j)\n  return ret\n\nif __name__ == '__main__':\n  nums = [0,1,0,2,1,0,1]\n  print findDisappearedNumbers(nums)"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-subarray-sum/discuss/251379/Python-with-explanation-of-how-to-implement-it\nclass Solution(object):\n    def findMaxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_sum = 0\n        max_pos = 0\n        for i in range(len(nums)):\n            cur_sum = nums[i]\n            if max_sum < cur_sum:\n                max_pos = i\n                max_sum = cur_sum\n            else:\n                if max_sum == cur_sum:\n                    max_pos = i\n        return [max_pos, max_pos + 1]"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        max = head\n        while head:\n            if head.val > max.val:\n                max = head\n            head = head.next\n        return max\n\n    # https://leetcode.com/problems/max-in-list/discuss/221788/C++-Solution-Using-Two-Pointers\n    def maxInList(self, head):\n        # write your code here\n        if not head:\n            return None\n        max = head\n        while head:\n            if head.val > max.val:\n                max = head\n            head = head.next\n        return max\n\n    # https://leetcode.com/problems/max-in-list/discuss/221788/C++-Solution-Using-Two-Pointers\n    def maxInList2(self, head):\n        # write your code here\n        if not head:\n            return None\n        max = head\n        while head:\n            if head.val > max.val:\n                max = head\n            head = head.next\n        return max\n\n    # https://leetcode.com/problems/max-in-list/discuss/221788/C++-Solution-Using-Two-Pointers\n    def maxInList3(self, head):\n        # write your code here\n        if not head:\n            return None\n        max = head\n        while head:\n            if head.val > max.val:\n                max = head\n            head = head.next\n        return max\n\n    # https://leetcode.com/problems/max-in-list/discuss/221788/C++-Solution-Using-Two-Pointers\n    def maxInList4(self, head):\n        # write your code here\n        if not head:\n            return None\n        max ="
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMax(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        d = {}\n        d[head] = 1\n        q = [head]\n        while q:\n            curr = q.pop()\n            for n in curr.next:\n                if n not in d:\n                    d[n] = 1\n                    q.append(n)\n        max_node = None\n        for node in d:\n            if d[node] > d[max_node]:\n                max_node = node\n        return max_node"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-subarray-i/\n# Given a list of integers, find the indices of the maximum values and return them in order.\n# Example:\n# Input: [10, 5, 15, 2, 18]\n# Output: [2, 3, 5]\n# Note:\n# You may assume all values in the array are non-negative.\n# The array size will not exceed 50,000.\n# Follow up:\n# Can you solve it with O(1) extra space?\n\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def start_inclusive(self):\n        return self.start\n\n    def end_inclusive(self):\n        return self.end\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_so_far = 0\n        max_so_far_idx = 0\n        for i in xrange(len(nums)):\n            if nums[i] > max_so_far:\n                max_so_far = nums[i]\n                max_so_far_idx = i\n\n        return [max_so_far_idx, max_so_far_idx + 1]"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-the-maximum-number-in-a-sorted-matrix/discuss/132816/Python-Solutions-with-Python-3-and-Python-3-2-Tutorial\n\nclass Solution:\n    # @param matrix, a list of lists of integers\n    # @return an integer\n    def maxNumber(self, matrix):\n        if not matrix:\n            return 0\n\n        row = len(matrix)\n        col = len(matrix[0])\n\n        max_row = 0\n        max_col = 0\n        max_value = -1\n\n        for i in range(row):\n            for j in range(col):\n                if matrix[i][j] > max_value:\n                    max_value = matrix[i][j]\n                    max_row = i\n                    max_col = j\n\n        for i in range(row):\n            for j in range(col):\n                if matrix[i][j] == max_value:\n                    if j > max_col:\n                        max_col = j\n                        max_row = i\n\n        return max_row * col + max_col\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(sol.maxNumber(matrix))\n    matrix = [[1, 2, 3], [4, 5, 6], [1, 2, 3]]\n    print(sol.maxNumber(matrix))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMaximumX(self, head):\n        if not head or not head.next:\n            return head\n        \n        p = head\n        while p:\n            if p.next:\n                # print(p.val, p.next.val)\n                if p.next.val > p.val:\n                    p = p.next\n                else:\n                    break\n            else:\n                break\n        \n        while p:\n            if p.next and p.next.val > p.val:\n                p = p.next\n            else:\n                break\n        \n        # print(p.val, p.next.val)\n        # return p\n        \n        p = head\n        while p.next:\n            if p.next.val > p.val:\n                p = p.next\n            else:\n                break\n        \n        return p"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def findMax(self, num):\n        ret = []\n        max_val = -1\n        for i in range(len(num)):\n            if num[i] > max_val:\n                ret.append(i)\n                max_val = num[i]\n        return ret\n\nif __name__ == \"__main__\":\n    sln = Solution()\n    nums = [2, 3, 1, 2, 3, -1]\n    print sln.findMax(nums)"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if root.left and root.right:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# -*- coding: utf-8 -*-\n\nimport sys\nsys.path.append(\"../\")\nimport re\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven an array and a value, write a function to check if this value exists in the array.\n\nThe function should return true if this array contains this value.\n\"\"\"\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven an array, write a function to check if this array is sorted.\n\nThe function should return true if the array is sorted, otherwise return false.\n\"\"\"\n\nclass Solution(object):\n    \"\"\"\n    @param arr: The sorted array\n    @param val: The value to be searched\n    @return: The index of the value\n    \"\"\"\n    def search(self, arr, val):\n        \"\"\"\n        :type arr: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if arr is None or len(arr) == 0:\n            return -1\n\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n            m = (l + r) / 2\n            if arr[m] == val:\n                return m\n            elif arr[m] > val:\n                r = m - 1\n            else:\n                l = m + 1\n\n        return -1\n\n    def search2(self, arr, val):\n        \"\"\"\n        :type arr: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if arr is None or len(arr) == 0:\n            return -1\n\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n            m = (l + r) / 2\n            if arr[m] == val:\n                return m\n            elif arr[m] > val:\n                r = m - 1\n            else:\n                l = m + 1\n\n        return -1\n\n    def search3(self, arr, val):\n        \"\"\"\n        :type arr: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if arr is None or"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef getIntersectionNode(self, head):\n\t\tif head is None:\n\t\t\treturn None\n\t\tp1 = head\n\t\tp2 = head\n\t\twhile p1 is not None and p2 is not None:\n\t\t\tif p1.next is None and p2.next is None:\n\t\t\t\tbreak\n\t\t\telif p1.next is None:\n\t\t\t\tp1 = p1.next\n\t\t\telif p2.next is None:\n\t\t\t\tp2 = p2.next\n\t\t\telif p1.next.val > p2.next.val:\n\t\t\t\tp1 = p1.next\n\t\t\telse:\n\t\t\t\tp2 = p2.next\n\t\tif p1 is None or p2 is None:\n\t\t\treturn None\n\t\treturn p1"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "# Write your code below.\ndef find_max(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return max(l), max(l)\n\nif __name__ == '__main__':\n    l = [1, 2, 3, 4, 5]\n    print(find_max(l))\n    print(find_max(l))"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def maxList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        max_val = head.val\n        max_pos = 0\n        curr = head\n        while curr:\n            if curr.val > max_val:\n                max_val = curr.val\n                max_pos = 0\n            if curr.val < max_val:\n                max_pos += 1\n            curr = curr.next\n        max_pos += 1\n        return head\n\n\nclass Solution2:\n    def maxList(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        curr = head\n        max_val = curr.val\n        max_pos = 0\n        while curr:\n            if curr.val > max_val:\n                max_val = curr.val\n                max_pos = 0\n            if curr.val < max_val:\n                max_pos += 1\n            curr = curr.next\n        max_pos += 1\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def maxSlidingWindow(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not intervals or not k:\n            return []\n        intervals.sort(key=lambda x: x.start)\n        res = []\n        i = 0\n        while i < len(intervals) - k + 1:\n            while i < len(intervals) - k + 1 and intervals[i].end < intervals[i + 1].start:\n                i += 1\n            res.append(intervals[i].end)\n            i += 1\n        return res"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "import unittest\n\n# Your Codec class should be named Codec and it should be derived from the Codec base class.\n# You should implement three methods:\n#   encode(self, x):  Given an integer x, return its base-10 string representation.\n#   decode(self, s): Given a base-10 string s, return its integer value.\n#   compare(self, x, y): Return -1, 0 or 1 if x < y, x == y or x > y.\n\nclass Codec:\n\n    def __init__(self):\n        self.table = {}\n\n    def encode(self, x):\n        return str(x)\n\n    def decode(self, s):\n        return int(s)\n\n    def compare(self, x, y):\n        return cmp(x, y)\n\n    def get_max_length(self, nums):\n        length = 0\n        for x in nums:\n            if x in self.table:\n                length += 1\n        return length\n\n    def get_max_index(self, nums):\n        length = self.get_max_length(nums)\n        max_index = 0\n        for x in range(length):\n            index = 0\n            for y in nums:\n                if self.compare(y, nums[x]) == -1:\n                    index += 1\n            if max_index < index:\n                max_index = index\n        return max_index\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(Codec().get_max_index([3, 2, 1, 5, 6, 7, 8, 9, 4]), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findMax(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        self.findMaxHelper(root, res)\n        return res\n        \n    def findMaxHelper(self, root, res):\n        if not root:\n            return\n        if root.val > res[-1]:\n            res.append(root.val)\n        if root.val > res[-1]:\n            self.findMaxHelper(root.left, res)\n        if root.val > res[-1]:\n            self.findMaxHelper(root.right, res)"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "import math\n\n\ndef find_max_index(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_arr = arr[:]\n    max_index = 0\n    max_value = 0\n    for i in range(len(arr)):\n        if max_value < arr[i]:\n            max_value = arr[i]\n            max_index = i\n    return max_index\n\n# Your Solution here.\ndef find_max_index(arr):\n    return max(arr)"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def max_value_index(arr):\n    if not arr:\n        return []\n\n    max_value = arr[0]\n    max_index = 0\n\n    for i in range(len(arr)):\n        if arr[i] > max_value:\n            max_value = arr[i]\n            max_index = i\n\n    return [max_index]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 6, 7, 8, 10, 12, 14, 15]\n\n    print max_value_index(arr)"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import numpy as np\n\n\ndef find_max_index(arr):\n    \"\"\"\n    Find all index positions of the maximum values in a given list.\n\n    :param arr: List of numbers.\n    :return: List of indexes.\n    \"\"\"\n    max_val = np.max(arr)\n    return np.where(arr == max_val)[0]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6]\n    print(find_max_index(arr))"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {integer}\n    def getIntersectionNode(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast:\n            return None\n        slow = slow.next\n        while slow and slow.next:\n            slow = slow.next\n            fast = fast.next\n        if slow.val < fast.val:\n            slow = slow.next\n        else:\n            fast = fast.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        return slow\n\nif __name__ == \"__main__\":\n    s = Solution()\n    #head = ListNode(0)\n    #head.next = ListNode(1)\n    #head.next.next = ListNode(2)\n    #head.next.next.next = ListNode(3)\n    #head.next.next.next.next = ListNode(4)\n    #head.next.next.next.next.next = ListNode(5)\n    #head.next.next.next.next.next.next = ListNode(6)\n    #print s.getIntersectionNode(head)\n    #head = ListNode(0)\n    #head.next = ListNode(1)\n    #head.next.next = ListNode(2)\n    #head.next.next.next = ListNode(3)\n    #head.next.next.next.next = ListNode(4)\n    #head.next.next.next.next.next = ListNode(5)\n    #head.next.next.next.next.next.next = ListNode(6)\n    #print s.getIntersectionNode(head)\n    #head = ListNode(0)\n    #head.next"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "#!/usr/bin/python\n\n#!/usr/bin/python\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def maxSlidingWindow(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        max_list = []\n        curr_max = 0\n        curr_max_index = 0\n        if not head:\n            return []\n        curr_node = head\n        while curr_node:\n            curr_max = max(curr_max, curr_node.val)\n            curr_max_index = max(curr_max_index, len(max_list) - 1)\n            max_list.append(curr_node.val)\n            curr_node = curr_node.next\n        max_list.append(max_list[curr_max_index])\n        return max_list[:k]\n\ns = Solution()\n\nprint s.maxSlidingWindow([1,2,3,4,5,6], 3)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def find_max_index(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    max_num = -1\n    max_index = -1\n    for i in range(len(nums)):\n        if nums[i] > max_num:\n            max_num = nums[i]\n            max_index = i\n    return max_index\n\n# test\nnums = [3, 2, 1]\nprint(find_max_index(nums))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/max-in-array/\n\n# The problem is to find the index positions of the maximum values in the given list.\n#\n# Example 1:\n# Input: [3,2,3,1,2]\n# Output: [0,2]\n# Note:\n# The length of the given array will be in range [2, 100,000].\n# The given list only contains unique integer values.\n#\n\nclass Solution(object):\n    def findMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Use the following method to find the max value in the given list.\n        #\n        # return max(nums)\n        #\n        # Use the following method to find the index positions of the max value in the given list.\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)]\n        #\n        # The following method is also valid.\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)][0]\n        #\n        # The following method is also valid.\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)]\n\n        # return max(nums)\n        #\n        # return max(nums)\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)]\n\n        # return max(nums)\n        #\n        # return max(nums)\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)]\n\n        # return max(nums)\n        #\n        # return max(nums)\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums)]\n\n        # return max(nums)\n        #\n        # return max(nums)\n        #\n        # return [i for i, v in enumerate(nums) if v == max(nums"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integer\n    def findMax(self, root):\n        if not root:\n            return []\n        res = [[] for _ in range(len(root))]\n        self.findMaxRecur(root, res, 0, len(res) - 1)\n        return res\n\n    def findMaxRecur(self, root, res, i, j):\n        if not root:\n            return\n        if i > j:\n            return\n        if i == j:\n            res[i].append(root.val)\n            return\n        self.findMaxRecur(root.left, res, i + 1, j)\n        self.findMaxRecur(root.right, res, i, j - 1)\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print Solution().findMax(root)"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import math\n\n\ndef max_values(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            indexes.append(i)\n    return indexes\n\n\ndef max_values_2(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            indexes.append(i)\n    return max(indexes)\n\n\ndef max_values_3(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            indexes.append(i)\n    return max(indexes)\n\n\ndef max_values_4(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            indexes.append(i)\n    return max(indexes)\n\n\ndef max_values_5(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):\n        if list_[i] > list_[i-1]:\n            indexes.append(i)\n    return max(indexes)\n\n\ndef max_values_6(list_):\n    \"\"\"\n    :type list_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    indexes = []\n    for i in range(len(list_)):"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/maximum-values/problem\n# https://www.hackerrank.com/challenges/maximum-values/submissions/code/285728\n\n# Brute force solution\ndef max_values(lst):\n    max_values = []\n    for i in range(len(lst)):\n        if lst[i] > lst[max_values[-1]]:\n            max_values.append(i)\n    return max_values\n\n# Dynamic Programming solution\n# http://www.geeksforgeeks.org/dynamic-programming-set-5-maximum-values-in-a-given-list/\ndef max_values_dp(lst):\n    max_values = [0] * len(lst)\n    for i in range(len(lst)):\n        max_values[i] = lst[i]\n        for j in range(i, len(lst)):\n            if lst[i] > lst[j]:\n                max_values[i] = max(max_values[i], max_values[j] + 1)\n    return max_values\n\n# Time Complexity: O(n^2)\n# Space Complexity: O(n^2)\ndef max_values_dp_time_complexity(lst):\n    max_values = [0] * len(lst)\n    for i in range(len(lst)):\n        max_values[i] = lst[i]\n        for j in range(i, len(lst)):\n            if lst[i] > lst[j]:\n                max_values[i] = max(max_values[i], max_values[j] + 1)\n    return max_values\n\n# Time Complexity: O(n^2)\n# Space Complexity: O(n^2)\ndef max_values_dp_space_complexity(lst):\n    max_values = [0] * len(lst)\n    for i in range(len(lst)):\n        max_values[i] = lst[i]\n        for j in range(i, len("
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMaximums(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        max_pos = 0\n        max_val = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > max_val:\n                max_pos = i\n                max_val = nums[i]\n        return [max_pos] if max_pos == 0 else [max_pos, max_pos+1]"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums, a list of integer\n    # @return a list of integer\n    def maxNumber(self, nums):\n        max_index = 0\n        max_val = -nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n                max_index = i\n        return [max_index, max_val]\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5]\n    print solution.maxNumber(nums)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-subarray-ii/description/\n# time: O(n)\n# space: O(1)\n\nimport collections\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        result = [0] * n\n        max_sum = nums[0]\n        for i in range(1, n):\n            if nums[i] > nums[i - 1]:\n                max_sum += nums[i]\n            else:\n                result[i] = max_sum\n                max_sum = nums[i]\n        result[n - 1] = max_sum\n\n        return result\n\n\nif __name__ == \"__main__\":\n    print(Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))\n    print(Solution().maxSubArray([-2, -1, -3, -4, -5]))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/max-subarray-sum/description/\n# https://leetcode.com/problems/max-subarray-sum/discuss/453961/Python-O(n)-Time-Java-O(1)-Space\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # \u521d\u59cb\u5316\uff0c\u7edf\u8ba1\u7ed3\u679c\n        max_sum = -sys.maxsize\n        max_idx = 0\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                max_sum += nums[i]\n                if max_sum > 0:\n                    max_idx = i\n                    if max_sum > nums[i]:\n                        max_sum = nums[i]\n        return max_idx"
    }
  ]
}