{
  "timestamp": "2025-09-14T19:06:14.557148",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 234,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from functools import reduce\n\nclass Solution(object):\n    def maxSumOfTwoSubseq(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # return max(sum(nums[:i]), sum(nums[i:]) for i in range(len(nums)))\n        return max(sum(nums[:i]), sum(nums[i:]))\n\n\nif __name__ == '__main__':\n    print(Solution().maxSumOfTwoSubseq([-2,1,-3,4,-1,2,1,-5,4]))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def max_sub(nums, start, end):\n            if start == end:\n                return nums[start]\n            ans = nums[start]\n            for i in range(start + 1, end):\n                ans = max(ans, nums[i] + max_sub(nums, start, i - 1))\n            return ans\n\n        return max_sub(nums, 0, len(nums) - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().maxSubArray(nums))\n    nums = [2, 5, 3, 1, 4]\n    print(Solution().maxSubArray(nums))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from collections import Counter\n\ndef bi_tonic_sub_sequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    # count the number of non-zero elements in arr\n    non_zero_count = Counter(arr).values()\n\n    # count the number of 0s in arr\n    zero_count = sum(non_zero_count)\n\n    # if there are two 0s, then we only need to check for the first one\n    if zero_count == 2:\n        return arr[0]\n\n    # if there are three 0s, then we can get the max from the following:\n    # (1) the sum of the two zero-count sub-sequences\n    # (2) the max of the first two zero-count sub-sequences\n    if zero_count == 3:\n        return max(\n            sum(arr[:non_zero_count[0]]),\n            sum(arr[:non_zero_count[1]]),\n        )\n\n    # if there are two zero-count sub-sequences, then we can get the max from the following:\n    # (1) the sum of the two zero-count sub-sequences\n    # (2) the max of the first two zero-count sub-sequences\n    # (3) the max of the third zero-count sub-sequence\n    if zero_count == 2:\n        return max(\n            sum(arr[:non_zero_count[0]]),\n            sum(arr[:non_zero_count[1]]),\n            arr[non_zero_count[2]],\n        )\n\n    # if there are three zero-count sub-sequences, then we can get the max from the following:\n    # (1) the sum of the three zero-count sub-sequences\n    # (2) the max of the first two zero-count sub-sequences\n    # (3) the max of the third zero-count sub-sequence\n    if zero_count == 3:\n        return max(\n            sum(arr[:non_zero_count[0]]),\n            sum(arr[:"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        max_sum = 0\n        for i in range(n):\n            for j in range(i, n):\n                max_sum = max(max_sum, nums[i] + nums[j])\n        return max_sum\n\n# Note:\n# 1. The input array can be a list or a matrix.\n# 2. The input array is in the form of a one-dimensional array."
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import numpy as np\nfrom collections import defaultdict\n\nclass Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums = sorted(nums)\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSum([1, 3, 2]))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/max-sum-of-two-non-overlapping-subsequences/\n\nclass Solution(object):\n    def maxSumTwoNoOverlap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        i, j = 0, 0\n        max_sum = 0\n        while i < len(nums):\n            while j < len(nums) and nums[j] < nums[i]:\n                j += 1\n            if j < len(nums):\n                max_sum = max(max_sum, nums[i] + nums[j])\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            i += 1\n        return max_sum"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-sum-of-bipartite-subsequence/discuss/262488/C++-Python-DP-solution-with-explanation\n# http://www.programcreek.com/2012/12/leetcode-maximum-sum-of-bipartite-subsequence/\nclass Solution:\n    # @param A, a list of integers\n    # @return an integer\n    def maxSubArray(self, A):\n        if len(A) == 0:\n            return 0\n        m = 0\n        n = len(A)\n        for i in xrange(n):\n            m = max(m, A[i])\n        for i in xrange(n):\n            m = max(m, A[n-1-i])\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                m = max(m, A[i]+A[j])\n        return m"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def bi_tonic(arr):\n    res = 0\n    for i in range(len(arr)):\n        if arr[i] == 1:\n            res = max(res, arr[i:i+2])\n    return res\n\ndef main():\n    arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    print(bi_tonic(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(bi_tonic(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(bi_tonic(arr))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "import collections\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def max_sum(nums):\n            if not nums:\n                return 0\n            result, max_sum = nums[0], 0\n            for i in range(1, len(nums)):\n                max_sum = max(max_sum, max(result, nums[i]))\n                result = max(result, nums[i] - nums[i - 1])\n            return max_sum\n        \n        max_sum = max_sum(nums)\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum, max_sum + nums[i])\n        return max_sum\n\nnums = [1, 2, -1, 4]\nnums = [-2, -1, 0, 1, 2]\nnums = [-1, 1, 2, 2, 1, -1]\nnums = [-1, -2, 2, 1, -1, 2]\nnums = [-1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nnums = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nnums = [-1,"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def max_subseq_sum(arr):\n    max_sum = 0\n    max_subseq = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == arr[i + 1] + arr[j - 1]:\n                max_sum = max(max_sum, arr[i] + arr[j])\n                max_subseq = max(max_subseq, arr[i] + arr[j] + arr[i + 1] + arr[j - 1])\n    return max_subseq, max_sum\n\n\n# arr = [1, 2, 3, 4]\n# print max_subseq_sum(arr)\n# arr = [1, 1, 1, 1]\n# print max_subseq_sum(arr)\n# arr = [1, 1, 1, 1, 1, 1, 1, 1, 1]\n# print max_subseq_sum(arr)\n# arr = [2, 1, 1, 3]\n# print max_subseq_sum(arr)\n# arr = [1, 2, 1, 2, 1, 2, 1, 2, 1]\n# print max_subseq_sum(arr)\narr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        max_sum = nums[0]\n        for n in nums:\n            max_sum = max(max_sum, n)\n            max_sum = max(max_sum, max_sum + n)\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSubArray([1,2,3,4,5]))\n    print(sol.maxSubArray([-2,-1,1,2,3]))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "import operator\n\ndef max_sum_subsequence(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # This solution works for all inputs\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums)):\n        if i == 0 or nums[i]!= nums[i - 1]:\n            max_sum = max(max_sum, nums[i] + max_sum_subsequence(nums[i + 1:]))\n    return max_sum\n\n# Note: This solution is not the best one\n# This solution works for all inputs\ndef max_sum_subsequence_no_sort(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # This solution works for all inputs\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums)):\n        if i == 0 or nums[i]!= nums[i - 1]:\n            max_sum = max(max_sum, nums[i] + max_sum_subsequence_no_sort(nums[i + 1:]))\n    return max_sum\n\n# Note: This solution is not the best one\n# This solution works for all inputs\ndef max_sum_subsequence_no_sort_1(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # This solution works for all inputs\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums)):\n        if i == 0 or nums[i]!= nums[i - 1]:\n            max_sum = max(max_sum, nums[i] + max_sum_subsequence_no_sort_1(nums[i + 1:]))\n    return max_sum\n\n# Note: This solution is not the best one\n# This solution works for all inputs\ndef max_sum_subsequence_no_sort_2(nums):\n    \"\"\"\n    :type nums: List[int]\n    :r"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findMaxSubTree(self, root: TreeNode) -> int:\n        maxSum = 0\n        self.findMaxSubTreeHelper(root, maxSum)\n        return maxSum\n\n    def findMaxSubTreeHelper(self, root, maxSum):\n        if root is None:\n            return\n        self.findMaxSubTreeHelper(root.left, maxSum)\n        self.findMaxSubTreeHelper(root.right, maxSum)\n        maxSum = max(maxSum, root.val)\n        self.findMaxSubTreeHelper(root.left, maxSum)\n        self.findMaxSubTreeHelper(root.right, maxSum)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# The solution below is not optimal.\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSum(self, nums):\n        n = len(nums)\n        nums.sort()\n        ans = 0\n        for i in range(1, n):\n            ans = max(ans, nums[i] + max(self.maxSum(nums[:i]), self.maxSum(nums[i + 1:])))\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSum([1, 2, 3]))\n    print(sol.maxSum([3, 2, 1]))\n    print(sol.maxSum([3, 3, 3]))\n    print(sol.maxSum([4, 4, 4, 4]))\n    print(sol.maxSum([4, 4, 4, 4, 4]))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        # write your code here\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums.sort()\n        result = nums[0]\n        for i in range(1, len(nums)):\n            result = max(result + nums[i], nums[i])\n        return result\n\n    def maxSubArray(self, nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        nums.sort()\n        result = nums[0]\n        for i in range(1, len(nums)):\n            result = max(result + nums[i], nums[i])\n        return result\n\n\ns = Solution()\nnums = [1,2,3]\nprint(s.maxSubArray(nums))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "import sys\n\nclass Solution(object):\n    def findMaxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, self.findMaxSum(nums[:i] + nums[i+1:]))\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [0,1,2,2,3,3]\n    print(sol.findMaxSum(nums))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "import math\nimport collections\n\ndef bi_tonic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    nums.sort()\n    max_sum = 0\n    max_idx = 0\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            max_idx = i+1\n            max_sum = nums[i] + nums[i+1]\n    return max_sum\n\nclass Solution(object):\n    def bi_tonic(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 1:\n            return 0\n        max_sum = 0\n        for i in range(len(nums)-1):\n            max_sum += nums[i] + nums[i+1]\n            if max_sum > 0:\n                return max_sum\n        return max_sum\n\nif __name__ == \"__main__\":\n    print(Solution().bi_tonic([1,1,2,3,5,7,8,10]))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-sum-of-two-arrays/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        if not nums:\n            return 0\n\n        max_sum = nums[0]\n        max_sum_index = 0\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n            if max_sum > max_sum_index:\n                max_sum_index = max_sum\n\n        return max_sum_index\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    print solution.maxSubArray([-1,1,-3,4,-1,2,1,-5,4])\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        max_sum = nums[0]\n        max_sum = max(max_sum, nums[0])\n        max_sum = max(max_sum, nums[1])\n        max_sum = max(max_sum, nums[2])\n        max_sum = max(max_sum, nums[3])\n        max_sum = max(max_sum, nums[4])\n        max_sum = max(max_sum, nums[5])\n        max_sum = max(max_sum, nums[6])\n        max_sum = max(max_sum, nums[7])\n        max_sum = max(max_sum, nums[8])\n        max_sum = max(max_sum, nums[9])\n        max_sum = max(max_sum, nums[10])\n        max_sum = max(max_sum, nums[11])\n        max_sum = max(max_sum, nums[12])\n        max_sum = max(max_sum, nums[13])\n        max_sum = max(max_sum, nums[14])\n        max_sum = max(max_sum, nums[15])\n        max_sum = max(max_sum, nums[16])\n        max_sum = max(max_sum, nums[17])\n        max_sum = max(max_sum, nums[18])\n        max_sum = max(max_sum, nums[19])\n        max_sum = max(max_sum, nums[20])\n        max_sum = max(max_sum, nums[21])"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        result = nums[0]\n        maxSum = nums[0]\n        for num in nums:\n            if num > maxSum:\n                maxSum = num\n            if num > 0 and num + result > maxSum:\n                maxSum = num + result\n            result = num\n        return maxSum"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum, nums[i] + max(nums[:i]))\n        return max_sum\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.maxSubArray([1,2,3,4,5,6])"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "from collections import deque\n\ndef find_max_subseq(arr):\n    # write your code here\n    if len(arr) < 2:\n        return 0\n    max_sum = arr[0]\n    max_sum_i = 0\n    max_sum_j = 0\n    for i in range(1, len(arr)):\n        # if current value is smaller than max sum of the previous\n        # sub-sequence, then update the max sum of the sub-sequence\n        if arr[i] <= max_sum:\n            max_sum = arr[i]\n            max_sum_i = i\n            max_sum_j = 0\n        # if current value is greater than max sum of the previous\n        # sub-sequence, then update the max sum of the sub-sequence\n        elif arr[i] > max_sum:\n            max_sum = arr[i]\n            max_sum_i = i\n            max_sum_j = 0\n\n        # if current value is greater than max sum of the previous\n        # sub-sequence, then update the max sum of the sub-sequence\n        elif arr[i] == max_sum:\n            max_sum_i = i\n            max_sum_j = 0\n    return max_sum\n\n\n\ndef main():\n    arr = [1,2,3,4,5,6,7,8]\n    print(find_max_subseq(arr))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def maxSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        res = self.maxSum(root.left)\n        res = max(res, self.maxSum(root.right))\n        res = max(res, root.val)\n        return res + root.val"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "import collections\nimport math\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i])\n            if i < len(nums) - 1:\n                max_sum = max(max_sum, nums[i] + nums[i + 1])\n        return max_sum\n\n\nif __name__ == '__main__':\n    assert Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def maxSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        max_sum = -root.val\n        self.maxSumHelper(root, 0, max_sum)\n        return max_sum\n\n    def maxSumHelper(self, root, sum, max_sum):\n        if root is None:\n            return sum\n        if root.left is None and root.right is None:\n            return sum + root.val\n        if root.left is None:\n            self.maxSumHelper(root.right, sum + root.val, max_sum)\n        elif root.right is None:\n            self.maxSumHelper(root.left, sum + root.val, max_sum)\n        else:\n            self.maxSumHelper(root.left, sum + root.val, max_sum)\n            self.maxSumHelper(root.right, sum + root.val, max_sum)"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/maximum-sum-of-bipartite-subsequence/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSumTwoNo(self, nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        n = len(nums)\n        nums.sort()\n        m = [0] * n\n        m[0] = nums[0]\n        for i in range(1, n):\n            m[i] = max(m[i - 1], nums[i] + m[i - 1])\n        return m[-1]\n\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSumTwo(self, nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        n = len(nums)\n        m = [0] * n\n        for i in range(1, n):\n            for j in range(i):\n                m[i] = max(m[i], nums[i] + m[j])\n        return m[-1]\n\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [3, 1, 1, 4, 2]\n    print(s.maxSumTwo(nums))"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSumSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        max_sum = nums[0]\n        for i in range(1, n):\n            max_sum = max(max_sum, nums[i] + max_sum)\n        return max_sum\n\n\nif __name__ == '__main__':\n    print Solution().maxSumSubArray([1,2,3,4,5,6,7,8,9])"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        max_sum = 0\n        max_index = 0\n        for i in range(len(nums)):\n            max_sum = max(max_sum, nums[i] + max_sum)\n            max_index = max(max_index, i)\n        return max_sum"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "#!/bin/python\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n@Author: Well\n@Date: 2014 - 05 - 24\n\"\"\"\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        maxSum = max(nums)\n        maxIndex = 0\n        for i in xrange(len(nums)):\n            leftSum = 0\n            rightSum = 0\n            if i == 0:\n                leftSum = nums[i]\n                continue\n            if i == len(nums) - 1:\n                rightSum = nums[i]\n                continue\n            leftSum = nums[i]\n            rightSum = nums[i]\n            for j in xrange(i + 1, len(nums)):\n                if j == i:\n                    continue\n                leftSum += nums[j]\n                rightSum += nums[j]\n                if leftSum > rightSum:\n                    maxSum = max(maxSum, leftSum)\n                elif rightSum > leftSum:\n                    maxSum = max(maxSum, rightSum)\n                else:\n                    maxSum = max(maxSum, leftSum + rightSum)\n        return maxSum\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.maxSubArray([1,2,3])\n    print s.maxSubArray([-1,2,-3])\n    print s.maxSubArray([-2,1,2,1])"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def maxSum(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode):\n            if root is None:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left > right:\n                return left\n            else:\n                return right\n        return max(dfs(root))"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxSubSum(self, root: TreeNode) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, cur_sum):\n            if not node:\n                return cur_sum\n            if node.left:\n                cur_sum = dfs(node.left, cur_sum)\n            if node.right:\n                cur_sum = dfs(node.right, cur_sum)\n            return max(cur_sum, node.val)\n\n        return dfs(root, 0)"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def helper(nums):\n            if len(nums) == 1:\n                return nums[0]\n            max_sum = nums[0]\n            for i in range(1, len(nums)):\n                max_sum = max(max_sum, nums[i] + helper(nums[:i]))\n            return max_sum\n\n        return helper(nums)"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        max_sum = nums[0]\n        max_sub = 0\n        for i in range(1, len(nums)):\n            max_sub = max(max_sub, nums[i] - nums[i - 1])\n            max_sum = max(max_sum, nums[i] + max_sub)\n        return max_sum\n\n\nif __name__ == '__main__':\n    nums = [1, -1, -2, 3]\n    print(Solution().maxSubArray(nums))"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "from collections import Counter\n\n\ndef max_sub_sequence_sum(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n    n = len(arr)\n    max_sum = 0\n    max_start = -1\n    max_end = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] < arr[j]:\n                max_sum = max(max_sum, arr[i] + arr[j])\n                if max_sum > arr[i] + arr[j]:\n                    max_start = i\n                    max_end = j\n    return max(arr[max_start:max_end + 1])\n\nif __name__ == \"__main__\":\n    arr = [3, 5, 1, 6, 2, 4, 8, 7]\n    print(max_sub_sequence_sum(arr))"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/maximum-sum-of-bipartite-sub-sequence/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSumBipartite(self, nums):\n        if not nums:\n            return 0\n\n        n = len(nums)\n        if n < 2:\n            return max(nums)\n\n        m = max(nums)\n        for i in xrange(1, n):\n            m = max(m, max(nums[:i], nums[i:]) + nums[i])\n        return m"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "def bi_tonic_sub_sequence(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    # initialize the max sum\n    max_sum = nums[0]\n    \n    # iterate through the nums\n    for i in range(n-1):\n        # iterate through the max sum, which is the max sum of the current nums sub-sequence\n        # we only need to consider the first two indices, i.e. [0,1]\n        max_sum = max(max_sum, nums[i] + nums[i+1])\n        \n    # return the max sum\n    return max_sum\n\n# Test cases\nprint bi_tonic_sub_sequence([1,2,3])\nprint bi_tonic_sub_sequence([3,2,1])\nprint bi_tonic_sub_sequence([1,2,3,4,5])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8,9])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8,9,10])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8,9,10,11])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8,9,10,11,12])\nprint bi_tonic_sub_sequence([1,2,3,4,5,6,7,8,"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        max = 0\n        for i in range(len(nums)):\n            cur = nums[i]\n            j = i + 1\n            while j < len(nums):\n                cur = max(cur + nums[j], nums[j])\n                j += 1\n            max = max(max, cur)\n        return max\n\n    def maxSubArray(self, nums):\n        max = 0\n        for i in range(len(nums)):\n            cur = nums[i]\n            j = i + 1\n            while j < len(nums):\n                cur = max(cur + nums[j], nums[j])\n                j += 1\n            max = max(max, cur)\n        return max\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3, -1, -2, -3]\n    print(sol.maxSubArray(nums))\n    nums = [1, 2, 3, 4]\n    print(sol.maxSubArray(nums))\n\n    nums = [1, 2, 3, 4, 5]\n    print(sol.maxSubArray(nums))"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "# The maximum sum of bi-tonic sub-sequence\n# https://leetcode.com/problems/maximum-sum-of-bi-tonic-sub-sequence/\n\nclass Solution(object):\n    def maxBiTonicSubSequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        \n        # the maximum sum of bi-tonic sub-sequence\n        max_sum = 0\n        \n        for i in range(n):\n            # the maximum sum of the sub-sequence\n            max_sum = max(max_sum, nums[i])\n            \n            # the maximum sum of the sub-sequence\n            max_sum = max(max_sum, nums[n-1-i])\n            \n            # the maximum sum of the sub-sequence\n            max_sum = max(max_sum, nums[n-2-i])\n        \n        return max_sum"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution:\n    def findMaxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_sum = 0\n        max_sub_sum = 0\n        max_sub_len = 0\n        for i in range(len(nums)):\n            cur_sum = 0\n            cur_sub_sum = 0\n            cur_sub_len = 0\n            while i < len(nums) and nums[i] <= nums[i - 1]:\n                cur_sum += nums[i]\n                cur_sub_sum += nums[i]\n                cur_sub_len += 1\n                i += 1\n            max_sum = max(max_sum, cur_sum)\n            max_sub_sum = max(max_sub_sum, cur_sub_sum)\n            max_sub_len = max(max_sub_len, cur_sub_len)\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findMaxSubArray([1,2,3,1]))\n    print(sol.findMaxSubArray([1,2,3,4]))"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "import numpy as np\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        for i in range(len(nums)):\n            if i < len(nums) - 1:\n                max_sum = max(max_sum, nums[i] + nums[i+1])\n            else:\n                max_sum = max(max_sum, nums[i])\n        return max_sum"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        if len(nums) == 0:\n            return max_sum\n        max_sum = nums[0]\n        sum_array = [0] * (len(nums) + 1)\n        sum_array[0] = nums[0]\n        for i in range(1, len(nums) + 1):\n            sum_array[i] = nums[i - 1] + sum_array[i - 1]\n        for i in range(len(nums)):\n            max_sum = max(max_sum, sum_array[i + 1] - sum_array[i])\n        return max_sum"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n        s = nums[0]\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            s += nums[i]\n            max_sum = max(max_sum, s)\n            s = s - nums[i]\n        return max_sum"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/maximum-sum-of-subarray-bipartite/\n# https://leetcode.com/problems/maximum-sum-of-subarray-bipartite/solution/\n# https://leetcode.com/problems/maximum-sum-of-subarray-bipartite/discuss/451061/Java-O(N^3)-Time-O(N)-Space-Solution\n# https://leetcode.com/problems/maximum-sum-of-subarray-bipartite/discuss/451061/Java-O(N^3)-Time-O(N)-Space-Solution\n# https://leetcode.com/problems/maximum-sum-of-subarray-bipartite/discuss/451061/Java-O(N^3)-Time-O(N)-Space-Solution\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArrayBipartite(self, nums):\n        max_sum = nums[0]\n        for n in nums:\n            if n < 0:\n                break\n            max_sum = max(max_sum, n)\n            sum = n + max_sum\n            for i in range(1, len(nums)):\n                if nums[i] > 0:\n                    sum = max(sum, nums[i] + max_sum)\n            if sum > max_sum:\n                max_sum = sum\n        return max_sum\n\nsolution = Solution()\n\nnums = [1, -2, 0, 3, -4, 5, -6, 7]\nprint(solution.maxSubArrayBipartite(nums))"
    },
    {
      "rank": 44,
      "score": 9.0,
      "candidate": "import sys\nimport timeit\nimport math\n\nstart_time = timeit.default_timer()\n\n# Complete the maxSubSum function below.\ndef maxSubSum(A):\n    maxSum = 0\n    maxIndex = 0\n    for i in range(len(A)):\n        for j in range(i + 1, len(A)):\n            maxSum += A[j]\n            if maxSum > maxSum:\n                maxIndex = i\n                maxSum = A[j]\n    return maxSum, maxIndex\n\nif __name__ == '__main__':\n    start_time = timeit.default_timer()\n    test_cases = int(sys.stdin.readline())\n    for t in range(test_cases):\n        A = list(map(int, sys.stdin.readline().split(' ')))\n        print(\"Case #{}: {}\".format(t + 1, maxSubSum(A)))\n    print(\"Time elapsed: {}\".format(timeit.default_timer() - start_time))"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def find_max_sum_bi_tonic(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] > max_sum:\n                max_sum = arr[i] + arr[j]\n    return max_sum\n\n\nif __name__ == '__main__':\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6,7,8,9,10]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6,7]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6,7,8]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6,7,8,9]))\n    print(find_max_sum_bi_tonic([1,2,3,4,5,6,7,8,9,10]))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef max_sum_bi_tonic(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def max_sub_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n        if right - left == 1:\n            return max(nums[left], nums[right])\n        return max(max_sub_sum(nums, left + 1, right), max_sub_sum(nums, left, right - 1))\n    return max_sub_sum(nums, 0, len(nums) - 1)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        max_sum = 0\n        max_i = 0\n        for i in range(len(nums)):\n            if nums[i] == nums[i + 1]:\n                max_sum = max(max_sum, nums[i] * (i + 1))\n                max_i = i + 1\n        return max_sum"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef max_subseq(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_subseq = 0\n    max_subseq_index = 0\n    max_subseq_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                # if arr[i] == arr[j]:\n                #     if arr[i] > max_subseq:\n                #         max_subseq = arr[i]\n                #         max_subseq_index = i\n                #         max_subseq_count = 1\n                #         break\n                #     elif arr[i] == max_subseq:\n                #         max_subseq_count += 1\n                # elif arr[i] < max_subseq:\n                #     max_subseq = arr[i]\n                #     max_subseq_index = i\n                #     max_subseq_count = 1\n                #     break\n                # elif arr[i] == max_subseq:\n                #     max_subseq_count += 1\n\n                if arr[j] > arr[i]:\n                    max_subseq = arr[j]\n                    max_subseq_index = j\n                    max_subseq_count = 1\n                    break\n\n                elif arr[j] == max_subseq:\n                    max_subseq_count += 1\n\n                elif arr[j] < max_subseq:\n                    max_subseq = arr[j]\n                    max_subseq_index = j\n                    max_subseq_count = 1\n                    break\n\n                elif arr[j] == max_subseq:\n                    max_subseq_count += 1\n\n    return max_subseq, max_subseq_index, max_subseq_count\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 1]\n    print(max_subseq(arr))\n\n    arr = [1, 2, 3, 1]\n    print(max_subseq(arr))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        max_sum = 0\n        max_index = 0\n        \n        for i in range(len(nums)):\n            cur_sum = nums[i]\n            max_sum = max(max_sum, cur_sum)\n            \n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                cur_sum += nums[i + 1]\n                max_sum = max(max_sum, cur_sum)\n                i += 1\n            \n            if max_sum > max_sum:\n                max_index = i\n        \n        return max_sum"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "class Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ans = nums[0]\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum, nums[i] + nums[i-1])\n            ans = max(ans, max_sum)\n\n        return ans"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def find_max_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    return max_subsequence(arr, 0, len(arr))\n\ndef max_subsequence(arr, i, j):\n    if i == j:\n        return arr[i]\n    elif i == j - 1:\n        return arr[i] + arr[i + 1]\n    elif arr[i] > arr[j]:\n        return arr[i] + max_subsequence(arr, i + 1, j)\n    else:\n        return max_subsequence(arr, i + 1, j)"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def max_sum_subseq(arr):\n    # write your code here\n    if not arr:\n        return 0\n    \n    sorted_arr = sorted(arr)\n    \n    # print(sorted_arr)\n    \n    if len(sorted_arr) == 1:\n        return sorted_arr[0]\n    \n    # print(sorted_arr[-1])\n    \n    if sorted_arr[-1] == sorted_arr[-2]:\n        return sorted_arr[-1]\n    \n    return max(max_sum_subseq(sub_seq) for sub_seq in [sorted_arr[:-1], sorted_arr[1:]])"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "import math\n\ndef max_sum(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum + arr[i], arr[i])\n        if i == len(arr) - 2:\n            max_sum = max(max_sum, arr[i] + arr[i + 1])\n\n    return max_sum\n\n# Your MaxSum function should return the maximum sum of all valid sub-sequences.\n# If no valid sub-sequence exists, return 0.\n# If multiple valid sub-sequences exist, return the largest one."
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "import collections\n\n\ndef max_sum(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(array)\n    max_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_sum = max(max_sum, array[i] + array[j])\n    return max_sum\n\n\nif __name__ == '__main__':\n    assert max_sum([-3, -1, 2, -4, 1]) == 6\n    assert max_sum([-1, -2, -3, -4, -5]) == -5\n    assert max_sum([-1, -2, -3, -4, -5, -6, -7]) == -7"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def max_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    # n = len(arr)\n    # print(arr)\n\n    max_so_far = arr[0]\n    for i in range(1, n):\n        max_so_far = max(max_so_far + arr[i], arr[i-1])\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    arr = [4, -3, 2, -1, -2, 1, -3]\n    print(max_subsequence(arr))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "import collections\n\n\ndef get_max_sum(arr):\n    max_sum = 0\n    max_index = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == arr[j+1]:\n                max_sum = max(max_sum, arr[i]+arr[j]+arr[j+1])\n                max_index = max(max_index, i)\n    return max_sum, max_index\n\n\ndef main():\n    arr = [2, 3, -3, -1]\n    max_sum, max_index = get_max_sum(arr)\n    print(\"Max sum = {}, max index = {}\".format(max_sum, max_index))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        if len(nums) == 0:\n            return 0\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum, nums[i] + max(self.maxSubArray(nums[:i]), self.maxSubArray(nums[i:])))\n        return max_sum\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def find_max_sum_subseq(arr):\n    if len(arr) == 0:\n        return 0\n\n    arr_len = len(arr)\n    max_sum = arr[0]\n    for i in range(1, arr_len):\n        max_sum = max(max_sum + arr[i], arr[i-1])\n\n    return max_sum"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    \"\"\"\n    >>> main()\n    \"\"\"\n    data = [1, 2, 3, 4]\n    max_sum = 0\n    for i in range(1, len(data)):\n        for j in range(i):\n            max_sum = max(max_sum, data[i] + data[j])\n    print \"max_sum =\", max_sum\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "import heapq\n\ndef max_sum_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    def find_max_sum(arr, left, right):\n        if left == right:\n            return arr[left]\n        mid = (left + right) / 2\n        if arr[mid] > arr[mid + 1]:\n            return find_max_sum(arr, mid + 1, right)\n        else:\n            return max(find_max_sum(arr, left, mid), find_max_sum(arr, mid + 1, right))\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, find_max_sum(arr, i, i))\n    return max_sum\n\ndef max_sum_subsequence_recursive(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i] + max_sum_subsequence_recursive(arr[:i]))\n    return max_sum\n\ndef max_sum_subsequence_recursive_1(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i] + max_sum_subsequence_recursive_1(arr[:i]))\n    return max_sum\n\n# Time:  O(n^2)\n# Space: O(n)\n# 1. Use max_sum_subsequence_recursive() to calculate the sum of the sub-sequence.\n# 2. Use max_sum_subsequence_recursive_1() to calculate the sum of the sub-sequence."
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def maxSubseqSum(self, num):\n        if not num:\n            return 0\n\n        # find the first index of sub-sequence\n        index = 0\n        while index < len(num) - 1:\n            if num[index] + num[index + 1] < num[index + 1]:\n                index += 1\n            else:\n                break\n\n        # if no sub-sequence, return 0\n        if index == len(num) - 1:\n            return 0\n\n        # find the maximum sum of sub-sequence\n        maxSum = 0\n        for i in range(index + 1, len(num)):\n            maxSum = max(maxSum, num[index] + num[i])\n\n        return maxSum\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.maxSubseqSum([0,1,2,3,4,5,6,7]))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        if not nums:\n            return 0\n\n        res = nums[0]\n        for i in range(1, len(nums)):\n            res = max(res, nums[i] + nums[i - 1])\n        return res"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_sum = -nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum + nums[i], nums[i])\n        return max_sum\n\nif __name__ == '__main__':\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1, 2, -1])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1, 2, 1])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1, 2, 1, 2])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1, 2, 1, 2, 1])\n    print Solution().maxSum([-2, -3, 4, -1, -2, 1, -5, -3, 2, 1, 2, 1, 2, 1, 2])"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def max_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    \n    max_sum = arr[0]\n    max_sub = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            max_sum += arr[i]\n            max_sub = max(max_sub, arr[i])\n        else:\n            max_sum += arr[i-1]\n            max_sub = max(max_sub, arr[i-1])\n    return max_sum\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5]\n    print(max_subsequence(arr))"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef max_subsequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_sum = 0\n    max_end = 0\n    max_start = 0\n\n    cur_sum = arr[0]\n    cur_end = 0\n    cur_start = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            cur_sum += arr[i]\n            cur_end = i\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                max_end = cur_end\n                max_start = cur_start\n\n        else:\n            cur_sum -= arr[i - 1]\n            cur_start = i\n            if cur_sum > max_sum:\n                max_sum = cur_sum\n                max_end = cur_end\n                max_start = cur_start\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    arr = [1, 1, 3, 2, 2, 3, 4, 1, 2, 1, 2]\n    print(max_subsequence(arr))"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "import math\n\ndef max_sum(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    n = len(arr)\n    l = [0] * n\n    r = [0] * n\n\n    for i in range(n):\n        l[i], r[i] = arr[i], arr[i]\n\n    for i in range(1, n):\n        for j in range(i):\n            l[i] = max(l[i], l[j] + r[i])\n            r[i] = max(r[i], r[j] + l[i])\n\n    return max(l[n-1], r[n-1])\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(max_sum(arr))"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # dp[i] is the maximum sum of the sub-sequence ending with nums[i]\n        # dp[i] = max(dp[i-1] + nums[i], dp[i-2] + nums[i])\n        dp = [0] * len(nums)\n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            max_sum = max(max_sum, nums[i])\n            dp[i] = max(dp[i-1] + nums[i], dp[i-2] + nums[i])\n        return max_sum\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSubArray([2, 3, 1, -1, -2, -3]))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        nums.sort()\n        ret = nums[0]\n        for i in xrange(1, len(nums)):\n            ret = max(ret + nums[i], nums[i])\n        return ret\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.maxSubArray([1,2,3,4,5,6])"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "def max_subseq(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    m, n = len(nums), len(nums[0])\n    max_subseq = 0\n    for i in range(m - 1):\n        for j in range(n - 1):\n            if nums[i][j] == nums[i + 1][j + 1]:\n                max_subseq += nums[i][j]\n            else:\n                break\n    return max_subseq\n\n# Note:\n# Recursive version is too slow\n# Greedy version is too simple\n# Dynamic programming solution is much faster"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def max_sum_subseq(a):\n    \"\"\"\n    :type a: List[int]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    max_index = 0\n    for i in range(len(a)):\n        if i == 0 or a[i]!= a[max_index]:\n            max_sum = max(max_sum, a[i])\n        if a[i] > max_sum:\n            max_index = i\n    return max_sum\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    print max_sum_subseq(a)"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums: a list of integer\n    # @return: a integer\n    def maxSubArray(self, nums):\n        n = len(nums)\n        max_sum = 0\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        \n        for i in xrange(1, n):\n            max_sum = max(max_sum, nums[i])\n            max_sum = max(max_sum, nums[i] + nums[i-1])\n            max_sum = max(max_sum, nums[i-1] + nums[i-2])\n            max_sum = max(max_sum, nums[i-2] + nums[i-3])\n        \n        return max_sum"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = 0\n        n = len(nums)\n        if n == 0:\n            return 0\n        for i in range(1, n):\n            max_sum = max(max_sum, nums[i-1] + nums[i])\n        return max_sum\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSubArray([1, 2, 3]))\n    print(sol.maxSubArray([1, 2, 3, -1]))\n    print(sol.maxSubArray([-2, -3, -5]))"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "def max_sum_subseq(array):\n    if len(array) == 0:\n        return 0\n    n = len(array)\n    max_sum = 0\n    for i in range(n-1):\n        max_sum = max(max_sum, array[i] + max_sum_subseq(array[i+1:]))\n    return max_sum\n\nprint(max_sum_subseq([1,2,3,4,5,6]))\nprint(max_sum_subseq([1,1,1,1,1,1,1,1,1,1]))\nprint(max_sum_subseq([-1,0,0,1,0,0,0,1,0,0]))\nprint(max_sum_subseq([-1,0,0,1,0,0,0,1,0,0]))\nprint(max_sum_subseq([-1,0,0,1,0,0,0,1,0,0]))"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "# https://discuss.leetcode.com/topic/26982/python-solution-understandable-explanation-and-time-complexity\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # @param root, a tree node\n    # @return an integer\n    def maxSubTreeSum(self, root):\n        if root is None:\n            return 0\n\n        max_sum = root.val\n        max_sub_tree = root.val\n\n        def max_sub_tree_sum(root):\n            if root is None:\n                return 0\n\n            if root.left is None and root.right is None:\n                return root.val\n\n            left_sum = max_sub_tree_sum(root.left)\n            right_sum = max_sub_tree_sum(root.right)\n            max_sub_tree = max(left_sum, right_sum) + root.val\n            max_sum = max(max_sub_tree, max_sum)\n\n            return max_sub_tree\n\n        max_sub_tree_sum(root)\n        return max_sum"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport math\n\ndef bi_tonic_subseq(arr, max_sum):\n    \"\"\"\n    Input: arr - an array of integers\n    Output: the maximum sum of bi-tonic sub-sequence for arr\n    \"\"\"\n    if not arr:\n        return 0\n\n    sum_list = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            sum_list.append(arr[i] + arr[j])\n\n    max_sum = max(sum_list)\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            sum_list[i] = max(sum_list[i], sum_list[j])\n\n    max_sum = max(max_sum, sum_list[0])\n\n    return max_sum\n\n\ndef main():\n    arr = [1,2,3,4,5,6,7,8,9]\n    print bi_tonic_subseq(arr, 9)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport time\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        max_sum = 0\n        i = 0\n        j = 0\n        while i < len(nums):\n            if j == 0 or nums[i] < nums[j-1]:\n                max_sum += nums[i]\n                i += 1\n            else:\n                max_sum = max(max_sum, nums[i-1] + nums[j])\n                j += 1\n        return max_sum\n\nif __name__ == '__main__':\n    start_time = time.time()\n    print Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\n    print \"run time: %fs\" % (time.time() - start_time)"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "import time\nstart_time = time.time()\n\n\ndef find_max_sum(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for i in range(len(nums) - 2):\n        left_sum = nums[i]\n        for j in range(i + 1, len(nums) - 1):\n            right_sum = nums[j + 1]\n            sum = left_sum + right_sum\n            max_sum = max(max_sum, sum)\n    return max_sum\n\n\nif __name__ == '__main__':\n    print(find_max_sum([2, 4, -1, 3, 1, 5, 6]))\n    print(find_max_sum([-1, -1, -1, -1, -1]))\n    print(find_max_sum([0, 0, 0, 0, 0]))\n    print(find_max_sum([1, 2, 3, 4, 5]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\n    print(find_max_sum([1, 2, 3, 4, 5, 6,"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/max-sum-of-bi-tonic-sub-sequence/problem\n# https://www.hackerrank.com/challenges/max-sum-of-bi-tonic-sub-sequence/submissions/code/25991759\n\nimport sys\n\nn = int(input().strip())\narr = [int(arr_temp) for arr_temp in input().strip().split(' ')]\n\nmax_sum = 0\n\nfor i in range(n-2, -1, -1):\n    for j in range(i+1, n-1):\n        temp = arr[i] + arr[j]\n        if temp > max_sum:\n            max_sum = temp\n\nprint(max_sum)"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        n = len(nums)\n        if n == 0: return 0\n        max_sum = nums[0]\n        for i in range(1, n):\n            max_sum = max(max_sum, nums[i] + max_sum)\n        return max_sum\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSubArray([1,2,3,4,5]))\n    print(sol.maxSubArray([-1,-2,-3,-4,-5]))\n    print(sol.maxSubArray([-5,-4,-3,-2,-1]))"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "def max_sum_bi_tonic(arr):\n    max_sum = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if i!= j:\n                curr_sum = arr[i] + arr[j]\n                if curr_sum > max_sum:\n                    max_sum = curr_sum\n    return max_sum\n\n# Your code here!\n\nprint max_sum_bi_tonic([1,2,3,4,5,6])"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "def find_max_sub_sequence(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    max_idx = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j]:\n                max_sum += arr[i]\n                if max_sum > arr[i]:\n                    max_idx = i\n                    max_sum = arr[i]\n    return max_idx"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        max_sum = -sys.maxsize - 1\n        for i in range(n):\n            max_sum = max(max_sum, nums[i])\n            if max_sum >= 0:\n                max_sum += nums[i]\n            else:\n                max_sum += nums[i]\n                if i < n-1:\n                    max_sum += nums[i+1]\n                else:\n                    max_sum += 0\n        return max_sum"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef find_max_sum(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # store the max sum\n    # store a dict of max sum and sub-seq\n    max_sum_dict = defaultdict(int)\n    for i in range(len(nums)):\n        max_sum_dict[nums[i]] += 1\n        for j in range(i+1, len(nums)):\n            max_sum_dict[nums[j]] -= 1\n            if max_sum_dict[nums[j]] > 0:\n                max_sum_dict[nums[j]] += 1\n                max_sum_dict[nums[i]] -= 1\n    return max(max_sum_dict.values())\n\nprint(find_max_sum([1,2,3,4,5,6,7,8,9,10]))"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "from typing import List\n\ndef find_max_sub_seq(nums: List[int]) -> int:\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    nums.sort()\n    result = 0\n    for i in range(len(nums)):\n        sum = nums[i]\n        for j in range(i+1, len(nums)):\n            sum += nums[j]\n            if sum > result:\n                result = sum\n    return result\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    print(find_max_sub_seq(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(find_max_sub_seq(nums))\n    nums = [1, 1, 1, 1, 1, 1, 1]\n    print(find_max_sub_seq(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_max_sub_seq(nums))\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(find_max_sub_seq(nums))"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "def max_sum_subsequence(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    # find the maximum sum of the first n-1 elements\n    max_sum_subsequence_first_n = max_sum_subsequence(nums[:n-1])\n    max_sum_subsequence_second_n = max_sum_subsequence(nums[1:n-1])\n\n    max_sum = max(max_sum_subsequence_first_n, max_sum_subsequence_second_n)\n\n    # find the maximum sum of the last n-1 elements\n    max_sum_subsequence_last_n = max_sum_subsequence(nums[n-1:])\n    max_sum = max(max_sum, max_sum_subsequence_last_n)\n\n    # return the maximum sum\n    return max_sum\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 2, -1, -2, -3, 4]\n    print(max_sum_subsequence(nums))"
    },
    {
      "rank": 86,
      "score": 3.0,
      "candidate": "from collections import Counter\nimport unittest\nimport timeit\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        max_sum = nums[0]\n        max_sum = max(max_sum, nums[0])\n        for i in range(1, n):\n            max_sum = max(max_sum, nums[i])\n            max_sum = max(max_sum, nums[i])\n            max_sum = max(max_sum, nums[i])\n            max_sum = max(max_sum, nums[i])\n        return max_sum\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/maximum-sum-of-bi-tonic-sub-sequence/solution/\n\n# 14ms 20%\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums.length == 0) return 0;\n        int max = nums[0];\n        int sum = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum += nums[i];\n            max = Math.max(max, sum);\n            sum = Math.max(sum, nums[i]);\n        }\n        return max;\n    }\n}\n\n# 16ms 100%\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int n = nums.length;\n        if (n == 0) return 0;\n        int[] sums = new int[n];\n        sums[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            sums[i] = nums[i] + sums["
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "def find_max_sum_subsequence(arr):\n    # write your code here\n    max_sum = 0\n    max_index = 0\n    for index in range(len(arr) - 1):\n        for i in range(index + 1, len(arr)):\n            if arr[i] > arr[i + 1]:\n                max_sum = max(max_sum, arr[i] + arr[i + 1])\n                max_index = max(max_index, index)\n    return max_sum, max_index"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxSubSum(self, root: TreeNode, k: int) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def maxSubSum(root, k):\n            if not root:\n                return 0\n            l, r = maxSubSum(root.left, k), maxSubSum(root.right, k)\n            if k == 0:\n                return l + r\n            return max(l + root.val, r + root.val)\n\n        return maxSubSum(root, k)"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Approach 1: O(n) time, O(1) space\n# This method is not optimal because it does not check for the sub-sequences that are not bi-tonic\ndef max_sum_subseq(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i])\n        max_sum = max(max_sum, arr[i] + arr[i - 1])\n    return max_sum\n\n# Approach 2: O(n) time, O(n) space\n# This method is optimal, but it is not guaranteed to find the maximum sum\ndef max_sum_subseq_opt(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i] + arr[i - 1])\n    return max_sum\n\n# Approach 3: O(n) time, O(n) space\n# This method is not optimal because it does not check for the sub-sequences that are not bi-tonic\ndef max_sum_subseq_opt_2(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i] + arr[i - 1])\n    return max_sum\n\n# Approach 4: O(n) time, O(n) space\n# This method is not optimal because it does not check for the sub-sequences that are not bi-tonic\ndef max_sum_subseq_opt_3(arr):\n    if len(arr) == 0:\n        return 0\n    max_sum = arr[0]\n    for i in range(1, len(arr)):\n        max_sum = max(max_sum, arr[i] + arr[i - 1] + arr[i - 2] + arr[i - 3])\n    return max_sum"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray(self, nums):\n        if nums == []:\n            return 0\n\n        max_sum = nums[0]\n        max_sum_index = 0\n        for i in range(1, len(nums)):\n            curr_sum = nums[i]\n            max_sum = max(max_sum + curr_sum, curr_sum)\n            max_sum_index = i if max_sum == curr_sum else max_sum_index\n\n        return max_sum\n\n    # @param {integer[]} nums\n    # @return {integer}\n    def maxSubArray_1(self, nums):\n        max_sum = nums[0]\n        max_sum_index = 0\n        for i in range(1, len(nums)):\n            curr_sum = nums[i]\n            max_sum = max(max_sum + curr_sum, curr_sum)\n            max_sum_index = i if max_sum == curr_sum else max_sum_index\n\n        return max_sum\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.maxSubArray([-2,1,-3,4,-1,2,1,-5]))\n    print(sol.maxSubArray([-2,-1,-3,-4,-5]))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def bi_t_max_sum(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    #TODO\n    return 0\n\n# Your BiTMaxSum object will be instantiated and called as such:\n# obj = BiTMaxSum(nums)\n# param_1 = obj.findMaxSum(nums)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/maximum-sum-of-subarray-equals-k/discuss/261386/Python-O(n-k)\n\n\ndef max_subarray(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not arr or not k:\n        return 0\n    if len(arr) <= 1:\n        return arr[0]\n    res, m = 0, 0\n    for i in range(len(arr) - 1):\n        m = max(m, arr[i])\n        if arr[i] > arr[i + 1]:\n            res = max(res, m)\n        else:\n            m += arr[i]\n    m += arr[-1]\n    res = max(res, m)\n    return res\n\n\ndef test_max_subarray():\n    assert max_subarray([1, 2, 3, 4, 5], 2) == 5\n    assert max_subarray([2, -1, -2, 3, -3, -5, -6], 2) == 6\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], 2) == 6\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], 5) == 0\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], 0) == -10\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], -5) == -10\n\n\ndef test_max_subarray_2():\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], 3) == -7\n    assert max_subarray([-10, -5, -2, -3, -4, -5, -6, -7], 2) == 6\n    assert max_subarray([-"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def findMaxSumSubseq(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # Write your code here\n        if root == None:\n            return 0\n        max_sum = 0\n        current_sum = root.val\n        max_left_sum = 0\n        max_right_sum = 0\n        max_left_sum = self.findMaxSumSubseq(root.left)\n        max_right_sum = self.findMaxSumSubseq(root.right)\n        if root.left!= None:\n            max_left_sum = max(max_left_sum, current_sum + root.left.val)\n        if root.right!= None:\n            max_right_sum = max(max_right_sum, current_sum + root.right.val)\n        max_sum = max(max_left_sum, max_right_sum)\n        return max_sum + current_sum"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def maxSubseqSum(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        nums_len = len(nums)\n        nums_max = defaultdict(int)\n        for i in range(nums_len):\n            nums_max[i] = nums[i]\n        for i in range(nums_len):\n            for j in range(i + 1, nums_len):\n                nums_max[i] = max(nums_max[i] + nums[j], nums_max[j] + nums[i])\n        return nums_max[0]\n\nif __name__ == '__main__':\n    assert Solution().maxSubseqSum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\n    assert Solution().maxSubseqSum([-1, -2]) == -2"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: The integer array.\n    @return: The maximum sum of bi-tonic sub-sequence for the given array.\n    \"\"\"\n    def maxBiTonic(self, nums):\n        max_sum = 0\n        max_index = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] > max_sum:\n                    max_sum = nums[i] + nums[j]\n                    max_index = j\n        return max_sum, max_index\n\n\nif __name__ == '__main__':\n    arr = [2, 1, 2, -1]\n    sol = Solution()\n    print(sol.maxBiTonic(arr))"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        res = nums[0]\n        for n in nums:\n            res = max(res, n)\n            res += n\n        return res"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def maxSum(self, root: TreeNode) -> int:\n        \"\"\"\n        dfs\n        \"\"\"\n        def dfs(root, cur_max, cur_sum):\n            if root is None:\n                return cur_max, cur_sum\n\n            if root.left is None and root.right is None:\n                return cur_max, cur_sum + root.val\n\n            cur_max = max(cur_max, cur_sum + root.val)\n            cur_sum = max(cur_sum, cur_sum + root.val + dfs(root.left, cur_max, cur_sum) + dfs(root.right, cur_max, cur_sum))\n\n            return cur_max, cur_sum\n\n        return dfs(root, 0, 0)"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def maxSubTreeSum(self, root: TreeNode, sum: int) -> int:\n        \"\"\"\n        Traverse the tree, then find the max sum of sub-tree.\n        \"\"\"\n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return sum\n        left_max = self.maxSubTreeSum(root.left, sum)\n        right_max = self.maxSubTreeSum(root.right, sum)\n        return max(left_max, right_max) + root.val\n\n\nif __name__ == \"__main__\":\n    cases = [(None, 0), (1, 3), (2, 1), (3, 4), (4, 2), (5, 1)]\n    for case in cases:\n        root, sum = case\n        assert Solution().maxSubTreeSum(root, sum) == max(Solution().maxSubTreeSum(root, sum), sum)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        # max sum of bi-tonic sub-sequence\n        # sum of every two digits\n        # sum of every three digits\n        # sum of every four digits\n        # sum of every five digits\n        # sum of every six digits\n        # sum of every seven digits\n        # sum of every eight digits\n        # sum of every nine digits\n        # sum of every ten digits\n        # sum of every 11 digits\n        # sum of every 12 digits\n        # sum of every 13 digits\n        # sum of every 14 digits\n        # sum of every 15 digits\n        # sum of every 16 digits\n        # sum of every 17 digits\n        # sum of every 18 digits\n        # sum of every 19 digits\n        # sum of every 20 digits\n        # sum of every 21 digits\n        # sum of every 22 digits\n        # sum of every 23 digits\n        # sum of every 24 digits\n        # sum of every 25 digits\n        # sum of every 26 digits\n        # sum of every 27 digits\n        # sum of every 28 digits\n        # sum of every 29 digits\n        # sum of every 30 digits\n        # sum of every 31 digits\n        # sum of every 32 digits\n        # sum of every 33 digits\n        # sum of every 34 digits\n        # sum of every 35 digits\n        # sum of every 36 digits\n        # sum of every 37 digits\n        # sum of every 38 digits\n        # sum of every 39 digits\n        # sum of every 40 digits\n        # sum of every 41 digits\n        # sum of every 42 digits\n        # sum of every 43 digits\n        # sum of every 44 digits\n        # sum of every 45 digits\n        # sum of every 46 digits\n        # sum of every 47 digits\n        # sum of every 48 digits\n        # sum of every 49 digits\n        # sum of every 50 digits\n        # sum of every 51 digits\n        # sum of every 52 digits\n        # sum of every 53 digits\n        # sum of every 54 digits\n        # sum of every 55 digits\n        # sum of every 56 digits\n        # sum of every 57"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxSubseq(self, root: TreeNode, target: int) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def maxSubseqHelper(root, target, sum, max_sum):\n            if root is None:\n                return 0\n            if target < root.val:\n                return maxSubseqHelper(root.left, target, sum, max_sum)\n            if target > root.val:\n                return maxSubseqHelper(root.right, target, sum, max_sum)\n            sum += root.val\n            if sum > max_sum:\n                max_sum = sum\n            maxSubseqHelper(root.left, target, sum, max_sum)\n            maxSubseqHelper(root.right, target, sum, max_sum)\n            return max_sum\n\n        return maxSubseqHelper(root, target, 0, 0)\n\n\nif __name__ == '__main__':\n    root = TreeNode(3)\n    root.left = TreeNode(5)\n    root.left.left = TreeNode(7)\n    root.left.right = TreeNode(9)\n    root.right = TreeNode(1)\n    root.right.left = TreeNode(2)\n    root.right.right = TreeNode(4)\n    print(Solution().maxSubseq(root, 5))"
    }
  ]
}