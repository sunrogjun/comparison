{
  "timestamp": "2025-09-14T19:33:08.910345",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 294,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a word:\n#     word: str\n#     def __init__(self, word):\n#         self.word = word\n#         self.n = len(word)\n#         self.data = []\n#         for i in range(self.n):\n#             self.data.append(0)\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m = len(p)\n        n = len(s)\n        if m == 0 or n == 0:\n            return m == 0 and n == 0\n        dp = [[False for _ in range(n+1)] for _ in range(m+1)]\n        dp[0][0] = True\n        for i in range(1, m+1):\n            dp[i][0] = dp[i-1][0] and (p[i-1] == s[0])\n        for j in range(1, n+1):\n            dp[0][j] = dp[0][j-1] and (p[0] == s[j-1])\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[i-1] == s[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        return dp[m][n]\n\nif __name__ == '__main__':\n    solution = Solution()\n    s = 'ab'\n    p = 'b'\n    print(solution.isMatch(s, p))\n    s = 'abbc'\n    p = 'b*'\n    print(solution.isMatch(s, p))\n    s = 'ab'\n    p = '*b'\n    print(solution.isMatch(s, p))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "import collections\n\n\ndef is_match(word, match_word):\n    \"\"\"\n    :type word: str\n    :type match_word: str\n    :rtype: bool\n    \"\"\"\n    word = word[::-1]\n    match_word = match_word[::-1]\n    return word == match_word\n\n\ndef is_match2(word, match_word):\n    \"\"\"\n    :type word: str\n    :type match_word: str\n    :rtype: bool\n    \"\"\"\n    if len(word)!= len(match_word):\n        return False\n    return all(is_match(w, mw) for w, mw in zip(word, match_word))\n\n\ndef is_match3(word, match_word):\n    \"\"\"\n    :type word: str\n    :type match_word: str\n    :rtype: bool\n    \"\"\"\n    if len(word)!= len(match_word):\n        return False\n    word = collections.deque(word)\n    match_word = collections.deque(match_word)\n    while word:\n        if not match_word:\n            return False\n        if is_match(word.popleft(), match_word.popleft()):\n            match_word.popleft()\n        else:\n            return False\n    return True\n\n\nif __name__ == '__main__':\n    print(is_match(\"abcd\", \"cabd\"))\n    print(is_match(\"abcd\", \"cdab\"))\n    print(is_match(\"abcd\", \"cdba\"))\n    print(is_match(\"abc\", \"cba\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bca\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac\"))\n    print(is_match(\"abc\", \"bac"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {integer}\n    def wordDistance(self, words, word1, word2):\n        \"\"\"\n        :type words: List[str]\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        i = j = 0\n        while i < len(word1) and j < len(word2):\n            if word1[i] == word2[j]:\n                i += 1\n                j += 1\n            elif word1[i] > word2[j]:\n                i += 1\n            else:\n                j += 1\n        return i + j"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def match_pairs(words, p):\n    \"\"\"\n    :type words: List[str]\n    :type p: str\n    :rtype: List[str]\n    \"\"\"\n    word_list = []\n    for word in words:\n        if word.startswith(p):\n            word_list.append(word)\n    return word_list\n\n# Note:\n# 1. The input string can be a list of words or a single string.\n# 2. The input string can only have lowercase letters.\n# 3. The input string must be a prefix of all the words in the input list.\n# 4. The input string can be longer than the input list.\n# 5. The output list must have the same length as the input list.\n# 6. The output list must contain all the words in the input list.\n\n# Note:\n# 1. The input string can be a list of words or a single string.\n# 2. The input string can only have lowercase letters.\n# 3. The input string must be a prefix of all the words in the input list.\n# 4. The input string can be longer than the input list.\n# 5. The output list must have the same length as the input list.\n# 6. The output list must contain all the words in the input list.\n\n# Note:\n# 1. The input string can be a list of words or a single string.\n# 2. The input string can only have lowercase letters.\n# 3. The input string must be a prefix of all the words in the input list.\n# 4. The input string can be longer than the input list.\n# 5. The output list must have the same length as the input list.\n# 6. The output list must contain all the words in the input list.\n\n# Note:\n# 1. The input string can be a list of words or a single string.\n# 2. The input string can only have lowercase letters.\n# 3. The input string must be a prefix of all the words in the input list.\n# 4. The input string can be longer than the input list.\n# 5. The output list must have the same length as the input list.\n# 6. The output list must contain all the words in the input list.\n\n#"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0 or len(p) == 0:\n            return False\n\n        s_idx = 0\n        p_idx = 0\n        while s_idx < len(s) and p_idx < len(p):\n            if s[s_idx] == p[p_idx]:\n                s_idx += 1\n                p_idx += 1\n            else:\n                if s_idx == 0:\n                    return False\n                else:\n                    s_idx = s_idx - 1\n            if p_idx == 0:\n                return False\n            else:\n                p_idx = p_idx - 1\n\n        if p_idx == len(p):\n            return True\n        else:\n            return False\n\n    # @param s, a string\n    # @param p, a string\n    # @return a boolean\n    def isMatch_2(self, s, p):\n        if len(s) == 0 or len(p) == 0:\n            return False\n\n        s_idx = 0\n        p_idx = 0\n        while s_idx < len(s) and p_idx < len(p):\n            if s[s_idx] == p[p_idx]:\n                s_idx += 1\n                p_idx += 1\n            else:\n                if s_idx == 0:\n                    return False\n                else:\n                    s_idx = s_idx - 1\n            if p_idx == 0:\n                return False\n            else:\n                p_idx = p_idx - 1\n\n        if p_idx == len(p):\n            return True\n        else:\n            return False"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for a word:\n#     word: str\n#     def __init__(self, word):\n#         self.word = word\n#         self.rank = {}\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if len(p) == 0:\n            return len(s) == 0\n        if len(p) > len(s):\n            return False\n        if p[0] == '*':\n            p = p[1:]\n            s = s[1:]\n        for i in range(len(p)):\n            if p[i] == '?':\n                if i > 0 and p[i - 1] == '*':\n                    s = s[0:i] + p[i + 1:]\n                    break\n                elif i > 0 and p[i - 1] == '*':\n                    s = s[0:i] + p[i + 1:]\n                    break\n                elif i < len(p) - 1 and p[i + 1] == '*':\n                    s = s[0:i] + p[i + 2:]\n                    break\n                elif i < len(p) - 1 and p[i + 1] == '*':\n                    s = s[0:i] + p[i + 2:]\n                    break\n                elif i > 0 and p[i - 1] == '*' and p[i + 1] == '*':\n                    s = s[0:i] + p[i + 2:]\n                    break\n                elif i > 0 and p[i - 1] == '*' and p[i + 1] == '*':\n                    s = s[0:i] + p[i + 2:]\n                    break\n                elif i < len(p) - 1 and p[i + 1] == '*' and p[i + 2] == '*':\n                    s = s[0:i] + p[i + 3:]\n                    break\n                elif i < len(p) - 1 and p[i + 1] == '*' and p[i"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def match(word1, word2, words):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :type words: List[str]\n    :rtype: bool\n    \"\"\"\n    for w in words:\n        if w[:len(word1)] == word1 and w[len(word1):] == word2:\n            return True\n    return False\n\nif __name__ == '__main__':\n    words = ['pizza', 'cake']\n    print(match('pizza', 'cake', words))\n    print(match('pie', 'cake', words))\n    print(match('pizza', 'pie', words))\n    print(match('pizza', 'pizza', words))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# pylint: disable=missing-docstring\n# pylint: disable=unused-argument\n\ndef match(word1, word2, wordList):\n    if word1[-1]!= word2[-1]:\n        return False\n    if word1[:-1]!= word2[:-1]:\n        return False\n    return True\n\n# Your Solution here\n\n# Note:\n# Have you met this question in a real interview?\n# If so, take this opportunity to practice your interview skills.\n# If not, you are free to write your own solutions.\n#\n# Clarification:\n# What is the difference between the two strings word1 and word2?\n# For example, word1 = \"apple\", word2 = \"app\".\n# What is the length of word1?\n# What is the length of word2?\n#\n# Example:\n# word1 = \"apple\", word2 = \"app\", wordList = [\"apple\", \"apple\", \"ap\", \"a\"]\n#\n# word1 = \"apple\", word2 = \"app\", wordList = [\"apple\", \"apple\", \"ap\", \"a\"]\n#\n# Return True\n\ndef match(word1, word2, wordList):\n    if word1[-1]!= word2[-1]:\n        return False\n    if word1[:-1]!= word2[:-1]:\n        return False\n    return True"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "import unittest\n\n# https://github.com/aubricus/LeetCode/blob/master/leetcode-0.9.1.md\n# https://leetcode.com/problems/match-words/\n# https://leetcode.com/problems/match-words-ii/\n\n\ndef match(words, word):\n    if word.startswith('p'):\n        return word[1:] in words\n    else:\n        return word in words\n\n\nclass TestMatchWords(unittest.TestCase):\n    def test_match(self):\n        self.assertEqual(match(['a', 'abcd', 'pwd', 'pwd'], 'pwd'), True)\n        self.assertEqual(match(['a', 'abcd', 'pwd', 'pwd'], 'abc'), False)\n        self.assertEqual(match(['a', 'abcd', 'pwd', 'pwd'], 'abcde'), False)\n        self.assertEqual(match(['a', 'abcd', 'pwd', 'pwd'], 'pwd'), True)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param words, a list of strings\n    # @param target, a string\n    # @return a boolean\n    def isMatch(self, words, target):\n        if len(words)!= len(target):\n            return False\n        \n        for i in range(len(words)):\n            if words[i][0] == target[0] and self.isMatch(words[i+1:], target[1:]):\n                return True\n        return False"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        # DP\n        # match\n        # match\n        # not match\n        # not match\n        # not match\n        dp = [[False for j in range(len(p)+1)] for i in range(len(s)+1)]\n        dp[0][0] = True\n        for i in range(len(p)):\n            for j in range(len(s)):\n                if p[i] == s[j]:\n                    dp[j+1][i+1] = dp[j][i]\n                else:\n                    dp[j+1][i+1] = dp[j][i] or dp[j][i+1]\n        return dp[-1][-1]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/word-search/discuss/122784/Python-Solution-with-explanation\n# https://leetcode.com/problems/word-search/discuss/122841/Python-Solution-with-explanation\n# https://leetcode.com/problems/word-search/discuss/122838/Python-Solution-with-explanation\n\nfrom collections import defaultdict\n\n\nclass Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if not board:\n            return False\n\n        row, col = len(board), len(board[0])\n        dic = defaultdict(set)\n        for i in range(row):\n            for j in range(col):\n                if board[i][j] == word[0]:\n                    dic[i, j].add(word[0])\n                    self.exist(board[i:row:1, j:col:1], word[1:])\n                    if not dic[i, j]:\n                        return False\n                    dic[i, j].discard(word[0])\n                    self.exist(board[i:row:1, j:col:1], word[1:])\n        return True\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    board = [\n        [\"a\", \"b\", \"c\"],\n        [\"d\", \"e\", \"f\"],\n        [\"c\", \"d\", \"e\"]\n    ]\n    board = [['a', 'b', 'c'], ['d', 'e', 'f'], ['c', 'd', 'e']]\n    print s.exist(board, \"abc\")\n    print s.exist(board, \"aed\")\n    print s.exist(board, \"abcdef\")\n    print s.exist(board, \"abcde\")"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/word-search/\n# https://leetcode.com/problems/word-search-ii/\n# https://leetcode.com/problems/word-search-iii/\n# https://leetcode.com/problems/word-search-iv/\n# https://leetcode.com/problems/word-search-v/\n# https://leetcode.com/problems/word-search-vi/\n# https://leetcode.com/problems/word-search-vii/\n# https://leetcode.com/problems/word-search-viii/\n# https://leetcode.com/problems/word-search-ix/\n# https://leetcode.com/problems/word-search-x/\n# https://leetcode.com/problems/word-search-xi/\n# https://leetcode.com/problems/word-search-xii/\n# https://leetcode.com/problems/word-search-xiii/\n# https://leetcode.com/problems/word-search-xiv/\n# https://leetcode.com/problems/word-search-xv/\n# https://leetcode.com/problems/word-search-xvi/\n# https://leetcode.com/problems/word-search-xvii/\n# https://leetcode.com/problems/word-search-xviii/\n# https://leetcode.com/problems/word-search-xix/\n# https://leetcode.com/problems/word-search-xiix/\n# https://leetcode.com/problems/word-search-ii-i/\n# https://leetcode.com/problems/word-search-ii-ii/\n# https://leetcode.com/problems/word-search-ii-iii/\n# https://leetcode.com/problems/word-search-ii-iv/\n# https://leetcode.com/problems/word-search-ii-v/\n# https://leetcode.com/problems/word-search"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def match(words, target):\n    return [word for word in words if target in word]\n\n\ndef main():\n    words = [\"pizza\", \"pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "from __future__ import print_function\n\nimport re\n\n\nclass Solution(object):\n\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(p):\n            return False\n\n        m = re.match(r'p(.*?)', s)\n        if m is None:\n            return False\n\n        s = m.group(1)\n        p = p[0]\n        return s.startswith(p) and self.isMatch(s[1:], p)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = \"pippo\"\n    p = \"p\"\n    print(sol.isMatch(s, p))\n    s = \"pippo\"\n    p = \"pp\"\n    print(sol.isMatch(s, p))\n    s = \"pippo\"\n    p = \"pp\"\n    print(sol.isMatch(s, p))\n    s = \"pippo\"\n    p = \"p\"\n    print(sol.isMatch(s, p))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def match_two_words(words, p):\n    \"\"\"\n    :type words: List[str]\n    :type p: str\n    :rtype: List[str]\n    \"\"\"\n    res = []\n    for word in words:\n        if word[0] == p:\n            res.append(word)\n    return res\n\n# Your Solution here."
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "import collections\n\ndef match_words(words, word1, word2):\n    \"\"\"\n    :type words: List[str]\n    :type word1: str\n    :type word2: str\n    :rtype: bool\n    \"\"\"\n    if word1.upper()!= word2.upper():\n        return False\n\n    if len(word1)!= len(word2):\n        return False\n\n    match = collections.defaultdict(int)\n    for i in range(len(word1)):\n        if word1[i] == word2[i]:\n            match[word1[i]] += 1\n    return all(match.values())\n\nif __name__ == '__main__':\n    words = [\"pizza\", \"papaya\", \"papaya pie\", \"papaya cake\", \"papaya cake cake\"]\n    print match_words(words, \"pizza\", \"papaya\")\n    print match_words(words, \"pizza\", \"papaya pie\")\n    print match_words(words, \"pizza\", \"papaya cake\")\n    print match_words(words, \"pizza\", \"papaya cake cake\")"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "def match(word1, word2, words):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :type words: List[str]\n    :rtype: bool\n    \"\"\"\n    if word1 == word2:\n        return True\n\n    if word1[0] == 'p' and word2[0] == 'p':\n        if word1[1:] in words:\n            return True\n        if word2[1:] in words:\n            return True\n        return False\n\n    if word1[0]!= 'p':\n        if word1 in words:\n            return match(word1[1:], word2, words)\n        return False\n\n    if word2[0]!= 'p':\n        if word2 in words:\n            return match(word1, word2[1:], words)\n        return False\n\n    return False\n\nif __name__ == '__main__':\n    words = ['pizza', 'cake', 'papaya', 'pear', 'pizza', 'papaya']\n    word1 = 'pizza'\n    word2 = 'papaya'\n    print(match(word1, word2, words))"
    },
    {
      "rank": 19,
      "score": 9.0,
      "candidate": "def match(w1, w2):\n    if w1[0]!= w2[0]:\n        return False\n    return w1[1:] == w2[1:]\n\nwords = open(\"words.txt\", 'r')\n\nw1 = words.readline().strip()\nw2 = words.readline().strip()\n\nprint match(w1, w2)"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/word-search/discuss/82757/Python-Cython-Java-and-C/10907\n\nclass Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(board, word, row, col):\n            if row == len(board) or col == len(board[row]):\n                return True\n            if board[row][col]!= word[row - row % 2][col - col % 2]:\n                return False\n            return dfs(board, word, row + 1, col) or dfs(board, word, row, col + 1)\n\n        return dfs(board, word, 0, 0)\n\n\nif __name__ == \"__main__\":\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"abcd\") == True\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"dabcd\") == False\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"abcd\") == True\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"bcad\") == False\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"abcde\") == True\n    assert Solution().exist([\"a\", \"b\", \"c\", \"d\"], \"abcd\") == True"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "def match_pattern(word_list, pattern):\n    \"\"\"\n    Write a function match_pattern to return the number of words in word_list that\n    match the pattern starting with 'p'.\n\n    word_list: list of strings, each string is a word\n    pattern: string, only contain letters 'p'\n    \"\"\"\n    word_count = 0\n    for word in word_list:\n        if word.startswith(pattern):\n            word_count += 1\n    return word_count\n\n#Test\nprint match_pattern(['cat', 'bat', 'rat', 'rat'], 'rat')\nprint match_pattern(['cat', 'bat', 'rat', 'rat'], 'rat')\nprint match_pattern(['cat', 'bat', 'rat', 'rat'], 'rat')\nprint match_pattern(['cat', 'bat', 'rat', 'rat'], 'rat')\nprint match_pattern(['cat', 'bat', 'rat', 'rat'], 'rat')"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "def find_match(word1, word2, words, index, letters, matches):\n    if index >= len(words):\n        return\n    if not letters[index]:\n        return\n    if not word1[letters[index]:] == word2[letters[index]:]:\n        return\n    if len(word1) == len(word2):\n        matches.append((word1, word2))\n    else:\n        find_match(word1, word2, words, index + 1, letters, matches)\n        find_match(word2, word1, words, index + 1, letters, matches)\n\ndef match_words(word1, word2, words):\n    matches = []\n    letters = list(word1)\n    find_match(word1, word2, words, 0, letters, matches)\n    return matches\n\nif __name__ == '__main__':\n    words = ['parrot', 'rat', 'rat', 'cat', 'cat', 'dog']\n    word1 = 'parrot'\n    word2 = 'rat'\n    matches = match_words(word1, word2, words)\n    print(matches)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "# https://oj.leetcode.com/problems/word-search/\n\nclass Solution(object):\n    def wordSearch(self, words, word):\n        \"\"\"\n        :type words: List[str]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(words, word, i):\n            if i >= len(word):\n                return True\n            if word == word[i]:\n                return dfs(words, word, i+1)\n            for j in range(len(word)):\n                if dfs(words, word[:j]+word[j+1:], i+1):\n                    return True\n            return False\n        return dfs(words, word, 0)\n\nif __name__ == \"__main__\":\n    words = [\"wxyz\", \"zxyw\", \"xyzw\"]\n    word = \"zxy\"\n    print Solution().wordSearch(words, word)"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "def match(words, word1, word2):\n    if word1[0]!= word2[0]:\n        return False\n\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n    return True\n\ndef main():\n    words = [\"apple\", \"apricot\", \"banana\", \"banana\"]\n    word1 = \"apple\"\n    word2 = \"banana\"\n\n    print match(words, word1, word2)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "def match(word1, word2, words):\n    \"\"\"\n    Return True if two words are matched, otherwise return False.\n    \"\"\"\n    if word1[0] == word2[0]:\n        return match(word1[1:], word2[1:], words)\n    else:\n        return False\n\nif __name__ == '__main__':\n    words = [\"parrot\", \"bat\", \"rat\", \"rat\", \"rat\", \"rat\", \"rat\", \"rat\", \"rat\", \"rat\"]\n    print match(\"rat\", \"rat\", words)\n    print match(\"rat\", \"bat\", words)\n    print match(\"rat\", \"bat\", words)\n    print match(\"parrot\", \"parrot\", words)"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef find_pattern(words, pattern):\n    \"\"\"\n    :type words: List[str]\n    :type pattern: str\n    :rtype: List[int]\n    \"\"\"\n    n = len(words)\n    dp = defaultdict(list)\n    for i in range(n):\n        for j in range(n):\n            if j >= i:\n                if pattern[i] == words[i][j]:\n                    dp[i].append(j)\n    ret = []\n    for k in range(n):\n        if dp[k]:\n            ret.append(dp[k][0])\n    return ret\n\nif __name__ == '__main__':\n    words = [\"p\", \"pp\", \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"]\n    pattern = \"pp\"\n    print(find_pattern(words, pattern))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef get_matches(words, word1, word2):\n    '''\n    :type words: List[str]\n    :type word1: str\n    :type word2: str\n    :rtype: List[str]\n    '''\n    if word1 == word2:\n        return [word1]\n    if word1 == word2 + word1:\n        return [word1]\n    if word1[-1] == word2[0]:\n        if word1[-1] == word2[-1]:\n            return get_matches(words, word1[:-1], word2[1:])\n        else:\n            return get_matches(words, word1[:-1], word2)\n    return []\n\nif __name__ == '__main__':\n    words = ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']\n    print(get_matches(words, 'aa', 'a'))\n    print(get_matches(words, 'a', 'a'))\n    print(get_matches(words, 'aa', 'a'))\n    print(get_matches(words, 'aaa', 'a'))\n    print(get_matches(words, 'aaaa', 'a'))\n    print(get_matches(words, 'aaaaa', 'a'))\n    print(get_matches(words, 'a', 'aa'))\n    print(get_matches(words, 'a', 'aaa'))\n    print(get_matches(words, 'a', 'aaaa'))\n    print(get_matches(words, 'a', 'aaaaa'))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom itertools import groupby\nfrom operator import itemgetter\n\ndef match_words(words, p_word):\n    p_word = p_word.lower()\n    p_word_len = len(p_word)\n    word_list = []\n    for word in words:\n        if word.lower().startswith(p_word):\n            word_list.append(word)\n    return word_list\n\n\ndef main():\n    p_word = input()\n    p_word_len = len(p_word)\n    words = []\n    for line in open('words.txt'):\n        words.append(line.strip())\n    words.sort()\n    word_list = match_words(words, p_word)\n    print(word_list)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\ndef is_palindrome(word):\n    \"\"\"\n    >>> is_palindrome('')\n    False\n    >>> is_palindrome('a')\n    True\n    >>> is_palindrome('ab')\n    True\n    >>> is_palindrome('abc')\n    True\n    >>> is_palindrome('abb')\n    False\n    >>> is_palindrome('ababb')\n    False\n    >>> is_palindrome('ababbc')\n    True\n    \"\"\"\n    if len(word) < 2:\n        return False\n    for i in range(len(word) - 1):\n        if word[i]!= word[-1 - i]:\n            return False\n    return True\n\ndef is_palindrome_short(word):\n    \"\"\"\n    >>> is_palindrome_short('')\n    False\n    >>> is_palindrome_short('a')\n    True\n    >>> is_palindrome_short('ab')\n    True\n    >>> is_palindrome_short('abc')\n    True\n    >>> is_palindrome_short('abb')\n    False\n    >>> is_palindrome_short('ababb')\n    False\n    >>> is_palindrome_short('ababbc')\n    True\n    \"\"\"\n    if len(word) < 2:\n        return False\n    for i in range(len(word) - 1):\n        if word[i]!= word[-1 - i]:\n            return False\n    return True\n\ndef main():\n    test_list = [\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['a', 'b', 'c', 'd'],\n        ['"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef match(words, p):\n    \"\"\"\n    :type words: List[str]\n    :type p: str\n    :rtype: bool\n    \"\"\"\n    m = defaultdict(int)\n    for w in words:\n        if w[0] == p:\n            m[w[1]] += 1\n    return all(v == 1 for v in m.values())\n\nif __name__ == '__main__':\n    words = [\"apple\", \"apple\", \"apple\", \"banana\", \"banana\"]\n    p = \"a\"\n    print match(words, p)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef match(words, word1, word2):\n    if len(word1)!= len(word2):\n        return False\n\n    word_dict = {}\n    word_dict[word1] = True\n    word_dict[word2] = True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\ndef main():\n    words = [\"paul\", \"paul\", \"paul\", \"paul\"]\n    word1 = \"paul\"\n    word2 = \"paul\"\n    print(match(words, word1, word2))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def is_subword(s, t):\n    \"\"\"\n    Write a function is_subword(s, t) that returns True if s is a subword of t, False otherwise.\n    \"\"\"\n    return s[0] in t\n\ndef is_word_p(s):\n    \"\"\"\n    Write a function is_word_p(s) that returns True if s is a word starting with letter 'p', False otherwise.\n    \"\"\"\n    return s[0] == 'p'\n\ndef main():\n    \"\"\"\n    Write a main() function that takes a list of words as input and prints a list of words that are subwords of the input list.\n    \"\"\"\n    # Note: the solution below is ambiguous.\n    # The correct solution should be a function that takes a list of words as input and returns a list of subwords.\n    # The word \"p\" is a subword of the list of words \"abc\", \"pq\", \"abcdef\".\n    words = [\"abc\", \"pq\", \"abcdef\"]\n    subwords = [word for word in words if is_subword(word, \"abc\")]\n    print(subwords)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def is_substring(word1, word2):\n\treturn len(word1) >= len(word2) and word1.startswith(word2)\n\ndef is_match(word1, word2):\n\tif len(word1) == 0 or len(word2) == 0:\n\t\treturn False\n\tif len(word1) == len(word2):\n\t\treturn is_substring(word1, word2)\n\tif len(word1) < len(word2):\n\t\treturn is_substring(word1, word2)\n\treturn False\n\nif __name__ == '__main__':\n\twords = ['pizza', 'pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def word_match(word_list, query):\n    \"\"\"\n    :type word_list: List[str]\n    :type query: str\n    :rtype: bool\n    \"\"\"\n    return any(query in w for w in word_list)\n\ndef main():\n    word_list = [\"pandas\", \"are\", \"awesome\", \"words\"]\n    query = \"are\"\n    print(word_match(word_list, query))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def match(word1, word2):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :rtype: bool\n    \"\"\"\n    if len(word1) == 0 or len(word2) == 0:\n        return False\n    if word1[0]!= word2[0]:\n        return False\n    return match(word1[1:], word2[1:]) or word1[0] == word2[0]\n\n\nif __name__ == '__main__':\n    print(match('p', 'pp'))\n    print(match('pp', 'p'))\n    print(match('pp', 'pp'))\n    print(match('p', 'pp'))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "# Definition for a word:\n# class Word:\n#     def __init__(self, word):\n#         self.word = word\n#         self.index = 0\n\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        if not beginWord or not endWord or not wordList:\n            return 0\n        word1 = beginWord\n        word2 = endWord\n        level = 1\n        length = 0\n        while word1!= word2:\n            length += 1\n            if word1 == word2:\n                level += 1\n                word1 = wordList[length]\n                word2 = wordList[length]\n            else:\n                word1 = wordList[length]\n                word2 = wordList[length + 1]\n            if word1 == word2:\n                level += 1\n        return level"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "# import the modules\nimport sys\nfrom collections import defaultdict\n\n# create a dictionary to store the words in the list\nwords = defaultdict(set)\n\n# read the list of words from the input\nwith open(sys.argv[1], 'r') as f:\n    for line in f:\n        word = line.strip()\n        if word:\n            words[word].add('p')\n\n# create a dictionary to store the words in the list\n# the key is the first letter of the word, and the value is the set of all the words\n# that start with that first letter\n# e.g. words['p'].add('cat') will add 'cat' to the set of words that start with 'p'\nwords_set = defaultdict(set)\n\n# read the list of words from the input\nwith open(sys.argv[2], 'r') as f:\n    for line in f:\n        word = line.strip()\n        if word:\n            words_set[word[0]].add(word)\n\n# check each word in the list against the words in the list of words that start with the first letter\nfor key, value in words.items():\n    for word in value:\n        if word[0] in words_set:\n            print(word)"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def match(words, s):\n    if s[0]!= 'p':\n        return False\n    if len(s) < 3 or len(s) > 4:\n        return False\n    \n    for word in words:\n        if len(word)!= len(s):\n            continue\n        if word[0]!= s[1]:\n            continue\n        if word[1]!= s[2]:\n            continue\n        if word[2]!= s[3]:\n            continue\n        return True\n    return False\n\nif __name__ == '__main__':\n    words = [\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],\n        ['p', 'p', 'p'],"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "# Definition for a word:\n#     word: str\n#     def __init__(self, word):\n#         self.word = word\n#         self.isPalindrome = self.isPalindrome()\n\nclass Solution(object):\n    def match(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        if word1 == word2:\n            return True\n        if word1 == '' or word2 == '':\n            return False\n        if word1[0]!= word2[0]:\n            return False\n        return self.match(word1[1:], word2[1:])\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.match('', '')\n    print s.match('', 'a')\n    print s.match('', 'aa')\n    print s.match('a', 'a')\n    print s.match('a', 'aa')\n    print s.match('aa', 'aa')\n    print s.match('', 'ab')\n    print s.match('', 'abc')\n    print s.match('abc', 'abc')\n    print s.match('', 'bad')\n    print s.match('abcde', 'cde')"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def find_matches(word1, word2, words):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :type words: List[str]\n    :rtype: List[str]\n    \"\"\"\n    matches = []\n    for w in words:\n        if w.startswith(word1) and w.endswith(word2):\n            matches.append(w)\n    return matches\n\nif __name__ == '__main__':\n    words = [\"banana\", \"orange\", \"apple\", \"banana\", \"apple\", \"banana\", \"orange\", \"banana\"]\n    print(find_matches(\"apple\", \"banana\", words))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "# import time\n# start = time.time()\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if p == '':\n            return s == ''\n        elif p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s, p[1:]) or self.isMatch(s, p[1:])\n        elif p[-1] == '*':\n            return self.isMatch(s, p[:-1]) or self.isMatch(s, p[:-1]) or self.isMatch(s, p[:-1])\n        elif p[-1] == '?':\n            return self.isMatch(s, p[:-1])\n        else:\n            return s[0] == p[0] and self.isMatch(s[1:], p[1:])\n        # return s == p or s[0] == p[0] and self.isMatch(s[1:], p[1:])\n\n# print Solution().isMatch('aa', 'a')\n# print Solution().isMatch('aa', 'a*')\n# print Solution().isMatch('aa', 'a*')\n# print Solution().isMatch('aa', 'a*c')\n# print Solution().isMatch('aa', 'a*c*')\n# print Solution().isMatch('ab', 'a*c*')\n# print Solution().isMatch('ab', 'a*')\n# print Solution().isMatch('aab', 'c*a*b')\n# print Solution().isMatch('aab', 'c*a*b?')\n# print Solution().isMatch('aab', 'a*b?')\n# print Solution().isMatch('aab', '*c*a*b')\n# print Solution().isMatch('aab', '*c*a*b?')\n# print Solution().isMatch('aab', '*c*a*b?')\n# print Solution().isMatch('aabb', 'a*b*c')\n# print Solution().isMatch"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def is_palindrome(string):\n    \"\"\"\n    Write a function is_palindrome(string) that returns true if the string is a palindrome and returns false otherwise.\n    \"\"\"\n    # Write your code here\n    return string == string[::-1]\n\n\ndef word_match(word1, word2):\n    \"\"\"\n    Write a function word_match(word1, word2) that returns true if word1 and word2 are equal and returns false otherwise.\n    \"\"\"\n    # Write your code here\n    if is_palindrome(word1) and is_palindrome(word2):\n        return word1 == word2\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ('p', 'p'),\n        ('pppppp', 'pppppp'),\n        ('pppppppppppppppppppp', 'pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom functools import reduce\nimport re\n\ndef match(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    \n    pairs = defaultdict(int)\n    for i in range(len(word1)):\n        for j in range(len(word2)):\n            pairs[word1[i] + word2[j]] += 1\n    \n    return pairs\n\ndef main():\n    \n    words = open(\"words.txt\", \"r\").read().split()\n    \n    words_pairs = defaultdict(int)\n    for word1 in words:\n        for word2 in words:\n            if word1.startswith(word2):\n                words_pairs[word1] += 1\n                words_pairs[word2] += 1\n    \n    print reduce(lambda a,b: a + b, words_pairs.values())\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def pw_match(word1, word2, words):\n    if word1 == word2:\n        return True\n    else:\n        for i in range(len(word1)):\n            if word1[i] == 'p':\n                if pw_match(word2[i:], word1[i:], words):\n                    return True\n    return False\n\ndef main():\n    words = [\"pw\", \"p\", \"pp\", \"ppp\", \"pppp\"]\n    word1 = \"pw\"\n    word2 = \"pp\"\n    print pw_match(word1, word2, words)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "import re\n\ndef match_words(word_list, pattern):\n    match = re.match(pattern, word_list[0])\n    if match:\n        return word_list[1]\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    print(match_words([\"cat\", \"dog\", \"pig\"], \"p\"))\n    print(match_words([\"cat\", \"dog\", \"pig\"], \"g\"))\n    print(match_words([\"cat\", \"dog\", \"pig\"], \"pig\"))\n    print(match_words([\"cat\", \"dog\", \"pig\"], \"dog\"))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "import re\n\ndef match_words(words, word1, word2):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :rtype: bool\n    \"\"\"\n    if len(word1) > len(word2):\n        return False\n    if len(word1) == len(word2):\n        return word1 == word2\n    \n    if word1[0]!= word2[0]:\n        return False\n\n    match = re.match(r\"^(.+)\\1{1,2}$\", word1)\n    if match is None:\n        return False\n    if match.group(1)!= word2[1:]:\n        return False\n\n    return True\n\nif __name__ == '__main__':\n    words = [\"pizza\", \"pizzeria\", \"pizza\"]\n    assert(match_words(words, \"pizza\", \"pizza\") == True)\n    assert(match_words(words, \"pizza\", \"pizzeria\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizz\") == False)\n    assert(match_words(words, \"pizza\", \"pizz\") == False)\n    assert(match_words(words, \"pizza\", \"pizz\") == False)\n    assert(match_words(words, \"pizza\", \"pizzeria\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizzeria\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizza\") == False)\n    assert(match_words(words, \"pizza\", \"pizzeria\") == False)\n    assert(match_words(words, \"pizza\", \"pizza"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef match(words, pattern):\n    \"\"\"\n    :type pattern: str\n    :rtype: List[str]\n    \"\"\"\n    m = defaultdict(int)\n    for word in words:\n        m[word[0]] += 1\n    for c in pattern:\n        m[c] = max(m[c], m[c.lower()])\n    ans = []\n    for c in pattern:\n        if m[c] == 0:\n            continue\n        ans.append(c)\n        for i in range(1, m[c]):\n            ans.append(c.lower())\n    return ans\n\nif __name__ == '__main__':\n    words = [\"pizza\", \"zombies\", \"zombie\", \"pizza\"]\n    pattern = \"pizz\"\n    print(match(words, pattern))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "# Definition for a word:\n#     word: str\n#     def is_palindrome(self, s):\n#         \"\"\"\n#         Returns a boolean.\n#         :type s: str\n#         \"\"\"\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m = p.find('*')\n        if m == -1:\n            return s == p\n        s = s.strip()\n        p = p.strip()\n        if m > 0:\n            if m > len(s):\n                return False\n            if s[m:m+2]!= p[m:m+2]:\n                return False\n            return self.isMatch(s[:m], p[:m]) and self.isMatch(s[m+2:], p[m+2:])\n        return s == p"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef match(words, p):\n    d = defaultdict(int)\n    for w in words:\n        if w.lower().startswith(p.lower()):\n            d[w] += 1\n    return d\n\nif __name__ == \"__main__\":\n    words = [\"abcd\", \"abcd\", \"abcd\", \"abcd\", \"abcd\"]\n    p = \"abcd\"\n    print match(words, p)"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def wordPattern(self, pattern, str):\n        \"\"\"\n        :type pattern: List[str]\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        if len(pattern)!= len(str):\n            return False\n        for i in range(len(pattern)):\n            if pattern[i]!= str[i]:\n                return False\n        return True\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'abc'))\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'd'))\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'a'))\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'abcd'))\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'abcd'))\n    print(s.wordPattern(['a', 'ab', 'abc', 'd'], 'abcde'))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "# Solution 1:\ndef match(word1, word2, words):\n    if word1[0]!= word2[0]:\n        return False\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i] and word1[i]!= words[i-1]:\n            return False\n    return True\n\n# Solution 2:\ndef match(word1, word2, words):\n    if len(word1)!= len(word2):\n        return False\n    if word1[0]!= word2[0]:\n        return False\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n        if word1[i]!= words[i-1]:\n            return False\n    return True\n\n# Solution 3:\ndef match(word1, word2, words):\n    if len(word1)!= len(word2):\n        return False\n    if word1[0]!= word2[0]:\n        return False\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n        if word1[i]!= words[i-1]:\n            return False\n    return True\n\n# Solution 4:\ndef match(word1, word2, words):\n    if len(word1)!= len(word2):\n        return False\n    if word1[0]!= word2[0]:\n        return False\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n        if word1[i]!= words[i-1]:\n            return False\n    return True\n\n# Solution 5:\ndef match(word1, word2, words):\n    if len(word1)!= len(word2):\n        return False\n    if word1[0]!= word2[0]:\n        return False\n    for i in range(1, len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n        if word1[i]!= words"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\nwords = ['abcd', 'pqrs', 'xyz']\n\ndef word_matcher(word1, word2):\n    # Build a hash table of all possible word pairs.\n    word_pairs = defaultdict(int)\n    for word in words:\n        word_pairs[word] += 1\n    # Find the minimum number of words in word1 and word2.\n    min_num_words = min(len(word1), len(word2))\n    # Iterate through the hash table to find the minimum number of words.\n    for i in range(min_num_words):\n        # If the words in word1 and word2 are equal, return true.\n        if word_pairs[word1[i]] == word_pairs[word2[i]]:\n            return True\n    return False\n\nprint word_matcher('abcd', 'xyz')"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport string\nimport re\n\ndef match_word(word1, word2):\n    if len(word1)!= len(word2):\n        return False\n    \n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    words = []\n    with open('/home/lxz/Desktop/ch4/words.txt') as f:\n        for line in f:\n            words.append(line.strip())\n    \n    word1 = 'p'\n    word2 = 'p'\n    result = match_word(word1, word2)\n    print(result)"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def match(word1, word2, words):\n    if word1 == word2:\n        return True\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            if match(word1[:i], word2[:i], words):\n                return True\n            elif match(word1[i+1:], word2[i+1:], words):\n                return True\n    return False\n\ndef main():\n    words = [\n        \"apple\",\n        \"ball\",\n        \"banana\",\n        \"cherry\",\n        \"dog\",\n        \"fish\",\n        \"flower\",\n        \"horse\",\n        \"kitten\",\n        \"mouse\",\n        \"pig\",\n        \"rat\",\n        \"sheep\",\n        \"snake\",\n        \"turtle\"\n    ]\n    word1 = \"apple\"\n    word2 = \"ball\"\n    print(match(word1, word2, words))\n    word1 = \"banana\"\n    word2 = \"cherry\"\n    print(match(word1, word2, words))\n    word1 = \"dog\"\n    word2 = \"fish\"\n    print(match(word1, word2, words))\n    word1 = \"flower\"\n    word2 = \"horse\"\n    print(match(word1, word2, words))\n    word1 = \"pig\"\n    word2 = \"rat\"\n    print(match(word1, word2, words))\n    word1 = \"sheep\"\n    word2 = \"snake\"\n    print(match(word1, word2, words))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def match(w1, w2, wordList):\n    if w1[0]!= w2[0]:\n        return False\n    if w1[1:] == w2[1:]:\n        return True\n    return match(w1[1:], w2[1:], wordList)\n\n#test\n#print match('', '', [])\n#print match('a', '', [])\n#print match('', 'b', [])\n#print match('a', 'b', [])\n#print match('bb', '', [])\n#print match('bb', 'b', [])\n#print match('bb', 'b', ['a', 'b'])\n#print match('abb', 'b', ['a', 'b'])\n#print match('bb', 'b', ['a', 'b'])\n#print match('abb', 'bb', ['a', 'b'])\n#print match('abb', 'bb', ['a', 'bb'])\n#print match('abb', 'bb', ['a', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n#print match('abb', 'bb', ['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport re\n\ndef match(words, p, q):\n    # print p\n    # print q\n    p = p.lower()\n    q = q.lower()\n    if p[0]!= q[0]:\n        return False\n    if p[0] == q[0]:\n        # print p[0]\n        return p == q\n    # print p[1:], q[1:]\n    if p[1:]!= q[1:]:\n        return False\n    if p[1:] == q[1:]:\n        # print p[1:], q[1:]\n        return True\n\n# words = ['abc', 'aac', 'aac', 'aac', 'abc', 'abc', 'abc', 'abc']\n# p = 'a'\n# q = 'c'\n# print match(words, p, q)\n\n# words = ['abc', 'aac', 'aac', 'aac', 'abc', 'abc', 'abc', 'abc']\n# p = 'a'\n# q = 'c'\n# print match(words, p, q)\n\n# words = ['abc', 'aac', 'aac', 'aac', 'abc', 'abc', 'abc', 'abc']\n# p = 'a'\n# q = 'c'\n# print match(words, p, q)\n\nwords = ['abc', 'aac', 'aac', 'aac', 'abc', 'abc', 'abc', 'abc']\np = 'a'\nq = 'c'\nprint match(words, p, q)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "import collections\nimport itertools\n\ndef pwl_match(word_list, p):\n    if p not in word_list:\n        return False\n    return any(word[0] == p for word in word_list)\n\ndef pwl_match_p(word_list, p):\n    return any(word[0] == p for word in word_list)\n\ndef pwl_match_q(word_list, q):\n    return any(word[0] == q for word in word_list)\n\ndef pwl_match_p_and_q(word_list, p, q):\n    return any(word[0] == p or word[0] == q for word in word_list)\n\ndef pwl_match_p_or_q(word_list, p, q):\n    return any(word[0] == p or word[0] == q for word in word_list)\n\ndef pwl_match_p_and_q_or_q_and_p(word_list, p, q):\n    return any(word[0] == p or word[0] == q for word in word_list) and any(word[0] == p or word[0] == q for word in word_list)\n\ndef pwl_match_p_and_q_or_q_and_p_or_q(word_list, p, q):\n    return any(word[0] == p or word[0] == q for word in word_list) and any(word[0] == p or word[0] == q for word in word_list) or any(word[0] == p or word[0] == q for word in word_list)\n\ndef pwl_match_p_or_q_or_p_and_q_or_q(word_list, p, q):\n    return any(word[0] == p or word[0] == q for word in word_list) or any(word[0] == p or word[0] == q for word in word_list) or any(word[0] == p or word[0] == q for word in word_list)\n\ndef pwl_match_"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\nwords = [\"w\", \"wo\", \"wor\", \"woof\", \"waggle\", \"wagglepig\"]\n\ndef match(word1, word2):\n    if word1[0]!= word2[0]:\n        return False\n    dp = defaultdict(lambda: 0)\n    for i in range(1, len(word1)+1):\n        for j in range(1, len(word2)+1):\n            if word1[:i] == word2[:j]:\n                dp[i, j] = dp[i-1, j-1] + 1\n            else:\n                dp[i, j] = max(dp[i-1, j], dp[i, j-1])\n    return dp[len(word1), len(word2)] > 0\n\n#print match(\"w\", \"w\")\nprint match(\"p\", \"p\")"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "def match(word1, word2, words):\n\t# words = [word1, word2,...]\n\tif word1 == word2:\n\t\treturn True\n\telif word1 == '' or word2 == '':\n\t\treturn False\n\telif word1[0]!= word2[0]:\n\t\treturn False\n\telse:\n\t\treturn match(word1[1:], word2[1:], words)\n\n\ndef test():\n\t# word1 = ['p', 'g', 'a', 'n', 'e']\n\t# word2 = ['p', 'g', 'e', 'n', 'e']\n\t# words = [word1, word2,...]\n\t# print(match(word1, word2, words))\n\tword1 = ['p', 'g', 'a', 'n', 'e']\n\tword2 = ['p', 'g', 'e', 'n', 'e']\n\twords = [word1, word2,...]\n\tprint(match(word1, word2, words))\n\n\nif __name__ == '__main__':\n\ttest()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport re\n\n\ndef match_two_words(words, pattern):\n    \"\"\"\n    :type words: List[str]\n    :type pattern: str\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    for word in words:\n        if re.match(pattern, word):\n            result.append(word)\n    return result\n\n\nif __name__ == '__main__':\n    words = [\n        \"peter\", \"peter\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\", \"peter\", \"and\", \"and\",\n        \""
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "import re\n\ndef word_match(word, words):\n    \"\"\"\n    :type word: str\n    :type words: list\n    :rtype: bool\n    \"\"\"\n    if len(word) < 2:\n        return False\n    regex = re.compile('^p{0,1}%s$' % word)\n    return any(regex.match(w) for w in words)\n\nwords = ['peter', 'peter', 'peter', 'peter', 'peter', 'peter', 'peter', 'peter', 'peter']\n\nprint word_match('peter', words)"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import collections\n\n# your code goes here\n#!/usr/bin/python\n\ndef match_words(words, word1, word2):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :rtype: bool\n    \"\"\"\n    word_1_index = 0\n    word_2_index = 0\n    while word_1_index < len(word1) and word_2_index < len(word2):\n        if word_1[word_1_index] == word2[word_2_index]:\n            word_1_index += 1\n            word_2_index += 1\n        elif word_1[word_1_index] < word2[word_2_index]:\n            word_1_index += 1\n        else:\n            return False\n    if word_1_index == len(word1) and word_2_index == len(word2):\n        return True\n    else:\n        return False\n\n# test cases\nwords = [\"cat\", \"bat\", \"rat\", \"rat\"]\nword1 = \"rat\"\nword2 = \"cat\"\nprint match_words(words, word1, word2)\n\nwords = [\"cat\", \"bat\", \"rat\", \"rat\", \"rat\"]\nword1 = \"rat\"\nword2 = \"cat\"\nprint match_words(words, word1, word2)\n\nwords = [\"cat\", \"bat\", \"rat\", \"rat\", \"rat\"]\nword1 = \"rat\"\nword2 = \"rat\"\nprint match_words(words, word1, word2)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import sys\n\ndef match(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    \n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n    \n    return True\n\nif __name__ == \"__main__\":\n    f = open(sys.argv[1], 'r')\n    words = f.read().splitlines()\n    f.close()\n    \n    for word in words:\n        if match(word, sys.argv[2]):\n            print word"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "# https://www.youtube.com/watch?v=y-Xg3l_DcqY\n\ndef is_match(word, pattern):\n    if len(word) < len(pattern):\n        return False\n    if len(word) == len(pattern):\n        return word == pattern\n    for i in range(len(word)):\n        if word[i]!= pattern[i]:\n            return False\n    return True\n\ndef main():\n    s = \"pizza\"\n    p = \"pppp\"\n    print is_match(s, p)\n    s = \"pppppppp\"\n    p = \"pppp\"\n    print is_match(s, p)\n    s = \"pppp\"\n    p = \"pppppppp\"\n    print is_match(s, p)\n    s = \"pppppppppp\"\n    p = \"pppppppppp\"\n    print is_match(s, p)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "import re\n\ndef match_words(words, pattern):\n    # write your code here\n    pattern = pattern.lower()\n    pattern = re.compile(pattern)\n    match = [word for word in words if pattern.match(word)]\n    return match\n\nwords = [\"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"the\", \"lazy\", \"dog\"]\n\nprint match_words(words, \"the\")"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def match(word_list, p):\n    p_len = len(p)\n    for word in word_list:\n        if word.startswith(p):\n            return True\n    return False\n\nif __name__ == '__main__':\n    word_list = ['abcd', 'abcd', 'abcde', 'abcde', 'abcde']\n    p = 'a'\n    print match(word_list, p)"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def match_pattern(words, pattern):\n    \"\"\"\n    Return the number of matching words.\n    \"\"\"\n    if not pattern:\n        return len(words)\n    if not words:\n        return 0\n    if words[0][0]!= pattern[0]:\n        return 0\n    if not pattern[0]:\n        return 1\n    return match_pattern(words[1:], pattern[1:]) + 1\n\nwords = [\n    \"apple\",\n    \"apple\",\n    \"apple\",\n    \"orange\",\n    \"orange\",\n    \"banana\",\n    \"banana\",\n    \"banana\",\n]\n\nprint(match_pattern(words, \"p\"))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def match_p_words(words, p):\n    \"\"\"\n    :type words: List[str]\n    :type p: str\n    :rtype: int\n    \"\"\"\n    def dfs(word, i):\n        if i == len(word):\n            return len(p)\n        for j in range(i, len(word)):\n            if word[j] == p[i]:\n                return dfs(word, j+1)\n        return -1\n    return dfs(words[0], 0)"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import sys\n\nwords = ['apple', 'app', 'ap', 'pizza', 'pp', 'ppp', 'c', 'ccc', 'cccc', 'ab', 'abb', 'abab', 'ababb']\n\ndef match(word):\n    # print(word)\n    for i in range(len(word)):\n        if word[i]!= word[0]:\n            return False\n    return True\n\n\ndef main():\n    print(match(words))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef word_matching(word_list, p):\n    \"\"\"\n    :type word_list: List[str]\n    :type p: str\n    :rtype: List[int]\n    \"\"\"\n    word_dict = defaultdict(list)\n    for w in word_list:\n        if w[0] == p:\n            word_dict[w].append(w)\n    return [len(w) for w in word_dict[p]]\n\nif __name__ == \"__main__\":\n    print(word_matching(['pizza', 'pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/word-search/discuss/17892/Python-Solution\n\n# TLE\n\nclass Solution:\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {boolean}\n    def exist(self, words, word1, word2):\n        # DP\n        # word1 = [word1]\n        # word2 = [word2]\n        # result = False\n        # for i in range(len(word1)):\n        #     for j in range(len(word2)):\n        #         if i < len(word1) - 1 and j < len(word2) - 1 and word1[i] == word2[j] and word1[i+1] == word2[j+1]:\n        #             result = True\n        #             break\n        # return result\n\n        # DP\n        # word1 = [word1]\n        # word2 = [word2]\n        # result = False\n        # for i in range(len(word1)):\n        #     for j in range(len(word2)):\n        #         if i < len(word1) - 1 and j < len(word2) - 1 and word1[i] == word2[j] and word1[i+1] == word2[j+1]:\n        #             result = True\n        #             break\n        # return result\n\n        # DP\n        # word1 = [word1]\n        # word2 = [word2]\n        # result = False\n        # for i in range(len(word1)):\n        #     for j in range(len(word2)):\n        #         if i < len(word1) - 1 and j < len(word2) - 1 and word1[i] == word2[j] and word1[i+1] == word2[j+1]:\n        #             result = True\n        #             break\n        # return result\n\n        # DP\n        # word1 = [word1]\n        # word2 = [word2]\n        # result = False\n        # for i in range("
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        # DFS, no loop\n        if not s:\n            return p == ''\n        if not p:\n            return s == ''\n        # DFS, loop\n        if s[0] == p[0]:\n            return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p)\n        else:\n            return False\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.isMatch('', '') is True\n    assert s.isMatch('', 'a') is False\n    assert s.isMatch('a', '') is False\n    assert s.isMatch('aa', '') is False\n    assert s.isMatch('', 'a*') is False\n    assert s.isMatch('a', 'a*') is True\n    assert s.isMatch('aa', 'a*') is True\n    assert s.isMatch('aa', 'a*a') is False\n    assert s.isMatch('ab', 'a*') is False\n    assert s.isMatch('aab', 'c*a*b') is True\n    assert s.isMatch('ab', 'c*a*b') is False\n    assert s.isMatch('aab', 'c*a*b') is False\n    assert s.isMatch('ab', 'c*a*b') is False\n    assert s.isMatch('aab', 'c*a*b') is True\n    assert s.isMatch('ab', 'c*a*b') is True\n    assert s.isMatch('aab', 'c*a*b') is True\n    assert s.isMatch('ab', 'c*a*b') is True\n    assert s.isMatch('aab', 'c*a*b') is True\n    assert s.isMatch('ab', 'c*a*b') is True\n    assert s.isMatch('aab', 'c*a*b') is True\n    assert s.isMatch('ab"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# https://oj.leetcode.com/problems/word-search/discuss/1148/C++-Dynamic-Programming-Solution-with-DFS\n# https://discuss.leetcode.com/topic/7024/c-java-dp-solution-with-dfs\nclass Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if not board:\n            return False\n        if not word:\n            return True\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == word[0]:\n                    self.exist(board[i][j:], word[1:])\n                    if self.exist(board[i][j+1:], word[1:]):\n                        return True\n        return False\n\n\nif __name__ == '__main__':\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits', 'rabbit', 'rabbitmq'], 'rabbit'))\n    print(Solution().exist(['rabbits',"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def is_palindrome(word):\n    if len(word) == 0:\n        return False\n    return word == word[::-1]\n\ndef is_palindrome_rec(word):\n    if len(word) == 0:\n        return False\n    if len(word) == 1:\n        return True\n    return is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:])\n\ndef is_palindrome_rec(word):\n    if len(word) == 0:\n        return False\n    if len(word) == 1:\n        return True\n    return is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:]) or \\\n           is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:])\n\ndef is_palindrome_rec(word):\n    if len(word) == 0:\n        return False\n    if len(word) == 1:\n        return True\n    return is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:]) or \\\n           is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:])\n\ndef is_palindrome_rec(word):\n    if len(word) == 0:\n        return False\n    if len(word) == 1:\n        return True\n    return is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:]) or \\\n           is_palindrome(word[0:len(word)//2]) and is_palindrome(word[len(word)//2:])\n\ndef is_palindrome_rec(word):\n    if len(word) == 0:\n        return False\n    if len(word) == 1:\n        return True\n    return is_palindrome(word"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    def wordPattern(self, pattern, words):\n        \"\"\"\n        :type pattern: str\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        for word in words:\n            if not self.check(pattern, word):\n                return False\n        return True\n\n    def check(self, pattern, word):\n        if pattern == word:\n            return True\n        if len(pattern)!= len(word):\n            return False\n        for i in range(len(pattern)):\n            if pattern[i]!= word[i]:\n                return False\n        return True\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/word-pattern/solution/\n\n# 1ms 100%\nclass Solution {\n    public boolean wordPattern(String pattern, String[] words) {\n        return wordPattern(pattern, words, 0);\n    }\n\n    private boolean wordPattern(String pattern, String[] words, int index) {\n        if (index == words.length) return true;\n        if (index == words.length - 1) return pattern.equals(words[index]);\n\n        for (int i = index; i < words.length; i++) {\n            if (wordPattern(pattern, words, i + 1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n'''"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        if beginWord == endWord:\n            return 0\n        dict = {}\n        for i in range(len(endWord)):\n            dict[endWord[:i]] = 0\n        dict[beginWord] = 1\n        queue = [beginWord]\n        while queue:\n            word = queue.pop(0)\n            for i in range(len(word)):\n                for j in range(i + 1, len(word)):\n                    new_word = word[:i] + word[j:]\n                    if new_word in wordList and new_word not in dict:\n                        dict[new_word] = dict[word] + 1\n                        queue.append(new_word)\n        return dict[endWord]\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# 12ms 100%\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        int[] dict = new int[26];\n        for (int i = 0; i < beginWord.length(); i++) {\n            dict[beginWord.charAt(i) - 'a'] = 1;\n        }\n        dict[endWord.charAt(0) - 'a'] = 0;\n\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(beginWord);\n        int count = 0;\n        while (!queue.isEmpty()) {\n            String word = queue.poll();\n            for (int i = 0; i < word.length(); i++) {\n                String newWord = word.substring(0, i) + word.substring(i + 1);\n                if (newWord.equals(endWord)) {"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def match_words(words, word1, word2):\n    \"\"\"\n    :type words: List[str]\n    :type word1: str\n    :type word2: str\n    :rtype: bool\n    \"\"\"\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n# Your Solution\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n\n# Your Solution\ndef match_words(words, word1, word2):\n    if word1 == word2:\n        return True\n\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n\n    return True\n\n\n# Your"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "import unittest\n\n# pylint: disable=missing-docstring\n\nclass Solution(object):\n    def isWordExist(self, words, word):\n        \"\"\"\n        :type words: List[str]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if word.lower() in words:\n            return True\n        for i in range(len(word)):\n            if word[:i] in words:\n                return True\n        return False\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/word-search/solution/\n\n# 1ms 100%\nclass Solution {\n    public boolean isWordExist(List<String> dict, String word) {\n        int index = word.length() - 1;\n        while (index >= 0) {\n            if (dict.contains(word.substring(index))) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public boolean isWordExist(List<String> dict, String word) {\n        for (String s : dict) {\n            if (s.startsWith(word)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n'''"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def wordSearch(self, words, word):\n        \"\"\"\n        :type words: List[str]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        words = [word] + words\n        for i in xrange(len(words)):\n            if word in words[:i] or word in words[i+1:]:\n                return True\n        return False\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/word-search/solution/\n\n# DFS\n# 2ms 100%\nclass Solution {\n    public boolean wordSearch(List<String> words, String word) {\n        return dfs(words, word, 0, 0);\n    }\n\n    private boolean dfs(List<String> words, String word, int i, int j) {\n        if (i == words.size()) return true;\n        if (j == word.length()) return true;\n        if (i == words.size() || j == word.length()) return false;\n\n        if (word.charAt(j)!= words.get(i).charAt(j)) return false;\n        return dfs(words, word, i+1, j+1) || dfs(words, word, i+1, j) || dfs(words, word, i, j+1);\n    }\n}\n\n# DP\n# 1ms 100%\nclass Solution {\n    public boolean wordSearch(List<String> words, String word) {\n        int[][] dp = new int[word.length()+1][words.size()+1];\n        for (int i = 0; i < dp[0].length; i++) {\n            dp[0][i] = i == 0? 0 : 1;\n        }\n        for (int i = 1; i < dp.length; i++) {\n            dp[i][0] = i == dp."
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "def is_match(word, pattern):\n    word_length = len(word)\n    pattern_length = len(pattern)\n    if word_length < pattern_length:\n        return False\n    for i in range(pattern_length):\n        if pattern[i]!= '*':\n            if word[i]!= pattern[i]:\n                return False\n    return True\n\ndef match_words(word_list, pattern):\n    match_list = []\n    for word in word_list:\n        if is_match(word, pattern):\n            match_list.append(word)\n    return match_list\n\nif __name__ == \"__main__\":\n    pattern = \"p*\"\n    word_list = [\"a\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"ag\", \"ah\", \"ai\", \"aj\", \"ak\", \"al\", \"am\", \"an\", \"ap\", \"aq\", \"ar\", \"as\", \"at\", \"au\", \"av\", \"aw\", \"ax\", \"ay\", \"az\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"bg\", \"bh\", \"bi\", \"bj\", \"bk\", \"bl\", \"bm\", \"bn\", \"bp\", \"bq\", \"br\", \"bs\", \"bt\", \"bv\", \"bw\", \"bx\", \"by\", \"bz\", \"ca\", \"cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"cg\", \"ch\", \"ci\", \"cj\", \"ck\", \"cl\", \"cm\", \"cn\", \"co\", \"cp\", \"cq\", \"cr\", \"cs\", \"ct\", \"cu\", \"cv\", \"cw\", \"cx\", \"cy\", \"cz\", \"da\", \"db\", \"dc\", \"dd\", \"de\", \"df\", \"dg\", \"dh\", \"di\", \"dj\", \"dk\", \"dl\", \"dm\", \"dn\", \"do\", \"dp\", \"dq\", \"dr\", \"ds\", \"dt\", \"du\", \"dv\", \"dw\", \"dx\", \"dy\", \"dz\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \"eg\", \"eh\", \""
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/word-search-ii/description/\n# @author: Chauncey\n\nclass Solution:\n    # @return a boolean\n    def wordSearch(self, words, word):\n        # write your code here\n        if not words or not word:\n            return False\n\n        n = len(words)\n        m = len(word)\n        i = j = 0\n        while i < n and j < m:\n            if word[j] == words[i][j]:\n                j += 1\n            else:\n                i += 1\n        return i == n and j == m\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.wordSearch(['abcd','pq','qwe'], 'p')\n    print s.wordSearch(['abcd','pq','qwe'], 'qq')\n    print s.wordSearch(['abcd','pq','qwe'], 'r')\n    print s.wordSearch(['abcd','pq','qwe'], 'pq')\n    print s.wordSearch(['abcd','pq','qwe'], 'qqr')\n    print s.wordSearch(['abcd','pq','qwe'], 'qwe')"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef match(word, words):\n    \"\"\"\n    :type word: str\n    :type words: List[str]\n    :rtype: bool\n    \"\"\"\n    if word == \"\":\n        return False\n    if word[0] == \"p\":\n        return True\n    if word[0] == \"q\":\n        return False\n    if word[0] == \"r\":\n        return False\n    if word[0] == \"s\":\n        return False\n    if word[0] == \"t\":\n        return False\n    if word[0] == \"u\":\n        return False\n    if word[0] == \"v\":\n        return False\n    if word[0] == \"w\":\n        return False\n    if word[0] == \"x\":\n        return False\n    if word[0] == \"y\":\n        return False\n    if word[0] == \"z\":\n        return False\n    if word[0] == \"0\":\n        return False\n    if word[0] == \"1\":\n        return False\n    if word[0] == \"2\":\n        return False\n    if word[0] == \"3\":\n        return False\n    if word[0] == \"4\":\n        return False\n    if word[0] == \"5\":\n        return False\n    if word[0] == \"6\":\n        return False\n    if word[0] == \"7\":\n        return False\n    if word[0] == \"8\":\n        return False\n    if word[0] == \"9\":\n        return False\n    if word[0] == \"a\":\n        return False\n    if word[0] == \"b\":\n        return False\n    if word[0] == \"c\":\n        return False\n    if word[0] == \"d\":\n        return False\n    if word[0] == \"e\":\n        return False\n    if word[0] == \"f\":\n        return False\n    if word[0] == \"g\":\n        return False\n    if word[0] == \"h\":\n        return False\n    if word[0] == \"i\":\n        return False\n    if word[0"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/word-search/problem\n# Using the list of words and a dictionary to map words to their index\n# Example:\n# words = [\"cat\", \"bat\", \"rat\", \"cat\", \"rat\", \"rat\"]\n# word_map = {\n#     \"cat\": 0,\n#     \"bat\": 1,\n#     \"rat\": 2\n# }\n# Given word_list = [\"rat\", \"cat\", \"bat\"], return 1\n# Given word_list = [\"rat\", \"cat\", \"rat\"], return 2\n# Given word_list = [\"rat\", \"cat\", \"bat\"], return 0\n\n# Note:\n# The length of word_list and word_map will not exceed 100.\n# The length of word_list and word_map will be the same.\n# word_list and word_map will not contain duplicate words.\n# If there is a tie, return the first index that you encounter.\n\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Solution(object):\n    def wordSearch(self, wordList, wordMap):\n        \"\"\"\n        :type wordList: List[str]\n        :type wordMap: Dict[str, int]\n        :rtype: int\n        \"\"\"\n        if not wordList or not wordMap:\n            return -1\n\n        word_list = deque(wordList)\n\n        while word_list:\n            word = word_list.popleft()\n            if word in wordMap:\n                return wordMap[word]\n\n            for i in range(len(word)):\n                word_list.append(word[:i] + word[i + 1:])\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.wordSearch([\"rat\", \"cat\", \"bat\"], {\n        \"rat\": 0,\n        \"cat\": 1,\n        \"bat\": 2\n    })\n    print solution.wordSearch([\"rat\", \"cat\", \"bat\"], {\n        \"rat\": 0,\n        \"bat\": 1,\n        \"cat\": 2\n    })\n    print solution.wordSearch([\"rat\", \"cat\", \"bat\"], {\n        \"rat\": 0"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        t = TreeNode()\n        for i in range(len(s)):\n            if i == len(p):\n                return True\n            if p[i] == '*':\n                t.left = t.right = TreeNode()\n            else:\n                if p[i]!= s[i]:\n                    return False\n                t.left = t.right = TreeNode()\n            if i < len(s) - 1:\n                if p[i]!= s[i+1]:\n                    t.left.val = t.right.val = p[i]\n                    t.left.left = t.right.right = TreeNode()\n                else:\n                    t.left.val = t.right.val = p[i]\n                    t.left.right = t.right.right = TreeNode()\n            if i < len(s) - 1:\n                if p[i]!= s[i+1]:\n                    t.left.left.val = t.right.right.val = p[i]\n                    t.left.left.left = t.right.right.right = TreeNode()\n                else:\n                    t.left.left.val = t.right.right.val = p[i]\n                    t.left.left.right = t.right.right.right = TreeNode()\n        if t.left.val!= p[len(p)-1]:\n            return False\n        if t.right.val!= p[len(p)-1]:\n            return False\n        return True\n\n\nif __name__ == \"__main__\":\n    assert Solution().isMatch(\"aa\", \"a*\") == True\n    assert Solution().isMatch(\"aa\", \"*a\") == False\n    assert Solution().isMatch(\"aa\", \"a*a\") == False\n    assert Solution().isMatch(\"aa\", \"aa\") == True\n    assert Solution()."
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from collections import Counter\nfrom functools import reduce\n\ndef match_words(word1, word2, words):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :type words: list\n    :rtype: bool\n    \"\"\"\n    if len(word1) == 0 or len(word2) == 0:\n        return False\n    if word1[0] == 'p' and word2[0]!= 'p':\n        return False\n    if word2[0] == 'p' and word1[0]!= 'p':\n        return False\n    if word1[0]!= 'p':\n        return match_words(word1[1:], word2, words)\n    if word2[0]!= 'p':\n        return match_words(word1, word2[1:], words)\n    if len(word1) == 1:\n        return word2 == words[0]\n    if len(word2) == 1:\n        return word1 == words[0]\n    if len(word1) > 1 and len(word2) > 1:\n        if word1[0] == word2[0]:\n            return match_words(word1[1:], word2[1:], words)\n        elif word1[1] == word2[1]:\n            return match_words(word1[2:], word2[2:], words)\n        elif word1[0] == word2[0]:\n            return match_words(word1[1:], word2[1:], words)\n        elif word1[1] == word2[1]:\n            return match_words(word1[2:], word2[2:], words)\n    return False\n\ndef match_words(word1, word2, words):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :type words: list\n    :rtype: bool\n    \"\"\"\n    if len(word1) == 0 or len(word2) == 0:\n        return False\n    if word1[0] == 'p' and word2[0]!= 'p':\n        return False\n    if word2["
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "def match_words(words, p_word):\n    \"\"\"\n    :type words: List[str]\n    :type p_word: str\n    :rtype: List[bool]\n    \"\"\"\n    p_word = p_word.lower()\n    if p_word not in words:\n        return [False]\n    return [word.lower() == p_word for word in words if word.lower()[0] == p_word[0]]\n\n# Your Solution here"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {boolean}\n    def isMatch(self, words, word1, word2):\n        if word1 == \"\" and word2 == \"\":\n            return True\n        if word1 == \"\" or word2 == \"\":\n            return False\n        if word1[0]!= word2[0]:\n            return False\n        return self.isMatch(words, word1[1:], word2[1:])\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    words = [\"a\", \"b\", \"c\", \"abc\"]\n    print(sol.isMatch(words, \"\", \"abc\"))\n    print(sol.isMatch(words, \"a\", \"a\"))\n    print(sol.isMatch(words, \"\", \"\"))\n    print(sol.isMatch(words, \"ab\", \"c\"))\n    print(sol.isMatch(words, \"ab\", \"bc\"))\n    print(sol.isMatch(words, \"abc\", \"cba\"))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def is_p_word(words, p_word):\n    if len(p_word) > len(words):\n        return False\n    for i in range(len(p_word)):\n        if p_word[i]!= words[i]:\n            return False\n    return True\n\ndef is_p_word_1(words, p_word):\n    for i in range(len(p_word)):\n        if p_word[i]!= words[i]:\n            return False\n    return True\n\ndef is_p_word_2(words, p_word):\n    for i in range(len(p_word)):\n        if p_word[i]!= words[i]:\n            return False\n    return True\n\ndef is_p_word_3(words, p_word):\n    if len(p_word) > len(words):\n        return False\n    for i in range(len(p_word)):\n        if p_word[i]!= words[i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    words = [\"hello\", \"hell\", \"hellooo\", \"p\", \"pp\"]\n    p_word = \"hell\"\n    print(is_p_word(words, p_word))\n    print(is_p_word_1(words, p_word))\n    print(is_p_word_2(words, p_word))\n    print(is_p_word_3(words, p_word))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import re\n\n\ndef find_word(list_of_words, word):\n    return next((word for word in list_of_words if word == word), None)\n\n\ndef match_words(list_of_words, word):\n    # if word not in list_of_words\n    if not word in list_of_words:\n        return 0\n\n    # if word matches with any other word in list_of_words\n    if list_of_words.count(word) > 1:\n        return 0\n\n    # if word matches with any other word in list_of_words\n    if list_of_words.count(word) == 1:\n        return 1\n\n    # if word matches with any other word in list_of_words\n    if list_of_words.count(word) == 0:\n        return 0\n\n\ndef main():\n    list_of_words = [\"pizza\", \"pepperoni\", \"banana\", \"apple\"]\n    word = \"pizza\"\n\n    result = match_words(list_of_words, word)\n    print(\"result = {}\".format(result))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def match_two(words, word_1, word_2):\n    \"\"\"\n    :type words: List[str]\n    :type word_1: str\n    :type word_2: str\n    :rtype: bool\n    \"\"\"\n    words = list(words)\n    if len(word_1)!= len(word_2):\n        return False\n    for i in range(len(word_1)):\n        if words[i]!= word_1[i] and words[i]!= word_2[i]:\n            return False\n    return True\n\n\nclass Solution:\n    def matchTwoWords(self, words: List[str], word_1: str, word_2: str) -> bool:\n        for i in range(len(words)):\n            if match_two(words, word_1, word_2):\n                return True\n        return False"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "import collections\n\ndef is_palindrome(word):\n    \"\"\"\n    :type word: str\n    :rtype: bool\n    \"\"\"\n    word = list(word)\n    word.reverse()\n    return word == word[::-1]\n\ndef is_palindrome_list(word_list):\n    word_list = list(word_list)\n    word_list.reverse()\n    return word_list == word_list[::-1]\n\ndef is_palindrome_dict(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_2(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_3(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_4(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_5(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_6(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_7(word_dict):\n    word_dict = dict(word_dict)\n    word_dict.pop('p')\n    return word_dict == word_dict[::-1]\n\ndef is_palindrome_dict_8(word_dict):"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "import re\n\ndef match_p(word_list, target):\n    \"\"\"\n    :type word_list: List[str]\n    :type target: str\n    :rtype: bool\n    \"\"\"\n    pattern = r'^p(.)+\\1$'\n    for word in word_list:\n        match = re.match(pattern, word)\n        if match and match.group(1) == target:\n            return True\n    return False\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert match_p([\"penguin\", \"penguins\", \"penguin penguins\", \"penguin penguin penguins\"], \"penguin\"), \"penguin\"\n    assert not match_p([\"penguin\", \"penguin penguin\", \"penguin penguin penguins\", \"penguin penguin penguin penguins\"], \"penguin\"), \"penguin\"\n    assert match_p([\"penguin\", \"penguin penguin\", \"penguin penguin penguins\", \"penguin penguin penguin penguins\"], \"penguin penguin penguin penguins\"), \"penguin penguin penguin penguins\"\n    assert not match_p([\"penguin\", \"penguin penguin\", \"penguin penguin penguins\", \"penguin penguin penguin penguins\"], \"penguin penguin penguin penguin penguins\"), \"penguin penguin penguin penguins\"\n    assert not match_p([\"penguin\", \"penguin penguin\", \"penguin penguin penguins\", \"penguin penguin penguin penguins\"], \"penguin penguin penguin penguin penguins\"), \"penguin penguin penguin penguins\"\n    assert not match_p([\"penguin\", \"penguin penguin\", \"penguin penguin penguins\", \"penguin penguin penguin penguins\"], \"penguin penguin penguin penguin penguins\"), \"penguin penguin penguin penguins\""
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "import unittest\nimport sys\n\n# @include\ndef is_word_match(word_list, word1, word2):\n    if len(word1)!= len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i]!= word2[i]:\n            return False\n    return True\n# @exclude\n\n\nclass Test(unittest.TestCase):\n    def test_is_word_match(self):\n        self.assertTrue(is_word_match([\"hello\", \"world\"], \"hello\", \"world\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"hello\", \"worldhello\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"hello\", \"worldworld\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"hello\", \"worldhellohello\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"hello\", \"worldworldworld\"))\n        self.assertTrue(is_word_match([\"hello\", \"world\"], \"world\", \"world\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"world\", \"hello\"))\n        self.assertTrue(is_word_match([\"hello\", \"world\"], \"world\", \"worldhello\"))\n        self.assertFalse(is_word_match([\"hello\", \"world\"], \"world\", \"worldworld\"))\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass Solution:\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {boolean}\n    def isAnagram(self, words, word1, word2):\n        if len(word1)!= len(word2):\n            return False\n        dict1 = {}\n        dict2 = {}\n        for w in words:\n            if w in dict1:\n                dict1[w] += 1\n            else:\n                dict1[w] = 1\n        for w in word1:\n            if w in dict2:\n                dict2[w] += 1\n            else:\n                dict2[w] = 1\n        if dict1 == dict2:\n            return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'app', 'apple')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'app', 'banana')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'banana', 'app')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'app', 'banana')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'app', 'app')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'app', 'applm')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'banana', 'app')\n    print s.isAnagram(['banana', 'app', 'applm', 'apple'], 'banana', 'applm')"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# Definition for a word:\n#     word: str\n#     word.length <= 30\n#     word.isalpha()\n#     word.isalnum()\n\nclass Solution:\n    def findMatch(self, dict, words):\n        \"\"\"\n        :type dict: List[str]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ret = []\n        for word in words:\n            for key in dict:\n                if word[0] == key[0]:\n                    ret.append(key)\n                    break\n            else:\n                return []\n        return ret"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def match(word1, word2):\n    if word1[0] == 'p' and word2[0] == 'p':\n        return word1 == word2\n    if word1[0] == 'p' and word2[0]!= 'p':\n        return False\n    if word1[0]!= 'p' and word2[0] == 'p':\n        return False\n    return word1[1:] == word2[1:]\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto\"\n    assert match(\"pashto\", \"pashto\") == True, \"pashto"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m = len(s)\n        n = len(p)\n        if m == 0 or n == 0:\n            return False\n\n        s = list(s)\n        p = list(p)\n\n        s_i = 0\n        p_i = 0\n        while s_i < m and p_i < n:\n            if s[s_i] == p[p_i]:\n                s_i += 1\n                p_i += 1\n            elif s[s_i] == '*':\n                s_i += 1\n            else:\n                p_i += 1\n        if p_i == n:\n            return True\n        return False\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isMatch(\"ab\", \"*\")\n    print s.isMatch(\"aab\", \"c*c\")\n    print s.isMatch(\"ab\", \"a*a\")"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "def is_subword(word, subword):\n    \"\"\"\n    :type word: str\n    :type subword: str\n    :rtype: bool\n    \"\"\"\n    if len(subword) > len(word):\n        return False\n    if subword[0] == word[0]:\n        return is_subword(word[1:], subword[1:])\n    return False\n\ndef is_subword_2(word, subword):\n    \"\"\"\n    :type word: str\n    :type subword: str\n    :rtype: bool\n    \"\"\"\n    if len(subword) > len(word):\n        return False\n    if subword[0] == word[0]:\n        return is_subword_2(word[1:], subword[1:])\n    if word[0] == subword[0]:\n        return is_subword_2(word[1:], subword[1:])\n    return False\n\ndef is_subword_3(word, subword):\n    \"\"\"\n    :type word: str\n    :type subword: str\n    :rtype: bool\n    \"\"\"\n    if len(subword) > len(word):\n        return False\n    if subword[0] == word[0]:\n        return is_subword_3(word[1:], subword[1:])\n    if word[0] == subword[0]:\n        return is_subword_3(word[1:], subword[1:])\n    return False\n\ndef is_subword_4(word, subword):\n    \"\"\"\n    :type word: str\n    :type subword: str\n    :rtype: bool\n    \"\"\"\n    if len(subword) > len(word):\n        return False\n    if subword[0] == word[0]:\n        return is_subword_4(word[1:], subword[1:])\n    if word[0] == subword[0]:\n        return is_subword_4(word[1:], subword[1:])\n    if subword[0] == word[0]:\n        return is_subword_4(word[1:"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "import unittest\nfrom collections import defaultdict\n\nclass Solution(object):\n    def wordPattern(self, pattern, string):\n        \"\"\"\n        :type pattern: List[str]\n        :type string: str\n        :rtype: bool\n        \"\"\"\n        if len(pattern)!= len(string):\n            return False\n        mapping = defaultdict(list)\n        for i in range(len(pattern)):\n            mapping[pattern[i]].append(string[i])\n        return all(map(lambda k, v: k in v, mapping.keys(), mapping.values()))\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/word-pattern/solution/\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public boolean wordPattern(String[] pattern, String s) {\n        if (pattern == null || pattern.length == 0) return false;\n        HashSet<String> map = new HashSet<String>();\n        for (String word : pattern) {\n            if (map.contains(word)) return false;\n            map.add(word);\n        }\n        return s.chars().allMatch(c -> map.contains(s.substring(0, s.length() - c.length())));\n    }\n}\n\n# DP\n# 1ms 100%\nclass Solution {\n    public boolean wordPattern(String[] pattern, String s) {\n        if (pattern == null || pattern.length == 0) return false;\n        boolean[][] dp = new boolean[s.length() + 1][pattern.length];\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < pattern.length; j++) {\n                if (i - pattern[j].length() >= 0) {\n                    dp[i][j] = dp[i - pattern[j].length()][j];\n                }\n                if ("
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "def is_possible(word, word2):\n    if word == word2:\n        return True\n    elif word[0]!= word2[0]:\n        return False\n    else:\n        if word2[1] == '*':\n            return True\n        if word[1] == '*':\n            return True\n        if word2[1] == word[1]:\n            return True\n    return False\n\ndef is_possible_list(word, word2):\n    return word[0] == word2[0] and word2[1] == '*'\n\ndef is_possible_list2(word, word2):\n    return word[0] == word2[0] and word[1] == '*'\n\ndef is_possible_list3(word, word2):\n    if word[0] == word2[0]:\n        if word[1] == word2[1]:\n            return True\n    return False\n\ndef is_possible_list4(word, word2):\n    if word[0] == word2[0]:\n        if word[1] == word2[1]:\n            if word2[2] == '*':\n                return True\n    return False\n\ndef is_possible_list5(word, word2):\n    if word[0] == word2[0]:\n        if word[1] == word2[1]:\n            if word2[2] == word[1]:\n                if word2[3] == '*':\n                    return True\n    return False\n\ndef is_possible_list6(word, word2):\n    if word[0] == word2[0]:\n        if word[1] == word2[1]:\n            if word[2] == word2[2]:\n                if word2[3] == '*':\n                    return True\n    return False\n\ndef is_possible_list7(word, word2):\n    if word[0] == word2[0]:\n        if word[1] == word2[1]:\n            if word[2] == word2[2]:\n                if word[3] == word2[3]:\n                    if word2[4]"
    }
  ]
}