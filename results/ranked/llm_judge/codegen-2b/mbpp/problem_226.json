{
  "timestamp": "2025-09-14T19:02:27.178749",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 226,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "import math\n\nclass Solution:\n    def _computeSimilarity(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        if len(a)!= len(b):\n            return 0\n\n        diff = 0\n        for i in xrange(len(a)):\n            diff += abs(a[i] - b[i])\n        return diff\n\n    def _computeSimilarity_2(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([abs(i - j) for i, j in zip(a, b)])\n\n    def _computeSimilarity_3(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([math.fabs(i - j) for i, j in zip(a, b)])\n\n    def _computeSimilarity_4(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([abs(i - j) for i, j in zip(a, b)])\n\n    def _computeSimilarity_5(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([math.fabs(i - j) for i, j in zip(a, b)])\n\n    def _computeSimilarity_6(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        return sum([abs(i - j) for i, j in zip(a, b)])\n\n    def _computeSimilarity_7(self, a, b):\n        \"\"\"\n        :type a: List[int]"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef check_similarity(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    d = defaultdict(list)\n    for t in tuple_list:\n        d[t[0], t[1]].append(t)\n\n    for k, v in d.items():\n        if len(v) > 1:\n            return v\n\n    return []\n\n\n# Your Solution here"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def find_similar(records, times):\n    \"\"\"\n    :type records: List[Tuple]\n    :type times: List[int]\n    :rtype: int\n    \"\"\"\n    if len(records) == 0 or len(times) == 0:\n        return 0\n\n    time_table = []\n    for time in times:\n        time_table.append((time, 0))\n\n    # initialize the time table\n    for i in range(len(records)):\n        for j in range(len(records[i])):\n            if records[i][j] in time_table:\n                time_table[records[i][j]][1] += 1\n\n    # calculate the similarity between records\n    similarity = 0\n    for i in range(len(records)):\n        for j in range(len(records[i])):\n            if records[i][j] in time_table:\n                if time_table[records[i][j]][1] > 1:\n                    similarity += 1\n\n    return similarity\n\n\nif __name__ == '__main__':\n    records = [(1,2,3,4,5,6,7,8,9,10), (1,2,3,4,5,6,7,8,9,10), (1,2,3,4,5,6,7,8,9,10)]\n    times = [2,3,2]\n\n    print(find_similar(records, times))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "import timeit\n\nstart = timeit.default_timer()\n\ndef find_similar_time_records(arr):\n    \"\"\"\n    :type arr: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    if not arr:\n        return []\n\n    res = []\n    for i in range(len(arr)):\n        if len(res) == 0:\n            res.append(arr[i])\n            continue\n\n        for j in range(len(res)):\n            if arr[i][0] == res[j][0]:\n                if arr[i][1] == res[j][1]:\n                    res.append(arr[i])\n                else:\n                    res.append(arr[i])\n                    break\n            else:\n                if arr[i][0] < res[j][0]:\n                    res.append(arr[i])\n                    break\n                else:\n                    break\n\n    return res\n\nprint(find_similar_time_records([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]))\n\nend = timeit.default_timer()\n\nprint(end - start)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# write your code here\ndef is_sorted(tuples, times):\n    for i in range(len(tuples)):\n        if times[i] > times[i+1]:\n            return False\n    return True\n\ndef is_time_sorted(times):\n    if times[0] > times[1]:\n        return False\n    return True\n\ndef find_sorted_times(tuples, times):\n    sorted_times = []\n    for i in range(len(tuples)):\n        if is_time_sorted(times):\n            sorted_times.append(times[i])\n    return sorted_times\n\ndef find_sorted_tuples(tuples, times):\n    sorted_tuples = []\n    for i in range(len(tuples)):\n        if is_sorted(tuples[i], times):\n            sorted_tuples.append(tuples[i])\n    return sorted_tuples\n\nif __name__ == \"__main__\":\n    tuples = [ [1,2,3], [1,2,4], [1,3,5], [1,3,6], [1,4,5], [2,3,4], [2,3,5], [2,3,6], [2,4,5], [3,4,5], [3,4,6], [3,5,6], [4,5,6] ]\n    times = [ [1,2,3], [1,2,4], [1,3,5], [1,3,6], [1,4,5], [2,3,4], [2,3,5], [2,3,6], [2,4,5], [3,4,5], [3,4,6], [3,5,6], [4,5,6] ]\n    sorted_times = find_sorted_times(tuples, times)\n    sorted_tuples = find_sorted_tuples(tuples, times)\n    print sorted_tuples\n    print sorted_times"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "import heapq\nfrom itertools import groupby\n\ndef find_similar_times(records, times):\n    \"\"\"\n    :type records: List[Tuple[int, int]]\n    :type times: List[int]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # group by tuple\n    tuple_group = groupby(records, lambda x: x[0])\n    similar_times = []\n\n    # build heap with tuple as key\n    for k, g in tuple_group:\n        heapq.heappush(similar_times, (len(g), k))\n\n    # loop through heap and compare with times\n    while similar_times:\n        # extract tuple from heap\n        t = heapq.heappop(similar_times)\n        # extract tuple\n        tup = t[1]\n        # compare times\n        if tup[0] <= times[0] and tup[1] <= times[1]:\n            # if tuple is not a duplicate\n            heapq.heappush(similar_times, (t[0], tup[0]))\n            heapq.heappush(similar_times, (t[0], tup[1]))\n    return similar_times\n\nif __name__ == '__main__':\n    records = [\n        (0, 0),\n        (0, 1),\n        (0, 2),\n        (0, 3),\n        (1, 0),\n        (1, 1),\n        (1, 2),\n        (1, 3),\n        (2, 0),\n        (2, 1),\n        (2, 2),\n        (2, 3),\n        (3, 0),\n        (3, 1),\n        (3, 2),\n        (3, 3)\n    ]\n    times = [0, 1, 2, 3]\n    print(find_similar_times(records, times))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-the-difference/discuss/76664/Python-Solution-with-O(n)-Space\n\n# 1. use a map to store the diff times\n# 2. use a set to store the unique diff times\n# 3. use a map to store the unique diff times and the index of the tuple\n# 4. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 5. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 6. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 7. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 8. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 9. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 10. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 11. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 12. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 13. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 14. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 15. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 16. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 17. use a map to store the unique diff times and the index of the tuple and a list to store the index of the tuple\n# 18. use a map to store the unique diff times and the index of the tuple and a list"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "import re\n\nclass Solution(object):\n    def isSimilar(self, t1, t2):\n        \"\"\"\n        :type t1: List[int]\n        :type t2: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(t1)!= len(t2):\n            return False\n\n        return set(t1).intersection(set(t2)) == set(t1)\n\nif __name__ == '__main__':\n    sol = Solution()\n    assert sol.isSimilar([1, 2, 3], [1, 2, 3])\n    assert sol.isSimilar([1, 2, 2], [1, 2, 2])\n    assert sol.isSimilar([1, 2, 2], [1, 2, 1])\n    assert not sol.isSimilar([1, 2, 2], [1, 3, 3])"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/quicksort2\n# https://www.hackerrank.com/challenges/quicksort3\n# https://www.hackerrank.com/challenges/quicksort4\n# https://www.hackerrank.com/challenges/quicksort5\n# https://www.hackerrank.com/challenges/quicksort6\n# https://www.hackerrank.com/challenges/quicksort7\n# https://www.hackerrank.com/challenges/quicksort8\n# https://www.hackerrank.com/challenges/quicksort9\n# https://www.hackerrank.com/challenges/quicksort10\n\nfrom itertools import groupby\nfrom collections import Counter\n\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a = list(map(int, input().strip().split(' ')))\n    b = list(map(int, input().strip().split(' ')))\n    c = list(map(int, input().strip().split(' ')))\n    # print(a, b, c)\n    a.sort()\n    b.sort()\n    c.sort()\n    # print(a, b, c)\n    # print(a, b, c)\n    # print(Counter(a))\n    # print(Counter(b))\n    # print(Counter(c))\n    # print(Counter(list(zip(a, b, c))))\n    # print(Counter(list(zip(a, b))))\n    # print(Counter(list(zip(b, c))))\n    # print(Counter(list(zip(c, a))))\n    # print(Counter(list(zip(c, b))))\n    # print(Counter(list(zip(c, a, b))))\n    # print(Counter(list(zip(c, b, a))))\n    # print(Counter(list(zip(c, b, a, b))))\n    # print(Counter(list(zip(c, b, a, b, c))))\n    # print(Counter(list(zip(c, b, a"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/count-and-say/#/description\n# Solution: \n# 1. sort the list\n# 2. compare two records in the sorted list\n# 3. if the two records are similar, print 1\n# 4. else, print 0\n\nclass Solution:\n    # @return a tuple, (index1, index2)\n    def findSimiliarRecords(self, records, times):\n        if not records:\n            return (None, None)\n\n        records.sort()\n        times.sort()\n        i = 0\n        j = 0\n        while i < len(records) and j < len(times):\n            if records[i] == times[j]:\n                print(records[i])\n                i += 1\n                j += 1\n            elif records[i] < times[j]:\n                i += 1\n            else:\n                j += 1\n\n        return (i, j)\n\nif __name__ == \"__main__\":\n    records = [1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7]\n    times = [1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7]\n    solution = Solution()\n    print(solution.findSimiliarRecords(records, times))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "import collections\n\ndef check_occurrences(tuples):\n    result = collections.defaultdict(int)\n    for tup in tuples:\n        for key, val in tup:\n            result[key] += val\n    return result\n\nif __name__ == \"__main__\":\n    tups = [(1, 10), (2, 5), (3, 15), (1, 20), (2, 20), (3, 15), (1, 15), (1, 15), (2, 5), (2, 10), (3, 15), (3, 15)]\n    result = check_occurrences(tups)\n    print(result)\n    print(sum(result.values()))\n    print(result.keys())\n    print(result[1])\n    print(result[1] * result[3])\n    print(result[1] * result[3] > result[2] * result[4] + result[1] * result[5] * result[6] + result[3] * result[7] * result[8] + result[1] * result[9] * result[10] * result[11] * result[12] * result[13])"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "import math\n\ndef find_occurrences(t1, t2):\n    if len(t1)!= len(t2):\n        return -1\n    n = 0\n    for i in range(len(t1)):\n        if t1[i] == t2[i]:\n            n += 1\n    return n\n\nif __name__ == '__main__':\n    t1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n    t2 = [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]\n    print(find_occurrences(t1, t2))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/the-times-you-need-to-know\n\ndef similar(t1, t2):\n    \"\"\"\n    Returns the number of times that the two tuples are equal.\n    :param t1: a tuple of time (e.g. (1, 3, 5))\n    :param t2: a tuple of time (e.g. (1, 3, 5))\n    :return: the number of times that the two tuples are equal\n    \"\"\"\n\n    # Use a set to store the unique items in the tuples\n    s1 = set(t1)\n    s2 = set(t2)\n    # Create a set of tuples to store the possible combinations\n    possible_combinations = set([])\n    # Iterate over the elements in s1\n    for e1 in s1:\n        # Create a set of tuples to store the possible combinations\n        possible_combinations = set([])\n        # Iterate over the elements in s2\n        for e2 in s2:\n            # Create a tuple of the two elements\n            t = (e1, e2)\n            # If the two elements are equal, add them to the possible_combinations\n            if t in possible_combinations:\n                continue\n            # Otherwise, create a tuple of the two elements\n            else:\n                possible_combinations.add(t)\n    # Iterate over the possible_combinations\n    for t in possible_combinations:\n        # If the elements in t are equal, add 1 to the count of similar times\n        if t in s1 and t in s2:\n            return 1\n    # If the elements in t are not equal, return 0\n    return 0\n\nif __name__ == \"__main__\":\n    t1 = [1, 3, 5]\n    t2 = [1, 3, 5]\n    print(similar(t1, t2))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import unittest\nfrom time import time\n\n\nclass Solution(object):\n    def checkRecord(self, records, times):\n        \"\"\"\n        :type records: List[List[int]]\n        :type times: List[int]\n        :rtype: List[int]\n        \"\"\"\n        times = list(set(times))\n        times.sort()\n        times.append(0)\n\n        max_diff = 0\n        max_index = 0\n        for i in range(len(times) - 1):\n            diff = times[i + 1] - times[i]\n            if diff > max_diff:\n                max_diff = diff\n                max_index = i\n\n        count = 0\n        for record in records:\n            diff = times[max_index] - record[0]\n            if diff <= max_diff:\n                count += 1\n\n        return count\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        records = [[1, 2, 3, 4], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]]\n        times = [1, 2, 3, 4, 5, 6]\n        self.assertEqual(Solution().checkRecord(records, times), 6)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def occurrences(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: int\n    \"\"\"\n    occurrences = 0\n    for t in tuples:\n        occurrences += 1\n        for i in range(occurrences):\n            occurrences = occurrences - 1\n            if t[0] == t[1]:\n                occurrences = occurrences - 1\n    return occurrences\n\ndef main():\n    tuples = [[1, 2], [1, 1], [1, 2], [1, 2], [1, 1], [1, 2], [1, 2], [1, 2], [1, 1], [1, 1], [1, 2], [1, 2], [1, 1], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1,"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "import time\nimport itertools\n\ndef find_similar(tuples, times):\n    \"\"\"\n    Given a list of tuples, find the records that occur similar times in the given tuples.\n\n    The tuple format is: (time, address)\n\n    :param tuples: A list of tuples.\n    :param times: A list of time values.\n    :return: A dictionary mapping address to a list of tuples.\n    \"\"\"\n    # Get the time difference between two tuples\n    def get_time_diff(t1, t2):\n        return abs(t1[0] - t2[0])\n\n    # Get the list of tuples for each address\n    def get_tuples(address):\n        return list(itertools.chain.from_iterable([t for t in tuples if t[1] == address]))\n\n    # Get the list of tuples for each time\n    def get_tuples(t):\n        return list(itertools.chain.from_iterable([t for t in tuples if t[0] == t]))\n\n    # Check the list of tuples for each time\n    def check_tuples(tuples, times):\n        # Get the list of tuples for each time\n        tuples_for_time = get_tuples(times[0])\n        # Get the list of tuples for each address\n        tuples_for_address = get_tuples(tuples[0])\n\n        # Check if the tuples for each address are similar\n        for t1 in tuples_for_time:\n            for t2 in tuples_for_address:\n                # Check if the tuples are similar\n                if get_time_diff(t1, t2) <= 1:\n                    # Check if the tuples are similar\n                    return True\n        # If no similar tuples are found, return False\n        return False\n\n    # Check the list of tuples for each time\n    for t in times:\n        # Check if the tuples are similar\n        if check_tuples(tuples, times):\n            # Check if the tuples are similar\n            return True\n    # If no similar tuples are found, return False\n    return False\n\nif __name__ =="
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "import collections\nimport time\n\nclass Solution(object):\n    def checkRecord(self, record, t):\n        \"\"\"\n        :type record: List[int]\n        :type t: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # sort and convert to a set to remove duplicates\n        records = set(t)\n        # remove the records that are not in the set\n        t = [r for r in t if r in records]\n        # check the records\n        for i in range(len(t)):\n            if record == t[i]:\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    t = [[1,2,3],[1,2,4],[1,2,5]]\n    print Solution().checkRecord([1,2,3], t)\n    print Solution().checkRecord([1,2,3], t[0])\n    print Solution().checkRecord([1,2,3], t[1])\n    print Solution().checkRecord([1,2,3], t[2])\n    print Solution().checkRecord([1,2,3], t[0:2])"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "import math\n\ndef count_similar_records(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            if tuples[i][0] == tuples[j][0]:\n                count += 1\n    return count\n\ndef main():\n    tuples = [\n        [1, 2, 3],\n        [2, 3, 4],\n        [3, 4, 5],\n        [4, 5, 6],\n        [5, 6, 7],\n        [6, 7, 8],\n        [7, 8, 9],\n        [8, 9, 10],\n        [9, 10, 11],\n        [10, 11, 12],\n        [11, 12, 13],\n        [12, 13, 14],\n        [13, 14, 15],\n        [14, 15, 16],\n        [15, 16, 17],\n        [16, 17, 18],\n        [17, 18, 19],\n        [18, 19, 20],\n        [19, 20, 21],\n        [20, 21, 22],\n        [21, 22, 23],\n        [22, 23, 24],\n        [23, 24, 25],\n        [24, 25, 26],\n        [25, 26, 27],\n        [26, 27, 28],\n        [27, 28, 29],\n        [28, 29, 30],\n        [29, 30, 31],\n        [30, 31, 32],\n        [31, 32, 33],\n        [32, 33, 34],\n        [33, 34, 35],\n        [34, 35, 36],\n        [35, 36, 37],\n        [36, 37, 38],\n        [37, 38, 39],\n        [38, 39, 40],\n        [39, 40, 41],\n        [40, 41, 42],\n        [41, 42, 43],\n        [42, 43, 44],\n        [43, 44, 45],\n        [44, 45, 46],"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "import time\n\ndef find_similar_records(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records2(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records3(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records4(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records5(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records6(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records7(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records8(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple\n    \"\"\"\n    #TODO\n    return tuple1\n\ndef find_similar_records9(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: tuple"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/time-slicing\n\ndef get_similar_time_slice(time_slice, tuple_list):\n    \"\"\"\n    :param time_slice: A tuple of time slices\n    :param tuple_list: A list of tuples\n    :return: A list of similar time slices\n    \"\"\"\n\n    # 1. Sort the list of tuples by their first element\n    tuple_list = sorted(tuple_list, key=lambda x: x[0])\n\n    # 2. Create a list of similar time slices\n    similar_time_slice = []\n\n    for i in range(len(time_slice)):\n        if i == 0:\n            # The first element of a time slice is the same\n            # as the first element of the list\n            time_slice[i] = tuple_list[0][0]\n            similar_time_slice.append(time_slice)\n        else:\n            # Find the first element of the list that is\n            # greater than the first element of the time slice\n            # and append the time slice to the similar time slice list\n            for j in range(i):\n                if tuple_list[j][0] > time_slice[i]:\n                    similar_time_slice.append(time_slice)\n                    time_slice[i] = tuple_list[j][0]\n                    break\n\n    # 3. Return the similar time slice list\n    return similar_time_slice\n\nif __name__ == '__main__':\n    # Enter your code here. Read input from STDIN. Print output to STDOUT\n    tuple_list = map(lambda x: map(int, x.split()), raw_input().strip().split(\" \"))\n    time_slice = map(lambda x: map(int, x.split()), raw_input().strip().split(\" \"))\n    print get_similar_time_slice(time_slice, tuple_list)"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "import random\n\ndef check_similar(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: bool\n    \"\"\"\n    if tuple1[0] == tuple2[0] and tuple1[1] == tuple2[1]:\n        return True\n    elif tuple1[0] == tuple2[0]:\n        return True\n    else:\n        return False\n\ndef main():\n    tuple1 = (random.randint(0, 100), random.randint(0, 100))\n    tuple2 = (random.randint(0, 100), random.randint(0, 100))\n    # print(tuple1)\n    # print(tuple2)\n    if check_similar(tuple1, tuple2):\n        print(\"The tuples are similar.\")\n    else:\n        print(\"The tuples are not similar.\")\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "import math\n\ndef find_similar_records(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    # Write your code here\n    return []\n\n\nif __name__ == '__main__':\n    tuples = [\n        (1, 1, 1),\n        (1, 1, 2),\n        (1, 1, 3),\n        (1, 2, 1),\n        (1, 2, 2),\n        (1, 2, 3),\n        (1, 3, 1),\n        (1, 3, 2),\n        (1, 3, 3),\n        (2, 1, 1),\n        (2, 1, 2),\n        (2, 1, 3),\n        (2, 2, 1),\n        (2, 2, 2),\n        (2, 2, 3),\n        (2, 3, 1),\n        (2, 3, 2),\n        (2, 3, 3),\n        (3, 1, 1),\n        (3, 1, 2),\n        (3, 1, 3),\n        (3, 2, 1),\n        (3, 2, 2),\n        (3, 2, 3),\n        (3, 3, 1),\n        (3, 3, 2),\n        (3, 3, 3)\n    ]\n\n    print(find_similar_records(tuples))"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "import math\nimport operator\n\ndef check_similar(tuples, query):\n    \"\"\"\n    Returns the list of tuples with the most similar records.\n\n    tuples: A list of tuples, each tuple containing a record, and a list of similar records.\n    query: A record.\n    \"\"\"\n    return sorted(tuples, key=lambda t: similarity(t[0], query), reverse=True)[:5]\n\n\ndef similarity(a, b):\n    \"\"\"\n    Returns the similarity of two records.\n\n    a: A record.\n    b: Another record.\n    \"\"\"\n    return (1 - math.fabs(a - b) / max(a, b)) * 100\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    tuples = [\n        (1, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (2, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (3, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (4, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (5, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (6, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (7, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (8, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n        (9, [1, 2, 3, 4, 5, 6, 7, 8, 9]),\n    ]\n    query = 9\n    print(check_similar(tuples, query))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "import collections\n\ndef find_occurrences(tuples, records):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :type records: List[int]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    occurrences = collections.defaultdict(list)\n    for record in records:\n        occurrences[record].append(tuples.index(record))\n    return occurrences\n\nif __name__ == '__main__':\n    tuples = [(1, 3), (2, 2), (2, 4), (3, 2), (3, 3), (3, 4)]\n    records = [1, 2, 3, 4]\n    occurrences = find_occurrences(tuples, records)\n    print occurrences\n    assert occurrences == {1: [0, 1], 2: [0, 2, 3], 3: [0, 1, 2, 3, 4]}"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "import time\nimport heapq\n\ndef is_similar(t1, t2):\n    \"\"\"\n    Check if two tuple t1 and t2 are similar.\n    \"\"\"\n    # if the times are not similar, return False\n    if t1[0]!= t2[0]:\n        return False\n\n    # if the times are similar, return True\n    if t1[1] == t2[1]:\n        return True\n\n    # if the times are similar and the difference is small, return True\n    if abs(t1[1] - t2[1]) < 1:\n        return True\n\n    # otherwise return False\n    return False\n\ndef is_similar_records(t1, t2):\n    \"\"\"\n    Check if records t1 and t2 are similar.\n    \"\"\"\n    # if the times are not similar, return False\n    if t1[0]!= t2[0]:\n        return False\n\n    # if the times are similar, return True\n    if t1[1] == t2[1]:\n        return True\n\n    # if the times are similar and the difference is small, return True\n    if abs(t1[1] - t2[1]) < 1:\n        return True\n\n    # otherwise return False\n    return False\n\ndef check_similar_records(records):\n    \"\"\"\n    Check the similarity between each record in records.\n    \"\"\"\n    heap = []\n    for t1 in records:\n        heapq.heappush(heap, (is_similar(t1, records[0]), t1))\n\n    while len(records) > 0:\n        while len(heap) > 0:\n            t1 = heapq.heappop(heap)\n            t2 = heapq.heappop(heap)\n            if is_similar(t1, t2):\n                return True\n\n        records = list(records)\n        records.sort()\n        records = [r for r in records if r[0]!= 0]\n        heapq.heappush(heap, (is_similar_records(records[0], records[1]), records[0]))\n        heapq.heappush"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def check_similar(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for t in tuples:\n        res.append(1)\n    for i in range(len(tuples)):\n        for j in range(len(tuples)):\n            if i!= j:\n                if t[i] == t[j]:\n                    res[i] += 1\n                    res[j] = 0\n    for i in range(len(tuples)):\n        if res[i] > 1:\n            res[i] = 0\n    return res"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def check_occurrences(tuple_set):\n\t#write your code here\n\t#tuple_set = [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,13),(13,14),(14,15),(15,16),(16,17),(17,18),(18,19),(19,20),(20,21),(21,22),(22,23),(23,24),(24,25),(25,26),(26,27),(27,28),(28,29),(29,30),(30,31),(31,32),(32,33),(33,34),(34,35),(35,36),(36,37),(37,38),(38,39),(39,40),(40,41),(41,42),(42,43),(43,44),(44,45),(45,46),(46,47),(47,48),(48,49),(49,50),(50,51),(51,52),(52,53),(53,54),(54,55),(55,56),(56,57),(57,58),(58,59),(59,60),(60,61),(61,62),(62,63),(63,64),(64,65),(65,66),(66,67),(67,68),(68,69),(69,70),(70,71),(71,72),(72,73),(73,74),(74,75),(75,76),(76,77),(77,78),(78,79),(79,80),(80,81),(81,82),(82,83),(83,84),(84,85),(85,86),(86,87),(87,88),(88,89),(89,90),(90,91),(91,92),(92,93),(93,94),(94,95),(95,96),(96,97),(97,98"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "import os\nimport sys\n\ndef main():\n    if len(sys.argv)!= 2:\n        print \"Usage: %s <filename>\" % sys.argv[0]\n        return\n\n    input_file = sys.argv[1]\n    input_file = open(input_file, \"r\")\n    input_data = [line.strip() for line in input_file.readlines()]\n    input_file.close()\n\n    for item in input_data:\n        item_split = item.split()\n        for i in range(len(item_split)):\n            item_split[i] = int(item_split[i])\n\n        if i == 0:\n            item_split[i] = item_split[i] * 10\n            item_split[i + 1] = item_split[i + 1] * 10\n\n        item_split[i] = int(item_split[i])\n        item_split[i + 1] = int(item_split[i + 1])\n\n        item_split[i] = item_split[i] * 10\n        item_split[i + 1] = item_split[i + 1] * 10\n\n        item_split[i] = int(item_split[i])\n        item_split[i + 1] = int(item_split[i + 1])\n\n    for item in input_data:\n        item_split = item.split()\n        for i in range(len(item_split)):\n            item_split[i] = int(item_split[i])\n\n        if i == 0:\n            item_split[i] = item_split[i] * 10\n            item_split[i + 1] = item_split[i + 1] * 10\n\n        item_split[i] = int(item_split[i])\n        item_split[i + 1] = int(item_split[i + 1])\n\n        item_split[i] = item_split[i] * 10\n        item_split[i + 1] = item_split[i + 1] * 10\n\n        item_split[i] = int(item_split[i])\n        item_split[i + 1] ="
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "import collections\n\n\nclass Time:\n    def __init__(self, time):\n        self.time = time\n\n    def __eq__(self, other):\n        return self.time == other.time\n\n    def __lt__(self, other):\n        return self.time < other.time\n\n    def __gt__(self, other):\n        return self.time > other.time\n\n    def __le__(self, other):\n        return self.time <= other.time\n\n    def __ge__(self, other):\n        return self.time >= other.time\n\n    def __ne__(self, other):\n        return self.time!= other.time\n\n    def __repr__(self):\n        return str(self.time)\n\n\nclass TimeSeries:\n    def __init__(self, data):\n        self.data = data\n\n    def __eq__(self, other):\n        return self.data == other.data\n\n    def __lt__(self, other):\n        return self.data < other.data\n\n    def __gt__(self, other):\n        return self.data > other.data\n\n    def __le__(self, other):\n        return self.data <= other.data\n\n    def __ge__(self, other):\n        return self.data >= other.data\n\n    def __ne__(self, other):\n        return self.data!= other.data\n\n    def __repr__(self):\n        return str(self.data)\n\n\nclass TimeSeriesList:\n    def __init__(self, data):\n        self.data = data\n\n    def __eq__(self, other):\n        return self.data == other.data\n\n    def __lt__(self, other):\n        return self.data < other.data\n\n    def __gt__(self, other):\n        return self.data > other.data\n\n    def __le__(self, other):\n        return self.data <= other.data\n\n    def __ge__(self, other):\n        return self.data >= other.data\n\n    def __ne__(self, other):\n        return self.data!= other.data\n\n    def __repr__(self):\n        return str(self.data)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "import sys\nimport time\n\nclass Time(object):\n    def __init__(self, hours, minutes):\n        self.hours = hours\n        self.minutes = minutes\n        self.secs = 0\n\n    def __str__(self):\n        return str(self.hours) + ':' + str(self.minutes) + ':' + str(self.secs)\n\n    def __repr__(self):\n        return str(self)\n\nclass TimeUtil(object):\n    def __init__(self, tuples):\n        self.tuples = tuples\n\n    def get_time(self, time_tuple):\n        return time_tuple.hours * 60 * 60 + time_tuple.minutes * 60 + time_tuple.secs\n\n    def get_time_diff(self, time_tuple1, time_tuple2):\n        return abs(self.get_time(time_tuple1) - self.get_time(time_tuple2))\n\n    def get_time_diff_by_minutes(self, time_tuple1, time_tuple2):\n        return abs(self.get_time(time_tuple1) - self.get_time(time_tuple2)) / 60\n\n    def get_time_diff_by_hours(self, time_tuple1, time_tuple2):\n        return abs(self.get_time(time_tuple1) - self.get_time(time_tuple2)) / 60 / 60\n\n    def get_time_diff_by_seconds(self, time_tuple1, time_tuple2):\n        return abs(self.get_time(time_tuple1) - self.get_time(time_tuple2))\n\n    def get_time_diff_by_seconds_with_format(self, time_tuple1, time_tuple2):\n        return str(self.get_time_diff_by_seconds(time_tuple1, time_tuple2))\n\n    def get_time_diff_by_minutes_with_format(self, time_tuple1, time_tuple2):\n        return str(self.get"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "import time\nimport datetime\nimport random\n\ndef check_times(t1, t2, t3):\n    \"\"\"\n    :param t1: a tuple\n    :param t2: a tuple\n    :param t3: a tuple\n    :return: a list\n    \"\"\"\n    if t1 < t2 and t1 < t3:\n        return [t1, t2, t3]\n    elif t2 < t1 and t2 < t3:\n        return [t2, t1, t3]\n    elif t3 < t1 and t3 < t2:\n        return [t3, t1, t2]\n    else:\n        return []\n\ndef check_time(t):\n    \"\"\"\n    :param t: a tuple\n    :return: a list\n    \"\"\"\n    if t < datetime.timedelta(minutes=30):\n        return [t]\n    else:\n        return []\n\ndef check_time_similar(t1, t2, t3):\n    \"\"\"\n    :param t1: a tuple\n    :param t2: a tuple\n    :param t3: a tuple\n    :return: a list\n    \"\"\"\n    if t1 < t2 and t1 < t3:\n        return [t1, t2, t3]\n    elif t2 < t1 and t2 < t3:\n        return [t2, t1, t3]\n    elif t3 < t1 and t3 < t2:\n        return [t3, t1, t2]\n    else:\n        return []\n\ndef check_time_similar_all(t1, t2, t3):\n    \"\"\"\n    :param t1: a tuple\n    :param t2: a tuple\n    :param t3: a tuple\n    :return: a list\n    \"\"\"\n    if t1 < t2 and t1 < t3:\n        return [t1, t2, t3]\n    elif t2 < t1 and t2 < t3:\n        return [t2, t1, t3]\n    elif t3 < t1 and t3 < t2:\n        return [t3"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef check_occurrences(tuples):\n    \"\"\"\n    tuples: list of tuples\n\n    Returns: a list of tuples, each tuple is a pair of (index, count)\n    \"\"\"\n    counts = Counter()\n    for t in tuples:\n        counts[t] += 1\n    return counts.most_common()\n\nif __name__ == \"__main__\":\n    t = [(\"1\", 5), (\"2\", 5), (\"3\", 2), (\"1\", 5), (\"2\", 5), (\"3\", 2)]\n    print(check_occurrences(t))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "import timeit\n\n\ndef find_similar_time(t1, t2):\n    \"\"\"\n    :type t1: list[tuple]\n    :type t2: list[tuple]\n    :rtype: list[tuple]\n    \"\"\"\n    if len(t1) == 0 or len(t2) == 0:\n        return []\n\n    if len(t1)!= len(t2):\n        return []\n\n    result = []\n    for t1_item in t1:\n        for t2_item in t2:\n            if t1_item == t2_item:\n                result.append(t1_item)\n\n    return result\n\n\nif __name__ == '__main__':\n    t = timeit.timeit(\"find_similar_time(t1, t2)\", setup=\"from __main__ import find_similar_time, t1, t2\", number=1000)\n    print(\"find_similar_time(t1, t2) executed %.4f times\" % t)"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "import math\n\ndef get_similar_times(time_list):\n    \"\"\"\n    time_list: a list of tuples of the form (time, time_difference)\n    returns: a dictionary of the form {(time, time_difference): count}\n    \"\"\"\n    similar_times = {}\n    for t in time_list:\n        if t[0] in similar_times:\n            similar_times[t[0], t[1]] += 1\n        else:\n            similar_times[t[0], t[1]] = 1\n    return similar_times\n\ndef get_similar_times_with_diff(time_list):\n    \"\"\"\n    time_list: a list of tuples of the form (time, time_difference)\n    returns: a dictionary of the form {(time, time_difference): count}\n    \"\"\"\n    similar_times = {}\n    for t in time_list:\n        if t[0] in similar_times:\n            similar_times[t[0], t[1]] += 1\n            if t[1] > 0:\n                similar_times[t[0], t[1]-1] += 1\n        else:\n            similar_times[t[0], t[1]] = 1\n            if t[1] > 0:\n                similar_times[t[0], t[1]-1] = 1\n    return similar_times\n\ndef get_all_times(time_list):\n    \"\"\"\n    time_list: a list of tuples of the form (time, time_difference)\n    returns: a dictionary of the form {(time, time_difference): count}\n    \"\"\"\n    all_times = {}\n    for t in time_list:\n        all_times[t[0], t[1]] += 1\n    return all_times\n\ndef get_all_times_with_diff(time_list):\n    \"\"\"\n    time_list: a list of tuples of the form (time, time_difference)\n    returns: a dictionary of the form {(time, time_difference): count}\n    \"\"\"\n    all_times = {}\n    for t in time_list:\n        all"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "import time\nimport random\nimport math\n\ndef find_similar_records(tuples):\n    similar_records = {}\n    for record in tuples:\n        if record in similar_records:\n            similar_records[record] += 1\n        else:\n            similar_records[record] = 1\n    return similar_records\n\n\ndef main():\n    # tuples = [(time.time(), random.randint(0, 100), random.randint(0, 100), random.randint(0, 100), random.randint(0, 100)) for _ in range(100)]\n    tuples = [(time.time(), random.randint(0, 100), random.randint(0, 100)) for _ in range(100)]\n\n    print(\"Similar records: \", find_similar_records(tuples))\n    print(\"Average time: \", sum(tuple[0] for tuple in tuples) / len(tuples))\n\n    # time.sleep(0.5)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/count-and-say/\n# https://leetcode.com/problems/count-and-say/discuss/90426/C%2B%2B-Python-DP-with-explained-explanation\n\n# DP\n# Time:  O(n * d^2)\n# Space: O(n * d)\nclass Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 0:\n            return \"\"\n        dp = [1] * n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i+1, n):\n                if dp[j] > dp[i]:\n                    dp[j] = dp[j] + dp[i]\n                else:\n                    dp[j] = dp[j] + dp[i]\n        for i in range(n):\n            dp[i] = str(dp[i])\n        return \"\".join(dp)\n\n# DP\n# Time:  O(n * d)\n# Space: O(n)\nclass Solution2(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 0:\n            return \"\"\n        dp = [1] * n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i+1, n):\n                if dp[j] > dp[i]:\n                    dp[j] = dp[j] + dp[i]\n                else:\n                    dp[j] = dp[j] + dp[i]\n        dp[n-1] = 1\n        for i in range(n-2, -1, -1):\n            dp[i] = str(dp[i])\n        return \"\".join(dp)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef get_similar_records(record_tuples):\n    \"\"\"\n    Input: A list of tuples.\n    Output: A list of tuples.\n    \"\"\"\n    records = []\n    for t in record_tuples:\n        count = Counter(t)\n        for key in count:\n            if count[key] > 1:\n                records.append(key)\n    return records\n\ndef find_similar_records(record_tuples):\n    \"\"\"\n    Input: A list of tuples.\n    Output: A list of tuples.\n    \"\"\"\n    similar_records = []\n    for t in record_tuples:\n        count = Counter(t)\n        if count > 1:\n            similar_records.append(t)\n    return similar_records\n\nif __name__ == '__main__':\n    record_tuples = [(1, 1), (2, 1), (1, 2), (2, 2), (1, 3), (2, 3)]\n    similar_records = find_similar_records(record_tuples)\n    print(similar_records)\n    records = get_similar_records(record_tuples)\n    print(records)"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef count_occurrences(t1, t2):\n    \"\"\"\n    Input:\n        t1: tuple, (1, 3, 7, 11)\n        t2: tuple, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    Output:\n        dict: {(1, 3): 3, (7, 11): 3}\n    \"\"\"\n    return defaultdict(int, zip(t1, t2))\n\nif __name__ == '__main__':\n    t1 = (1, 3, 7, 11)\n    t2 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    print(count_occurrences(t1, t2))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "import collections\n\ndef find_duplicates(tuples):\n    \"\"\"\n    :type tuples: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    duplicates = collections.defaultdict(list)\n    for tup in tuples:\n        for key, val in tup:\n            if key in duplicates[val]:\n                duplicates[val].append(key)\n            else:\n                duplicates[val].append(key)\n    return [tup for tup in duplicates.values() if len(tup) > 1]\n\nif __name__ == '__main__':\n    tuples = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n    duplicates = find_duplicates(tuples)\n    print(duplicates)"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def get_similar_times(tuple1, tuple2):\n    \"\"\"\n    :type tuple1: tuple\n    :type tuple2: tuple\n    :rtype: int\n    \"\"\"\n    if len(tuple1)!= len(tuple2):\n        return 0\n    occur_times = 0\n    for i in range(len(tuple1)):\n        if tuple1[i] == tuple2[i]:\n            occur_times += 1\n    return occur_times\n\nif __name__ == '__main__':\n    print(get_similar_times((1,2,3,4,5), (1,2,3,4,5)))\n    print(get_similar_times((1,2,3,4,5), (1,2,3,4,5,6)))\n    print(get_similar_times((1,2,3,4,5), (1,2,3,4,5,6,7)))\n    print(get_similar_times((1,2,3,4,5), (1,2,3,4,5,6,7,8)))\n    print(get_similar_times((1,2,3,4,5), (1,2,3,4,5,6,7,8,9)))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "import sys\n\ndef find_similar(tuples):\n    \"\"\"\n    Find the records which occur similar times in the given tuples.\n    :type tuples: List[List[str]]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for t in tuples:\n        res.append(find_similar_records(t))\n    return res\n\ndef find_similar_records(tuples):\n    \"\"\"\n    Find the records which occur similar times in the given tuples.\n    :type tuples: List[List[str]]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            if tuples[i][0] == tuples[j][0]:\n                if tuples[i][1] == tuples[j][1]:\n                    res.append(i)\n    return res\n\nif __name__ == '__main__':\n    tuples = []\n    with open(sys.argv[1], 'r') as f:\n        for line in f:\n            tuples.append([line.strip(), line.strip()])\n    print(find_similar(tuples))"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "import collections\n\ndef check_similar_records(tuples):\n    \"\"\"\n    Input: A list of tuples of (date, time)\n    Return: A list of tuples of (date, time)\n    \"\"\"\n    # sort tuples by date\n    tuples = sorted(tuples, key=lambda x: x[0])\n\n    # compare the time of two records\n    similar_records = collections.defaultdict(list)\n    for record in tuples:\n        similar_records[record[0]].append(record[1])\n\n    # return the records that are similar\n    return [record for record in tuples if len(similar_records[record[0]]) == 1]\n\n\nif __name__ == '__main__':\n    tuples = [(2015, 14, 13, 23, 59), (2015, 14, 13, 22, 59), (2015, 14, 13, 21, 59)]\n    tuples = check_similar_records(tuples)\n    print(tuples)"
    },
    {
      "rank": 43,
      "score": 4.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def countSimilar(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    count += 1\n                    break\n        return count\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-the-similar-numbers/solution/\n\n# 1ms 100%\nclass Solution {\n    public int countSimilar(int[] A, int[] B) {\n        int count = 0;\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < B.length; j++) {\n                if (A[i] == B[j]) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int countSimilar(int[] A, int[] B) {\n        int count = 0;\n        if (A == null || B == null) {\n            return 0;\n        }\n        if (A.length!= B.length) {\n            return 0;\n        }\n        Map<Integer, Integer> map = new HashMap();\n        for (int i = 0; i < A.length; i++) {\n            if (map.containsKey(A[i])) {\n                map.put(A[i], map.get(A[i]) + 1);\n            } else {\n                map.put(A[i], 1);\n            }\n        }\n        for (int i = 0; i < B.length; i++) {\n            if (map.containsKey(B[i])) {"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "import time\nimport random\n\n\ndef find_similar_records(tuples):\n    \"\"\"\n    :param tuples: a list of tuples\n    :return: a list of tuples\n    \"\"\"\n\n    # create a list of random integers\n    random_ints = [random.randint(0, len(tuples) - 1) for _ in range(len(tuples))]\n\n    # sort the random integers\n    random_ints = sorted(random_ints)\n\n    # create a list of tuples\n    tuple_list = [tuples[i] for i in random_ints]\n\n    # calculate the difference between two tuples\n    diff = [abs(tuple_list[i][0] - tuple_list[i + 1][0]),\n            abs(tuple_list[i][1] - tuple_list[i + 1][1])]\n\n    # get the minimum difference\n    min_diff = min(diff)\n\n    # if the difference is smaller than the minimum difference,\n    # the two tuples are similar\n    if min_diff <= 1:\n        return tuple_list\n\n    # if the difference is larger than the minimum difference,\n    # the two tuples are different\n    else:\n        return None\n\n\nif __name__ == \"__main__\":\n    tuples = [(time.time(), random.randint(1, 10)) for _ in range(30)]\n\n    print(find_similar_records(tuples))"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "def find_similar_records(records, times):\n    \"\"\"\n    :type records: List[Tuple[str, int]]\n    :type times: List[int]\n    :rtype: List[Tuple[str, int]]\n    \"\"\"\n    if len(records) == 0:\n        return []\n    records.sort(key=lambda x: x[1])\n    records.reverse()\n    for i in range(len(records) - 1):\n        if records[i][1] == records[i + 1][1]:\n            continue\n        if records[i][1] > records[i + 1][1]:\n            records[i + 1][1] = records[i][1]\n        else:\n            records[i][1] = records[i + 1][1]\n    return records\n\nif __name__ == '__main__':\n    times = [1, 2, 3, 4, 5]\n    records = [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    print(find_similar_records(records, times))\n    times = [1, 2, 3, 4, 5, 6]\n    records = [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)]\n    print(find_similar_records(records, times))\n    times = [1, 2, 3, 4, 5, 6, 7]\n    records = [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)]\n    print(find_similar_records(records, times))\n    times = [1, 2, 3, 4, 5, 6, 7, 8]\n    records = [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)]\n    print(find_similar_records(records, times))"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "#Write your function here\ndef is_similar(t1, t2):\n    \"\"\"\n    t1 and t2 are tuples of strings.\n    Returns True if t1 and t2 have similar timestamps, and False otherwise.\n    \"\"\"\n    # Write your code here\n    # Get the time from the tuple\n    t1_time = t1[0]\n    t2_time = t2[0]\n    # Compare the time\n    if t1_time == t2_time:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    t1 = ('10:00', '10:01')\n    t2 = ('10:00', '10:01')\n    t3 = ('10:00', '10:02')\n    t4 = ('10:02', '10:03')\n    t5 = ('10:03', '10:04')\n    t6 = ('10:04', '10:05')\n    t7 = ('10:05', '10:06')\n    t8 = ('10:06', '10:07')\n    t9 = ('10:07', '10:08')\n    t10 = ('10:08', '10:09')\n    t11 = ('10:09', '10:10')\n    t12 = ('10:10', '10:11')\n    t13 = ('10:11', '10:12')\n    t14 = ('10:12', '10:13')\n    t15 = ('10:13', '10:14')\n    t16 = ('10:14', '10:15')\n    t17 = ('10:15', '10:16')\n    t18 = ('10:16', '10:17')\n    t19 = ('10:17', '10:18')\n    t20 = ('10:18', '10:19')\n    t21 = ('10:19', '10:20')\n    t22 = ('10:20', '10:21')\n    t23 = ('10:21', '10:22')\n    t24 = ('10:22', '10:23')\n    t25 = ('10:23', '10"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "def check_records(tuples):\n    def is_similar(t1, t2):\n        return t1[1] == t2[1] and t1[2] == t2[2]\n    def similar_records(t1, t2):\n        return t1[0] in t2[0]\n    for t in tuples:\n        # print(t)\n        for i in range(len(tuples)):\n            if is_similar(t, tuples[i]):\n                print(t, tuples[i])\n                tuples[i] = (tuples[i][0], tuples[i][1] + tuples[i][2])\n                print(tuples[i])\n                return similar_records(t, tuples[i])\n    return False\n\ndef main():\n    tuples = [(1, 'a', 10), (1, 'b', 20), (1, 'c', 30), (2, 'a', 10), (2, 'b', 20), (2, 'c', 30)]\n    print(check_records(tuples))\n    tuples = [(1, 'a', 10), (1, 'b', 20), (1, 'c', 30), (2, 'a', 10), (2, 'b', 20), (2, 'c', 30)]\n    print(check_records(tuples))\n    tuples = [(1, 'a', 10), (1, 'b', 20), (1, 'c', 30), (2, 'a', 10), (2, 'b', 20), (2, 'c', 30)]\n    print(check_records(tuples))\n    tuples = [(1, 'a', 10), (1, 'b', 20), (1, 'c', 30), (2, 'a', 10), (2, 'b', 20), (2, 'c', 30)]\n    print(check_records(tuples))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Mar 14 13:29:26 2017\n\n@author: AmatVictoriaCuramIII\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport time\nimport datetime as dt\nimport math\n\ndef check_times(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y.time:\n                output_list.append(y)\n    return output_list\n\ndef check_times_1(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y:\n                output_list.append(y)\n    return output_list\n\ndef check_times_2(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y.time:\n                output_list.append(y)\n    return output_list\n\ndef check_times_3(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y.time:\n                output_list.append(y)\n    return output_list\n\ndef check_times_4(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y.time:\n                output_list.append(y)\n    return output_list\n\ndef check_times_5(input_list, target_list):\n    output_list = []\n    for x in input_list:\n        for y in target_list:\n            if x.time == y.time:\n                output_list.append(y)\n    return output_list\n\ndef check_times_6(input_list, target_list):\n    output_list = []\n    for x in input_list:"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/similar-event-sequences/description/\n\nclass Solution(object):\n    def __init__(self, records):\n        \"\"\"\n        :type records: List[List[int]]\n        \"\"\"\n        self.records = records\n\n    def similar_events(self, time_point_list):\n        \"\"\"\n        :type time_point_list: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not self.records:\n            return []\n\n        # sort by time\n        sorted_records = sorted(self.records, key=lambda x: x[0])\n        sorted_records.sort(key=lambda x: x[1])\n\n        # compute the number of events\n        num_events = len(self.records)\n\n        # store the difference between the index of the first event and the index of the next event\n        diff = 0\n\n        # store the current index of the first event\n        curr_index = 0\n\n        # store the list of the similar events\n        similar_events = []\n\n        for i in range(num_events):\n            # if the current event is not the first event, then add the difference between the current event and the previous event to the list of similar events\n            if curr_index > 0:\n                similar_events.append(diff)\n\n            # compute the difference between the current event and the next event\n            diff = sorted_records[curr_index][1] - sorted_records[curr_index + 1][1]\n\n            # if the difference is zero, then the current event is the same as the previous event\n            if diff == 0:\n                similar_events.append(curr_index)\n                curr_index += 1\n\n        return similar_events\n\nif __name__ == \"__main__\":\n    solution = Solution(\n        [[1, 2], [1, 3], [1, 4], [2, 4], [2, 3], [3, 4], [4, 4], [4, 3], [4, 2], [5, 2], [6, 2]])\n    print(solution.similar_events([1, 3, 4, 3,"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "import unittest\n\n# Your code here.\nclass Solution(object):\n    def findSimiliar(self, T, K):\n        \"\"\"\n        :type T: List[List[int]]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        if len(T) == 0:\n            return []\n        result = []\n        for i in range(len(T)):\n            for j in range(i + 1, len(T)):\n                if len(set(T[i]) & set(T[j])) == K:\n                    result.append(T[i][0])\n        return result\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\nThe problem is similar to the problem of grouping similar numbers, but we need to group similar numbers\ninstead of grouping similar times.\n\n# 7ms 100%\nclass Solution {\n    public List<Integer> findSimiliar(int[] arr, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (map.containsKey(arr[i])) {\n                map.put(arr[i], map.get(arr[i]) + 1);\n            } else {\n                map.put(arr[i], 1);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            if (map.get(arr[i]) == k) {\n                result.add(arr[i]);\n            }\n        }\n        return result;\n    }\n}\n\n# 11ms 98.70%\nclass Solution {\n    public List<Integer> findSimiliar(int[] arr, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "import collections\n\ndef count_occurrences(tuple_list):\n    \"\"\"\n    Input: A list of tuples.\n    Output: A dictionary of the following format:\n    {\n        \"<record1>\": <number of occurrences>,\n        \"<record2>\": <number of occurrences>,\n       ...\n    }\n    \"\"\"\n    # Create a dictionary of the following format:\n    # {\n    #     \"<record1>\": <number of occurrences>,\n    #     \"<record2>\": <number of occurrences>,\n    #    ...\n    # }\n    dict_of_occurrences = collections.Counter()\n\n    # For each tuple in the given list, add the tuple's key to the dictionary.\n    for tuple_item in tuple_list:\n        dict_of_occurrences[tuple_item[0]] += 1\n\n    # Return the dictionary of the following format:\n    # {\n    #     \"<record1>\": <number of occurrences>,\n    #     \"<record2>\": <number of occurrences>,\n    #    ...\n    # }\n    return dict_of_occurrences\n\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert count_occurrences([(\"cat\", 2), (\"dog\", 2), (\"cat\", 2), (\"cat\", 3)]) == {\n        \"cat\": 3,\n        \"dog\": 2\n    }, \"Count occurrences\"\n    assert count_occurrences([(\"cat\", 2), (\"cat\", 2), (\"cat\", 3)]) == {\n        \"cat\": 3\n    }, \"Count occurrences\"\n    assert count_occurrences([(\"cat\", 2), (\"dog\", 2), (\"cat\", 2), (\"cat\", 3)]) == {\n        \"cat\": 2\n    }, \"Count occurrences\""
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "def find_similar_records(tuples, target_time):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :type target_time: int\n    :rtype: List[int]\n    \"\"\"\n    # Write your code here\n    if not tuples:\n        return []\n\n    res = []\n\n    for t1, t2 in itertools.combinations(tuples, 2):\n        # find the difference\n        diff = abs(t1[0] - t2[0]) + abs(t1[1] - t2[1])\n        # print(diff)\n\n        # if the difference is greater than the target time\n        if diff > target_time:\n            # append the record\n            res.append(t1)\n\n    return res\n\n\ndef main():\n    # read the input\n    n = int(input())\n    tuples = []\n    for _ in range(n):\n        t = list(map(int, input().split()))\n        tuples.append(t)\n\n    # write your code here\n    print(find_similar_records(tuples, target_time=500))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "import unittest\n\n\nclass Solution(object):\n    def __init__(self):\n        self.count = 0\n\n    def isSimilar(self, times1, times2):\n        \"\"\"\n        :type times1: List[int]\n        :type times2: List[int]\n        :rtype: bool\n        \"\"\"\n        # write your code here\n        if len(times1)!= len(times2):\n            return False\n        self.count += 1\n        if self.count % 10000000 == 0:\n            print('count:', self.count)\n        for i in range(len(times1)):\n            if times1[i] == times2[i]:\n                return True\n        return False\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution/\n\n# DFS: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/223988/C%2B%2B-Java%2B-%3F-solution-%3F-%3F-%3F-%3F-%3F\n# Time:  O(n)\n# Space: O(1)\n# # By using a map, we can store all the numbers in the given array. Then, we can check whether there is a duplicate in the array.\n# # If there is a duplicate, we can just increment the count. If there is no duplicate, we can just increment the count.\n# # If there is a duplicate, we can just increment the count.\n# # If there is no duplicate, we can just increment the count.\n# # If there is a duplicate, we can just increment the count.\n# # If there is no duplicate, we can just increment the count.\n\n# # The main idea is to use a map to store the numbers in the array.\n# # Then, we can"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param: first: a list of integers\n    @param: second: a list of integers\n    @return: a list of tuples\n    \"\"\"\n    def findDisappearedNumbers(self, first, second):\n        if len(first)!= len(second):\n            return [-1]\n\n        res = []\n        for i in range(len(first)):\n            if first[i] > second[i]:\n                res.append((first[i], second[i]))\n            elif first[i] < second[i]:\n                res.append((second[i], first[i]))\n            else:\n                res.append((first[i], second[i]))\n\n        return res"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Test(unittest.TestCase):\n    def setUp(self):\n        self.test_data = [\n            (('11:00:00', '22:00:00'), ('11:00:00', '22:00:00')),\n            (('11:00:00', '22:00:00'), ('22:00:00', '23:00:00')),\n            (('11:00:00', '22:00:00'), ('22:00:00', '22:00:00'))\n        ]\n\n    def test_occurrences(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00'), 3)\n\n    def test_occurrences_2(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00', '22:00:00'), 3)\n\n    def test_occurrences_3(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00', '22:00:00', '22:00:00'), 3)\n\n    def test_occurrences_4(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00'), 3)\n\n    def test_occurrences_5(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00'), 3)\n\n    def test_occurrences_6(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00', '22:00:00'), 3)\n\n    def test_occurrences_7(self):\n        self.assertEqual(occurrences('11:00:00', '22:00:"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def __init__(self, times):\n        \"\"\"\n        :type times: List[List[int]]\n        \"\"\"\n        self.times = times\n\n    def checkTime(self, times):\n        \"\"\"\n        :type times: List[int]\n        :rtype: int\n        \"\"\"\n        times = sorted(times)\n        start = times[0]\n        end = times[-1]\n        count = 0\n        for i in range(len(times)):\n            if times[i] > start and times[i] < end:\n                count += 1\n            else:\n                count -= 1\n        return count\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/check-time-of-day/solution/\n\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\n\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\n\n/**\n * Your CheckTimeOfDay object will be instantiated and called as such:\n * CheckTimeOfDay obj = new CheckTimeOfDay(intervals);\n * int param_1 = obj.checkTime(intervals);\n */\n\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "import math\n\n# Your function will be called like this:\n# f = Solution()\n# f.findClosestTime(day, hour, minute)\n# for i in f.findClosestTime(day, hour, minute):\n#     print i\n#     break\n\nclass Solution(object):\n    def findClosestTime(self, day, hour, minute):\n        \"\"\"\n        :type day: int\n        :type hour: int\n        :type minute: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(0, 24 * 60):\n            if i == hour:\n                res.append(day)\n                continue\n            delta = abs(i - hour)\n            if delta == 0 or delta == 1:\n                continue\n            if delta <= 60:\n                res.append(delta)\n                continue\n            if delta <= 60 * 2:\n                res.append(delta / 2)\n                continue\n            if delta <= 60 * 5:\n                res.append(delta / 5)\n                continue\n            if delta <= 60 * 10:\n                res.append(delta / 10)\n                continue\n            res.append(delta / 15)\n        return res\n\n# Your function will be called like this:\n# f = Solution()\n# f.findClosestTime(day, hour, minute)\n# for i in f.findClosestTime(day, hour, minute):\n#     print i"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def checkRecord(self, records, time):\n        \"\"\"\n        :type records: List[tuple]\n        :type time: int\n        :rtype: bool\n        \"\"\"\n        if not records: return False\n\n        d = {}\n        for r in records:\n            t = tuple(sorted(r))\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n\n        for t in d:\n            if d[t] > 1: return True\n\n        return False\n\nif __name__ == '__main__':\n    assert Solution().checkRecord([(1,2),(2,3)], 4) == True\n    assert Solution().checkRecord([(1,2),(2,2),(3,3)], 4) == False"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "import re\nimport math\nimport datetime\nimport collections\n\ndef check_time_similarity(t1, t2):\n    \"\"\"\n    Check whether the two given time tuples are similar.\n    :param t1: a tuple\n    :param t2: a tuple\n    :return: a boolean\n    \"\"\"\n    d1 = datetime.datetime.strptime(t1[0], \"%Y-%m-%d %H:%M:%S.%f\")\n    d2 = datetime.datetime.strptime(t2[0], \"%Y-%m-%d %H:%M:%S.%f\")\n    diff = abs(d1 - d2)\n    if diff.days > 1:\n        return False\n    else:\n        return True\n\n\ndef check_time_similarity_with_hour(t1, t2):\n    \"\"\"\n    Check whether the two given time tuples are similar.\n    :param t1: a tuple\n    :param t2: a tuple\n    :return: a boolean\n    \"\"\"\n    d1 = datetime.datetime.strptime(t1[0], \"%Y-%m-%d %H:%M:%S.%f\")\n    d2 = datetime.datetime.strptime(t2[0], \"%Y-%m-%d %H:%M:%S.%f\")\n    diff = abs(d1 - d2)\n    if diff.days > 1:\n        return False\n    else:\n        return True\n\n\ndef check_time_similarity_with_hour_and_minute(t1, t2):\n    \"\"\"\n    Check whether the two given time tuples are similar.\n    :param t1: a tuple\n    :param t2: a tuple\n    :return: a boolean\n    \"\"\"\n    d1 = datetime.datetime.strptime(t1[0], \"%Y-%m-%d %H:%M:%S.%f\")\n    d2 = datetime.datetime.strptime(t2[0], \"%Y-%m-%d %H:%M:%S.%f\")"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-similar-words/discuss/2711/Python-O(NlogN)-Time-O(N)-Space-Solution\n\n\ndef find_similar_words(word_list, query_list):\n    \"\"\"\n    :type word_list: List[str]\n    :type query_list: List[str]\n    :rtype: List[str]\n    \"\"\"\n    # write your code here\n    if not word_list or not query_list:\n        return []\n    word_list = sorted(word_list)\n    query_list = sorted(query_list)\n    res = []\n    for i in range(len(query_list)):\n        for j in range(i + 1, len(query_list)):\n            if query_list[i] == query_list[j]:\n                res.append(word_list[i])\n    return res\n\n\nif __name__ == \"__main__\":\n    words = [\"cat\", \"bat\", \"rat\", \"hat\"]\n    query = [\"bat\", \"cat\", \"hat\"]\n    res = find_similar_words(words, query)\n    print(res)"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "import time\nfrom itertools import groupby\n\ndef get_time_diff(time_tuple):\n    \"\"\"\n    Given a time tuple, return the difference between the time and now.\n    \"\"\"\n    return time.mktime(time.strptime(time_tuple[0], \"%H:%M:%S\")) - time.time()\n\ndef get_time_diff_from_group(group):\n    \"\"\"\n    Given a group of tuples, return the difference between the time and now.\n    \"\"\"\n    return [get_time_diff(t) for t in group]\n\ndef get_similar_times(time_tuple_list, diff):\n    \"\"\"\n    Given a list of tuples and the time difference, return the list of tuples which have similar times.\n    \"\"\"\n    return [t for t in time_tuple_list if get_time_diff(t) <= diff]\n\ndef get_similar_times_from_group(group, diff):\n    \"\"\"\n    Given a group of tuples and the time difference, return the list of tuples which have similar times.\n    \"\"\"\n    return [t for t in group if get_time_diff_from_group(t) <= diff]\n\ndef get_time_diff_from_group_list(group):\n    \"\"\"\n    Given a group of tuples, return the list of times which have similar times.\n    \"\"\"\n    return [get_time_diff_from_group(t) for t in group]\n\ndef get_time_diff_from_group_list_all(group):\n    \"\"\"\n    Given a group of tuples, return the list of times which have similar times.\n    \"\"\"\n    return [get_time_diff_from_group(t) for t in group]\n\ndef get_similar_times_all(time_tuple_list, diff):\n    \"\"\"\n    Given a list of tuples and the time difference, return the list of tuples which have similar times.\n    \"\"\"\n    return [t for t in time_tuple_list if get_time_diff_from_group_all(t) <= diff]\n\ndef get_time_diff_from_group_all(group):"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "def find_similar(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    # Write your code here\n    # For example, given the tuple of (1,2,3,4), and the tuple of (2,4,5,6), return the tuple (2,2,2,2)\n    return t1[0] * t2[0] + t1[1] * t2[1] + t1[2] * t2[2] + t1[3] * t2[3]\n\n\n# Your code here"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "import collections\n\ndef find_similar(t1, t2):\n    # Write your code here\n    # t1 and t2 are tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of tuples of strings\n    # t1 and t2 are lists of"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "import math\n\ndef get_similar_times(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    similar_times = []\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            if i!= j:\n                if tuple_list[i][0] == tuple_list[j][0] and tuple_list[i][1] == tuple_list[j][1] and tuple_list[i][2] == tuple_list[j][2]:\n                    similar_times.append(tuple_list[i])\n    return similar_times\n\ndef get_dist(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: int\n    \"\"\"\n    dist = 0\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            if i!= j:\n                if tuple_list[i][0] == tuple_list[j][0] and tuple_list[i][1] == tuple_list[j][1] and tuple_list[i][2] == tuple_list[j][2]:\n                    dist += math.sqrt((tuple_list[i][0] - tuple_list[j][0]) ** 2 + (tuple_list[i][1] - tuple_list[j][1]) ** 2 + (tuple_list[i][2] - tuple_list[j][2]) ** 2)\n    return dist\n\ndef get_similar_times_dist(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    similar_times = []\n    dist = get_dist(tuple_list)\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            if i!= j:\n                if tuple_list[i][0] == tuple_list[j][0] and tuple"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "import unittest\nimport timeit\n\nclass Solution(object):\n    def countSimilar(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A)!= len(B):\n            return 0\n        \n        # map from A to B\n        m = dict()\n        for i in range(len(A)):\n            m[A[i]] = B[i]\n        \n        # use map to find all the matches\n        return sum(map(lambda x: m[x] in m, A))\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/count-similar/solution/\n\n# DFS\n# 4ms 100%\nclass Solution {\n    public int countSimilar(int[] A, int[] B) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < A.length; i++) {\n            map.put(A[i], B[i]);\n        }\n        int res = 0;\n        for (int i = 0; i < A.length; i++) {\n            if (map.containsKey(A[i])) {\n                if (map.get(A[i]) == B[i]) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n# DFS + HashMap\n# 1ms 100%\nclass Solution {\n    public int countSimilar(int[] A, int[] B) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < A.length; i++) {\n            map.put(A[i], B[i]);\n        }\n        int res = 0;\n        for (int i = 0; i < A.length; i++) {\n            if (map.cont"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "import collections\n\n\nclass Solution(object):\n    def __init__(self, arr):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.count = collections.Counter()\n        for tup in arr:\n            self.count.update(tup)\n\n    def findSimilarRecords(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return [[self.count[tup] for tup in arr] for arr in self.findRecords(arr)]\n\n    def findRecords(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ans = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if self.count[arr[i]] == self.count[arr[j]]:\n                    ans.append(arr[i])\n                    ans.append(arr[j])\n        return ans\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(arr)\n# param_1 = obj.findSimilarRecords(arr)"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "import heapq\n\nclass TimeSlot(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __str__(self):\n        return '{}-{}'.format(self.start, self.end)\n\n    def __eq__(self, other):\n        if isinstance(other, TimeSlot):\n            return self.start == other.start and self.end == other.end\n        return False\n\n    def __lt__(self, other):\n        if isinstance(other, TimeSlot):\n            return self.start < other.start\n        return False\n\n    def __hash__(self):\n        return hash(str(self))\n\nclass TimeSlotHeap(object):\n    def __init__(self):\n        self.heap = []\n\n    def push(self, time):\n        heapq.heappush(self.heap, time)\n\n    def pop(self):\n        return heapq.heappop(self.heap)\n\n    def peek(self):\n        return self.heap[0]\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\n    def __len__(self):\n        return len(self.heap)\n\n    def __iter__(self):\n        return iter(self.heap)\n\n    def __getitem__(self, index):\n        return self.heap[index]\n\n    def __contains__(self, time):\n        return time in self.heap\n\ndef check_time_slots(tuples):\n    \"\"\"\n    :type tuples: List[TimeSlot]\n    :rtype: List[TimeSlot]\n    \"\"\"\n    time_slots = TimeSlotHeap()\n    for t in tuples:\n        time_slots.push(t)\n    while not time_slots.is_empty():\n        curr_time = time_slots.pop()\n        for next_time in tuples:\n            if next_time.start <= curr_time.end and next_time.end >= curr_time.start:\n                time_slots.push(next_time)"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findClosestElements(self, tuples, k):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :type k: int\n        :rtype: List[Tuple]\n        \"\"\"\n        d = {}\n        for t in tuples:\n            d[t] = d.get(t, 0) + 1\n        for t in tuples:\n            d[t] = d[t] / len(tuples)\n        l = []\n        for t in tuples:\n            if d[t] < k:\n                l.append(t)\n        return l"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # find the two different numbers\n        count = 0\n        for num1, num2 in zip(nums, nums[1:]):\n            if num1 == num2:\n                count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    assert sol.findDuplicate([1, 2, 2, 3]) == 2\n    assert sol.findDuplicate([1, 1, 1, 1]) == 1\n    assert sol.findDuplicate([1, 2, 2, 3, 3, 4]) == 0\n    assert sol.findDuplicate([1, 1, 1, 1, 1]) == 0"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, tup):\n        self.tup = tup\n\n    def __eq__(self, other):\n        return self.tup == other.tup\n\n    def __hash__(self):\n        return hash(self.tup)\n\nclass Solution(object):\n    def findDuplicate(self, tups):\n        \"\"\"\n        :type tups: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        hash_set = set()\n        for tup in tups:\n            hash_set.add(tup.tup)\n        return [tup for tup in tups if tup.tup in hash_set]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    tups = [Tuple((1, 2)), Tuple((1, 1)), Tuple((1, 3)), Tuple((1, 1)), Tuple((2, 1)), Tuple((2, 2))]\n    print(s.findDuplicate(tups))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# Example\n# >>> from timeit import timeit\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted, list, zip\")\n# >>> print(t)\n# 1000000 loops, best of 3: 4.99 s per loop\n# >>> t = timeit('sorted(list(zip([1,2,3], [1,2,3])))', setup=\"from __main__ import sorted"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "import re\nimport operator\n\n# My solution\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# # your code here\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# def occurrences(t1, t2):\n#     if len(t1)!= len(t2):\n#         return 0\n#     occurrence = 0\n#     for i in range(len(t1)):\n#         if t1[i] == t2[i]:\n#             occurrence += 1\n#     return occurrence\n#\n# def occurrences(t1, t2"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "def similar_records(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    similar_tuples = []\n\n    for i in range(len(tuples)):\n        for j in range(len(tuples)):\n            if i == j:\n                continue\n            if tuples[i][0] == tuples[j][0] and tuples[i][1] == tuples[j][1]:\n                similar_tuples.append(tuples[i])\n\n    return similar_tuples\n\ndef test_similiar_records():\n    tuples = [(1, '10:00'), (2, '10:00'), (3, '10:00'), (4, '10:00'), (5, '10:00'), (6, '10:00'), (7, '10:00'), (8, '10:00'), (9, '10:00'), (10, '10:00'), (11, '10:00'), (12, '10:00'), (13, '10:00'), (14, '10:00'), (15, '10:00'), (16, '10:00'), (17, '10:00'), (18, '10:00'), (19, '10:00'), (20, '10:00'), (21, '10:00'), (22, '10:00'), (23, '10:00'), (24, '10:00'), (25, '10:00'), (26, '10:00'), (27, '10:00'), (28, '10:00'), (29, '10:00'), (30, '10:00'), (31, '10:00'), (32, '10:00'), (33, '10:00'), (34, '10:00'), (35, '10:00'), (36, '10:00'), (37, '10:00'), (38, '10:00'), (39, '10:00'), (40, '10:00'), (41, '10:00'), (42, '10:00'), (43, '10:00'), (44, '10:00'), (45, '10:"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "import unittest\nimport time\n\nclass Solution(object):\n    def _similar(self, t1, t2):\n        \"\"\"\n        :type t1: List[int]\n        :type t2: List[int]\n        :rtype: bool\n        \"\"\"\n        i = 0\n        while i < len(t1) and i < len(t2):\n            if t1[i] == t2[i]:\n                i += 1\n            else:\n                return False\n        return True\n\n    def similar(self, t1, t2):\n        \"\"\"\n        :type t1: List[int]\n        :type t2: List[int]\n        :rtype: bool\n        \"\"\"\n        return len(filter(lambda x: self._similar(t1, x), t2)) > 0\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/similar-strings/solution/\n#\nApproach #1: Brute Force [Accepted]\nComplexity Analysis\nTime Complexity: O(m + n)\nSpace Complexity: O(m + n)\n\n# 7ms 98.32%\nclass Solution {\n    public boolean similar(int[] t1, int[] t2) {\n        int m = t1.length, n = t2.length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (t1[i] == t2[j]) return true;\n            }\n        }\n        return false;\n    }\n}\n\n# 7ms 98.32%\nclass Solution {\n    public boolean similar(int[] t1, int[] t2) {\n        int m = t1.length, n = t2.length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (t1["
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "import time\nfrom collections import Counter\n\nclass Solution:\n    def findSimilars(self, tuples, k):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # time complexity: O(k*n^2)\n        # space complexity: O(n^2)\n        # sort\n        tuples = sorted(tuples)\n        # count\n        count = Counter(tuples)\n        # dict\n        d = dict()\n        for key, value in count.items():\n            d[key] = value\n        # for each tuple\n        for i in range(len(tuples)):\n            for j in range(i+1, len(tuples)):\n                if d[tuples[i]][tuples[j]] == 1:\n                    # if tuples[i] and tuples[j] are in the same time, then return j\n                    return j\n        return -1\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.findSimilars([[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [2,3,5]], 2))\n    print(solution.findSimilars([[1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [2,3,5]], 1))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "import collections\nimport heapq\nimport itertools\n\nclass Solution(object):\n    def findDuplicates(self, t):\n        \"\"\"\n        :type t: List[int]\n        :rtype: int\n        \"\"\"\n        # the heap is sorted by time\n        heap = []\n        for tt in t:\n            heapq.heappush(heap, (tt, tt))\n        count = 0\n        while heap:\n            cur = heapq.heappop(heap)\n            count += 1\n            if cur[1] == cur[0]:\n                for tt in t:\n                    if tt == cur[0]:\n                        heapq.heappush(heap, (tt, tt))\n        return count\n\nif __name__ == \"__main__\":\n    print Solution().findDuplicates([1, 1, 2, 3])"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "import collections\n\nclass Solution:\n    def checkRecord(self, record, times):\n        \"\"\"\n        :type record: List[int]\n        :type times: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(times)\n        for i in range(len(record)):\n            if record[i] not in count:\n                return i\n        return -1\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = []\n# param_2 = []\n# obj.checkRecord(param_1, param_2)"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "from collections import Counter\nimport heapq\n\nclass CounterHeap(object):\n    def __init__(self, num_heap):\n        self.counter_heap = num_heap\n\n    def push(self, item):\n        self.counter_heap.push(item)\n\n    def pop(self):\n        return self.counter_heap.pop()\n\n    def top(self):\n        return self.counter_heap.top()\n\n    def peek(self):\n        return self.counter_heap.peek()\n\n    def __len__(self):\n        return len(self.counter_heap)\n\n    def __str__(self):\n        return str(self.counter_heap)\n\n\ndef count_similar(tuple_list, num_heap, count_heap):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :type num_heap: CounterHeap\n    :type count_heap: CounterHeap\n    :rtype: List[tuple]\n    \"\"\"\n    for tuple_item in tuple_list:\n        if tuple_item not in num_heap:\n            num_heap.push(tuple_item)\n        else:\n            if count_heap.top() == tuple_item:\n                continue\n            heapq.heappush(count_heap, tuple_item)\n            heapq.heappush(num_heap, tuple_item)\n    return count_heap\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert count_similar([(\"a\", 2), (\"a\", 1), (\"b\", 2), (\"b\", 3), (\"c\", 4)], CounterHeap(), CounterHeap()), \"1\"\n    assert count_similar([(\"a\", 2), (\"a\", 1), (\"b\", 2), (\"b\", 3), (\"c\", 4)], CounterHeap(), CounterHeap()), \"2\"\n    assert count_similar([(\"a\", 2), (\"a\", 1), (\"b\", 2), (\"b\", 3), (\"c\", 4)], CounterHeap(), CounterHeap()),"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def similar_times(time_list):\n    \"\"\"\n    :type time_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # write your code here\n    return time_list"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "def check_times(tuple_list):\n    \"\"\"\n    :type tuple_list: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not tuple_list:\n        return []\n\n    # sort the list\n    tuple_list = sorted(tuple_list, key=lambda t: t[0])\n\n    # initialise the result list\n    res = [0] * len(tuple_list)\n\n    # iterate over the list\n    for i in range(len(tuple_list)):\n        # get the time difference between the first tuple and the current tuple\n        delta = tuple_list[i][0] - tuple_list[i-1][0]\n\n        # if the delta is small, the time difference between the current tuple and the next tuple is small\n        # we can skip the current tuple as it is not similar to any other tuple\n        if delta <= 1:\n            continue\n\n        # if the time difference between the current tuple and the next tuple is big, we can assume that the\n        # time difference between the current tuple and the previous tuple is big too\n        # so we can skip the current tuple and all the following tuples\n        if delta > 1:\n            break\n\n        # if the time difference between the current tuple and the next tuple is big, we can assume that the\n        # time difference between the current tuple and the previous tuple is big too\n        # so we can skip the current tuple and all the following tuples\n        if delta > 2:\n            break\n\n        # if the time difference between the current tuple and the next tuple is big, we can assume that the\n        # time difference between the current tuple and the previous tuple is big too\n        # so we can skip the current tuple and all the following tuples\n        if delta > 3:\n            break\n\n        # if the time difference between the current tuple and the next tuple is big, we can assume that the\n        # time difference between the current tuple and the previous tuple is big too\n        # so we can skip the current tuple and all the following tuples\n        if delta > 4:\n            break\n\n        # if the time difference between the current tuple and the next tuple is big, we can assume that the\n        # time difference between the current tuple and the previous"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# -*- coding:utf-8 -*-\nclass Solution:\n    # @param {List[List[int]]} tuples\n    # @return {int}\n    def findSimiliarRecords(self, tuples):\n        # Write your code here\n        if not tuples:\n            return 0\n        n = len(tuples)\n        if n == 1:\n            return 0\n\n        # sort tuples\n        tuples.sort(key=lambda t: t[0])\n        # store the max_index\n        max_index = 0\n        max_value = -1\n        for i in range(n):\n            if tuples[i][0] == tuples[i+1][0]:\n                # store the max value in max_value\n                max_value = max(max_value, tuples[i][1])\n            else:\n                # if the max_value is different, store it in max_value\n                if max_value!= -1:\n                    max_index = i\n                    max_value = -1\n        # store the max_index\n        max_index += 1\n\n        # store the max_value\n        max_value = -1\n        for i in range(n):\n            if tuples[i][0] == tuples[i+1][0] and tuples[i][1] == tuples[i+1][1]:\n                max_value = max(max_value, tuples[i][1])\n            else:\n                # if the max_value is different, store it in max_value\n                if max_value!= -1:\n                    max_index = i\n                    max_value = -1\n        # store the max_index\n        max_index += 1\n\n        # store the max_value\n        max_value = -1\n        for i in range(n):\n            if tuples[i][0] == tuples[i+1][0] and tuples[i][1]!= tuples[i+1][1]:\n                max_value = max(max_value, tuples[i][1])\n            else:\n                # if the max_value is different, store it in max_value\n                if max_value!= -1"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def checkRecord(self, records, times):\n        \"\"\"\n        :type records: List[int]\n        :type times: List[int]\n        :rtype: int\n        \"\"\"\n        if not records or not times:\n            return 0\n\n        max_dif = 0\n        max_idx = 0\n\n        for i in range(len(records)):\n            if times[i]!= records[i]:\n                dif = abs(records[i] - times[i])\n                if dif > max_dif:\n                    max_dif = dif\n                    max_idx = i\n\n        if max_dif == 0:\n            return 0\n\n        return max_idx + 1"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Time:  O(N^2)\n# Space: O(N)\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def _compare(self, x, y):\n        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\n    def _get_dist(self, x, y):\n        return abs(x[0] - y[0]) + abs(x[1] - y[1])\n\n    def _get_max_dist(self, x, y):\n        return max(abs(x[0] - y[0]), abs(x[1] - y[1]))\n\n    def checkPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        for i in range(len(tuples)):\n            for j in range(i + 1, len(tuples)):\n                if self._get_dist(tuples[i], tuples[j]) <= self._get_max_dist(tuples[i], tuples[j]):\n                    result.append(tuples[i])\n                    result.append(tuples[j])\n        return result\n\n\nclass Solution2(object):\n    def _get_dist(self, x, y):\n        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\n    def _get_max_dist(self, x, y):\n        return max(abs(x[0] - y[0]), abs(x[1] - y[1]))\n\n    def checkPairs(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        for i in range(len(tuples)):\n            for j in range(i + 1, len(tuples)):\n                if self._get_dist"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "import math\nimport sys\n\nclass Solution(object):\n    def countSimilar(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A)!= len(B):\n            return 0\n        count = 0\n        for i in xrange(len(A)):\n            if A[i]!= B[i]:\n                diff = abs(A[i] - B[i])\n                if diff == 0 or diff == 1:\n                    count += 1\n        return count\n\n    def countSimilar1(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        # write your code here\n        if len(A)!= len(B):\n            return 0\n        max_diff = 0\n        count = 0\n        for i in xrange(len(A)):\n            max_diff = max(max_diff, abs(A[i] - B[i]))\n        return max(1, math.ceil(float(len(A)) / max_diff))\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    A = [1, 2, 3, 4, 5]\n    B = [2, 3, 3, 5, 5]\n    print sol.countSimilar(A, B)\n    A = [1, 2, 3, 3, 4, 5]\n    B = [2, 3, 3, 5, 5]\n    print sol.countSimilar(A, B)\n    A = [1, 2, 3, 3, 4, 5]\n    B = [2, 3, 3, 5, 5]\n    print sol.countSimilar1(A, B)"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findDuplicates(self, tuples):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        d = {}\n        for t in tuples:\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n        return [k for k, v in d.items() if v > 1]\n\n\na = Solution()\n\nprint a.findDuplicates([[1, 2], [2, 3], [2, 3], [2, 3], [2, 3]])"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/similar-strings/discuss/2048/Easy-to-understand-and-very-fast-Java-solution\n\nclass Solution:\n    # @param {List[List[int]]} arr\n    # @return {List[int]}\n    def findDuplicate(self, arr: List[List[int]]) -> List[int]:\n        dic = {}\n        for t in arr:\n            for i in range(len(t)):\n                if t[i] in dic:\n                    dic[t[i]].append(i)\n                else:\n                    dic[t[i]] = [i]\n\n        for t in arr:\n            for i in range(len(t)):\n                if len(dic[t[i]]) > 1:\n                    return [t[i]] + dic[t[i]][1:]\n        return []\n\n\nif __name__ == \"__main__\":\n    arr = [[1,2,3], [2,3,1], [1,2,2], [1,1,1]]\n    arr = [[1,2,3,3], [2,3,1,1], [1,2,2,2], [1,1,1,1]]\n    solution = Solution()\n    print(solution.findDuplicate(arr))"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "def find_similar_records(records):\n    \"\"\"\n    Write a function to check the occurrences of records which occur similar times in the given tuples.\n\n    For example, given [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9)]\n   , the function should return a list [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9)]\n   , which is the occurrences of the records which are similar times in the given tuples.\n    \"\"\"\n    result = []\n    for r1 in records:\n        for r2 in records:\n            if r1!= r2 and r1[0] == r2[0] and r1[1] == r2[1]:\n                result.append(r1)\n    return result\n\n\nif __name__ == '__main__':\n    records = [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9)]\n    print(find_similar_records(records))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "from collections import defaultdict\nfrom operator import itemgetter\n\ndef similar_records(tuples, k=1):\n    \"\"\"\n    :type tuples: List[tuple]\n    :type k: int\n    :rtype: List[tuple]\n    \"\"\"\n    records = defaultdict(list)\n    for t in tuples:\n        for i in range(k):\n            records[t[i]].append(t)\n    return sorted(records.items(), key=itemgetter(1), reverse=True)\n\n\n# Your Solution\n#\n# Note:\n# You can assume that the given tuples are all unique.\n#\n# Example:\n#\n# Input:\n# [('a', 1), ('a', 2), ('a', 3), ('a', 4), ('b', 1), ('c', 1)]\n# k = 2\n# Output:\n# [['a', 2], ['a', 4], ['b', 1], ['c', 1]]"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import collections\n\ndef check_occurrences(tuples):\n    \"\"\"\n    :type tuples: List[List[int]]\n    :rtype: int\n    \"\"\"\n    occurrences = collections.Counter()\n    for t in tuples:\n        for i in range(len(t)):\n            occurrences[t[i]] += 1\n    return occurrences.most_common(1)[0][1]\n\nif __name__ == \"__main__\":\n    tuples = [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n    print(check_occurrences(tuples))"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import timeit\n\n\nclass Solution:\n    def checkRecord(self, records, times):\n        \"\"\"\n        :type records: List[List[int]]\n        :type times: List[int]\n        :rtype: List[bool]\n        \"\"\"\n        times.sort()\n        result = [False] * len(records)\n        for i, record in enumerate(records):\n            if i == 0:\n                for j in range(len(times)):\n                    if record[j] >= times[j]:\n                        result[i] = True\n                        break\n            else:\n                for j in range(len(times)):\n                    if record[j] >= times[j] and (record[j] - times[j]) == j:\n                        result[i] = True\n                        break\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4, 5]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4, 5, 6]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4, 5, 6, 7]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4, 5, 6, 7, 8]))\n    print(sol.checkRecord([[1, 2, 3], [3, 4, 5], [3, 4, 5]], [1, 2, 3, 4,"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "import collections\n\nclass Solution(object):\n    def times2(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not arr:\n            return []\n        \n        dic = collections.defaultdict(list)\n        for r in arr:\n            for i in range(len(r)):\n                dic[r[i]].append(r[:i] + [r[i+1]] + r[i+2:])\n                \n        return [dic[x][0] for x in dic if len(dic[x]) > 1]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/similar-strings/discuss/1608/Java-C%2B%2B-O(n^2)-Java-O(n)\n# https://leetcode.com/problems/similar-strings/discuss/1607/Java-C%2B%2B-O(n)-Java-O(n)\n# https://leetcode.com/problems/similar-strings/discuss/1606/Java-C%2B%2B-O(n^2)-Java-O(n)\n# https://leetcode.com/problems/similar-strings/discuss/1604/Java-C%2B%2B-O(n)-Java-O(n)\n\nfrom collections import defaultdict\nimport unittest\n\n\nclass Solution(object):\n    def _getSimilarity(self, a, b):\n        \"\"\"\n        :type a: List[str]\n        :type b: List[str]\n        :rtype: int\n        \"\"\"\n        m = len(a)\n        n = len(b)\n        dp = defaultdict(lambda: 0)\n        for i in range(m):\n            for j in range(n):\n                if a[i] == b[j]:\n                    dp[(i, j)] = dp[(i - 1, j - 1)] + 1\n        return dp[(m - 1, n - 1)]\n\n    def _getSimilarity2(self, a, b):\n        \"\"\"\n        :type a: List[str]\n        :type b: List[str]\n        :rtype: int\n        \"\"\"\n        m = len(a)\n        n = len(b)\n        dp = defaultdict(lambda: 0)\n        for i in range(m):\n            for j in range(n):\n                if a[i] == b[j]:\n                    dp[(i, j)] = dp[(i - 1, j - 1)] + 1\n                elif a[i] == b[j + 1]:\n                    dp[(i, j)] = dp[(i - 1, j)] + 1\n                elif a[i]"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from itertools import groupby\n\ndef find_similar_time(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: t[0] - t[1])\n\ndef find_similar_time_rec_iter(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_iter_2(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_2(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: t[0] - t[1])\n\ndef find_similar_time_rec_2_2(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_2_3(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_2_4(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_2_5(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_rec_2_6(tuples):\n    # O(n) time\n    return groupby(tuples, lambda t: (t[0] - t[1]).total_seconds())\n\ndef find_similar_time_"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "import unittest\nimport random\nimport time\nimport sys\n\nclass Solution(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.num_map = {}\n        self.start_time = time.time()\n\n    def count(self, t1, t2):\n        \"\"\"\n        :type t1: List[int]\n        :type t2: List[int]\n        :rtype: int\n        \"\"\"\n        # print t1, t2\n        t1.sort()\n        t2.sort()\n        i = 0\n        j = 0\n        while i < len(t1) and j < len(t2):\n            if t1[i] == t2[j]:\n                i += 1\n                j += 1\n            elif t1[i] < t2[j]:\n                i += 1\n            else:\n                j += 1\n        if i == len(t1) and j == len(t2):\n            return 1\n        elif i == len(t1):\n            return 0\n        else:\n            return 0\n\n    def get_time(self, t1, t2):\n        \"\"\"\n        :type t1: List[int]\n        :type t2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # print t1, t2\n        t1.sort()\n        t2.sort()\n        i = 0\n        j = 0\n        while i < len(t1) and j < len(t2):\n            if t1[i] == t2[j]:\n                i += 1\n                j += 1\n            elif t1[i] < t2[j]:\n                i += 1\n            else:\n                j += 1\n        if i == len(t1) and j == len(t2):\n            return t1[:i]\n        elif i == len(t1):\n            return t2[:j]\n        else:\n            return []\n\n    def get_count(self, t1, t2"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import math\nfrom collections import defaultdict\n\n\nclass Solution(object):\n    def similar(self, tuple_list):\n        \"\"\"\n        :type tuple_list: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        tuple_dict = defaultdict(int)\n        for t in tuple_list:\n            for i in range(len(t)):\n                tuple_dict[t[i]] += 1\n        for key, value in tuple_dict.items():\n            if value < 2:\n                return key\n        return tuple_list[0]\n\n\nif __name__ == '__main__':\n    assert Solution().similar([[1, 2, 3], [1, 2, 4], [1, 2, 3]]) == [1, 2, 3]\n    assert Solution().similar([[1, 2, 3], [1, 2, 4], [1, 2, 3]]) == [1, 2, 3]"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "import datetime\nfrom collections import defaultdict\n\nclass Solution:\n    # @param {integer[]} events\n    # @param {integer[]} times\n    # @return {integer}\n    def numSimilars(self, events, times):\n        if not events or not times:\n            return 0\n        # sort events by time\n        events = sorted(events, key=lambda x: x[1])\n        times = sorted(times, key=lambda x: x)\n        event_map = defaultdict(list)\n        for e, t in zip(events, times):\n            event_map[t].append(e)\n        # sort by time\n        for event_list in event_map.values():\n            event_list.sort(key=lambda x: x[1])\n        # count similar times\n        result = 0\n        for event_list in event_map.values():\n            for i in range(1, len(event_list)):\n                if event_list[i][0] == event_list[i-1][0]:\n                    result += 1\n        return result\n\n# Time:  O(n * m)\n# Space: O(n)\nclass Solution2:\n    # @param {integer[]} events\n    # @param {integer[]} times\n    # @return {integer}\n    def numSimilars(self, events, times):\n        if not events or not times:\n            return 0\n        # sort events by time\n        events = sorted(events, key=lambda x: x[1])\n        times = sorted(times, key=lambda x: x)\n        # count similar times\n        result = 0\n        for i in range(1, len(events)):\n            if times[i] == times[i-1]:\n                result += 1\n        return result\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3:\n    # @param {integer[]} events\n    # @param {integer[]} times\n    # @return {integer}\n    def numSimilars(self, events, times):\n        if not events or not times:\n            return 0\n        # sort events by time\n        events = sorted(events,"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/check-binary-search-tree-for-duplicate-subtrees/discuss/330031/Python-JavaScript-Solution-O(n-log-n)\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSimilarBST(self, root, A):\n        \"\"\"\n        :type root: TreeNode\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        l = len(A)\n        if l <= 1:\n            return root.val == A[0]\n        if root.val < A[0]:\n            return False\n        if root.val > A[0]:\n            return True\n        return self.isSimilarBST(root.left, A[1:]) and self.isSimilarBST(root.right, A[1:])"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/similar-strings/\nclass Solution(object):\n    def findClosestStrings(self, A, B):\n        \"\"\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if not A:\n            return []\n        d = defaultdict(int)\n        for s in A:\n            for t in B:\n                d[s+t] += 1\n        result = []\n        for k, v in d.items():\n            if v == len(B):\n                result.append(k)\n        return result\n\n\nif __name__ == \"__main__\":\n    A = [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaaa\", \"aaaaaaa\", \"aaaaaaaa\", \"aaaaaaaaa\"]\n    B = [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaaa\", \"aaaaaaa\", \"aaaaaaaa\", \"aaaaaaaaa\"]\n    solution = Solution()\n    print(solution.findClosestStrings(A, B))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "import unittest\nfrom collections import defaultdict\n\n\nclass Solution:\n    def findDuplicates(self, tuples):\n        \"\"\"\n        :type tuples: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        duplicates = defaultdict(list)\n        for tup in tuples:\n            for i in range(len(tup)):\n                if tup[i] == tup[i - 1]:\n                    duplicates[tup[i - 1]].append(tup[i])\n\n        return [k for k, v in duplicates.items() if len(v) > 1]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [1, 2, 3]])\n        self._test([[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4], [1, 2, 3]])\n        self._test([[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4], [2, 3, 4]])\n        self._test([[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4], [1, 2, 3]])\n        self._test([[1, 2, 3], [2, 3, 4]], [[1, 2, 3], [2, 3, 4]])\n\n    def _test(self, tuples, exp):\n        sol = Solution()\n        self.assertEqual(sol.findDuplicates(tuples), exp)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, tup):\n        self.tup = tup\n\nclass Solution(object):\n    def occur(self, tups, key):\n        \"\"\"\n        :type tups: List[Tuple]\n        :type key: str\n        :rtype: int\n        \"\"\"\n        # Use a map to store the keys of each tuple.\n        map = {}\n        for tup in tups:\n            map[tup] = map.get(tup, 0) + 1\n\n        # Count the occurrences of the key in all tuples.\n        count = 0\n        for tup in tups:\n            if tup.tup.count(key) == 1:\n                count += 1\n                map[tup] = map.get(tup, 0) - 1\n\n        return count"
    }
  ]
}