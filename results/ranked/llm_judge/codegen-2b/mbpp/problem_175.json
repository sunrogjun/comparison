{
  "timestamp": "2025-09-14T18:39:50.545902",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 175,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# -*- coding: utf-8 -*-\n# @Author: omi\n# @Date:   2014-08-10 21:05:48\n# @Last Modified by:   omi\n# @Last Modified time: 2015-07-18 12:12:36\n\nclass Solution(object):\n    \"\"\"\n    @param s: A string\n    @param literals: A list of string\n    @return: A boolean\n    \"\"\"\n    def isMatch(self, s, literals):\n        # write code here\n        if not s or not literals:\n            return False\n        if s == literals[0]:\n            return True\n        if s[0] == literals[0][0]:\n            return self.isMatch(s[1:], literals[1:])\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isMatch(\"aa\", \"a\")\n    print s.isMatch(\"aa\", \"a*\")\n    print s.isMatch(\"aaa\", \"aa\")\n    print s.isMatch(\"aa\", \".*\")\n    print s.isMatch(\"aa\", \"a.a\")\n    print s.isMatch(\"aa\", \".*a\")"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {string} s\n    # @param {string[]} words\n    # @return {boolean}\n    def isLiteral(self, s, words):\n        if not words:\n            return True\n        for w in words:\n            if re.search(w, s):\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.isLiteral(\"a\", [\"a\",\"b\",\"c\"]))\n    print(sol.isLiteral(\"abc\", [\"a\",\"b\",\"c\"]))\n    print(sol.isLiteral(\"abc\", [\"a\",\"b\",\"c\",\"d\"]))\n    print(sol.isLiteral(\"abc\", [\"a\",\"b\",\"c\",\"d\",\"e\"]))\n    print(sol.isLiteral(\"abc\", [\"a\",\"b\",\"c\",\"d\",\"a\"]))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\n# Example:\n# Input:\n# s = \"hello world\"\n# literals = [\"hello\", \"world\"]\n# Output: True\n# Explanation:\n# \"hello\" is in \"hello world\"\n# \"world\" is in \"hello world\"\n\n# Note:\n# The size of literals is small than 50.\n# The size of string is between 1 and 100.\n# The size of input string will not exceed 1,000,000.\n\nclass Solution(object):\n    def isMatch(self, s, literals):\n        \"\"\"\n        :type s: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        if not literals:\n            return False\n\n        # store the last used position in the string\n        last_used = 0\n        for i, l in enumerate(literals):\n            # for each literal\n            # if the string does not contain the literal\n            # then the function will return false\n            if not s.find(l, last_used):\n                return False\n\n            # the last used position in the string will be the last position\n            # in the literal\n            last_used = i + 1\n\n        # all literals were used in the string\n        return True"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport re\n\nclass Solution:\n    \"\"\"\n    @param s: A string\n    @return: A list of strings\n    \"\"\"\n    def findLiterals(self, s):\n        regex = re.compile(r'(\\\".*?\\\")|(\\'.*?\\')')\n        result = []\n        for match in regex.finditer(s):\n            if match.group(1):\n                result.append(match.group(1)[1:-1])\n            else:\n                result.append(match.group(2)[1:-1])\n        return result\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findLiterals(\"a.b.c\")\n    print s.findLiterals(\"\\\"a\\\"\")\n    print s.findLiterals(\"a.b.c\")\n    print s.findLiterals(\"a\")\n    print s.findLiterals(\"a.b.c.d\")\n    print s.findLiterals(\"\\\"a.b.c\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h.i\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h.i.j\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h.i.j.k\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h.i.j.k.l\\\"\")\n    print s.findLiterals(\"\\\"a.b.c.d.e.f.g.h."
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import re\n\ndef search(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list[str]\n    :rtype: bool\n    \"\"\"\n    result = False\n    for literal in literals:\n        if re.search(literal, string):\n            result = True\n            break\n    return result\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    string = 'I love you.'\n    literals = ['love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love', 'love"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, text, k):\n        \"\"\"\n        :type text: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        re_str = \"^[a-zA-Z]*\"\n        re_list = re.findall(re_str, text)\n        re_list.sort()\n        return re_list.index(k)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search(\"abcabcbb\", 2)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: int\n        \"\"\"\n        if not text or not query:\n            return -1\n        return text.find(query)"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not text or not literals:\n            return []\n\n        text = text.lower()\n        literals = [x.lower() for x in literals]\n\n        # search first char\n        if text[0] in literals:\n            return [0]\n\n        # search all chars\n        for i in range(len(text)):\n            if text[i] in literals:\n                return [i + 1]\n\n        return []\n\n    # @param text, a string\n    # @param literals, a list of string\n    # @return a list of integers\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not text or not literals:\n            return []\n\n        text = text.lower()\n        literals = [x.lower() for x in literals]\n\n        # search first char\n        if text[0] in literals:\n            return [0]\n\n        # search all chars\n        for i in range(len(text)):\n            if text[i] in literals:\n                return [i + 1]\n\n        return []"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @param literals, a string\n    # @return an integer\n    def numSubstrings(self, s, literals):\n        # write your code here\n        s = list(s)\n        i, j = 0, 0\n        res = 0\n        while i < len(s):\n            while j < len(literals) and s[i]!= literals[j]:\n                j += 1\n            if j == len(literals):\n                res += 1\n                j = 0\n            i += 1\n            j += 1\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.numSubstrings('abcabc', 'bc')\n    print s.numSubstrings('abcabc', 'abc')"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        if not p:\n            return True\n\n        m = defaultdict(int)\n        for c in p:\n            m[c] += 1\n\n        def dfs(i, j):\n            if i == j:\n                return True\n            if s[i]!= p[i]:\n                return False\n            if s[i] == '*':\n                return True\n            if m[s[i]] == 0:\n                return False\n            m[s[i]] -= 1\n            return dfs(i+1, j) or dfs(i, j-1)\n\n        return dfs(0, len(s))\n\n\nif __name__ == \"__main__\":\n    print Solution().search(\"banana\", \"bana\")\n    print Solution().search(\"banana\", \"banana\")\n    print Solution().search(\"banana\", \"banana\")\n    print Solution().search(\"banana\", \"banana\")"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, s, p):\n        \"\"\"\n        :param s: str\n        :param p: str\n        :return: bool\n        \"\"\"\n        return s.find(p) >= 0\n\n    def search_all(self, s, p):\n        \"\"\"\n        :param s: str\n        :param p: str\n        :return: List[int]\n        \"\"\"\n        res = []\n        m = len(s)\n        n = len(p)\n        for i in range(m):\n            for j in range(n):\n                if self.search(s[i:m], p[j:n]):\n                    res.append(i)\n        return res\n\n\nif __name__ == \"__main__\":\n    print Solution().search_all(\"hello\", \"el\")"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\n# https://leetcode.com/problems/search-in-rotated-sorted-array/\n\n# A simple approach, we just use the python standard library.\ndef search(needle, haystack):\n    index = 0\n    while index < len(haystack):\n        if haystack[index] == needle:\n            return True\n        else:\n            index += 1\n    return False\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    index = 0\n    while index < len(haystack):\n        if re.match(needle, haystack[index]):\n            return True\n        else:\n            index += 1\n    return False\n\n# The python standard library provides a built-in function for the regex.\ndef search(needle, haystack):\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    # The built-in function for the regex.\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    # The built-in function for the regex.\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    # The built-in function for the regex.\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    # The built-in function for the regex.\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, haystack):\n    # The built-in function for the regex.\n    return re.search(needle, haystack)\n\n# Another way.\n# We use the python standard library for the regex.\ndef search(needle, hay"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution:\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: bool\n        \"\"\"\n        return S.find(P)!= -1\n\n\nif __name__ == \"__main__\":\n    assert Solution().search(\"a\", \"a\") == True\n    assert Solution().search(\"a\", \"b\") == False\n    assert Solution().search(\"\", \"a\") == False\n    assert Solution().search(\"aa\", \"a\") == True"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import re\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_string_literal(string, literal):\n    return string.find(literal)\n\n# Returns the index of the last occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_last_string_literal(string, literal):\n    return string.rfind(literal)\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_first_string_literal(string, literal):\n    return string.find(literal)\n\n# Returns the index of the last occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_last_string_literal_in_range(string, start, end, literal):\n    return string.rfind(literal, start, end)\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_first_string_literal_in_range(string, start, end, literal):\n    return string.find(literal, start, end)\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_first_string_literal_in_slice(string, start, end, literal):\n    return string.find(literal, start, end)\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_first_string_literal_in_slice_in_range(string, start, end, literal):\n    return string.find(literal, start, end)\n\n# Returns the index of the first occurrence of the string literal in the\n# string.\n# Returns -1 if the string literal is not found.\ndef find_first_string_literal_in_slice_in_range"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nGiven a string, find the first non-repeating character in it and return it's index.\nIf there is no non-repeating character, return -1.\n\nExamples:\n\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n\nNote:\nYou may assume the string contain only lowercase letters.\n\"\"\"\n\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def firstUniqChar(self, s):\n        # Write your code here\n        i = 0\n        while i < len(s):\n            if s[i] not in s[i + 1:]:\n                break\n            i += 1\n        if i == len(s):\n            return -1\n        return i\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.firstUniqChar(\"leetcode\")\n    s.firstUniqChar(\"loveleetcode\")"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/string-search-regex/problem\n\nfrom collections import defaultdict\nimport re\n\n\ndef search_regex(regex, string):\n    \"\"\"\n    :type regex: str\n    :type string: str\n    :rtype: int\n    \"\"\"\n    pattern = re.compile(regex)\n    matches = 0\n    for word in string.split():\n        if pattern.match(word):\n            matches += 1\n    return matches\n\n\ndef main():\n    \"\"\"\n    Main.\n    \"\"\"\n    string = input()\n    regex = input()\n    print(search_regex(regex, string))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        target = \"\".join(target)\n        return text.find(target)\n\n\ndef main():\n    s = Solution()\n    s.search(\"\", \"\")\n    s.search(\"abcd\", \"a\")\n    s.search(\"abcd\", \"b\")\n    s.search(\"abcd\", \"c\")\n    s.search(\"abcd\", \"d\")\n    s.search(\"abcd\", \"e\")\n    s.search(\"abcd\", \"f\")\n    s.search(\"abcd\", \"g\")\n    s.search(\"abcd\", \"h\")\n    s.search(\"abcd\", \"i\")\n    s.search(\"abcd\", \"j\")\n    s.search(\"abcd\", \"k\")\n    s.search(\"abcd\", \"l\")\n    s.search(\"abcd\", \"m\")\n    s.search(\"abcd\", \"n\")\n    s.search(\"abcd\", \"o\")\n    s.search(\"abcd\", \"p\")\n    s.search(\"abcd\", \"q\")\n    s.search(\"abcd\", \"r\")\n    s.search(\"abcd\", \"s\")\n    s.search(\"abcd\", \"t\")\n    s.search(\"abcd\", \"u\")\n    s.search(\"abcd\", \"v\")\n    s.search(\"abcd\", \"w\")\n    s.search(\"abcd\", \"x\")\n    s.search(\"abcd\", \"y\")\n    s.search(\"abcd\", \"z\")\n    s.search(\"abcd\", \"a\")\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\nclass Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: bool\n        \"\"\"\n        return any(x in S for x in P)\n\n    def search_2(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: bool\n        \"\"\"\n        return any(x in S for x in P)\n\n\nif __name__==\"__main__\":\n    print(Solution().search_2(\"abcd\", \"ab\"))\n    print(Solution().search_2(\"abcd\", \"bc\"))\n    print(Solution().search_2(\"abcd\", \"cd\"))\n    print(Solution().search_2(\"abcd\", \"d\"))\n    print(Solution().search_2(\"abcd\", \"ab\"))\n    print(Solution().search_2(\"abcd\", \"a\"))\n    print(Solution().search_2(\"abcd\", \"z\"))\n    print(Solution().search_2(\"abcd\", \"abd\"))\n    print(Solution().search_2(\"abcd\", \"bcd\"))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nTake the literal in the string literal1 and search it in the string literal2.\n\nExample 1:\n\nInput: literal1 = \"the sky is blue\", literal2 = \"the sky is green\"\nOutput: true\nExplanation: literal2 contains the literal1.\n\nExample 2:\n\nInput: literal1 = \"the sky is blue\", literal2 = \"the sky is yellow\"\nOutput: false\nExplanation: literal2 does not contain the literal1.\n\"\"\"\n\nclass Solution(object):\n    def isLiteralSubstring(self, literal, s):\n        \"\"\"\n        :type literal: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return len(s) >= len(literal) and s.startswith(literal) and s.endswith(literal)\n\n    def isLiteralSubstring2(self, literal, s):\n        return s.startswith(literal) and s.endswith(literal)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.isLiteralSubstring(\"the sky is blue\", \"the sky is green\")\n    print s.isLiteralSubstring(\"the sky is blue\", \"the sky is yellow\")\n    print s.isLiteralSubstring2(\"the sky is blue\", \"the sky is green\")\n    print s.isLiteralSubstring2(\"the sky is blue\", \"the sky is yellow\")"
    },
    {
      "rank": 20,
      "score": 9.0,
      "candidate": "#!/usr/bin/env python\n# coding: utf-8\n\nimport re\n\n\ndef search_literals(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list\n    :rtype: str\n    \"\"\"\n    result = \"\"\n    for literal in literals:\n        if literal in string:\n            result = literal\n            break\n    return result\n\n\nif __name__ == '__main__':\n    # string = \"I love you, I love you, I love you, I love you, I love you!\"\n    string = \"I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you!\"\n    # literals = [\"I love you\", \"I love you, I love you\", \"I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you\"]\n    literals = [\"I love you\", \"I love you, I love you\", \"I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you, I love you\"]\n    print(search_literals(string, literals))"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "import re\n\n\ndef search_literals(string, literals):\n    for literal in literals:\n        if re.search(literal, string):\n            return literal\n    return None\n\n\nif __name__ == '__main__':\n    string ='some string'\n    literals = ['s','m', 'o','st', 'ing']\n    print(search_literals(string, literals))"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "# https://oj.leetcode.com/problems/search-a-2d-matrix-ii/\n# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix or not target: return False\n        matrix.sort(key=lambda x: x[0])\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if j == 0:\n                    if matrix[i][j] == target:\n                        return True\n                    else:\n                        continue\n                if j == len(matrix[0])-1:\n                    if matrix[i][j] == target:\n                        return True\n                    else:\n                        continue\n                if matrix[i][j] == target:\n                    return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 22)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literal(string, literal):\n    \"\"\"\n    :type string: str\n    :type literal: str\n    :rtype: bool\n    \"\"\"\n    return re.search(literal, string)\n\nif __name__ == '__main__':\n    s = \"The quick brown fox jumps over the lazy dog\"\n    l = \"brown\"\n    print(search_literal(s, l))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "from string import digits\n\ndef search_literals(string, literals):\n    \"\"\"\n    Return the index of literals strings in a string.\n    \"\"\"\n    regex = r'\\b(' + '|'.join(literals) + r')\\b'\n    return string.find(regex)\n\nif __name__ == '__main__':\n    assert search_literals('foo bar', ['foo', 'bar']) == 0\n    assert search_literals('foo bar', ['foo', 'baz']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'foo']) == 0\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar']) == 0\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar', 'foo']) == 0\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar', 'foo', 'bar']) == 0\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar', 'foo', 'bar', 'foo']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar', 'foo', 'bar', 'foo']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar']) == -1\n    assert search_literals('foo bar', ['foo', 'bar', 'baz', 'baz', 'foo"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        if not text or not literals:\n            return False\n        text_len = len(text)\n        for index, literal in enumerate(literals):\n            if text_len < len(literal):\n                return False\n            if text[index:index+len(literal)] == literal:\n                return True\n        return False"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "import re\n\n# Complete the searchLiterals function below.\ndef searchLiterals(searchString, string):\n    pattern = re.compile(searchString)\n    return pattern.search(string)\n\n\nif __name__ == \"__main__\":\n    searchString = \"abcd\"\n    string = \"the quick brown fox\"\n    print searchLiterals(searchString, string)"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom string import digits\nfrom itertools import product\nfrom operator import xor\n\n\ndef literals_in_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list[str]\n    :rtype: int\n    \"\"\"\n    return sum(xor(re.findall(literal, string), literals))\n\n\ndef literals_in_string_re(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list[str]\n    :rtype: int\n    \"\"\"\n    return sum(xor(re.findall(literal, string), literals))\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"aabbccddeeff\"\n    # string = \"aabbccddeeff\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuvwxyz\"\n    # string = \"abcdefghijklmnopqrstuv"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "# Definition for a string\nclass String:\n    def __init__(self, s):\n        self.s = s\n\n    def __eq__(self, other):\n        return self.s == other.s\n\nclass Solution:\n    def search(self, s, p):\n        \"\"\"\n        :type s: String\n        :type p: String\n        :rtype: bool\n        \"\"\"\n        if not s or not p:\n            return False\n\n        if s.s == p.s:\n            return True\n\n        if p.s[0] == '*':\n            return self.search(s, String(p.s[1:])) or self.search(s, String(p.s[1:]))\n\n        if p.s[-1] == '*':\n            return self.search(s, String(p.s[:-1])) or self.search(s, String(p.s[:-1]))\n\n        return s.s.find(p.s)!= -1\n\ns = Solution()\n\n# s.search(\"abcd\", \"*\")\n# s.search(\"abcd\", \"ab*\")\n# s.search(\"abcd\", \"*c*\")\n# s.search(\"abcd\", \"*d*\")\n# s.search(\"abcd\", \"*cd*\")\n# s.search(\"abcd\", \"ab*cd*\")\n\n# s.search(\"abcd\", \"ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n\n# s.search(\"abcd\", \"ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd*\")\n# s.search(\"abcd\", \"*ab*cd"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {string} s\n    # @param {string[]} words\n    # @return {string}\n    def search(self, s, words):\n        for w in words:\n            if w in s:\n                return w\n        return None\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.search(\"banana\", [\"banana\", \"banana\"]))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, text, query):\n        \"\"\"\n        :type text: str\n        :type query: str\n        :rtype: bool\n        \"\"\"\n        if not text or not query:\n            return False\n        if len(text) < len(query):\n            return False\n        if len(text) == len(query):\n            return text == query\n        return self.search_regex(text, query)\n\n    def search_regex(self, text, query):\n        p = re.compile(query)\n        m = p.search(text)\n        if m:\n            return True\n        return False\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.search('abcd', 'a') == True\n    assert s.search('abcd', 'b') == True\n    assert s.search('abcd', 'c') == False\n    assert s.search('abcd', 'd') == False\n    assert s.search('abcd', 'd') == False"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/\n# time:O(n)\n# space:O(n)\n\nclass Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: bool\n        \"\"\"\n        if not P:\n            return True\n\n        if not S or not P:\n            return False\n\n        if len(S) < len(P):\n            return self.search(S, P[len(S):])\n\n        if not P[0] in S:\n            return False\n\n        # find the first index of P in S\n        i = 0\n        while i < len(S) and P[0]!= S[i]:\n            i += 1\n\n        if i >= len(S):\n            return False\n\n        # now find the first char of P in S\n        j = i + 1\n        while j < len(S) and P[1]!= S[j]:\n            j += 1\n\n        # now find the first char of P in S\n        while j < len(S) and P[0] == S[j]:\n            j += 1\n\n        # if P is in S\n        if j == len(S):\n            return True\n\n        return self.search(S[j:], P[1:])\n\nif __name__ == \"__main__\":\n    print Solution().search(\"abc\", \"b\")\n    print Solution().search(\"abc\", \"a\")\n    print Solution().search(\"abc\", \"c\")\n    print Solution().search(\"abc\", \"d\")\n    print Solution().search(\"abc\", \"abc\")\n    print Solution().search(\"abc\", \"abb\")"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "import re\n\n\ndef search_literals_strings(s, literals):\n    for literal in literals:\n        if re.search(literal, s):\n            return literal\n\n\nif __name__ == '__main__':\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['fox', 'dog'])\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['dog', 'fox'])\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['fox', 'fox'])\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['dog', 'dog'])\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['dog', 'fox', 'fox'])\n    print search_literals_strings('The quick brown fox jumped over the lazy dog.', ['fox', 'fox', 'fox'])"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def is_literal(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        literal = literal.lower()\n        re = re.compile(r'\\b' + literal + r'\\b')\n        return re.search(s)\n\n    def is_literal_str(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.lower().find(''.join(sorted(literal)))!= -1"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def literal_search(literal_string, string):\n    pattern = literal_string.lower()\n    return string.lower().find(pattern)!= -1\n\nif __name__ == '__main__':\n    print literal_search('hello', 'World')"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, text, literals):\n        \"\"\"\n        :type text: str\n        :type literals: List[str]\n        :rtype: bool\n        \"\"\"\n        if not text:\n            return False\n        if not literals:\n            return True\n        for i in range(len(text)):\n            if text[i] in literals:\n                return True\n            if text[i] not in literals:\n                continue\n            if self.search(text[i+1:], literals[text[i]:text[i+1]]):\n                return True\n        return False"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literal_strings(literal_strings, target_string):\n    literal_strings = literal_strings.lower()\n    target_string = target_string.lower()\n    for literal_string in literal_strings.split():\n        for i in range(len(target_string)):\n            if literal_string in target_string[:i]:\n                return i\n    return -1\n\nif __name__ == '__main__':\n    literal_strings = input()\n    target_string = input()\n    result = search_literal_strings(literal_strings, target_string)\n    print(result)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nclass Solution(object):\n    def search(self, text, word):\n        \"\"\"\n        :type text: str\n        :type word: str\n        :rtype: int\n        \"\"\"\n        return text.find(word)\n\n\ndef main():\n    sol = Solution()\n    print(sol.search(\"Hello, world!\", \"hello\"))\n    print(sol.search(\"Hello, world!\", \"world\"))\n    print(sol.search(\"Hello, world!\", \"hello world\"))\n    print(sol.search(\"Hello, world!\", \"hello\"))\n    print(sol.search(\"Hello, world!\", \"hello world\"))\n    print(sol.search(\"Hello, world!\", \"Hello\"))\n    print(sol.search(\"Hello, world!\", \"Hello World\"))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import re\n\n\ndef search_string(string, literal):\n    \"\"\"\n    Write a function to search some literals strings in a string by using regex.\n\n    :param string: a string\n    :param literal: a string literal\n    :return: a list of indices of the string literals\n    \"\"\"\n    match_list = []\n    for i in range(len(string)):\n        if re.search(literal, string[i:i + len(literal)]):\n            match_list.append(i)\n    return match_list"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isLiteral(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return s.lower() == literal.lower()\n\n    def isLiteralStr(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return s.lower().startswith(literal.lower())\n\n    def isLiteralStr2(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return literal in s.lower()\n\n    def isLiteralStr3(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return s.startswith(literal)\n\n    def isLiteralStr4(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return literal in s\n\n    def isLiteralStr5(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return literal in s.lower()"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def search_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    regex = \"|\".join(literals)\n    return string.find(regex)!= -1\n\nif __name__ == '__main__':\n    string = 'The quick brown fox jumps over the lazy dog.'\n    literals = 'brown fox'\n\n    print(search_string(string, literals))\n    print(search_string(string, literals.upper()))\n    print(search_string(string, literals.lower()))\n    print(search_string(string, literals.swapcase()))\n    print(search_string(string, literals.upper()))\n    print(search_string(string, literals.lower()))\n    print(search_string(string, literals.swapcase()))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, text, word):\n        \"\"\"\n        :type text: str\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if not text or not word:\n            return False\n        regex = re.compile(word)\n        return regex.search(text)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.search(\"Hello World!\", \"World\")\n    assert not s.search(\"Hello World!\", \"World Hello\")\n    assert s.search(\"Hello World!\", \"Hello\")"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def search_literal_in_string(literal_string, string):\n    literal_string = literal_string.lower()\n    string = string.lower()\n    return string.find(literal_string)!= -1"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "import re\n\ndef search(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list[str]\n    :rtype: bool\n    \"\"\"\n    pattern = re.compile(r'|'.join(literals))\n    return pattern.search(string) is not None\n\n\nif __name__ == '__main__':\n    assert search('aab', 'aabb') == True\n    assert search('aaab', 'aabb') == False\n    assert search('ab', 'aabb') == False\n    assert search('aabb', 'aabb') == True"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Author: Gillett Hernandez\n# @Date:   2016-01-10 21:43:01\n# @Last Modified by:   Gillett Hernandez\n# @Last Modified time: 2017-08-10 12:18:56\n\nimport re\n\ndef search(literal, text):\n    p = re.compile(literal)\n    return p.search(text)\n\nif __name__ == '__main__':\n    assert search('abcd', 'abcd') == True\n    assert search('abcd', 'abc') == False\n    assert search('a', 'abc') == False\n    assert search('a', '') == False\n    assert search('abcd', '') == False"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param str, a string\n    # @param literals, a list of string\n    # @return a string\n    def replaceString(self, str, literals):\n        if not str or not literals:\n            return str\n        regex = re.compile(\"|\".join(literals))\n        return regex.sub(lambda x: x.group().lower(), str)\n\nif __name__ == '__main__':\n    s = Solution()\n    # s = Solution()\n    # str = 'this is a test'\n    # literals = ['test', 'is', 'a']\n    # str = 'this is a test'\n    # literals = ['test', 'is', 'a']\n    print s.replaceString(str, literals)"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "import re\n\n\ndef find_all(s, pattern):\n    \"\"\"\n    :type s: str\n    :type pattern: str\n    :rtype: list[str]\n    \"\"\"\n    return re.findall(pattern, s)\n\n\ndef main():\n    s = \"Hello, world!\"\n    p = \"hello\"\n    assert find_all(s, p) == ['hello']\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport re\n\ndef search_literals(string, literals):\n    \"\"\"\n    Returns the position of literals in a string, or -1 if no literals in string.\n    \"\"\"\n    pos = -1\n    for literal in literals:\n        pos = string.find(literal)\n        if pos!= -1:\n            break\n    return pos\n\n\ndef test():\n    assert search_literals('A', 'A') == 0\n    assert search_literals('abc', 'abc') == 0\n    assert search_literals('abc', 'bc') == -1\n    assert search_literals('abc', 'abcdefghijklmnopqrstuvwxyz') == -1\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literals_strings(string, literals):\n    pattern = '|'.join(literals)\n    regex = re.compile(pattern)\n    return regex.search(string)\n\nif __name__ == '__main__':\n    string = 'We have a dog, a cat and a dog'\n    literals = ['dog', 'cat']\n    print(search_literals_strings(string, literals))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literal_in_string(literal, str):\n    return re.search(literal, str) is not None\n\nif __name__ == '__main__':\n    print(search_literal_in_string('foo', 'bar foo bar foo'))\n    print(search_literal_in_string('foo', 'bar foo bar foo'))\n    print(search_literal_in_string('bar', 'bar foo bar foo'))\n    print(search_literal_in_string('bar', 'bar foo bar'))\n    print(search_literal_in_string('foo', 'bar bar foo bar'))\n    print(search_literal_in_string('foo', 'bar bar foo'))\n    print(search_literal_in_string('foo', 'bar foo bar foo'))\n    print(search_literal_in_string('foo', 'bar foo bar foo'))\n    print(search_literal_in_string('bar', 'bar foo bar foo'))\n    print(search_literal_in_string('bar', 'bar foo bar'))\n    print(search_literal_in_string('foo', 'bar foo bar foo'))\n    print(search_literal_in_string('foo', 'bar foo bar'))\n    print(search_literal_in_string('foo', 'bar foo'))\n    print(search_literal_in_string('foo', 'bar'))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "import re\n\n# Complete the function below.\ndef search_literals(literal, text):\n    \"\"\"\n    literal: string\n    text: string\n    return: boolean\n    \"\"\"\n    # Complete this function\n    if re.search(literal, text):\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    literal = \"hello\"\n    text = \"hello world\"\n    print search_literals(literal, text)"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from string import ascii_uppercase\nimport re\n\ndef literal_search(string, literal):\n    pattern = re.compile(r'\\b' + literal + r'\\b')\n    return pattern.search(string) is not None\n\ndef main():\n    string = 'The quick brown fox jumps over the lazy dog'\n    literal = 'dog'\n    print(literal_search(string, literal))\n    print(literal_search(string, 'lazy'))\n    print(literal_search(string, 'fox'))\n    print(literal_search(string, 'jumps'))\n    print(literal_search(string, 'quick'))\n    print(literal_search(string, 'fox jumps'))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "import re\nimport string\n\ndef search_regex(target_str, pattern):\n    pattern = re.compile(pattern)\n    return pattern.search(target_str)\n\n# Complete the'search_regex' function below.\n\ndef search_regex_2(target_str, pattern):\n    pattern = re.compile(pattern)\n    return pattern.findall(target_str)"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def find(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: list[str]\n    :rtype: str\n    \"\"\"\n    pattern = '|'.join(literals)\n    return re.search(pattern, string)\n\nif __name__ == '__main__':\n    assert find('abc', ['a', 'b', 'c']) == 'abc'\n    assert find('abc', ['d', 'e', 'f']) == None\n    assert find('abc', ['a', 'b', 'c']) == 'abc'"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, S, P):\n        \"\"\"\n        :type S: str\n        :type P: str\n        :rtype: int\n        \"\"\"\n        return self.search_with_regex(S, P)\n\n    def search_with_regex(self, S, P):\n        # write your code here\n        if len(S) == 0 or len(P) == 0:\n            return -1\n        re = re.compile(P)\n        match = re.search(S)\n        return match.start() if match else -1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search(\"hello world\", \"world\")\n    print s.search(\"hello world\", \"world\")\n    print s.search(\"hello world\", \"wor\")"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literal(s, literal):\n    pattern = re.compile(literal)\n    return pattern.search(s)\n\nif __name__ == \"__main__\":\n    test_cases = open(\"1.txt\", \"r\")\n    for test in test_cases:\n        print(\"Test case #{}:\".format(test_cases.readline()))\n        literal = test_cases.readline()\n        literal = literal.strip()\n        s = test_cases.readline()\n        s = s.strip()\n        print(\"\\\"{}\\\"\".format(search_literal(s, literal)))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @param words, a list of string\n    # @return a boolean\n    def search(self, s, words):\n        words = set(words)\n        for i in range(len(s)):\n            if i == len(s) - 1 or s[i]!= s[i + 1]:\n                m = s[i:i + 2]\n                if m in words:\n                    return True\n                else:\n                    words.add(m)\n        return False"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        if not text or not target:\n            return -1\n        text = text.lower()\n        target = target.lower()\n        pos = 0\n        while pos < len(text):\n            if text[pos:pos+len(target)] == target:\n                return pos\n            pos += 1\n        return -1"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "import re\n\ndef search_literals(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    pattern = r'[A-Za-z]{2,}'\n    return list(set(re.findall(pattern, string)))\n\nif __name__ == '__main__':\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world! '))\n    print(search_literals('Hello, world!\\t'))\n    print(search_literals('Hello, world!\\n'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))\n    print(search_literals('Hello, world!'))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "import re\n\n\ndef search_literals(input_string, literals):\n    \"\"\"\n    :type input_string: str\n    :type literals: list[str]\n    :rtype: int\n    \"\"\"\n    match_count = 0\n    for literal in literals:\n        pattern = re.compile(literal)\n        match = pattern.search(input_string)\n        while match:\n            match_count += 1\n            input_string = input_string[:match.start()] + input_string[match.end():]\n            match = pattern.search(input_string)\n    return match_count\n\n\nif __name__ == '__main__':\n    assert search_literals('aaa', ['a', 'a', 'a', 'a']) == 1\n    assert search_literals('aaa', ['a', 'b', 'a', 'a']) == 0\n    assert search_literals('a', ['a', 'b', 'a', 'a']) == 0\n    assert search_literals('a', ['a', 'b', 'a', 'b']) == 1"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @param literals, a set of string\n    # @return an integer\n    def numLiterals(self, s, literals):\n        if not literals:\n            return 0\n\n        m = re.match(r'(.*?)('+'|'.join(literals)+')', s)\n        if not m:\n            return 0\n\n        return len(m.groups()[0])"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "# Definition for a literal string.\nclass Literal:\n    def __init__(self, literal):\n        self.literal = literal\n\n    def __repr__(self):\n        return self.literal\n\n    def __eq__(self, other):\n        return self.literal == other.literal\n\n    def __hash__(self):\n        return hash(self.literal)\n\nclass Solution:\n    def search(self, text, target):\n        \"\"\"\n        :type text: str\n        :type target: str\n        :rtype: bool\n        \"\"\"\n        if not target:\n            return False\n        if len(target) == 1:\n            return text.find(target)!= -1\n        if len(target) > len(text):\n            return False\n        return self.search_regex(text, target)\n\n    def search_regex(self, text, target):\n        if not target:\n            return False\n        if len(target) == 1:\n            return text.find(target)!= -1\n        if len(target) > len(text):\n            return False\n        regex = ''.join(['(?=.*{0})'.format(x) for x in target])\n        return re.match(regex, text) is not None"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n# #############################################################################\n# Copyright (C) 2013-2015 The tp Authors. See the LICENSE file at the top-level\n# directory of this distribution and at https://github.com/ThePythonPegasus/pegasus/blob/master/LICENSE\n# #############################################################################\n\nfrom __future__ import print_function\n\nimport re\n\n\ndef search(string, literals):\n    \"\"\"\n    Search for literals in a string by using regex.\n\n    :param string: A string to search.\n    :param literals: A list of literals to search for.\n    :return: A list of positions where literals are found.\n    \"\"\"\n    # Compile the regex\n    pattern = re.compile(\"|\".join(literals))\n    # Search\n    result = []\n    for i in range(len(string)):\n        m = pattern.search(string, i)\n        if m:\n            result.append(m.start())\n    # Return\n    return result\n\n\nif __name__ == \"__main__\":\n    string = \"Hello, world!\"\n    literals = [\"Hello\", \"world\"]\n    print(\"string:\", string)\n    print(\"literals:\", literals)\n    print(\"result:\", search(string, literals))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nimport re\n\ndef search_string(string, literals):\n    \"\"\"\n    Write a function to search some literals strings in a string by using regex.\n\n    :type string: str\n    :type literals: List[str]\n    :rtype: int\n    \"\"\"\n    return len(re.findall(r'|'.join(literals), string))\n\nif __name__ == '__main__':\n    s = '''\n    The quick brown fox jumps over the lazy dog\n    '''\n    print(search_string(s, ['the','quick','brown']))\n    print(search_string(s, ['fox','lazy']))\n    print(search_string(s, ['fox','dog']))\n    print(search_string(s, ['fox','dog','lazy']))\n    print(search_string(s, ['fox','dog','lazy','quick']))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def search(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    if not string:\n        return False\n    for literal in literals:\n        if literal in string:\n            return True\n    return False"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isLiteral(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        pattern = r'\\w+'\n        p = re.compile(pattern)\n        return p.match(s) is not None\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.isLiteral(\"abcd\"))\n    print(sol.isLiteral(\"ab\"))\n    print(sol.isLiteral(\"abcdab\"))\n    print(sol.isLiteral(\"a\"))"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "import re\n\n\ndef search_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    return any(re.search(literal, string) for literal in literals)\n\n\nif __name__ == '__main__':\n    assert search_string('abcdef', 'a')\n    assert not search_string('abcdef', 'd')\n    assert search_string('abcdef', '.*a')\n    assert search_string('abcdef', '.*d')"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @param literals, a string\n    # @return a boolean\n    def isLiteral(self, s, literals):\n        if s is None or literals is None:\n            return False\n        s = s.lower()\n        literals = literals.lower()\n        re = re.compile(r\"([^\\W\\d])(\" + literals + r\")([^\\W\\d])\")\n        return re.search(s) is not None"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def search_literal(target, literals):\n    \"\"\"\n    :type target: str\n    :type literals: List[str]\n    :rtype: int\n    \"\"\"\n    pattern = '|'.join(literals)\n    return len(re.findall(pattern, target, re.IGNORECASE))\n\nif __name__ == '__main__':\n    target = 'The quick brown fox jumps over the lazy dog'\n    print(search_literal(target, ['dog','fox','lazy']))"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import re\n\n# Returns a list of literals in a string\ndef literals(string):\n    return re.findall('[A-Za-z]+', string)\n\n# Returns a list of literals in a string by using regex\ndef literals_regex(string):\n    return re.findall('[A-Za-z]+', string, re.IGNORECASE)\n\n# Test Cases\nprint literals('hello')\n# ['h', 'e', 'l', 'l', 'o']\n\nprint literals('Hello')\n# ['h', 'e', 'l', 'l', 'o']\n\nprint literals('hellooo')\n# ['h', 'e', 'l', 'l', 'o', 'o']\n\nprint literals('Hello World')\n# ['h', 'e', 'l', 'l', 'o','', 'w', 'o', 'r', 'l', 'd']\n\nprint literals_regex('Hello World')\n# ['h', 'e', 'l', 'l', 'o','', 'w', 'o', 'r', 'l', 'd']\n\nprint literals_regex('Hello World!')\n# ['h', 'e', 'l', 'l', 'o','', 'w', 'o', 'r', 'l', 'd', '!']"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "import re\n\n# Complete the searchLiterals function below.\ndef searchLiterals(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: List[str]\n    :rtype: List[str]\n    \"\"\"\n    return [x for x in literals if re.search(x, s)]"
    },
    {
      "rank": 71,
      "score": 7.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @param literals, a string\n    # @return a boolean\n    def search(self, s, literals):\n        return s.lower() in literals.lower()\n\n\nif __name__ == \"__main__\":\n    assert Solution().search(\"abcabcabcabcabc\", \"abc\") == True, \"abc\"\n    assert Solution().search(\"abcabcabcabcabc\", \"abcabc\") == False, \"abc\""
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/305973/Python-O(n)-time-and-O(1)-space-solution\n# https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/305973/Python-O(n)-time-and-O(1)-space-solution\n# https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/305973/Python-O(n)-time-and-O(1)-space-solution\n\nfrom typing import List\n\nclass Solution:\n    def search(self, S: str, p: str) -> bool:\n        def check(S, p):\n            return S.startswith(p) or S.endswith(p) or S.count(p)\n\n        def check_substring(S, p):\n            return S.startswith(p) or S.endswith(p) or S.count(p)\n\n        if not p:\n            return True\n\n        p = p.lower()\n\n        return any(check(S, p) for S in S.split(' ')) or any(check_substring(S, p) for S in S.split(' '))\n\n    def search(self, S: str, p: str) -> bool:\n        return any(S.startswith(p), S.endswith(p), S.count(p))\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.search('', 'a') == False\n    assert s.search('abcabc', 'abc') == True\n    assert s.search('abcabc', 'a') == False\n    assert s.search('abcabc', 'bc') == True\n    assert s.search('abcabc', 'c') == False\n    assert s.search('abcabc', 'abcabc') == True\n    assert s.search('abcabc', 'abcabcabc') == True\n    assert s.search('abcabc', 'abcabcabcabc') == False\n    assert s.search"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n\nclass Solution:\n    def search(self, text, k):\n        \"\"\"\n        :type text: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        pattern = ''.join(['(?<=%s)' % x for x in k])\n        regex = re.compile(pattern)\n        return regex.search(text) is not None\n\nif __name__ == '__main__':\n    assert Solution().search('abcabc', 2)"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# TODO:\n# 1. Use regex to search the literals string\n# 2. Use regex to search the literals string\n# 3. Use regex to search the literals string\n# 4. Use regex to search the literals string\n# 5. Use regex to search the literals string\n# 6. Use regex to search the literals string\n# 7. Use regex to search the literals string\n\nimport re\n\ndef search_literals_string(s, literals):\n    regex_literals = []\n    for literal in literals:\n        regex_literals.append(re.compile(literal))\n\n    return [literal for literal in regex_literals if any(literal.search(s) for literal in regex_literals)]\n\nif __name__ == '__main__':\n    literals = ['abc', 'def', 'ghi']\n    s = 'abcdefghi'\n    print(search_literals_string(s, literals))"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/string-search-regex/problem\n\ndef search_string_by_regex(string, pattern):\n    # Complete this function\n    return -1"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param s: A string\n    @param literals: A list of string\n    @return: A boolean\n    \"\"\"\n    def isLiteral(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral2(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral3(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral4(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral5(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral6(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral7(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral8(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral9(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral10(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral11(self, s, literals):\n        for literal in literals:\n            if literal in s:\n                return True\n        return False\n    \n    def isLiteral12(self, s, literals):\n        for literal in literals:"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def search_string(search_string, string):\n    re_string = search_string + \"$\"\n    re_string = re.compile(re_string)\n    return re_string.search(string)\n\nif __name__ == \"__main__\":\n    search_string = \"apple\"\n    string = \"The quick brown fox jumped over the lazy dog\"\n    print search_string, string\n    search_string = \"apple\"\n    print search_string, string\n    search_string = \"apple\"\n    print search_string, string\n    search_string = \"apple\"\n    print search_string, string"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# Your function should return a bool value, indicating whether the string is a\n# match or not.\n\n# Example 1:\n# Given s = \"apple\", pattern = \"a.*\", return true.\n# Example 2:\n# Given s = \"orange\", pattern = \"or.*\", return true.\n# Example 3:\n# Given s = \"apple\", pattern = \"p.*\", return false.\n# Note:\n# The pattern string only contains lowercase letters.\n# The pattern string must be a valid regular expression.\n# The string consists of lowercase letters and numbers.\n# The length of pattern and string are not greater than 10000.\n\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        return False\n\nif __name__ == \"__main__\":\n    print Solution().isMatch(\"apple\", \"a.*\")\n    print Solution().isMatch(\"apple\", \"or.*\")\n    print Solution().isMatch(\"apple\", \"p.*\")\n    print Solution().isMatch(\"applepie\", \"a.*\")\n    print Solution().isMatch(\"applepie\", \"or.*\")\n    print Solution().isMatch(\"applepie\", \"p.*\")"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "import re\n\n\ndef search_regex(string, pattern):\n    \"\"\"\n    Write a function to search some literals strings in a string by using regex.\n\n    :type string: str\n    :type pattern: str\n    :rtype: bool\n    \"\"\"\n    return re.search(pattern, string) is not None\n\n# TEST CASES\n\nstring = \"Hello, world!\"\npattern = \"Hello\"\n\nprint(search_regex(string, pattern))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "import re\n\ndef search(literal, text):\n    return re.search(literal, text) is not None\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert search('a', 'Hello World') == True, \"Hello\"\n    assert search('a', 'Hello') == False, \"Hello\"\n    assert search('a', 'Helloa') == False, \"Hello\"\n    assert search('a', 'Helloaa') == False, \"Hello\"\n    assert search('a', 'Helloaa') == False, \"Hello\"\n    assert search('a', 'aa') == False, \"Hello\"\n    assert search('a', 'aa') == False, \"Hello\"\n    assert search('a', 'a') == True, \"Hello\"\n    assert search('a', 'a') == True, \"Hello\"\n    assert search('a', 'aaa') == False, \"Hello\"\n    assert search('a', 'aab') == False, \"Hello\"\n    assert search('a', 'aabb') == False, \"Hello\"\n    assert search('a', 'aabbb') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'a') == True, \"Hello\"\n    assert search('a', 'a') == True, \"Hello\"\n    assert search('a', 'aaa') == True, \"Hello\"\n    assert search('a', 'aab') == True, \"Hello\"\n    assert search('a', 'aabb') == True, \"Hello\"\n    assert search('a', 'aabbb') == True, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a', 'ab') == False, \"Hello\"\n    assert search('a',"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def search_literals_in_string(text, literals):\n    \"\"\"\n    :type text: str\n    :type literals: List[str]\n    :rtype: bool\n    \"\"\"\n    for literal in literals:\n        if re.search(literal, text):\n            return True\n    return False"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import re\n\n\ndef search(s, literals):\n    \"\"\"\n    :type s: str\n    :type literals: list[str]\n    :rtype: int\n    \"\"\"\n    if not s:\n        return 0\n    match_len = 0\n    for i, l in enumerate(literals):\n        if re.search(l, s):\n            match_len += len(l)\n    return match_len\n\n\nif __name__ == '__main__':\n    assert search('This is a string', ['This', 'is', 'a','string']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', 'is', 'a','string', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']) == 4\n    assert search('This is a string', ['This', '"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        def is_sub(s, l):\n            return l in s and s[l] == '*'\n        words = [word for word in words if word]\n        words = [word for word in words if word not in set('*')]\n        words = [word for word in words if len(word) > 1]\n        words = sorted(words)\n        words = [word for word in words if is_sub(s, word)]\n        if not words:\n            return []\n        result = []\n        i = 0\n        while i < len(s):\n            while i < len(s) and not is_sub(s, words[0]):\n                i += 1\n            j = i\n            while j < len(s) and is_sub(s, words[0]):\n                j += 1\n            result.append(i)\n            i = j\n            if j == len(s):\n                break\n            words = [word for word in words if is_sub(s, word)]\n            if not words:\n                break\n            words = [word for word in words if len(word) > 1]\n            words = sorted(words)\n            words = [word for word in words if is_sub(s, word)]\n        return result"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# TODO:\n# 1. write a function to search some literals strings in a string by using regex.\n# 2. implement a function to search some literals strings in a string by using regex.\n\n# Example\n# input:\n# s = \"hello\"\n# literals = \"hello\", \"hell\", \"h\"\n# output:\n# s.find(\"hello\") == 0\n# s.find(\"hell\") == 2\n# s.find(\"h\") == -1\n\nimport re\n\n# TODO: write a function to search some literals strings in a string by using regex.\ndef find_literals_in_string(s, literals):\n    for literal in literals:\n        regex = re.compile(literal)\n        if regex.search(s):\n            return True\n    return False\n\n# TODO: implement a function to search some literals strings in a string by using regex.\ndef search_literals_in_string(s, literals):\n    for literal in literals:\n        regex = re.compile(literal)\n        if regex.search(s):\n            return True\n    return False\n\n# Test case\n# s = \"hello\"\n# literals = \"hello\", \"hell\", \"h\"\n# print(find_literals_in_string(s, literals))\n# print(search_literals_in_string(s, literals))\n\n# Test case\n# s = \"hello\"\n# literals = \"hello\", \"hell\", \"h\"\n# print(find_literals_in_string(s, literals))\n# print(search_literals_in_string(s, literals))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, text, keyword):\n        \"\"\"\n        :type text: str\n        :type keyword: str\n        :rtype: int\n        \"\"\"\n        # TODO: write a regex to search literals.\n        return -1"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "import re\n\n# Time:  O(n)\n# Space: O(n)\n# DP solution.\n\nclass Solution:\n    # @param s, a string\n    # @param literals, a list of string\n    # @return an integer\n    def numLiteralsMatch(self, s, literals):\n        n = len(literals)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(len(s)):\n                if s[j] == literals[i - 1]:\n                    dp[i] = max(dp[i], dp[i - 1] + 1)\n        return dp[n]\n\n    # @param s, a string\n    # @param literals, a list of string\n    # @return an integer\n    def numLiteralsMatch2(self, s, literals):\n        n = len(literals)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(len(s)):\n                if s[j] == literals[i - 1]:\n                    dp[i] = max(dp[i], dp[i - 1] + 1)\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    s = \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "import re\n\nclass Solution:\n    def search(self, text: str, pattern: str) -> bool:\n        \"\"\"\n        :type text: str\n        :type pattern: str\n        :rtype: bool\n        \"\"\"\n        return bool(re.search(pattern, text))\n\n# TESTS\ntests = [\n    (\"a\", \"a\", True),\n    (\"ab\", \"ab\", True),\n    (\"abcd\", \"ab\", False),\n    (\"\", \"\", True),\n    (\"a\", \"a\", True),\n    (\"a\", \"b\", False),\n    (\"ab\", \"ac\", False),\n    (\"ab\", \"abc\", True),\n    (\"ab\", \"b\", False),\n    (\"abc\", \"acb\", True),\n    (\"abc\", \"bac\", False),\n    (\"abcd\", \"acbcd\", True),\n    (\"abcd\", \"bcad\", False),\n    (\"abcd\", \"abbcd\", True),\n    (\"abcd\", \"abcde\", False),\n]\nfor t, s, expected in tests:\n    sol = Solution()\n    actual = sol.search(s, t)\n    print(\"Search\", s, \"for\", t, \"->\", actual)\n    assert actual == expected"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "import re\n\ndef search_literals(text, literals):\n    \"\"\"\n    :type text: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    # print literals, text\n    for literal in literals.split():\n        if re.search(literal, text, re.IGNORECASE):\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    assert search_literals(\"abcd\", \"abcd\")\n    assert search_literals(\"abc\", \"abcd\")\n    assert search_literals(\"abcd\", \"abcdabc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")\n    assert search_literals(\"abcd\", \"abc\")"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import re\nimport unittest\n\n\nclass Solution(object):\n    def is_in_string(self, s, literal):\n        \"\"\"\n        :type s: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        return re.search(literal, s) is not None\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-a-2d-matrix-ii/solution/\n#\nApproach #1: Matching\nComplexity Analysis\nTime Complexity: O(m * n)\nSpace Complexity: O(m * n)\n\n# 48ms 98.99%\nclass Solution {\n    public boolean isInString(String S, String[] L) {\n        int m = L.length;\n        int n = L[0].length();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (isInString(S, L[i], j)) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isInString(String S, String[] L, int j) {\n        int i = 0;\n        while (i < L.length && j < S.length()) {\n            if (L[i].charAt(j)!= S.charAt(j)) return false;\n            i++;\n            j++;\n        }\n        return true;\n    }\n}\n\nApproach #2: Boyer Moore\nComplexity Analysis\nTime Complexity: O(m * n)\nSpace Complexity: O(m * n)\n\n# 48ms 98.99%\nclass Solution {\n    public boolean isInString(String S, String[] L) {\n        int m = L.length;\n        int n = L[0].length();\n        if (m * n!= S.length()) return false;\n        boolean[][] dp ="
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n\n# https://leetcode.com/problems/search-a-2d-matrix-ii/\n# Given a 2D matrix of characters 'M' and 'I' (matrix[i][j] = 'M' if the i-th row and j-th column is 'M', 'I' otherwise). \n# Write a function to check if a literal is in the matrix. \n# The literal can be either 'M' or 'I'. \n# Return true if the literal is in the matrix, otherwise return false.\n\nclass Solution(object):\n    def searchMatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :type k: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return False\n        dp = [[False for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == k:\n                    dp[i][j] = True\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] and i > 0 and dp[i - 1][j] and j > 0 and dp[i - 1][j - 1] and matrix[i][j] == 'M':\n                    return True\n                elif dp[i][j] and i > 0 and dp[i - 1][j] and j < n - 1 and dp[i - 1][j + 1] and matrix[i][j] == 'I':\n                    return True\n        return False\n\n\nif __name__ == \"__main__\":\n    assert Solution().searchMatrix([\"M\", \"M\", \"I\"], \"M\") == True\n    assert Solution().searchMatrix([\"M\", \"I\", \"I\"], \"M\") == True\n    assert Solution().searchMatrix([\"M\", \"I\", \"I\"], \"I\") == False\n    assert Solution().searchMatrix([\"M\", \"M\", \"I\"], \"I\") == False"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "__author__ = 'Libao Jin'\n__date__ = 'December 6, 2015'\n\ndef search_literals_strings(literal_strings, string):\n    \"\"\"\n    :type literal_strings: str\n    :type string: str\n    :rtype: str\n    \"\"\"\n    for literal in literal_strings.split():\n        if re.search(literal, string):\n            return literal\n    return None\n\n\nif __name__ == '__main__':\n    print(search_literals_strings('abcd', 'abcdd'))\n    print(search_literals_strings('abcd', 'abcdddd'))\n    print(search_literals_strings('abcd', 'abcd'))\n    print(search_literals_strings('abcd', 'abd'))\n    print(search_literals_strings('abcd', 'abd'))\n    print(search_literals_strings('abcd', 'ab'))"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, text, literal):\n        \"\"\"\n        :type text: str\n        :type literal: str\n        :rtype: bool\n        \"\"\"\n        regex = r'\\b' + literal + r'\\b'\n        return bool(re.match(regex, text))\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.search('hello world', 'he')\n    print s.search('hello world', 'll')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')\n    print s.search('hello world', 'world')"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# -*- coding: utf-8 -*-\n# @Author: omi\n# @Date:   2014-08-10 14:11:57\n# @Last Modified by:   omi\n# @Last Modified time: 2015-09-11 14:17:28\n\nclass Solution(object):\n    def isLiteral(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s == s[::-1]\n\n# debug\ns = Solution()\nprint s.isLiteral(\"a\")\nprint s.isLiteral(\"aaa\")\nprint s.isLiteral(\"abb\")\nprint s.isLiteral(\"abcd\")\nprint s.isLiteral(\"abbbb\")\nprint s.isLiteral(\"abbc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abbcc\")\nprint s.isLiteral(\"abb"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def search_string(string, literals):\n    \"\"\"\n    :type string: str\n    :type literals: str\n    :rtype: bool\n    \"\"\"\n    for literal in literals:\n        if string.find(literal)!= -1:\n            return True\n    return False\n\nif __name__ == '__main__':\n    print(search_string('a', 'a'))\n    print(search_string('aa', 'a'))\n    print(search_string('aa', 'aa'))\n    print(search_string('b', 'a'))\n    print(search_string('bbb', 'a'))\n    print(search_string('b', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('b', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('b', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('b', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'b'))\n    print(search_string('bbb', 'bbb'))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import re\n\ndef search_literals(string, literals):\n    \"\"\"\n    Write a function to search some literals strings in a string by using regex.\n    :param string: str\n    :param literals: list\n    :return: boolean\n    \"\"\"\n    # if there is no literals, just return true\n    if not literals:\n        return True\n\n    # if there is no string, just return false\n    if not string:\n        return False\n\n    # if there is only one literal, just return true\n    if len(literals) == 1:\n        return literals[0] in string\n\n    # if there is more than one literal, use the regex to match\n    for literal in literals:\n        if literal in string:\n            return True\n\n    # if there is no match, return false\n    return False\n\nif __name__ == '__main__':\n    # test cases\n    assert search_literals('Hello, world!', []) is True\n    assert search_literals('Hello, world!', ['Hello', 'world']) is True\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello']) is False\n    assert search_literals('Hello, world!', ['Hello', 'world', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello',"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param s: A string\n    @param literals: A list of string\n    @return: A list of string\n    \"\"\"\n    def search(self, s, literals):\n        res = []\n        for i in range(len(s)):\n            for j in range(len(literals)):\n                if j == len(literals):\n                    res.append(s[i:])\n                    break\n                if literals[j] == s[i]:\n                    res.append(s[i:i + len(literals[j])])\n                    break\n        return res"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def isLiteral(self, str, literals):\n        for literal in literals:\n            if str.find(literal)!= -1:\n                return True\n        return False\n\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def isLiteral2(self, str, literals):\n        if len(str) == 0 or len(literals) == 0:\n            return False\n        if str.find(literals[0]) == -1:\n            return False\n        for i in range(1, len(literals)):\n            if str.find(literals[i]) == -1:\n                return False\n        return True\n\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def isLiteral3(self, str, literals):\n        if len(str) == 0 or len(literals) == 0:\n            return False\n        if str.find(literals[0]) == -1:\n            return False\n        for i in range(1, len(literals)):\n            if str.find(literals[i]) == -1:\n                return False\n        return True\n\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def isLiteral4(self, str, literals):\n        if len(str) == 0 or len(literals) == 0:\n            return False\n        if str.find(literals[0]) == -1:\n            return False\n        for i in range(1, len(literals)):\n            if str.find(literals[i]) == -1:\n                return False\n        return True\n\n    # @param {string} str\n    # @param {string[]} literals\n    # @return {boolean}\n    def isLiteral5(self, str, literals):\n        if len(str) == 0 or len"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isLiteral(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n\n        # return s.lower() in self.literalStrings\n        return any(s.lower().startswith(literal) for literal in self.literalStrings)\n\n    def isLiteral2(self, s):\n        return s in self.literalStrings\n\n    def __init__(self):\n        self.literalStrings = [\"\\\\w+\", \"\\\\s+\", \"\\\\d+\", \"\\\\D+\"]\n\n    def addLiteralString(self, s):\n        if s not in self.literalStrings:\n            self.literalStrings.append(s)\n\n    def removeLiteralString(self, s):\n        if s in self.literalStrings:\n            self.literalStrings.remove(s)\n\n    def literalStrings(self):\n        return self.literalStrings\n\n    def removeLiteralStrings(self):\n        self.literalStrings = []\n\n    def isLiteral(self, s):\n        return s in self.literalStrings\n\n    def isLiteral2(self, s):\n        return s in self.literalStrings\n\nclass Solution2(object):\n    def isLiteral(self, s):\n        return s.lower() in self.literalStrings\n\n    def literalStrings(self):\n        return self.literalStrings\n\n    def isLiteral2(self, s):\n        return s.lower() in self.literalStrings\n\nclass Solution3(object):\n    def isLiteral(self, s):\n        return s.lower() in self.literalStrings\n\n    def isLiteral2(self, s):\n        return s.lower() in self.literalStrings\n\n    def literalStrings(self):\n        return self.literalStrings\n\n    def isLiteral3(self, s):\n        return s.lower() in self.literalStrings\n\n    def isLiteral4(self, s"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/155700/Python-solution-using-regex-with-comments-and-extra-code-and-my-own-notes\n# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/155700/Python-solution-using-regex-with-comments-and-extra-code-and-my-own-notes\n# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/155700/Python-solution-using-regex-with-comments-and-extra-code-and-my-own-notes\n# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/155700/Python-solution-using-regex-with-comments-and-extra-code-and-my-own-notes\n\nclass Solution:\n    # @param haystack, a string\n    # @param needle, a string\n    # @return an integer\n    def search(self, haystack, needle):\n        haystack = haystack.lower()\n        needle = needle.lower()\n        if not needle:\n            return 0\n        if not haystack:\n            return -1\n        if needle == haystack:\n            return 0\n        if needle == haystack[0]:\n            return 0\n        haystack_len = len(haystack)\n        needle_len = len(needle)\n        i = 0\n        j = haystack_len - needle_len\n        while i <= j:\n            mid = i + (j - i) / 2\n            if haystack[mid:mid+needle_len] == needle:\n                return mid\n            elif haystack[mid:mid+needle_len] > needle:\n                j = mid - 1\n            else:\n                i = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.search(\"aab\", \"a\"))\n    print(s."
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# The function should be in the format of:\n# def search(string, literal):\n\n# Your search function should return the index of the first found literal\n# in the string.\n# If no literal is found, return -1.\n\n# Example 1:\n# Input:\n# string = \"barfoothefoobarman\"\n# literals = [\"foo\", \"bar\"]\n# Output: 1\n# Explanation:\n# The first literal is \"bar\" with index 1.\n# Example 2:\n# Input:\n# string = \"foobarfoo\"\n# literals = [\"foo\", \"bar\"]\n# Output: -1\n# Explanation:\n# No literal is found.\n# Note:\n# The length of string and literals will be in the range [1, 10000].\n# The length of literals will be in the range [1, 10].\n# The length of string and literal will be in the range [1, 1000].\n\nclass Solution(object):\n    def search(self, string, literals):\n        \"\"\"\n        :type string: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        for index, literal in enumerate(literals):\n            if string.find(literal) == index:\n                return index\n        return -1\n\n    def search(self, string, literals):\n        \"\"\"\n        :type string: str\n        :type literals: List[str]\n        :rtype: int\n        \"\"\"\n        return -1"
    }
  ]
}