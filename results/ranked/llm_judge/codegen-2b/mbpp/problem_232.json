{
  "timestamp": "2025-09-14T19:05:20.437609",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 232,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def sort_list(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(arr, key=lambda x: x[0])"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __repr__(self):\n        return \"Tuple(\" + repr(self.x) + \",\" + repr(self.y) + \")\"\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __hash__(self):\n        return hash(self.x) + hash(self.y)\n\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        if not tuples:\n            return\n\n        for i in range(len(tuples) - 1):\n            if tuples[i].x < tuples[i + 1].x:\n                tuples[i], tuples[i + 1] = tuples[i + 1], tuples[i]\n\n        return\n\n\ns = Solution()\nt1 = (1, 2)\nt2 = (2, 1)\nt3 = (2, 2)\nt4 = (1, 1)\nt5 = (1, 2, 3, 4)\nt6 = (2, 1, 3, 4)\nt7 = (2, 2, 1, 3)\nt8 = (2, 2, 1, 1)\nt9 = (2, 1, 1, 1)\nt10 = (1, 2, 1, 1)\nt11 = (1, 2, 3, 4, 5, 6)\nt12 = (1, 2, 3, 4, 5, 6, 7, 8)\nt13 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nt14 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\nt15 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\nt16 = (1, 2"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\n# TODO:\n# - Use list comprehensions to reduce the number of comparisons.\n\n# Note:\n# - If the list is empty, return it.\n# - If the list is a single element, return that element.\n# - If the list has length 1, return it.\n\ndef sort_array(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) == 0:\n        return arr\n    if len(arr) == 1:\n        return arr\n    \n    # Sort using the first element of the list.\n    return sort_array_using_first_element(arr)\n\ndef sort_array_using_first_element(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(arr) == 1:\n        return arr\n    \n    # Sort using the first element of the list.\n    return arr[:1] + arr[1:]\n\nif __name__ == '__main__':\n    arr = [2, 1, 3, 4, 5]\n    arr_sorted = sort_array(arr)\n    \n    print(arr_sorted)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-a-list/problem\n# Write a function to sort the given list based on the occurrence of first element of tuples.\n# The list can be of any size.\n\ndef sort_list(l):\n    i = 0\n    while i < len(l):\n        j = i\n        while j < len(l) and l[j][0] == l[i][0]:\n            j += 1\n        l[i], l[j] = l[j], l[i]\n        i = j\n    return l\n\n# Test cases\nprint(sort_list([(1,2),(1,1),(2,3)]))\nprint(sort_list([(1,3),(1,1),(2,2)]))\nprint(sort_list([(1,2),(2,3),(2,2)]))\nprint(sort_list([(1,2),(2,3),(2,2),(1,3)]))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/sort-list-with-duplicate-elements/discuss/354959/Python-solution-using-lambda-with-one-function-call-per-element\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        h = head\n        while h:\n            nh = h.next\n            while h.next and h.next.val == h.val:\n                h = h.next\n            if not h.next:\n                return head\n            h.next = h.next.next\n            new_head = h\n            h = nh\n        return new_head\n\n\nif __name__ == '__main__':\n    # head = ListNode(1)\n    # head.next = ListNode(2)\n    # head.next.next = ListNode(3)\n    # head.next.next.next = ListNode(4)\n    # head.next.next.next.next = ListNode(5)\n    # head.next.next.next.next.next = ListNode(6)\n    # head.next.next.next.next.next.next = ListNode(7)\n    # head.next.next.next.next.next.next.next = ListNode(8)\n    # head.next.next.next.next.next.next.next.next = ListNode(9)\n    # head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    # head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    # head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    # head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    # head.next.next.next.next.next.next.next.next.next."
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def sort(myList):\n    for i in range(len(myList)):\n        myList[i] = sorted(myList[i])\n    return myList\n\nprint(sort([(1, 'a'), (2, 'b'), (2, 'c'), (3, 'd')]))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n            \n        fast, slow = head, head.next\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n            \n        fast, slow = head, head.next\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n            \n        while slow:\n            temp = slow.next\n            slow.next = fast\n            fast = temp\n            \n        return head"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "import collections\nimport heapq\nimport itertools\n\n# Complete the sorting function below.\ndef sorting(arr):\n    heap = collections.defaultdict(list)\n    for i in arr:\n        heap[i[0]].append(i)\n\n    for k, v in heap.items():\n        heapq.heapify(v)\n\n    return [heap[i][0] for i in xrange(len(heap))]\n\n# https://www.hackerrank.com/challenges/sorting-a-sorted-list/problem"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __repr__(self):\n        return \"({}, {})\".format(self.x, self.y)\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        if len(tuples) <= 1:\n            return\n        \n        for i in range(len(tuples) - 1):\n            if tuples[i].x == tuples[i+1].x:\n                tuples[i].y += tuples[i+1].y\n                tuples.pop(i+1)\n        \n        for i in range(len(tuples) - 1):\n            tuples[i].y += tuples[i+1].y\n            tuples.pop(i+1)\n        \n        for i in range(len(tuples)):\n            tuples[i].y += tuples[i].y\n            \n        \n    def sortTuples2(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        if len(tuples) <= 1:\n            return\n        \n        for i in range(len(tuples) - 1):\n            if tuples[i].x == tuples[i+1].x:\n                tuples[i].y += tuples[i+1].y\n                tuples.pop(i+1)\n        \n        for i in range(len(tuples) - 1):\n            tuples[i].y += tuples[i+1].y\n            tuples.pop(i+1)\n        \n        for i in range(len(tuples)):\n            tuples[i].y += tuples[i].y\n            \n        \n    def sortTuples3(self, tuples):\n        \"\"\"\n        :type tuples"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sort-a-list/problem\n# https://www.hackerrank.com/challenges/sort-a-list/submissions/code/14120414\n\n\ndef sort_list(lst):\n    \"\"\"\n    Sorts the given list based on the occurrence of first element of tuples.\n    :param lst: List to be sorted.\n    :return: List of sorted elements.\n    \"\"\"\n    # Sorting the list based on the occurrence of first element of tuples.\n    return sorted(lst, key=lambda x: (x[0], x[1]))\n\n\nif __name__ == '__main__':\n    lst = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]\n    print(sort_list(lst))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/sort-list-based-on-frequency/\n\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def sortListBasedOnFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = dummy.next\n\n        while curr:\n            next = curr.next\n            while next and next.val == curr.val:\n                next = next.next\n\n            if next:\n                prev.next = next\n                curr = next\n            else:\n                curr = curr.next\n                prev = prev.next\n\n        return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8))))))))\n\n    s = Solution()\n    print s.sortListBasedOnFrequency(head)"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = None\n\nclass Solution(object):\n    def sortList(self, list):\n        \"\"\"\n        :type list: List[Tuple]\n        :rtype: void Do not return anything, modify list in-place instead.\n        \"\"\"\n        if not list:\n            return\n        t = list[0]\n        for i in range(1, len(list)):\n            if t[0]!= list[i][0]:\n                list.insert(i, t)\n                t = list[i]\n        list.insert(0, t)\n        return\n\n\nif __name__ == '__main__':\n    s = Solution()\n    t = [\n        (1, 2),\n        (3, 4),\n        (1, 3),\n        (3, 1),\n        (2, 1),\n        (2, 3),\n        (1, 2, 3),\n        (1, 3, 2),\n        (3, 1, 2)\n    ]\n    s.sortList(t)\n    for t in t:\n        print(t)"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def sort_list(l):\n    l.sort(key=lambda x: x[0])\n    return l\n\n\ndef test():\n    l = [('a', 1), ('b', 1), ('c', 3)]\n    print(sort_list(l))\n    l = [('a', 1), ('c', 3), ('b', 1)]\n    print(sort_list(l))\n    l = [('a', 1), ('c', 3), ('b', 1), ('c', 3)]\n    print(sort_list(l))\n    l = [('a', 1), ('c', 3), ('b', 1), ('c', 3), ('c', 3)]\n    print(sort_list(l))\n\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def sort_list(lst):\n    if len(lst) <= 1:\n        return lst\n    else:\n        return sort_list(lst[:len(lst)/2]) + sort_list(lst[len(lst)/2:])\n\n\ndef main():\n    lst = [(-1, 1), (-2, 2), (-3, 3), (-4, 4), (-5, 5), (-6, 6), (-7, 7)]\n    print(sort_list(lst))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\ndef sort_list(list_to_sort):\n    return sorted(list_to_sort, key=lambda x: x[0])\n\n# Test Cases\nprint(sort_list([(1, 3), (3, 5), (1, 1)]))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# Example\n# [1,2,3,1,2,3,1,2,3]\n# sort([1,2,3]) -> [1,1,2,2,3,3]\n# sort([1,3,2,1,2,3]) -> [1,1,2,2,3,3]\n# sort([-3,-2,-1,0,1,2,3]) -> [0,1,2,2,3,3,3]\n# sort([-3,-2,-1,0,1,2,3,4]) -> [0,0,1,1,2,2,3,3,3]\n\n# Time complexity: O(n log n)\n# Space complexity: O(n)\n\nclass Solution:\n    def sort(self, nums: List[int]) -> None:\n        if not nums:\n            return\n\n        n = len(nums)\n        for i in range(n):\n            for j in range(i, n):\n                if nums[i] < nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return\n\n\nif __name__ == \"__main__\":\n    print(Solution().sort([-3, -2, -1, 0, 1, 2, 3, 4]))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n\n        head.next = self.sortList(head.next)\n        head.next.next = None\n        head.next = self.sortList(head.next)\n        return head\n\n\nif __name__ == \"__main__\":\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))).next\n    head = Solution().sortList(head)\n    print(head.val)\n    print(head.next.val)\n    print(head.next.next.val)\n    print(head.next.next.next.val)\n    print(head.next.next.next.next.val)"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: None Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        n = len(tuples)\n        if n == 0:\n            return\n        \n        for i in range(n-1):\n            if tuples[i].x > tuples[i+1].x:\n                tuples[i], tuples[i+1] = tuples[i+1], tuples[i]\n        \n        return"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-an-array/problem\n# https://www.hackerrank.com/challenges/sorting-an-array/submissions/code/14558834\n# https://www.hackerrank.com/challenges/sorting-an-array/discuss/9351852\n# https://www.hackerrank.com/challenges/sorting-an-array/submissions/code/14558833\n\nimport sys\n\ndef sort(lst):\n    \"\"\"\n    Sort an array using the occurrence of the first element of tuples.\n    \"\"\"\n    \n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[j][0] == lst[i][0]:\n                lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\n\ndef main():\n    n = int(input().strip())\n    lst = list(map(int, input().strip().split(' ')))\n    lst = sort(lst)\n    print(' '.join(map(str, lst)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/sort-list-based-on-frequency-of-elements/discuss/130159/Python-Sorting-based-on-frequency-of-elements\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def sortListBasedOnFrequency(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # https://leetcode.com/problems/sort-list-based-on-frequency-of-elements/discuss/130159/Python-Sorting-based-on-frequency-of-elements\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element.\n        # The idea is to use a map to keep track of the frequency of each element."
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# TODO\n# Use numpy.argsort()\n\n# Your Solution\n# The idea is to create a function that sorts the list based on the occurrence of the first element of the tuple\n# and then compare the first element of the tuple with the other elements of the tuple.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater.\n# When the first element of the tuple is greater than the other elements of the tuple, it means the first element of the tuple is greater."
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "def sort_list_by_occurrence(list):\n    \"\"\"\n    :type list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # sort by the first element of the tuple, if the first element is same, sort by the second element\n    # if the first element is not same, sort by the first element\n    # for example: [(1, 1), (1, 2), (2, 1)]\n    # [1, 2, 1]\n    # [1, 1, 2]\n    # [2, 1, 1]\n    return sorted(list, key=lambda x: x[0], reverse=False)\n\ndef test_sort_list_by_occurrence():\n    assert sort_list_by_occurrence([[1, 1], [1, 2], [2, 1]]) == [[1, 1], [1, 2], [2, 1]]\n\nif __name__ == '__main__':\n    test_sort_list_by_occurrence()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-a-list/problem\n\ndef sort_list(l):\n    # sort the list\n    return sorted(l, key=lambda x: x[0])\n\n# Driver program to test above functions\nl = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12)]\nprint(sort_list(l))"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\ndef sort_arr(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n                \n    return arr\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sort_arr(arr))\n    \nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 25,
      "score": 9.0,
      "candidate": "# -*- coding: utf-8 -*-\n# pylint: disable=no-self-use\n# pylint: disable=too-few-public-methods\n\ndef sort_list(lst):\n    \"\"\"\n    Sort the given list based on the occurrence of first element of tuples.\n\n    Example\n    Given\n    lst = [\n        (1, 2, 3),\n        (1, 2, 4),\n        (1, 3, 4),\n        (1, 3, 5),\n        (1, 4, 5),\n        (2, 3, 4),\n        (2, 3, 5),\n        (2, 4, 5),\n        (3, 4, 5)\n    ]\n    return\n    [\n        (1, 2, 3),\n        (1, 2, 4),\n        (1, 3, 4),\n        (1, 3, 5),\n        (1, 4, 5),\n        (2, 3, 4),\n        (2, 3, 5),\n        (2, 4, 5),\n        (3, 4, 5)\n    ]\n    \"\"\"\n    for i in range(0, len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if lst[i][0] == lst[j][0]:\n                lst[i], lst[j] = lst[j], lst[i]\n    return lst"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\n# https://www.hackerrank.com/challenges/sorting-an-array\n\ndef sort_array(arr):\n    for i in range(len(arr)):\n        min_index = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        if i!= min_index:\n            arr[i], arr[min_index] = arr[min_index], arr[i]\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 1, 4, 6, 5]\n    sort_array(arr)\n    print arr"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "import collections\nfrom collections import namedtuple\n\ndef sort_by_first_elem(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n    t = namedtuple('t', 'first second')\n    occurrence = collections.Counter(t(x, y) for x, y in enumerate(lst))\n    occurrence = [(x, y) for (x, y), count in occurrence.items() for i in range(count)]\n    occurrence.sort(key=lambda x: x[0])\n    return [y for x, y in occurrence]"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def sort_tuple(list_):\n    \"\"\"\n    >>> sort_tuple([('a',1),('b',2),('c',2),('d',3)])\n    [('d', 3), ('b', 2), ('c', 2), ('a', 1)]\n    >>> sort_tuple([('a',1),('c',2),('b',2),('d',3)])\n    [('a', 1), ('b', 2), ('c', 2), ('d', 3)]\n    >>> sort_tuple([('a',1),('a',2),('a',3),('a',4)])\n    [('a', 4), ('a', 3), ('a', 2), ('a', 1)]\n    >>> sort_tuple([('a',1),('a',2),('a',3),('a',4),('a',5),('a',6)])\n    [('a', 5), ('a', 6), ('a', 4), ('a', 3), ('a', 2), ('a', 1)]\n    \"\"\"\n    return list_\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        def sort(tuples):\n            if len(tuples) == 1:\n                return\n            if tuples[0].x < tuples[1].x:\n                tuples[0], tuples[1] = tuples[1], tuples[0]\n            for i in range(2, len(tuples)):\n                if tuples[i].x < tuples[i - 1].x:\n                    tuples[i - 1], tuples[i] = tuples[i], tuples[i - 1]\n                else:\n                    continue\n            sort(tuples[1:])\n        sort(tuples)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    print(arr)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-an-array\n\nimport random\n\ndef sort(a):\n    n = len(a)\n    if n == 0:\n        return a\n\n    # Generate a random permutation of the list.\n    perm = [random.randint(0, n-1) for _ in range(n)]\n    random.shuffle(perm)\n\n    # Create a new list to store the sorted elements.\n    new_a = [a[i] for i in perm]\n\n    # Sort the original list.\n    sort(a)\n\n    # Merge the sorted list with the original list.\n    new_a.extend(a)\n\n    return new_a\n\nif __name__ == \"__main__\":\n    a = [random.randint(0, 100) for _ in range(10)]\n    print(sort(a))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def sort_list(list_):\n    \"\"\"\n    Input: List of tuples\n    Output: Sorted list of tuples\n    \"\"\"\n    \n    # Sorting using bubble sort\n    for i in range(len(list_) - 1):\n        for j in range(i + 1, len(list_)):\n            if list_[i][0] > list_[j][0]:\n                list_[i], list_[j] = list_[j], list_[i]\n\n    return list_"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def sort(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda tup: tup[0])\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ([1, 2, 3, 1, 2, 3, 1, 2, 3], [1, 1, 2, 2, 3, 3, 1, 2, 2]),\n        ([1, 2, 3], [1, 1, 2, 2, 3, 3])\n    ]\n    for case in test_cases:\n        print(\"Case #{}: {}\".format(case[0], sort(case[1])))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def sort_list(lst):\n    \"\"\"\n    :type lst: List[Tuple]\n    :rtype: None\n    \"\"\"\n    for i in range(len(lst) - 1):\n        for j in range(i + 1, len(lst)):\n            if lst[j][0] < lst[i][0]:\n                lst[i], lst[j] = lst[j], lst[i]\n\n\nif __name__ == \"__main__\":\n    lst = [\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),\n        (3, 1),\n        (3, 3),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),\n        (3, 1),\n        (3, 3),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),\n        (3, 1),\n        (3, 3),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),\n        (3, 1),\n        (3, 3),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),\n        (3, 1),\n        (3, 3),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 2),\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (1, 3),"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\n# Your sorting function will be called as follows:\n# function(some_list, key_function=None, reverse=False)\ndef sort(some_list, key_function=None, reverse=False):\n    if key_function is None:\n        key_function = lambda x: x[0]\n    d = defaultdict(list)\n    for x in some_list:\n        d[x[0]].append(x)\n    for k, v in d.items():\n        if key_function(v[0]) == k:\n            d[k].sort(key=lambda x: x[1])\n            if reverse:\n                d[k].reverse()\n    return [x for x in d.values()]\n\n# Examples:\nsome_list = [\n    (1, 2, 3),\n    (1, 2, 3),\n    (1, 3, 2),\n    (1, 3, 2),\n    (2, 1, 3),\n    (2, 1, 3),\n    (2, 3, 1),\n    (2, 3, 1),\n    (3, 1, 2),\n    (3, 1, 2),\n]\n\n# Output:\n# [(2, 1, 3), (1, 2, 3), (1, 3, 2), (3, 1, 2), (3, 2, 1), (1, 3, 2), (2, 1, 3), (1, 3, 2)]\n# [(1, 3, 2), (3, 1, 2), (2, 1, 3), (1, 2, 3), (3, 1, 2), (2, 3, 1), (1, 2, 3), (3, 2, 1)]\n# [(3, 2, 1), (1, 2, 3), (1, 3, 2), (2, 3, 1), (2, 1, 3), (1, 3, 2), (3, 1, 2), (2, 1, 3)]\nsort(some_list)"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "def sort_list(lst):\n    for i in range(0, len(lst)):\n        for j in range(0, i):\n            if lst[j][0] < lst[i][0]:\n                lst.insert(j, lst.pop(i))\n                break\n\nprint(sort_list([('a', 1), ('b', 2), ('c', 3), ('d', 4)]))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort_list(my_list):\n    \"\"\"\n    :type my_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    my_dict = defaultdict(int)\n    for item in my_list:\n        my_dict[item[0]] += 1\n\n    my_list.sort(key=lambda x: my_dict[x[0]])\n    return my_list\n\n# Your Solution"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def sort_list(l):\n    return sorted(l, key=lambda x: (x[0], x[1]))\n\nif __name__ == \"__main__\":\n    l = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n    print(sort_list(l))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "import collections\n\n\ndef sort(l):\n    \"\"\"\n    :type l: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    n = int(input())\n    l = []\n    for _ in range(n):\n        l.append(input())\n\n    print(sort(l))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort_tuples(tuples):\n    \"\"\"\n    :type tuples: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    d = defaultdict(int)\n    for t in tuples:\n        d[t] += 1\n    sorted_tuples = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    return [t for t in sorted_tuples]"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from itertools import groupby\n\n\ndef sort_occurrences(a_list):\n    # write your code here\n    for key, value in groupby(a_list, lambda x: x[0]):\n        value = list(value)\n        value.sort(key=lambda x: x[1])\n        yield value\n\n\nif __name__ == '__main__':\n    a_list = [('a', 1), ('b', 2), ('c', 3), ('a', 1), ('b', 2)]\n    for item in sort_occurrences(a_list):\n        print(item)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "import collections\n\ndef sort_list(arr):\n    \"\"\"\n    :type arr: List[Tuple[int, int]]\n    :rtype: None\n    \"\"\"\n    lst = collections.defaultdict(list)\n    for i in arr:\n        lst[i[0]].append(i)\n    for k, v in lst.items():\n        v.sort(key=lambda x: x[1])\n    for i in lst.values():\n        arr[:] = i\n\nif __name__ == '__main__':\n    arr = [(-2, -1), (-1, -1), (-1, -2), (1, 1), (2, 2)]\n    sort_list(arr)\n    print(arr)"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __str__(self):\n        return str(self.x) + str(self.y)\n\nclass Solution(object):\n    def sortOccurrence(self, nums):\n        \"\"\"\n        :type nums: List[Tuple[int]]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x[0])"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        tuples.sort(key=lambda x: (x.x, x.y))"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def sort_list(list_):\n    # write your code here\n    if len(list_) > 1:\n        for i in range(1, len(list_)):\n            for j in range(i):\n                if list_[j][0] < list_[j-1][0]:\n                    list_[j-1], list_[j] = list_[j], list_[j-1]\n    return list_"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort_list(lst):\n    \"\"\"\n    >>> sort_list([(1,2),(1,3),(2,3),(2,4),(3,4),(3,5),(4,5),(4,6),(5,6),(6,7),(7,8),(7,9),(8,9)])\n    [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5), (4, 6), (5, 6), (5, 7), (6, 7), (6, 8), (7, 8), (7, 9), (8, 9)]\n    \"\"\"\n    d = defaultdict(list)\n    for i in lst:\n        d[i[0]].append(i[1:])\n    return sorted(d.items())\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom collections import OrderedDict\n\n# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\n# Input Format\n# The first line contains an integer T denoting the number of test cases.\n# Then T lines follow, each containing an integer N denoting the length of the given list.\n# The Nth line contains N space-separated integers denoting the elements of the given list.\n# The last line contains a single integer denoting the value of the first element of the given list.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is denoted by 3.\n# The last element of the list is denoted by N.\n# The first element of the list is denoted by 1.\n# The second element of the list is denoted by 2.\n# The third element of the list is"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "import heapq\n\ndef sort_by_first_occurrence(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    heapq.heapify(list_of_tuples)\n    for index, tuple in enumerate(list_of_tuples):\n        if tuple[0] in list_of_tuples[index][1]:\n            heapq.heapreplace(list_of_tuples, (tuple[0], tuple[1], tuple[2], tuple[3]))\n    return list_of_tuples"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def sort_list(list_):\n    list_ = sorted(list_, key=lambda x: x[0])\n    return list_\n\nprint(sort_list([(1,2),(1,1),(2,2)]))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def sort_lists(lst):\n    \"\"\"\n    :type lst: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return sorted(lst, key=lambda x: len(x[0]))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "import heapq\n\ndef sort_by_first_element(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # First element of all the tuples\n    first_element = []\n    for i in range(len(nums)):\n        first_element.append(nums[i][0])\n\n    # Sort the list based on first element of all the tuples\n    return sorted(nums, key=lambda x: first_element.index(x[0]))\n\n# Note: The first element of tuple is the first element of first tuple\n#       and second element is the second element of first tuple\ndef sort_by_second_element(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # First element of all the tuples\n    first_element = []\n    for i in range(len(nums)):\n        first_element.append(nums[i][0])\n\n    # Sort the list based on second element of all the tuples\n    return sorted(nums, key=lambda x: first_element.index(x[1]))\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    print(sort_by_first_element(nums))\n    print(sort_by_second_element(nums))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "import heapq\n\ndef sort_list(my_list):\n    heap = []\n    for i in my_list:\n        heapq.heappush(heap, i)\n\n    for i in range(len(my_list)):\n        heapq.heappop(heap)\n\n    return heap\n\nif __name__ == '__main__':\n    my_list = [1, 2, 3, 4, 5, 6, 7]\n    print sort_list(my_list)"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def sort(lst):\n    return sorted(lst, key=lambda x: len(x))\n\n\ndef main():\n    print(sort([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort_lists(lists):\n    \"\"\"\n    :type lists: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    for lst in lists:\n        res.append(sorted(lst))\n\n    return res\n\nif __name__ == '__main__':\n    lists = [\n        [1,2,3],\n        [2,3,1],\n        [1,2,2],\n        [1,2,3,1],\n        [1,2,3,4],\n        [1,2,4,3],\n        [1,2,3,4,3],\n        [1,2,3,4,5],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6,7],\n        [1,2,3,4,5,6,7,8],\n        [1,2,3,4,5,6,7,8,9],\n        [1,2,3,4,5,6,7,8,9,10],\n        [1,2,3,4,5,6,7,8,9,10,11],\n        [1,2,3,4,5,6,7,8,9,10,11,12],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\n        [1,2,3,4,5,6,7,8,9,10,"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def sort_list_by_occurrence(list_to_sort):\n    if len(list_to_sort) == 0:\n        return list_to_sort\n\n    tuple_list = list(zip(*list_to_sort))\n    tuple_list = sorted(tuple_list, key=lambda x: x[0])\n\n    return [x[1] for x in tuple_list]\n\ndef main():\n    list_to_sort = [('B', 2), ('A', 1), ('C', 1), ('A', 3), ('C', 2)]\n    print(sort_list_by_occurrence(list_to_sort))\n\n    list_to_sort = [('B', 2), ('A', 1), ('C', 1), ('A', 3), ('C', 2), ('B', 1)]\n    print(sort_list_by_occurrence(list_to_sort))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "def sort_list(lst):\n    \"\"\"\n    :type lst: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # The idea is to find the first element of the tuple\n    # and then sort the list based on the occurrence of the first element of the tuple.\n    # This is how you can do it.\n    # sort(a, lambda a, b: cmp(a[0], b[0]))\n    # sort(a, lambda a, b: cmp(a[0], b[1]))\n\n    # But how do you do it?\n    # sort(a, lambda a, b: cmp(a[0], b[0]) or cmp(a[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[0], a[1]) < (b[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[0], b[0]) > (b[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[0], b[0]) > (b[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[0], b[1]) < (b[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[0], b[1]) > (b[0], b[1]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[1], b[0]) < (b[1], b[0]))\n\n    # This is the way you can do it.\n    # sort(a, lambda a, b: (a[1], b[0]) > (b[1], b[0]))\n\n    # This is the way you can do it.\n    # sort(a,"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort(alist):\n    \"\"\"\n    Sort a list based on the occurrence of first element of tuples.\n    :param alist: list\n    :return: sorted list\n    \"\"\"\n    res = defaultdict(list)\n    for item in alist:\n        res[item[0]].append(item)\n\n    res = [(i, l) for i, l in res.items()]\n    res = sorted(res, key=lambda x: x[1])\n    return [i for i, l in res]\n\nif __name__ == \"__main__\":\n    alist = [('a', 3), ('b', 2), ('c', 1), ('d', 2), ('e', 1), ('f', 1)]\n    print(sort(alist))\n    print(alist)\n    print(alist)"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef sort_by_occurrence(lst):\n    \"\"\"\n    :type lst: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    d = defaultdict(list)\n    for i in lst:\n        d[i[0]].append(i)\n    return sorted(d.items(), key=lambda x: x[0])"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        current = head\n        while current:\n            current = self.next(current)\n        current = head\n        while current:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = self.next(current)\n        return head\n    \n    def next(self, node):\n        if node.next:\n            return node.next\n        else:\n            return None"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'a b')\n\ndef sort_tuple(lst):\n    def sort_func(x):\n        return Tuple(x[0], x[1])\n    return sorted(lst, key=sort_func)\n\nif __name__ == '__main__':\n    lst = [('b', 'a'), ('a', 'b'), ('a', 'a'), ('a', 'b'), ('b', 'b'), ('c', 'a'), ('a', 'c')]\n    print(sort_tuple(lst))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "def sort_by_occurrence(list_of_tuples):\n    \"\"\"\n    :type list_of_tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda x: x[0])\n\nif __name__ == '__main__':\n    l = [('a', 1), ('b', 2), ('c', 1), ('d', 3)]\n    l = sort_by_occurrence(l)\n    print(l)"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "# The solution is to use a hash table to store the result of comparing each tuple\n# and then use the hash table to find the first element of the tuple.\n\n# Time complexity : O(n)\n\n# Space complexity : O(n)\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {void} Do not return anything, modify head in-place instead.\n    def sortList(self, head):\n        if not head or not head.next:\n            return head\n        \n        h = {}\n        p = head\n        while p:\n            h[p.val] = p\n            p = p.next\n        \n        p = head\n        while p:\n            if p.val in h:\n                p.next = h[p.val]\n                h[p.val].next = p.next\n                p.next = None\n            p = p.next\n        \n        return head"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "from collections import Counter\n\ndef sort_list(lst):\n    \"\"\"\n    Write a function to sort the given list based on the occurrence of first element of tuples.\n    :type lst: List[Tuple[str, int]]\n    :rtype: List[Tuple[str, int]]\n    \"\"\"\n    return sorted(lst, key=lambda tup: tup[1], reverse=True)\n\n\nif __name__ == '__main__':\n    lst = [('a', 3), ('b', 2), ('c', 4), ('d', 1), ('e', 1)]\n    print(sort_list(lst))"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "def sort_list_by_occurrence(lst):\n    \"\"\"\n    :type lst: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return sorted(lst, key=lambda x: x[0])\n\nclass Solution(object):\n    def sortListByOccurrence(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        lst = [x for x in (head.val, head.next.val) if x]\n        lst.sort()\n        return self.sortListByOccurrence(head.next)\n\n\nif __name__ == \"__main__\":\n    # n1 = ListNode(1)\n    # n2 = ListNode(2)\n    # n3 = ListNode(1)\n    # n4 = ListNode(2)\n    # n5 = ListNode(3)\n    # n6 = ListNode(4)\n    # n7 = ListNode(5)\n    # n8 = ListNode(6)\n    # n9 = ListNode(7)\n    # n10 = ListNode(8)\n    # n11 = ListNode(9)\n    # n12 = ListNode(10)\n    # n13 = ListNode(11)\n    # n14 = ListNode(12)\n    # n15 = ListNode(13)\n    # n16 = ListNode(14)\n    # n17 = ListNode(15)\n    # n18 = ListNode(16)\n    # n19 = ListNode(17)\n    # n20 = ListNode(18)\n    # n21 = ListNode(19)\n    # n22 = ListNode(20)\n    # n23 = ListNode(21)\n    # n24 = ListNode(22)\n    # n25 = ListNode(23)\n    # n26 = ListNode(24)\n    # n27 = ListNode(25)\n    # n28 = ListNode(26)\n    # n29 = ListNode(27)\n    # n30 = ListNode(28)\n    # n31 = List"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "import collections\nimport unittest\nfrom itertools import chain\n\n# https://www.geeksforgeeks.org/sort-a-given-list-based-on-the-occurrence-of-the-first-element-of-tuples/\n\ndef sort_list_based_on_first_element(lst):\n    \"\"\"\n    :type lst: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    return sorted(lst, key=lambda x: x[0])\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(sort_list_based_on_first_element([(1, 2), (1, 1), (2, 1), (3, 1), (2, 3)]),\n                         [(1, 1), (1, 2), (2, 1), (2, 3), (3, 1)])\n\n        self.assertEqual(sort_list_based_on_first_element([(1, 2), (1, 1), (2, 1), (3, 1), (2, 3)]),\n                         [(2, 1), (2, 3), (1, 1), (1, 2), (3, 1)])\n\n        self.assertEqual(sort_list_based_on_first_element([(1, 2), (1, 1), (2, 1), (3, 1), (2, 3)]),\n                         [(1, 1), (1, 2), (2, 1), (2, 3), (3, 1)])\n\n        self.assertEqual(sort_list_based_on_first_element([(1, 2), (1, 1), (2, 1), (3, 1), (2, 3)]),\n                         [(1, 1), (1, 2), (2, 1), (2, 3), (3, 1)])\n\n        self.assertEqual(sort_list_based_on_first_element([(1, 2), (1, 1), (2, 1), (3, 1), (2, 3)]),\n                         [(1, 1), (1, 2), (2, 1), (2, 3), (3"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "# Your function will be called as follows:\n# sorted_list = your_function(unsorted_list)\n\n# Note:\n# Your function should return the sorted list.\n# The input list will be given as a tuple of lists.\n\n# Example:\n# Given [1,2,3,2,3,2,1],\n# return [1,1,2,2,3,3,2].\n\ndef sort_list(unsorted_list):\n    \"\"\"\n    :type unsorted_list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # https://www.tutorialspoint.com/python/sort_list.htm\n    # https://www.tutorialspoint.com/python/sort_list_recursive.htm\n    # https://www.tutorialspoint.com/python/sort_list_iterative.htm\n    if not unsorted_list:\n        return []\n\n    # base case\n    if len(unsorted_list) == 1:\n        return unsorted_list\n\n    # recursive case\n    # sort_list_recursive(unsorted_list)\n    # sort_list_iterative(unsorted_list)\n\n    # iterative case\n    # sort_list_iterative(unsorted_list)\n\n    # iterative case\n    # sort_list_iterative(unsorted_list)\n    return sort_list_recursive(unsorted_list)\n\n\ndef sort_list_recursive(unsorted_list):\n    if not unsorted_list:\n        return []\n\n    # base case\n    if len(unsorted_list) == 1:\n        return unsorted_list\n\n    # recursive case\n    # sort_list_recursive(unsorted_list[0:1])\n    # sort_list_recursive(unsorted_list[0:2])\n    return sort_list_recursive(unsorted_list[0:1]) + unsorted_list[1:] + sort_list_recursive(unsorted_list[0:2])\n\n\ndef sort_list_iterative(unsorted_list):\n    if not unsorted_list:\n        return []\n\n    # base case"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/sorting-an-array/problem\n\nimport unittest\n\ndef sort_list(list):\n    \"\"\"\n    Sort the given list based on the occurrence of first element of tuples.\n\n    :param list: A list of numbers.\n    :return: The sorted list.\n    \"\"\"\n\n    # Sort the given list based on the occurrence of first element of tuples.\n    # 1. Find the first element of the list.\n    # 2. Find the next element of the list that has the same first element as the first element of the list.\n    # 3. Move the second element to the first position of the list.\n    # 4. Repeat steps 2 and 3 until the end of the list.\n    # 5. Return the sorted list.\n\n    # The first element of the list.\n    first = list[0]\n\n    # The next element of the list that has the same first element as the first element of the list.\n    next_first = list[1]\n\n    # The second element of the list.\n    second = list[2]\n\n    # Move the second element to the first position of the list.\n    list[0], list[1] = list[1], list[0]\n\n    # Repeat steps 2 and 3 until the end of the list.\n    for i in range(3, len(list)):\n        if list[i] == next_first:\n            list[i], list[i-1] = list[i-1], list[i]\n            next_first = list[i+1]\n\n    # Return the sorted list.\n    return list\n\n\nclass TestCode(unittest.TestCase):\n    def test_sort_list(self):\n        self.assertEqual(sort_list([2, 1, 3]), [1, 2, 3])\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "def sort_list(my_list):\n    \"\"\"\n    :type my_list: List[Tuple]\n    :rtype: None\n    \"\"\"\n    # Your code here\n    list_of_tuples = [(i,j) for i,j in my_list]\n    list_of_tuples.sort(key=lambda tup: tup[0])\n    return [tup[1] for tup in list_of_tuples]\n\nif __name__ == \"__main__\":\n    my_list = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n    print(sort_list(my_list))"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "def sort_list(lst):\n    '''\n    :type lst: List[int]\n    :rtype: List[int]\n    '''\n    return sorted(lst, key=lambda x: lst.count(x[0]))\n\ndef main():\n    '''\n    Example:\n        >>> lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        >>> sort_list(lst)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    '''\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    lst = sort_list(lst)\n    print(lst)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "def sort_tuples(lst):\n    \"\"\"\n    :type lst: List[tuple]\n    :rtype: None\n    \"\"\"\n    # Your Code Here\n    if len(lst) < 2:\n        return\n    pivot = lst[0]\n    lst = [x for x in lst if x[0]!= pivot]\n    lst = [x for x in lst if x[1]!= pivot]\n    lst = [x for x in lst if x[0]!= pivot]\n    lst.sort(key=lambda x: x[0])\n    lst = [x for x in lst if x[1]!= pivot]\n    lst = [x for x in lst if x[1]!= pivot]\n    lst.sort(key=lambda x: x[1])\n    lst = [x for x in lst if x[0]!= pivot]\n    lst = [x for x in lst if x[0]!= pivot]\n    lst.sort(key=lambda x: x[0])\n    lst = [x for x in lst if x[1]!= pivot]\n    lst = [x for x in lst if x[1]!= pivot]\n    lst.sort(key=lambda x: x[1])\n    lst = [x for x in lst if x[0]!= pivot]\n    lst = [x for x in lst if x[0]!= pivot]\n    lst.sort(key=lambda x: x[0])\n    lst = [x for x in lst if x[1]!= pivot]\n    lst = [x for x in lst if x[1]!= pivot]\n    lst.sort(key=lambda x: x[1])\n    lst = [x for x in lst if x[0]!= pivot]\n    lst = [x for x in lst if x[0]!= pivot]\n    lst.sort(key=lambda x: x[0])\n    lst = [x for x in lst if x[1]!= pivot]\n    lst = [x for x in lst if x["
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "def sort_tuple(tuple_list):\n    \"\"\"\n    :type tuple_list: List[tuple]\n    :rtype: void\n    \"\"\"\n    # YOUR CODE HERE\n    tuple_list.sort(key=lambda x: x[0])\n\n\nif __name__ == \"__main__\":\n    tuple_list = [('a', 1), ('a', 2), ('b', 1), ('b', 3), ('c', 1), ('c', 2)]\n    sort_tuple(tuple_list)\n    for item in tuple_list:\n        print(item)"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "# Your sorting function should return a new list which is sorted in ascending order.\n# The list should be sorted in ascending order for the given input list.\n# If the given input list is empty, the output should be an empty list.\n# The input list is given as a tuple of numbers.\n# The input tuple is sorted in ascending order.\n# The first element of each tuple is the number of times that the first element appears in the input list.\n# Example 1:\n# Input: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Example 2:\n# Input: [1, 2, 1, 1, 1, 1]\n# Output: [1, 1, 1, 1, 1, 1]\n# Example 3:\n# Input: [2, 1, 2, 1, 2, 1]\n# Output: [1, 2, 2, 1, 1, 1]\n\n# Note:\n# The number of elements in the input list is in the range [1, 10,000].\n# The range of the first element in the input list is in the range [1, 10^9].\n# The given list is a sorted list and the input list is also sorted in ascending order.\n# Example 1:\n# Input: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Example 2:\n# Input: [1, 2, 1, 1, 1, 1]\n# Output: [1, 1, 1, 1, 1, 1]\n# Example 3:\n# Input: [2, 1, 2, 1, 2, 1]\n# Output: [1, 2, 2, 1, 1, 1]\n\n# Solution:\n\nclass Solution:\n    # @param {list} nums\n    # @return {list}\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in range(len(nums) -"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# O(NlogN) time and O(N) space\n# O(NlogN) time and O(N) space\ndef sort_list(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0])\n\n# O(NlogN) time and O(N) space\ndef sort_list_2(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0], reverse=True)\n\n# O(NlogN) time and O(N) space\ndef sort_list_3(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0], reverse=True)\n\n# O(NlogN) time and O(N) space\ndef sort_list_4(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0], reverse=True)\n\n# O(NlogN) time and O(N) space\ndef sort_list_5(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0], reverse=True)\n\n# O(NlogN) time and O(N) space\ndef sort_list_6(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void\n    \"\"\"\n    # sort the list\n    alist.sort(key=lambda x: x[0], reverse=True)\n\n# O(NlogN) time and O(N) space\ndef sort_list_7(alist):\n    \"\"\"\n    :type alist: List[tuple]\n    :rtype: void"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# Your function will be called as follows:\n# sorted_list = your_function(sorted_list)\n\ndef sort_list(list_of_tuples):\n    # YOUR CODE HERE\n    print list_of_tuples\n    sorted_list = []\n    for i in range(len(list_of_tuples)):\n        for j in range(len(list_of_tuples)):\n            if list_of_tuples[j][0] == list_of_tuples[i][0]:\n                list_of_tuples[j][1] = list_of_tuples[j][1] + list_of_tuples[i][1]\n                list_of_tuples[j][2] = list_of_tuples[j][2] + list_of_tuples[i][2]\n                list_of_tuples[j][3] = list_of_tuples[j][3] + list_of_tuples[i][3]\n                list_of_tuples[j][4] = list_of_tuples[j][4] + list_of_tuples[i][4]\n                list_of_tuples[j][5] = list_of_tuples[j][5] + list_of_tuples[i][5]\n                list_of_tuples[j][6] = list_of_tuples[j][6] + list_of_tuples[i][6]\n                list_of_tuples[j][7] = list_of_tuples[j][7] + list_of_tuples[i][7]\n                list_of_tuples[j][8] = list_of_tuples[j][8] + list_of_tuples[i][8]\n                list_of_tuples[j][9] = list_of_tuples[j][9] + list_of_tuples[i][9]\n                list_of_tuples[j][10] = list_of_tuples[j][10] + list_of_tuples[i][10]\n                list_of_tuples[j][11] = list_of_tuples"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/sort-a-list-based-on-the-frequency-of-its-elements/discuss/235713/Python-solution-using-tuple-and-dictionary-sorting\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # https://leetcode.com/problems/sort-a-list-based-on-the-frequency-of-its-elements/discuss/235713/Python-solution-using-tuple-and-dictionary-sorting\n        # TODO: sort list by frequency of elements in the list\n        # find the frequency of each element\n        # use a dictionary to record frequency\n        # for each element, check if the frequency is already in the dictionary, if yes, remove the element from the list, if not, add the element to the list\n        # finally, reverse the list\n        # return the head\n        if not head:\n            return None\n\n        dic = {}\n        cur = head\n        while cur:\n            dic[cur.val] = dic.get(cur.val, 0) + 1\n            cur = cur.next\n\n        # for each element in the list, check if the frequency is already in the dictionary\n        # if yes, remove the element from the list, if not, add the element to the list\n        # finally, reverse the list\n        # return the head\n        cur = head\n        while cur:\n            if dic.get(cur.val, 0) in dic:\n                # remove the element\n                prev = cur\n                cur = cur.next\n            else:\n                # add the element\n                prev.next = cur\n                cur = cur.next\n                prev = cur\n\n        return head"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        p = head\n        q = head\n        while q.next is not None:\n            p = p.next\n            q = q.next\n            if p is None:\n                return head\n\n        if p.next is None:\n            p.next = head\n            return head\n\n        q.next = None\n        while p.next is not None:\n            p.next = p.next.next\n            q = q.next\n            while p.next is not None:\n                p = p.next\n                if p.next is None:\n                    break\n                if p.next.next is not None:\n                    if p.next.next.next is None:\n                        break\n                    if p.next.next.next.data == p.next.data:\n                        p.next = p.next.next\n                    else:\n                        break\n                else:\n                    p.next = None\n                    break\n\n        return head"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __lt__(self, other):\n        return self.x < other.x\n    def __gt__(self, other):\n        return self.x > other.x\n    def __eq__(self, other):\n        return self.x == other.x\n\n# Your Solution\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: void Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        # Your code here\n        for i in range(len(tuples)):\n            for j in range(i+1, len(tuples)):\n                if tuples[i] < tuples[j]:\n                    tuples[i], tuples[j] = tuples[j], tuples[i]\n        return"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        p1 = head\n        p2 = head.next\n        while p2 is not None:\n            if p1.val == p2.val:\n                p1 = p1.next\n                p2 = p2.next\n            elif p1.val > p2.val:\n                temp = p2\n                p2 = p1\n                p1 = p2\n                p2 = temp\n            else:\n                p1 = p1.next\n        \n        p1.next = None\n        p2 = head\n        while p1 is not None:\n            if p1.val > p2.val:\n                temp = p2\n                p2 = p1\n                p1 = p2\n                p2 = temp\n            else:\n                p1 = p1.next\n        \n        return p2"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def sort_list(lst):\n    \"\"\"\n    Input: list\n    Output: sorted list\n    \"\"\"\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][0] > lst[j][0]:\n                lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\nif __name__ == \"__main__\":\n    print sort_list([(1,2),(2,3),(3,4),(4,5),(5,6)])"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n\n        pivot = head\n        pre = head\n        while pre.next:\n            if pre.next.val == pivot.val:\n                pivot = pivot.next\n            else:\n                pre = pre.next\n                pivot = pivot.next\n\n        pre.next = pivot.next\n        pivot.next = None\n        return self.sortList(head)\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(2)\n    head.next.next.next.next.next = ListNode(3)\n\n    solution = Solution()\n    print(solution.sortList(head))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# Example 1\n# Input: [1,2,3,4,5,6,7,8,9]\n# Output: [1,1,2,3,4,5,6,7,8,9]\n\n# Example 2\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Example 3\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Example 4\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Example 5\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Example 6\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Example 7\n# Input: [1,2,3,4,5,6,7,8,9,10]\n# Output: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n\n# Note:\n# The given list"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import collections\n\ndef sort_by_first_element(list):\n    \"\"\"\n    :type list: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    sorted_list = []\n    sorted_list.append(list[0])\n    for i in range(1, len(list)):\n        if list[i][0] == sorted_list[0][0]:\n            sorted_list.append(list[i])\n        else:\n            sorted_list.append(sorted(list[i], key=lambda x: x[0]))\n    return sorted_list\n\n\nif __name__ == '__main__':\n    print(sort_by_first_element([[1,1], [2,2], [3,3]]))\n    print(sort_by_first_element([[1,1], [3,3], [2,2]]))\n    print(sort_by_first_element([[1,1], [2,2], [3,3], [1,2]]))\n    print(sort_by_first_element([[1,1], [2,2], [3,3]]))\n    print(sort_by_first_element([[1,1], [2,2]]))"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "def sort_by_first(arr):\n    \"\"\"\n    :type arr: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    return sorted(arr, key=lambda x: x[0])\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort_by_first([[1, 2], [1, 3], [2, 1], [1, 3]]) == [[1, 1], [1, 2], [2, 1], [1, 3]], \"1st\"\n    assert sort_by_first([[1, 2], [1, 3], [2, 1], [1, 3], [1, 4]]) == [[1, 1], [1, 2], [1, 3], [2, 1], [1, 4]], \"2nd\"\n    assert sort_by_first([[1, 2], [1, 3], [2, 1], [1, 3]]) == [[1, 1], [1, 2], [2, 1], [1, 3]], \"3rd\"\n    assert sort_by_first([[1, 2], [1, 3], [2, 1], [1, 3], [1, 4]]) == [[1, 1], [1, 2], [1, 3], [2, 1], [1, 4]], \"4th\"\n    assert sort_by_first([[1, 2], [1, 3], [2, 1], [1, 3], [1, 4]]) == [[1, 1], [1, 2], [1, 3], [2, 1], [1, 4]], \"5th\""
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Your sorting function should return the sorted list.\n\n# Example\n\n# Input: [1,2,3,1,1,3,4]\n# Output: [1,1,1,3,3,4,2]\n\n# Note\n\n# 1 <= elements.length <= 10^5\n# 1 <= elements[i] <= 10^7\n# tuples is an array of length 2.\n# tuples[i][0] is the first element of tuples.\n# tuples[i][1] is the second element of tuples.\n\n\nclass Solution:\n    def sortList(self, nodes):\n        \"\"\"\n        :type nodes: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nodes) == 0:\n            return []\n        else:\n            index = 0\n            while index < len(nodes):\n                if nodes[index][0] == nodes[index + 1][0]:\n                    nodes[index][1], nodes[index + 1][1] = nodes[index + 1][1], nodes[index][1]\n                    nodes[index + 1], nodes[index] = nodes[index], nodes[index + 1]\n                    index += 2\n                else:\n                    index += 1\n            return nodes\n\n\n# Time:  O(n*2^n)\n# Space: O(n)\n#\n# 2ms 100%\nclass Solution2:\n    def sortList(self, nodes):\n        \"\"\"\n        :type nodes: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nodes) == 0:\n            return []\n        else:\n            index = 0\n            while index < len(nodes):\n                if nodes[index][0] == nodes[index + 1][0]:\n                    nodes[index][1], nodes[index + 1][1] = nodes[index + 1][1], nodes[index][1]\n                    nodes[index + 1], nodes[index] = nodes[index], nodes[index + 1]\n                    index += 2\n                else:\n                    index += 1\n            return nodes\n\n# Time:  O(n*2^n"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "import time\n\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            j = i\n            while j < len(nums):\n                if nums[j][0] < nums[i][0]:\n                    nums[i], nums[j] = nums[j], nums[i]\n                    j += 1\n                else:\n                    break\n            i += 1"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "import sys\nimport random\n\n\"\"\"\nExample 1:\n\nInput: [3, 2, 1]\nOutput: [1, 2, 3]\nExplanation: [1, 1, 2] is the only possible sorting of the input list.\n\nExample 2:\n\nInput: [1, 3, 5, 2]\nOutput: [1, 2, 3, 5]\nExplanation: [1, 1, 2, 2, 3, 3, 5] is the only possible sorting of the input list.\n\nExample 3:\n\nInput: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nOutput: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nExplanation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] is the only possible sorting of the input list.\n\"\"\"\n\n\ndef sort_list(lst):\n    # write your code here\n    if len(lst) < 2:\n        return lst\n\n    return_list = []\n    random.shuffle(lst)\n    for i in lst:\n        return_list.append(i)\n\n    return return_list\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    lst = []\n    for i in range(n):\n        lst.append(int(sys.stdin.readline()))\n\n    print sort_list(lst)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        cur = head\n        while cur.next:\n            if cur.next.val == cur.val:\n                while cur.next.val == cur.val:\n                    cur = cur.next\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# sort_list(list)\n# Returns a sorted version of the input list.\n\n# Example\n# >>> sort_list([2, 1, 5, 6, 3])\n# [1, 2, 3, 5, 6]\n\ndef sort_list(list_):\n    result = []\n    for i in range(len(list_)):\n        for j in range(len(list_)):\n            if list_[j][0] < list_[i][0]:\n                result.append(list_[j])\n                list_[j] = list_[i]\n                list_[i] = list_[j]\n                break\n    return result\n\n# Test\n# >>> sort_list([2, 1, 5, 6, 3])\n# [1, 2, 3, 5, 6]\n\nif __name__ == '__main__':\n    print(sort_list([2, 1, 5, 6, 3]))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Example\n#\n# Given [1, 2, 3, 4, 5, 6, 7],\n#\n# Your function should return [1, 2, 3, 4, 5, 6, 7].\n#\n# Note:\n#\n# The given list is already sorted in ascending order.\n#\n# Company Tags: Google, Bloomberg, Facebook\n# Tags: Sort, Heap\n# Similar Problems: (M) Sort List By Frequency\n#\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        root = TreeNode(head.val)\n        curr = root\n        while head:\n            curr.left = TreeNode(head.val)\n            head = head.next\n            curr = curr.left\n        head = root.left\n        while head:\n            next = head.right\n            head.right = curr\n            curr = head\n            head = next\n        return root.left"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "from collections import namedtuple\n\n# Definition for a tuple\nTuple = namedtuple('Tuple', 'a b')\n\nclass Solution:\n    def sortTuple(self, tuples: '[[int]]') -> '[[int]]':\n        # write your code here\n        if not tuples:\n            return tuples\n        tuples.sort(key=lambda x: x[0])\n        return tuples"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "import unittest\nfrom heapq import nlargest\nfrom heapq import nsmallest\n\nclass Solution(object):\n    def sortTuples(self, tuples):\n        \"\"\"\n        :type tuples: List[tuple]\n        :rtype: List[tuple]\n        \"\"\"\n        sorted_tuples = []\n        for tup in tuples:\n            heapq_sorted_tuples = sorted(tup, key=lambda x: x[0])\n            sorted_tuples.extend(heapq_sorted_tuples)\n        return sorted_tuples\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/sort-tuple/solution/\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public List<Tuple> sortTuples(List<Tuple> tuples) {\n        List<Tuple> ans = new ArrayList<>();\n        for (Tuple tup : tuples) {\n            heapq(tup, (x, y) -> x[0] - y[0]);\n            ans.add(tup);\n        }\n        return ans;\n    }\n}\n\n# BFS\n# 1ms 100%\nclass Solution {\n    public List<Tuple> sortTuples(List<Tuple> tuples) {\n        List<Tuple> ans = new ArrayList<>();\n        for (Tuple tup : tuples) {\n            heapq(tup, (x, y) -> x[0] - y[0]);\n            ans.add(tup);\n        }\n        return ans;\n    }\n}\n'''"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# Example\n# Given the list [1, 2, 3, 4],\n# The function should return [1, 4, 2, 3].\n# Note:\n# You may assume all elements in the given list are unique.\n# Example 2:\n# Given the list [1, 1, 2, 2],\n# The function should return [1, 1, 2, 2].\n# Example 3:\n# Given the list [1, 3, 2, 2, 5],\n# The function should return [1, 2, 2, 3, 5].\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sortList(self, nodes):\n        \"\"\"\n        :type nodes: List[TreeNode]\n        :rtype: void Do not return anything, modify nodes in-place instead.\n        \"\"\"\n        if not nodes:\n            return\n\n        for i in xrange(len(nodes) - 1):\n            if not nodes[i].right:\n                # left most node\n                self.swap(nodes, i, 0)\n                return\n\n            if not nodes[i].left:\n                # right most node\n                self.swap(nodes, i, len(nodes) - 1)\n                return\n\n            # find the first node\n            j = i\n\n            while j >= 0 and nodes[j].val > nodes[i].val:\n                j -= 1\n\n            # i is the first node\n            self.swap(nodes, i, j + 1)\n\n    def swap(self, nodes, i, j):\n        tmp = nodes[i]\n        nodes[i] = nodes[j]\n        nodes[j] = tmp"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        p = head\n        while p and p.next:\n            if p.next.next and p.next.next.next:\n                n = p.next\n                while n.next:\n                    if n.next.next.next and n.next.next.next.next:\n                        n = n.next.next\n                    else:\n                        break\n                if n.next and n.next.next and n.next.next.next:\n                    n = n.next.next\n                p.next = n.next\n                n.next = p\n            else:\n                p = p.next\n        return head"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/sort-list/discuss/93529/O(n)\n\nfrom collections import defaultdict\nimport time\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        dic = defaultdict(list)\n        curr = head\n        while curr:\n            dic[curr.val].append(curr)\n            curr = curr.next\n\n        pairs = [v for v in dic.items()]\n        pairs.sort(key=lambda x: x[1])\n\n        res = head\n        for i in range(len(pairs)):\n            res = pairs[i][1][0]\n            pairs[i][1][0] = pairs[i][1][1]\n            pairs[i][1][1] = res\n\n        return res\n\nclass Solution2(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n\n        dic = defaultdict(list)\n        curr = head\n        while curr:\n            dic[curr.val].append(curr)\n            curr = curr.next\n\n        pairs = [v for v in dic.items()]\n        pairs.sort(key=lambda x: x[1])\n\n        res = head\n        for i in range(len(pairs)):\n            curr = pairs[i][1][0]\n            pairs[i][1][0] = pairs[i][1][1]\n            pairs[i][1][1] = curr\n            res = pairs[i][1][0]\n\n        return res\n\nif __name__ == '__main__':\n    start_time = time.time()\n    s = Solution()\n    s.sortList(ListNode(1, ListNode(2, ListNode(3, None))))\n    print(time."
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import unittest\n\n\n# Your sorting function should return the sorted list.\n# The input is a list of tuples.\ndef sort_tuples(tuples):\n    return sorted(tuples, key=lambda x: x[0])\n\n\nclass TestSortTuples(unittest.TestCase):\n\n    def test_sort_tuples(self):\n        tuples = [(1, 2, 3), (3, 4, 5), (5, 6, 7)]\n        sorted_tuples = sort_tuples(tuples)\n        self.assertEqual(sorted_tuples, [(1, 2, 3), (3, 4, 5), (5, 6, 7)])\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from collections import OrderedDict\n\ndef sort_by_first_element(my_list):\n    \"\"\"\n    :type my_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # my_list is sorted\n    my_list.sort(key=lambda tup: tup[0])\n    # my_list is sorted in the increasing order\n    return my_list\n\n\ndef sort_by_first_element_1(my_list):\n    \"\"\"\n    :type my_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # my_list is sorted\n    my_list.sort(key=lambda tup: tup[0], reverse=True)\n    # my_list is sorted in the increasing order\n    return my_list\n\n\ndef sort_by_first_element_2(my_list):\n    \"\"\"\n    :type my_list: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    # my_list is sorted\n    my_list.sort(key=lambda tup: tup[0], reverse=True)\n    # my_list is sorted in the increasing order\n    return my_list\n\n\nif __name__ == \"__main__\":\n    # test cases\n    my_list = [('a', 1), ('b', 2), ('c', 3)]\n    print(sort_by_first_element(my_list))\n    print(sort_by_first_element_1(my_list))\n    print(sort_by_first_element_2(my_list))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "import random\nimport unittest\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        p, q = head, head.next\n        while p.next and p.next.next:\n            if p.next.val < q.val:\n                p = p.next\n            else:\n                q = q.next\n        \n        p.next = q.next\n        return self.sortList(head)\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/sort-list-by-frequency/solution/\n\n# 1ms 100%\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next!= null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow.val < fast.val) {\n                prev.next = slow.next;\n                slow.next = fast;\n                fast.next = slow;\n                prev = slow;\n            }\n        }\n        return dummy.next;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next!= null) {\n            slow = slow.next;\n            fast"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Your sorting function will be called as the main() function.\n\n# Note: The length of all elements is less than 150.\n# 0 <= First element <= 100\n# 1 <= Second element <= 100\n# 1 <= Third element <= 100\n# 1 <= Fourth element <= 100\n# 1 <= Fifth element <= 100\n# 1 <= Sixth element <= 100\n# 1 <= Seventh element <= 100\n# 1 <= Eighth element <= 100\n# 1 <= Ninth element <= 100\n# 1 <= Tenth element <= 100\n# 1 <= Eleventh element <= 100\n# 1 <= Twelfth element <= 100\n# 1 <= Thirteenth element <= 100\n# 1 <= Fourteenth element <= 100\n# 1 <= Fifteenth element <= 100\n# 1 <= Sixteenth element <= 100\n# 1 <= Seventeenth element <= 100\n# 1 <= Eighteenth element <= 100\n# 1 <= Nineteenth element <= 100\n\nclass Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Sort in-place\n        # self.sortColors_recursive(nums)\n\n        # Sort in-place\n        # self.sortColors_iterative(nums)\n\n    def sortColors_iterative(self, nums):\n        for i in range(len(nums)):\n            # Set the first element to 0\n            if nums[i] == 0:\n                # Set the first element to 1\n                nums[i] = 1\n                # Set the first element to 0\n                nums[i] = 0\n                # Set the first element to 1\n                nums[i] = 1\n\n    def sortColors_recursive(self, nums):\n        def sort(i, j):\n            if i < j:\n                if nums[i] == 0:\n                    # Set the first element to 1\n                    nums[i] = 1\n                    # Set the first element to 0\n                    nums[i] = 0\n                    # Set the first element to 1\n                    nums[i] = 1\n                    sort(i, j)\n                elif nums[j] == 0:\n                    # Set"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# Your sorting function will be called as the following:\n# function(some_list, key_function)\n# where some_list is a list of numbers and key_function is a function that takes one argument and returns a single number.\n\n# Hint:\n# Use a tuple to store the first element of the tuple.\n\ndef sort(some_list, key_function):\n\t# write your code here\n\ttuple_list = []\n\tfor i in range(len(some_list)):\n\t\ttuple_list.append((key_function(some_list[i]), i))\n\ttuple_list.sort()\n\treturn [t[1] for t in tuple_list]\n\ndef test_sort():\n\tassert sort([1,3,2,4,5,6], lambda x:x) == [1,2,3,4,5,6]\n\ndef test_sort_2():\n\tassert sort([1,1,1,1,1,1], lambda x:x) == [1,1,1,1,1,1]\n\ndef test_sort_3():\n\tassert sort([1,2,3,4,5,6], lambda x:x) == [1,2,3,4,5,6]\n\ndef test_sort_4():\n\tassert sort([1,1,1,1,1,1], lambda x:x) == [1,1,1,1,1,1]\n\ndef test_sort_5():\n\tassert sort([1,2,3,4,5,6], lambda x:x) == [1,2,3,4,5,6]\n\ndef test_sort_6():\n\tassert sort([1,2,3,4,5,6], lambda x:x) == [1,2,3,4,5,6]\n\ndef test_sort_7():\n\tassert sort([1,2,3,4,5,6], lambda x:x) == [1,2,3,4,5,6]\n\ndef test_sort_8():\n\tassert sort([1,2,3,4,5,6], lambda x:x) == [1,2,3,4"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from collections import namedtuple\n\ndef sort_by_occurrence(lst):\n    \"\"\"\n    :type lst: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return sorted(lst, key=lambda tup: tup[0])\n\n# Your Solution Here\n# Your code here!\n\ndef sort_by_occurrence2(lst):\n    \"\"\"\n    :type lst: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return sorted(lst, key=lambda tup: tup[0], reverse=True)\n\n# Your Solution Here\n# Your code here!\n\ndef sort_by_occurrence3(lst):\n    \"\"\"\n    :type lst: List[tuple]\n    :rtype: List[tuple]\n    \"\"\"\n    return sorted(lst, key=lambda tup: tup[0], reverse=True, key=lambda tup: tup[1])"
    }
  ]
}