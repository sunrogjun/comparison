{
  "timestamp": "2025-09-14T20:02:06.084403",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 359,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def sort_by_float(tuple_to_sort):\n    \"\"\"\n    :type tuple_to_sort: List[Tuple[int, float]]\n    :rtype: List[Tuple[int, float]]\n    \"\"\"\n    tuple_to_sort = sorted(tuple_to_sort, key=lambda x: x[1])\n    return tuple_to_sort\n\nif __name__ == '__main__':\n    tuple_to_sort = (2, 10.1)\n    tuple_to_sort = (1, 2.1)\n    tuple_to_sort = (1, 2.2)\n    tuple_to_sort = (2, 2.1)\n    tuple_to_sort = (2, 2.2)\n    tuple_to_sort = (3, 3.1)\n    tuple_to_sort = (3, 3.2)\n    tuple_to_sort = (4, 4.1)\n    tuple_to_sort = (4, 4.2)\n    tuple_to_sort = (5, 5.1)\n    tuple_to_sort = (5, 5.2)\n    tuple_to_sort = (6, 6.1)\n    tuple_to_sort = (6, 6.2)\n    tuple_to_sort = (7, 7.1)\n    tuple_to_sort = (7, 7.2)\n    tuple_to_sort = (8, 8.1)\n    tuple_to_sort = (8, 8.2)\n    tuple_to_sort = (9, 9.1)\n    tuple_to_sort = (9, 9.2)\n    tuple_to_sort = (10, 10.1)\n    tuple_to_sort = (10, 10.2)\n    tuple_to_sort = (11, 11.1)\n    tuple_to_sort = (11, 11.2)\n    tuple_to_sort = (12, 12.1)\n    tuple_to_sort = (12, 12.2)\n    tuple_to_sort = ("
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sorting-tuple/problem\n\n# Time complexity: O(n^2)\n# Space complexity: O(1)\n\nfrom collections import namedtuple\n\n\nclass Tuple(namedtuple(\"Tuple\", \"x y\")):\n    \"\"\"\n    Tuple class.\n    \"\"\"\n\n    def __lt__(self, other):\n        \"\"\"\n        Less-than operator.\n        \"\"\"\n        return self.x < other.x\n\n    def __le__(self, other):\n        \"\"\"\n        Less-or-equal operator.\n        \"\"\"\n        return self.x <= other.x\n\n    def __gt__(self, other):\n        \"\"\"\n        Greater-than operator.\n        \"\"\"\n        return self.x > other.x\n\n    def __ge__(self, other):\n        \"\"\"\n        Greater-or-equal operator.\n        \"\"\"\n        return self.x >= other.x\n\n    def __eq__(self, other):\n        \"\"\"\n        Equality operator.\n        \"\"\"\n        return self.x == other.x\n\n    def __ne__(self, other):\n        \"\"\"\n        Inequality operator.\n        \"\"\"\n        return self.x!= other.x\n\n    def __hash__(self):\n        \"\"\"\n        Hash operator.\n        \"\"\"\n        return hash(self.x)\n\n\n# Your Tuple object will be instantiated and called as such:\n# obj = Solution(iterable)\n# param_1 = obj.sort(iterable)\n\n# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __le__(self, other):\n        return self.x <= other.x\n\n    def __gt__(self, other):\n        return self.x > other.x\n\n    def __ge__(self, other):\n        return self.x >= other.x\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n    def __ne__(self"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def sort_tuple_by_float(tuple_obj):\n    \"\"\"\n    >>> sort_tuple_by_float((1, 3.0, 'c', 'a', 'b'))\n    (1, 'a', 'b', 3.0, 'c')\n    \"\"\"\n    return sorted(tuple_obj, key=lambda x: x[1])\n\ndef sort_tuple_by_float_reverse(tuple_obj):\n    \"\"\"\n    >>> sort_tuple_by_float_reverse((1, 3.0, 'c', 'a', 'b'))\n    (3.0, 'c', 'b', 'a', 1)\n    \"\"\"\n    return sorted(tuple_obj, key=lambda x: x[1], reverse=True)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/sort-a-tuple-by-its-float-element/\n\n# Definition for a tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def sort(self, a):\n        \"\"\"\n        :type a: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        b = []\n        for i in a:\n            b.append(i)\n        b.sort()\n        return b"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution:\n    def sort(self, tupleList):\n        \"\"\"\n        :type tupleList: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        tupleList.sort()\n        return tupleList"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "#!/usr/bin/python\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# https://www.hackerrank.com/challenges/tuple-sort/problem\n\nfrom itertools import tee, islice\n\ndef sort_tuple(t):\n    return sorted(t, key=lambda x: x[0])\n\ndef sort_tuple_by_float(t):\n    return sorted(t, key=lambda x: x[1])\n\ndef sort_tuple_by_element(t):\n    return sorted(t, key=lambda x: x[2])\n\ndef sort_tuple_by_element_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[0]))\n\ndef sort_tuple_by_element_and_float_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[1], x[0]))\n\ndef sort_tuple_by_element_and_float_and_float_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[1], x[0], x[3]))\n\ndef sort_tuple_by_element_and_float_and_float_and_float_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[1], x[0], x[3], x[4]))\n\ndef sort_tuple_by_element_and_float_and_float_and_float_and_float_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[1], x[0], x[3], x[4], x[5]))\n\ndef sort_tuple_by_element_and_float_and_float_and_float_and_float_and_float_and_float(t):\n    return sorted(t, key=lambda x: (x[2], x[1], x[0], x[3], x[4], x[5], x[6]))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def sort(tuple_list):\n    \"\"\"\n    sort(tuple_list) -> None\n    \n    Sort a tuple list by its float element.\n    \"\"\"\n    \n    # Write your code here\n    \n    # Test case\n    tuple_list = (3.0, 1.0, 2.0)\n    tuple_list = (3.0, 2.0, 1.0)\n    tuple_list = (2.0, 3.0, 1.0)\n    tuple_list = (1.0, 2.0, 3.0)\n    tuple_list = (1.0, 1.0, 2.0)\n    \n    # Output\n    for i in range(len(tuple_list)):\n        print tuple_list[i]\n    \n    return\n\n\nif __name__ == '__main__':\n    sort(tuple_list)"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void sort(vector<float>& nums) {\n        if (nums.size() < 2) {\n            return;\n        }\n        sort(nums.begin(), nums.end());\n        float temp;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] > nums[i + 1]) {\n                temp = nums[i];\n                nums[i] = nums[i + 1];\n                nums[i + 1] = temp;\n            }\n        }\n    }\n};\n\nint main(void)\n{\n    vector<float> nums = {5.0, 1.0, 6.0, 3.0, 7.0, 4.0, 8.0, 2.0};\n    Solution s;\n    s.sort(nums);\n    for (auto n : nums) {\n        cout << n << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    def sort(self, A):\n        \"\"\"\n        :type A: List[Tuple[float, int]]\n        :rtype: None Do not return anything, modify A in-place instead.\n        \"\"\"\n        \n        A.sort()\n        \n        for i in range(1, len(A)):\n            if A[i-1][0] > A[i][0]:\n                A[i-1], A[i] = A[i], A[i-1]"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    Sort a tuple by the float element.\n\n    Input: A tuple of numbers.\n    Output: A tuple of numbers sorted by the float element.\n\n    Example:\n        >>> sort_tuple_by_float((1, 2, 3))\n        (1, 2, 3)\n        >>> sort_tuple_by_float((1, 2.3, 3))\n        (1, 2.3, 3)\n        >>> sort_tuple_by_float((1, 2.2, 3))\n        (1, 2.2, 3)\n        >>> sort_tuple_by_float((1, 3, 2.2))\n        (1, 3, 2.2)\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda x: x[1])\n\n\ndef sort_tuple_by_float_recursive(tuple_to_sort):\n    \"\"\"\n    Sort a tuple by the float element.\n\n    Input: A tuple of numbers.\n    Output: A tuple of numbers sorted by the float element.\n\n    Example:\n        >>> sort_tuple_by_float_recursive((1, 2, 3))\n        (1, 2, 3)\n        >>> sort_tuple_by_float_recursive((1, 2.3, 3))\n        (1, 2.3, 3)\n        >>> sort_tuple_by_float_recursive((1, 2.2, 3))\n        (1, 2.2, 3)\n        >>> sort_tuple_by_float_recursive((1, 3, 2.2))\n        (1, 3, 2.2)\n    \"\"\"\n    if len(tuple_to_sort) == 1:\n        return tuple_to_sort\n    else:\n        return sort_tuple_by_float_recursive(tuple_to_sort[:len(tuple_to_sort) // 2]) + \\\n               sort_tuple_by_float_recursive(tuple_to_sort[len(tuple_to_sort) // 2:])\n\n\nif __name__ == '__main__':\n    import"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in xrange(len(nums)):\n            for j in xrange(i, len(nums)):\n                if nums[i].x < nums[j].x:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return\n\nnums = [Tuple(3), Tuple(1), Tuple(2), Tuple(4), Tuple(6)]\ns = Solution()\ns.sort(nums)\nprint nums"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'float_element')\n\ndef sort_tuples(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(Tuple(t.float_element, t.float_element))\n    return sorted(result, key=lambda t: t.float_element)\n\ndef sort_tuples_2(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(Tuple(t.float_element, t.float_element))\n    return sorted(result, key=lambda t: t.float_element)\n\ndef sort_tuples_3(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(Tuple(t.float_element, t.float_element))\n    return sorted(result, key=lambda t: t.float_element)\n\ndef sort_tuples_4(tuples):\n    \"\"\"\n    :type tuples: List[Tuple]\n    :rtype: List[Tuple]\n    \"\"\"\n    result = []\n    for t in tuples:\n        result.append(Tuple(t.float_element, t.float_element))\n    return sorted(result, key=lambda t: t.float_element)"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\nclass MyTuple(namedtuple('MyTuple', 'float1 float2 float3')):\n    @classmethod\n    def from_tuple(cls, t):\n        return cls(t[0], t[1], t[2])\n\ndef sort_tuples(tuples):\n    return sorted(tuples, key=lambda t: t.float1)\n\ndef main():\n    t = (1.0, 2.0, 3.0)\n    tuples = MyTuple.from_tuple(t)\n    print(sort_tuples(tuples))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# https://www.codewars.com/kata/54d9d9b6f3d8/train/python\n\nimport random\n\ndef sort(tupleList):\n    return sorted(tupleList, key=lambda x: x[1])\n\n# Test Cases\n\nprint(sort(['b', 'c', 'a', 'd']))\nprint(sort(['a', 'd', 'b', 'c']))\nprint(sort(['d', 'c', 'a', 'b']))\nprint(sort(['c', 'a', 'b', 'd']))\nprint(sort(['a', 'b', 'c', 'd']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']))\n\n# Your Code Here\n\n# Test Cases\n\nprint(sort(['b', 'c', 'a', 'd']))\nprint(sort(['a', 'd', 'b', 'c']))\nprint(sort(['d', 'c', 'a', 'b']))\nprint(sort(['c', 'a', 'b', 'd']))\nprint(sort(['a', 'b', 'c', 'd']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']))\nprint(sort(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']))\nprint(sort(['a', 'b', 'c"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class TupleSort(object):\n    \"\"\"\n    @param self: the object pointer\n    @param tuple: the input tuple\n    @return: the sorted tuple\n    \"\"\"\n    def __init__(self, tuple):\n        self.tuple = tuple\n\n    def sort(self):\n        \"\"\"\n        @param self: the object pointer\n        @return: the sorted tuple\n        \"\"\"\n        for i in range(len(self.tuple) - 1):\n            for j in range(i + 1, len(self.tuple)):\n                if self.tuple[i] > self.tuple[j]:\n                    self.tuple[i], self.tuple[j] = self.tuple[j], self.tuple[i]\n\n    def show(self):\n        \"\"\"\n        @param self: the object pointer\n        @return: the sorted tuple\n        \"\"\"\n        for i in range(len(self.tuple)):\n            print(self.tuple[i])\n\n\nif __name__ == '__main__':\n    tuple = (1.0, 1.0, 1.0)\n    tuple2 = (1.0, 2.0, 3.0)\n    tuple3 = (1.0, 2.0, 3.0, 4.0)\n    tuple4 = (1.0, 2.0, 3.0, 4.0, 5.0)\n    tuple5 = (1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\n    tuple6 = (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0)\n    tuple7 = (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0)\n    tuple8 = (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)\n    tuple9 = (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0,"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution:\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        nums.sort()\n        for i in xrange(len(nums)-1):\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print Solution().sort(nums)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def bubbleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if nums[j] < nums[i]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return\n\n\nif __name__ == \"__main__\":\n    print(Solution().bubbleSort([2, 1, 3, 4, 3, 2, 3, 5]))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "def sort_tuple_by_float(tuple_):\n    \"\"\"\n    >>> tuple_ = (3.0, 2.0, 1.0)\n    >>> sort_tuple_by_float(tuple_)\n    >>> tuple_\n    (1.0, 2.0, 3.0)\n    \"\"\"\n    return sorted(tuple_, key=lambda x: float(x))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        self.sort_helper(nums, 0, len(nums))\n        \n    def sort_helper(self, nums, start, end):\n        if start >= end:\n            return\n        \n        mid = (start + end) / 2\n        \n        # sort the two subsets\n        self.sort_helper(nums, start, mid)\n        self.sort_helper(nums, mid + 1, end)\n        \n        # merge the two sorted subsets\n        i = start\n        j = mid + 1\n        while i < mid and j < end:\n            if nums[i].num < nums[j].num:\n                nums[i + 1] = nums[i]\n                i += 1\n            else:\n                nums[i + 1] = nums[j]\n                j += 1\n        \n        nums[i + 1] = nums[mid]\n        \n        # swap the two subsets\n        tmp = nums[start]\n        nums[start] = nums[j - 1]\n        nums[j - 1] = tmp\n        \n        self.sort_helper(nums, start, j - 1)\n        self.sort_helper(nums, j, end)\n        \nif __name__ == '__main__':\n    s = Solution()\n    nums = [('2', 4), ('3', 5), ('1', 1), ('5', 3), ('4', 2)]\n    s.sort(nums)\n    for i in nums:\n        print(i)"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "def sort_tuple(tuple_to_sort):\n    \"\"\"\n    Sort a tuple of numbers.\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda t: t[0])"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "import unittest\n\ndef tuple_sort(tuple_list):\n    \"\"\"\n    Sort a list of tuples by the element at the second position.\n    \"\"\"\n    return sorted(tuple_list, key=lambda t: t[1])\n\n\nclass TestSort(unittest.TestCase):\n    def test_sort_empty(self):\n        tuple_list = []\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n    def test_sort_one(self):\n        tuple_list = [(1,)]\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n    def test_sort_two(self):\n        tuple_list = [(1, 2)]\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n    def test_sort_three(self):\n        tuple_list = [(1, 2, 3)]\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n    def test_sort_four(self):\n        tuple_list = [(1, 2, 3, 4)]\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n    def test_sort_five(self):\n        tuple_list = [(1, 2, 3, 4, 5)]\n        self.assertEqual(tuple_sort(tuple_list), tuple_list)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 22,
      "score": 9.0,
      "candidate": "def sort(a):\n    return sorted(a, key=lambda x: float(x[0]))\n\n# These \"asserts\" using only for self-checking and not necessary for auto-testing\nif __name__ == '__main__':\n    assert sort([(1, 3), (2, 1)]) == [(1, 3), (2, 1)], \"Example\"\n    assert sort([(2, 3), (1, 2)]) == [(1, 2), (2, 3)], \"Reverse Order\"\n    assert sort([(3, 2), (2, 1)]) == [(2, 1), (3, 2)], \"Reverse Order\"\n    assert sort([(3, 2), (1, 2)]) == [(1, 2), (3, 2)], \"Reverse Order\"\n    assert sort([(1, 3), (3, 1)]) == [(1, 3), (3, 1)], \"Reverse Order\"\n    assert sort([(1, 3), (1, 2)]) == [(1, 2), (1, 3)], \"Reverse Order\"\n    assert sort([(1, 3), (3, 1)]) == [(1, 3), (3, 1)], \"Reverse Order\"\n    assert sort([(1, 3), (3, 1)]) == [(1, 3), (3, 1)], \"Reverse Order\""
    },
    {
      "rank": 23,
      "score": 9.0,
      "candidate": "# -*- coding: utf-8 -*-\n\n# Coded by Amir El Bawab\n# Last Update: 28 December 2015\n\n\ndef sort_tuple_by_float(tuple_obj):\n    \"\"\"\n    Function that sorts a tuple by its float element.\n\n    :param tuple_obj: the tuple to be sorted\n    :return: the sorted tuple\n    \"\"\"\n\n    # Sort the tuple\n    tuple_obj.sort()\n\n    # Return the sorted tuple\n    return tuple_obj\n\n\nif __name__ == \"__main__\":\n\n    # Sample tuple\n    tuple_obj = (1.5, 2.5, 3.5, 4.5, 5.5)\n\n    # Sort the tuple\n    print(\"Sorted tuple:\")\n    print(sort_tuple_by_float(tuple_obj))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {tuple} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        if len(nums) == 0:\n            return\n        \n        if len(nums) == 1:\n            return\n        \n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            while i < j and nums[i] > nums[j]:\n                j -= 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n            while i < j and nums[i] < nums[j]:\n                i += 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n        \n        self.sort(nums[:i + 1])\n        self.sort(nums[i + 1:])"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "import random\n\ndef sort(tup):\n    \"\"\"\n    Sort a tuple by its float element.\n\n    :param tup: a tuple\n    :return: a sorted tuple\n    \"\"\"\n    return sorted(tup, key=lambda x: x[0])\n\n\ndef main():\n    \"\"\"\n    Test cases.\n    \"\"\"\n    tup = (3.1, 1.5, 2.5, 2.6)\n    print(sort(tup))\n    tup = (1.5, 3.1, 2.6, 2.5)\n    print(sort(tup))\n    tup = (3.1, 2.6, 1.5, 2.5)\n    print(sort(tup))\n    tup = (1.5, 2.6, 2.5, 3.1)\n    print(sort(tup))\n    tup = (1.5, 2.6, 2.5, 3.1, 2.5)\n    print(sort(tup))\n    tup = (1.5, 2.6, 2.5, 3.1, 2.5, 1.5)\n    print(sort(tup))\n    tup = (1.5, 2.6, 2.5, 3.1, 2.5, 1.5, 2.5)\n    print(sort(tup))\n    tup = (1.5, 2.6, 2.5, 3.1, 2.5, 1.5, 2.5, 2.5)\n    print(sort(tup))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "# https://oj.leetcode.com/problems/sort-a-tuple/\n# algorithm\n# Sort a tuple by its float element\n# Complexity: O(n*log(n))\n# Space: O(n)\n# http://www.programcreek.com/2012/12/leetcode-sort-tuple/\n\ndef sort(t):\n    if len(t) < 2:\n        return t\n    elif len(t) == 2:\n        return (t[0], t[1], t[0])\n    else:\n        return sort(t[:2]) + sort(t[2:])"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_list):\n    \"\"\"\n    Sort a tuple list by its float element.\n    \"\"\"\n    return sorted(tuple_list, key=lambda x: x[0])\n\nprint(sort_tuple([(4, 3.0), (2, 2.0), (1, 1.0)]))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def sort_by_float(a_tuple):\n    \"\"\"\n    :type a_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    return sorted(a_tuple, key=lambda x: x[1])\n\nif __name__ == '__main__':\n    assert sort_by_float((1, 2, 3)) == (1, 2, 3)\n    assert sort_by_float((3, 1, 2)) == (1, 2, 3)\n    assert sort_by_float((2, 3, 1)) == (1, 2, 3)\n    assert sort_by_float((3, 2, 1)) == (1, 2, 3)\n    assert sort_by_float((1, 3, 2)) == (1, 2, 3)\n    assert sort_by_float((2, 1, 3)) == (1, 2, 3)"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if len(nums) == 0:\n            return nums\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            while i < j and nums[i].y > nums[j].y:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n            while i < j and nums[i].y < nums[j].y:\n                i += 1\n            nums[i], nums[j] = nums[j], nums[i]\n        return nums"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_to_sort):\n    return tuple(sorted(tuple_to_sort))\n\nprint(sort_tuple((1, 2, 3)))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_to_sort):\n    return sorted(tuple_to_sort, key=lambda x: x[0])\n\ndef test_sort_tuple():\n    assert sort_tuple((2, 1, 3)) == ((2, 1, 3),)\n    assert sort_tuple((1, 3, 2)) == ((1, 3, 2),)\n    assert sort_tuple((3, 2, 1)) == ((3, 2, 1),)\n    assert sort_tuple((2, 3, 1)) == ((2, 3, 1),)\n    assert sort_tuple((1, 2, 3)) == ((1, 2, 3),)\n    assert sort_tuple((2, 1, 3)) == ((2, 1, 3),)\n    assert sort_tuple((3, 1, 2)) == ((3, 1, 2),)\n    assert sort_tuple((3, 2, 1)) == ((3, 2, 1),)\n    assert sort_tuple((1, 3, 2)) == ((1, 3, 2),)\n    assert sort_tuple((3, 1, 2)) == ((3, 1, 2),)\n\nif __name__ == \"__main__\":\n    test_sort_tuple()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def sort_by_float(tuple_to_sort):\n    \"\"\"\n    Sort the given tuple by its float element.\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda x: x[1])\n\nif __name__ == \"__main__\":\n    print(sort_by_float((1,2,3,4,5)))\n    print(sort_by_float((5,4,3,2,1)))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'x y')\n\ndef sort_tuple(tuple_list):\n    \"\"\"\n    :type tuple_list: list[Tuple]\n    :rtype: list[Tuple]\n    \"\"\"\n    tuple_list.sort(key=lambda x: x.y)\n    return tuple_list\n\ndef test_my_func():\n    tuple_list = [Tuple(x=1, y=2), Tuple(x=2, y=1)]\n    assert sort_tuple(tuple_list) == [Tuple(x=1, y=2), Tuple(x=2, y=1)]"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    sort_tuple_by_float(tuple_to_sort) -> None\n    \n    The tuple should have 3 elements.\n    \"\"\"\n    \n    tuple_sorted = sorted(tuple_to_sort, key=lambda x: x[2])\n    \n    for i in range(len(tuple_sorted)):\n        tuple_sorted[i] = tuple_sorted[i][0]\n    \n    return tuple_sorted"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def sort(tuple_list):\n    \"\"\"\n    Args:\n        tuple_list: a list of tuples.\n\n    Returns:\n        sorted_list: a sorted list of tuples.\n    \"\"\"\n    sorted_list = []\n    for i in range(len(tuple_list)):\n        for j in range(len(tuple_list)):\n            if tuple_list[j][0] <= tuple_list[i][0]:\n                sorted_list.append(tuple_list[j])\n    return sorted_list\n\n\ndef test_sort():\n    assert sort([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)]\n    assert sort([(1.2, 2), (3, 4), (5, 6)]) == [(1.2, 2), (3, 4), (5, 6)]\n    assert sort([(1, 2.1), (3, 4), (5, 6)]) == [(1, 2.1), (3, 4), (5, 6)]\n    assert sort([(1, 2), (2.1, 3), (4, 5)]) == [(1, 2), (2.1, 3), (4, 5)]\n\n\nif __name__ == '__main__':\n    test_sort()"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_list):\n    \"\"\"\n    Sorting a tuple by its float element.\n\n    >>> sort_tuple([(1.0, 3), (2.0, 1), (0.5, 4)])\n    [(0.5, 4), (1.0, 3), (2.0, 1)]\n    \"\"\"\n    return sorted(tuple_list, key=lambda x: x[0])\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution(object):\n    def sort(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        if not tuples:\n            return tuples\n        pairs = []\n        for t in tuples:\n            pairs.append((t, t))\n        pairs.sort()\n        for i in range(len(pairs) - 1):\n            pairs[i], pairs[i + 1] = pairs[i + 1], pairs[i]\n        return [pairs[0]] + [p for p in pairs[1:] if p[1] > p[0]]"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_to_sort):\n    \"\"\"\n    >>> sort_tuple((3.0, 2.0, 1.0))\n    (1.0, 2.0, 3.0)\n    >>> sort_tuple((1.0, 2.0, 3.0))\n    (1.0, 2.0, 3.0)\n    >>> sort_tuple((3.0, 2.0, 1.0, 2.0, 3.0))\n    (1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0)\n    >>> sort_tuple((1.0, 3.0, 2.0, 1.0, 2.0, 3.0))\n    (1.0, 1.0, 2.0, 2.0, 3.0, 3.0)\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda x: float(x))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    Sort a tuple by the float element.\n    \"\"\"\n\n    return sorted(tuple_to_sort, key=lambda x: x[1])\n\ndef test_sort_tuple_by_float():\n    assert sort_tuple_by_float([(3, 7), (1, 4), (2, 3), (1, 5)]) == \\\n        [(1, 1), (1, 4), (2, 3), (3, 7)]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "import random\n\ndef sort_by_float(tuple_to_sort):\n    \"\"\"\n    :type tuple_to_sort: tuple\n    :rtype: None\n    \"\"\"\n    \n    for i in range(len(tuple_to_sort) - 1):\n        if tuple_to_sort[i] > tuple_to_sort[i+1]:\n            # swap the elements\n            temp = tuple_to_sort[i]\n            tuple_to_sort[i] = tuple_to_sort[i+1]\n            tuple_to_sort[i+1] = temp\n            \n    return tuple_to_sort\n\n\ndef main():\n    \"\"\"\n    Write a function to sort a tuple by its float element.\n    \"\"\"\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random.randint(0, 10) for i in range(10)]))\n    print(sort_by_float([random."
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        nums.sort()\n        return nums\n\ndef main():\n    nums = [Tuple(x) for x in range(1, 6)]\n    nums = Solution().sort(nums)\n    for x in nums:\n        print(x.x)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_list):\n    \"\"\"\n    Args:\n        tuple_list (list): A list of tuples.\n    Returns:\n        A list of tuples sorted by their float element.\n    \"\"\"\n    # Sort the list\n    return sorted(tuple_list, key=lambda x: float(x[1]))"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param: a tuple\n    @return: a tuple\n    \"\"\"\n    def sort(self, a):\n        if len(a) == 1:\n            return a\n        \n        b = a[:]\n        for i in range(len(a)):\n            for j in range(i, len(a)):\n                if a[j] < a[i]:\n                    b[i], b[j] = b[j], b[i]\n                    \n        return tuple(b)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.sort((1, 3, 4, 6, 2, 5))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def mySort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        self.quickSort(nums, 0, len(nums)-1)\n    \n    def quickSort(self, nums, start, end):\n        if start == end:\n            return\n        \n        pivot = self.partition(nums, start, end)\n        self.quickSort(nums, start, pivot-1)\n        self.quickSort(nums, pivot+1, end)\n    \n    def partition(self, nums, start, end):\n        pivot = start + (end-start)/2\n        \n        pivotVal = nums[pivot]\n        \n        i = start\n        j = end\n        \n        while i < j:\n            while nums[i] <= pivotVal:\n                i += 1\n            while nums[j] > pivotVal:\n                j -= 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n            \n        nums[i], nums[end] = nums[end], nums[i]\n        return i"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    >>> sort_tuple_by_float(('b', 2, 'a', 'c'))\n    ('a', 'b', 'c', 'd')\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda x: x[2])\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x)\n        \n        for i in range(1, len(nums)):\n            if nums[i-1] > nums[i]:\n                nums[i-1], nums[i] = nums[i], nums[i-1]\n        \n        return"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "import collections\n\ndef sort_tuple(t):\n    return collections.OrderedDict(sorted(t.items(), key=lambda t: t[1]))\n\nt = (2.0, 1.0, 3.0, 5.0)\nprint(sort_tuple(t))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        n = len(nums)\n        if n == 0:\n            return\n\n        if n < 2:\n            return nums\n\n        # sort by the first element\n        # then sort by the second element\n        # then sort by the third element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the third element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last element\n        # then sort by the first element\n        #...\n        # then sort by the last element\n        # then sort by the second element\n        #...\n        # then sort by the last"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param a a tuple\n    # @return nothing\n    def sort(self, a):\n        if len(a) < 2:\n            return\n        left = 0\n        right = len(a) - 1\n        while left <= right:\n            if a[left] > a[right]:\n                a[left], a[right] = a[right], a[left]\n                left += 1\n                right -= 1\n            else:\n                right -= 1\n        self.sort(a[:left + 1])\n        self.sort(a[right + 1:])\n        return"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "import random\n\ndef sort(t):\n    \"\"\"Sort a tuple t by its float element.\n\n    Example:\n    >>> t = (3.0, 2.0, 1.0)\n    >>> sort(t)\n    >>> t\n    (1.0, 2.0, 3.0)\n    \"\"\"\n    return sorted(t, key=lambda x: x[0])\n\ndef test():\n    \"\"\"Unit tests.\"\"\"\n    random.seed(1)\n    for i in range(100):\n        t = tuple(random.sample(range(1, 10), 3))\n        print t, sort(t)\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "import random\n\ndef sort_tuple_by_float(tuple_):\n    \"\"\"\n    Sort a tuple by its float element.\n    :param tuple_: tuple to sort\n    :return: tuple sorted\n    \"\"\"\n    return tuple(sorted(tuple_, key=lambda x: float(x)))\n\ndef test_sort_tuple_by_float():\n    \"\"\"\n    Test sort_tuple_by_float() function.\n    \"\"\"\n    tuple_ = (1, 3.4, 5, 7)\n    assert sort_tuple_by_float(tuple_) == tuple_\n\ndef test_sort_tuple_by_float_fail():\n    \"\"\"\n    Test sort_tuple_by_float() function fail.\n    \"\"\"\n    tuple_ = (1, 3.4, 5)\n    assert sort_tuple_by_float(tuple_) == tuple_\n\ndef test_random_sort_tuple_by_float():\n    \"\"\"\n    Test random_sort_tuple_by_float() function.\n    \"\"\"\n    tuple_ = (1, 3.4, 5, 7)\n    random_sort_tuple_by_float(tuple_)\n    assert sort_tuple_by_float(tuple_) == tuple_\n\ndef random_sort_tuple_by_float(tuple_):\n    \"\"\"\n    Randomly sort a tuple by its float element.\n    :param tuple_: tuple to sort\n    :return: tuple sorted\n    \"\"\"\n    random.shuffle(tuple_)\n    return tuple_\n\ndef test_random_sort_tuple_by_float():\n    \"\"\"\n    Test random_sort_tuple_by_float() function.\n    \"\"\"\n    tuple_ = (1, 3.4, 5, 7)\n    random_sort_tuple_by_float(tuple_)\n    assert sort_tuple_by_float(tuple_) == tuple_"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def sort_tuple(tup):\n    return sorted(tup, key=lambda x: x[0])\n\nif __name__ == \"__main__\":\n    tup = (2.0, 3.0, 1.0, 1.0)\n    print(sort_tuple(tup))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'a b c d')\n\n\ndef sort_tuple_by_float(tuple_tuple: Tuple) -> Tuple:\n    \"\"\"\n    :type tuple_tuple: Tuple\n    :rtype: Tuple\n    \"\"\"\n    return Tuple(\n        tuple_tuple.a,\n        tuple_tuple.b,\n        tuple_tuple.c,\n        tuple_tuple.d,\n    )\n\n\nif __name__ == '__main__':\n    tuple_tuple = Tuple(3.14, 4.56, 7.89, 1.23)\n    print(sort_tuple_by_float(tuple_tuple))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    >>> sort_tuple_by_float(('a', 1.0, 'b', 2.0))\n    ('b', 2.0, 'a', 1.0)\n    >>> sort_tuple_by_float((1.0, 2.0, 'a', 'b'))\n    ('b', 2.0, 'a', 1.0)\n    >>> sort_tuple_by_float(('a', 'b', 1.0, 2.0))\n    ('a', 1.0, 'b', 2.0)\n    \"\"\"\n    tuple_to_sort = tuple(tuple_to_sort)\n    return tuple(sorted(tuple_to_sort, key=lambda x: x[1]))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    :type tuple_to_sort: tuple\n    :rtype: tuple\n    \"\"\"\n    # write your code here\n    tuple_to_sort = sorted(tuple_to_sort, key=lambda x: float(x[0]))\n    return tuple_to_sort\n\n# test cases\ntuple_to_sort = (('a', 1), ('c', 2), ('b', 3), ('d', 4), ('e', 5), ('f', 6))\n\ntuple_to_sort_sorted = (('f', 6), ('c', 2), ('b', 3), ('d', 4), ('a', 1), ('e', 5))\n\ntuple_to_sort_reverse = (('e', 5), ('d', 4), ('c', 2), ('b', 3), ('f', 6), ('a', 1))\n\ntuple_to_sort_sorted_reverse = (('e', 5), ('a', 1), ('b', 3), ('d', 4), ('f', 6), ('c', 2))\n\ntuple_to_sort_sorted_reverse_reverse = (('e', 5), ('a', 1), ('b', 3), ('d', 4), ('f', 6), ('c', 2))\n\nprint(sort_tuple_by_float(tuple_to_sort))\nprint(sort_tuple_by_float(tuple_to_sort_sorted))\nprint(sort_tuple_by_float(tuple_to_sort_reverse))\nprint(sort_tuple_by_float(tuple_to_sort_sorted_reverse))\nprint(sort_tuple_by_float(tuple_to_sort_sorted_reverse_reverse))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_to_sort):\n    \"\"\"\n    >>> sort_tuple((1, 2, 3))\n    (1, 2, 3)\n    >>> sort_tuple((3, 2, 1))\n    (3, 2, 1)\n    >>> sort_tuple((1, 3, 2))\n    (1, 3, 2)\n    >>> sort_tuple((1.0, 2.0, 3.0))\n    (1.0, 2.0, 3.0)\n    >>> sort_tuple((2.0, 1.0, 3.0))\n    (2.0, 1.0, 3.0)\n    \"\"\"\n    return tuple(sorted(tuple_to_sort, key=lambda x: x))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "def sort_tuple(tuple_obj):\n    \"\"\"\n    >>> sort_tuple([2, 1, 3])\n    [1, 2, 3]\n    >>> sort_tuple([1, 1.1, 3])\n    [1.1, 1, 3]\n    >>> sort_tuple([1, 2.1, 3])\n    [2.1, 1, 3]\n    >>> sort_tuple([1.1, 2.1, 3])\n    [1.1, 2.1, 3]\n    \"\"\"\n    return sorted(tuple_obj, key=lambda x: float(x))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: The integer tuple\n    @return: The sorted list\n    \"\"\"\n    def sort(self, nums):\n        \"\"\"\n        @type nums: List[int]\n        @rtype: List[int]\n        \"\"\"\n        def compare(num1, num2):\n            return num2 - num1\n        nums.sort(compare)\n        return nums"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nA = namedtuple('A', 'x y')\nA(1, 2)\nA(1, 3)\nA(2, 1)\nA(3, 1)\n\ndef sort_tuple(tup):\n    \"\"\"\n    tuple sort\n    \"\"\"\n    return sorted(tup, key=lambda x: x[0])\n\nprint(sort_tuple(A(3, 1)))"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = (1,3,2,2,5)\n    sol.sort(nums)\n    print nums\n    nums = (5,4,3,2,1)\n    sol.sort(nums)\n    print nums"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param a, a tuple\n    # @return nothing\n    def sort(self, a):\n        if len(a) < 2:\n            return\n        b = a\n        a = []\n        for i in range(len(b)):\n            for j in range(i, len(b)):\n                if b[j][0] > b[i][0]:\n                    a.append(b[j])\n                    b[j] = b[i]\n                    b[i] = a[j]\n        self.sort(a)\n        self.sort(b)\n        return a + b\n\nif __name__ == '__main__':\n    a = Solution().sort([(1,2),(3,4)])\n    print(a)"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def sort_by_float(tuple_to_sort):\n    \"\"\"\n    >>> tuple_to_sort = (3.5, 2.3, 4.2, 2.0, 2.9)\n    >>> sort_by_float(tuple_to_sort)\n    (2.9, 2.0, 2.3, 2.5, 4.2)\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda x: x[0])\n\ndef main():\n    \"\"\"\n    Run unit tests if run from command line.\n    \"\"\"\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x)\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def sort(tup, sort_by_key=True):\n    \"\"\"\n    tup: a tuple\n    sort_by_key: whether the tuple contains a key\n    \"\"\"\n    if sort_by_key:\n        tup = sorted(tup, key=lambda x: x[0])\n    else:\n        tup = sorted(tup, key=lambda x: x[1])\n    return tup"
    },
    {
      "rank": 65,
      "score": 1.5,
      "candidate": "#!/usr/bin/env python\n\ndef sort_tuple_by_float(tup):\n    \"\"\"\n    tup - tuple\n    \"\"\"\n    if not isinstance(tup, tuple):\n        return tup\n    \n    return sorted(tup, key=lambda x: x[0], reverse=True)\n\ndef sort_tuple_by_float_2(tup):\n    \"\"\"\n    tup - tuple\n    \"\"\"\n    if not isinstance(tup, tuple):\n        return tup\n    \n    return sorted(tup, key=lambda x: x[1], reverse=True)\n\ndef sort_tuple_by_float_3(tup):\n    \"\"\"\n    tup - tuple\n    \"\"\"\n    if not isinstance(tup, tuple):\n        return tup\n    \n    return sorted(tup, key=lambda x: x[0], reverse=True)\n\nif __name__ == \"__main__\":\n    print sort_tuple_by_float_2((1, 2.3))\n    print sort_tuple_by_float_3((1, 2.3))"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x)"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "def sort(tuple_list):\n    \"\"\"\n    :type tuple_list: List[Tuple[int, float]]\n    :rtype: List[Tuple[int, float]]\n    \"\"\"\n    \n    for i in range(len(tuple_list)):\n        tuple_list[i] = tuple(sorted(tuple_list[i]))\n    return tuple_list\n\n\nif __name__ == '__main__':\n    tuple_list = [(1, 3), (2, 1), (3, 2), (4, 1)]\n    print(sort(tuple_list))"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sortByBits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: int(x))\n        nums.sort(key=lambda x: x)\n        return\n\n\nif __name__ == \"__main__\":\n    print(Solution().sortByBits([1, 2, 3, 4, 5]))"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums: return\n        if len(nums) == 1: return\n        nums.sort(key=lambda x: x)\n        nums.sort(key=lambda x: x, reverse=True)\n        nums.sort(key=lambda x: x, reverse=False)\n\ns = Solution()\ns.sort([1,3,2,5,7,4,9])"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from collections import namedtuple\nfrom typing import List\n\nTuple = namedtuple('Tuple', 'first second')\n\nclass Solution:\n    def sortTuple(self, tuples: List[Tuple]) -> None:\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x: x[1])\n        tuples.sort(key=lambda x: x[0])\n        tuples.sort(key=lambda x"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "def sort(tuple_):\n    \"\"\"\n    :param tuple_: a tuple\n    :return: a sorted tuple\n    \"\"\"\n    return tuple(sorted(tuple_))\n\nif __name__ == '__main__':\n    t = (3.1, 3.2, 3.3, 3.4, 3.5)\n    print(sort(t))\n    print(sort((3.1, 3.2, 3.3)))\n    print(sort((3.1, 3.2, 3.3, 3.4)))\n    print(sort((3.1, 3.2, 3.3, 3.4, 3.5)))\n    print(sort((3.1, 3.2, 3.3, 3.4, 3.5, 3.6)))\n    print(sort((3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7)))\n    print(sort((3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8)))"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/sort-a-tuple-by-its-float-element/discuss/372268/C++-Implementation-using-Python-and-Python-Sorting-Library\nclass Solution(object):\n    def sort(self, tup):\n        \"\"\"\n        :type tup: List[float]\n        :rtype: void Do not return anything, modify tup in-place instead.\n        \"\"\"\n        tup.sort(key=lambda x: x)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    tup = [1.1,2.3,3.4,4.5]\n    sol.sort(tup)\n    print(tup)"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\n# class Tuple(object):\n#     def __init__(self, x):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def sort_by_element(nums):\n            for i in xrange(len(nums)):\n                for j in xrange(i+1, len(nums)):\n                    if nums[i].x > nums[j].x:\n                        nums[i], nums[j] = nums[j], nums[i]\n        sort_by_element(nums)"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '<{}, {}>'.format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n# @include\ndef sort_tuple(tuple_t):\n    # Sort the tuple by the first element.\n    def sort_tuple_by_x(tuple_t):\n        return sorted(tuple_t, key=lambda t: t.x)\n\n    # Sort the tuple by the second element.\n    def sort_tuple_by_y(tuple_t):\n        return sorted(tuple_t, key=lambda t: t.y)\n\n    # Return the sorted tuple.\n    return sort_tuple_by_x(tuple_t) if (\n            isinstance(tuple_t, Tuple)) else sort_tuple_by_y(tuple_t)\n# @exclude\n\n\ndef main():\n    tuple_t = (1, 3)\n    # The following line should not compile.\n    # sort_tuple(tuple_t)\n    assert sort_tuple(tuple_t) == sort_tuple(Tuple(1, 3))\n    tuple_t = (1, 2, 3)\n    assert sort_tuple(tuple_t) == sort_tuple(Tuple(1, 2, 3))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(key=lambda x: x)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\n    sol.sort(nums)\n    print(nums)"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param a, a tuple\n    # @return nothing\n    def sort(self, a):\n        if not a: return\n\n        a.sort()\n        a.reverse()\n\n        for i in range(len(a) - 1):\n            if a[i][1] > a[i+1][1]:\n                a[i], a[i+1] = a[i+1], a[i]\n\nif __name__ == '__main__':\n    s = Solution()\n    s.sort([(1, 2), (2, 1)])\n    s.sort([(1, 2), (2, 1), (1, 1)])"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        # write your code here\n        n = len(nums)\n        if n == 1:\n            return\n        if n == 2:\n            if nums[0] > nums[1]:\n                nums[0], nums[1] = nums[1], nums[0]\n        elif n == 3:\n            if nums[0] > nums[1]:\n                nums[0], nums[1] = nums[1], nums[0]\n            if nums[1] > nums[2]:\n                nums[1], nums[2] = nums[2], nums[1]\n            if nums[0] > nums[1]:\n                nums[0], nums[1] = nums[1], nums[0]\n        else:\n            for i in range(n - 2):\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        for i in range(n - 1):\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "class Solution:\n    def sort(self, a):\n        \"\"\"\n        :type a: List[float]\n        :rtype: None Do not return anything, modify a in-place instead.\n        \"\"\"\n        # for a, b in zip(a, a[1:]):\n        #     if a > b:\n        #         a, b = b, a\n        # for a, b in zip(a, a[1:]):\n        #     if a > b:\n        #         a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a, b = b, a\n        #     a"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def compare(a, b):\n            if a == b:\n                return 0\n            if a > b:\n                return 1\n            else:\n                return -1\n\n        nums.sort(cmp=compare)\n\nif __name__ == '__main__':\n    assert Solution().sort([3.14, 1.0, 2.0]) == [1.0, 2.0, 3.14]\n    assert Solution().sort([0.0, 1.0, 2.0]) == [1.0, 2.0, 0.0]\n    assert Solution().sort([1.0, 2.0, 3.14]) == [1.0, 2.0, 3.14]\n    assert Solution().sort([3.14, 1.0, 2.0, 0.0]) == [1.0, 2.0, 3.14, 0.0]"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        return sorted(nums, key=lambda x: x.y)"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param num, a tuple\n    # @return nothing\n    def sort(self, num):\n        def cmp_fn(a, b):\n            if a[0] == b[0]:\n                return 0\n            if a[0] < b[0]:\n                return -1\n            return 1\n\n        return sorted(num, cmp=cmp_fn)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.sort([(1, 2), (3, 4)])"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def mySorted(self, mytuple):\n        \"\"\"\n        :type mytuple: List[int]\n        :rtype: void Do not return anything, modify mytuple in-place instead.\n        \"\"\"\n        \n        mytuple.sort()\n        \n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public void mySorted(List<Integer> mytuple) {\n        mytuple.sort((a, b) -> a - b);\n    }\n}\n\n# BFS\n# 1ms 100%\nclass Solution {\n    public void mySorted(List<Integer> mytuple) {\n        mytuple.sort((a, b) -> a - b);\n        for (int i = 0; i < mytuple.size(); i++) {\n            mytuple.set(i, mytuple.get(i) + mytuple.get(i + 1));\n        }\n    }\n}\n'''"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "import random\n\ndef sort(tuple_list):\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            if tuple_list[i][0] > tuple_list[j][0]:\n                tuple_list[i], tuple_list[j] = tuple_list[j], tuple_list[i]\n    return tuple_list\n\ndef test_sort(tuple_list):\n    assert sort(tuple_list) == tuple_list\n\ndef test_sort_empty_list(tuple_list):\n    tuple_list = []\n    assert sort(tuple_list) == tuple_list\n\ndef test_sort_random_list(tuple_list):\n    random.shuffle(tuple_list)\n    assert sort(tuple_list) == tuple_list\n\nif __name__ == '__main__':\n    test_sort([(0, 0), (0, 0), (0, 0)])\n    test_sort_empty_list([(0, 0), (0, 0), (0, 0)])\n    test_sort_random_list([(0, 0), (0, 0), (0, 0)])"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[float]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        if n == 1:\n            return nums[0],\n\n        if n % 2 == 0:\n            mid = (n / 2) + 1\n            # left = self.sort(nums[:mid])\n            # right = self.sort(nums[mid:])\n            left = self.sort(nums[:mid])\n            right = self.sort(nums[mid:])\n            nums[:mid] = left + right\n        else:\n            mid = (n / 2) + 1\n            left = self.sort(nums[:mid])\n            right = self.sort(nums[mid:])\n            nums[:mid] = left + right\n            right = self.sort(nums[mid:])\n            nums[mid:] = right\n\n    # @param nums, a list of integer\n    # @return nothing\n    def sort(self, nums):\n        n = len(nums)\n        if n == 0:\n            return\n        if n == 1:\n            return nums[0],\n\n        if n % 2 == 0:\n            mid = (n / 2) + 1\n            # left = self.sort(nums[:mid])\n            # right = self.sort(nums[mid:])\n            left = self.sort(nums[:mid])\n            right = self.sort(nums[mid:])\n            nums[:mid] = left + right\n        else:\n            mid = (n / 2) + 1\n            left = self.sort(nums[:mid])\n            right = self.sort(nums[mid:])\n            nums[:mid] = left + right\n            right = self.sort(nums[mid:])\n            nums[mid:] = right"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def sort(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: None Do not return anything, modify tuples in-place instead.\n        \"\"\"\n        for i in range(len(tuples)):\n            max_index = i\n            for j in range(i, len(tuples)):\n                if tuples[j].x > tuples[max_index].x:\n                    max_index = j\n            if i!= max_index:\n                tuples[i], tuples[max_index] = tuples[max_index], tuples[i]\n\n    def sort_tuple(self, tuple_):\n        max_index = len(tuple_) - 1\n        for i in range(len(tuple_)):\n            if tuple_[i] > tuple_[max_index]:\n                max_index = i\n        if tuple_[max_index] > tuple_[0]:\n            tuple_[0], tuple_[max_index] = tuple_[max_index], tuple_[0]\n        return tuple_\n\na = [Tuple(1), Tuple(2), Tuple(3), Tuple(4), Tuple(5), Tuple(6), Tuple(7)]\ns = Solution()\ns.sort(a)\n\nfor t in a:\n    print(t)"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param: A tuple\n    @return: The sorted tuple.\n    \"\"\"\n    def sort(self, a):\n        \"\"\"\n        @param: A tuple\n        @return: The sorted tuple.\n        \"\"\"\n        # write your code here\n        return tuple(sorted(a))\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    a = (1.0,2.0,3.0,4.0)\n    print solution.sort(a)"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[Tuple]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n\n        for i in range(n - 1):\n            if nums[i][0] > nums[i + 1][0]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n        for j in range(n - 2, -1, -1):\n            for i in range(j + 1, n):\n                if nums[i][0] > nums[j][0]:\n                    nums[i], nums[j] = nums[j], nums[i]"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    tuple_to_sort.sort(key=lambda item: float(item[0]))\n\nprint(sort_tuple_by_float([(1, 2), (2, 3), (3, 1)]))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sort(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return\n\n        # sort the element\n        def cmp(a, b):\n            if a[0] == b[0]:\n                return 0\n            if a[0] > b[0]:\n                return 1\n            return -1\n\n        # sort the element\n        nums.sort(cmp)\n        for i in range(n - 1):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nif __name__ == \"__main__\":\n    nums = [(-1.5, 0), (1.5, 1), (1, 1), (0, 0), (-1, -1)]\n    Solution().sort(nums)\n    for i in nums:\n        print(i)"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-sorting\n\ndef sort_tuple(tuple_to_sort):\n    \"\"\"\n    Sort the given tuple.\n\n    :param tuple_to_sort: A tuple to sort.\n    :return: The sorted tuple.\n    \"\"\"\n    # Sort the elements of the tuple.\n    return sorted(tuple_to_sort, key=lambda x: x[0])\n\nif __name__ == '__main__':\n    # Sample Input\n    # ((1, 2.1), (2, 3), (3, 2.1))\n    tuple_to_sort = ((1, 2.1), (2, 3), (3, 2.1))\n    # Sample Output\n    # ((1, 2.1), (2, 3), (3, 2.1))\n    print(sort_tuple(tuple_to_sort))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def sort_tuple(tuple_list):\n    \"\"\"\n    Sort a tuple list by its float element.\n    \"\"\"\n    return sorted(tuple_list, key=lambda t: t[0])\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert sort_tuple([(1.0, 2.0), (2.0, 3.0), (3.0, 1.0)]) == [\n        (3.0, 1.0), (2.0, 3.0), (1.0, 2.0)]\n    assert sort_tuple([(2.0, 1.0), (3.0, 1.0), (1.0, 3.0), (1.0, 2.0)]) == [\n        (1.0, 2.0), (1.0, 3.0), (2.0, 1.0), (3.0, 1.0)]\n    assert sort_tuple([(1.0, 2.0), (2.0, 3.0), (3.0, 1.0)]) == [\n        (1.0, 2.0), (2.0, 3.0), (3.0, 1.0)]\n    assert sort_tuple([(1.0, 2.0), (3.0, 1.0), (2.0, 3.0)]) == [\n        (3.0, 1.0), (2.0, 3.0), (1.0, 2.0)]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        nums.sort(key=lambda x: x)\n        nums.sort(key=lambda x: x, reverse=True)\n\n# Note:\n# 1. The following code is using a dict to store the result.\n# 2. The code is not the most efficient way to do this.\n# 3. There are many ways to do this. The below code is not the most efficient way.\n\nclass Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        nums.sort(reverse=True)"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "import random\n\ndef sort_by_float(tuples):\n    \"\"\"\n    Sort the given tuple by its float element.\n    tuples: a tuple of tuples to sort.\n    \"\"\"\n    return sorted(tuples, key=lambda t: t[0])\n\n\ndef test_sort_by_float():\n    tuples = [(0, 1.0), (2, 3.0), (4, 5.0)]\n    sort_by_float(tuples)\n    assert tuples == [(0, 1.0), (2, 3.0), (4, 5.0)]\n\ndef test_sort_by_float_2():\n    tuples = [(0, 1.0), (2, 3.0), (4, 5.0), (1, -1.0)]\n    sort_by_float(tuples)\n    assert tuples == [(0, 1.0), (2, 3.0), (4, 5.0), (1, -1.0)]\n\ndef test_sort_by_float_3():\n    tuples = [(0, 1.0), (2, 3.0), (4, 5.0), (1, -1.0), (0, -1.0)]\n    sort_by_float(tuples)\n    assert tuples == [(0, 1.0), (0, -1.0), (2, 3.0), (4, 5.0), (1, -1.0)]\n\ndef test_sort_by_float_4():\n    tuples = [(0, 1.0), (2, 3.0), (4, 5.0), (1, -1.0), (0, -1.0)]\n    sort_by_float(tuples)\n    assert tuples == [(0, 1.0), (0, -1.0), (2, 3.0), (4, 5.0), (1, -1.0)]\n\ndef test_sort_by_float_5():\n    tuples = [(0, 1.0), (2, 3.0), (4, 5.0), (1, -1.0), (0, -1.0)]\n    sort_by_float(tu"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def sort_helper(nums, start, end):\n            if start >= end:\n                return\n\n            mid = (start + end) / 2\n            if nums[mid] > nums[end]:\n                nums[mid], nums[end] = nums[end], nums[mid]\n            if nums[start] > nums[mid]:\n                nums[start], nums[mid] = nums[mid], nums[start]\n            sort_helper(nums, start, mid - 1)\n            sort_helper(nums, mid + 1, end)\n\n        sort_helper(nums, 0, len(nums) - 1)\n\n    def sort1(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def sort_helper(nums, start, end):\n            if start >= end:\n                return\n            mid = (start + end) / 2\n            if nums[mid] > nums[end]:\n                nums[mid], nums[end] = nums[end], nums[mid]\n            if nums[start] > nums[mid]:\n                nums[start], nums[mid] = nums[mid], nums[start]\n            sort_helper(nums, start, mid - 1)\n            sort_helper(nums, mid + 1, end)\n\n        sort_helper(nums, 0, len(nums) - 1)\n\nif __name__ == '__main__':\n    print(Solution().sort([]))\n    print(Solution().sort([3, 1, 4, 2]))\n    print(Solution().sort([-3, -2, -1, 0, 1, 2, 3]))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def sort_tuple(t):\n    \"\"\"\n    >>> sort_tuple((1.0, 2.0))\n    (1.0, 2.0)\n    >>> sort_tuple((2.0, 1.0))\n    (2.0, 1.0)\n    >>> sort_tuple((2.0, 2.0))\n    (2.0, 2.0)\n    >>> sort_tuple((3.0, 1.0))\n    (3.0, 1.0)\n    >>> sort_tuple((3.0, 2.0))\n    (3.0, 2.0)\n    \"\"\"\n    return t\n\ndef sort_tuple2(t):\n    \"\"\"\n    >>> sort_tuple2((1.0, 2.0))\n    (1.0, 2.0)\n    >>> sort_tuple2((2.0, 1.0))\n    (2.0, 1.0)\n    >>> sort_tuple2((2.0, 2.0))\n    (2.0, 2.0)\n    >>> sort_tuple2((3.0, 1.0))\n    (3.0, 1.0)\n    >>> sort_tuple2((3.0, 2.0))\n    (3.0, 2.0)\n    \"\"\"\n    return t\n\ndef sort_tuple3(t):\n    \"\"\"\n    >>> sort_tuple3((1.0, 2.0))\n    (1.0, 2.0)\n    >>> sort_tuple3((2.0, 1.0))\n    (2.0, 1.0)\n    >>> sort_tuple3((2.0, 2.0))\n    (2.0, 2.0)\n    >>> sort_tuple3((3.0, 1.0))\n    (3.0, 1.0)\n    >>> sort_tuple3((3.0, 2.0))\n    (3.0, 2.0)\n    \"\"\"\n    return t\n\ndef sort_tuple4(t):\n    \"\"\"\n    >>> sort_tuple4((1.0, 2.0))\n    (1."
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# https://oj.leetcode.com/problems/sort-a-tuple/\n# sort a tuple by its element.\n\nclass Solution:\n    # @param {Tuple[]} tuples\n    # @return {void} Do not return anything, modify tuples in-place instead.\n    def sort(self, tuples):\n        tuples.sort(key=lambda t: t[0])\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.sort([(2, 4), (1, 3), (2, 1)]))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def sort_tuple_by_float(tuple_to_sort):\n    \"\"\"\n    :type tuple_to_sort: tuple\n    :rtype: tuple\n    \"\"\"\n    return sorted(tuple_to_sort, key=lambda t: t[0])\n\n#Testing\n\ndef main():\n    \"\"\"\n    Write a test function to check your solution.\n    :return: 0 (passed test), 1 (failed test)\n    :rtype: int\n    \"\"\"\n    tuple_to_sort = (1, 4.5, 2.3, 3, 7, 5)\n    print(sort_tuple_by_float(tuple_to_sort))\n\n    return 0\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import unittest\n\ndef sort_tuple(tuple_list):\n    return tuple(sorted(tuple_list))\n\n\nclass TestSortTuple(unittest.TestCase):\n    def test_sort_tuple(self):\n        tuple_list = [(-2.0, -3.0), (-1.0, -2.0), (0.0, 1.0), (2.0, 3.0)]\n        self.assertEqual(sort_tuple(tuple_list), [-1.0, -2.0, -2.0, 0.0, 2.0, 3.0])"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/sort-a-tuple-by-element-of-it/\n\nclass Solution(object):\n    def sort(self, t):\n        \"\"\"\n        :type t: List[Tuple[float, float]]\n        :rtype: None Do not return anything, modify t in-place instead.\n        \"\"\"\n        if not t:\n            return\n\n        def sort(t, index):\n            if len(t) == 1:\n                return t\n\n            min_index = 0\n            min = t[0]\n\n            for i in range(1, len(t)):\n                if t[i] < min:\n                    min = t[i]\n                    min_index = i\n\n            t[index] = min\n            sort(t, min_index)\n\n            return t\n\n        sort(t, 0)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.sort([(1, 1), (2, 3), (5, 2), (3, 1)]))\n    print(sol.sort([(1, 2), (2, 1), (3, 1)]))\n    print(sol.sort([(1, 2), (3, 1), (2, 1)]))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-sort\n\nimport unittest\n\ndef tuple_sort(t):\n    \"\"\"\n    Sorts a tuple.\n    :param t: The tuple to sort.\n    :return: The sorted tuple.\n    \"\"\"\n    if len(t) < 2:\n        return t\n\n    for i in range(len(t)):\n        for j in range(i+1, len(t)):\n            if t[i] > t[j]:\n                t[i], t[j] = t[j], t[i]\n    return t\n\nclass MyTestCases(unittest.TestCase):\n    def test_tuple_sort_1(self):\n        t = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n        self.assertEqual(tuple_sort(t), (1, 2, 3, 4, 5, 6, 7, 8, 9))\n\n    def test_tuple_sort_2(self):\n        t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        self.assertEqual(tuple_sort(t), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n    def test_tuple_sort_3(self):\n        t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n        self.assertEqual(tuple_sort(t), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))\n\n    def test_tuple_sort_4(self):\n        t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\n        self.assertEqual(tuple_sort(t), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))\n\n    def test_tuple_sort_5(self):\n        t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)"
    }
  ]
}