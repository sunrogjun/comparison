{
  "timestamp": "2025-09-14T20:15:55.929434",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 390,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __iter__(self):\n        return iter(self.x)\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = []\n        self.ans_index = 0\n    def add(self, tuple1, tuple2):\n        for i in xrange(0, len(tuple1)):\n            self.ans.append(tuple1[i] + tuple2[i])\n    def add_index(self, tuple1, tuple2):\n        for i in xrange(0, len(tuple1)):\n            self.ans[self.ans_index] = tuple1[i] + tuple2[i]\n            self.ans_index += 1\n    def __str__(self):\n        return str(self.ans)\n\nif __name__ == '__main__':\n    t1 = Tuple([1, 2, 3])\n    t2 = Tuple([4, 5, 6])\n    s = Solution()\n    s.add(t1, t2)\n    print s\n    print s.ans\n    s.add_index(t1, t2)\n    print s\n    print s.ans"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# https://www.codewars.com/kata/54c6c0a70f8f0f7b9d0f7e/train/python\n\ndef tuple_add(a, b):\n    \"\"\"\n    :param a: tuple\n    :param b: tuple\n    :return: tuple\n    \"\"\"\n    return tuple(a[i] + b[i] for i in range(len(a)))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\n\ndef add_tuples(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples2(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples3(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples4(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples5(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples6(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples7(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples8(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples9(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples10(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a + b)\n\n\ndef add_tuples11(a, b):\n    \"\"\""
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def add(self, tuple1, tuple2):\n        \"\"\"\n        :type tuple1: List[List[int]]\n        :type tuple2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not tuple1 or not tuple2:\n            return tuple2\n        for i in xrange(min(len(tuple1), len(tuple2))):\n            tuple1[i] = tuple1[i] + tuple2[i]\n        return tuple1\n\ns = Solution()\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])\nprint s.add([[1,2,3,4], [1,2,3,4]], [[3,4,5,6], [1,2,3,4]])"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/nested-tuples/problem\n\ndef addNestedTuples(a, b):\n    \"\"\"\n    :type a: List[Tuple[int, int]]\n    :type b: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    a_list = list(a)\n    b_list = list(b)\n    c_list = []\n\n    for i in range(len(a_list)):\n        if len(a_list[i]) == 2:\n            a_list[i] = (a_list[i][0] + b_list[i][0], a_list[i][1] + b_list[i][1])\n            c_list.append(a_list[i])\n        else:\n            c_list.append(a_list[i])\n    return c_list\n\n# Sample Input\n# [[1,2],[3,4]]\n# [[5,6],[7,8]]\n# Sample Output\n# [[6,8],[10,12]]\n\na = [[1,2],[3,4]]\nb = [[5,6],[7,8]]\nc = addNestedTuples(a, b)\n\nprint(c)"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "import collections\n\nclass Tuple(object):\n    def __init__(self, items):\n        self.items = items\n\n    def __iter__(self):\n        return iter(self.items)\n\n    def __add__(self, other):\n        return Tuple(self.items + other.items)\n\n\nclass Tuple2(object):\n    def __init__(self, items):\n        self.items = items\n\n    def __iter__(self):\n        return iter(self.items)\n\n    def __add__(self, other):\n        return Tuple2(self.items + other.items)\n\n\ndef add_tuple(t1, t2):\n    return Tuple(t1.items + t2.items)\n\n\ndef add_tuple2(t1, t2):\n    return Tuple2(t1.items + t2.items)\n\n\ndef add_tuple_tuple2(t1, t2):\n    return Tuple2(t1.items + t2.items)\n\n\ndef add_tuple3(t1, t2):\n    return Tuple(t1.items + t2.items)\n\n\ndef add_tuple_tuple3(t1, t2):\n    return Tuple(t1.items + t2.items)\n\n\ndef add_tuple_tuple3(t1, t2):\n    return Tuple(t1.items + t2.items)\n\n\nif __name__ == '__main__':\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n\n    print(add_tuple(t1, t2))\n    print(add_tuple2(t1, t2))\n    print(add_tuple3(t1, t2))\n    print(add_tuple_tuple2(t1, t2))\n    print(add_tuple_tuple3(t1, t2))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/add-tuple-to-nested-tuples/\n\nclass Solution:\n    # @param {List[List[int]]} nestedTuple1\n    # @param {List[List[int]]} nestedTuple2\n    # @return {List[List[int]]}\n    def addNestedTuples(self, nestedTuple1, nestedTuple2):\n        return [tuple(nestedTuple1[i] + tuple(tuple2)) for i, tuple2 in enumerate(nestedTuple2)]"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "import collections\n\ndef add_tuple(t1, t2):\n    \"\"\"\n    Add tuple elements of t1 and t2.\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    if isinstance(t1, collections.Iterable) and isinstance(t2, collections.Iterable):\n        return tuple(sum(t1, t2))\n    else:\n        return t1 + t2\n\n\nif __name__ == '__main__':\n    print(add_tuple((1, 2), (3, 4)))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/adding-tuples\n# https://www.hackerrank.com/challenges/adding-tuples-ii\n# https://www.hackerrank.com/challenges/adding-tuples-iii\n# https://www.hackerrank.com/challenges/adding-tuples-iv\n# https://www.hackerrank.com/challenges/adding-tuples-v\n\ndef add_tuples(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    res = []\n    for i in range(0, len(t1)):\n        res.append(tuple(t1[i] + t2[i]))\n    return tuple(res)\n\nif __name__ == \"__main__\":\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    res = add_tuples(t1, t2)\n    print(res)"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "import unittest\nfrom collections import namedtuple\n\n\ndef add_tuples(t1, t2):\n    \"\"\"\n    :type t1: namedtuple\n    :type t2: namedtuple\n    :rtype: namedtuple\n    \"\"\"\n    return namedtuple('result', t1.__fields__ + t2.__fields__)(*t1.__fields__ + t2.__fields__)\n\n\nclass Test(unittest.TestCase):\n\n    def test(self):\n        t1 = namedtuple('t1', 'a b c d')\n        t2 = namedtuple('t2', 'e f g h')\n        self.assertEqual(add_tuples(t1(1, 2, 3), t2(4, 5, 6)),\n                         namedtuple('result', 'a b c d e f g h')(1, 2, 3, 4, 5, 6))\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def add_tuple_elements(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    res = []\n    for i, j in zip(t1, t2):\n        res.append(i + j)\n    return tuple(res)\n\nif __name__ == \"__main__\":\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    print(add_tuple_elements(t1, t2))\n    t1 = (1, 2, 3, 4, 5)\n    t2 = (6, 7, 8, 9, 10)\n    print(add_tuple_elements(t1, t2))\n    t1 = (1, 2)\n    t2 = (3, 4)\n    print(add_tuple_elements(t1, t2))\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6, 7)\n    print(add_tuple_elements(t1, t2))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-addition/problem\n\nimport unittest\nfrom collections import namedtuple\n\nclass TupleAddition:\n    def __init__(self):\n        self.num_tuple = namedtuple(\"num_tuple\", [\"a\", \"b\", \"c\", \"d\"])\n\n    def get_sum(self, a, b):\n        return a.a + b.a + a.b + b.b + a.c + b.c + a.d + b.d\n\n\nclass TupleAdditionTest(unittest.TestCase):\n    def test_tuple_addition(self):\n        t = TupleAddition()\n        a = t.num_tuple(1, 2, 3, 4)\n        b = t.num_tuple(5, 6, 7, 8)\n        self.assertEqual(t.get_sum(a, b), 14)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def add(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[List[int]]\n        :type nums2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums1) == 0:\n            return nums2\n        if len(nums2) == 0:\n            return nums1\n\n        nums1.append(nums2[0])\n        nums2.pop(0)\n        nums1 = self.add(nums1, nums2)\n        return nums1\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    nums1 = [[1,2], [3,4]]\n    nums2 = [[5,6], [7,8], [9,0]]\n    print solution.add(nums1, nums2)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import sys\n\n# Your Solution here\n\ndef add(a, b):\n    if len(a)!= len(b):\n        return None\n    return tuple(a + b)\n\ndef main():\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    print(add(t1, t2))\n    t3 = (7, 8, 9)\n    t4 = (10, 11, 12)\n    print(add(t3, t4))\n    t5 = (13, 14, 15)\n    t6 = (16, 17, 18)\n    print(add(t5, t6))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Tuple(object):\n    def __init__(self, v):\n        self.v = v\n\n    def __add__(self, other):\n        return Tuple(self.v + other.v)\n\ndef add(a, b):\n    return Tuple(a.v + b.v)\n\nif __name__ == '__main__':\n    t1 = Tuple((1, 2, 3))\n    t2 = Tuple((4, 5, 6))\n    t3 = add(t1, t2)\n    print t3.v"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\nT = namedtuple('T', 'a b c')\n\ndef add(a, b):\n    return T(a.a + b.a, a.b + b.b, a.c + b.c)\n\ndef test_add():\n    assert add(T(1, 2, 3), T(4, 5, 6)).a == 7\n    assert add(T(1, 2, 3), T(4, 5, 6)).b == 8\n    assert add(T(1, 2, 3), T(4, 5, 6)).c == 11\n\ndef test_add_2():\n    assert add(T(1, 2, 3), T(4, 5, 6)).a == 7\n    assert add(T(1, 2, 3), T(4, 5, 6)).b == 8\n    assert add(T(1, 2, 3), T(4, 5, 6)).c == 11\n\ndef test_add_3():\n    assert add(T(1, 2, 3), T(4, 5, 6)).a == 7\n    assert add(T(1, 2, 3), T(4, 5, 6)).b == 8\n    assert add(T(1, 2, 3), T(4, 5, 6)).c == 11\n\ndef test_add_4():\n    assert add(T(1, 2, 3), T(4, 5, 6)).a == 7\n    assert add(T(1, 2, 3), T(4, 5, 6)).b == 8\n    assert add(T(1, 2, 3), T(4, 5, 6)).c == 11\n\ndef test_add_5():\n    assert add(T(1, 2, 3), T(4, 5, 6)).a == 7\n    assert add(T(1, 2, 3), T(4, 5, 6)).b == 8\n    assert add(T(1, 2, 3), T(4, 5, 6)).c == 11"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\n    def __add__(self, y):\n        return Tuple(self.x + y.x, self.y + y.y)\n\n    def __str__(self):\n        return str(self.x) + str(self.y)\n\nclass Solution:\n    def tupleAddition(self, a, b):\n        \"\"\"\n        :type a: Tuple\n        :type b: Tuple\n        :rtype: Tuple\n        \"\"\"\n        ans = Tuple(0, 0)\n        for i in range(len(a.x)):\n            ans.x[i] = a.x[i] + b.x[i]\n            ans.y += a.y[i] + b.y[i]\n        return ans\n\nif __name__ == \"__main__\":\n    a = Tuple(1, 2)\n    b = Tuple(3, 4)\n    a.y[0] = 5\n    b.y[0] = 6\n    print(a)\n    print(b)\n    print(Solution().tupleAddition(a, b))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param first: A tuple\n    @param second: A tuple\n    @return: A tuple\n    \"\"\"\n    def add(self, first, second):\n        res = ()\n        for i in range(len(first)):\n            res += (first[i], second[i])\n        return tuple(res)\n\n    def add1(self, first, second):\n        res = ()\n        for i in range(len(first)):\n            res += (first[i], second[i])\n        return tuple(res)\n\n    def add2(self, first, second):\n        res = ()\n        for i in range(len(first)):\n            for j in range(len(second)):\n                res += (first[i], second[j])\n        return tuple(res)\n\n    def add3(self, first, second):\n        res = ()\n        for i in range(len(first)):\n            for j in range(len(second)):\n                res += (first[i], second[j])\n        return tuple(res)\n\n    def add4(self, first, second):\n        res = ()\n        for i in range(len(first)):\n            for j in range(len(second)):\n                res += (first[i], second[j])\n        return tuple(res)"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "class Tuple(object):\n    def __init__(self, *args):\n        self.args = args\n\n    def __add__(self, other):\n        if not isinstance(other, tuple):\n            raise TypeError(\"Can only add tuples\")\n        return Tuple(*(self.args + other.args))\n\ndef tuple_add(a, b):\n    return Tuple(*(a.args + b.args))\n\ndef test_tuple_add():\n    assert tuple_add((1,2,3), (4,5,6)) == Tuple(1,4,5,6)\n\nif __name__ == \"__main__\":\n    test_tuple_add()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/add-two-numbers/description/\n\nclass Solution(object):\n    def add(self, a, b):\n        \"\"\"\n        :type a: List[int]\n        :type b: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(a) == 0:\n            return b\n        if len(b) == 0:\n            return a\n        return [a[i]+b[i] for i in range(len(a))]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    a = [1,2,3]\n    b = [4,5,6]\n    print(s.add(a,b))"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\n\ndef add_tuples(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(map(lambda x, y: x + y, t1, t2))\n\n\ndef main():\n    \"\"\"\n    Sample Inputs\n    t1 = (1, 2, 3, 4)\n    t2 = (5, 6, 7, 8)\n    \"\"\"\n    t1 = (1, 2, 3, 4)\n    t2 = (5, 6, 7, 8)\n    print(add_tuples(t1, t2))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 22,
      "score": 9.0,
      "candidate": "def add(a, b):\n    \"\"\"\n    >>> a = (1, (2, (3, 4)))\n    >>> b = (4, (5, 6))\n    >>> add(a, b)\n    (1, (2, (3, 4)) + (4, (5, 6)))\n    \"\"\"\n    if not isinstance(a, tuple) or not isinstance(b, tuple):\n        return a + b\n    for i in range(len(a)):\n        if isinstance(a[i], tuple):\n            add(a[i], b[i])\n        else:\n            a[i] += b[i]\n    return a\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.0,
      "candidate": "def add_tuple(a,b):\n\treturn tuple(map(lambda x,y: x+y, a, b))\n\n#test cases:\nprint(add_tuple((1,2),(3,4)))\nprint(add_tuple((1,2,3),(4,5,6)))\nprint(add_tuple((1,2),(3,4,5)))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __iter__(self):\n        return iter(self.x)\n\ndef add(t1, t2):\n    \"\"\"\n    :type t1: Tuple\n    :type t2: Tuple\n    :rtype: Tuple\n    \"\"\"\n    x = []\n    for i, v in enumerate(t1):\n        for j, w in enumerate(t2):\n            x.append((v + w) % 10)\n    return Tuple(x)\n\n# Your function will be called like this:\n# add(t1, t2)"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def add(self, x, y):\n        \"\"\"\n        :type x: tuple\n        :type y: tuple\n        :rtype: tuple\n        \"\"\"\n        result = []\n        for i, j in zip(x, y):\n            result.append(i + j)\n        return tuple(result)"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def add_tuple(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(map(lambda x, y: x + y, t1, t2))\n\n\nif __name__ == '__main__':\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    print(add_tuple(t1, t2))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\n# Your code here\n\nclass Tuple(namedtuple('Tuple', 'a b')):\n    pass\n\ndef add_tuples(tuples1, tuples2):\n    for i in range(len(tuples1)):\n        tuples1[i] = Tuple(a=tuples1[i].a + tuples2[i].a, b=tuples1[i].b + tuples2[i].b)\n    return tuples1\n\ndef test():\n    tuples1 = Tuple(a=1, b=2)\n    tuples2 = Tuple(a=3, b=4)\n    tuples1 = add_tuples(tuples1, tuples2)\n    print(tuples1)\n\nif __name__ == \"__main__\":\n    test()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nfrom typing import List, Tuple\n\n\nclass TupleAddition(namedtuple(\"TupleAddition\", \"a b\")):\n    def __add__(self, other):\n        return TupleAddition(self.a + other.a, self.b + other.b)\n\n\nt = TupleAddition(1, 2)\nt2 = TupleAddition(3, 4)\n\nprint(t + t2)\nprint(t2 + t)"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def add(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(a[i] + b[i] for i in range(len(a)))\n\nif __name__ == \"__main__\":\n    a = (1, (2, 3))\n    b = (4, (5, 6))\n    print(add(a, b))\n    print(add((1, 2), (3, 4)))\n    print(add((1, 2), (3, 4, 5, 6)))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {tuple} a\n    # @param {tuple} b\n    # @return {tuple}\n    def add(self, a, b):\n        if len(a)!= len(b):\n            return None\n        res = []\n        for i in range(len(a)):\n            if i == len(b):\n                res.append(a[i])\n            else:\n                res.append(a[i] + b[i])\n        return tuple(res)\n\n\nif __name__ == '__main__':\n    a = (1,2,3)\n    b = (4,5,6)\n    s = Solution()\n    print s.add(a,b)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "import collections\n\ndef add_tuples(a, b):\n    if isinstance(a, collections.Mapping) and isinstance(b, collections.Mapping):\n        return {k: add_tuples(a[k], b[k]) for k in a}\n    elif isinstance(a, collections.Sequence) and isinstance(b, collections.Sequence):\n        return tuple(add_tuples(a[i], b[i]) for i in range(len(a)))\n    else:\n        return a + b\n\nif __name__ == '__main__':\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    print(add_tuples(a, b))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "# https://oj.leetcode.com/problems/add-two-numbers/\n\n# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n\nclass Solution:\n    def add_tuple(self, tuple1, tuple2):\n        \"\"\"\n        :type tuple1: Tuple\n        :type tuple2: Tuple\n        :rtype: Tuple\n        \"\"\"\n        t = Tuple(0)\n        t.x = tuple1.x + tuple2.x\n        t.y = tuple1.y + tuple2.y\n        return t\n\nif __name__ == '__main__':\n    s = Solution()\n    t1 = Tuple(3)\n    t2 = Tuple(1)\n    print(s.add_tuple(t1, t2))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {tuple} a\n    # @param {tuple} b\n    # @return {tuple}\n    def add(self, a, b):\n        if len(a)!= len(b):\n            raise ValueError(\"Addition of tuples with different lengths is not allowed\")\n        res = tuple(a[i] + b[i] for i in range(len(a)))\n        return res"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def add_tuple(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(x+y for x, y in zip(a, b))\n\n\ndef main():\n    a = (1, 2, 3, 4)\n    b = (5, 6, 7, 8)\n    print(add_tuple(a, b))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def add(t1, t2):\n    t1_list = list(t1)\n    t2_list = list(t2)\n    for i in range(len(t1)):\n        t1_list[i] += t2_list[i]\n    return tuple(t1_list)\n\nprint(add((1, 2, 3), (3, 2, 1)))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'a b c')\n\ndef add_tuples(t1, t2):\n    \"\"\"\n    :type t1: Tuple\n    :type t2: Tuple\n    :rtype: Tuple\n    \"\"\"\n    return Tuple(t1.a + t2.a, t1.b + t2.b, t1.c + t2.c)\n\nif __name__ == '__main__':\n    t1 = Tuple(1, 2, 3)\n    t2 = Tuple(4, 5, 6)\n    t3 = add_tuples(t1, t2)\n    print(t3)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "import collections\n\ndef add(a, b):\n    return collections.namedtuple('add_result', a.keys())(*a.values())\n\nprint(add(('a', 1), ('b', 2)))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def add_tuples(a, b):\n    return tuple(a[0] + b[0] for a in a)\n\nif __name__ == \"__main__\":\n    t = (1, (2, 3))\n    print(add_tuples(t, t))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-addition/problem\n\ndef add(t1, t2):\n    return tuple(map(lambda x: x + y, t1) + map(lambda x: x + y, t2))\n\nif __name__ == '__main__':\n    t1, t2 = tuple(map(int, input().split()))\n    print(add(t1, t2))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nT = namedtuple('T', 'x y')\n\ndef add_tuple(a, b):\n    \"\"\"\n    :type a: Tuple[int, int]\n    :type b: Tuple[int, int]\n    :rtype: Tuple[int, int]\n    \"\"\"\n    return a.x + b.x, a.y + b.y\n\ndef add_tuple_with_tuples(a, b):\n    \"\"\"\n    :type a: Tuple[int, Tuple[int, int]]\n    :type b: Tuple[int, Tuple[int, int]]\n    :rtype: Tuple[int, Tuple[int, int]]\n    \"\"\"\n    return a.x + b.x, add_tuple(a.y, b.y)\n\ndef test_add_tuple():\n    assert add_tuple((1, 2), (3, 4)) == (4, 6)\n\ndef test_add_tuple_with_tuples():\n    assert add_tuple_with_tuples((1, (2, 3)), (4, (5, 6))) == (5, (7, 9))\n\nif __name__ == '__main__':\n    test_add_tuple()\n    test_add_tuple_with_tuples()"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\n# class Tuple(namedtuple('Tuple', 'a, b, c')):\n\nclass Tuple(namedtuple('Tuple', 'a, b, c')):\n    def __add__(self, other):\n        result = Tuple(self.a, self.b, self.c)\n        result.c = self.c + other.c\n        return result\n\n# a, b, c = Tuple(1, 2, 3), Tuple(4, 5, 6), Tuple(7, 8, 9)\n# print(a + b)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)\n# print(a + b + c)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\n# Recursion\nclass TupleAdd(object):\n    def __init__(self, tuple1, tuple2):\n        self.tuple1 = tuple1\n        self.tuple2 = tuple2\n\n    def add(self, i, j):\n        if i == 0:\n            return self.tuple1[0] + self.tuple2[0]\n        elif j == 0:\n            return self.tuple1[i] + self.tuple2[0]\n        else:\n            return self.tuple1[i] + self.tuple1[j] + self.tuple2[j]\n\n\n# DP\nclass TupleAddDP(object):\n    def __init__(self, tuple1, tuple2):\n        self.tuple1 = tuple1\n        self.tuple2 = tuple2\n\n    def add(self, i, j):\n        if i == 0:\n            return self.tuple1[0] + self.tuple2[0]\n        elif j == 0:\n            return self.tuple1[i] + self.tuple2[0]\n        else:\n            return self.tuple1[i] + self.tuple1[j] + self.tuple2[j]\n\n# Recursion\nclass TupleAddDP(object):\n    def __init__(self, tuple1, tuple2):\n        self.tuple1 = tuple1\n        self.tuple2 = tuple2\n\n    def add(self, i, j):\n        if i == 0:\n            return self.tuple1[0] + self.tuple2[0]\n        elif j == 0:\n            return self.tuple1[i] + self.tuple2[0]\n        else:\n            return self.tuple1[i] + self.tuple1[j] + self.tuple2[j]\n\n# DP\nclass TupleAddDP(object):\n    def __init__(self, tuple1, tuple2):\n        self.tuple1 = tuple1\n        self.tuple2 = tuple2\n\n    def add(self, i, j):\n        if i"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nclass TupleAdd(object):\n    def __init__(self, tuple1, tuple2):\n        self.tuple1 = tuple1\n        self.tuple2 = tuple2\n\n    def __add__(self, other):\n        tuple_tuple = namedtuple('tuple_tuple', 'tuple1 tuple2')\n        tuple_tuple = tuple_tuple(self.tuple1, self.tuple2)\n        return tuple_tuple\n\ndef main():\n    t1 = (1,2,3)\n    t2 = (4,5,6)\n\n    print(TupleAdd(t1,t2))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def add(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    c = []\n    for i in range(len(a)):\n        c.append(a[i] + b[i])\n    return tuple(c)\n\n\n\nif __name__ == '__main__':\n    a = (1,2,3,4,5,6,7,8,9,10)\n    b = (1,2,3,4,5,6,7,8,9,10)\n    c = add(a,b)\n    print(c)"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "# Tuple addition\ndef add_tuples(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_2(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_3(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_4(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_5(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_6(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(t1[i] + t2[i] for i in range(len(t1)))\n\n# Tuple addition, Pythonic\ndef add_tuples_7(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def add_tuples(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i, v in enumerate(a):\n        for j, w in enumerate(b):\n            result.append(v + w)\n    return tuple(result)\n\n\nif __name__ == \"__main__\":\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    result = add_tuples(a, b)\n    print(result)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "import collections\n\nclass Solution(object):\n    def add(self, tuple1, tuple2):\n        \"\"\"\n        :type tuple1: List[List[int]]\n        :type tuple2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(tuple1)!= len(tuple2):\n            return tuple1\n        result = collections.deque()\n        for i in range(len(tuple1)):\n            result.append(tuple1[i] + tuple2[i])\n        return tuple(result)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.add([[1,2,3], [4,5,6]], [[7,8,9]]))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution:\n    def add(self, a, b):\n        \"\"\"\n        :type a: tuple\n        :type b: tuple\n        :rtype: tuple\n        \"\"\"\n        if len(a)!= len(b):\n            raise ValueError(\"length of a and b should be same\")\n        c = []\n        for i in range(len(a)):\n            c.append(a[i] + b[i])\n        return tuple(c)\n\nif __name__ == \"__main__\":\n    assert Solution().add((1,2,3), (2,3,4)) == (3, 5, 7)"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "#!/bin/python\n\nimport sys\n\ndef add_tuples(a, b):\n    if len(a) == 0:\n        return b\n    elif len(b) == 0:\n        return a\n    else:\n        a_1 = tuple(a[0])\n        a_2 = tuple(a[1])\n        b_1 = tuple(b[0])\n        b_2 = tuple(b[1])\n        c = (a_1 + b_1, a_2 + b_2)\n        return c\n\ndef main(a, b):\n    print(add_tuples(a, b))\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2])"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def add_tuples(a, b):\n    \"\"\"\n    :param a: tuple\n    :param b: tuple\n    :return: tuple\n    \"\"\"\n    return tuple(x + y for x, y in zip(a, b))\n\nif __name__ == '__main__':\n    assert(add_tuples((1, 2), (3, 4)) == (4, 6))\n    assert(add_tuples((1, 2), (3, 4, 5)) == (4, 6, 9))\n    assert(add_tuples((1, 2), (3, 4, 5, 6)) == (4, 6, 9, 12))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nclass Tuple(namedtuple('Tuple', 'x y')):\n    __slots__ = ()\n\nt1 = Tuple(1, 2)\nt2 = Tuple(3, 4)\n\ndef add(t1, t2):\n    return Tuple(t1.x + t2.x, t1.y + t2.y)\n\nprint(add(t1, t2))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from typing import List, Tuple\n\n\ndef add_nested_tuples(a: Tuple[Tuple[int,...], Tuple[int,...]]) -> Tuple[Tuple[int,...], Tuple[int,...]]:\n    \"\"\"\n    :type a: Tuple[Tuple[int,...], Tuple[int,...]]\n    :rtype: Tuple[Tuple[int,...], Tuple[int,...]]\n    \"\"\"\n    b = a[0]\n    c = a[1]\n    for i in range(len(c)):\n        b[i] += c[i]\n    return b, c\n\n\nif __name__ == '__main__':\n    a = (1, 2, 3, 4)\n    b = (1, 2, 3, 4)\n    c = (1, 2, 3, 4)\n    d = (1, 2, 3, 4)\n    print(add_nested_tuples(a, b))\n    print(add_nested_tuples(a, c))\n    print(add_nested_tuples(a, d))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\ndef add(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    result = namedtuple('result', a.__slots__)(*a)\n    for i in range(len(a)):\n        result[i] += b[i]\n    return result\n\nif __name__ == \"__main__\":\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    print(add(a, b))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\n\ndef tuple_add(first, second):\n    \"\"\"\n    :type first: namedtuple\n    :type second: namedtuple\n    :rtype: namedtuple\n    \"\"\"\n    for i, j in zip(first, second):\n        setattr(first, i, j)\n\n\ndef main():\n    tuple_a = namedtuple('tuple_a', 'a b c')\n    tuple_b = namedtuple('tuple_b', 'd e f')\n\n    tuple_a_1 = tuple_a(a=1, b=2, c=3)\n    tuple_a_2 = tuple_a(a=4, b=5, c=6)\n\n    tuple_b_1 = tuple_b(d=1, e=2, f=3)\n    tuple_b_2 = tuple_b(d=4, e=5, f=6)\n\n    tuple_add(tuple_a_1, tuple_b_1)\n    tuple_add(tuple_a_2, tuple_b_2)\n\n    print(tuple_a_1.a, tuple_a_1.b, tuple_a_1.c)\n    print(tuple_a_2.a, tuple_a_2.b, tuple_a_2.c)\n    print(tuple_b_1.d, tuple_b_1.e, tuple_b_1.f)\n    print(tuple_b_2.d, tuple_b_2.e, tuple_b_2.f)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "import collections\n\n\nclass TupleElementAdd(object):\n    @classmethod\n    def add(cls, first, second):\n        \"\"\"\n        :type first: collections.Iterable[TupleElement]\n        :type second: collections.Iterable[TupleElement]\n        :rtype: collections.Iterable[TupleElement]\n        \"\"\"\n        result = []\n        for first_element, second_element in zip(first, second):\n            result.append((first_element + second_element).value)\n        return result\n\n\nif __name__ == '__main__':\n    first_tuple = (1, 2)\n    second_tuple = (3, 4)\n    assert TupleElementAdd.add(first_tuple, second_tuple) == [5, 8]"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "import sys\nimport timeit\n\ndef add(t1, t2):\n    \"\"\"\n    Input:\n    t1: tuple\n    t2: tuple\n\n    Output:\n    A tuple\n    \"\"\"\n    return tuple([sum(x) for x in zip(t1, t2)])\n\nif __name__ == '__main__':\n    t = timeit.timeit('add(1, 2)', setup=\"from __main__ import add\", number=100)\n    print(\"Time taken to execute: %s\" % t)\n    print(\"Average time taken: %s\" % t/100)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "import collections\n\ndef add_tuples(a, b):\n    return collections.OrderedDict([(k, v + b[k]) for k, v in a.items()])\n\nif __name__ == '__main__':\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    print(add_tuples(a, b))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "class Solution:\n    def add(self, l1, l2):\n        \"\"\"\n        :type l1: List[List[int]]\n        :type l2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i in range(0, len(l1)):\n            result.append([])\n            for j in range(0, len(l1[0])):\n                result[i].append(l1[i][j] + l2[i][j])\n\n        return result"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "def add_tuples(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        for j in range(len(b[i])):\n            result.append(a[i][j] + b[i][j])\n    return tuple(result)\n\nif __name__ == '__main__':\n    a = (('a', 1), ('b', 2), ('c', 3))\n    b = (('a', 1), ('b', 2), ('c', 3))\n    print add_tuples(a, b)"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {tuple} a a tuple\n    # @param {tuple} b a tuple\n    # @return {tuple}\n    def add(self, a, b):\n        \"\"\"\n        :type a: tuple\n        :type b: tuple\n        :rtype: tuple\n        \"\"\"\n        def inner(a, b):\n            if len(a) == 0:\n                return b\n            elif len(b) == 0:\n                return a\n            else:\n                return (inner(a[1:], b[1:]) + [a[0] + b[0]] + inner(a[0:1], b[0:1]))\n\n        return inner(a, b)\n\n\nif __name__ == '__main__':\n    print(Solution().add((1, 2), (3, 4)))"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def add(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[0] * len(a[0]) for _ in range(len(a))]\n        for i in range(len(a)):\n            for j in range(len(a[i])):\n                result[i][j] = a[i][j] + b[i][j]\n        return result\n\na = [[1, 2], [3, 4]]\nb = [[1, 2], [3, 4], [1, 2]]\nprint(Solution().add(a, b))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import collections\n\ndef tuple_add(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    new_tuple = collections.deque()\n    for i in range(0, len(a)):\n        new_tuple.append(a[i] + b[i])\n    return tuple(new_tuple)\n\nif __name__ == '__main__':\n    tuple_a = (1, 2, 3)\n    tuple_b = (4, 5, 6)\n    tuple_c = tuple_add(tuple_a, tuple_b)\n    print(tuple_c)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def add(self, tuple1, tuple2):\n        \"\"\"\n        :type tuple1: List[List[int]]\n        :type tuple2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not tuple1 or not tuple2:\n            return []\n\n        res = [[0 for _ in range(len(tuple2[0]))] for _ in range(len(tuple1[0]))]\n        for i in range(len(tuple1[0])):\n            for j in range(len(tuple2[0])):\n                res[i][j] = tuple1[0][i] + tuple2[0][j]\n        return res"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def add_tuples(self, tuple1, tuple2):\n        \"\"\"\n        :type tuple1: tuple\n        :type tuple2: tuple\n        :rtype: tuple\n        \"\"\"\n        return tuple(x + y for x, y in zip(tuple1, tuple2))\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.add_tuples((1, 2, 3), (4, 5, 6)))\n    print(sol.add_tuples((1, 2, 3), (4, 5, 6, 7)))"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from collections import namedtuple\n\nTuple = namedtuple('Tuple', 'x y')\n\n\ndef index_add(t1, t2):\n    if len(t1)!= len(t2):\n        raise ValueError('Invalid input')\n    result = []\n    for i in range(len(t1)):\n        result.append(Tuple(t1[i][0] + t2[i][0], t1[i][1] + t2[i][1]))\n    return tuple(result)\n\n\nif __name__ == '__main__':\n    t1 = Tuple(1, 2)\n    t2 = Tuple(3, 4)\n    t3 = index_add(t1, t2)\n    print(t3)\n    t4 = Tuple(2, 3)\n    t5 = index_add(t3, t4)\n    print(t5)\n    t6 = Tuple(3, 4)\n    t7 = index_add(t5, t6)\n    print(t7)"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def sum_tuple(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple([(i+j) for i, j in zip(t1, t2)])\n\n\nif __name__ == '__main__':\n    t1 = (1,2,3,4,5)\n    t2 = (6,7,8,9,10)\n    t3 = sum_tuple(t1, t2)\n    print(t3)"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "import collections\n\nclass Tuple(collections.MutableSequence):\n    def __init__(self, *args):\n        self._tuple = args\n\n    def __len__(self):\n        return len(self._tuple)\n\n    def __iter__(self):\n        return iter(self._tuple)\n\n    def __getitem__(self, key):\n        return self._tuple[key]\n\n    def __setitem__(self, key, value):\n        self._tuple[key] = value\n\n    def __delitem__(self, key):\n        del self._tuple[key]\n\n    def insert(self, key, value):\n        self._tuple.insert(key, value)\n\ndef add(a, b):\n    return Tuple(a[0]+b[0], a[1]+b[1])\n\nt1 = (1, 2)\nt2 = (3, 4)\nprint add(t1, t2)"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def add(t1, t2):\n    \"\"\"\n    Input:\n    t1 and t2 are nested tuples of any length.\n    Output:\n    Returns the result as a nested tuple of the same length as t1.\n    \"\"\"\n    for i in range(len(t1)):\n        if isinstance(t1[i], tuple):\n            t1[i] = add(t1[i], t2[i])\n        else:\n            t1[i] += t2[i]\n    return t1\n\ndef test_add():\n    assert add(((1, 2), (3, 4)), ((1, 2), (3, 4))) == ((1, 4), (3, 6))\n    assert add(((1, 2), (3, 4)), ((1, 2), (3, 5))) == ((1, 4), (3, 6))\n    assert add(((1, 2), (3, 4)), ((1, 2), (3, 4))) == ((1, 4), (3, 4))\n    assert add(((1, 2), (3, 4)), ((1, 2), (3, 5))) == ((1, 4), (3, 6))\n\nif __name__ == '__main__':\n    test_add()"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "class Tuple(object):\n    \"\"\"\n    A tuple object.\n    \"\"\"\n    def __init__(self, tup=None):\n        if tup is None:\n            self.tup = []\n        else:\n            self.tup = tup\n\n    def __add__(self, tup):\n        \"\"\"\n        Addition of two tuple\n        \"\"\"\n        if isinstance(tup, Tuple):\n            self.tup.extend(tup.tup)\n        else:\n            self.tup.append(tup)\n        return self\n\n    def __str__(self):\n        \"\"\"\n        String representation of the tuple.\n        \"\"\"\n        return str(self.tup)\n\n    def __repr__(self):\n        \"\"\"\n        Represents the tuple in a printable format.\n        \"\"\"\n        return str(self.tup)\n\n\ndef add_tuples(t1, t2):\n    \"\"\"\n    Add two tuples.\n    \"\"\"\n    result = Tuple()\n    for i in t1.tup:\n        result += i\n    for i in t2.tup:\n        result += i\n    return result"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def add(x, y):\n    return (x[0] + y[0], x[1] + y[1])\n\ndef add2(x, y):\n    return (x[0] + y[0], x[1] + y[1])\n\ndef test_add():\n    assert add((1,2), (3, 4)) == (4, 6)\n    assert add((1,2), (3, 4, 5)) == (4, 6, 9)\n\ndef test_add2():\n    assert add2((1,2), (3, 4)) == (4, 6)\n    assert add2((1,2), (3, 4, 5)) == (4, 6, 9)\n\nif __name__ == '__main__':\n    test_add()\n    test_add2()"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "def add_nested_tuples(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(map(lambda x, y: x + y, t1, t2))\n\nif __name__ == '__main__':\n    t1 = (1,2,3)\n    t2 = (3,2,1)\n    print(add_nested_tuples(t1, t2))"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def add_tuple_elements(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(map(lambda x, y: x+y, t1, t2))\n\nt1 = (1, 2)\nt2 = (3, 4)\nprint(add_tuple_elements(t1, t2))"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "def add_tuples(t1, t2):\n    \"\"\"\n    :type t1: tuple\n    :type t2: tuple\n    :rtype: tuple\n    \"\"\"\n    tuple1 = []\n    tuple2 = []\n    for i in range(0, len(t1)):\n        tuple1.append(t1[i])\n        tuple2.append(t2[i])\n    return tuple(tuple1) + tuple(tuple2)\n\n\nif __name__ == \"__main__\":\n    t1 = (1, 2, 3)\n    t2 = (1, 2, 3)\n    t3 = add_tuples(t1, t2)\n    print t3"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.y = 0\n    def __add__(self, y):\n        return Tuple(self.x + y.x)\n\nclass Solution(object):\n    def __init__(self):\n        self.dic = {}\n        self.ans = []\n    def add(self, x, y):\n        if x not in self.dic:\n            self.dic[x] = 0\n        if y not in self.dic:\n            self.dic[y] = 0\n        if x == y:\n            self.ans.append(x)\n            return\n        if self.dic[x] < self.dic[y]:\n            self.dic[x] += self.dic[y]\n            self.dic[y] = 0\n        else:\n            self.dic[y] += self.dic[x]\n            self.dic[x] = 0\n        self.ans.append(x)\n\nsol = Solution()\n\n# input: (1, 2), (3, 4)\n# output: (1, 2), (3, 4), (2, 4), (4, 4)\nsol.add(Tuple(1), Tuple(2))\nsol.add(Tuple(3), Tuple(4))\nprint sol.ans"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "def add_nested_tuples(a, b):\n    \"\"\"\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    \n    return tuple(map(lambda x, y: x + y, a, b))\n\nif __name__ == '__main__':\n    a = (1, 2, 3)\n    b = (4, 5, 6)\n    print(add_nested_tuples(a, b))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "from typing import Tuple, List\nfrom collections import namedtuple\n\n_Tuple = namedtuple('_Tuple', 'a b')\n\ndef add(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add2(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add3(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add4(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add5(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add6(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add7(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add8(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add9(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add10(a: _Tuple, b: _Tuple) -> _Tuple:\n    return _Tuple(a.a + b.a, a.b + b.b)\n\ndef add11(a: _Tuple, b: _Tuple) -> _"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "import unittest\n\n\nclass Solution:\n    def add(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[List[int]]\n        :type nums2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                ret.append([nums1[i][j] + nums2[j][i]])\n        return ret\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/index-wise-addition-of-tuple/solution/\n\nApproach #1: Recursion\nComplexity Analysis\nTime Complexity: O(M + N), where M and N are the size of the input lists.\nSpace Complexity: O(M + N), where M and N are the size of the input lists.\n\n# 12ms 100%\nclass Solution {\n    public List<List<Integer>> add(List<List<Integer>> nums1, List<List<Integer>> nums2) {\n        List<List<Integer>> ret = new ArrayList<>();\n        add(nums1, nums2, 0, 0, ret);\n        return ret;\n    }\n    private void add(List<List<Integer>> nums1, List<List<Integer>> nums2, int i, int j, List<List<Integer>> ret) {\n        if (i == nums1.size() && j == nums2.size()) {\n            ret.add(new ArrayList<>(nums1));\n            return;\n        }\n        if (i == nums1.size()) {\n            ret.add(new ArrayList<>(nums2.subList(j, nums2.size())));\n            return;\n        }\n        if (j == nums2.size())"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/add-two-numbers/discuss/125098/Python-Solution-using-recursion-and-lists\ndef add_numbers(nums1, nums2):\n    if len(nums1) == 0:\n        return nums2\n    if len(nums2) == 0:\n        return nums1\n    if nums1[0] == 0 and nums2[0] == 0:\n        return (0, 0)\n    if nums1[0] == 0:\n        return (nums2[0], nums2[1])\n    if nums2[0] == 0:\n        return (nums1[0], nums1[1])\n    return (add_numbers(nums1[1:], nums2[1:]), nums1[0] + nums2[0])\n\nclass Solution(object):\n    def add_numbers(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return add_numbers(nums1, nums2)"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def add_tuples(a, b):\n    for i in range(len(a)):\n        for j in range(len(a[0])):\n            if i == j:\n                a[i][j] = a[i][j] + b[i][j]\n            else:\n                a[i][j] = a[i][j] + b[i][j]\n    return a\n\ndef add_tuples_recursive(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return a + b\n    else:\n        return add_tuples_recursive(a[0:len(a) - 1], b[0:len(b) - 1]) + [a[len(a) - 1] + b[len(b) - 1]]\n\ndef add_tuples_recursive_2(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return a + b\n    else:\n        return add_tuples_recursive_2(a[0:len(a) - 1], b[0:len(b) - 1]) + [a[len(a) - 1] + b[len(b) - 1]]\n\ndef add_tuples_recursive_3(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return a + b\n    else:\n        return add_tuples_recursive_3(a[0:len(a) - 1], b[0:len(b) - 1]) + [a[len(a) - 1] + b[len(b) - 1]]\n\ndef add_tuples_recursive_4(a, b):\n    if len(a) == 0 or len(b) == 0:\n        return a + b\n    else:\n        return add_tuples_recursive_4(a[0:len(a) - 1], b[0:len(b) - 1]) + [a[len(a) - 1] + b[len(b) - 1]]\n\ndef add_tuples_recursive_5(a, b):\n    if"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "def add_tuples(a, b):\n    \"\"\"\n    Add two nested tuples.\n\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple([(a[i] + b[i]) for i in range(len(a))])\n\ndef add_tuples_2(a, b):\n    \"\"\"\n    Add two nested tuples.\n\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple([(a[i] + b[i]) for i in range(len(a))])\n\ndef add_tuples_3(a, b):\n    \"\"\"\n    Add two nested tuples.\n\n    :type a: tuple\n    :type b: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple([(a[i] + b[i]) for i in range(len(a))])\n\n\n# Your add_tuples function will be called like this:\n# a = add_tuples(a,b)"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "import collections\n\n\ndef add_tuple(t1, t2):\n    return collections.OrderedDict(zip(t1, t2))\n\n\nif __name__ == '__main__':\n    t1 = (1, 2)\n    t2 = (3, 4)\n    assert add_tuple(t1, t2) == (1, 2, 3, 4)\n    t1 = (1, 2, 3)\n    t2 = (3, 4, 5)\n    assert add_tuple(t1, t2) == (1, 2, 3, 4, 5)\n    t1 = (1, 2, 3, 4)\n    t2 = (5, 6, 7, 8)\n    assert add_tuple(t1, t2) == (1, 2, 3, 4, 5, 6, 7, 8)"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import unittest\n\n\ndef add_tuples(first, second):\n    \"\"\"\n    :type first: tuple\n    :type second: tuple\n    :rtype: tuple\n    \"\"\"\n    return tuple(first) + tuple(second)\n\n\nclass TestExample(unittest.TestCase):\n    def test_add_tuples(self):\n        first = (1, 2, 3)\n        second = (4, 5, 6)\n        expected = (1, 2, 3, 4, 5, 6)\n        self.assertEqual(add_tuples(first, second), expected)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def add(self, lhs, rhs):\n        \"\"\"\n        :type lhs: List[List[int]]\n        :type rhs: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(lhs) == 0 or len(rhs) == 0:\n            return []\n\n        ret = []\n\n        for i in range(len(lhs[0])):\n            ret.append([0 for _ in range(len(rhs[0]))])\n\n        for i in range(len(lhs)):\n            for j in range(len(rhs)):\n                ret[i][j] = lhs[i][j] + rhs[j][i]\n\n        return ret"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {Tuple[]} nestedTuple1\n    # @param {Tuple[]} nestedTuple2\n    # @return {Tuple[]}\n    def add(self, nestedTuple1, nestedTuple2):\n        return [x + y for x, y in zip(nestedTuple1, nestedTuple2)]\n\nif __name__ == \"__main__\":\n    s = Solution()\n    a = (1, 2, 3, 4)\n    b = (5, 6, 7, 8)\n    print(s.add(a, b))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from collections import namedtuple\n\n# tuple_list is a list of nested tuples\n\ntuple_list = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list2 is a list of tuples\n\ntuple_list2 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list3 is a list of nested tuples\n\ntuple_list3 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list4 is a list of tuples\n\ntuple_list4 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list5 is a list of tuples\n\ntuple_list5 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list6 is a list of tuples\n\ntuple_list6 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list7 is a list of tuples\n\ntuple_list7 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list8 is a list of tuples\n\ntuple_list8 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list9 is a list of tuples\n\ntuple_list9 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list10 is a list of tuples\n\ntuple_list10 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list11 is a list of tuples\n\ntuple_list11 = [\n    (1, (2, 3)),\n    (4, (5, 6))\n]\n\n# tuple_list12 is a list of tuples\n\ntuple_list12 ="
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def __init__(self):\n        self.ans = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n\n    def add(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[List[int]]\n        :type nums2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len("
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def add(self, lhs, rhs):\n        \"\"\"\n        :type lhs: List[Tuple[int, int]]\n        :type rhs: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        # lhs, rhs = self.to_tuples(lhs, rhs)\n        # return self.sum(lhs, rhs)\n        return self.sum_tuples(lhs, rhs)\n\n    def to_tuples(self, lhs, rhs):\n        \"\"\"\n        Convert lhs and rhs to tuples.\n        :type lhs: List[Tuple[int, int]]\n        :type rhs: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        lhs = [tuple(x) for x in lhs]\n        rhs = [tuple(x) for x in rhs]\n        return lhs + rhs\n\n    def sum_tuples(self, lhs, rhs):\n        \"\"\"\n        Sum lhs and rhs as tuples.\n        :type lhs: List[Tuple[int, int]]\n        :type rhs: List[Tuple[int, int]]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        lhs = [tuple(x) for x in lhs]\n        rhs = [tuple(x) for x in rhs]\n        return lhs + rhs\n\n\nif __name__ == '__main__':\n    s = Solution()\n    lhs = [(1, 2), (3, 4)]\n    rhs = [(2, 3), (4, 5)]\n    print(s.add(lhs, rhs))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "import random\nimport collections\n\n\ndef add_tuples(a, b):\n    \"\"\"\n    :type a: List[Tuple[int, int]]\n    :type b: List[Tuple[int, int]]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    result = []\n    for a_tuple, b_tuple in zip(a, b):\n        result.append((a_tuple[0] + b_tuple[0], a_tuple[1] + b_tuple[1]))\n    return result\n\n\ndef test_add_tuples():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6), (7, 8)]\n    assert add_tuples(a, b) == [(4, 10), (11, 18)]\n\n\ndef test_add_tuples2():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6)]\n    assert add_tuples(a, b) == [(4, 10)]\n\n\ndef test_add_tuples3():\n    a = [(1, 2)]\n    b = [(5, 6)]\n    assert add_tuples(a, b) == [(6, 6)]\n\n\ndef test_add_tuples4():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6), (7, 8)]\n    assert add_tuples(a, b) == [(4, 10), (11, 18)]\n\n\ndef test_add_tuples5():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6), (7, 8)]\n    assert add_tuples(a, b) == [(4, 10), (11, 18)]\n\n\ndef test_add_tuples6():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6)]\n    assert add_tuples(a, b) == [(4, 10)]\n\n\ndef test_add_tuples7():\n    a = [(1, 2), (3, 4)]\n    b = [(5, 6)]\n    assert add_tuples("
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def add(self, num1, num2):\n        \"\"\"\n        :type num1: List[List[int]]\n        :type num2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def rec(num1, num2):\n            if not num1 or not num2:\n                return num1 + num2\n            if not num1[0]:\n                return rec(num2, num1[1:])\n            if not num2[0]:\n                return rec(num1, num2[1:])\n            if num1[0] < num2[0]:\n                return rec(num1[1:], num2[1:])\n            if num1[0] > num2[0]:\n                return rec(num1[1:], num2[1:])\n            return rec(num1[1:], num2[1:]) + [num1[0] + num2[0]]\n\n        return rec(num1, num2)\n\n\nif __name__ == \"__main__\":\n    assert Solution().add([1], [2]) == [[3]]\n    assert Solution().add([1], [1]) == [[2]]\n    assert Solution().add([1, 2], [1]) == [[3, 2]]\n    assert Solution().add([1, 2], [3]) == [[4, 3]]"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def add(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if a is None or b is None:\n            return None\n        res = []\n        for i in range(len(a)):\n            res.append([])\n            for j in range(len(a[i])):\n                res[i].append(a[i][j] + b[i][j])\n        return res\n\n    def add1(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if a is None or b is None:\n            return None\n        res = []\n        for i in range(len(a)):\n            res.append([])\n            for j in range(len(a[i])):\n                res[i].append(a[i][j] + b[i][j])\n        return res\n\n    def add2(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if a is None or b is None:\n            return None\n        res = []\n        for i in range(len(a)):\n            res.append([])\n            for j in range(len(a[i])):\n                res[i].append(a[i][j] + b[i][j])\n        return res\n\n    def add3(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if a is None or b is None:\n            return None\n        res = []\n        for i in range(len(a)):\n            res.append([])\n            for j in range(len(a[i])):\n                res["
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    # @param {tuple} a\n    # @param {tuple} b\n    # @return {tuple}\n    def add(self, a, b):\n        if not a:\n            return b\n        elif not b:\n            return a\n        else:\n            return tuple(a[0] + b[0]) + tuple(a[1] + b[1]) + tuple(a[2] + b[2]) + tuple(a[3] + b[3])\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/add-two-numbers/solution/\n\n# TLE\nclass Solution {\n    public int[] add(int[] a, int[] b) {\n        int[] result = new int[a.length];\n        for (int i = 0; i < a.length; i++) {\n            result[i] = a[i] + b[i];\n        }\n        return result;\n    }\n}\n\n# TLE\nclass Solution {\n    public int[] add(int[] a, int[] b) {\n        int[] result = new int[a.length];\n        for (int i = 0; i < a.length; i++) {\n            result[i] = a[i] + b[i];\n        }\n        return result;\n    }\n}\n\n# TLE\nclass Solution {\n    public int[] add(int[] a, int[] b) {\n        int[] result = new int[a.length];\n        for (int i = 0; i < a.length; i++) {\n            result[i] = a[i] + b[i];\n        }\n        return result;\n    }\n}\n\n# TLE\nclass Solution {\n    public int[] add(int[] a, int[] b) {\n        int[] result = new int[a.length];\n        for (int i = 0;"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from collections import namedtuple\nfrom typing import List, Tuple\n\n# @include\ndef add_tuple_elements(lhs: List[Tuple[int,...]], rhs: List[Tuple[int,...]]) -> List[Tuple[int,...]]:\n  result = []\n  for lhs_tuple in lhs:\n    result.append(tuple(map(lambda x: lhs_tuple[0] + x, rhs)))\n  return result\n# @exclude\n\n\ndef simple_test():\n    A = namedtuple(\"A\", \"x y\")\n    B = namedtuple(\"B\", \"x y z\")\n    C = namedtuple(\"C\", \"x y z w\")\n    assert add_tuple_elements([A(1, 2), A(3, 4)], [B(1, 2), B(3, 4)]) == [\n        A(4, 6),\n        A(7, 8),\n        A(9, 10),\n        A(11, 12),\n        A(13, 14),\n        A(15, 16),\n    ]\n\n\nif __name__ == \"__main__\":\n    simple_test()"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/add-root-to-node-in-binary-tree/discuss/257978/Python-Solution\n# https://leetcode.com/problems/add-root-to-node-in-binary-tree/discuss/257978/Python-Solution\n\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def addOneRow(self, root, n):\n        \"\"\"\n        :type root: TreeNode\n        :type n: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return root\n        if n == 0:\n            return root\n        if n == 1:\n            return TreeNode(root.val, root.left, root.right)\n        if root.left:\n            return self.addOneRow(root.left, n - 1)\n        if root.right:\n            return self.addOneRow(root.right, n - 1)\n        return root"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-tostring/problem\n\nimport unittest\n\nclass TupleToString(unittest.TestCase):\n    def test_tuple_to_string(self):\n        \"\"\"\n        Write a function that takes two tuples as input and returns a string representation of the input tuple.\n        \"\"\"\n        self.assertEqual(\"(1, 2)\", tuple_to_string((1, 2)))\n        self.assertEqual(\"(1, (2, 3))\", tuple_to_string((1, (2, 3))))\n        self.assertEqual(\"(1, (2, (3, 4)))\", tuple_to_string((1, (2, (3, 4)))))\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import unittest\n\n\nclass Solution:\n    def add(self, lhs: tuple, rhs: tuple) -> tuple:\n        \"\"\"\n        :type lhs: tuple\n        :type rhs: tuple\n        :rtype: tuple\n        \"\"\"\n        for i, l in enumerate(lhs):\n            r = rhs[i]\n            if isinstance(l, tuple) and isinstance(r, tuple):\n                l = self.add(l, r)\n            else:\n                l += r\n            lhs[i] = l\n        return lhs\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([(1, 2), (3, 4)], [3, 7])\n        self._test([(1, 2), (3, 4)], [2, 4])\n        self._test([(1, 2), (3, 4)], [1, 4])\n\n    def _test(self, lhs, rhs):\n        actual = Solution().add(lhs, rhs)\n        self.assertEqual(actual, tuple(lhs + rhs))\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/tuple-addition/problem\n\n\n# https://www.hackerrank.com/challenges/tuple-addition/submissions/code/2717095\n\ndef tuple_addition(t1, t2):\n    new_tuple = []\n    for i in range(len(t1)):\n        for j in range(len(t2)):\n            new_tuple.append(tuple_addition(t1[i], t2[j]))\n    return tuple(new_tuple)\n\n\n# https://www.hackerrank.com/challenges/tuple-addition/submissions/code/2717095\n\n\n# https://www.hackerrank.com/challenges/tuple-addition/submissions/code/2717095\n\ndef tuple_addition_2(t1, t2):\n    new_tuple = []\n    for i in range(len(t1)):\n        for j in range(len(t2)):\n            new_tuple.append(tuple_addition_2(t1[i], t2[j]))\n    return tuple(new_tuple)\n\n\n# https://www.hackerrank.com/challenges/tuple-addition/submissions/code/2717095\n\ndef tuple_addition_3(t1, t2):\n    new_tuple = []\n    for i in range(len(t1)):\n        for j in range(len(t2)):\n            new_tuple.append(tuple_addition_3(t1[i], t2[j]))\n    return tuple(new_tuple)\n\n\n# https://www.hackerrank.com/challenges/tuple-addition/submissions/code/2717095\n\ndef tuple_addition_4(t1, t2):\n    new_tuple = []\n    for i in range(len(t1)):\n        for j in range(len(t2)):\n            new_tuple.append(tuple_addition_4(t1[i], t2["
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "import copy\n\ndef add_tuples(left_tuple, right_tuple):\n    \"\"\"\n    Add tuple elements of left_tuple and right_tuple element by element.\n    :type left_tuple: tuple\n    :type right_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i, (l, r) in enumerate(zip(left_tuple, right_tuple)):\n        result.append((l + r) if i else (l or r))\n    return tuple(result)\n\ndef add_tuples_2(left_tuple, right_tuple):\n    \"\"\"\n    Add tuple elements of left_tuple and right_tuple element by element.\n    :type left_tuple: tuple\n    :type right_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i, (l, r) in enumerate(zip(left_tuple, right_tuple)):\n        result.append((l or r) if i else (l + r))\n    return tuple(result)\n\ndef add_tuples_3(left_tuple, right_tuple):\n    \"\"\"\n    Add tuple elements of left_tuple and right_tuple element by element.\n    :type left_tuple: tuple\n    :type right_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i, (l, r) in enumerate(zip(left_tuple, right_tuple)):\n        result.append((l or r) if i else (l + r))\n    return tuple(result)\n\ndef add_tuples_4(left_tuple, right_tuple):\n    \"\"\"\n    Add tuple elements of left_tuple and right_tuple element by element.\n    :type left_tuple: tuple\n    :type right_tuple: tuple\n    :rtype: tuple\n    \"\"\"\n    result = []\n    for i, (l, r) in enumerate(zip(left_tuple, right_tuple)):\n        result.append((l or r) if i else (l + r))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def add(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not a or not b:\n            return []\n        res = []\n        for i in range(len(a)):\n            res.append([0] * len(b))\n        for i in range(len(a[0])):\n            for j in range(len(b[0])):\n                res[i][j] = a[i][j] + b[i][j]\n        return res\n\n\n# TESTS\nfor a, b, expected in [\n    (([1, 2, 3], [4, 5, 6]), ([7, 8, 9], [10, 11, 12]), [[14, 15, 16], [17, 18, 19]]),\n    (([1, 2, 3], [4, 5, 6]), ([7, 8, 9], [10, 11, 12]), [[14, 15, 16], [17, 18, 19], [22, 23, 24]]),\n    (([1, 2, 3], [4, 5, 6]), ([7, 8, 9], [10, 11, 12, 13]), [[14, 15, 16], [17, 18, 19], [22, 23, 24], [27, 28, 29]]),\n]:\n    sol = Solution()\n    actual = sol.add(a, b)\n    assert actual == expected"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from collections import namedtuple\nfrom operator import add\n\n\ndef add_tuples(t1, t2):\n    return namedtuple('Sum', t1.__slots__)(*[getattr(t1, i) + getattr(t2, i) for i in t1.__slots__])\n\n\ndef test_add_tuples():\n    t1 = (1, 2, 3)\n    t2 = (4, 5, 6)\n    assert add_tuples(t1, t2)._asdict() == {'a': 5, 'b': 7, 'c': 9}\n\n\nif __name__ == '__main__':\n    test_add_tuples()"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "class Solution:\n    def add(self, a: tuple, b: tuple) -> tuple:\n        \"\"\"\n        :type a: tuple\n        :type b: tuple\n        :rtype: tuple\n        \"\"\"\n        return tuple(sum(x, y) for x, y in zip(a, b))\n\n    def test(self) -> None:\n        a = (1, 2, 3)\n        b = (4, 5, 6)\n        assert self.add(a, b) == (5, 7, 9)"
    }
  ]
}