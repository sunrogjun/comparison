{
  "timestamp": "2025-09-14T19:40:52.027653",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 311,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return min(enumerate(nums), key=lambda x:x[1])[0]"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Example\n# Given [1, 2, 3, 4, 5],\n# Return: [0, 2, 4].\n# Note:\n# The returned array does not include value 5.\n# Example 2:\n# Given [1, 2, 2, 3, 5, 8],\n# Return: [0, 1, 2, 5, 7].\n\n# 2017.05.18\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.helper(nums, 0, len(nums))\n\n    def helper(self, nums, start, end):\n        if start == end:\n            return [start]\n        mid = (start + end) / 2\n        if nums[mid] > nums[start]:\n            return self.helper(nums, start, mid)\n        elif nums[mid] < nums[start]:\n            return self.helper(nums, mid+1, end)\n        else:\n            return self.helper(nums, mid+1, end) + [mid]\n\n    def findMin2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.helper(nums, 0, len(nums))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values-in-a-sorted-array/problem\n# Time complexity: O(n)\n# Space complexity: O(1)\n# Runtime: 20 ms, faster than 60.00% of python submissions.\n\ndef find_min_index(arr):\n    return arr.index(min(arr))\n\narr = [3, 1, 4, 2]\nprint(find_min_index(arr))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values\n\ndef find_index_of_min(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    if len(arr) == 0:\n        return []\n\n    arr = sorted(arr)\n    min_index = 0\n    min_value = arr[0]\n\n    for index, value in enumerate(arr):\n        if value < min_value:\n            min_index = index\n            min_value = value\n\n    return [min_index, min_value]\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    print(find_index_of_min(arr))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return min(range(len(nums)), key=lambda x: nums[x])\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.findMinIndex([1,3,4,5,6])\n    print sol.findMinIndex([1,3,4,5,6])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex([1,2,3,4,5])\n    print sol.findMinIndex(["
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # DP\n        nums.sort()\n        min_nums = [0] * len(nums)\n        min_nums[0] = nums[0]\n        for i in xrange(1, len(nums)):\n            if nums[i] < min_nums[i-1]:\n                min_nums[i] = nums[i]\n            else:\n                min_nums[i] = min_nums[i-1]\n\n        return min_nums\n\n\nif __name__ == \"__main__\":\n    print Solution().findMin([-2, 1, 3, 4, 5, 6, 7])\n    print Solution().findMin([1, 2, 3, 4, 5, 6])\n    print Solution().findMin([7, 6, 5, 4, 3, 2, 1])"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://www.geeksforgeeks.org/find-index-position-of-minimum-value-in-a-given-list/\n# https://www.geeksforgeeks.org/find-index-position-of-minimum-value-in-a-given-list/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www.geeksforgeeks.org/find-minimum-value-in-a-given-list-with-a-given-number-of-numbers/\n# https://www"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values\n\ndef find_min_values(array):\n    \"\"\"\n    :param array: An array of integers\n    :return: A list of indices of the minimum values\n    \"\"\"\n\n    # Initialize a list of minimum indices\n    min_indices = []\n\n    # Sort the array\n    sorted_array = sorted(array)\n\n    # Find the minimum value and add it to the list of minimum indices\n    min_index = 0\n    min_value = sorted_array[0]\n    for index in range(1, len(sorted_array)):\n        if sorted_array[index] < min_value:\n            min_value = sorted_array[index]\n            min_index = index\n\n    # Add the minimum indices to the list\n    min_indices.append(min_index)\n\n    # Add the remaining indices to the list\n    for index in range(len(sorted_array), 0, -1):\n        if sorted_array[index - 1] < min_value:\n            min_value = sorted_array[index - 1]\n            min_index = index - 1\n\n        min_indices.append(min_index)\n\n    return min_indices"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.findMin_helper(nums, 0, len(nums))\n\n    def findMin_helper(self, nums, start, end):\n        if start >= end:\n            return []\n\n        mid = start + (end - start) / 2\n        if nums[mid] < nums[start]:\n            return self.findMin_helper(nums, start, mid)\n        else:\n            return self.findMin_helper(nums, mid + 1, end)\n\n# Note:\n# 1. Recursive\n# 2. Use 2 pointers\n# 3. O(n) space"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return repr(self.val)\n\nclass Solution:\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        res = []\n        cur = head\n        while cur:\n            res.append(cur.val)\n            cur = cur.next\n        res.reverse()\n        cur = head\n        for i in range(len(res)):\n            while cur and cur.val > res[i]:\n                cur = cur.next\n            if cur and cur.val == res[i]:\n                cur = cur.next\n        return cur\n\nif __name__ == \"__main__\":\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    print Solution().findMin(head)"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-of-two-arrays\n# https://www.hackerrank.com/challenges/minimum-of-three-arrays\n\n# TODO:\n# 1) Test cases\n# 2) Test cases\n# 3) Test cases\n# 4) Test cases\n# 5) Test cases\n# 6) Test cases\n# 7) Test cases\n\n# TODO:\n# 1) Test cases\n# 2) Test cases\n# 3) Test cases\n# 4) Test cases\n# 5) Test cases\n# 6) Test cases\n# 7) Test cases\n# 8) Test cases\n# 9) Test cases\n# 10) Test cases\n# 11) Test cases\n# 12) Test cases\n# 13) Test cases\n# 14) Test cases\n# 15) Test cases\n# 16) Test cases\n# 17) Test cases\n# 18) Test cases\n# 19) Test cases\n# 20) Test cases\n# 21) Test cases\n# 22) Test cases\n# 23) Test cases\n# 24) Test cases\n# 25) Test cases\n# 26) Test cases\n# 27) Test cases\n# 28) Test cases\n# 29) Test cases\n# 30) Test cases\n# 31) Test cases\n# 32) Test cases\n# 33) Test cases\n# 34) Test cases\n# 35) Test cases\n# 36) Test cases\n# 37) Test cases\n# 38) Test cases\n# 39) Test cases\n# 40) Test cases\n# 41) Test cases\n# 42) Test cases\n# 43) Test cases\n# 44) Test cases\n# 45) Test cases\n# 46) Test cases\n# 47) Test cases\n# 48) Test cases\n# 49) Test cases\n# 50) Test cases\n# 51) Test cases\n# 52) Test cases\n# 53) Test cases\n# 54) Test cases\n# 55) Test cases\n# 56) Test cases\n# 57) Test cases\n# 58) Test cases\n# 59) Test cases\n# 60) Test cases\n# 61) Test cases\n# 62) Test cases\n# 63) Test cases\n# 64) Test cases\n# 65) Test cases\n# 66) Test cases\n# 67) Test cases\n# 68) Test cases\n# 69)"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            if nums[i] < nums[-1]:\n                res.append(i)\n        return res\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.findMin([1,2,3,4,5,6,7])"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-minimum-in-a-list/problem\n# https://www.hackerrank.com/challenges/find-minimum-in-a-list/submissions/code/373813\n\ndef find_min(arr):\n    # Your code here\n    if len(arr) == 0:\n        return -1\n    if len(arr) == 1:\n        return arr[0]\n    min_index = 0\n    for i in range(len(arr)):\n        if arr[i] < arr[min_index]:\n            min_index = i\n    return min_index\n\nif __name__ == '__main__':\n    arr = [1, 3, 5, 7, 9, 10, 12, 15, 20]\n    print(find_min(arr))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values/problem\n# https://www.hackerrank.com/challenges/minimum-values/submissions/code/285913\n\ndef minimum_values(list_of_numbers):\n    # Your code here\n    #return min(list_of_numbers)\n    return min(list_of_numbers)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/min-list/problem\n# Time complexity : O(n)\n# Space complexity : O(1)\ndef findMin(myList):\n    # Your code here\n    if len(myList) == 0:\n        return []\n    min = myList[0]\n    min_index = 0\n    for i in range(1, len(myList)):\n        if myList[i] < min:\n            min = myList[i]\n            min_index = i\n    return [min_index]\n\nif __name__ == \"__main__\":\n    print(findMin(myList))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/minimum-values-in-a-sorted-array/\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def minValuePositions(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        min_values = []\n        stack = []\n        for interval in intervals:\n            if not stack:\n                stack.append([interval.start, interval.end])\n            else:\n                if interval.start < stack[-1][0]:\n                    stack.append([interval.start, interval.end])\n                else:\n                    while stack and stack[-1][1] <= interval.start:\n                        stack.pop()\n                    while stack and stack[-1][1] >= interval.start:\n                        stack.pop()\n                    stack.append([interval.start, interval.end])\n        while stack:\n            min_values.append(stack.pop()[0])\n        return min_values"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/minimum-in-rotated-sorted-array/\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        nums.reverse()\n        return [i for i, x in enumerate(nums) if x == nums[i]]\n\n\nif __name__ == '__main__':\n    print Solution().findMin([1, 2, 3, 4, 5, 6])"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-of-a-given-list\n\n# Complete the minimumIndexes function below.\ndef minimumIndexes(nums):\n    # Complete this function\n    min_indexes = []\n    for i in range(len(nums)):\n        if nums[i] < nums[min_indexes[0]]:\n            min_indexes[0] = i\n    for i in range(len(nums)):\n        if nums[i] < nums[min_indexes[1]]:\n            min_indexes[1] = i\n    for i in range(len(nums)):\n        if nums[i] < nums[min_indexes[2]]:\n            min_indexes[2] = i\n    return min_indexes"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values\n# https://www.hackerrank.com/challenges/minimum-values-part-two\n# https://www.hackerrank.com/challenges/minimum-values-part-three\n# https://www.hackerrank.com/challenges/minimum-values-part-four\n# https://www.hackerrank.com/challenges/minimum-values-part-five\n# https://www.hackerrank.com/challenges/minimum-values-part-six\n# https://www.hackerrank.com/challenges/minimum-values-part-seven\n# https://www.hackerrank.com/challenges/minimum-values-part-eight\n# https://www.hackerrank.com/challenges/minimum-values-part-nine\n# https://www.hackerrank.com/challenges/minimum-values-part-ten\n# https://www.hackerrank.com/challenges/minimum-values-part-eleven\n# https://www.hackerrank.com/challenges/minimum-values-part-twelve\n# https://www.hackerrank.com/challenges/minimum-values-part-thirteen\n# https://www.hackerrank.com/challenges/minimum-values-part-fourteen\n# https://www.hackerrank.com/challenges/minimum-values-part-fifteen\n# https://www.hackerrank.com/challenges/minimum-values-part-sixteen\n# https://www.hackerrank.com/challenges/minimum-values-part-seventeen\n# https://www.hackerrank.com/challenges/minimum-values-part-eighteen\n# https://www.hackerrank.com/challenges/minimum-values-part-nineteen\n# https://www.hackerrank.com/challenges/minimum-values-part-twenty\n# https://www.hackerrank.com/challenges/minimum-values-part-twenty-one\n# https://www.hackerrank.com/challenges/minimum-values-part-twenty-two\n# https://www.hackerrank.com/challenges/minimum"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "# Example 1\n# Input: [1,2,3,4,5,6]\n# Output: [0,1,3,4,5,6]\n\n# Example 2\n# Input: [1,2,3,4,5,6]\n# Output: [0,0,0,0,0,0]\n\n# Example 3\n# Input: [1,2,3,4,5,6]\n# Output: [0,0,0,0,0,0]\n\ndef find_min_index(list):\n    min_val = min(list)\n    min_index = 0\n    for i in range(len(list)):\n        if list[i] < min_val:\n            min_index = i\n            min_val = list[i]\n    return min_index\n\nif __name__ == '__main__':\n    test_list = [1,2,3,4,5,6]\n    print find_min_index(test_list)\n    print find_min_index(test_list)\n    print find_min_index(test_list)"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef find_min_index(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    res = defaultdict(int)\n    for i in range(len(nums)):\n        res[nums[i]] += 1\n    res = [v for k, v in res.items() if v == 1]\n    return res\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 3, 4, 4, 5]\n    print(find_min_index(nums))"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "# https://www.youtube.com/watch?v=9d9Q8d_pj1M\n# https://www.youtube.com/watch?v=oL_aHk0zCcM\n\ndef find_min_index(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    min_value = arr[0]\n    min_index = 0\n    for i in range(len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n            min_index = i\n    return min_index\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_min_index(arr))\n    print(find_min_index(arr[::-1]))\n    print(find_min_index(arr[1:3]))"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "#!/usr/bin/python\n\n# write your code here\n\n# Example:\n# Input: [3, 2, 5, 1, 6, 4]\n# Output: [0, 2, 4]\n\ndef find_min_index(nums):\n    return [i for i, x in enumerate(nums) if x == min(nums)]\n\nif __name__ == '__main__':\n    nums = [3, 2, 5, 1, 6, 4]\n    print(find_min_index(nums))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_min_index(list_of_numbers):\n    \"\"\"\n    Finds the index of the minimum value in a list.\n\n    :param list_of_numbers: The list to be searched.\n    :return: The index of the minimum value.\n    \"\"\"\n    return min(enumerate(list_of_numbers), key=lambda x: x[1])[0]\n\ndef min_count(list_of_numbers):\n    \"\"\"\n    Finds the number of values in a list that are equal to the minimum value.\n\n    :param list_of_numbers: The list to be searched.\n    :return: The number of times the minimum value is found.\n    \"\"\"\n    return sum(1 for x in list_of_numbers if x == min(list_of_numbers))\n\ndef min_count_iterative(list_of_numbers):\n    \"\"\"\n    Finds the number of values in a list that are equal to the minimum value.\n\n    :param list_of_numbers: The list to be searched.\n    :return: The number of times the minimum value is found.\n    \"\"\"\n    return sum(1 for x in list_of_numbers if x == min(list_of_numbers))\n\ndef test_min_count():\n    assert min_count([1, 2, 3, 4, 5, 6]) == 2\n    assert min_count_iterative([1, 2, 3, 4, 5, 6]) == 2\n    assert min_count([1, 2, 3, 4, 5, 6]) == 2\n\ndef test_find_min_index():\n    assert find_min_index([1, 2, 3, 4, 5, 6]) == 1\n    assert find_min_index([1, 2, 3, 4, 5, 6]) == 1\n    assert find_min_index([1, 2, 3, 4, 5, 6]) == 1\n\ndef test_min_count_iterative():\n    assert min_count_iterative([1, 2, 3, 4, 5, 6]) == 2\n    assert min_count_iterative([1, 2, 3, 4, 5, 6]) == 2"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "# This is the standard library module that has to be used\nimport math\n\n# Define a function\ndef find_index(list, target):\n    \"\"\"\n    Find the index of the minimum value in the given list.\n\n    Args:\n        list: A list of numbers\n        target: The minimum value to be found\n\n    Returns:\n        An array containing the indices of the minimum values in the given list.\n\n    Examples:\n        >>> find_index([2, 5, -1, -2], -2)\n        [1]\n        >>> find_index([2, 5, -1, -2], 4)\n        []\n    \"\"\"\n\n    # Create a list to hold the indices of the minimum values\n    indices = []\n\n    # Iterate over the list\n    for i in range(len(list)):\n\n        # If the current value is smaller than the target value\n        if list[i] < target:\n            # Add the index to the indices list\n            indices.append(i)\n\n    # Return the indices list\n    return indices\n\n# Test the function\nprint(find_index([2, 5, -1, -2], -2))"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\ndef find_min_index(arr):\n    \"\"\"\n    Given an array arr, return a tuple of (min_index, min_value)\n    where min_value is the minimum value in the array.\n    \"\"\"\n    min_index = 0\n    min_value = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < min_value:\n            min_value = arr[i]\n            min_index = i\n    return (min_index, min_value)\n\n\ndef main():\n    arr = [3, 4, 5, 1, 3, 6, 7, 8, 9]\n    min_index, min_value = find_min_index(arr)\n    print min_index, min_value\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    min_index, min_value = find_min_index(arr)\n    print min_index, min_value\n\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    min_index, min_value = find_min_index(arr)\n    print min_index, min_value\n    \nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def find_min_index(arr):\n    \"\"\"\n    Input: arr is a list of integers.\n    Output: return a list of the index positions of the minimum value.\n    \"\"\"\n    return min(range(len(arr)), key=lambda i: arr[i])\n\n\ndef find_min_index_2(arr):\n    \"\"\"\n    Input: arr is a list of integers.\n    Output: return a list of the index positions of the minimum value.\n    \"\"\"\n    return min(range(len(arr)), key=lambda i: arr[i], reverse=True)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    print(find_min_index(arr))\n    print(find_min_index_2(arr))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\n\nclass Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def findMin(self, num):\n        result = []\n        if len(num) == 0:\n            return result\n        left = 0\n        right = len(num) - 1\n        while left <= right:\n            if num[left] < num[right]:\n                result.append(left)\n            elif num[left] > num[right]:\n                result.append(right)\n            else:\n                result.append(left)\n            if num[left] < num[right]:\n                left += 1\n            else:\n                right -= 1\n        return result\n\nif __name__ == '__main__':\n    print Solution().findMin([2, 1, 3, 4, 5, 4, 2, 3])"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def findMinIndex(array):\n    \"\"\"\n    :type array: List[int]\n    :rtype: List[int]\n    \"\"\"\n    min = array[0]\n    min_index = 0\n    for i in range(1, len(array)):\n        if array[i] < min:\n            min = array[i]\n            min_index = i\n    return min_index\n\nif __name__ == \"__main__\":\n    assert findMinIndex([2, 1, 3, 4, 3]) == 1\n    assert findMinIndex([2, 3, 1, 3, 4]) == 2\n    assert findMinIndex([1, 2, 3]) == 0\n    assert findMinIndex([1, 2, 3, 4, 5]) == 0\n    assert findMinIndex([1, 2, 3, 4, 5, 6]) == 1\n    assert findMinIndex([1, 2, 3, 4, 5, 6, 7]) == 2\n    assert findMinIndex([1, 2, 3, 4, 5, 6, 7, 8]) == 3\n    assert findMinIndex([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 4"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\n\"\"\"\nInput:\n- arr: a list of integers\n- k: an integer\n\nOutput:\n- a list of indices\n\"\"\"\ndef find_min_idx(arr, k):\n    \n    # If there are less than k elements, then return an empty list\n    if len(arr) < k:\n        return []\n    \n    # Initialize min_idx as the first index\n    min_idx = 0\n    \n    # Iterate over arr to find the minimum value\n    for idx in range(len(arr)):\n        if arr[idx] < arr[min_idx]:\n            min_idx = idx\n    \n    # Return the index positions of the minimum value\n    return [min_idx] + find_min_idx(arr[min_idx+1:], k-1)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from collections import Counter\nfrom collections import defaultdict\n\ndef find_min_index(arr):\n    return min(enumerate(arr), key=lambda x: x[1])[0]\n\ndef find_min_index_set(arr):\n    return min(Counter(arr).iteritems(), key=lambda x: x[1])[0]\n\ndef find_min_index_dict(arr):\n    return min(defaultdict(int).fromkeys(arr), key=lambda x: x[1])[0]\n\ndef find_min_index_list(arr):\n    return min(arr, key=lambda x: x[0])[0]\n\ndef find_min_index_list2(arr):\n    return min(arr, key=lambda x: x[1])[0]\n\nif __name__ == '__main__':\n    arr = [1, 1, 1, 2, 2, 2]\n    print find_min_index(arr)\n    print find_min_index_set(arr)\n    print find_min_index_list(arr)\n    print find_min_index_dict(arr)\n    print find_min_index_list2(arr)"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def find_min_index(l):\n    \"\"\"\n    :type l: List[int]\n    :rtype: List[int]\n    \"\"\"\n    res = []\n    for i in range(len(l)):\n        if l[i] < l[0]:\n            res.append(i)\n    return res\n\nif __name__ == \"__main__\":\n    l = [1, 2, 3, 4, 5, 6]\n    print(find_min_index(l))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "import unittest\nfrom collections import defaultdict\n\n# O(n)\ndef find_min_index(nums):\n    min_index = defaultdict(list)\n    for i in range(len(nums)):\n        min_index[nums[i]].append(i)\n    return min_index\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(find_min_index([1,3,2,2,4]), {1:[0], 3:[1], 2:[2], 4:[3]})\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.min_index(nums)\n\n    def min_index(self, nums):\n        if len(nums) == 0:\n            return []\n\n        min_index = []\n        for i in range(len(nums)):\n            if i == 0:\n                min_index.append(0)\n                continue\n            if nums[i] < nums[i-1]:\n                min_index.append(i)\n            else:\n                min_index.append(i-1)\n        return min_index\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,3,2,1]\n    print(sol.findMin(nums))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        min_value = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < min_value:\n                min_value = nums[i]\n                ret.append(i)\n        return ret\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.findMin([2, 1, 1, 3, 4, 2])"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        nums.sort()\n        return [i for i, v in enumerate(nums) if v == nums[i]]"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def find_min_index(L):\n    \"\"\"\n    :type L: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(L) == 0:\n        return []\n    \n    if len(L) == 1:\n        return [0]\n    \n    min_value = min(L)\n    \n    # Find the first index where the value is equal to the minimum value\n    for i in range(len(L)):\n        if L[i] == min_value:\n            return [i]\n    \n    # If there is no index where the value is equal to the minimum value, \n    # then return the index where the value is the smallest\n    return [0]"
    },
    {
      "rank": 38,
      "score": 4.0,
      "candidate": "import collections\n\ndef find_minimums(lst):\n    \"\"\"\n    :type lst: List[int]\n    :rtype: List[int]\n    \"\"\"\n    \n    return [i for i, v in enumerate(lst) if v == min(lst[:i])]\n\n# Your FindMinimums object will be instantiated and called as such:\n# obj = FindMinimums(lst)\n# param_1 = obj.find_minimums(lst)"
    },
    {
      "rank": 39,
      "score": 4.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(nums)):\n            if i == 0:\n                if nums[i] < nums[i + 1]:\n                    res.append(i)\n                    res.append(i + 1)\n            elif i == len(nums) - 1:\n                if nums[i] < nums[i - 1]:\n                    res.append(i)\n                    res.append(i - 1)\n            else:\n                if nums[i] < nums[i + 1]:\n                    res.append(i)\n                elif nums[i] < nums[i - 1]:\n                    res.append(i)\n                elif nums[i - 1] < nums[i]:\n                    res.append(i - 1)\n                elif nums[i + 1] < nums[i]:\n                    res.append(i + 1)\n        return res\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/minimum-values-in-a-sorted-array/solution/\n#\nApproach 1: Sort and Find Minimum\nComplexity Analysis\nTime Complexity: O(n log n), where n is the length of the input array.\nSpace Complexity: O(n log n).\n\n# 4ms 100%\nclass Solution {\n    public List<Integer> findMin(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0) {\n                if (nums[i] < nums[i + 1]) {\n                    res.add(i);\n                    res.add(i + 1);"
    },
    {
      "rank": 40,
      "score": 2.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMinIndex(self, nums):\n        n = len(nums)\n        if n == 0:\n            return []\n\n        if n == 1:\n            return [0]\n\n        # find min value\n        min_value = nums[0]\n        for i in range(1, n):\n            if nums[i] < min_value:\n                min_value = nums[i]\n\n        # find min index\n        min_index = 0\n        for i in range(1, n):\n            if nums[i] < min_value:\n                min_index = i\n                min_value = nums[i]\n        return [min_index]\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [2, 3, 1, 2, 4, 5, 3]\n    print(sol.findMinIndex(nums))"
    },
    {
      "rank": 41,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n\n# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/102698/Python-solution-with-explanation-and-examples\n\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @return a list of integers\n    def findMin(self, intervals):\n        if not intervals:\n            return []\n\n        if len(intervals) == 1:\n            return [0]\n\n        result = []\n        i = 0\n        while i < len(intervals):\n            if intervals[i].end < intervals[i + 1].start:\n                result.append(intervals[i].start)\n                i += 2\n            else:\n                i += 1\n\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().findMin([Interval(0, 3), Interval(2, 5), Interval(1, 7)]) == [0, 1, 2]\n    assert Solution().findMin([Interval(0, 3), Interval(2, 5), Interval(1, 7)]) == [0, 1, 2]\n    assert Solution().findMin([Interval(0, 3), Interval(2, 5), Interval(1, 7)]) == [0, 1, 2]"
    },
    {
      "rank": 42,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            cur = cur.next\n            while cur:\n                if cur.next:\n                    cur = cur.next\n                    while cur and cur.val < cur.next.val:\n                        cur = cur.next\n                else:\n                    return cur\n        return head\n\n    def findMin_1(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            cur = cur.next\n            while cur:\n                if cur.next:\n                    cur = cur.next\n                    while cur and cur.val < cur.next.val:\n                        cur = cur.next\n                    cur = cur.next\n                else:\n                    return cur\n        return head\n\n    def findMin2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            cur = cur.next\n            while cur:\n                if cur.next:\n                    cur = cur.next\n                    while cur and cur.val < cur.next.val:\n                        cur = cur.next\n                else:\n                    return cur\n        return head"
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/290027/Python-Solution-with-O(n)-Time-and-Space\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        ans = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                ans.append(i)\n        return ans"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-values-in-a-sorted-array/\n# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n#         self.start_inc = 0\n#         self.end_inc = 0\n\n# @param intervals, a list of Interval.\n# @return a list of integer, where list[i] represents the start point of the i-th interval.\nclass Solution(object):\n    def minValue(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        if not intervals:\n            return []\n\n        # sort by start\n        intervals.sort(key=lambda x: x.start)\n\n        # find the first interval\n        first = 0\n        while first < len(intervals) and intervals[first].end <= intervals[first].start:\n            first += 1\n\n        # find the last interval\n        last = len(intervals) - 1\n        while last > first and intervals[last].end <= intervals[last].start:\n            last -= 1\n\n        # if there are more than one interval with the same start, we have to consider the start\n        # of the first interval\n        if first < last and intervals[first].start == intervals[last].start:\n            first += 1\n            last -= 1\n\n        # we have to consider the start of the first interval\n        if first < last and intervals[first].start <= intervals[first].end:\n            first += 1\n\n        # we have to consider the end of the last interval\n        if last > first and intervals[last].end <= intervals[last].start:\n            last -= 1\n\n        # we have to consider the end of the last interval\n        if last > first and intervals[last].end <= intervals[last].start:\n            last -= 1\n\n        return [intervals[first].start, intervals[last].end]\n\n\nif __name__ == \"__main__\":\n    assert Solution().minValue([Interval(1, 3), Interval(2, 4), Interval(1,"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "# The list\nlst = [1, 2, 3, 4, 5, 6, 7]\n\n# The function\ndef find_min_index(lst):\n    \"\"\"\n    :param lst: the list\n    :return: the index positions of the minimum values in the list\n    \"\"\"\n    return min(enumerate(lst), key=lambda i: lst[i[0]])\n\n# Test\nprint(find_min_index(lst))"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n# \n# Given a sorted array of integers, find the minimum number of rotations to\n# make all the numbers in the array unique.\n# \n# Example:\n# Input: [2, 3, 1, 1, 5]\n# Output: 2\n# \n# Follow up: Could you optimize your algorithm to use only O(n) extra space?\n# \n# Note:\n# - The number of rotations will be at most equal to the length of the array.\n# - The length of the given array is in the range of [1, 10000].\n# - The input array may contain duplicates, and they are permitted.\n# - The input array may contain 0s, and they are permitted.\n# \n# \n#\n\n# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/93735/Python-O(n)-space-solution-in-2-lines\n# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/93735/Python-O(n)-space-solution-in-2-lines\n# \n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n# \n# score:100(0ms)\n# time:O(n)\n# space:O(1)\n\nclass Solution(object):\n    def findRotateIndex(self, nums):\n        \"\"\"\n        :type nums:"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-in-rotated-sorted-array/\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n\n        # first find the minimum in the first element, then find all the minimums in the next elements\n        minimum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < minimum:\n                minimum = nums[i]\n\n        # find the minimum in the rest of the elements\n        index = 0\n        while index < len(nums):\n            if nums[index] < minimum:\n                minimum = nums[index]\n            index += 1\n\n        return [index] if index < len(nums) else []\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 2, 3]\n    sol = Solution()\n    print(sol.findMin(nums))\n\n    nums = [1, 2, 3, 4]\n    sol = Solution()\n    print(sol.findMin(nums))"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        while slow:\n            fast = slow.next\n            if fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            else:\n                return slow\n        \n        return None"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "def find_minimum_index(list_of_numbers):\n    \"\"\"\n    Write a function that finds the indices of the minimum values in a given list.\n\n    Arguments:\n        list_of_numbers (list): The list of numbers to find the minimum values from.\n\n    Returns:\n        list: The indices of the minimum values in the given list.\n\n    Examples:\n        >>> find_minimum_index([1, 2, 3, 3, 2, 1])\n        [0, 2]\n        >>> find_minimum_index([1, 2, 3, 3, 2, 1, 2])\n        [0, 1, 3]\n        >>> find_minimum_index([1, 2, 3, 3, 2, 1, 2, 3, 4])\n        [0, 1, 2]\n    \"\"\"\n\n    # Your function should return a list of indices.\n    return [i for i, value in enumerate(list_of_numbers) if value == min(list_of_numbers)]"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [0]\n        \n        if len(nums) == 2:\n            return [0, 1]\n        \n        if len(nums) == 3:\n            return [0, 1, 2]\n        \n        if len(nums) == 4:\n            return [0, 1, 2, 3]\n        \n        if len(nums) == 5:\n            return [0, 1, 2, 3, 4]\n        \n        if len(nums) == 6:\n            return [0, 1, 2, 3, 4, 5]\n        \n        if len(nums) == 7:\n            return [0, 1, 2, 3, 4, 5, 6]\n        \n        if len(nums) == 8:\n            return [0, 1, 2, 3, 4, 5, 6, 7]\n        \n        if len(nums) == 9:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        \n        if len(nums) == 10:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        \n        if len(nums) == 11:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        \n        if len(nums) == 12:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        \n        if len(nums) == 13:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n        \n        if len(nums) == 14:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "# Your function will be called as follows:\n# function(nums, low, high)\n#\n# The input parameters will be\n# nums       : A list of integers\n# low         : A low bound on the integers\n# high        : A high bound on the integers\n#\n# The output should be a list of indices that are the minimum values in the input list.\n# If there are multiple answers, you should return them as a list of indices.\n# If there is no answer, return an empty list.\n#\n# Example 1:\n# nums = [1, 2, 3]\n# low = 0\n# high = 4\n#\n# The output should be\n# [0]\n# Example 2:\n# nums = [2, 2, 3, 3, 3, 4]\n# low = 2\n# high = 6\n#\n# The output should be\n# [1, 4]\n#\n\nclass Solution(object):\n    def findMin(self, nums, low, high):\n        \"\"\"\n        :type nums: List[int]\n        :type low: int\n        :type high: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        if low > high:\n            return res\n        mid = low + (high - low) / 2\n        if mid == low:\n            if nums[mid] <= nums[low]:\n                res.append(low)\n            else:\n                res.append(mid)\n            return res\n        if nums[mid] <= nums[low]:\n            res.append(low)\n            if mid < high:\n                res.append(mid)\n            return res\n        if nums[mid] <= nums[high]:\n            res.append(mid)\n            if mid < high:\n                res.append(high)\n            return res\n        res.append(mid)\n        if mid < high:\n            res.append(high)\n        return res\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3]\n    print Solution().findMin(nums, 0, 4)\n    nums = [2, 2, 3, 3, 3, 4]"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        res = ListNode(-1)\n        cur = res\n        cur.next = head\n        prev = None\n        while cur.next is not None:\n            cur = cur.next\n            if prev is None:\n                prev = cur\n            else:\n                if prev.val < cur.val:\n                    prev = cur\n        return res.next"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "import unittest\nfrom collections import Counter\n\n\nclass Solution(object):\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n\n        Time complexity: O(n)\n        Space complexity: O(n)\n        \"\"\"\n        if not nums:\n            return []\n\n        min_idx = 0\n        min_val = nums[0]\n        for idx, num in enumerate(nums):\n            if num < min_val:\n                min_val = num\n                min_idx = idx\n        return [min_idx] if min_val == nums[0] else [min_idx + 1]\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self._test([1, 2, 3, 4, 5], [2, 3, 4])\n\n    def _test(self, nums, expected):\n        actual = Solution().findMinIndex(nums)\n        self.assertEqual(expected, actual)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums, a list of integer\n    # @return an integer\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return -1\n        \n        if n == 1:\n            return 0\n        \n        if n == 2:\n            return nums[0] < nums[1]? 0 : 1\n        \n        l = [0] * n\n        r = [0] * n\n        \n        for i in range(n):\n            l[i] = i\n            r[i] = i\n            \n        for i in range(1, n):\n            if nums[i] < nums[l[i]]:\n                l[i] = r[i]\n            else:\n                r[i] = l[i]\n            \n        # if the minimum is the last element of the list, return the last index\n        if nums[n-1] < nums[r[n-1]]:\n            return r[n-1]\n        else:\n            return l[n-1]"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "import numpy as np\n\ndef find_min_index(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_2(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_3(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_4(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_5(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_6(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    return [min_index]\n\ndef find_min_index_7(arr):\n    \"\"\"\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        list of integers\n    \"\"\"\n    min_value = min(arr)\n    min_index = arr.index(min_"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def findMin(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(num) == 0:\n            return []\n\n        if len(num) == 1:\n            return [0]\n\n        ans = [0]\n        for i in range(len(num)):\n            if num[i] < num[ans[-1]]:\n                ans.append(i)\n            else:\n                while i < len(ans) and num[i] >= num[ans[-1]]:\n                    ans.pop()\n        return ans"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-values-in-a-sorted-matrix/discuss/81865/Python-solution-with-O(n)-time-and-O(1)-space\n\n\nclass Solution(object):\n    def minValues(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        res = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] < matrix[0][j]:\n                    res.append(0)\n                else:\n                    res.append(1)\n        return res"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = [0] * len(nums)\n        res[0] = min(nums)\n        for i in xrange(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                res[i] = res[i-1]\n            else:\n                res[i] = nums[i]\n        return res"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "import unittest\nfrom pythonds.basic.linkedlist import ListNode\n\n#------------------------------------------------------------------------------\n\nclass Solution:\n    \n    # @param head, a ListNode\n    # @return a ListNode\n    def get_min_node(self, head):\n        if not head:\n            return None\n        \n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        min_node = slow\n        \n        while slow:\n            slow = slow.next\n            \n            if not slow:\n                break\n            \n            if min_node.val > slow.val:\n                min_node = slow\n                \n        return min_node\n        \n    # @param head, a ListNode\n    # @return a ListNode\n    def get_min_node_2(self, head):\n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        min_node = head\n        \n        while head.next and head.next.next:\n            if min_node.val > head.next.val:\n                min_node = head.next\n            \n            head = head.next\n        \n        return min_node\n        \n    # @param head, a ListNode\n    # @return a ListNode\n    def get_min_node_3(self, head):\n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        min_node = head\n        \n        while head.next and head.next.next:\n            if min_node.val > head.next.val:\n                min_node = head.next\n            \n            head = head.next\n        \n        return min_node\n        \n    # @param head, a ListNode\n    # @return a ListNode\n    def get_min_node_4(self, head):\n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        if not head.next.next:\n            return head\n        \n        min_node = head\n        \n        while head"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-in-rotated-sorted-array/\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) < 2:\n            return nums\n        nums.sort()\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            if nums[start] > nums[end]:\n                return nums[:end]\n            elif nums[start] < nums[end]:\n                return nums[start:]\n            start += 1\n            end -= 1\n        return nums[start:]\n\n# test\nnums = [4, 6, 7, 7, 8]\nprint(Solution().findMin(nums))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "def find_min_index(list_values):\n    \"\"\"\n    :type list_values: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Complete this function\n    list_values.sort()\n    return [i for i in range(len(list_values)) if list_values[i] == list_values[i]]\n\n\nif __name__ == \"__main__\":\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_min_index([1, -3, 0, -1, 5, 2, 1]) == [0, 1, 2], \"Testcase 1\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 2\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 3\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 4\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 5\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 6\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 7\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Testcase 8\"\n    assert find_min_index([1, 0, -1, -3, 5, 2, 3, 0, -5]) == [0, 1, 2, 3], \"Test"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMinIndex(self, nums):\n        if len(nums) == 0:\n            return []\n\n        res = [0] * len(nums)\n        res[0] = 0\n        res[1] = 0\n\n        for i in range(2, len(nums)):\n            if nums[i] < nums[res[i - 1]]:\n                res[i] = res[i - 1]\n            else:\n                res[i] = i\n        return res"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "import math\nclass Solution:\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        else:\n            min_val = nums[0]\n            min_idx = 0\n            for i in range(1, len(nums)):\n                if nums[i] < min_val:\n                    min_val = nums[i]\n                    min_idx = i\n            return [min_idx]"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.helper(nums, [])\n\n    def helper(self, nums, curr):\n        if len(nums) == 0:\n            return curr\n        if len(nums) == 1:\n            return [0] if nums[0] < curr[0] else curr\n        if len(curr) == 0:\n            return self.helper(nums[1:], [nums[0]])\n        if nums[0] < curr[0]:\n            return self.helper(nums[1:], curr)\n        if nums[0] > curr[-1]:\n            return self.helper(nums[1:], curr + [nums[0]])\n        return curr + [nums[0]]"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def getMinIndex(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        min_val = float(\"inf\")\n        cur_min_val = float(\"inf\")\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node = None\n        cur_min_list = None\n        cur_min_index = -1\n        cur_min_node"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "# Approach:\n# 1. Sort the list and iterate over it.\n# 2. If the current value is smaller than the minimum value, break.\n# 3. If the current value is equal to the minimum value, set the index to the current index.\n# 4. If the current value is greater than the minimum value, keep iterating.\n\n# Runtime: O(n^2)\n# Space: O(n)\n\nclass Solution:\n    # @param nums a list of integers\n    # @return a list of indices\n    def findMin(self, nums):\n        if not nums:\n            return []\n        sorted_nums = sorted(nums)\n        for i in range(len(nums)):\n            if nums[i] < sorted_nums[i]:\n                return [i]\n        return [len(nums) - 1]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.findMin([1, 2, 3, 4, 5]))\n    print(sol.findMin([2, 5, 1, 6, 3]))\n    print(sol.findMin([4, 2, 3, 1, 2]))"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "# https://www.hackerrank.com/challenges/minimum-values-in-a-sorted-list/problem\n\ndef find_min_positions(arr):\n    \"\"\"\n    :param arr: A list of integers.\n    :return: A list of indices that are the minimum values in the given list.\n    \"\"\"\n    # Your code here\n    if len(arr) == 0:\n        return []\n    else:\n        if len(arr) == 1:\n            return [0]\n        elif len(arr) == 2:\n            return [0, 1]\n        elif len(arr) == 3:\n            return [0, 1, 2]\n        else:\n            return find_min_positions(arr[:len(arr) / 2]) + \\\n                   find_min_positions(arr[len(arr) / 2:])"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integer\n    def findMin(self, root):\n        if root is None:\n            return []\n        lists = []\n        self.findMin(root, lists)\n        return lists\n    def findMin(self, root, lists):\n        if root.left is None:\n            lists.append([])\n            return\n        self.findMin(root.left, lists[0])\n        self.findMin(root.right, lists[0])\n        lists[0].append(root.val)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findMin([3,1,2,5,6,7,9,10,15,16,17]))\n    print(s.findMin([3,1,2,5,6,7,9,10,15,16,17,None]))"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMinIndex(self, nums):\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [0, 1]\n\n        min_val = nums[0]\n        min_idx = 0\n        for i in range(1, n):\n            if nums[i] < min_val:\n                min_idx = i\n                min_val = nums[i]\n        return [min_idx] + self.findMinIndex(nums[min_idx + 1:])"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "def find_min_index(nums):\n    if len(nums) == 0:\n        return 0\n\n    min_val = nums[0]\n    min_idx = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            min_idx = i\n\n    return min_idx\n\n\ndef find_min_index_list(nums):\n    if len(nums) == 0:\n        return []\n\n    min_val = nums[0]\n    min_idx = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            min_idx = i\n\n    return [min_idx]\n\n\ndef find_min_index_list2(nums):\n    if len(nums) == 0:\n        return []\n\n    min_val = nums[0]\n    min_idx = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            min_idx = i\n\n    return [min_idx]\n\n\ndef find_min_index_list3(nums):\n    if len(nums) == 0:\n        return []\n\n    min_val = nums[0]\n    min_idx = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            min_idx = i\n\n    return [min_idx]\n\n\nif __name__ == '__main__':\n    nums = [1, 3, 5, 6, 7, 8, 9]\n    print(find_min_index(nums))\n    print(find_min_index_list(nums))\n    print(find_min_index_list2(nums))\n    print(find_min_index_list3(nums))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "from collections import Counter\n\nclass Solution(object):\n    def findMin(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not arr:\n            return []\n        result = []\n        min_index = 0\n        min_value = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] < min_value:\n                min_value = arr[i]\n                min_index = i\n        result.append(min_index)\n        for i in range(1, len(arr)):\n            if arr[i] == min_value:\n                result.append(i)\n        return result\n\n    def findMin2(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not arr:\n            return []\n        result = []\n        min_value = arr[0]\n        min_index = 0\n        for i in range(1, len(arr)):\n            if arr[i] < min_value:\n                min_value = arr[i]\n                min_index = i\n        result.append(min_index)\n        for i in range(1, len(arr)):\n            if arr[i] == min_value:\n                result.append(i)\n        return result\n\n\nif __name__ == \"__main__\":\n    assert Solution().findMin(list(range(1, 10))) == [0]\n    assert Solution().findMin(list(range(1, 10))) == [0, 1]\n    assert Solution().findMin(list(range(1, 10))) == [0, 1, 2]\n    assert Solution().findMin(list(range(1, 10))) == [0, 1, 2, 3]\n    assert Solution().findMin(list(range(1, 10))) == [0, 1, 2, 3, 4]\n    assert Solution().findMin(list(range(1"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "import unittest\n\n__author__ = 'Daniel'\n\n\ndef find_min_index(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # TODO: write your code here\n    if len(arr) == 0:\n        return []\n\n    min_val = arr[0]\n    min_idx = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_idx = i\n            min_val = arr[i]\n\n    return [min_idx]\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertEqual(find_min_index([1, 2, 3, 4, 5, 6, 7]), [0])\n        self.assertEqual(find_min_index([1, 2, 3, 4, 5, 6, 7, 8]), [0, 3, 6])\n        self.assertEqual(find_min_index([-1, -2, -3, -4, -5, -6, -7, -8]), [0, 1, 2, 3, 4, 5, 6, 7])\n\nif __name__ == \"__main__\":\n    unittest.main()"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ans = []\n        for i in range(len(nums)):\n            if nums[i] < nums[0]:\n                ans.append(i)\n        return ans"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        slow, fast = head, head\n        while fast and fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def minLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for l in lists:\n            min_node = self.findMin(l)\n            res.append(min_node.val)\n        return res\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.minLists([[1], [2], [3], [4], [5]])\n    print s.minLists([[1], [2], [3], [4], [5], [6]])\n    print s.minLists([[1,2,3], [4,5,6], [7,8,9]])"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "class Solution:\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(nums)):\n            if nums[i] < nums[0]:\n                res.append(i)\n        return res"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "import collections\n\ndef find_min_index(array):\n    if not array:\n        return 0\n    min_value = min(array)\n    return collections.Counter(array).most_common(1)[0][0]\n\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_min_index([]) == 0, \"Find Minimum Index\"\n    assert find_min_index([4, 2, 1, 3]) == 0, \"Find Minimum Index\"\n    assert find_min_index([4, -1, 1, 3]) == 2, \"Find Minimum Index\"\n    assert find_min_index([-4, -1, 1, 3]) == 2, \"Find Minimum Index\"\n    assert find_min_index([-4, -5, -1, 1, 3]) == 2, \"Find Minimum Index\"\n    assert find_min_index([-4, -5, -1, 1, 3, -3]) == 3, \"Find Minimum Index\"\n    assert find_min_index([-3, -3, -3, -3]) == 0, \"Find Minimum Index\""
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from itertools import count\nimport math\n\n\ndef min_positions(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # write your code here\n    n = len(nums)\n    if n == 0:\n        return []\n    result = []\n    for i in count(0):\n        if i == n:\n            result.append(i)\n            break\n        if nums[i] < nums[i + 1]:\n            result.append(i)\n    return result\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4]\n    print(min_positions(nums))\n    nums = [1, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4]\n    print(min_positions(nums))\n    nums = [0]\n    print(min_positions(nums))"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# Approach #1: Brute Force\ndef find_min_index(nums):\n    return [i for i, x in enumerate(nums) if x < nums[i]]\n\n# Approach #2: Heap\ndef find_min_index(nums):\n    heap = [(-x, i) for i, x in enumerate(nums)]\n    heapq.heapify(heap)\n    while heap:\n        x, i = heapq.heappop(heap)\n        if x < nums[i]:\n            return [i]\n        else:\n            heapq.heappush(heap, (-x, i))\n\n# Approach #3: Heap + Binary Search\ndef find_min_index(nums):\n    min_value = float('inf')\n    min_index = -1\n    for i in range(len(nums)):\n        if nums[i] < min_value:\n            min_value = nums[i]\n            min_index = i\n    return [min_index]\n\n# Approach #4: Binary Search\ndef find_min_index(nums):\n    return [i for i, x in enumerate(nums) if x == min(nums)]\n\n# Approach #5: Binary Search\ndef find_min_index(nums):\n    min_value = float('inf')\n    min_index = -1\n    for i in range(len(nums)):\n        if nums[i] < min_value:\n            min_value = nums[i]\n            min_index = i\n    return [min_index]\n\n# Approach #6: Binary Search + Heap\ndef find_min_index(nums):\n    min_value = float('inf')\n    min_index = -1\n    for i in range(len(nums)):\n        if nums[i] < min_value:\n            min_value = nums[i]\n            min_index = i\n    heap = [(-nums[i], i) for i, x in enumerate(nums) if x < min_value]\n    heapq.heapify("
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMin(self, nums):\n        if not nums:\n            return []\n        if len(nums) == 1:\n            return [0]\n        mid = len(nums) / 2\n        return self.findMin(nums[:mid]) + [mid] + self.findMin(nums[mid:])\n\nif __name__ == '__main__':\n    sol = Solution()\n    nums = [1,2,3,4,5]\n    print(sol.findMin(nums))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "from typing import List\n\nclass Solution:\n    def findMinIndex(self, nums: List[int]) -> List[int]:\n        ans = [0] * len(nums)\n        for i in range(1, len(nums)):\n            if nums[i] < nums[ans[i - 1]]:\n                ans[i] = ans[i - 1]\n            else:\n                ans[i] = i\n        return ans"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "import collections\n\n# https://www.hackerrank.com/challenges/minimum-values-in-a-sorted-list\ndef find_min_values(lst):\n    min_value = None\n    min_index = None\n    for i in range(0, len(lst)):\n        if min_value is None or lst[i] < min_value:\n            min_value = lst[i]\n            min_index = i\n\n    return min_index\n\nif __name__ == '__main__':\n    lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_min_values(lst))"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def findMin(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        self.helper(root, result)\n        return result\n\n    def helper(self, root, result):\n        if root is None:\n            return\n\n        if root.left is None and root.right is None:\n            result.append(root.val)\n        else:\n            self.helper(root.left, result)\n            self.helper(root.right, result)"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def findMin(self, root: TreeNode) -> int:\n        if root is None:\n            return -1\n        if root.left is None and root.right is None:\n            return root.val\n        if root.left is None:\n            return self.findMin(root.right)\n        if root.right is None:\n            return self.findMin(root.left)\n        if root.val < self.findMin(root.left):\n            return self.findMin(root.left)\n        if root.val > self.findMin(root.right):\n            return self.findMin(root.right)\n        return root.val"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-index-of-element-in-sorted-matrix/description/\n\nclass Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def findMinIndex(self, num):\n        \"\"\"\n        :type num: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(num)-1\n        while left <= right:\n            mid = left + (right-left)/2\n            if num[mid] < num[left]:\n                left = mid+1\n            elif num[mid] > num[left]:\n                right = mid-1\n            else:\n                return mid\n        return left"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def findMin(self, head):\n        if head is None or head.next is None:\n            return head\n\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def findMinIter(self, head):\n        if head is None:\n            return None\n        slow = head\n        while slow.next:\n            slow = slow.next\n            fast = slow.next\n            while fast and fast.next:\n                fast = fast.next\n                slow = slow.next\n        return slow\n\n    def findMinIter2(self, head):\n        if head is None:\n            return None\n        slow = head\n        while slow.next:\n            slow = slow.next\n            fast = slow.next\n            while fast and fast.next:\n                fast = fast.next\n                slow = slow.next\n        return slow\n\n    def findMinIter3(self, head):\n        if head is None:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n            while fast and fast.next:\n                fast = fast.next\n                slow = slow.next\n        return slow\n\n\nif __name__ == '__main__':\n    head = ListNode(3)\n    head.next = ListNode(2)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(4)\n\n    print Solution().findMinIter(head)\n    print Solution().findMin(head)\n    print Solution().findMinIter2(head)\n    print Solution().findMinIter3(head)"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-of-two-sorted-arrays/description/\n# https://leetcode.com/problems/minimum-of-two-sorted-arrays/discuss/272749/Python-solution-using-binary-search-and-list-index-and-list-sorting\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMinIndex(self, nums):\n        if not nums:\n            return []\n\n        nums.sort()\n        result = []\n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] < nums[i + 1]:\n                result.append(i)\n                i += 1\n            else:\n                i += 1\n        result.append(len(nums) - 1)\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMinIndex([1, 2, 3, 4, 5, 6])"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# TODO:\n# 1. There are multiple ways to solve the problem, e.g. https://www.geeksforgeeks.org/minimum-value-sublist-in-a-given-list/\n# 2. The solution should be O(n)\n# 3. The solution should be O(n log n)\n\nfrom random import randint\nfrom collections import defaultdict\nfrom itertools import permutations\n\n\ndef find_min_values(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    d = defaultdict(int)\n    for i in numbers:\n        d[i] += 1\n\n    min_values = []\n    for i in range(len(numbers)):\n        if d[numbers[i]] == 1:\n            min_values.append(numbers[i])\n\n    return min_values\n\n\ndef find_min_values_recursive(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not numbers:\n        return []\n    else:\n        min_values = []\n        for i in range(len(numbers)):\n            if numbers[i] < numbers[min_values[-1]]:\n                min_values.append(numbers[i])\n        return min_values\n\n\ndef find_min_values_dp(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    dp = [0] * len(numbers)\n    dp[0] = numbers[0]\n    for i in range(1, len(numbers)):\n        dp[i] = min(dp[i - 1], numbers[i])\n    return dp\n\n\ndef find_min_values_dp_recursive(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not numbers:\n        return []\n    else:\n        min_values = []\n        for i in range(len(numbers)):\n            if numbers[i] < numbers[min_"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def minIndex(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        if not head: return 0\n        dic = {}\n        node = head\n        while node:\n            if node.val not in dic:\n                dic[node.val] = 1\n            else:\n                dic[node.val] += 1\n            node = node.next\n        min_val = -1\n        min_idx = 0\n        for k, v in dic.items():\n            if v == 1:\n                if min_val == -1 or min_val > k:\n                    min_val = k\n                    min_idx = min_idx + 1\n        return min_idx"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Example 1:\n# Given input list is [2, 5, 1, 6, 3]\n# The output should be\n# [0, 1, 2, 3, 4]\n# Example 2:\n# Given input list is [5, 1, 6, 4, and 0]\n# The output should be\n# [0, 1, 2, 3]\n\n# T:O(N), S:O(N), 38 ms\nclass Solution(object):\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if nums[0] < nums[1]:\n            return [0]\n        elif nums[0] > nums[1]:\n            return [1]\n        else:\n            return [0, 1]\n\n# T:O(N), S:O(1), 40 ms\nclass Solution2(object):\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if nums[0] < nums[1]:\n            return [0]\n        elif nums[0] > nums[1]:\n            return [1]\n        else:\n            return [0, 1]"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        min_index = 0\n        for i in range(1, len(nums)):\n            if nums[min_index] > nums[i]:\n                min_index = i\n        return [min_index]"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "import collections\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def findMin(self, nums):\n        if not nums: return []\n        ret = collections.defaultdict(list)\n        for i in range(len(nums)):\n            ret[nums[i]].append(i)\n        return [list(i) for i in ret.values() if len(i) == 1]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "import sys\n\nclass Solution(object):\n    def findMinIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        # find the first element\n        first = nums[0]\n\n        # find the index of the first element\n        index = 0\n\n        # find the last element\n        last = nums[-1]\n\n        # find the index of the last element\n        last_index = len(nums) - 1\n\n        # find the index of the first element\n        first_index = 0\n\n        # find the index of the last element\n        last_index = len(nums) - 1\n\n        # find the index of the first element\n        first_index = 0\n\n        # find the index of the last element\n        last_index = len(nums) - 1\n\n        for i in range(0, len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                if nums[i] < first:\n                    first = nums[i]\n                    index = i\n                    first_index = i\n                if nums[i] > last:\n                    last = nums[i]\n                    last_index = i\n        return [index, first_index, last_index]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3]\n    print(sol.findMinIndex(nums))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Time Limit Exceeded\n        # This solution is not the best solution\n        # The problem is that the list is not sorted and the solution\n        # requires a lot of extra time.\n        #\n        # Idea:\n        #\n        # If the list is sorted, then we can use a binary search to find the minimum.\n        # If the list is not sorted, then we need to keep track of the minimum\n        # and keep track of the minimum index.\n        #\n        # This is not the most efficient solution because we need to keep track of\n        # the minimum index.\n        #\n        # If the list is sorted, then we can use a binary search to find the minimum\n        # and then we can compare the current minimum value with the current minimum index.\n        #\n        # If the list is not sorted, then we need to keep track of the minimum value\n        # and the minimum index.\n        #\n        # We can do a binary search for the minimum index and then compare the current\n        # minimum value with the current minimum index.\n        #\n        # This is a simple solution.\n        #\n        # It is not the best solution.\n        #\n        # The problem is that we need to keep track of the minimum index.\n        #\n        # The problem is that we need to keep track of the minimum value.\n        #\n        # This is the worst solution.\n        #\n        # We need to keep track of the minimum value and the minimum index.\n        #\n        # This is the worst solution.\n        #\n        # We need to keep track of the minimum index and the minimum value.\n        #\n        # This is the worst solution.\n        #\n        # We need to keep track of the minimum value and the minimum index.\n        #\n        # This is the worst solution.\n        #\n        # We need to keep track of the minimum index and the minimum value.\n        #\n        # This is the worst solution"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        for i, n in enumerate(nums):\n            if n < nums[i]:\n                ret.append(i)\n        return ret\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 3, 5, 6]\n    print(sol.findMin(nums))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-of-all-elements-in-a-sorted-matrix/discuss/4194/Python-Solution-using-bsearch-and-list-index-to-find-the-minimum\n\nclass Solution:\n    # @param num, a list of integers\n    # @return a list of integers includes the index\n    def findMin(self, num):\n        if len(num) == 0:\n            return []\n        else:\n            if len(num) == 1:\n                return [0]\n            \n            start = 0\n            end = len(num) - 1\n            while start < end:\n                mid = start + (end - start) / 2\n                if num[mid] < num[end]:\n                    start = mid + 1\n                elif num[mid] > num[end]:\n                    end = mid - 1\n                else:\n                    return [mid]\n        \n        return []"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-index-of-minimum-value-in-a-sorted-array/\n# Approach: DFS\n# time complexity: O(n)\n# space complexity: O(n)\n\nclass Solution:\n    # @param num, a list of integer\n    # @return a list of integer\n    def findMin(self, num):\n        if not num:\n            return [-1]\n\n        min = num[0]\n        idx = 0\n        for i in range(1, len(num)):\n            if num[i] < min:\n                min = num[i]\n                idx = i\n        return [idx]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findMin([5, 2, 6, 1, 3]))\n    print(s.findMin([1, 2, 3, 4, 5]))\n    print(s.findMin([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums: A list of integers\n    # @return: A list of intergers\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        return self.findMin(nums, 0, len(nums) - 1)\n\n    def findMin(self, nums, start, end):\n        if start == end:\n            return [start]\n        mid = (start + end) / 2\n        if nums[mid] < nums[start]:\n            return self.findMin(nums, start, mid)\n        if nums[mid] > nums[end]:\n            return self.findMin(nums, mid + 1, end)\n        return self.findMin(nums, mid + 1, end)\n\nif __name__ == \"__main__\":\n    print(Solution().findMin([1, 2, 3, 1, 2, 3]))\n    print(Solution().findMin([1, 2, 3, 1, 4, 5, 6]))\n    print(Solution().findMin([1, 1, 1, 1, 1, 1, 1]))\n    print(Solution().findMin([1]))\n    print(Solution().findMin([1, 2, 3, 4, 5]))\n    print(Solution().findMin([1, 2, 3, 4, 5, 6]))\n    print(Solution().findMin([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMin(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        fast = head\n        slow = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        while slow:\n            fast = slow.next\n            slow = slow.next\n            if fast is None:\n                return head\n            slow = slow.next\n        return fast"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/minimum-values-in-a-sorted-array/\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n    def findMin(self, head):\n        if head is None:\n            return None\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n    \n    def minValue(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        min_node = None\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if min_node is None:\n                min_node = slow\n            elif min_node.val > slow.val:\n                min_node = slow\n            fast = fast.next\n            slow = slow.next\n        return min_node\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.minValue([1, 2, 3, 4])"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from __future__ import annotations\n\nimport copy\n\nimport pytest\n\n\n@pytest.mark.parametrize(\n    \"list_to_check\",\n    [\n        [0, 1, 2],\n        [0, 1, 3, 4],\n        [0, 1, 3, 5, 6],\n        [1, 2, 3, 4, 5],\n        [1, 2, 3, 5, 6],\n        [1, 2, 3, 5, 6, 7],\n        [1, 2, 3, 5, 6, 7, 8],\n        [1, 2, 3, 5, 6, 7, 8, 9],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n        [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n    ],\n)\ndef test_find_min_values(list_to_check):\n    \"\"\"Test find_min_values function.\"\"\"\n    assert list_to_check == find_min_values(list_to_check)\n\n\ndef find_min_values(list_to_check):\n    \"\"\"Find minimum values in a list.\n\n    Args:\n        list_to_check: List of values.\n\n    Returns:\n        A list of indexes of the minimum values in the list.\n    \"\"\"\n    # Initialize variables.\n    indexes = []\n    min_value = float(\"inf\")\n\n    # Find min value in list.\n    for i in range(len(list_to_check)):\n        if list_to_check["
    }
  ]
}