{
  "timestamp": "2025-09-14T17:36:07.809312",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 32,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-the-duplicate-number/description/\n\nclass Solution(object):\n    def findDuplicate(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        dic = {}\n        for s in strs:\n            for i in range(len(s)):\n                if s[i] in dic:\n                    if s[i]!= dic[s[i]]:\n                        return i\n                else:\n                    dic[s[i]] = i\n        return -1"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def hasMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        return self.regex.match(s) is not None\n        \n    def hasMatch_re(self, s, p):\n        return s.find(p)!= -1\n        \n    regex = re.compile('[a-z]*[_a-z]+')\n        \n    \n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_1 = obj.hasMatch(s, p)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/lowercase-words/\n# Given a string s, find the longest subsequence of s that\n# is made up entirely of lowercase letters.\n#\n# The subsequence must start and end with the same letter.\n# If there are multiple possible answers, return the longest one.\n#\n# Example 1:\n# Input: \"abcd\"\n# Output: \"abc\"\n# Example 2:\n# Input: \"aaab\"\n# Output: \"aab\"\n# Example 3:\n# Input: \"abc\"\n# Output: \"abc\"\n# Example 4:\n# Input: \"abcddddee\"\n# Output: \"abcdddee\"\n# Example 5:\n# Input: \"abab\"\n# Output: \"abab\"\n# Example 6:\n# Input: \"aabbb\"\n# Output: \"aabbb\"\n# Example 7:\n# Input: \"abbbbb\"\n# Output: \"abbbbb\"\n# Note:\n# The length of s will be in the range [1, 10,000].\n# s will contain only lowercase letters.\n\n# 2018.01.22\nclass Solution(object):\n    def longestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return ''.join(sorted(s, key=str.lower))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-sequences/problem\n\n# Iterate over the string and store the index of each lowercase character as a list.\ndef find_sequences(str):\n    # YOUR CODE HERE\n    # Iterate over the string and store the index of each lowercase character as a list.\n    #\n    # For each lowercase character in the string, append the index of that character to the list.\n    # Then, join the list into a single list and return it.\n    return\n\nif __name__ == '__main__':\n    test_string = 'abcdefghijklmnopqrstuvwxyz'\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string = '_' + test_string\n    test_string"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    for i in range(len(text)):\n        if text[i] not in \"abcdefghijklmnopqrstuvwxyz\":\n            continue\n        if text[i] == text[i-1]:\n            result.append(text[i-1])\n            continue\n        if i == len(text)-1:\n            result.append(text[i])\n            continue\n        if text[i+1] in \"abcdefghijklmnopqrstuvwxyz\":\n            result.append(text[i])\n            i += 1\n    return result"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.re = '^[a-z]+$'\n        self.dict = {}\n        self.cur = ''\n        self.cur_dict = {}\n\n    def addToDict(self, ch):\n        if ch not in self.cur_dict:\n            self.cur_dict[ch] = 1\n        else:\n            self.cur_dict[ch] += 1\n\n    def addToDict_2(self, ch):\n        if ch not in self.cur_dict:\n            self.cur_dict[ch] = 1\n        else:\n            self.cur_dict[ch] += 1\n            self.cur_dict[ch] = max(self.cur_dict[ch], self.cur_dict[ch - 1])\n\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        self.dict = {}\n        self.cur = ''\n        self.cur_dict = {}\n        for c in s:\n            self.addToDict(c)\n\n        ans = []\n        for c in s:\n            if c in self.dict and self.dict[c] == 1:\n                self.cur = c\n                self.addToDict_2(c)\n            else:\n                if self.cur!= '':\n                    ans.append(self.cur)\n                self.cur = c\n                self.addToDict(c)\n        if self.cur!= '':\n            ans.append(self.cur)\n        return ans\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findSequence('aa'))\n    print(s.findSequence('abb'))\n    print(s.findSequence('aaa'))\n    print(s.findSequence('abbb'))\n    print(s.findSequence('aaaabbbbb'))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from collections import deque\n\ndef solve(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        dp[i] = dp[i-1] + s[i-1].isalpha()\n    return dp[n]\n\nif __name__ == '__main__':\n    s = 'aaa'\n    print(solve(s))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/regex-match-all/discuss/302918/Python-Python-solution-using-regex\n# http://www.cnblogs.com/grandyang/p/4026243.html\n# http://blog.csdn.net/lmj623565791/article/details/40858559\n\nclass Solution(object):\n    def findSequence(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: List[str]\n        \"\"\"\n        if not S or not T:\n            return []\n        m = S.lower()\n        n = T.lower()\n        if len(m) < len(n):\n            m, n = n, m\n        match = [m[i:i + len(n)] for i in range(len(m)) if m[i:i + len(n)] == n]\n        return match\n\nif __name__ == \"__main__\":\n    print(Solution().findSequence(\"hello\", \"ll\"))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def sequence(s):\n    s = list(s)\n    res = []\n    for i in range(len(s)-1):\n        if s[i] == s[i+1]:\n            res.append(s[i])\n    return res\n\ndef main():\n    test_cases = open(\"1.txt\", \"r\")\n    for test in test_cases:\n        test = test.rstrip()\n        print(sequence(test))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.ans = []\n\n    def solve(self, cipher):\n        \"\"\"\n        :param cipher: the cipher\n        :return: the solutions\n        \"\"\"\n        self.ans = []\n        for i in range(1, len(cipher) + 1):\n            if i > 1:\n                if cipher[i - 1]!= cipher[i - 2]:\n                    self.ans.append(cipher[:i])\n            for j in range(i, len(cipher)):\n                if j > i:\n                    if cipher[j - 1]!= cipher[j - i]:\n                        self.ans.append(cipher[:j])\n                        break\n        return self.ans\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    for i in range(5):\n        print(\"Case #{}:\".format(i + 1))\n        cipher = f.readline().strip()\n        # cipher = sys.stdin.readline().strip()\n        solution.solve(cipher)\n        print(\"  \", end=\"\")\n        for j in solution.ans:\n            print(\"{}\".format(j), end=\"\")\n        print()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-sequences-of-lower-case-letters-joined-with-underscore/problem\n\n#!/usr/bin/python\nimport re\n\ndef find_sequences(s):\n    seqs = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            seqs.append(s[i:])\n            s = s[:i]\n    return seqs\n\ndef main():\n    s = input().strip()\n    seqs = find_sequences(s)\n    print(len(seqs))\n    for seq in seqs:\n        print(seq)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/letter-sequence-regex/\n# https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n# https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n# https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n# https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n# https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n\nclass Solution(object):\n    def letterSequence(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/problems/letter-sequence-regex/discuss/121625/Java-solution-using-regex\n        # https://leetcode.com/pro"
    },
    {
      "rank": 13,
      "score": 9.0,
      "candidate": "import re\n\ndef sequence(s):\n    return re.compile('([a-z])_*([a-z])').findall(s)\n\nif __name__ == \"__main__\":\n    s = 'a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z'\n    print sequence(s)"
    },
    {
      "rank": 14,
      "score": 9.0,
      "candidate": "import re\nimport collections\n\ndef find_sequences(text):\n    return list(find_sequences_with_regex(text, r\"[a-z]*_[a-z]\"))\n\ndef find_sequences_with_regex(text, regex):\n    pattern = re.compile(regex)\n    matches = pattern.finditer(text)\n    sequences = []\n    for match in matches:\n        sequences.append(match.group())\n    return sequences\n\ndef main():\n    text = 'abc_def_ghi'\n    sequences = find_sequences(text)\n    print(sequences)\n    \nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 15,
      "score": 9.0,
      "candidate": "import re\n\ndef find_sequences(string):\n    pattern = re.compile('[a-z]+')\n    matches = re.findall(pattern, string)\n    return matches\n\ndef main():\n    print(find_sequences('abcd_efgh_ijkl_mnop_qrst_uvw_xyz'))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 16,
      "score": 8.0,
      "candidate": "import re\n\n\ndef find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    regex = re.compile('[a-z]*_*[a-z]*')\n    sequences = []\n    for i, j in enumerate(regex.finditer(string)):\n        # print(i, j.start(), j.end())\n        # print(string[i:j.start()])\n        # print(string[j.end():])\n        sequences.append(string[i:j.start()])\n        # print(sequences)\n        # print(sequences[-1])\n        if i == 0:\n            sequences[-1] = sequences[-1] + '_'\n        else:\n            sequences[-1] = sequences[-1] + '_' + string[i:j.end()]\n    return sequences\n\n\nif __name__ == '__main__':\n    s = 'abc_de_fg_'\n    print(find_sequences(s))"
    },
    {
      "rank": 17,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSubsequences(self, s):\n        ans = []\n        if not s:\n            return ans\n        s = s.lower()\n        l = len(s)\n        for i in range(1, l):\n            for j in range(i):\n                if s[j:i] not in ans:\n                    ans.append(s[j:i])\n        return ans\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findSubsequences(\"aba_abab\"))"
    },
    {
      "rank": 18,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/regex-repetition\n\ndef regex_repetition(s):\n    pattern = r'[a-z]+'\n    matches = re.findall(pattern, s)\n    return len(matches)\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(regex_repetition(s))"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    seqs = []\n    pattern = r'[a-z]{1,}'\n    regex = re.compile(pattern)\n    for m in regex.finditer(s):\n        seqs.append(m.group())\n    return seqs\n\ns = \"Hello, my name is John. I am 15 years old.\"\nprint(find_sequences(s))\n\ns = \"Hello, my name is John. I am 15 years old.\"\nprint(find_sequences(s))"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "def find_sequences(text, pattern):\n    pattern = re.compile(pattern)\n    matches = []\n    for match in pattern.finditer(text):\n        matches.append(match.group())\n    return matches\n\nif __name__ == \"__main__\":\n    text = \"The quick brown fox jumped over the lazy dog.\"\n    pattern = \"\\\\w+\"\n    matches = find_sequences(text, pattern)\n    for match in matches:\n        print(match)"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def __init__(self):\n        self.regex = re.compile(r'^[a-z]+$')\n\n    def is_abbreviation(self, word):\n        return self.regex.match(word)\n\n    def find_sequences(self, words):\n        result = []\n        for word in words:\n            if self.is_abbreviation(word):\n                result.append(word)\n            else:\n                result.append('_'.join(word.split()))\n        return result\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    words = ['a', '_a', '_b', 'aa', 'aa_b', 'b_b', 'a_a', 'a_b', 'a_a_a', 'a_b_a', 'a_b_b', 'a_c', 'aa_a']\n    result = solution.find_sequences(words)\n    print(result)"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    # Complete this function\n    sequence_regex = re.compile('[a-z]{2,}')\n    sequence_list = []\n    for i in range(len(s)):\n        if sequence_regex.match(s[i]):\n            sequence_list.append(s[i])\n    return sequence_list\n\nif __name__ == \"__main__\":\n    s = \"Hello_world\"\n    print(find_sequences(s))"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "def find_sequences_regex(s):\n    # write your code here\n    seqs = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            seqs.append(s[:i])\n            s = s[i + 1:]\n        else:\n            continue\n    seqs.append(s)\n    return seqs\n\nif __name__ == \"__main__\":\n    s = '___a___b_c_d_e_f_g__h_i_j_k__l_m_n_o_p_q_r_s_t_u_v_w_x_y_z'\n    seqs = find_sequences_regex(s)\n    print seqs"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Solution:\n    def isPossible(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        s = s.upper()\n        pattern = '[a-z]{2,}'\n        return bool(re.match(pattern, s))\n\nif __name__ == '__main__':\n    assert Solution().isPossible('abc')\n    assert Solution().isPossible('_abc')\n    assert not Solution().isPossible('abcd')\n    assert not Solution().isPossible('abcde')\n    assert not Solution().isPossible('abcdefghijklmnopqrstuvwxyz')\n    assert Solution().isPossible('abcd_efghi_jkl_mno_pqrstuv_wxyz')"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    regex = '([a-z]{1})([a-z]{1})([a-z]{1})'\n    return re.findall(regex, s)\n\nif __name__ == '__main__':\n    assert(find_sequences('abcde') == ['abcde'])\n    assert(find_sequences('abcd') == ['abcd'])\n    assert(find_sequences('abcd') == ['abcd'])\n    assert(find_sequences('abcd_') == ['abcd_'])\n    assert(find_sequences('abcd_efgh') == ['abcd_efgh'])\n    assert(find_sequences('abcd_efgh_ijkl') == ['abcd_efgh_ijkl'])"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef find_sequences_regex(string):\n    regex = r'[a-z]+'\n    matches = defaultdict(list)\n    for match in re.finditer(regex, string):\n        matches[match.group()].append(match.start())\n\n    return matches\n\nif __name__ == '__main__':\n    string = 'abcd_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z'\n    print(find_sequences_regex(string))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(string):\n    pattern = re.compile('[a-z]+')\n    sequences = []\n    for i in range(len(string)):\n        match = pattern.search(string[i:])\n        if match:\n            sequences.append(match.group())\n    return sequences\n\nif __name__ == \"__main__\":\n    string = \"abcdefghijklmnopqrstuvwxyz\"\n    sequences = find_sequences(string)\n    print(sequences)"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "import re\nimport string\n\ndef find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    pattern = re.compile('[a-z]{2,}')\n    for m in pattern.finditer(s):\n        seqs.append(m.group())\n    return seqs\n\nif __name__ == '__main__':\n    s = 'abc_ab_ab_ab'\n    print(find_sequences(s))\n    s = 'abcd'\n    print(find_sequences(s))\n    s = 'abc'\n    print(find_sequences(s))\n    s = 'abc_'\n    print(find_sequences(s))\n    s = 'a_a'\n    print(find_sequences(s))\n    s = 'a_b'\n    print(find_sequences(s))\n    s = 'a_b_c'\n    print(find_sequences(s))\n    s = 'ab_ab_ab'\n    print(find_sequences(s))"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        seq = []\n        for i in range(len(s)):\n            if s[i] == '_':\n                if seq:\n                    seq[-1] += s[i]\n                else:\n                    seq.append(s[i])\n            else:\n                seq.append(s[i])\n        return seq\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print(solution.findSequence(\"_a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z\"))\n    print(solution.findSequence(\"aaabbbcccdddeeffggghhiiijjjkkkklllmmmnnnooppqqrrssttttuuvvwwxxyyzz\"))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def get_all_lower_case_words(s):\n    words = []\n    for i in range(len(s)):\n        if s[i].isalpha():\n            words.append(s[i:i+1])\n    return words\n\ndef get_sequences_with_underscore(s):\n    sequences = []\n    for i in range(len(s)):\n        if s[i] == '_':\n            sequences.append(s[:i])\n            sequences.append(s[i+1:])\n    return sequences\n\ndef main():\n    s = 'abcdefghijklmnopqrstuvwxyz_'\n    sequences = get_sequences_with_underscore(s)\n    print(sequences)\n    for sequence in sequences:\n        words = get_all_lower_case_words(sequence)\n        print(words)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "import re\n\n\ndef get_regex_sequence(n):\n    return re.compile(\"[a-z]{%d}[a-z]*\" % n)\n\n\ndef main():\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    print(get_regex_sequence(len(s)).findall(s))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def find_sequences(text):\n    pattern = re.compile('[a-z]{2,}')\n    sequences = []\n    for word in pattern.findall(text):\n        sequences.append(word)\n    return sequences\n\nif __name__ == '__main__':\n    text = 'Hello_world_and_this_is_a_test'\n    sequences = find_sequences(text)\n    print sequences"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def sequence(s, n):\n    \"\"\"\n    :type s: str\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n    # write your code here\n    regex = re.compile('[a-z]{' + str(n) + '}')\n    seqs = []\n    for i in range(len(s) - n + 1):\n        if regex.match(s[i:i + n]):\n            seqs.append(s[i:i + n])\n    return seqs\n\ndef test():\n    assert sequence(\"a_b_c_d_e_f\", 4) == [\n        \"a_b_c_d_e\", \"a_b_c_d\", \"a_b_c\", \"a_b\", \"a\", \"b_c_d_e\", \"b_c_d\", \"b_c\", \"b\", \"c_d_e\", \"c_d\", \"c\", \"d_e\", \"d\", \"e\",\n    ]\n    assert sequence(\"abcd\", 3) == [\n        \"ab\", \"abcd\", \"cd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\",\n        \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\", \"abcd\", \"cdab\",\n    ]\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    pattern = r'[a-z]+'\n    matches = re.finditer(pattern, s)\n    for match in matches:\n        if match.group().lower() not in Counter(s):\n            result.append(match.group())\n    return result"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nimport re\n\ndef find_sequence(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    seq = []\n    for i in range(0, len(s)):\n        if re.match(r'[a-z]', s[i]):\n            seq.append(s[i])\n        else:\n            if seq:\n                if len(seq) > 1 and seq[-1] == '_':\n                    seq[-1] = seq[-2] + seq[-1]\n                else:\n                    seq.append('_')\n            seq = []\n    if seq:\n        if len(seq) > 1 and seq[-1] == '_':\n            seq[-1] = seq[-2] + seq[-1]\n        else:\n            seq.append('_')\n    return seq\n\n\nif __name__ == '__main__':\n    assert find_sequence('abcdef') == ['a', 'b', 'c', 'd', 'e', 'f']\n    assert find_sequence('abcdefghijklmnopqrstuvwxyz') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    assert find_sequence('abcd_efgh_ijkl_mno_pqrst_uvwxyz') == ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "# TODO:\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of a given length\n# - write a function to find all the lowercase sequences of"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "#!/bin/python\n\n# Complete the lowerCamel function below.\ndef lowerCamel(s):\n    return s.title().replace('_','')\n\nif __name__ == '__main__':\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    print lowerCamel(s)"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/regex-matching-string-with-regex-pattern\n\nimport re\n\ndef find_regex_pattern(str):\n    pattern = re.compile(r'[a-z]')\n    match = pattern.search(str)\n    return match.group()\n\nif __name__ == '__main__':\n    for line in open('1.txt'):\n        str = line.strip()\n        print find_regex_pattern(str)"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def helper(self, s, index, prev_index, prev_s):\n        if index == len(s):\n            return [s[:index], s[index:]]\n        else:\n            if s[index] == '_':\n                return [s[:index], s[index:]]\n            elif prev_s[prev_index] == s[index]:\n                return self.helper(s, index+1, prev_index, prev_s)\n            elif prev_s[prev_index]!= s[index]:\n                return self.helper(s, index+1, prev_index, prev_s)\n            else:\n                return [s[:index], s[index:]]\n\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        prev_s = s[0]\n        result = []\n        for index, ch in enumerate(s):\n            if ch == '_':\n                result.append(s[:index])\n            elif prev_s!= ch:\n                result.append(s[:index])\n            else:\n                result.append(s[:index])\n                result.append(s[index:])\n            prev_s = ch\n        return result\n\n# Note:\n# This is a classic problem, I'm not sure whether it's a good solution"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences_with_underscore(s):\n    pattern = re.compile('[a-z]+')\n    sequences = []\n    for word in s.split(' '):\n        if pattern.match(word):\n            sequences.append(word)\n    return sequences\n\nif __name__ == '__main__':\n    s = 'Hello World! Hello World!'\n    sequences = find_sequences_with_underscore(s)\n    print(sequences)"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nimport re\n\ndef find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    counter = defaultdict(int)\n    pattern = re.compile(r'[a-z]+')\n    for match in pattern.finditer(string):\n        letters = match.group()\n        counter[letters] += 1\n        if counter[letters] == 2:\n            sequences.append(letters)\n            counter[letters] = 0\n    return sequences\n\nif __name__ == '__main__':\n    assert find_sequences('abcdefg') == ['abc', 'def', 'abcdefg']\n    assert find_sequences('a') == []\n    assert find_sequences('aa') == ['aa']"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "from re import findall\n\ndef find_sequences(text):\n    regex = '([a-z])_([a-z])'\n    match = findall(regex, text)\n    print(match)\n    return match\n\nif __name__ == '__main__':\n    text = 'abbc_aabb_ab_bcc_abbcc'\n    match = find_sequences(text)\n    print(match)"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def helper(self, s, i, j):\n        if i == j:\n            return 0\n        \n        if j == len(s) or s[i]!= s[j]:\n            return 0\n        \n        return 1 + self.helper(s, i + 1, j - 1)\n    \n    def numDistinct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.helper(s, 0, len(s) - 1)"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def sequence(s, regex):\n    for i in range(len(s)):\n        if re.match(regex, s[i:i+1]):\n            yield s[:i]\n            yield s[i+1:i+2]\n            yield s[i+2:]\n            break\n        else:\n            yield s[i:]\n\ndef main():\n    s = \"cdefghijklmnopqrstuvwxyz_\"\n    assert sequence(s, r'[a-z]') == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    assert sequence(s, r'[a-z]*') == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    assert sequence(s, r'[a-z]{2,}') == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSequence(self, s):\n        regex = '.*?([a-z])([a-z]*?)\\1.*?'\n        result = []\n        for index in range(len(s) - 1):\n            if s[index] == s[index+1]:\n                result.append(s[index:index+2])\n                break\n        return result\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findSequence('abcd')"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def find_sequences(s, re):\n    res = []\n    for i in range(len(s)):\n        if re.match(s[i:i+2], s[i] + s[i+1]):\n            res.append(s[i:i+2])\n        else:\n            res.append(s[i:])\n    return res\n\ns = \"abcde\"\nre = r\"a|b|c|d|e\"\nprint find_sequences(s, re)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/word-break-ii/description/\n\nclass Solution(object):\n    def __init__(self):\n        self.map = {}\n        \n    def helper(self, s):\n        if len(s) == 0:\n            return []\n        if s in self.map:\n            return self.map[s]\n        ret = []\n        for i in range(1, len(s)):\n            if s[i-1] == s[i]:\n                ret += self.helper(s[0:i])\n        self.map[s] = ret\n        return ret\n    \n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        words = set(words)\n        ret = []\n        for word in words:\n            ret += self.helper(word)\n        return [w for w in ret if w not in words]"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from collections import deque\n\n\ndef find_sequences(word):\n    # Write your code here\n    if not word:\n        return []\n    results = []\n    word = word.lower()\n    for i in range(len(word)):\n        if word[i] in 'abcdefghijklmnopqrstuvwxyz':\n            curr = deque([word[i]])\n            while curr and curr[0] in 'abcdefghijklmnopqrstuvwxyz':\n                curr.appendleft(word[i])\n                i += 1\n            results.append(''.join(curr))\n    return results\n\n\nif __name__ == '__main__':\n    assert find_sequences('abcde') == []\n    assert find_sequences('abcdefghijklmnopqrstuvwxyz') == ['abc', 'def', 'ghi', 'jkl','mnop', 'qrs', 'tuv', 'wxyz']\n    assert find_sequences('aaabbbccc') == ['aabbb', 'ccc']\n    assert find_sequences('aab') == []"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(str):\n    \"\"\"\n    :type str: str\n    :rtype: List[str]\n    \"\"\"\n    result = []\n    for i, c in enumerate(str):\n        if c.isupper():\n            if i!= 0 and str[i-1].islower():\n                result.append(str[:i])\n                break\n        if c.islower():\n            result.append(str[:i+1])\n            break\n    return result\n\nif __name__ == '__main__':\n    print(find_sequences('abcde'))\n    print(find_sequences('aaa'))\n    print(find_sequences('a'))\n    print(find_sequences('aa'))\n    print(find_sequences('aaa'))\n    print(find_sequences('aaaa'))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    pattern = re.compile('([a-z]){3}')\n    match = pattern.finditer(s)\n    return [m.group(0) for m in match]\n\nif __name__ == '__main__':\n    s = 'abcabc_'\n    print find_sequences(s)\n    #print find_sequences('abcdabc_')\n    #print find_sequences('abcdabcd_')"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def is_sequence(seq):\n    return all(seq.isalnum() for seq in seq)\n\ndef find_sequences(string):\n    sequences = []\n    for i in range(len(string) - 1):\n        if string[i]!= string[i + 1] and is_sequence(string[i:i + 2]):\n            sequences.append(string[i:i + 2])\n    return sequences\n\nif __name__ == '__main__':\n    string = 'abcd_efgh_ijkl_mno_pqrs_tuvw_xyz'\n    sequences = find_sequences(string)\n    print(sequences)"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def find_sequences(text):\n    pattern = re.compile(r\"\\w+\")\n    matches = pattern.findall(text)\n    return matches\n\n#Test cases\nprint find_sequences(\"abcd\")\nprint find_sequences(\"abcd_\")\nprint find_sequences(\"abcd_def\")\nprint find_sequences(\"abcd_def_ghi\")\nprint find_sequences(\"abcd_def_ghi_jkl\")"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    regex = r'[a-z]*_[a-z]+'\n    return [s for s in s.split('_') if s]\n\nif __name__ == '__main__':\n    s = '_aa_aabbcc_'\n    print(find_sequences(s))\n    s = '_aa_aabbcc_'\n    print(find_sequences(s))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    # TODO: implement this\n    return []\n\nif __name__ == '__main__':\n    s = 'a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z'\n    sequences = find_sequences(s)\n    print(sequences)"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def find_sequences(string):\n    return [s for s in string if s.isalpha() and s.islower()]\n\n# Complete the lowerCamel function below.\ndef lower_camel(string):\n    return ''.join(s.title() for s in string.split('_'))\n\nif __name__ == '__main__':\n    string = 'a_b_c_d_e'\n    print(find_sequences(string))\n    print(lower_camel(string))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i]!= s[i+1]:\n                if s[i] == s[i+1].lower():\n                    res.append(s[i:i+2])\n                else:\n                    res.append(s[i:])\n        return res"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    sequence_pattern = r'[a-z]+'\n    sequences = []\n    for i in range(len(s)-1):\n        if s[i]!= s[i+1]:\n            sequences.append(s[i:i+2])\n            s = s[i+2:]\n    if s:\n        sequences.append(s)\n    return sequences\n\nif __name__ == \"__main__\":\n    s = \"a_bc_d_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z\"\n    print(find_sequences(s))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    pattern = re.compile('[a-z]*[^a-z]')\n    res = []\n    for i in range(0, len(s)):\n        if pattern.match(s[i:]) is not None:\n            res.append(s[:i])\n            s = s[i+1:]\n    return res\n\nif __name__ == '__main__':\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    print(find_sequences(s))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "#!/usr/bin/env python\n\nimport re\n\n\ndef find_sequences(string):\n    # Create a pattern to match all lowercase letters.\n    pattern = re.compile(r'^[a-z]*$')\n\n    # Create a list of all sequences.\n    sequences = []\n\n    # Create a matcher.\n    matcher = re.match(pattern, string)\n\n    # Loop over all matches.\n    while matcher:\n        # Get the match.\n        match = matcher.group(0)\n\n        # Add to the list.\n        sequences.append(match)\n\n        # Create a matcher for the next match.\n        matcher = re.match(pattern, match)\n\n    return sequences\n\n\nif __name__ == \"__main__\":\n    # Test 1:\n    string = \"abcdefghijklmnopqrstuvwxyz\"\n    sequences = find_sequences(string)\n    print(sequences)\n\n    # Test 2:\n    string = \"abcd_efghijklmnopqrstuvwxyz\"\n    sequences = find_sequences(string)\n    print(sequences)\n\n    # Test 3:\n    string = \"abcdefghijklmnopqrstuvwxyz_\"\n    sequences = find_sequences(string)\n    print(sequences)"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSequence(self, s):\n        ans = []\n        start = 0\n        for i in range(1, len(s)):\n            if s[i]!= s[i-1]:\n                if start!= -1:\n                    ans.append(s[start:i])\n                start = i\n        if start!= -1:\n            ans.append(s[start:])\n        return ans"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    return re.findall('[a-z]*_[a-z]*', s)\n\nif __name__ == '__main__':\n    s = 'Hello_world'\n    print(find_sequences(s))\n    s = 'Hello_world_world'\n    print(find_sequences(s))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(text):\n    sequence = []\n    pattern = re.compile('[a-z]+')\n    for i in range(len(text)):\n        if pattern.match(text[i:]) is not None:\n            sequence.append(text[i:])\n            text = text[i+1:]\n        else:\n            sequence = []\n            text = text[i:]\n    return sequence\n\nif __name__ == \"__main__\":\n    assert find_sequences(\"abcde\") == [], \"abcde\"\n    assert find_sequences(\"abcd\") == [], \"abcd\"\n    assert find_sequences(\"abcd_efgh\") == [\"abcd_efgh\"], \"abcd_efgh\"\n    assert find_sequences(\"abcd_efgh_ijkl\") == [\"abcd_efgh_ijkl\"], \"abcd_efgh_ijkl\"\n    assert find_sequences(\"abcd_efgh_ijkl_mno\") == [\"abcd_efgh_ijkl_mno\"], \"abcd_efgh_ijkl_mno\"\n    assert find_sequences(\"abcd_efgh_ijkl_mno_pqrs\") == [\"abcd_efgh_ijkl_mno_pqrs\"], \"abcd_efgh_ijkl_mno_pqrs\"\n    assert find_sequences(\"abcd_efgh_ijkl_mno_pqrs_tuvw\") == [\"abcd_efgh_ijkl_mno_pqrs_tuvw\"], \"abcd_efgh_ijkl_mno_pqrs_tuvw\"\n    assert find_sequences(\"abcd_efgh_ijkl_mno_pqrs_tuvw_xyz\") == [\"abcd_efgh_ijkl_mno_pqrs_tuvw_xyz\"], \"abcd_efgh_ijkl_mno_pqrs_tuvw_xyz\""
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import re\n\n# Complete the lowerCases function below.\ndef lowerCases(str):\n    return re.sub(r'[A-Z]', '_', str)\n\nif __name__ == '__main__':\n    assert lowerCases(\"Hello_world\") == \"_hello_world_\", \"Hello_world is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\") == \"_hello_world_\", \"Hello_world_ is not valid\"\n    assert lowerCases(\"Hello_world_\")"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # using a list to store the sequence\n        seq = []\n        # using a stack to store the position of the current character\n        pos = []\n        # using a set to store the characters we have seen\n        seen = set()\n        # using a set to store the characters we have seen from the sequence\n        seq_seen = set()\n\n        for c in s:\n            if c.islower() and c not in seen:\n                seen.add(c)\n                seq_seen.add(c)\n                pos.append(len(seq))\n            else:\n                if len(seq) > 0:\n                    # check if we have seen all the characters in the sequence\n                    if len(seq) == len(seq_seen):\n                        # if we have, append the current sequence\n                        seq.append(c)\n                        # set the position of the current character to the end of the sequence\n                        pos.append(len(seq))\n                        # reset the sequence and the position\n                        seq = []\n                        pos = []\n                        seq_seen = set()\n                else:\n                    # if the sequence is empty, append the current character\n                    seq.append(c)\n                    # set the position of the current character to the end of the sequence\n                    pos.append(len(seq))\n                    # reset the sequence and the position\n                    seq = []\n                    pos = []\n                    seq_seen = set()\n\n        # check if we have seen all the characters in the sequence\n        if len(seq) > 0:\n            # if we have, append the current sequence\n            seq.append(c)\n            # set the position of the current character to the end of the sequence\n            pos.append(len(seq))\n\n        return seq\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findSequence('abcd')\n    print s.findSequence('cabd')\n    print s.findSequence('cabd')\n    print s.findSequence('abcd')\n    print s.findSequence('cabd')"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "import re\n\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    for i in range(len(text) - 1):\n        if text[i] == text[i + 1] and text[i] >= 'a' and text[i] <= 'z':\n            seqs.append(text[i:i + 2])\n    return seqs\n\n\ndef main():\n    text = 'aaaaaa'\n    seqs = find_sequences(text)\n    print(seqs)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    seqs = []\n    for i, ch in enumerate(text):\n        if ch.isupper() and ch.isalpha():\n            seqs.append(text[:i] + '_' + text[i:])\n    return seqs\n\ndef main():\n    text = 'I am a very good man.'\n    print(find_sequences(text))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a string\n    def sequenceOfLetters(self, s):\n        res = ''\n        for i in range(len(s)):\n            if s[i] == '_':\n                if res!= '':\n                    res = res + '_'\n                res = res + s[i:]\n            else:\n                res = res + s[i]\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.sequenceOfLetters('a_c_e_a_n_o_r_t'))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    pattern = '.*[a-z]*_[a-z].*'\n    m = re.search(pattern, s)\n    if m:\n        return m.group(0)\n    else:\n        return \"\"\n\nif __name__ == \"__main__\":\n    s = \"Hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_hello_world_"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(string):\n    # write your code here\n    pattern = re.compile(r'([a-z])+')\n    result = []\n    for match in pattern.finditer(string):\n        sub_string = match.group()\n        if sub_string[0] == sub_string[-1]:\n            sub_string = sub_string[1:-1]\n        result.append(sub_string)\n    return result\n\nif __name__ == '__main__':\n    test_cases = [\n        ('abbc_a', [['a', 'b', 'c']]),\n        ('ab_c_', [['c', 'b']]),\n        ('abb_c', [['b', 'c']]),\n        ('abbc', [['b', 'c']]),\n        ('ab_c', [['b', 'c']]),\n        ('abbc_', [['c', 'b']]),\n        ('aabbcc', [['b', 'c', 'a', 'b', 'c']]),\n        ('abbcc', [['b', 'c', 'a', 'b', 'c']]),\n        ('abbcc_', [['c', 'b', 'c', 'a', 'b', 'c']]),\n        ('abbcc_', [['c', 'b', 'c', 'a', 'b', 'c']]),\n        ('abbcc_', [['c', 'b', 'c', 'a', 'b', 'c']]),\n        ('abbcc_', [['c', 'b', 'c', 'a', 'b', 'c']]),\n        ('abbcc_', [['c', 'b', 'c', 'a', 'b', 'c']]),\n    ]\n    for case in test_cases:\n        print 'Case #{}: {}'.format(case[0], find_sequences(case[1]))"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        s = s.lower()\n        d = defaultdict(int)\n        for c in s:\n            d[c] += 1\n        seq = []\n        curr = ''\n        for c in s:\n            if d[c] == 0:\n                if curr:\n                    seq.append(curr)\n                    curr = ''\n            elif d[c] == 1:\n                curr += c\n            else:\n                curr += c + '_'\n                seq.append(curr)\n                curr = ''\n        if curr:\n            seq.append(curr)\n        return seq\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findSequence('abcd_efgh')\n    print s.findSequence('ab_cd_efgh')\n    print s.findSequence('ab_cd_efgh_')\n    print s.findSequence('abcd')\n    print s.findSequence('abcd_')\n    print s.findSequence('abcd_efgh')\n    print s.findSequence('ab_cd_efgh')\n    print s.findSequence('ab_cd_efgh_')\n    print s.findSequence('abcd_efgh')\n    print s.findSequence('abcd_efgh_')\n    print s.findSequence('abcd_efgh_')\n    print s.findSequence('abcd')"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "from collections import Counter\nimport re\n\ndef find_sequences(text):\n    pattern = re.compile('[a-z][a-z]')\n    sequences = []\n    for i in range(len(text)):\n        if pattern.match(text[i]):\n            if len(sequences) > 0 and sequences[-1][-1]!= text[i]:\n                sequences[-1] += text[i]\n            else:\n                sequences.append([text[i]])\n        else:\n            if len(sequences) > 0:\n                sequences[-1] += text[i]\n    return sequences\n\ndef find_sequences_count(text):\n    sequences = []\n    pattern = re.compile('[a-z][a-z]')\n    for i in range(len(text)):\n        if pattern.match(text[i]):\n            if len(sequences) > 0 and sequences[-1][-1]!= text[i]:\n                sequences[-1] += text[i]\n            else:\n                sequences.append([text[i]])\n        else:\n            if len(sequences) > 0:\n                sequences[-1] += text[i]\n    return Counter(sequences)\n\nif __name__ == '__main__':\n    text = \"This is a test\"\n    sequences = find_sequences(text)\n    sequences = find_sequences_count(text)\n    print(sequences)"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def find_sequences(text, min_length):\n    \"\"\"\n    :type text: str\n    :type min_length: int\n    :rtype: List[str]\n    \"\"\"\n    # +++your code here+++\n    # Write your code below\n\n    # for each char of the text\n    for char in text:\n        # if the char is a lowercase letter,\n        if char.islower():\n            # if the previous char is a lowercase letter,\n            if char.islower() and prev_char.islower():\n                # join them with an underscore\n                yield char + '_'\n            # if the previous char is not a lowercase letter,\n            elif prev_char.islower():\n                # join them with an underscore\n                yield char + '_'\n            # if the previous char is a letter,\n            elif prev_char.isalpha():\n                # join them with an underscore\n                yield char + '_'\n            # if the previous char is not a letter,\n            else:\n                # join them with an underscore\n                yield char + '_'\n        # if the char is a non-lowercase letter,\n        else:\n            # join them with an underscore\n            yield char + '_'\n\n    # if the text does not have a letter,\n    if not text.isalpha():\n        # join them with an underscore\n        yield '_'\n\n    # if the text is a single letter,\n    if len(text) == 1:\n        # join them with an underscore\n        yield '_'\n\n    # if the text is a single underscore,\n    if text == '_':\n        # join them with an underscore\n        yield '_'\n\n    # if the text is empty,\n    if not text:\n        # join them with an underscore\n        yield '_'\n\ndef main():\n    # This is your test code that you wrote above.\n    text = 'a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z_0_1_2_3_4_"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    return re.findall(r'[a-z]{2,}', s)\n\nif __name__ == '__main__':\n    s = 'aa_bb_cc_dd'\n    print find_sequences(s)"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(input_str):\n    \"\"\"\n    :type input_str: str\n    :rtype: List[str]\n    \"\"\"\n    pattern = re.compile(\"[a-z]+\")\n    result = []\n\n    for word in pattern.findall(input_str):\n        if word[0]!= word[-1]:\n            result.append(word[:-1] + \"_\")\n        else:\n            result.append(word[:-1])\n\n    return result\n\nif __name__ == '__main__':\n    assert find_sequences(\"a_b_c\") == ['a_', 'b_', 'c_']\n    assert find_sequences(\"abcd\") == ['abcd']\n    assert find_sequences(\"abbc\") == ['abbc']\n    assert find_sequences(\"abcd_efg\") == ['abcd_', 'efg_']\n    assert find_sequences(\"ab_cd_ef_g\") == ['ab_', 'cd_', 'ef_', 'g_']\n    assert find_sequences(\"ab_cd_ef_g_\") == ['ab_', 'cd_', 'ef_', 'g_']\n    assert find_sequences(\"ab_cd_ef_g_h_i\") == ['ab_', 'cd_', 'ef_', 'g_', 'h_', 'i_']\n    assert find_sequences(\"ab_cd_ef_g_h_i_\") == ['ab_', 'cd_', 'ef_', 'g_', 'h_', 'i_']"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "import re\n\ndef sequence_with_underscore(s):\n    if not isinstance(s, str):\n        return \"\"\n\n    seq = []\n    pattern = re.compile(\"[a-z]\")\n    for i in range(0, len(s)):\n        if not pattern.match(s[i]):\n            seq.append(s[i])\n        elif not seq or seq[-1]!= \"a\":\n            seq.append(\"_\")\n        else:\n            seq.pop()\n    return \"\".join(seq)\n\nif __name__ == \"__main__\":\n    print(sequence_with_underscore(\"abcdefghijklmnopqrstuvwxyz\"))"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nimport re\n\ndef find_sequences(string):\n    regex = re.compile('[a-z]+')\n    sequences = defaultdict(list)\n    for match in regex.finditer(string):\n        sequences[match.group()].append(match.start())\n\n    return sequences\n\n\nif __name__ == '__main__':\n    string = 'abcdefghijklmnopqrstuvwxyz'\n    sequences = find_sequences(string)\n    print(sequences)"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "def find_sequences(s, n):\n    return [m.group(0) for m in re.finditer('[a-z]{%d}' % n, s)]\n\nif __name__ == '__main__':\n    print find_sequences('abcabcbb', 3)"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "from string import ascii_lowercase\n\n\ndef find_sequences(s):\n    # your code here\n    n = len(s)\n    m = n + 1\n    for i in range(0, n):\n        if s[i]!= s[i + 1]:\n            m += 1\n    return m\n\nif __name__ == '__main__':\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    print(find_sequences(s))"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(text):\n    pattern = re.compile('[a-z]+')\n    matches = pattern.findall(text)\n    \n    sequences = []\n    \n    for match in matches:\n        if match[0]!= match[-1]:\n            sequences.append(match)\n        else:\n            sequences.append(match[0:-1])\n    \n    return sequences\n\n\nif __name__ == '__main__':\n    text = \"a_b_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q_r_s_t_u_v_w_x_y_z\"\n    sequences = find_sequences(text)\n    for sequence in sequences:\n        print sequence"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "#\n# TODO\n# - Test cases\n# - Write a function to check if a string is a valid email address\n# - Write a function to check if a string is a valid ISBN\n#\n\n#\n# Sample Inputs and Outputs\n#\n# \"Hello World\"\n# \"Hello_World\"\n# \"HELLO WORLD\"\n# \"HELLO WORLD_\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD_\"\n# \"HELLO_WORLD_\"\n# \"HELLO_WORLD_\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n# \"HELLO_WORLD\"\n#"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(s):\n    seq = []\n    for i in range(len(s)):\n        if s[i].isalpha():\n            if s[i] not in seq:\n                seq.append(s[i])\n    return seq\n\nif __name__ == \"__main__\":\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    print(find_sequences(s))"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "from string import ascii_lowercase\n\n\ndef find_sequences(text):\n    seqs = []\n    for i in range(len(text)):\n        seqs.append(text[i:i+2])\n    return seqs\n\n\nif __name__ == '__main__':\n    text = 'abacd'\n    print(find_sequences(text))"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "def find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    pattern = re.compile('[a-z]{2,}')\n    results = []\n    for i in range(len(text)):\n        if text[i] == '_':\n            if i > 0 and pattern.match(text[i - 1:i + 2]):\n                results.append(text[i - 1:i + 2])\n    return results\n\nif __name__ == '__main__':\n    assert find_sequences('abc') == []\n    assert find_sequences('abc_') == [u'abc']\n    assert find_sequences('_abc_') == [u'_abc']\n    assert find_sequences('abc_def') == [u'abc', u'def']\n    assert find_sequences('ab_cd_ef') == [u'ab', u'cd', u'ef']\n    assert find_sequences('ab_cd_ef_') == [u'ab', u'cd', u'ef', u'_']\n    assert find_sequences('ab_cd_ef_g') == [u'ab', u'cd', u'ef', u'g']"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "import re\n\ndef find_sequences(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    # TODO: Implement\n    pass\n\nif __name__ == '__main__':\n    assert find_sequences('ab_c') == []\n    assert find_sequences('ab_c_d') == []\n    assert find_sequences('ab_c_d_e') == []\n    assert find_sequences('ab_c_d_e_f') == []\n    assert find_sequences('ab_c_d_e_f_g') == []\n    assert find_sequences('ab_c_d_e_f_g_h') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l_m') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l_m_n') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l_m_n_o') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l_m_n_o_p') == []\n    assert find_sequences('ab_c_d_e_f_g_h_i_j_k_l_m_n_o_p_q') == []"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "import re\n\ndef find_regex_pattern(text):\n    pattern = re.compile(r'[a-z]')\n    matches = [m.group() for m in pattern.finditer(text)]\n    return matches\n\ndef test_find_regex_pattern():\n    assert find_regex_pattern('a_b_c') == ['a', 'b', 'c']\n    assert find_regex_pattern('a_b_c_d') == ['a_b_c', 'd']\n    assert find_regex_pattern('a_b_c_d_e') == ['a_b_c_d', 'e']\n    assert find_regex_pattern('a_b_c_d_e_f') == ['a_b_c_d_e', 'f']\n    assert find_regex_pattern('a_b_c_d_e_f_g') == ['a_b_c_d_e_f', 'g']\n    assert find_regex_pattern('a_b_c_d_e_f_g_h') == ['a_b_c_d_e_f_g', 'h']\n    assert find_regex_pattern('a_b_c_d_e_f_g_h_i') == ['a_b_c_d_e_f_g_h', 'i']\n    assert find_regex_pattern('a_b_c_d_e_f_g_h_i_j') == ['a_b_c_d_e_f_g_h', 'i_j']\n    assert find_regex_pattern('a_b_c_d_e_f_g_h_i_j_k') == ['a_b_c_d_e_f_g_h', 'i_j_k']\n    assert find_regex_pattern('a_b_c_d_e_f_g_h_i_j_k_l') == ['a_b_c_d_e_f_g_h', 'i_j_k_l']\n    assert find_regex_pattern('a_b"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": ""
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from collections import deque\n\ndef find_sequences(s):\n    seqs = []\n    seq = []\n    for c in s:\n        if c.isalpha():\n            seq.append(c)\n        else:\n            seqs.append(''.join(seq))\n            seq = []\n    seqs.append(''.join(seq))\n    return seqs\n\n\ndef test():\n    assert find_sequences('a_b_c_d_e_f') == ['a', 'b', 'c', 'd', 'e', 'f']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert find_sequences('abcd') == ['ab', 'cd']\n    assert"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def find_sequences(s):\n    return [re.search(r'[a-z]*_[a-z]*', s).group()]\n\nif __name__ == '__main__':\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_sequences(\"Hello_world\") == ['Hello_world'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent_world_is_really_cool'], \"Examples\"\n    assert find_sequences(\"Hello_world_this_is_excellent_world_is_really_cool\") == ['Hello_world_', 'this_is_excellent"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(map(lambda c: c.isdigit() or c == '.', s))\n\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if len(s)!= len(p):\n            return False\n        if len(p) == 0:\n            return True\n        if p[0] == '*':\n            return True\n        if p[0] == '?':\n            return any(self.isMatch(s[1:], p[1:]))\n        if p[0] == '.':\n            return all(self.isMatch(s[1:], p[1:]))\n        if p[0] == '^':\n            return self.isMatch(s[1:], p[1:])\n        if p[0] == '$':\n            return self.isMatch(s[:-1], p[1:])\n        return s[0] == p[0] and self.isMatch(s[1:], p[1:])\n\n    def match_regex(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return True\n        if p[0] == '.':\n            return self.match_regex(s, p[1:])\n        if p[0] == '*':\n            return any(self.match_regex(s, p[1:]))\n        if p[0] == '?':\n            return any(self.match_regex(s, p[1:]))\n        if p[0] == '^':\n            return self.match_regex(s, p[1:])\n        if p[0] == '$':\n            return self.match_regex(s, p[1:])\n        if p[0] == '\\\\':\n            return self.match_regex(s, p["
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def __init__(self):\n        self.result = []\n\n    def solve(self, cipher):\n        \"\"\"\n        :param cipher: the cipher\n        :return: the result\n        \"\"\"\n        cipher = cipher.strip().upper()\n        if not cipher:\n            return \"\"\n\n        s = []\n        for i in range(len(cipher)):\n            if cipher[i] == cipher[i + 1]:\n                s.append(cipher[i])\n            else:\n                if len(s) > 1:\n                    self.result.append(''.join(s))\n                s = []\n\n        if len(s) > 1:\n            self.result.append(''.join(s))\n\n        return '_'.join(self.result)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\" % (solution.solve(cipher))\n        # print s,\n\n    f.close()"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findRepeatedDnaSequences(self, s):\n        if not s:\n            return []\n        m = [[False] * len(s) for _ in range(len(s))]\n        m[0][0] = True\n        for i in range(1, len(s)):\n            for j in range(0, i):\n                if s[j] == s[i]:\n                    m[i][j] = m[j][i]\n        #print m\n        ans = []\n        for i in range(1, len(s)):\n            for j in range(0, i):\n                if m[i][j]:\n                    if j == 0:\n                        ans.append(s[0:i])\n                    elif j == i:\n                        ans.append(s[j:])\n                    else:\n                        ans.append(s[j:i])\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().findRepeatedDnaSequences(\"AAAAAA\") == []\n    assert Solution().findRepeatedDnaSequences(\"AAAA\") == []\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAA\") == [\"AAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAAB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAAB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAAB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAABB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAABBB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAABBBB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAABBBBB\") == [\"AAAAA\", \"AAAAA\"]\n    assert Solution().findRepeatedDnaSequences(\"AAAAAAABBBBBBB\") == [\"AAAAA"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": ""
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://oj.leetcode.com/problems/find-repeated-characters/\n\n# TLE\n# O(n) time, O(n) space\nclass Solution(object):\n    def repeatedCharSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        for i in range(len(s)):\n            if s[i] == '_':\n                ans.append(s[:i])\n            else:\n                ans.append(s[i:])\n        return ans\n\n# TLE\nclass Solution2(object):\n    def repeatedCharSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        ans = []\n        for i in range(len(s)):\n            if s[i] == '_':\n                ans.append(s[:i])\n                ans.append(s[i+1:])\n            else:\n                ans.append(s[i:])\n        return ans"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from collections import Counter\n\ndef find_sequences(text):\n    \"\"\"\n    :type text: str\n    :rtype: List[str]\n    \"\"\"\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text[j].islower():\n            j += 1\n        if j - i > 1:\n            sequences.append(text[i:j])\n    return sequences\n\ndef find_sequences_regex(text):\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text[j].islower():\n            j += 1\n        if j - i > 1:\n            sequences.append(text[i:j])\n    return sequences\n\ndef find_sequences_regex_2(text):\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text[j].islower():\n            j += 1\n        if j - i > 1:\n            sequences.append(text[i:j])\n    return sequences\n\ndef find_sequences_regex_3(text):\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text[j].islower():\n            j += 1\n        if j - i > 1:\n            sequences.append(text[i:j])\n    return sequences\n\ndef find_sequences_regex_4(text):\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text[j].islower():\n            j += 1\n        if j - i > 1:\n            sequences.append(text[i:j])\n    return sequences\n\ndef find_sequences_regex_5(text):\n    sequences = []\n    for i in range(len(text)):\n        j = i + 1\n        while j < len(text) and text"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "__author__ = 'vivek'\n\nimport re\n\n\ndef check_for_regex_match(s):\n    \"\"\"\n    :param s: string\n    :return: boolean\n    \"\"\"\n    return re.search(r'^[a-z][a-z]*$', s) is not None\n\n\ndef get_regex_match(s):\n    \"\"\"\n    :param s: string\n    :return: regex\n    \"\"\"\n    return r'^[a-z][a-z]*$'\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Your function here\n    s = \"a_b_c_d\"\n    print(check_for_regex_match(s))\n    print(get_regex_match(s))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-the-duplicate-number-in-an-array/\n# https://leetcode.com/problems/find-the-duplicate-number-in-an-array/solution/\n# https://leetcode.com/problems/find-the-duplicate-number-in-an-array/discuss/274554/Python-solution-using-regex-and-str-replace-for-a-quick-and-dirty-solution\n\nclass Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    return nums[i]\n        return -1"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findDuplicate(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        # https://discuss.leetcode.com/topic/92638/python-solution-with-explanation/2\n        # https://www.youtube.com/watch?v=JYJx2vjN6Zs\n        res = []\n        for s in strs:\n            if '_' in s:\n                res.append(s.split('_')[0])\n        return '_'.join(res)\n\n    def findDuplicate(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        res = []\n        for s in strs:\n            if s in res:\n                return s\n            else:\n                res.append(s)\n        return '_'.join(res)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.findDuplicate(['a_b_c', 'b_c_d', 'c_d_e', 'd_e_f', 'e_f_g']) == '_a_b_c_d_e_f_g'\n    assert s.findDuplicate(['a_b_c', 'b_c_d', 'c_d_e', 'd_e_f', 'e_f_g']) == '_a_b_c_d_e_f_g'"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "__author__ = 'Daniel'\n\nclass Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        if not s: return res\n\n        m = re.match('[a-z]+', s)\n        if not m: return res\n\n        for i in range(m.end()):\n            if s[i] == '_':\n                res.append(s[:i])\n            else:\n                break\n        return res\n\n\nif __name__ == '__main__':\n    so = Solution()\n    print(so.findSequence('ab_c'))\n    print(so.findSequence('a_bc'))\n    print(so.findSequence('_a_bc'))\n    print(so.findSequence('a_bc_'))\n    print(so.findSequence('abc'))\n    print(so.findSequence('abc_'))\n    print(so.findSequence('a_bc_'))\n    print(so.findSequence('a_bc_d'))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def get_matching_regex(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_1(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_2(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_3(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_4(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_5(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_6(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_7(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_8(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall(regex, string)\n\ndef get_matching_regex_9(string):\n    regex = r'[a-z][0-9]*[a-z]*'\n    return re.findall("
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# This is a simple example, we can use the same regex to solve this problem.\n\n# For example, given the following sequence, \"a_b_c_d\", the answer is \"a_b_c_d\".\n# \"a_b_c_d\" = \"a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\")\n# \"a_b_c_d\" = \"a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\")\n\n# Note that the join is performed using the regex.\n# This example is from https://www.reddit.com/r/dailyprogrammer/comments/5jv5xq/20150609_challenge_5_easy_regex/\n#\n# In the problem, you can use the regex to find the sequence of lowercase letters,\n# then join them with an underscore.\n#\n# In this problem, we will use the same regex to find the sequence of lowercase letters,\n# then join them with an underscore.\n#\n# For example, we will use the regex to find the sequence of lowercase letters, then\n# join them with an underscore.\n#\n# The regex is:\n# [a-z]{2,}\n#\n# We will use the same regex to find the sequence of lowercase letters, then join them with an underscore.\n\n# This is the function you need to implement.\ndef find_sequence(str):\n    # Write your code here.\n    # str = str.lower()\n    # return str\n    return str.replace(\"_\", \"\")\n\n\n# This is a simple example, we can use the same regex to solve this problem.\n# For example, given the following sequence, \"a_b_c_d\", the answer is \"a_b_c_d\".\n# \"a_b_c_d\" = \"a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\") = \"_a_b_c_d\".join(\"_\")\n# \"a"
    }
  ]
}