{
  "timestamp": "2025-09-14T18:53:09.825886",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 205,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if subset is None or nums is None:\n            return False\n        \n        if subset.val < nums[0]:\n            return False\n        \n        if subset.val > nums[-1]:\n            return False\n        \n        p = subset\n        while p is not None:\n            if p.val >= nums[0] and p.val <= nums[-1]:\n                if not self.isSubset(p.next, nums):\n                    return False\n            p = p.next\n        \n        return True"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if subset is None or len(subset) == 0:\n            return True\n        if nums is None or len(nums) == 0:\n            return False\n        curr = subset\n        while curr is not None:\n            if curr.val not in nums:\n                return False\n            nums.remove(curr.val)\n            curr = curr.next\n        return True"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all(map(lambda x: subset[x] <= superset[x], xrange(len(subset))))\n\n\nif __name__ == '__main__':\n    subset = [[1], [2], [3]]\n    superset = [[1, 2], [1, 3], [2, 3]]\n    print Solution().isSubset(subset, superset)\n    subset = [[1, 2, 3], [2, 3, 4]]\n    superset = [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n    print Solution().isSubset(subset, superset)\n\n    subset = [[1, 2], [3]]\n    superset = [[1, 2], [1, 3], [2, 3], [3, 4]]\n    print Solution().isSubset(subset, superset)\n\n    subset = [[1, 2], [3], [4, 5]]\n    superset = [[1, 2], [1, 3], [2, 3], [3, 4], [4, 5]]\n    print Solution().isSubset(subset, superset)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def isSubset(subset, superset):\n    \"\"\"\n    subset and superset are lists of integers\n    returns true if subset is a subset of superset, false otherwise\n    time: O(n)\n    space: O(n)\n    \"\"\"\n    if len(subset) < len(superset):\n        return False\n    for i in range(len(subset)):\n        if subset[i] > superset[i]:\n            return False\n        if subset[i] == superset[i]:\n            continue\n        return isSubset(subset[i+1:], superset[i+1:])\n    return True\n\n\ndef main():\n    subset = [1, 2, 3]\n    superset = [1, 2, 3, 4, 5]\n    print(isSubset(subset, superset))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         \"\"\"\n#         head: the head node of the nested list.\n#         \"\"\"\n#         self.val = head\n#         self.next = None\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: NestedList\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        subset.next = None\n        pre = subset\n        for i in xrange(len(nums)):\n            if subset.val == nums[i]:\n                subset = subset.next\n            else:\n                if subset.val == None:\n                    return False\n                else:\n                    subset = subset.next\n                    pre = pre.next\n        return subset.val == None\n\n\nif __name__ == '__main__':\n    n1 = NestedList([1,2,3,4])\n    n2 = NestedList([3,4])\n    n3 = NestedList([3,4,5,6,7,8,9,10,11,12])\n    n4 = NestedList([1,2,3])\n    n5 = NestedList([1,2])\n    n6 = NestedList([1])\n    n7 = NestedList([])\n    n8 = NestedList([])\n    n9 = NestedList([1,2,3,4,5,6,7])\n    n10 = NestedList([1,2,3,4,5,6,7,8,9])\n    n11 = NestedList([1,2,3,4,5,6,7,8,9,10,11,12,13])\n    n12 = NestedList([1,2,3,4,5,6,7,8,9,10,11,12,13,14])\n    n13 = NestedList([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n    n14 = NestedList([1,2"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass Solution:\n    def isSubset(self, subset, suffix):\n        \"\"\"\n        :type subset: ListNode\n        :type suffix: ListNode\n        :rtype: bool\n        \"\"\"\n        if subset is None:\n            return True\n        if suffix is None:\n            return False\n        return self.isSubset(subset.next, suffix.next) and self.isSubset(subset, suffix)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import unittest\n\n\ndef is_subset(nested_list, subset_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type subset_list: List[int]\n    :rtype: bool\n    \"\"\"\n    # base case\n    if len(nested_list) == 0:\n        return len(subset_list) == 0\n    # recursive case\n    if len(nested_list) == 1:\n        return nested_list[0] == subset_list\n    # recursive case\n    for i in range(0, len(nested_list)):\n        if not is_subset(nested_list[i:], subset_list[i:]):\n            return False\n    return True\n\n\nclass Test(unittest.TestCase):\n    def test(self):\n        self.assertTrue(is_subset([[1, 2, 3], [1, 2, 3]], [1, 2, 3]))\n        self.assertTrue(is_subset([[1, 2, 3], [1, 2, 3]], [1, 2, 3, 4]))\n        self.assertFalse(is_subset([[1, 2, 3], [1, 2, 3]], [1, 2, 3, 4, 5]))\n        self.assertFalse(is_subset([[1, 2, 3], [1, 2, 3]], [1, 2, 3, 4, 5, 6]))\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "import unittest\n\n\nclass Solution(object):\n\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n        if subset == superset:\n            return True\n        for i in range(len(subset)):\n            if not self.isSubset(subset[i], superset[i]):\n                return False\n        return True\n\n    def isSubset1(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n        if subset == superset:\n            return True\n        for i in range(len(subset)):\n            if subset[i]!= superset[i] and self.isSubset1(subset[i], superset[i]):\n                return False\n        return True\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/subsets/solution/\n#\nApproach 1: Sort\nComplexity Analysis\nTime Complexity: O(nlogn)\nSpace Complexity: O(n)\n\n# 73. Subsets II\n#\n# Given a set of distinct integers, nums, return all possible subsets of it as a list.\n#\n# Note: The solution set must not contain duplicate subsets.\n#\n# For example,\n# If nums = [1,2,3], a solution is:\n#\n# [\n#   [3],\n#   [1],\n#   [2],\n#   [1,2,3],\n#   [1,3],\n#   [2,3],\n#   [1,2],\n#   []"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        for i in range(len(superset)):\n            if subset[i]!= superset[i]:\n                return False\n        return True"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, next_node):\n        self.val = val\n        self.next = next_node\n\nclass Solution:\n    def isSubset(self, subset, nested):\n        \"\"\"\n        :type subset: List[int]\n        :type nested: List[NestedListNode]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(nested):\n            return False\n        \n        for i in range(len(subset)):\n            if nested[i].val!= subset[i]:\n                return False\n        \n        return True"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[int]\n        :rtype: bool\n        \"\"\"\n        if subset == [] or superset == [] or subset == superset:\n            return True\n        if len(subset) > len(superset):\n            return False\n        for i in range(len(subset)):\n            if self.isSubset(subset[i], superset):\n                return True\n        return False\n\n\nif __name__ == '__main__':\n    print Solution().isSubset([[1, 2, 3], [4, 5, 6]], [[1, 2], [4, 5], [1, 2, 3]])\n    print Solution().isSubset([[1, 2], [4, 5]], [[1, 2, 3], [4, 5]])\n    print Solution().isSubset([[1, 2, 3], [4, 5, 6]], [[1, 2], [4, 5], [1, 2, 3]])"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\n\n# Definition for a nested list\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def isSubset(self, A, B):\n        \"\"\"\n        :type A: ListNode\n        :type B: ListNode\n        :rtype: bool\n        \"\"\"\n        if A is None and B is None:\n            return True\n        elif A is None or B is None:\n            return False\n        elif A.val!= B.val:\n            return False\n        else:\n            return self.isSubset(A.next, B.next)\n\nif __name__ == \"__main__\":\n    A = ListNode(1)\n    A.next = ListNode(2)\n    A.next.next = ListNode(3)\n    B = ListNode(2)\n    B.next = ListNode(1)\n    B.next.next = ListNode(3)\n    print(Solution().isSubset(A, B))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, values):\n#         self.values = values\n#         self.n = len(values)\n#         self.a = []\n#         for i in range(0, self.n):\n#             self.a.append(NestedList(values[i]))\n#         self.a = sorted(self.a)\n#\n#     def __str__(self):\n#         return str(self.values)\n#\n#     def is_subset(self, other):\n#         if other.n!= self.n:\n#             return False\n#         for i in range(0, self.n):\n#             if self.a[i].values[i]!= other.a[i].values[i]:\n#                 return False\n#         return True\n#\n#     def is_equal(self, other):\n#         if other.n!= self.n:\n#             return False\n#         for i in range(0, self.n):\n#             if self.a[i].values[i]!= other.a[i].values[i]:\n#                 return False\n#         return True\n#\n#     def is_subset_of(self, other):\n#         if other.n < self.n:\n#             return False\n#         for i in range(0, self.n):\n#             if self.a[i].values[i]!= other.a[i].values[i]:\n#                 return False\n#         return True\n#\n#     def is_super(self, other):\n#         if other.n > self.n:\n#             return False\n#         for i in range(0, self.n):\n#             if self.a[i].values[i]!= other.a[i].values[i]:\n#                 return False\n#         return True\n#\n#     def is_super_of(self, other):\n#         if other.n < self.n:\n#             return False\n#         for i in range(0, self.n):\n#             if self.a[i].values[i]!= other.a[i"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, x):\n\t\tself.val = x\n\t\tself.next = None\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @param m, an integer\n\t# @param n, an integer\n\t# @return a boolean\n\tdef isSubset(self, head, m, n):\n\t\tif not head:\n\t\t\treturn False\n\t\tif head.val!= m:\n\t\t\treturn False\n\t\tif head.next == None:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn self.isSubset(head.next, m, n)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution:\n    def isSubset(self, nestedList, targetList):\n        \"\"\"\n        :type nestedList: List[NestedListNode]\n        :type targetList: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nestedList) > len(targetList):\n            return False\n        for i in range(len(nestedList)):\n            if not self.isSubset(nestedList[i].children, targetList[i:]):\n                return False\n        return True\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nestedList = [NestedListNode(1, [NestedListNode(2, [NestedListNode(3, []), NestedListNode(4, [])]), NestedListNode(5, [NestedListNode(6, []), NestedListNode(7, [])])]), NestedListNode(8, [NestedListNode(9, []), NestedListNode(10, [])]), NestedListNode(11, [NestedListNode(12, []), NestedListNode(13, [])]), NestedListNode(14, [NestedListNode(15, [])])])\n    targetList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    print(sol.isSubset(nestedList, targetList))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: ListNode\n        :type superset: ListNode\n        :rtype: bool\n        \"\"\"\n        if subset is None:\n            return superset is None\n        if subset.val > superset.val:\n            return False\n        if superset is None:\n            return True\n        return subset.val == superset.val and self.isSubset(subset.next, superset.next)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val=None, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, num):\n        \"\"\"\n        :type subset: List[NestedListNode]\n        :type num: List[int]\n        :rtype: bool\n        \"\"\"\n        if not subset or not num:\n            return False\n\n        n = len(num)\n        head = NestedListNode()\n        tail = NestedListNode(None)\n        head.next = tail\n        current = head\n        for i in range(n):\n            while current.next and subset[i].val < num[i]:\n                current = current.next\n            if subset[i].val!= num[i]:\n                return False\n            current.next = NestedListNode(num[i], None)\n            current = current.next\n        return True\n\nif __name__ == \"__main__\":\n    s = Solution()\n    n1 = NestedListNode(1, NestedListNode(2, NestedListNode(3)))\n    n2 = NestedListNode(3, NestedListNode(4))\n    n3 = NestedListNode(4, NestedListNode(5, NestedListNode(6)))\n    n4 = NestedListNode(5, NestedListNode(6, NestedListNode(7, NestedListNode(8, NestedListNode(9, NestedListNode(10))))))\n    n5 = NestedListNode(5, NestedListNode(6, NestedListNode(7, NestedListNode(8, NestedListNode(9, NestedListNode(10, NestedListNode(11, NestedListNode(12, NestedListNode(13, NestedListNode(14, NestedListNode(15, NestedListNode(16, NestedListNode(17)))))))))))))\n    n6 = NestedListNode(5, NestedListNode(6, NestedListNode(7, NestedListNode(8, NestedListNode(9, NestedListNode("
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "from collections import defaultdict\nfrom functools import reduce\n\n\ndef is_subset(nested_list, nested_list_2):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type nested_list_2: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    if len(nested_list) > len(nested_list_2):\n        return False\n    for i in range(len(nested_list)):\n        if not is_subset(nested_list[i], nested_list_2[i]):\n            return False\n    return True\n\n\ndef test_is_subset():\n    assert is_subset([[1, 2, 3], [4, 5]], [[1, 2, 3], [4, 5, 6]])\n    assert not is_subset([[1, 2, 3], [4, 5]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    assert not is_subset([[1, 2, 3], [4, 5]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n\ndef main():\n    test_is_subset()\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param otherHead, a ListNode\n    # @return a boolean\n    def isSubset(self, head, otherHead):\n        # Write your code here\n        if head == None or otherHead == None:\n            return False\n        \n        head = self.traverse(head)\n        otherHead = self.traverse(otherHead)\n        \n        while head!= None and otherHead!= None:\n            if head.val!= otherHead.val:\n                return False\n            head = head.next\n            otherHead = otherHead.next\n        \n        return True\n    \n    def traverse(self, head):\n        if head == None:\n            return None\n        \n        next = head.next\n        head.next = None\n        return self.traverse(next)"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         \"\"\"\n#         head: the head node of the nested list.\n#         \"\"\"\n#         self.head = head\n#         self.next = None\n\n#         if head is not None:\n#             self.next = NestedList(head.next)\n\n#     def toList(self):\n#         \"\"\"\n#         Convert a NestedList into a list.\n#         \"\"\"\n#         node = self.head\n#         rst = []\n#         while node is not None:\n#             rst.append(node.val)\n#             node = node.next\n#         return rst\n\n#     def insert(self, val):\n#         \"\"\"\n#         Insert a new node into the list.\n#         \"\"\"\n#         if self.head is None:\n#             self.head = NestedList(val)\n#             self.next = self.head\n#         else:\n#             node = self.head\n#             while node.next is not None:\n#                 node = node.next\n#             node.next = NestedList(val)\n#             self.next = node.next\n\n#     def remove(self, val):\n#         \"\"\"\n#         Remove the first node that equals val.\n#         \"\"\"\n#         node = self.head\n#         while node.val!= val:\n#             if node.next is None:\n#                 return\n#             node = node.next\n\n#     def isSubset(self, other):\n#         \"\"\"\n#         Check if this list is subset of other.\n#         \"\"\"\n#         cur = self.head\n#         other_cur = other.head\n#         while other_cur is not None and cur is not None:\n#             if cur.val!= other_cur.val:\n#                 return False\n#             cur = cur.next\n#             other_cur = other_cur.next\n\n#         return cur is None and other_cur is None\n\n#     def __str__(self):\n#         return str(self.toList())\n\nclass Solution:\n    # @param A,"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.prev = None\n\nclass Solution:\n    def isSubList(self, head, subList):\n        \"\"\"\n        :type head: NestedListNode\n        :type subList: List[int]\n        :rtype: bool\n        \"\"\"\n        if head is None:\n            return False\n        if head.val not in subList:\n            return False\n        if len(subList) == 1 and subList[0] == head.val:\n            return True\n        if subList[0] == head.val:\n            return self.isSubList(head.next, subList[1:]) or self.isSubList(head.next.next, subList)\n        if subList[-1] == head.val:\n            return self.isSubList(head.next, subList[:-1]) or self.isSubList(head.next.next, subList)\n        return self.isSubList(head.next, subList) or self.isSubList(head.next.next, subList)"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "import unittest\n\ndef is_subset(subset, superset):\n    \"\"\"\n    subset: a list\n    superset: a list\n    returns: True if subset is a subset of superset, False otherwise\n    \"\"\"\n    return all(item in superset for item in subset)\n\n\nclass TestIsSubset(unittest.TestCase):\n    def test_is_subset(self):\n        self.assertTrue(is_subset([1, 2, 3], [1, 2]))\n        self.assertTrue(is_subset([1, 2, 3], [1, 2, 3]))\n        self.assertTrue(is_subset([1, 2, 3], [1, 2, 3, 4]))\n        self.assertTrue(is_subset([1, 2, 3], [1, 2, 3, 4, 5]))\n        self.assertFalse(is_subset([1, 2, 3], [4, 5, 6]))\n\n\nif __name__ == \"__main__\":\n    unittest.main()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n        elif len(subset) > len(superset):\n            return False\n        else:\n            for i in range(len(subset)):\n                if subset[i]!= superset[i]:\n                    return False\n        return True\n\n# Note:\n#  1. The length of subset and superset is same\n#  2. The length of subset and superset is same\n#  3. The length of subset is the same with the length of superset\n#  4. The length of subset is the same with the length of superset"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSubtree(self, s, t):\n        \"\"\"\n        :type s: List[TreeNode]\n        :type t: List[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return len(t) == 0\n        elif len(t) == 0:\n            return False\n        elif len(s) < len(t):\n            return False\n        for i in range(len(s)):\n            if s[i].val!= t[i].val:\n                return False\n            if self.isSubtree(s[i].left, t[i].left):\n                return True\n            if self.isSubtree(s[i].right, t[i].right):\n                return True\n        return False"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "# Definition for a N-ary Tree node\nclass TreeNode:\n\tdef __init__(self, val=0, children=None):\n\t\tself.val = val\n\t\tself.children = children\n\nclass Solution:\n\t# @param root, a tree node\n\t# @param sum, an integer\n\t# @return a boolean\n\tdef isSubtree(self, root, sum):\n\t\tif root is None:\n\t\t\treturn False\n\t\telif root.val == sum:\n\t\t\treturn True\n\t\telse:\n\t\t\tif root.val > sum:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\treturn self.isSubtree(root.children, sum - root.val)\n\n\ns = Solution()\nroot = TreeNode(val=1, children=[TreeNode(val=2, children=[TreeNode(val=3), TreeNode(val=4)]), TreeNode(val=5)])\nprint s.isSubtree(root, 6)"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def is_subset(sub, sup):\n    \"\"\"\n    sub and sup are lists of lists.\n    \"\"\"\n    if not sub:\n        return sup\n    if not sup:\n        return sub\n    if len(sub[0]) > len(sup[0]):\n        return False\n    for i in range(len(sub[0])):\n        if is_subset(sub[1:], sup[i:]) and is_subset(sub[0], sup[:i]):\n            return True\n    return False\n\ndef is_subset_n(sub, sup):\n    \"\"\"\n    sub and sup are lists of lists.\n    \"\"\"\n    if not sub:\n        return sup\n    if not sup:\n        return sub\n    if len(sub[0]) > len(sup[0]):\n        return False\n    for i in range(len(sub[0])):\n        if is_subset_n(sub[1:], sup[i:]) and is_subset_n(sub[0], sup[:i]):\n            return True\n    return False\n\ndef is_subset_2(sub, sup):\n    \"\"\"\n    sub and sup are lists of lists.\n    \"\"\"\n    if not sub:\n        return sup\n    if not sup:\n        return sub\n    if len(sub[0]) > len(sup[0]):\n        return False\n    for i in range(len(sub[0])):\n        if is_subset_2(sub[1:], sup[i:]) and is_subset_2(sub[0], sup[:i]):\n            return True\n    return False\n\ndef is_subset_3(sub, sup):\n    \"\"\"\n    sub and sup are lists of lists.\n    \"\"\"\n    if not sub:\n        return sup\n    if not sup:\n        return sub\n    if len(sub[0]) > len(sup[0]):\n        return False\n    for i in range(len(sub[0])):\n        if is_subset_3(sub[1:], sup[i:]) and is_subset_3(sub[0], sup[:i]):\n            return"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def isSubset(s1, s2):\n    \"\"\"\n    Returns True if the first list is subset of the second.\n    >>> isSubset([1, 2, 3], [1, 2])\n    True\n    >>> isSubset([1, 2, 3], [1, 3])\n    False\n    \"\"\"\n    if len(s1) > len(s2):\n        return False\n    for i in range(len(s1)):\n        if s1[i]!= s2[i]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # base case\n        if not subset or not superset:\n            return subset == superset\n\n        # recursive case\n        for i in range(len(subset)):\n            if subset[i] == superset[i]:\n                continue\n            if self.isSubset(subset[i], superset[i]):\n                return True\n            else:\n                return False\n        return False\n\nprint Solution().isSubset([[1], [2, 3]], [[1, 2], [3]])\nprint Solution().isSubset([[1], [2, 3]], [[1], [2, 3]])\nprint Solution().isSubset([[1], [2, 3]], [[1, 2], [3]])\nprint Solution().isSubset([[1, 2], [3, 4, 5]], [[1, 2], [3, 4]])\nprint Solution().isSubset([[1, 2], [3, 4, 5]], [[1, 2], [3]])\nprint Solution().isSubset([[1, 2], [3, 4, 5]], [[1, 2], [3, 4]])"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def is_subset(subset, superset):\n    \"\"\"\n    subset and superset are both nested lists.\n\n    :param subset: a nested list\n    :param superset: a nested list\n    :return: True if subset is a subset of superset, else False.\n    \"\"\"\n    # The idea is to check if a subset is a subset of superset by comparing each\n    # element in subset with each element in superset.\n    # If the same element is present in both lists, then they are equal.\n    # If the same element is not present in both lists, then subset is not a subset\n    # of superset.\n    # If a subset is a subset of a superset, then the corresponding elements in both\n    # lists should be the same.\n    # If the superset is a subset of a subset, then the corresponding elements in both\n    # lists should be the same.\n    # If the superset is a subset of subset, then the corresponding elements in both\n    # lists should be the same.\n    if len(subset) == len(superset):\n        for i in range(0, len(subset)):\n            if subset[i] not in superset:\n                return False\n        return True\n    else:\n        return False\n\ndef is_subset_2(subset, superset):\n    \"\"\"\n    subset and superset are both nested lists.\n\n    :param subset: a nested list\n    :param superset: a nested list\n    :return: True if subset is a subset of superset, else False.\n    \"\"\"\n    if subset == superset:\n        return True\n    elif subset == []:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    subset = [1, 2, 3]\n    superset = [1, 2]\n    print(is_subset(subset, superset))\n    print(is_subset_2(subset, superset))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def is_subset(nested_list, subset_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type subset_list: List[int]\n    :rtype: bool\n    \"\"\"\n    return len(nested_list) == len(subset_list) and all(item in nested_list for item in subset_list)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        for i in range(len(subset)):\n            if self.isSubset(subset[i], superset[i]):\n                return True\n        return False"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def isSubset(list1, list2):\n\tif len(list1)!= len(list2):\n\t\treturn False\n\n\tfor i in range(len(list1)):\n\t\tif not list1[i] in list2:\n\t\t\treturn False\n\n\treturn True\n\n# print isSubset([1, 2, 3], [1, 2, 3, 4])\n# print isSubset([1, 2, 3], [2, 3])\n# print isSubset([1, 2, 3], [1, 2])\n# print isSubset([1, 2, 3], [1])\n# print isSubset([1, 2, 3], [2])\n# print isSubset([1, 2, 3], [3])\n# print isSubset([1, 2, 3], [1, 2, 3])\n# print isSubset([1, 2, 3], [1, 2, 3, 4])\n# print isSubset([1, 2, 3], [1, 2, 3, 4, 5])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4])\n# print isSubset([1, 2, 3, 4, 5], [1, 2])\n# print isSubset([1, 2, 3, 4, 5], [1])\n# print isSubset([1, 2, 3, 4, 5], [2])\n# print isSubset([1, 2, 3, 4, 5], [3])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6])\n# print isSubset([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, llist):\n#         self.list = llist\n#         self.size = len(llist)\n#         self.count = 0\n#\n#     def size(self):\n#         return self.size\n#\n#     def count(self):\n#         return self.count\n#\n#     def add(self, val):\n#         self.list.append(val)\n#         self.count += 1\n#\n#     def __str__(self):\n#         return str(self.list)\n#\n#     def __eq__(self, other):\n#         return self.list == other.list\n#\n#     def __hash__(self):\n#         return hash(self.list)\n#\n#     def __len__(self):\n#         return len(self.list)\n#\n#     def __getitem__(self, key):\n#         return self.list[key]\n#\n#     def __add__(self, other):\n#         result = NestedList(self.list)\n#         result.add(other.list)\n#         return result\n#\n#     def __mul__(self, other):\n#         result = NestedList(self.list)\n#         result.add(self)\n#         result.add(other)\n#         return result\n#\n#     def __rmul__(self, other):\n#         return self.__mul__(other)\n#\n#     def __getitem__(self, key):\n#         return self.list[key]\n#\n#     def __lt__(self, other):\n#         return len(self.list) < len(other.list)\n#\n#     def __add__(self, other):\n#         return NestedList(self.list) + other\n#\n#     def __str__(self):\n#         return str(self.list)\n#\n#     def __repr__(self):\n#         return str(self.list)\n#\n#     def __eq__(self, other):\n#         return self.list == other"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        for s in subset:\n            if s not in superset:\n                return False\n        return True"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def is_subset(nested_list, nested_list_to_check):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type nested_list_to_check: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    # TODO: Implement\n    return False\n\nif __name__ == \"__main__\":\n    print(is_subset([[1, 2, 3], [4, 5]], [[1, 2], [3, 4]]))\n    print(is_subset([[1, 2, 3], [4, 5]], [[1, 2, 4], [3, 4, 5]]))\n    print(is_subset([[1, 2, 3], [4, 5]], [[1, 2, 4], [3, 4, 5], [5, 6, 7]]))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "import collections\n\ndef is_subset(sublist, superset):\n    if not sublist:\n        return True\n    for item in sublist:\n        if not is_subset(item, superset):\n            return False\n    return True\n\ndef is_subset_of(sublist, superset):\n    if not sublist:\n        return True\n    for item in sublist:\n        if not is_subset_of(item, superset):\n            return False\n    return True\n\ndef is_subset_of_all(sublist, superset):\n    if not sublist:\n        return True\n    for item in sublist:\n        if not is_subset_of_all(item, superset):\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    sublist = [1, 2, 3]\n    superset = [1, 2, 3, 4]\n    print(is_subset(sublist, superset))\n    print(is_subset_of(sublist, superset))\n    print(is_subset_of_all(sublist, superset))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def isSubset(sub, sup):\n    \"\"\"\n    subset(sub, sup) -> bool\n    subset(sup, sub) -> bool\n    Check if sub is a subset of sup.\n    \"\"\"\n\n    # Base cases\n    if not sub:\n        return False\n    elif not sup:\n        return True\n    elif len(sub) < len(sup):\n        return False\n    elif sub == sup:\n        return True\n\n    for i in range(0, len(sub)):\n        if not isSubset(sub[i:], sup[:i]):\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    print(isSubset([1, 2, 3], [1, 2, 3, 4]))\n    print(isSubset([1, 2, 3], [1, 2, 3]))\n    print(isSubset([1, 2, 3], [1, 2]))\n    print(isSubset([1, 2], [1, 2, 3]))\n    print(isSubset([1, 2, 3], [1, 2]))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        for i in range(len(subset)):\n            if subset[i]!= superset[i]:\n                return False\n        for i in range(len(subset), len(superset)):\n            if subset[i]!= superset[i]:\n                return False\n        return True\n\na = [[1, 2], [2], [1, 2, 3], [1, 3], [2, 3], [1, 2, 3]]\nprint Solution().isSubset(a, [[1, 2, 3], [1, 2], [1, 3]])\nprint Solution().isSubset(a, [[1, 2, 3], [1, 3], [2, 3], [1, 2, 3]])\nprint Solution().isSubset(a, [[1, 2, 3], [1, 3], [2, 3], [1, 2]])\nprint Solution().isSubset(a, [[1, 2, 3], [1, 3], [2, 3], [1, 2]])\nprint Solution().isSubset(a, [[1, 2, 3], [1, 3], [2, 3], [1, 2, 3]])\nprint Solution().isSubset(a, [[1, 2, 3], [1, 3], [2, 3], [1, 2]])"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSubtree(self, root: TreeNode, s: TreeNode) -> bool:\n        if root is None or s is None:\n            return False\n\n        if root.val!= s.val:\n            return False\n\n        if root.left is None and root.right is None:\n            return True\n\n        if root.left is not None:\n            if not self.isSubtree(root.left, s):\n                return False\n        if root.right is not None:\n            if not self.isSubtree(root.right, s):\n                return False\n        return True\n\n# Note:\n# https://leetcode.com/problems/is-subtree/discuss/83554/Java-O(N)-C++-Binary-Tree-Sorted-Set-and-Binary-Tree-Sorted-Set-in-O(N)-Time"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSubtree(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: bool\n        \"\"\"\n        if l1 == None or l2 == None:\n            return False\n        elif l1.val == l2.val:\n            return self.isSubtree(l1.left, l2.left) and self.isSubtree(l1.right, l2.right)\n        elif l1.val < l2.val:\n            return self.isSubtree(l1.left, l2) or self.isSubtree(l1, l2.right)\n        else:\n            return self.isSubtree(l1.right, l2.left) or self.isSubtree(l1.right, l2)\n\nif __name__ == '__main__':\n    sol = Solution()\n    #print sol.isSubtree(TreeNode(1), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(2))\n    print sol.isSubtree(TreeNode(2), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(2))\n    print sol.isSubtree(TreeNode(1), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(2))\n    print sol.isSubtree(TreeNode(2), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(2))\n    print sol.isSubtree(TreeNode(2), TreeNode(1))\n    print sol.isSubtree(TreeNode(1), TreeNode(2))\n    print sol.isSubtree(TreeNode(2), TreeNode(2))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "def is_subset(nested_list, target_list):\n    if not isinstance(nested_list, list):\n        return False\n    if not isinstance(target_list, list):\n        return False\n    if len(nested_list) > len(target_list):\n        return False\n    for i in range(len(nested_list)):\n        if not is_subset(nested_list[i], target_list[i:]):\n            return False\n    return True\n\nif __name__ == '__main__':\n    test_cases = [[[1,2,3], [3,4,5]], [[1,2,3], [3,4]], [[1,2], [3,4]]]\n    for test in test_cases:\n        result = is_subset(test[0], test[1])\n        print(result)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        \n        for i in range(len(subset)):\n            if not self.isSubset(subset[i], superset):\n                return False\n        \n        return True"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "def isSubset(nestedList, subsetList):\n    \"\"\"\n    :type nestedList: List[List[int]]\n    :type subsetList: List[int]\n    :rtype: bool\n    \"\"\"\n    for i in range(len(nestedList)):\n        if i == 0:\n            if nestedList[i] == subsetList:\n                return True\n        else:\n            if not isSubset(nestedList[i], subsetList):\n                return False\n    return True"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "# https://www.geeksforgeeks.org/check-if-a-nested-list-is-a-subset-of-another-nested-list/\n\ndef is_subset(l1, l2):\n    for i in range(len(l1)):\n        if not l2[i] in l1[i]:\n            return False\n    return True\n\ndef main():\n    print(is_subset([1,2,3], [1,2,3]))\n    print(is_subset([1,2,3], [1,2,3,4]))\n    print(is_subset([1,2,3,4,5], [1,2,3,4,5]))\n    print(is_subset([1,2,3], [1,2,3,4]))\n    print(is_subset([1,2,3], [1,2,3,4,5]))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 45,
      "score": 3.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        for s in subset:\n            if not s in superset:\n                return False\n        return True\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/is-subset/solution/\n\nApproach #1: Dynamic Programming\nComplexity Analysis\nTime Complexity: O(n^2 + m^2), where n is the length of the subset and m is the length of the superset.\nSpace Complexity: O(n + m).\n\n# 4ms 100%\nclass Solution {\n    public boolean isSubset(List<List<Integer>> subset, List<List<Integer>> superset) {\n        if (subset.size() > superset.size()) return false;\n        for (int i = 0; i < subset.size(); i++) {\n            for (int j = 0; j < superset.get(i).size(); j++) {\n                if (superset.get(i).get(j)!= subset.get(i).get(j)) return false;\n            }\n        }\n        return true;\n    }\n}\n\nApproach #2: HashTable\nComplexity Analysis\nTime Complexity: O(n + m), where n is the length of the subset and m is the length of the superset.\nSpace Complexity: O(n + m).\n\n# 3ms 100%\nclass Solution {\n    public boolean isSubset(List<List<Integer>> subset, List<List<Integer>> superset) {\n        HashMap<List<Integer>, Boolean> map = new HashMap<>();\n        for (int i = 0; i < subset.size(); i++) {\n            map.put(subset.get(i), true"
    },
    {
      "rank": 46,
      "score": 2.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         self.head = head\n#         self.nodes = []\n#         self.nodes.append(head)\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: List[int]\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return True\n\n        if len(subset) > len(nums):\n            return False\n\n        for i in range(len(subset)):\n            if subset[i]!= nums[i]:\n                return False\n        return True"
    },
    {
      "rank": 47,
      "score": 2.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n\n        if subset is None:\n            return True\n\n        if subset.val!= nums[0]:\n            return False\n\n        # TODO: write a recursive solution\n\n        return self.isSubset(subset.next, nums[1:])\n\n    def isSubset2(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n\n        if subset is None:\n            return True\n\n        if subset.val!= nums[0]:\n            return False\n\n        # TODO: write a recursive solution\n\n        return self.isSubset2(subset.next, nums[1:])\n\n\nif __name__ == '__main__':\n    assert Solution().isSubset([1], [1,2,3])\n    assert Solution().isSubset([1], [1])\n    assert Solution().isSubset([1], [2])\n    assert Solution().isSubset([1], [1,2])\n    assert Solution().isSubset([1], [2,3])\n    assert Solution().isSubset([1], [3,4])\n    assert Solution().isSubset([1], [2,3,4])\n    assert Solution().isSubset([1], [1,2,3,4])\n    assert Solution().isSubset([1], [1,2,3,4,5])\n    assert Solution().isSubset([1], [1,2,3,4,5,6])\n\n    assert Solution().isSubset2([1], [1,2,3])\n    assert Solution().isSubset2([1], [1])\n    assert Solution().isSubset2"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "def is_subset(nested_list, target_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type target_list: List[int]\n    :rtype: bool\n    \"\"\"\n    # Your code here\n    # Return False if the target is a subset of the nested_list, otherwise return True\n    return False\n\n# Your function here\n\nif __name__ == '__main__':\n    print(is_subset([[1,2], [1,2,3], [1,2,3,4]], [[1,2], [1,2], [1,2,3]]))"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        count = 0\n        for i in range(len(nums)):\n            while subset and subset.val!= nums[i]:\n                count += 1\n                subset = subset.next\n            if subset and subset.val == nums[i]:\n                count += 1\n        return count >= len(nums)\n\n    # @param {ListNode[]} subset\n    # @param {ListNode[]} nums\n    # @return {boolean}\n    def isSubset(self, subset, nums):\n        if len(nums) == 0:\n            return False\n        if len(subset) == 0:\n            return True\n\n        return self.isSubset(subset.next, nums) and self.isSubset(subset.next.next, nums)\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.isSubset([1,2,3], [1,2,3,4])\n    print solution.isSubset([1,2,3], [1,2,3])\n    print solution.isSubset([1,2,3], [1,2,3,4,5])\n    print solution.isSubset([1,2,3], [1,2,3,4,5,6])\n    print solution.isSubset([1,2,3], [1,2,3,4,5,6,7])\n    print solution.isSubset([1,2,3], [1,2,3,4,5,6,7,8])\n    print solution.isSubset([1,2,3], [1,2,3,4,5,6,7,8,9])\n    print solution.isSubset([1,2,3], [1,2,3,4,"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, nexts=None):\n        self.val = val\n        self.nexts = nexts if nexts else []\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        # https://leetcode.com/problems/is-subset/discuss/144415/Java-O(N)-Solution\n        if not subset:\n            return True\n        if subset.val < subset.nexts[0].val:\n            return False\n        if subset.val == subset.nexts[0].val:\n            for i in range(len(subset.nexts) - 1):\n                if subset.nexts[i].val < subset.nexts[i + 1].val:\n                    return False\n            return True\n        if subset.val > subset.nexts[0].val:\n            return False\n        if subset.val == subset.nexts[0].val:\n            for i in range(len(subset.nexts) - 1):\n                if subset.nexts[i].val > subset.nexts[i + 1].val:\n                    return False\n            return True\n        return False\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3]\n    subset = NestedListNode(1, [NestedListNode(2, [NestedListNode(3)]), NestedListNode(4, [NestedListNode(5)])])\n    print Solution().isSubset(subset, nums)\n    nums = [1, 2, 3]\n    subset = NestedListNode(1, [NestedListNode(2, [NestedListNode(3)])])\n    print Solution().isSubset(subset, nums)\n    nums = [1, 2, 3]\n    subset = NestedListNode(1, [NestedList"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSubtree(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root or not p:\n            return False\n        if root.val == p.val:\n            return True\n        if root.val > p.val:\n            return False\n        if root.val < p.val:\n            return self.isSubtree(root.left, p) and self.isSubtree(root.right, p)\n        return self.isSubtree(root.left, p) or self.isSubtree(root.right, p)"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head1\n    # @param {ListNode} head2\n    # @return {boolean}\n\n    def isSubset(self, head1, head2):\n        if not head1 or not head2:\n            return False\n        \n        while head1 and head2:\n            if head1.val!= head2.val:\n                return False\n            head1 = head1.next\n            head2 = head2.next\n        return True"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return True\n        if subset.val == nums[0]:\n            return self.isSubset(subset.next, nums[1:])\n        return False\n\nif __name__ == '__main__':\n    sol = Solution()\n    subset = ListNode(1)\n    nums = [1,2,3]\n    print sol.isSubset(subset, nums)"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for num in nums:\n            while subset:\n                if subset.val!= num:\n                    break\n                subset = subset.next\n            else:\n                stack.append(num)\n        if not stack:\n            return True\n        if len(stack) > len(nums):\n            return False\n        for i in range(len(stack)):\n            if stack[i]!= nums[i]:\n                return False\n        return True"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) == 0:\n            return True\n        if len(subset) > len(superset):\n            return False\n        subset_dict = defaultdict(list)\n        for i in subset:\n            for j in i:\n                subset_dict[j].append(i)\n        for i in superset:\n            if i not in subset_dict:\n                return False\n            for j in i:\n                if j not in subset_dict[i]:\n                    return False\n        return True\n\n\nif __name__ == '__main__':\n    assert Solution().isSubset([[1, 2]], [[1, 2]])\n    assert Solution().isSubset([[1, 2]], [[1], [2]])\n    assert Solution().isSubset([[1, 2]], [[2], [1]])\n    assert Solution().isSubset([[1, 2], [2, 3], [3, 4]], [[1, 2], [2, 3], [3, 4]])\n    assert Solution().isSubset([[1, 2], [2, 3], [3, 4]], [[1, 2], [2, 3]])"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "# Definition for a Nested list.\nclass NestedListNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSubset(self, subset, nested):\n        \"\"\"\n        :type subset: List[int]\n        :type nested: List[NestedListNode]\n        :rtype: bool\n        \"\"\"\n        n = len(subset)\n        m = len(nested)\n        \n        if n > m:\n            return False\n        \n        for i in range(m):\n            if subset[i] < nested[i].val:\n                return False\n        \n        return self.isSubset(subset, nested[:m]) and self.isSubset(subset, nested[m:])"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n\tdef __init__(self, val=0, next=None):\n\t\tself.val = val\n\t\tself.next = next\n\nclass Solution:\n\t\n\t# @param head, a ListNode\n\t# @param m, an integer\n\t# @param n, an integer\n\t# @return a boolean\n\tdef isSubset(self, head, m, n):\n\t\t\n\t\tif not head or not n:\n\t\t\treturn False\n\t\t\n\t\tif head.val!= m:\n\t\t\treturn False\n\t\t\n\t\t# start from head and check all the nodes\n\t\tnode = head\n\t\twhile node and node.val!= n:\n\t\t\tnode = node.next\n\t\t\n\t\t# if node is None, then head is not the subset\n\t\tif not node:\n\t\t\treturn False\n\t\t\n\t\t# if node is not None, then we have the subset\n\t\treturn self.isSubset(node.next, m, n)\n\t\t\n\tdef isSubset2(self, head, m, n):\n\t\t\n\t\tif not head or not n:\n\t\t\treturn False\n\t\t\n\t\tif head.val!= m:\n\t\t\treturn False\n\t\t\n\t\t# start from head and check all the nodes\n\t\tnode = head\n\t\twhile node and node.val!= n:\n\t\t\tnode = node.next\n\t\t\n\t\t# if node is None, then head is not the subset\n\t\tif not node:\n\t\t\treturn False\n\t\t\n\t\t# if node is not None, then we have the subset\n\t\treturn self.isSubset2(node.next, m, n)\n\t\t\n\t# @param head, a ListNode\n\t# @return a boolean\n\tdef isSubset(self, head):\n\t\t\n\t\tif not head or not head.next:\n\t\t\treturn False\n\t\t\n\t\treturn self.isSubset2(head, head.val, head.next.val)\n\t\t\n\t# @param head, a ListNode\n\t# @return a boolean\n\tdef isSubset2(self, head):\n\t\t\n\t\tif not head:\n\t\t\treturn False\n\t\t\n\t\tif head.val == head.next.val:\n\t\t\treturn self.isSubset2(head.next"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedListNode:\n#     def __init__(self, val=0, children=None):\n#         self.val = val\n#         self.children = children\n#         self.next = None\n\nclass Solution:\n    # @param a nested list\n    # @param b nested list\n    # @return a boolean\n    def isSubset(self, head, tail):\n        if head is None:\n            return False\n        if tail is None:\n            return True\n        while head is not None:\n            if head.val!= tail.val:\n                return False\n            if tail.next is None:\n                return False\n            head = head.next\n            tail = tail.next.next\n        return True"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         \"\"\"\n#         head: the head node of the nested list.\n#         \"\"\"\n#         self.head = head\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @param other, a list node\n    # @return a boolean\n    def isSubset(self, head, other):\n        if not head or not other:\n            return False\n        \n        while head and other:\n            if head.val!= other.val:\n                return False\n            head = head.next\n            other = other.next\n        return True"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, node):\n        \"\"\"\n        :type subset: List[ListNode]\n        :type node: ListNode\n        :rtype: bool\n        \"\"\"\n        if not subset:\n            return True\n\n        curr = node\n        while curr is not None:\n            if subset.index(curr) == 0:\n                return True\n            curr = curr.next\n\n        return False\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.isSubset([], None))\n    print(sol.isSubset([1], [1, 2, 3]))\n    print(sol.isSubset([1, 2], [1, 2, 3]))\n    print(sol.isSubset([1, 2], [1, 2, 3, 4]))\n    print(sol.isSubset([1, 2, 3], [1, 2, 3, 4, 5, 6]))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        result = False\n        n = len(nums)\n        if n == 0:\n            return True\n        for i in range(n):\n            if subset.val!= nums[i]:\n                return False\n            subset = subset.next\n        return True\n\nif __name__ == '__main__':\n    sol = Solution()\n    a = ListNode(1)\n    a.next = ListNode(2, a)\n    a.next.next = ListNode(3)\n    a.next.next.next = ListNode(4)\n    a.next.next.next.next = ListNode(5)\n    b = ListNode(1)\n    b.next = ListNode(2)\n    b.next.next = ListNode(3)\n    b.next.next.next = ListNode(4)\n    b.next.next.next.next = ListNode(5)\n    print(sol.isSubset(a, [2,3,4]))\n    print(sol.isSubset(a, [2,3,4,5]))\n    print(sol.isSubset(b, [2,3,4]))\n    print(sol.isSubset(b, [2,3,4,5]))"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n\n        if len(subset) > len(superset):\n            return False\n\n        for i in range(len(subset)):\n            if not subset[i] <= superset[i]:\n                return False\n\n        for i in range(len(subset)):\n            for j in range(len(superset)):\n                if not subset[i][j] >= superset[j]:\n                    return False\n\n        return True"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param other, a ListNode\n    # @return a boolean\n    def isSubset(self, head, other):\n        if not head or not other:\n            return head == other\n        \n        if not head.next:\n            return False\n        \n        p = head.next\n        while p:\n            if not other or other.val < p.val:\n                return False\n            if other.val == p.val:\n                if not self.isSubset(p, other.next):\n                    return False\n                other = other.next\n            p = p.next\n        return True\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.isSubset([1,2,3], [2,3]))"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if subset == superset:\n            return True\n\n        if len(subset) > len(superset):\n            return False\n\n        for i in range(len(subset)):\n            if self.isSubset(subset[i], superset[i]):\n                return True\n\n        return False\n\n\n    def isSubset2(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if subset == superset:\n            return True\n\n        if len(subset) > len(superset):\n            return False\n\n        for i in range(len(subset)):\n            if self.isSubset2(subset[i], superset[i]):\n                return True\n\n        return False\n\n\n    def isSubset3(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if subset == superset:\n            return True\n\n        if len(subset) > len(superset):\n            return False\n\n        for i in range(len(subset)):\n            if self.isSubset3(subset[i], superset[i]):\n                return True\n\n        return False\n\n\n\nif __name__ == \"__main__\":\n    subset = [ [1], [2,2], [3,3,3] ]\n    superset = [ [1,2,2], [3,3,3,3] ]\n\n    print Solution().isSubset(subset, superset)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, next):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, nestedList, targetList):\n        \"\"\"\n        :type nestedList: List[NestedListNode]\n        :type targetList: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nestedList:\n            return False\n        if len(nestedList)!= len(targetList):\n            return False\n        if not nestedList[0].val:\n            return True\n        if targetList[0]!= nestedList[0].val:\n            return False\n        return self.isSubset(nestedList[1:], targetList[1:])"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList(object):\n#     def __init__(self, head):\n#         \"\"\"\n#         head: the head node of the nested list\n#         \"\"\"\n#         self.head = head\n#         self.next = None\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if subset == None or nums == None:\n            return False\n\n        # 1. \u6839\u636e\u94fe\u8868\u7684head\u548c\u6ca1\u6709\u4e3a\u7a7a\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u5224\u65ad\u662f\u5426\u662fsubset\u7684head\n        # 2. \u5982\u679csubset\u7684head\u662fnums\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u5219\u8fd4\u56deTrue\n        # 3. \u5982\u679csubset\u7684head\u4e0d\u662fnums\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u5219\u8fd4\u56deFalse\n        while subset.next!= None:\n            # \u5982\u679csubset\u7684head\u4e0d\u662fnums\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u5219\u8fd4\u56deFalse\n            if subset.head!= nums[-1]:\n                return False\n            subset = subset.next\n        return True\n\nif __name__ == '__main__':\n    #n1 = ListNode(1)\n    #n2 = ListNode(2)\n    #n1.next = n2\n    #print Solution().isSubset(n1, [1,2])\n    #print Solution().isSubset(n1, [2,1])\n    n1 = ListNode(1)\n    n2 = ListNode(2)\n    n3 = ListNode(3)\n    n1.next = n2\n    n2.next = n3\n    print Solution().isSubset(n1, [1,2])\n    print Solution().isSubset(n1, [2,1])\n    print Solution().isSubset(n1, [3,1"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[int]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return True\n        \n        if len(subset) > len(superset):\n            return False\n        \n        for i in range(len(subset)):\n            if subset[i] is None or subset[i]!= superset[i:]:\n                return False\n        \n        return True"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "import collections\n\nclass Solution:\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # TODO: Write the solution using the following\n        # if len(subset) > len(superset):\n        #     return False\n        # for i in xrange(len(superset)):\n        #     if not self.isSubset(subset[i], superset[i]):\n        #         return False\n        # return True\n\n        # TODO: Write the solution using the following\n        # for i in xrange(len(superset)):\n        #     if subset[0][i] > superset[0][i]:\n        #         return False\n        # for i in xrange(1, len(subset)):\n        #     if subset[i][0] > superset[i][0]:\n        #         return False\n        # return True\n\n        # TODO: Write the solution using the following\n        # if subset[-1] > superset[-1]:\n        #     return False\n        # for i in xrange(len(superset) - 1, -1, -1):\n        #     if subset[0][i] > superset[i][0]:\n        #         return False\n        # return True\n\n        # TODO: Write the solution using the following\n        # if subset[0][-1] > superset[-1][0]:\n        #     return False\n        # for i in xrange(1, len(superset)):\n        #     if subset[0][i] > superset[i][0]:\n        #         return False\n        # return True\n\n        # TODO: Write the solution using the following\n        # if subset[-1][-1] > superset[-1][-1]:\n        #     return False\n        # for i in xrange(len(superset) - 1, -1, -1):\n        #     if subset[-1][i] > superset[i][-1]:\n        #         return False\n        #"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "from collections import deque\n\ndef is_subset(L1, L2):\n    \"\"\"\n    :type L1: List[List[int]]\n    :type L2: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    if len(L1) > len(L2):\n        return False\n\n    for i in range(len(L2)):\n        if not is_subset(L1[i], L2[i]):\n            return False\n\n    return True\n\nclass Solution(object):\n    def isSubset(self, set, s):\n        \"\"\"\n        :type set: List[List[int]]\n        :type s: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(set) > len(s):\n            return False\n\n        for i in range(len(s)):\n            if not self.isSubset(set[i], s[i]):\n                return False\n\n        return True\n\nif __name__ == \"__main__\":\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3]]) == True\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2],[3,4]]) == False\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3]]) == True\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3],[3,4]]) == False\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3],[3,4,5]]) == True\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3],[4,5]]) == False\n    assert Solution().isSubset([[1,2,3], [3,4,5]], [[1,2,3],[4,5,6]]) == False\n    assert Solution().isSubset([["
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isSubtree(self, root, par):\n        \"\"\"\n        :type root: TreeNode\n        :type par: TreeNode\n        :rtype: bool\n        \"\"\"\n        if root is None or par is None:\n            return False\n\n        if root == par:\n            return True\n\n        if par.val < root.val:\n            return self.isSubtree(root.right, par) or self.isSubtree(root.left, par)\n        else:\n            return self.isSubtree(root.left, par) or self.isSubtree(root.right, par)\n\n\ndef main():\n    sol = Solution()\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6)))\n    par = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))\n    print(sol.isSubtree(root, par))\n    root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4, TreeNode(5, TreeNode(6))))\n    par = TreeNode(1, TreeNode(2, TreeNode(3)))\n    print(sol.isSubtree(root, par))\n    root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4, TreeNode(5, TreeNode(6))))\n    par = TreeNode(1, TreeNode(2))\n    print(sol.isSubtree(root, par))\n    root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)))\n    par = TreeNode(1, TreeNode(2, TreeNode(3)))\n    print(sol.isSubtree(root, par))\n    root = TreeNode(1, TreeNode(2, TreeNode(3)))\n    par = TreeNode(1, TreeNode(2, TreeNode(3)))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedListNode:\n#     def __init__(self, val=None, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    # @param head, a list node\n    # @param n, an integer\n    # @return a boolean\n    def isSubset(self, head, n):\n        if not head:\n            return False\n        if not n:\n            return True\n        if head.val < n:\n            return self.isSubset(head.next, n)\n        else:\n            return head.val == n and self.isSubset(head.next, n - 1)"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        return all(self.isSubset(subset[i:], superset) for i in range(len(subset)))\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.isSubset([[1], [2], [3]], [[1], [2], [3]]))\n    print(sol.isSubset([[1], [2], [3]], [[1, 2], [1, 3], [2, 3]]))\n    print(sol.isSubset([[1], [2]], [[1, 2]]))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/nested-list-subset/\n# Definition for a  ListNode.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def isSubList(self, head, mHead):\n        \"\"\"\n        :type head: ListNode\n        :type mHead: ListNode\n        :rtype: bool\n        \"\"\"\n        if mHead is None:\n            return True\n        if mHead.val < head.val:\n            return False\n        if mHead.val > head.val:\n            return self.isSubList(head, mHead.next)\n        if mHead.val == head.val:\n            return self.isSubList(head.next, mHead.next)\n        return False\n\n# Note:\n# Definition for a  ListNode.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def isSubList(self, head, mHead):\n        \"\"\"\n        :type head: ListNode\n        :type mHead: ListNode\n        :rtype: bool\n        \"\"\"\n        if mHead is None:\n            return True\n        if mHead.val < head.val:\n            return False\n        if mHead.val > head.val:\n            return self.isSubList(head, mHead.next)\n        if mHead.val == head.val:\n            return self.isSubList(head.next, mHead.next)\n        return False"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param B, a list of integers\n    # @return a boolean\n    def isSubset(self, A, B):\n        if A is None or B is None:\n            return False\n        if len(A) > len(B):\n            return False\n        \n        for i in range(len(A)):\n            if A[i]!= B[i]:\n                return False\n            \n            if A[i] == B[i]:\n                continue\n            \n            if self.isSubset(A[i+1:], B[i+1:]):\n                return True\n            else:\n                return False\n        \n        return True\n\na = [1,2,3,4,5]\nb = [1,3,5]\nprint Solution().isSubset(a, b)"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[NestedListNode]\n        :type superset: List[NestedListNode]\n        :rtype: bool\n        \"\"\"\n        # Write your code here\n        def is_sub(node, target_node):\n            if node is None:\n                return False\n            if node.val == target_node.val:\n                return True\n            if node.val < target_node.val:\n                return False\n            if target_node.next is None:\n                return False\n            if is_sub(node.next, target_node.next):\n                return True\n            return False\n        \n        start = 0\n        end = len(subset)\n        while start < end:\n            mid = (start+end)/2\n            if is_sub(subset[mid], superset[0]):\n                start = mid + 1\n            else:\n                end = mid\n        return start == len(subset)"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "import collections\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(subset) > len(superset):\n            return False\n        if len(subset) == 0:\n            return True\n\n        for i in range(len(subset)):\n            if subset[i]!= superset[i]:\n                return False\n            if not self.isSubset(subset[i + 1], superset[i + 1]):\n                return False\n\n        return True\n\n    def isSubset2(self, subset, superset):\n        return all(x in subset for x in superset)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    # print(s.isSubset([[1], [1, 2], [1, 2, 3]], [[1, 2, 3], [1, 2]]))\n    # print(s.isSubset2([[1], [1, 2], [1, 2, 3]], [[1, 2, 3], [1, 2]]))\n    assert(s.isSubset(\n        [[1], [1, 2], [1, 2, 3]],\n        [[1, 2, 3], [1, 2]]\n    ))\n    assert(s.isSubset2(\n        [[1], [1, 2], [1, 2, 3]],\n        [[1, 2, 3], [1, 2]]\n    ))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, A, B):\n        \"\"\"\n        :type A: List[List[int]]\n        :type B: List[int]\n        :rtype: bool\n        \"\"\"\n        if A is None or B is None:\n            return False\n        if len(A) > len(B):\n            return False\n        for i in range(len(B)):\n            if not self.isSubset(A[i], B[i:]):\n                return False\n        return True\n\n\nif __name__ == \"__main__\":\n    assert Solution().isSubset([[1, 2, 3], [1], [2, 2]], [1, 2, 2, 2]) == True\n    assert Solution().isSubset([[1, 2, 3], [1], [2, 2]], [1, 2, 2, 2, 3]) == False\n    assert Solution().isSubset([[1, 2, 3], [1], [2, 2]], [1, 2, 2, 2, 3, 4]) == False"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         self.head = head\n#         self.next = None\n\nclass Solution:\n    # @param two ListNode\n    # @return a boolean\n    def isSubset(self, subset, list):\n        if len(subset) == 0 or len(list) == 0:\n            return False\n        if subset[0]!= list[0]:\n            return False\n        if len(subset) == 1:\n            return True\n        if len(subset) == 2:\n            return subset[1] == list[1]\n        if subset[1] == list[1]:\n            return subset[2] == list[2] or subset[2] == list[2]\n        if subset[2] == list[2]:\n            return subset[3] == list[3] or subset[3] == list[3]\n        if subset[3] == list[3]:\n            return subset[4] == list[4] or subset[4] == list[4]\n        return False"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not subset:\n            return False\n        if not nums:\n            return True\n        \n        pivot = subset.val\n        head = subset\n        while head:\n            if head.val!= pivot:\n                return False\n            head = head.next\n        \n        return head.val == nums[0]\n        \n\nif __name__ == \"__main__\":\n    sol = Solution()\n    subset = ListNode(1)\n    nums = [1, 2]\n    print(sol.isSubset(subset, nums))\n    nums = [1, 2, 3, 4]\n    print(sol.isSubset(subset, nums))\n    nums = [1, 2, 3]\n    print(sol.isSubset(subset, nums))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# Definition for a N-ary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @param node, a list of tree node\n    # @return a boolean\n    def isSubset(self, root, node):\n        if root is None:\n            return True\n        elif len(node) == 0:\n            return False\n        else:\n            if root.val!= node[0]:\n                return False\n            else:\n                return self.isSubset(root.left, node[1:]) and self.isSubset(root.right, node[1:])"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if subset is None:\n            return False\n        if subset.val > nums[0]:\n            return False\n        subset = subset.next\n        while subset:\n            if subset.val > nums[0]:\n                return False\n            subset = subset.next\n        return True"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head1\n    # @param {ListNode} head2\n    # @return {boolean}\n    def isSubset(self, head1, head2):\n        if not head1 or not head2:\n            return False\n        \n        while head1 and head2:\n            if head1.val!= head2.val:\n                return False\n            head1 = head1.next\n            head2 = head2.next\n        \n        return True\n\nif __name__ == '__main__':\n    print Solution().isSubset([1, 2, 3], [1, 2])\n    print Solution().isSubset([1, 2], [1, 2, 3])\n    print Solution().isSubset([1, 2, 3], [1, 2, 3])\n    print Solution().isSubset([1, 2, 3], [])"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n\n        for i in xrange(len(subset)):\n            if not subset[i] or subset[i]!= superset[i]:\n                return False\n        return True\n\nclass Solution2(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n\n        for i in xrange(len(subset)):\n            if not subset[i] or subset[i]!= superset[i]:\n                return False\n        return True"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/valid-nested-list-subset/\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(subset) == 0:\n            return True\n        if len(nums) == 0:\n            return False\n\n        for i in range(len(nums)):\n            if nums[i] not in subset[0]:\n                return False\n            if not self.isSubset(subset[i + 1:], nums[i:]):\n                return False\n        return True\n\n    def isSubset2(self, subset, nums):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 0:\n            return True\n        if len(subset) == 0:\n            return False\n\n        for i in range(len(subset)):\n            if subset[i][0] > nums[0]:\n                return False\n            if not self.isSubset2(subset[i + 1:], nums[1:]):\n                return False\n        return True\n\n\n\nif __name__ == '__main__':\n    nums = [1, 2]\n    subset = [[1, 2], [1, 3], [2, 4], [3, 4]]\n    print(Solution().isSubset(subset, nums))\n    print(Solution().isSubset2(subset, nums))\n\n    nums = [1]\n    subset = [[1]]\n    print(Solution().isSubset(subset, nums))\n    print(Solution().isSubset2(subset, nums))\n\n    nums = [1, 2]\n    subset = [[1, 2]]\n    print(Solution().isSubset(subset, nums))\n    print(Solution().isSubset2(subset, nums))\n\n    nums = [1, 2]"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head1\n    # @param {ListNode} head2\n    # @return {boolean}\n    def isSubset(self, head1, head2):\n        if head1 is None or head2 is None:\n            return False\n\n        if head1.val == head2.val:\n            return self.isSubset(head1.next, head2.next)\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    head1 = ListNode(1)\n    head2 = ListNode(2)\n    head1.next = ListNode(1)\n    head2.next = ListNode(3)\n    head1.next.next = ListNode(1)\n    head2.next.next = ListNode(3)\n    head1.next.next.next = ListNode(2)\n    head2.next.next.next = ListNode(3)\n    print solution.isSubset(head1, head2)"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         self.val = head\n#         self.next = None\n\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[NestedList]\n        :type superset: List[NestedList]\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n\n        if subset == superset:\n            return True\n\n        if subset[0] is None or superset[0] is None:\n            return False\n\n        if subset[0].val == superset[0].val:\n            return self.isSubset(subset[1:], superset[1:])\n\n        if subset[0].val < superset[0].val:\n            return self.isSubset(subset[1:], superset)\n\n        return False\n\n    def isSubset2(self, subset, superset):\n        \"\"\"\n        :type subset: List[NestedList]\n        :type superset: List[NestedList]\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n\n        if subset == superset:\n            return True\n\n        if subset[0] is None or superset[0] is None:\n            return False\n\n        if subset[0].val == superset[0].val:\n            return self.isSubset2(subset[1:], superset)\n\n        if subset[0].val < superset[0].val:\n            return self.isSubset2(subset, superset[1:])\n\n        return False\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n\n    subset = [1, 2, 3, 4, 5]\n    superset = [1, 2, 3, 4, 5]\n    print(sol.isSubset(subset, superset))\n    print(sol.isSubset2(subset, superset))\n\n    subset = [1, 2, 3, 4]\n    superset = [1, 2"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         \"\"\"\n#         head: the head node of the nested list.\n#         \"\"\"\n#         self.head = head\n#         self.size = 1\n#         while self.head:\n#             self.size += 1\n#             self.head = self.head.next\n#         self.size -= 1\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: ListNode\n        :type superset: ListNode\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n        if subset.val!= superset.val:\n            return False\n        if subset.val == superset.val:\n            return self.isSubset(subset.next, superset.next)\n        return False\n\n    def isSubset1(self, subset, superset):\n        \"\"\"\n        :type subset: ListNode\n        :type superset: ListNode\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n        if subset.val!= superset.val:\n            return False\n        if subset.val == superset.val:\n            return self.isSubset1(subset.next, superset.next)\n        return False\n\n    def isSubset2(self, subset, superset):\n        \"\"\"\n        :type subset: ListNode\n        :type superset: ListNode\n        :rtype: bool\n        \"\"\"\n        if subset is None or superset is None:\n            return False\n        if subset.val!= superset.val:\n            return False\n        if subset.val == superset.val:\n            return self.isSubset2(subset.next, superset.next)\n        return False"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def isSubList(self, head, sublist):\n        \"\"\"\n        :type head: ListNode\n        :type sublist: ListNode\n        :rtype: bool\n        \"\"\"\n        if head is None or sublist is None:\n            return False\n        if head == sublist:\n            return True\n        if head.val!= sublist.val:\n            return False\n        if not self.isSubList(head.next, sublist.next):\n            return False\n        return True"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param m, an integer\n    # @param n, an integer\n    # @return a boolean\n    def isSubset(self, head, m, n):\n        if head is None:\n            return False\n        if head.val == m or head.val == n:\n            return True\n        if head.val < m or head.val < n:\n            return False\n        if head.next is None:\n            return False\n        return self.isSubset(head.next, m, n)\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    print Solution().isSubset(head, 2, 2)\n    print Solution().isSubset(head, 2, 3)\n    print Solution().isSubset(head, 3, 2)\n    print Solution().isSubset(head, 3, 3)"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\n# class NestedList:\n#     def __init__(self, head):\n#         self.head = head\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @return a boolean\n    def isSubset(self, subset, head):\n        if subset == [] or head == None:\n            return True\n        if subset[0] == head.val:\n            return self.isSubset(subset[1:], head.next)\n        else:\n            return False\n\ns = Solution()\nsubset = [[1,2,3], [4,5,6], [7,8,9]]\nhead = NestedList(1)\nhead.next = NestedList(2)\nhead.next.next = NestedList(3)\nhead.next.next.next = NestedList(4)\nhead.next.next.next.next = NestedList(5)\nhead.next.next.next.next.next = NestedList(6)\nhead.next.next.next.next.next.next = NestedList(7)\nhead.next.next.next.next.next.next.next = NestedList(8)\nhead.next.next.next.next.next.next.next.next = NestedList(9)\nprint(s.isSubset(subset, head))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            cur = self\n            ret = \"[\"\n            while cur:\n                ret = ret + str(cur.val) + \",\"\n                cur = cur.next\n            ret = ret + \"]\"\n            return ret\n        else:\n            return \"nil\"\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not subset or not nums:\n            return False\n        if nums[0] < subset.val:\n            return False\n        cur = subset\n        while cur:\n            if cur.val > nums[0]:\n                break\n            cur = cur.next\n        else:\n            return True\n        for i in range(1, len(nums)):\n            if cur.val > nums[i]:\n                return False\n            cur = cur.next\n        return True\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,4,5]\n    subset = ListNode(4)\n    subset.next = ListNode(2)\n    subset.next.next = ListNode(1)\n    print Solution().isSubset(subset, nums)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Solution:\n    # @param lists, a list of lists of integers\n    # @return a boolean\n    def isSubset(self, lists):\n        # write your code here\n        if not lists:\n            return True\n        if not lists[0]:\n            return False\n        head = lists[0]\n        prev = head\n        for i in xrange(1, len(lists)):\n            if not lists[i]:\n                return False\n            curr = lists[i]\n            while curr:\n                if prev.val < curr.val:\n                    prev = prev.next\n                else:\n                    curr = curr.next\n                if prev:\n                    prev = prev.next\n            prev = head\n        return True"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param: A list\n    @param: B list\n    @return: a boolean\n    \"\"\"\n    def isSubset(self, A, B):\n        \"\"\"\n        A list A is a subset of another list B if we can take the elements of A and put them all in B.\n\n        Example 1:\n        A = [1,2]\n        B = [1,2,3]\n        Return true.\n\n        Example 2:\n        A = [1,2]\n        B = [1]\n        Return false.\n        \"\"\"\n        if len(A) > len(B):\n            return False\n\n        for i in range(len(A)):\n            if A[i] > B[i]:\n                return False\n            else:\n                if B[i] > A[i]:\n                    return False\n\n        return True\n\nif __name__ == '__main__':\n    A = [1,2]\n    B = [1,2,3]\n\n    print Solution().isSubset(A,B)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef is_subset(nested_list, target_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :type target_list: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    # TODO\n    return False\n\nif __name__ == '__main__':\n    nested_list = [[1,2,3],[4,5,6]]\n    target_list = [[1,2,3],[4,5,6,7]]\n    print(is_subset(nested_list, target_list))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @param node1, a tree node\n    # @param node2, a tree node\n    # @return a boolean\n    def isSubset(self, root, node1, node2):\n        if root is None:\n            return False\n        if root.val > node1.val or root.val < node2.val:\n            return False\n        if root.val == node1.val and self.isSubset(root.left, node1, node2) and self.isSubset(root.right, node1, node2):\n            return True\n        if root.val == node2.val and self.isSubset(root.left, node2, node1) and self.isSubset(root.right, node2, node1):\n            return True\n        return False\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.isSubset(TreeNode(0), TreeNode(0), TreeNode(1)))\n    print(s.isSubset(TreeNode(0), TreeNode(0), TreeNode(1)))\n    print(s.isSubset(TreeNode(0), TreeNode(0), TreeNode(0)))\n    print(s.isSubset(TreeNode(0), TreeNode(1), TreeNode(1)))"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return True\n\n        for i in range(len(subset)):\n            if not subset[i]:\n                return False\n\n            for j in range(len(subset[i])):\n                if subset[i][j] not in subset:\n                    return False\n\n        for i in range(len(superset)):\n            if not superset[i]:\n                return False\n\n            for j in range(len(superset[i])):\n                if superset[i][j] not in superset[i]:\n                    return False\n\n        return True\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return True\n\n        for i in range(len(subset)):\n            if not subset[i]:\n                return False\n\n            for j in range(len(subset[i])):\n                if subset[i][j] not in subset:\n                    return False\n\n        for i in range(len(superset)):\n            if not superset[i]:\n                return False\n\n            for j in range(len(superset[i])):\n                if superset[i][j] not in superset[i]:\n                    return False\n\n        return True"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def isSubset(self, subset, nums):\n        \"\"\"\n        :type subset: ListNode\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def dfs(head, tail):\n            if head is None:\n                return tail is None\n            if tail is None:\n                return False\n            if head.val > tail.val:\n                return dfs(head.next, tail)\n            elif head.val < tail.val:\n                return dfs(head.next, tail.next)\n            else:\n                return dfs(head.next, tail.next.next)\n\n        return dfs(subset, nums)"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from collections import deque\n\n\nclass Solution(object):\n    def isSubset(self, subset, superset):\n        \"\"\"\n        :type subset: List[List[int]]\n        :type superset: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not subset or not superset:\n            return False\n\n        if len(subset) > len(superset):\n            return False\n\n        if len(superset) == len(subset):\n            return True\n\n        for i in range(len(superset)):\n            if subset[i] == superset[i]:\n                continue\n            else:\n                return False\n\n        return True\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.isSubset([[1], [2]], [[1, 2], [1]])\n    print s.isSubset([[1, 2, 3], [2, 3]], [[1, 2], [1, 2, 3]])\n    print s.isSubset([[1, 2], [1, 2, 3]], [[1, 2], [1, 2, 3]])"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/check-if-a-linked-list-is-a-subset-of-another-linked-list/\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def isSubset(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: ListNode\n        :rtype: bool\n        \"\"\"\n        if head is None or target is None:\n            return False\n        if target.val >= head.val:\n            return False\n        if target.val <= head.val:\n            return self.isSubset(head.next, target)\n        if target.val == head.val:\n            return self.isSubset(head.next, target.next)\n        if target.val < head.val:\n            return self.isSubset(head, target.next)\n        if target.val > head.val:\n            return self.isSubset(head.next, target)\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    target = ListNode(2)\n    target.next = ListNode(3)\n    target.next.next = ListNode(4)\n    print Solution().isSubset(head, target)"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef is_subset(list_1, list_2):\n    \"\"\"\n    :type list_1: List[List[int]]\n    :type list_2: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    if len(list_1) < len(list_2):\n        return False\n    if len(list_1) > len(list_2):\n        return True\n\n    return set(list_1) <= set(list_2)\n\nclass Solution:\n    def isSubset(self, set1, set2):\n        \"\"\"\n        :type set1: List[List[int]]\n        :type set2: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if len(set1) < len(set2):\n            return False\n        if len(set1) > len(set2):\n            return True\n\n        res = defaultdict(list)\n        for i in set1:\n            res[i[0]].append(i[1])\n        for i in set2:\n            if i[0] in res:\n                if i[1] not in res[i[0]]:\n                    return False\n            else:\n                return False\n\n        return True\n\nif __name__ == \"__main__\":\n    assert Solution().isSubset([[1,2],[2,3]], [[1],[1,2]]) == True\n    assert Solution().isSubset([[1,2],[2,3]], [[1,2],[1,2,3]]) == True\n    assert Solution().isSubset([[1,2],[2,3]], [[1,2],[2,3],[1,2,3]]) == False\n    assert Solution().isSubset([[1,2],[2,3]], [[1,3],[2,3]]) == False"
    }
  ]
}