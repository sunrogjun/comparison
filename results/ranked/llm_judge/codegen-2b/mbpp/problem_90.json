{
  "timestamp": "2025-09-14T18:02:00.187224",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 90,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 1:\n            return -1\n        if n < k:\n            return nums[0]\n        if k == 1:\n            return nums[0]\n        if k == n:\n            return nums[n - 1]\n        if k < n / 2:\n            left = self.findKthLargest(nums[:k], k)\n            right = self.findKthLargest(nums[k:], k)\n            return nums[left] if left > right else right\n        else:\n            right = self.findKthLargest(nums[k:], k - k % 2)\n            left = self.findKthLargest(nums[:k], k - k % 2)\n            return nums[left] if left > right else right\n\n\nif __name__ == '__main__':\n    print Solution().findKthLargest([1, 2, 3, 4, 5], 4)"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/find-kth-element-in-sorted-array\n\ndef find_kth(arr, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    Input:\n        arr: A sorted array of size n.\n        k: An integer.\n    Output:\n        The kth element of the given array.\n    \"\"\"\n    # Binary search\n    # if k is 0, return the first element\n    if k == 0:\n        return arr[0]\n    # if k is n, return the last element\n    if k == len(arr):\n        return arr[-1]\n    # otherwise, use the binary search to find the kth element\n    # in the sorted array.\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = left + (right - left) / 2\n        if arr[mid] < k:\n            left = mid + 1\n        elif arr[mid] > k:\n            right = mid - 1\n        else:\n            return arr[mid]\n    return arr[left]\n\n\nif __name__ == '__main__':\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = int(input())\n    print(find_kth(arr, k))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/discuss/342299/Python-O(n)-Solutions-Using-Two-Pointers\n# https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/discuss/342299/Java-O(n)-Solutions-Using-Two-Pointers\n# https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/discuss/342299/Java-O(n)-Solutions-Using-Two-Pointers\n# https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/discuss/342299/Java-O(n)-Solutions-Using-Two-Pointers\n# https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/discuss/342299/Java-O(n)-Solutions-Using-Two-Pointers\n\nimport unittest\nimport collections\n\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        # sort the array\n        # return nums[k-1]\n        nums.sort()\n        return nums[k-1]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/find-k-th-element-in-sorted-array-ii/solution/\n#\nApproach #1: Two Pointers [Accepted]\nComplexity Analysis\nTime Complexity: O(n), where n is the size of the array.\nSpace Complexity: O(1)\n\n#"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if len(arr) <= 1:\n        return arr[0]\n\n    if len(arr) <= k:\n        return arr[k]\n\n    l = 0\n    r = len(arr) - 1\n\n    while l < r:\n        mid = l + (r - l) / 2\n        if arr[mid] == arr[l]:\n            l = mid + 1\n        else:\n            r = mid\n\n    return arr[r]\n\n# Your KthElement object will be instantiated and called as such:\n# obj = KthElement(arr,k)\n# param_1 = obj.kth_element(arr,k)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0: return 0\n        if n == 1: return nums[0]\n        if k == 1: return max(nums)\n        if k == n: return nums[-1]\n\n        # find left and right of the kth largest\n        left = 0\n        right = n - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= nums[right]:\n                right = mid\n            elif nums[mid] < nums[right]:\n                left = mid + 1\n            else:\n                return nums[mid]\n        return nums[left]"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def kthToTail(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        while head:\n            count += 1\n            head = head.next\n        k -= 1\n        while count > k:\n            head = head.next\n            count -= 1\n        return head.val"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1:\n            return nums[0]\n        if k == 1:\n            return nums[0]\n        if k == len(nums):\n            return nums[-1]\n        max = max(nums)\n        min = min(nums)\n        if min == max:\n            return min\n        start = 0\n        end = len(nums) - 1\n        while start < end:\n            mid = start + (end - start) / 2\n            if nums[mid] < max:\n                start = mid + 1\n            elif nums[mid] > max:\n                end = mid\n            elif nums[mid] == max:\n                k -= 1\n                if k == 1:\n                    return nums[mid]\n        if k == 1:\n            return nums[start]\n        return nums[start]"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # write your code here\n        l = len(num)\n        if k < l:\n            return self.findKthLargest(num[l-k:], k)\n        else:\n            return num[-k-1]"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def start_string(self):\n        return str(self.start)\n\n    def end_string(self):\n        return str(self.end)\n\n    def __repr__(self):\n        return self.start_string() + \" \" + self.end_string()\n\n\nclass Solution:\n    \"\"\"\n    @param intervals: A list of Interval\n    @return: The kth interval\n    \"\"\"\n    def findKthInterval(self, intervals, k):\n        if len(intervals) < 1:\n            return None\n        left = 0\n        right = len(intervals) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if intervals[mid].end < k:\n                right = mid - 1\n            elif intervals[mid].end == k:\n                return intervals[mid]\n            else:\n                left = mid + 1\n        return None\n\n\nif __name__ == \"__main__\":\n    print Solution().findKthInterval([Interval(1, 3), Interval(6, 9), Interval(15, 18)], 16)\n    print Solution().findKthInterval([Interval(1, 3), Interval(6, 9), Interval(15, 18)], 0)\n    print Solution().findKthInterval([Interval(1, 3), Interval(6, 9), Interval(15, 18)], 15)"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param {integer[]} intervals\n    # @param {integer} k\n    # @return {integer}\n    def findKth(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(intervals) == 0:\n            return 0\n        if k < 1 or k > len(intervals):\n            return -1\n        # sort intervals by start\n        intervals = sorted(intervals, key=lambda x: x.start)\n        # find the first interval\n        i = 0\n        while i < len(intervals) and intervals[i].start <= k:\n            i += 1\n        if i == len(intervals):\n            return -1\n        # find the kth interval\n        j = i\n        while j < len(intervals) and intervals[j].start <= k:\n            j += 1\n        return intervals[i].end if i == j - 1 else intervals[j - 1].end"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def getKth(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not head:\n            return None\n        p1 = head\n        p2 = head\n        for i in range(k):\n            p1 = p1.next\n        while p1:\n            p2 = p2.next\n        while p2.next:\n            p1 = p1.next\n            p2 = p2.next\n        return p1.val"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                break\n        return nums[left] if left == k else nums[right]"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/kth-element-in-sorted-array/\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n#"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import sys\n\nclass Solution:\n    def kth(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        idx = k - 1\n        for i in range(len(nums) - 1, -1, -1):\n            if i == k - 1:\n                return nums[idx]\n            idx -= 1\n            if nums[idx] == nums[i]:\n                idx -= 1\n        return -1\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.kth([1, 2, 3, 4, 5], 3))\n    print(sol.kth([], 1))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) < k:\n            return -1\n        if len(nums) == k:\n            return nums[k - 1]\n        \n        def select(nums, start, end, k):\n            if start == end:\n                return nums[start]\n            mid = start + (end - start) / 2\n            if mid == k - 1:\n                return nums[mid]\n            elif mid > k - 1:\n                return select(nums, start, mid, k)\n            else:\n                return select(nums, mid + 1, end, k)\n        \n        return select(nums, 0, len(nums) - 1, k)"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        def getLargest(nums, start, end):\n            if start >= end:\n                return nums[start]\n            mid = (start + end) / 2\n            if nums[mid] > nums[end]:\n                return getLargest(nums, mid + 1, end)\n            else:\n                return getLargest(nums, start, mid)\n        \n        return getLargest(nums, 0, len(nums) - 1)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0 or k <= 0:\n            return 0\n        max_heap = []\n        for i in range(len(nums)):\n            if i == len(nums) - 1:\n                max_heap.append(nums[i])\n            elif nums[i] > nums[k]:\n                max_heap.append(nums[i])\n            elif nums[i] == nums[k]:\n                if len(max_heap) == k:\n                    return nums[i]\n                else:\n                    max_heap.append(nums[i])\n        return max_heap[k - 1]\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(Solution().findKthLargest(nums, 3))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getKth(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        cur = head\n        for i in range(k):\n            cur = cur.next\n        while cur:\n            cur = cur.next\n            if i == k - 1:\n                break\n        return cur\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(15)\n    head.next.next.next.next.next"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if len(nums) == 2:\n            if nums[0] < nums[1]:\n                return nums[0]\n            else:\n                return nums[1]\n        \n        mid = len(nums) / 2\n        \n        if k <= mid:\n            return self.findKthLargest(nums[:k], k)\n        else:\n            return self.findKthLargest(nums[mid:], k - mid)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findKthLargest([1, 2, 3, 4, 5], 2))\n    print(s.findKthLargest([1, 2, 3, 4, 5], 3))\n    print(s.findKthLargest([1, 2, 3, 4, 5], 7))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        return self.findKthLargestRec(nums, 0, len(nums) - 1, k)\n        \n    def findKthLargestRec(self, nums, start, end, k):\n        if start == end:\n            if nums[start] > nums[end]:\n                return nums[start]\n            else:\n                return nums[end]\n        \n        mid = start + (end - start) / 2\n        \n        if nums[mid] > nums[end]:\n            return self.findKthLargestRec(nums, start, mid, k)\n        elif nums[mid] < nums[end]:\n            return self.findKthLargestRec(nums, mid + 1, end, k)\n        else:\n            return nums[mid]\n            \n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findKthLargest(range(1, 10), 1))\n    print(s.findKthLargest(range(1, 10), 5))\n    print(s.findKthLargest(range(1, 10), 10))\n    print(s.findKthLargest(range(1, 10), 11))\n    print(s.findKthLargest(range(1, 10), -1))\n    print(s.findKthLargest(range(1, 10), 0))\n    print(s.findKthLargest(range(1, 10), 1))\n    print(s.findKthLargest(range(1, 10), 10))\n    print(s.findKthLargest(range(1, 10), 11))\n    print(s.findKthLargest(range(1, 10), -1))\n    print(s.findKthLargest(range(1, 10), 0))\n    print(s.findKthLargest("
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k > n:\n            return nums[n-1]\n        if k == n:\n            return nums[n-1]\n        if k == 1:\n            return nums[0]\n        pivot = nums[k-1]\n        i = k-1\n        while i < n:\n            if nums[i] < pivot:\n                nums[i], nums[k-1] = nums[k-1], nums[i]\n                i += 1\n            else:\n                break\n        nums[i], nums[k-1] = nums[k-1], nums[i]\n        if i == k-1:\n            return nums[k-1]\n        nums[i], nums[k-1] = nums[k-1], nums[i]\n        i = k-1\n        while i >= 0:\n            if nums[i] < pivot:\n                nums[i], nums[k-1] = nums[k-1], nums[i]\n                i -= 1\n            else:\n                break\n        nums[i], nums[k-1] = nums[k-1], nums[i]\n        return nums[k-1]\n\n\n# Note:\n# kth largest is O(n)\n# kth smallest is O(log(n))\n# O(log(n)) because we need to find the kth smallest element.\n# Time complexity: O(log(n))"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution:\n    def kthToTail(self, head: ListNode, k: int) -> ListNode:\n        if k == 1:\n            return head\n        elif k == 2:\n            return head if head else None\n\n        node = head\n        while k > 1:\n            node = node.next\n            k -= 1\n        return node\n\nif __name__ == '__main__':\n    s = Solution()\n    arr = [1,2,3,4,5,6,7,8,9]\n    for i in range(10):\n        head = ListNode(arr[i])\n        head.next = ListNode(arr[i+1])\n        head.next.next = ListNode(arr[i+2])\n        head.next.next.next = ListNode(arr[i+3])\n        head.next.next.next.next = ListNode(arr[i+4])\n        head.next.next.next.next.next = ListNode(arr[i+5])\n        head.next.next.next.next.next.next = ListNode(arr[i+6])\n        head.next.next.next.next.next.next.next = ListNode(arr[i+7])\n        head.next.next.next.next.next.next.next.next = ListNode(arr[i+8])\n        head.next.next.next.next.next.next.next.next.next = ListNode(arr[i+9])\n        print(s.kthToTail(head, 9))"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # find the max element\n        max_num = max(nums)\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] > max_num:\n                max_num = nums[j]\n                i = j\n            if i == k - 1:\n                return max_num\n        return max_num"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @param k, integer\n    # @return an integer\n    def findKthLargest(self, num, k):\n        # write your code here\n        \n        if len(num) == 0:\n            return 0\n\n        if len(num) == 1:\n            return num[0]\n\n        n = len(num)\n        m = len(num) / 2\n        # initialize the max\n        max = num[m]\n        # find the max of the left half\n        for i in range(m):\n            if num[i] > max:\n                max = num[i]\n        # find the max of the right half\n        for i in range(m + 1, n):\n            if num[i] > max:\n                max = num[i]\n        # compare\n        for i in range(m, n):\n            if num[i] > max:\n                max = num[i]\n            elif num[i] < max:\n                max = num[i]\n            \n        # find the index\n        i = m\n        j = n - 1\n        while i < j:\n            # find the index of max\n            while num[i] < max:\n                i += 1\n            while num[j] > max:\n                j -= 1\n            if i < j:\n                num[i], num[j] = num[j], num[i]\n                i += 1\n                j -= 1\n        \n        # compare to k\n        if k < num[m]:\n            return self.findKthLargest(num[:m], k)\n        elif k > num[m]:\n            return self.findKthLargest(num[m + 1:], k - num[m])\n        else:\n            return num[m]\n\nif __name__ == '__main__':\n    s = Solution()\n    #print s.findKthLargest([3, 2, 1, 5, 6, 4], 5)\n    #print s.findKthLargest([1, 2, 3, 4, 5, 6], 6)\n    #print s.findKth"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        l, r = 0, len(nums)-1\n        while l <= r:\n            mid = l + (r-l)/2\n            if nums[mid] < nums[r]:\n                l = mid + 1\n            elif nums[mid] > nums[r]:\n                r = mid - 1\n            else:\n                return nums[mid]\n        return nums[l]"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param num, a list of integer\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(num)\n        if k == 1:\n            return num[0]\n        if k > n:\n            return num[n - 1]\n        if k == n:\n            return num[0]\n        if k == n + 1:\n            return num[-1]\n        # sort num\n        tmp = num[:]\n        tmp.sort()\n        # find the index\n        i = k - 2\n        while i >= 0:\n            if num[i] < num[k - 1]:\n                k = i + 1\n            else:\n                break\n            i -= 1\n        return tmp[k - 1]"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_largest = nums[0]\n        kth_largest_index = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[kth_largest_index]:\n                kth_largest = nums[i]\n                kth_largest_index = i\n        return kth_largest"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/kth-element-in-a-sorted-matrix/problem\n\ndef kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # Sort the array\n    arr.sort()\n\n    # Start from the end of the array\n    for i in range(len(arr) - 1, 0, -1):\n        # If we reach the kth element, return it\n        if i == k:\n            return arr[i]\n\n        # If we haven't reached the kth element yet, move one element to the left\n        else:\n            arr[i] = arr[i - 1]\n\n# Testcases\n\n# arr = [1, 3, 2, 4, 5, 6, 7, 8, 9]\n# arr = [1, 2, 3, 4, 5]\n# arr = [1, 2, 3, 4, 5, 6, 7]\n# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nk = 3\nprint(kth_element(arr, k))"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # note:\n        # 1. the kth largest is not the last element\n        # 2. it doesn't matter if the last element is the largest\n        # 3. if there are multiple largest, we choose the one that is the kth largest\n        # 4. we do not need to sort the list first\n        # 5. the following code is tricky:\n        #    1. we need to determine the value of the kth element\n        #    2. we need to find the index of the kth largest value\n        #    3. we need to find the index of the kth largest value from the sorted list\n        #    4. we need to find the kth largest value from the sorted list\n        #    5. we need to sort the list\n        #    6. the sorted list needs to be used to find the kth largest value\n        #    7. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    8. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    9. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    10. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    11. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    12. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    13. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    14. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    15. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    16. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    17. the sorted list needs to be used to find the kth largest value from the sorted list\n        #    18"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        else:\n            heap = []\n            heap.extend(nums)\n            heapq.heapify(heap)\n            for i in range(len(heap)):\n                heapq.heappop(heap)\n            return heap[k-1]"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return nums[0]\n        if len(nums) == 1:\n            return nums[0]\n\n        mid = len(nums) / 2\n        if len(nums) % 2 == 0:\n            left = nums[:mid]\n            right = nums[mid:]\n        else:\n            left = nums[:mid]\n            right = [nums[mid]]\n            right.extend(nums[mid+1:])\n\n        left.sort()\n        right.sort()\n\n        if k == 2:\n            return max(left)\n\n        if k == len(left):\n            return left[-1]\n\n        return max(right[k-2:])\n\n\nif __name__ == \"__main__\":\n    nums = [1,2,3,4,5,6,7,8,9,10]\n    print(Solution().findKthLargest(nums, 3))"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @param k, an integer\n    # @return a list node\n    def getKth(self, head, k):\n        if head is None:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        if k == 1:\n            return slow\n        k -= 1\n        slow = slow.next\n        while k > 0:\n            fast = fast.next\n            k -= 1\n        slow.next = slow.next.next\n        return head"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def kthNode(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        dummy = dummy.next\n        pre = dummy\n        for i in range(k):\n            pre = pre.next\n        while pre.next is not None:\n            pre = pre.next\n        return pre.val\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.kthNode([1, 2, 3, 4, 5], 4)\n    print s.kthNode([1, 2, 3, 4, 5], 5)\n    print s.kthNode([1, 2, 3, 4, 5], 0)\n    print s.kthNode([1, 2, 3, 4, 5], 6)"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        if len(nums) == 1:\n            return nums[0]\n\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] < nums[right]:\n                left = mid + 1\n            elif nums[mid] > nums[right]:\n                right = mid - 1\n            else:\n                return nums[mid]\n\n        return nums[left]"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "import numpy as np\n\n\ndef kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    :param arr: A numpy array.\n    :param k: A positive integer.\n    :return: The kth element in the given array.\n    \"\"\"\n    # If the array is empty, return None.\n    if len(arr) == 0:\n        return None\n\n    # If the array is too small, return the first element.\n    if len(arr) < k:\n        return arr[0]\n\n    # If the array is too large, return the last element.\n    if k > len(arr):\n        return arr[-1]\n\n    # If the kth element is not in the first k elements, return the first element.\n    if k > len(arr) - k:\n        return arr[0]\n\n    # Otherwise, return the kth element.\n    return arr[k - 1]\n\n\ndef kth_element_2(arr, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    :param arr: A numpy array.\n    :param k: A positive integer.\n    :return: The kth element in the given array.\n    \"\"\"\n    # If the array is empty, return None.\n    if len(arr) == 0:\n        return None\n\n    # If the array is too small, return the first element.\n    if len(arr) < k:\n        return arr[0]\n\n    # If the array is too large, return the last element.\n    if k > len(arr):\n        return arr[-1]\n\n    # If the kth element is not in the first k elements, return the first element.\n    if k > len(arr) - k:\n        return arr[0]\n\n    # Otherwise, return the kth element.\n    return arr[k - 1]\n\n\ndef kth_element_3(arr, k):\n    \"\"\"\n    Find the kth element in the given array.\n\n    :param arr: A numpy array.\n    :param k: A positive integer.\n    :return: The kth element in the given array.\n    \"\"\"\n    # If the array is"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def kthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return None\n        if k == 1:\n            return nums[0]\n        if k == n:\n            return nums[n - 1]\n        if k > n:\n            return nums[n - 1]\n        pivot = self.partition(nums, k - 1)\n        if pivot == k - 1:\n            return nums[pivot]\n        elif pivot < k - 1:\n            return self.kthLargest(nums[pivot + 1:k], k - 1)\n        else:\n            return self.kthLargest(nums[:pivot], k - pivot)\n\n    def partition(self, nums, k):\n        pivot = nums[k - 1]\n        i = k - 1\n        for j in range(k - 1, -1, -1):\n            if nums[j] > pivot:\n                nums[j + 1], nums[i] = nums[i], nums[j + 1]\n                i = j\n        nums[i + 1], nums[k] = nums[k], nums[i + 1]\n        return i + 1\n\nif __name__ == '__main__':\n    print(Solution().kthLargest([1, 5, 7, 10, 11], 4))"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k < 0:\n            return nums[-k - 1]\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == k:\n            return nums[k - 1]\n        middle = len(nums) / 2\n        if k == middle:\n            return nums[k - 1]\n        if k > middle:\n            return self.findKthLargest(nums[middle:], k - middle)\n        return self.findKthLargest(nums[:middle], k - 1)\n\nprint Solution().findKthLargest([-1, 2, 3, 4, 5, 6], 3)\nprint Solution().findKthLargest([-1, 2, 3, 4, 5, 6], 1)\nprint Solution().findKthLargest([-1, 2, 3, 4, 5, 6], 7)"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "def findKth(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    l = 0\n    r = n - 1\n    while l <= r:\n        m = (l + r) / 2\n        if arr[m] == k:\n            return m\n        elif arr[m] > k:\n            r = m - 1\n        else:\n            l = m + 1\n    return l\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(findKth(arr, 9))\n    print(findKth(arr, 0))\n    print(findKth(arr, 15))\n    print(findKth(arr, 11))\n    print(findKth(arr, -1))"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, A, k):\n        \"\"\"\n        :type A: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(A) < k:\n            return -1\n        else:\n            return self.findKthLargestRecu(A, 0, len(A)-1, k)\n\n    def findKthLargestRecu(self, A, start, end, k):\n        if start == end:\n            return A[start]\n        else:\n            mid = (start + end) / 2\n            if A[mid] > A[end]:\n                return self.findKthLargestRecu(A, start, mid, k)\n            elif A[mid] < A[end]:\n                return self.findKthLargestRecu(A, mid + 1, end, k)\n            else:\n                return A[start]\n\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print Solution().findKthLargest(A, 3)"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "import sys\n\nclass Solution(object):\n    def kthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) < k:\n            return nums[0]\n        else:\n            nums.sort()\n            return nums[k - 1]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    s = Solution()\n    print s.kthLargest(nums, k)"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def kthToTail(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if head is None:\n            return None\n        if k == 1:\n            return head\n        curr = head\n        while curr.next is not None:\n            curr = curr.next\n            k -= 1\n        curr = head\n        while k > 0:\n            curr = curr.next\n            k -= 1\n        return curr.val\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    head.next.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(14)\n    head.next.next.next.next.next"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution:\n    # @param head, a list node\n    # @param k, an integer\n    # @return a list node\n    def getKth(self, head, k):\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast.next:\n            fast = fast.next\n        if k == 1:\n            return fast\n        slow = slow.next\n        while k > 1:\n            slow = slow.next\n            k -= 1\n        return slow\n        \n    def getKth(self, head, k):\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast.next:\n            fast = fast.next\n        if k == 1:\n            return fast\n        slow = slow.next\n        while k > 1:\n            slow = slow.next\n            k -= 1\n        return slow\n        \n    def getKth(self, head, k):\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        if fast.next:\n            fast = fast.next\n        if k == 1:\n            return fast\n        slow = slow.next\n        while k > 1:\n            slow = slow.next\n            k -= 1\n        return slow"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/find-k-th-element-in-sorted-array/\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def findKthLargest(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n        elif k == 1:\n            return head.val\n        elif k == 2:\n            return max(head.val, head.next.val)\n        else:\n            if not head.next:\n                return head.val\n            pivot = head.val\n            left = head.next\n            while left:\n                if left.val > pivot:\n                    pivot = left.val\n                left = left.next\n            return pivot\n\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @param k: An integer\n    @return: An integer\n    \"\"\"\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] < nums[j]:\n                i += 1\n            else:\n                j -= 1\n        if k - 1 == i:\n            return nums[i]\n        else:\n            return nums[i]"
    },
    {
      "rank": 45,
      "score": 10.0,
      "candidate": "def kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # https://discuss.leetcode.com/topic/12063/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/17084/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/12063/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/18084/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/18084/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/18084/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://discuss.leetcode.com/topic/19186/java-python-dp-solution\n    # https://disc"
    },
    {
      "rank": 46,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k < 1 or k > n:\n            return nums[n - 1]\n        i, j = 0, n - 1\n        while i < j:\n            m = (i + j) / 2\n            if m < k:\n                i = m + 1\n            elif m > k:\n                j = m - 1\n            else:\n                return nums[m]\n        return nums[i]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(Solution().findKthLargest(nums, 10))\n    print(Solution().findKthLargest(nums, 2))\n    print(Solution().findKthLargest(nums, 5))"
    },
    {
      "rank": 47,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1:\n            return nums[0]\n        if k == 1:\n            return nums[0]\n        if k > len(nums):\n            return nums[-1]\n        if k == len(nums):\n            return nums[-1]\n        mid = len(nums) / 2\n        if k == 2:\n            return nums[mid]\n        if k == mid + 1:\n            return nums[mid]\n        if k > mid + 1:\n            return nums[mid]\n        return self.findKthLargest(nums[:mid], k)\n\n\nif __name__ == \"__main__\":\n    print Solution().findKthLargest([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)"
    },
    {
      "rank": 48,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def kthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < k:\n            return nums[n]\n        else:\n            for i in xrange(n - k + 1):\n                if nums[i] > nums[i + k - 1]:\n                    return nums[i]\n                elif nums[i] < nums[i + k - 1]:\n                    return nums[i + k - 1]\n        return nums[-1]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 3\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5]\n    k = 2\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 8\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 10\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 11\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 12\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 13\n    print sol.kthLargest(nums, k)\n    nums = [1, 2, 3, 4, 5, 6, 7, 8,"
    },
    {
      "rank": 49,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def kthLargestElement(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return nums[0]\n        elif k == 1:\n            return nums[0]\n        else:\n            mid = k / 2\n            return self.findLargest(nums, 0, n - 1, mid)\n\n    def findLargest(self, nums, start, end, mid):\n        if start == end:\n            return nums[start]\n        elif start == end - 1:\n            return max(nums[start], nums[end])\n        else:\n            if nums[start] > nums[end]:\n                return self.findLargest(nums, start + 1, end, mid)\n            else:\n                return self.findLargest(nums, start, end - 1, mid)"
    },
    {
      "rank": 50,
      "score": 9.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, A, k):\n        l = len(A)\n        if l < k:\n            return self.findKthLargest(A, l)\n        elif k == 1:\n            return A[0]\n        elif k == l:\n            return max(A)\n        elif k < l:\n            i = k - 1\n            j = k\n            while i < j:\n                while j >= k and A[j] >= A[i]:\n                    j -= 1\n                while i < j:\n                    if A[i] < A[j]:\n                        A[i] = A[j]\n                        A[j] = A[i]\n                    i += 1\n        return A[k - 1]\n\n\nif __name__ == '__main__':\n    print Solution().findKthLargest([1, 3, 2, 6, 7], 3)"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def find(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    length = len(nums)\n    \n    if length == 0:\n        return 0\n    \n    if length == 1:\n        return nums[0]\n    \n    left = 0\n    right = length - 1\n    \n    while left <= right:\n        mid = (left + right) / 2\n        \n        if nums[mid] == k:\n            return nums[mid]\n        \n        if nums[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return nums[right]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3]\n    k = 2\n    print find(nums, k)\n    \n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    print find(nums, k)\n    \n    nums = [0, 0]\n    k = 0\n    print find(nums, k)\n    \n    nums = [0]\n    k = 0\n    print find(nums, k)\n    \n    nums = [0, 0, 0, 0, 0]\n    k = 0\n    print find(nums, k)"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def find_kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if len(arr) == 0:\n        return arr[k]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find the first index in arr that is less than k\n    # 2. find the second index in arr that is less than k\n    # 3. if the second index is less than k, return arr[second index]\n    # 4. if the second index is greater than k, return arr[first index]\n    \n    # 1. find"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # sort the array and find the kth largest element\n        nums.sort()\n        return nums[k-1]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findKthLargest([3,2,1,5,6,4], 5))\n    print(sol.findKthLargest([3,2,1,5,6,4], 6))\n    print(sol.findKthLargest([3,2,1,5,6,4], 7))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        i = 0\n        j = n - 1\n        while i < j:\n            if nums[i] < nums[j]:\n                i += 1\n            else:\n                j -= 1\n        return nums[i + 1]\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print solution.findKthLargest(nums, 4)"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "from math import ceil\n\nclass Solution(object):\n    def kthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return None\n        if k == 0:\n            return nums[0]\n        if k == 1:\n            return nums[-1]\n        if k == n:\n            return nums[-1]\n\n        mid = ceil(n / 2)\n        left = self.kthLargest(nums[:mid], k - 1)\n        right = self.kthLargest(nums[mid:], k - 1)\n        return max(left, right) if left!= None else right"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 0 or k < 1:\n            return nums[0]\n        \n        pivot = nums[0]\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] > pivot:\n                pivot = nums[j]\n                i = j\n            \n        return self.findKthLargest(nums[i + 1:], k - 1)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_largest = 0\n        for i in range(len(nums)):\n            if i == k:\n                kth_largest = nums[i]\n            elif i < k:\n                kth_largest = max(kth_largest, nums[i])\n        return kth_largest"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def find_kth_element(arr, k):\n    \"\"\"\n    For arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3, the output should be:\n\n    find_kth_element(arr, 3) -> 4\n    find_kth_element(arr, 1) -> 1\n    find_kth_element(arr, 10) -> 10\n    find_kth_element(arr, 2) -> 2\n    find_kth_element(arr, 4) -> 4\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if arr[mid] == k:\n            return mid\n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left if arr[left] == k else left + 1\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 3\n    print(find_kth_element(arr, k))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k < 0 or k >= len(nums):\n            return nums[0]\n        \n        if k == 0:\n            return nums[0]\n        \n        if k == 1:\n            return nums[0] if nums[0] > nums[1] else nums[1]\n        \n        # find the first index of nums[k]\n        for i in range(k):\n            if nums[i] > nums[k]:\n                return nums[i]\n        \n        # find the first index of nums[k-1]\n        for i in range(k-1, -1, -1):\n            if nums[i] > nums[k-1]:\n                return nums[i]\n            \n        return nums[k-1]"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "def kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not arr or len(arr) < 1:\n        return None\n\n    l = 0\n    r = len(arr) - 1\n    while l < r:\n        m = (l + r) / 2\n        if arr[m] < k:\n            l = m + 1\n        elif arr[m] > k:\n            r = m - 1\n        else:\n            return arr[m]\n    return arr[l]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print kth_element(arr, 5)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "import math\n\ndef find_kth(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    return find_kth_recursive(arr, 0, len(arr) - 1, k)\n\ndef find_kth_recursive(arr, start, end, k):\n    if start == end:\n        return arr[start]\n    mid = start + (end - start) / 2\n    if arr[mid] == k:\n        return mid\n    elif arr[mid] > k:\n        return find_kth_recursive(arr, start, mid - 1, k)\n    else:\n        return find_kth_recursive(arr, mid + 1, end, k)\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 6\n    print(find_kth(arr, k))\n    k = 4\n    print(find_kth(arr, k))\n    k = 7\n    print(find_kth(arr, k))\n    k = 0\n    print(find_kth(arr, k))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "class Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k > len(nums):\n            return nums[-1]\n        heap = []\n        for i in range(len(nums)):\n            if i == k - 1:\n                heapq.heappush(heap, nums[i])\n            elif len(heap) < k - i:\n                heapq.heappush(heap, nums[i])\n            else:\n                heapq.heappop(heap)\n                heapq.heappush(heap, nums[i])\n        return heap[0]\n\nif __name__ == '__main__':\n    s = Solution()\n    nums = [1, 3, 2, 2, 3, 1]\n    print s.findKthLargest(nums, 5)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (-nums[i], i))\n        heapq.heapify(heap)\n        for i in range(k):\n            heapq.heappop(heap)\n        return -heap[0][0]"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums or k < 1:\n            return -1\n        # nums.sort()\n        i = 0\n        j = len(nums) - 1\n        while i <= j:\n            mid = i + (j - i) / 2\n            if nums[mid] < nums[k-1]:\n                i = mid + 1\n            elif nums[mid] > nums[k-1]:\n                j = mid - 1\n            else:\n                return nums[k-1]\n        return nums[k-1]\n\na = Solution()\n\nprint a.findKthLargest([1,2,3,4,5,6], 2)"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        elif n == 2:\n            return nums[1] if nums[0] > nums[1] else nums[0]\n        \n        pivot = nums[0]\n        \n        # find the kth smallest element\n        for i in xrange(1, n):\n            if nums[i] > pivot:\n                pivot = nums[i]\n            elif nums[i] < pivot:\n                pivot = i\n        \n        # now pivot is the kth smallest element\n        if k == 1:\n            return nums[0]\n        \n        # get the next kth largest element\n        for i in xrange(1, k):\n            if nums[i] > pivot:\n                return nums[i]\n            \n        # all elements are smaller than the kth largest element\n        return nums[k - 1]"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        heap = []\n        for n in nums:\n            heap.append((n, k))\n            k -= 1\n        heapq.heapify(heap)\n        for i in range(k, 0, -1):\n            heapq.heappop(heap)\n        return heap[0][0]"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def find_kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not arr or k > len(arr):\n        return -1\n    \n    left, mid, right = 0, 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == k:\n            return mid\n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def kth(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if k < 1 or k > n:\n        return -1\n    elif k == 1:\n        return arr[0]\n    elif k == n:\n        return arr[n-1]\n    elif k == 2:\n        return min(arr[0], arr[n-1])\n    else:\n        return arr[k-1]"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "def kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return arr[0]\n    elif k == 1:\n        return arr[0]\n    else:\n        if k > n:\n            return arr[n-1]\n        else:\n            return kth_element(arr[k-1:n-1], k-1)\n\nif __name__ == '__main__':\n    print(kth_element([1, 2, 3, 4], 3))"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def find_kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # Using binary search\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == k:\n            return mid\n        elif arr[mid] > k:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "from collections import defaultdict\nfrom random import randint\n\n\ndef kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    def get_kth_element(arr, k):\n        if len(arr) == 0:\n            return 0\n        if len(arr) == 1:\n            return arr[0]\n        if k == 1:\n            return min(arr)\n        if k == 2:\n            return max(arr)\n        if k >= len(arr):\n            return arr[-1]\n        if k <= 0:\n            return arr[0]\n        if len(arr) == 2:\n            return arr[0]\n        if len(arr) == 3:\n            return arr[1]\n        if k > len(arr) - 2:\n            return arr[-1]\n        if k > len(arr) - 1:\n            return arr[-2]\n        return arr[k-1]\n\n    return get_kth_element(arr, k)\n\nif __name__ == '__main__':\n    arr = [1,2,3,4,5,6,7,8,9,10,11]\n    print(kth_element(arr, 5))\n    print(kth_element(arr, -1))\n    print(kth_element(arr, 3))\n    print(kth_element(arr, 8))\n    print(kth_element(arr, 10))\n    print(kth_element(arr, 0))\n    print(kth_element(arr, 11))"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def find(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    \n    if n == 0:\n        return None\n    \n    if k > n:\n        return arr[n-1]\n    \n    if k == 1:\n        return arr[0]\n    \n    mid = n / 2\n    \n    if k == mid:\n        return arr[k-1]\n    elif k < mid:\n        return find(arr, k)\n    else:\n        return find(arr, k-1)\n\n# Test Cases\n\nprint(find([1,2,3,4,5,6,7,8], 1))\nprint(find([1,2,3,4,5,6,7,8], 2))\nprint(find([1,2,3,4,5,6,7,8], 3))\nprint(find([1,2,3,4,5,6,7,8], 4))\nprint(find([1,2,3,4,5,6,7,8], 5))\nprint(find([1,2,3,4,5,6,7,8], 6))\nprint(find([1,2,3,4,5,6,7,8], 7))\nprint(find([1,2,3,4,5,6,7,8], 8))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        # get the index of the first element\n        i = 0\n        # get the index of the last element\n        j = n - 1\n        # get the index of the kth element\n        kth_index = k - 1\n        # compare the first element with the kth element\n        while i <= j:\n            # if the first element is greater than the kth element\n            # then we have found the kth element\n            if nums[i] > nums[kth_index]:\n                # move the index of the first element to the next one\n                kth_index = kth_index - 1\n            # if the first element is less than the kth element\n            # then we have found the kth element\n            elif nums[i] < nums[kth_index]:\n                # move the index of the last element to the next one\n                kth_index = kth_index - 1\n            # if the first element is equal to the kth element\n            # then we have found the kth element\n            elif i == kth_index:\n                return nums[i]\n            # move the index of the first element to the next one\n            i = i + 1\n        return nums[i]\n\nif __name__ == '__main__':\n    assert Solution().findKthLargest([1, 2, 3, 4, 5, 6], 4) == 4"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def find_kth_element(arr, k):\n    \"\"\"\n    :type arr: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    l = 0\n    r = len(arr) - 1\n    while l < r:\n        m = (l + r) / 2\n        if arr[m] == k:\n            return m\n        elif arr[m] > k:\n            l = m + 1\n        else:\n            r = m - 1\n    return l\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(find_kth_element(arr, 1))\n    print(find_kth_element(arr, 4))\n    print(find_kth_element(arr, 10))"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        else:\n            return self.findKthLargest(nums[:k], k-1)\n\n\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest2(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        else:\n            p = (k-1)/2\n            q = k-1-p\n            if nums[p] > nums[q]:\n                return self.findKthLargest2(nums[p+1:q+1], k)\n            else:\n                return self.findKthLargest2(nums[:p+1], k)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.findKthLargest([3, 4, 1, 2, 3], 3))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        # base case\n        if len(nums) == 0:\n            return -1\n        # binary search\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) / 2\n            if nums[mid] > nums[r]:\n                r = mid - 1\n            elif nums[mid] < nums[r]:\n                l = mid + 1\n            else:\n                return nums[mid]\n        return nums[l]"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "# @include\ndef kth_element(arr, k):\n    # kth element is the kth smallest element in the array.\n    # In this implementation, we start with the largest element in the array\n    # and iteratively find the kth smallest element.\n    # For example, for arr = [2, 5, 7, 1, 3, 4], k = 3, we will return 7.\n    # Then we find the kth smallest element by comparing it with the next\n    # element in the array, and so on.\n    #\n    # We can write a more efficient function by comparing kth_element with\n    # the kth element in the array.\n    #\n    # The complexity of the function is O(n).\n    # The space complexity is O(1).\n    #\n    # Assume that we have a list of n elements.\n    #\n    # The complexity of kth_element is O(log(n)).\n    # The space complexity of kth_element is O(1).\n    #\n    # The time complexity of kth_element is O(log(n)).\n    # The space complexity of kth_element is O(1).\n    if k == 1:\n        return arr[0]\n    elif k == n:\n        return arr[-1]\n    elif k > n:\n        return None\n    else:\n        if k == 2:\n            return min(arr)\n        elif k == 3:\n            return arr[k - 1]\n        else:\n            # We start with the largest element in the array.\n            # Then we find the kth smallest element by comparing it with the\n            # next element in the array, and so on.\n            # We can write a more efficient function by comparing kth_element\n            # with the kth element in the array.\n            #\n            # We can write a more efficient function by comparing kth_element\n            # with the kth element in the array.\n            #\n            # The complexity of the function is O(log(n)).\n            # The space complexity of kth_element is O(1).\n            #\n            # The time complexity of kth_element is O(log(n)).\n            # The space complexity of"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0 or k <= 0:\n            return None\n        mid = len(nums) / 2\n        if k == 1:\n            return nums[0]\n        if k == len(nums):\n            return nums[len(nums) - 1]\n        if k > len(nums):\n            return nums[mid]\n        if k - 1 < mid:\n            return nums[k - 1]\n        else:\n            return nums[mid]\n\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().findKthLargest(nums, 1))\n    print(Solution().findKthLargest(nums, 3))\n    print(Solution().findKthLargest(nums, 5))\n    print(Solution().findKthLargest(nums, 6))\n    print(Solution().findKthLargest(nums, 7))"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKth(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n\n        left = 0\n        right = len(intervals) - 1\n\n        while left <= right:\n            mid = (left + right) / 2\n            if intervals[mid].start <= k:\n                left = mid + 1\n            elif intervals[mid].end >= k:\n                right = mid - 1\n            else:\n                return mid + 1\n        return -1\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findKth([Interval(1, 3), Interval(2, 6), Interval(8, 10)], 4)\n    print s.findKth([Interval(1, 3), Interval(2, 6), Interval(8, 10)], 5)\n    print s.findKth([Interval(1, 3), Interval(2, 6), Interval(8, 10)], 9)\n    print s.findKth([Interval(1, 3), Interval(2, 6), Interval(8, 10)], 0)"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution:\n    def kthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if k == n:\n            return nums[-1]\n        if k == 1:\n            return nums[0]\n        if k > n:\n            return nums[n - 1]\n        pivot = nums[k - 2]\n        i = 0\n        while i < k - 1:\n            if nums[i] > pivot:\n                i += 1\n            else:\n                break\n        j = k - 1\n        while j < n:\n            if nums[j] > pivot:\n                j += 1\n            else:\n                break\n        if i < j:\n            return self.kthLargest(nums[i:j], k - i)\n        elif i == j:\n            return nums[i]\n        else:\n            return self.kthLargest(nums[i + 1:j], k - j - 1)"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-k-th-element-in-sorted-array/\n# Given an array of n integers where n > 1,\n# find the nth element.\n# The function should return either\n# the index of the nth element or -1 if the nth element does not exist.\n# Note:\n# You may assume k is always valid, 1 \u2264 k \u2264 n.\n# Example:\n# Given [100, 1, 2, 50, 3, 4, 10, 7], and k = 4, return 5.\n# Note:\n# Your algorithm's time complexity must be better than O(n log n).\n# Try to utilize the knowledge of the array's sort order.\n# Try to split the problem into two parts.\n# Try to utilize the second part's sort order.\n\n# DFS\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKth(self, nums, k):\n        if k == 1:\n            return nums[0]\n        if k == 2:\n            return nums[k - 1]\n        \n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return nums[1]\n\n        m = k / 2\n        if k % 2 == 0:\n            return self.findKth(nums, m)\n        else:\n            return self.findKth(nums[:m], m) + self.findKth(nums[m:], k - m)\n\n\n\n# BFS\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKth(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return nums[1]\n        \n        m = k / 2\n        if k % 2 == 0:"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # O(n)\n        # kth largest is the middle one, so the last k-1 elements are already sorted.\n        # then just do a binary search to find the kth largest\n        if len(nums) <= k:\n            return nums[k - 1]\n        else:\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) / 2\n                if nums[mid] < nums[k - 1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return nums[right]\n\n    def findKthLargest2(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # O(nlog(n))\n        # kth largest is the middle one, so the last k-1 elements are already sorted.\n        # then do a binary search to find the kth largest\n        if len(nums) <= k:\n            return nums[k - 1]\n        else:\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) / 2\n                if nums[mid] < nums[k - 1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return nums[left]\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6]\n    print Solution().findKthLargest(nums, 3)\n    nums = [1, 2, 3, 4, 5, 6, 7,"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def findKthLargest(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not head:\n            return 0\n\n        kth = head\n        while kth.next:\n            kth = kth.next\n            k -= 1\n\n        head = head.next\n        while head and k!= 0:\n            kth = kth.next\n            head = head.next\n            k -= 1\n\n        return kth.val"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        if k == 1:\n            return nums[0]\n        if len(nums) == 1:\n            return nums[0]\n        mid = len(nums) / 2\n        if k == mid:\n            return nums[mid]\n        elif k > mid:\n            return self.findKthLargest(nums[:mid], k - 1)\n        else:\n            return self.findKthLargest(nums[mid:], k - 1)\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.findKthLargest([1, 2, 3, 4, 5, 6], 5))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 1:\n            return nums[0]\n        if k == n:\n            return nums[-1]\n        if k > n:\n            return nums[n - 1]\n\n        p = self.partition(nums, k)\n        return nums[p]\n\n    def partition(self, nums, k):\n        p = 0\n        for i in xrange(k, len(nums)):\n            if nums[i] < nums[p]:\n                p = i\n            else:\n                nums[i], nums[p] = nums[p], nums[i]\n        return p"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def kthToTail(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        if k == 1:\n            return head\n        node = head\n        while k > 1:\n            node = node.next\n            k -= 1\n        return node\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    a1 = ListNode(1)\n    a2 = ListNode(2)\n    a3 = ListNode(3)\n    a4 = ListNode(4)\n    a5 = ListNode(5)\n    a6 = ListNode(6)\n    a7 = ListNode(7)\n    a8 = ListNode(8)\n    a9 = ListNode(9)\n    a10 = ListNode(10)\n    a11 = ListNode(11)\n    a12 = ListNode(12)\n    a13 = ListNode(13)\n    a14 = ListNode(14)\n    a15 = ListNode(15)\n    a16 = ListNode(16)\n    a17 = ListNode(17)\n    a18 = ListNode(18)\n    a19 = ListNode(19)\n    a20 = ListNode(20)\n    a21 = ListNode(21)\n    a22 = ListNode(22)\n    a23 = ListNode(23)\n    a24 = ListNode(24)\n    a25 = ListNode(25)\n    a26 = ListNode(26)\n    a27 = ListNode(27)\n    a28 = ListNode(28)\n    a29 = ListNode(29)\n    a30 = ListNode(30)\n    a31 = ListNode(31)\n    a32 = ListNode(32)\n    a33 = ListNode(33)\n    a34 = ListNode(34)\n    a35 ="
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k > len(nums):\n            return nums[-1]\n        if k == 1:\n            return nums[0]\n        mid = len(nums) / 2\n        if k > mid:\n            return self.findKthLargest(nums[:mid], k-mid)\n        else:\n            return self.findKthLargest(nums[mid:], k-mid)\n\n\nif __name__ == '__main__':\n    nums = [1,3,2,5,3,5,6]\n    k = 4\n    print Solution().findKthLargest(nums, k)"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, intervals, k):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        i = 0\n        max_end = max(x.end for x in intervals)\n        \n        # find the first interval with start >= max_end\n        while i < len(intervals) and intervals[i].start < max_end:\n            i += 1\n        \n        # find the kth largest interval\n        if i == 0:\n            return 0\n        \n        # kth interval starts from i\n        while i < len(intervals) and k > 0:\n            if intervals[i].end > max_end:\n                return max(intervals[i].end - max_end, 0)\n            k -= 1\n            i += 1\n        return 0"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def findKthLargest(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        if k < 1 or k > len(arr):\n            return 0\n        if k == 1:\n            return arr[0]\n\n        p = 0\n        q = len(arr) - 1\n\n        while p < q:\n            mid = (p + q) // 2\n            if arr[mid] <= arr[q]:\n                p = mid + 1\n            else:\n                q = mid\n        return arr[p - 1]"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums: A list of integers\n    # @param k: An integer\n    # @return: An integer\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        if len(nums) < k:\n            return nums[-1]\n        else:\n            return nums[-k]\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findKthLargest([3, 2, 1, 5, 6], 2)"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def getKth(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        while head:\n            count += 1\n            head = head.next\n        if count == k:\n            return head.val\n        elif count > k:\n            return self.getKth(head.next, k)\n        else:\n            return self.getKth(head.next, k - count)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def kthToTail(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 1:\n            return head\n\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        if not fast:\n            return head\n\n        fast = head\n        while k > 1:\n            fast = fast.next\n            k -= 1\n\n        slow = slow.next\n        while fast:\n            slow = slow.next\n            fast = fast.next\n\n        return slow\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    arr = [1, 2, 3, 4, 5]\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, None))))).next\n    head = sol.kthToTail(head, 2)\n    while head:\n        print(head.val)\n        head = head.next"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def getKth(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not head: return 0\n        curr = head\n        count = 1\n        while curr:\n            curr = curr.next\n            count += 1\n        if count <= k:\n            return self.getKth(head.next, k)\n        else:\n            return self.getKth(head, k - count)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif k == 1:\n            return nums[0]\n        elif k == 2:\n            return max(nums)\n        elif k == n:\n            return nums[n - 1]\n        else:\n            mid = (n + 1) / 2\n            left = self.findKthLargest(nums[:mid], k - 1)\n            right = self.findKthLargest(nums[mid:], k - 1)\n            if left < right:\n                return left\n            else:\n                return right"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def kth(self, nums, k):\n        # write your code here\n        if len(nums) == 0:\n            return None\n        \n        if k == 1:\n            return nums[0]\n        \n        if k == len(nums):\n            return nums[-1]\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if k == mid + 1:\n                return nums[mid]\n            elif k < mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[right]"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def getKth(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        q = [head]\n        for i in range(k - 1):\n            if q[-1] is None:\n                return None\n            q.append(q[-1].next)\n        if q[-1] is None:\n            return None\n        return q[-1].val\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = ListNode(13)\n    print(sol.getKth(head, 13))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # O(n)\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if k == 1:\n            return nums[0]\n        if k == 2:\n            return max(nums)\n        if k > n:\n            return nums[n-1]\n        if k <= n/2:\n            # O(n)\n            return self.findKthLargest(nums[:k], k)\n        # O(nlog(n))\n        return self.findKthLargest(nums[k:], k-1)\n\n\n# Time:  O(nlog(n))\n# Space: O(1)\nclass Solution2(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 1:\n            return nums[0]\n        if k == 2:\n            return max(nums)\n        if k > n:\n            return nums[n-1]\n        if k <= n/2:\n            # O(n)\n            return self.findKthLargest(nums[:k], k)\n        # O(nlog(n))\n        return self.findKthLargest(nums[k:], k-1)"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param k, an integer\n    # @return an integer\n    def findKthLargest(self, A, k):\n        return self.findKthLargestRecu(A, 0, len(A) - 1, k)\n\n    def findKthLargestRecu(self, A, start, end, k):\n        if start == end:\n            return A[start]\n        mid = (start + end) / 2\n        if A[mid] < A[start]:\n            if k == mid + 1:\n                return A[mid]\n            else:\n                return self.findKthLargestRecu(A, mid + 1, end, k)\n        else:\n            if k == mid + 1:\n                return A[start]\n            else:\n                return self.findKthLargestRecu(A, start, mid, k)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 1:\n            return nums[0]\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            if nums[0] > nums[1]:\n                return nums[0]\n            return nums[1]\n        if k > len(nums):\n            return nums[len(nums) - 1]\n        if k <= len(nums) / 2:\n            l = 0\n            r = len(nums) - 1\n            while l <= r:\n                mid = (l + r) / 2\n                if nums[mid] >= nums[l] and nums[mid] >= nums[r]:\n                    return nums[mid]\n                if nums[mid] < nums[l]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        else:\n            l = len(nums) - 1\n            r = 0\n            while l >= r:\n                mid = (l + r) / 2\n                if nums[mid] >= nums[l] and nums[mid] >= nums[r]:\n                    return nums[mid]\n                if nums[mid] < nums[l]:\n                    r = mid + 1\n                else:\n                    l = mid - 1\n        return nums[r]"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # dp\n        # dp[i] = max(i)\n        # dp[0] = nums[0]\n        # for i in range(1, k):\n        #     dp[i] = max(dp[i-1], nums[i])\n        # return dp[k-1]\n        # lt\n        # lt[i] = nums[i]\n        # for i in range(k):\n        #     lt[i] = max(lt[i], lt[i+1])\n        # return lt[k-1]\n        # lt\n        # dp[k-1] = nums[k-1]\n        # for i in range(k-2, -1, -1):\n        #     dp[i] = max(dp[i], dp[i+1]+nums[i])\n        # return dp[0]\n        # lt\n        # dp[k-1] = nums[k-1]\n        # for i in range(k-2, -1, -1):\n        #     dp[i] = max(dp[i], dp[i+1]+nums[i])\n        # return dp[0]\n        # lt\n        # dp[k-1] = nums[k-1]\n        # for i in range(k-2, -1, -1):\n        #     dp[i] = max(dp[i], dp[i+1]+nums[i])\n        # return dp[0]\n        # lt\n        # dp[k-1] = nums[k-1]\n        # for i in range(k-2, -1,"
    }
  ]
}