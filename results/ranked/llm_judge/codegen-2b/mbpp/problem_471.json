{
  "timestamp": "2025-09-14T20:51:52.714853",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 471,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-all-the-n-grams-in-the-string/\n\nclass Solution(object):\n    def allTheNgrams(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return self.allTheNgrams_slow(s)\n\n    def allTheNgrams_slow(self, s):\n        res = []\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if s[i] == s[j] and s[i] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    res.append(s[i:j + 1])\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.allTheNgrams(\"aabbbb\")\n    print s.allTheNgrams(\"bbbbbbb\")\n    print s.allTheNgrams(\"aaaaaaaaa\")\n    print s.allTheNgrams(\"\")\n    print s.allTheNgrams(\"bbbbbbbbbbbb\")\n    print s.allTheNgrams(\"bbbbbbbbbbbbbbbbbbbb\")\n    print s.allTheNgrams(\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for i, c in enumerate(s):\n            if c.isupper():\n                if i > 0 and s[i-1].islower():\n                    result.append(s[i-1:i+1])\n                else:\n                    result.append(s[i:i+1])\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.findSequence(\"aabb\")"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def countSequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        ans = []\n        for i in range(len(s)):\n            if s[i] == s[i + 1]:\n                if len(ans) == 0 or ans[-1][1]!= s[i]:\n                    ans.append([s[i], 1])\n                else:\n                    ans[-1][2] += 1\n            else:\n                ans.append([s[i], 1])\n\n        return ans\n\nif __name__ == \"__main__\":\n    print Solution().countSequences(\"abcd\")\n    print Solution().countSequences(\"aaabbbccccdddaaad\")\n    print Solution().countSequences(\"aab\")"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n\n        s = ''.join(sorted(s))\n\n        pattern = '.*?([a-z])([A-Z])'\n        match = re.search(pattern, s)\n        if match is None:\n            return []\n\n        subs = []\n        for group in match.groups():\n            subs.append(group[0])\n            subs.append(group[1].lower())\n\n        return subs"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        subseqs = []\n        for i in xrange(len(s)):\n            if i == 0 or s[i]!= s[i-1]:\n                if len(subseqs) > 0 and s[i] == s[i-1]:\n                    subseqs[-1].append(s[i])\n                else:\n                    subseqs.append([s[i]])\n            else:\n                subseqs[-1].append(s[i])\n        return subseqs\n\nif __name__ == '__main__':\n    s = \"AAAAACCCCC\"\n    s = \"a\"\n    s = \"a\"\n    s = \"a\"\n    s = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        use regex\n        :param s: str\n        :return: List[str]\n        \"\"\"\n        regex = '([A-Z])([a-z])'\n        m = re.search(regex, s)\n        if m is None:\n            return []\n        start, end = m.span()\n        result = []\n        for i in range(start, end):\n            result.append(s[i:end])\n        return result\n\n\nif __name__ == \"__main__\":\n    s = \"AABBCCDD\"\n    print Solution().findSubsequences(s)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import re\n\ndef find_uppercase_sequence(string):\n    regex = r'\\b[A-Z]\\b'\n    match = re.search(regex, string)\n    while match:\n        yield match.group()\n        match = re.search(regex, string)\n\n\n\nstring = 'CAT'\nprint(list(find_uppercase_sequence(string)))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/valid-anagram/description/\n\n# The valid anagram of a string S is a sequence of characters in S such that the characters are in the same order and the characters never appear in the same order.\n\n# For example, \"anagram\" is a valid anagram of \"rabbit\".\n# \"anagram\" is a valid anagram of \"caviar\".\n# \"anagram\" is not a valid anagram of \"rat\".\n# \"anagram\" is not a valid anagram of \"car\".\n\n# Given a string, find the valid anagram of it.\n\n# Example 1:\n# Input:\n# s = \"anagram\"\n# Output:\n# [\"anagram\", \"naRAM\", \"naRbA\", \"naRbI\", \"naRbA\", \"naRbI\"]\n# Note:\n# The string length will be in the range [1, 50].\n# The input string will only contain lowercase letters.\n\n# score:80.26(14ms)\n# time:O(n)\n# space:O(n)\nclass Solution(object):\n    def anagram(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        m = {}\n        for c in s:\n            if c not in m:\n                m[c] = c\n            else:\n                m[c] = m[c]\n        res = []\n        for c in m:\n            if m[c] not in res:\n                res.append(m[c])\n        return res"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-sequences-of-one-uppercase-letter-followed-by-lowercase-letters/discuss/91380/Python-Regex-Solution\n\n# 11ms 99.66%\nclass Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def is_upper(c):\n            return c.isupper()\n\n        def is_lower(c):\n            return c.islower()\n\n        def upper_lower(c):\n            return is_upper(c) ^ is_lower(c)\n\n        re = \"^[A-Za-z]+(?=.*[a-z])\"\n        re = re.replace('.', '[^\\\\.]')\n        re = re.replace('(', '\\\\(').replace(')', '\\\\)')\n        re = re.replace('+', '\\\\+')\n        re = re.replace('*', '\\\\*')\n        re = re.replace('?', '\\\\?')\n        re = re.replace('[', '\\\\[')\n        re = re.replace(']', '\\\\]')\n        re = re.replace('{', '\\\\{')\n        re = re.replace('}', '\\\\}')\n        re = re.replace('(', '\\\\(').replace(')', '\\\\)')\n        re = re.replace('$', '\\\\$')\n        re = re.replace('^', '\\\\^')\n        re = re.replace('|', '\\\\|')\n        re = re.replace('\\\\', '\\\\\\\\')\n        re = re.replace('.', '\\\\.')\n        re = re.replace('*', '\\\\*')\n        re = re.replace('+', '\\\\+')\n        re = re.replace('(', '\\\\(').replace(')', '\\\\)')\n        re = re.replace('{', '\\\\{')\n        re = re.replace('}', '\\\\}')\n        re = re.replace('[', '\\\\[')\n        re = re.replace(']', '"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of integers\n    def findSubsequences(self, s):\n        result = []\n        for i in range(len(s)):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2]:\n                result.append([s[i], s[i + 1], s[i + 2]])\n                i += 2\n        return result"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        return self.process(digits)\n\n    def process(self, digits):\n        if not digits:\n            return []\n        res = []\n        for i, d in enumerate(digits):\n            if i == 0:\n                res.append(d)\n            else:\n                for c in self.process(digits[:i]):\n                    res.append(c + d)\n        return res"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSubsequences(self, s):\n        if not s: return []\n        result = []\n        for i in range(len(s)):\n            if s[i] == s[i+1]:\n                result.append(s[i:i+2])\n        return result\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.findSubsequences(\"abcd\")"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def letterCombinations(self, s):\n        if not s:\n            return []\n        res = self.letterCombinations(s[1:])\n        if s[0] == 'a':\n            res = self.letterCombinations(s[1:])\n            res.append(['a'])\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.letterCombinations('a'))\n    print(s.letterCombinations('aa'))\n    print(s.letterCombinations('aaa'))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # DFS\n        def dfs(s, i):\n            if i >= len(s):\n                yield s\n            else:\n                for j in dfs(s, i + 1):\n                    yield s[:i] + j + s[i + 1:]\n\n        # for each substring\n        substrs = set()\n        for s in dfs(s, 0):\n            # if s is a subsequence of another subsequence\n            if s in substrs:\n                # append s to substrs\n                substrs.add(s)\n                # print substrs\n                continue\n            # if s is a subsequence of some other subsequence\n            # append s to substrs\n            substrs.add(s)\n\n        return substrs\n\n\nif __name__ == \"__main__\":\n    s = \"AABCC\"\n    print Solution().findSubsequences(s)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/find-all-subsequences/description/\n\nclass Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        result = []\n        result.append(s)\n        for i in range(1, len(s)):\n            # match in the beginning\n            if s[i-1].isupper() and s[i].islower():\n                result.append(s[i-1]+s[i])\n            # match in the middle\n            elif s[i-1].islower() and s[i].isupper():\n                result.append(s[i-1]+s[i])\n            # match in the end\n            elif s[i-1].isupper() and s[i].islower():\n                result.append(s[i-1]+s[i])\n            # match in the middle\n            elif s[i-1].islower() and s[i].isupper():\n                result.append(s[i-1]+s[i])\n        return result\n\nif __name__ == '__main__':\n    s = \"aabb\"\n    print Solution().findSubsequences(s)"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # pattern is \"^[A-Z][a-z]*$\"\n        pattern = re.compile('^[A-Z][a-z]*$')\n        return bool(pattern.match(s))\n\n    def isOneUpperToLower2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # pattern is \"^[A-Z][a-z]*$\"\n        pattern = re.compile('^[A-Z][a-z]*$')\n        return bool(pattern.match(s))\n\n\nif __name__ == \"__main__\":\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    print Solution().isOneUpperToLower(s)\n    print Solution().isOneUpperToLower2(s)"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n\n        if not p:\n            return True\n\n        if len(s)!= len(p):\n            return False\n\n        if not s[0].isupper():\n            return False\n\n        if not p[0].islower():\n            return False\n\n        if s[0]!= p[0]:\n            return False\n\n        if p[0]!= '*':\n            return True\n\n        return self.isMatch(s[1:], p[1:])\n\n\nif __name__ == \"__main__\":\n    print Solution().isMatch(\"aa\", \"a*\")\n    print Solution().isMatch(\"aa\", \"a*a\")\n    print Solution().isMatch(\"ab\", \"*a\")\n    print Solution().isMatch(\"aab\", \"c*a*b\")\n    print Solution().isMatch(\"aab\", \"a*b*\")\n    print Solution().isMatch(\"\", \"a*\")\n    print Solution().isMatch(\"\", \"a*a\")"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return self.regex_search(s, r'([A-Z]+)')\n\n    def regex_search(self, s, pattern):\n        return [m.group(1) for m in re.finditer(pattern, s)]"
    },
    {
      "rank": 19,
      "score": 9.0,
      "candidate": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport re\n\ndef find_sequences(string):\n    pattern = re.compile(r'(?=.*?[A-Z])(?=.*?[a-z])')\n    sequences = pattern.findall(string)\n    return sequences\n\nif __name__ == '__main__':\n    string = 'ABaaACddABaaACdd'\n    sequences = find_sequences(string)\n    print'sequences:', sequences"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        import re\n        return any(re.match(r'^[A-Z][a-z]$', x) for x in s)\n\nif __name__ == '__main__':\n    print Solution().isOneUpperToLower('bbbbccccdddddeeee')"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/find-repeated-characters/description/\n\nclass Solution(object):\n    def findRepeatedDnaSequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n        regex = re.compile(r'(\\d+)([A-Z]\\d+)([A-Z]\\d+)([A-Z]\\d+)')\n        seqs = []\n        for m in regex.finditer(s):\n            seqs.append(''.join(m.groups()))\n        return seqs\n\ns = Solution()\nprint s.findRepeatedDnaSequences('AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT')"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "def find_upper_lower(string):\n    pattern = r'([A-Z])\\1*'\n    regex = re.compile(pattern)\n    result = regex.findall(string)\n    return result\n\nif __name__ == '__main__':\n    string = 'abcA1A2A3A4A5A6A7A8A9Abc'\n    print find_upper_lower(string)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    pattern = re.compile('[A-Z]{2,}')\n    return pattern.findall(s)\n\ndef main():\n    s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n    print(find_sequences(s))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isupper() for c in s)\n\n    def isOneLowerCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.islower() for c in s)\n\n    def isOneLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isalpha() for c in s)\n\n    def isOneUpperLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isupper() for c in s)\n\n    def isOneLowerLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.islower() for c in s)\n\n    def isOneLetterOrDigit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isalnum() for c in s)\n\n    def isOneUpperDigit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isdigit() and c.isupper() for c in s)\n\n    def isOneLowerDigit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isdigit() and c.islower() for c in s)\n\n    def isOneLetterOrDigitOrLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isalnum() or c.islower() for c in s)\n\n    def isOneLetterOrDigitOrUpper(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return all(c.isalnum() or c.isupper()"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findRepeatedDnaSequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        result = []\n        if s:\n            regex = re.compile('[A-Z]{2,}[a-z]{2,}')\n            for i in range(len(s) - 2):\n                if regex.match(s[i:i+4]):\n                    result.append(s[i:i+4])\n        return result"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def letterCasePermutation(self, s):\n        if not s: return 0\n        \n        m = len(s)\n        \n        def is_upper(s):\n            return s.islower() or s.isupper()\n        \n        def is_lower(s):\n            return s.isupper()\n        \n        def is_letter(s):\n            return s.isalpha()\n        \n        def letter_count(s):\n            return sum([1 for i in range(len(s)) if is_letter(s[i])])\n        \n        def perm(s, n, m):\n            if n == m:\n                yield s\n                return\n            \n            for i in range(n, m):\n                for j in perm(s[:i] + s[i+1:], n-1, m-1):\n                    yield j + s[i]\n        \n        for i in range(m):\n            if is_upper(s[i]):\n                yield s[i]\n                for j in perm(s[i+1:], m-1, m):\n                    yield j + s[i]\n            else:\n                for j in perm(s[i+1:], m-1, m):\n                    yield s[i] + j\n        \n        return len(s)\n    \n    def letterCasePermutation(self, s):\n        if not s: return 0\n        \n        m = len(s)\n        \n        def is_upper(s):\n            return s.islower() or s.isupper()\n        \n        def is_lower(s):\n            return s.isupper()\n        \n        def is_letter(s):\n            return s.isalpha()\n        \n        def letter_count(s):\n            return sum([1 for i in range(len(s)) if is_letter(s[i])])\n        \n        def perm(s, n, m):\n            if n == m:\n                yield s\n                return\n            \n            for i in range(n, m):\n                for j in perm"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    regex = re.compile(r'([A-Z])\\1+')\n    results = regex.findall(s)\n    return results\n\nif __name__ == '__main__':\n    s = \"CaaBCbDc\"\n    results = find_sequences(s)\n    print(results)"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "# Your function should return a list of strings.\n\n# Test cases\n\n# Given s = \"abacd\", return [\"ab\",\"cd\"]\n# Given s = \"abcd\", return [\"ab\",\"cd\"]\n# Given s = \"\", return []\n# Given s = \"aaaaaaaaaa\", return [\"aaaaaaaaaa\"]\n\ndef one_upper_lower_case_sequence(s):\n    pattern = r'[A-Z]+'\n    return list(filter(lambda x: re.match(pattern, x), s))\n\nif __name__ == \"__main__\":\n    assert one_upper_lower_case_sequence(\"abacd\") == [\"ab\", \"cd\"]\n    assert one_upper_lower_case_sequence(\"abcd\") == [\"ab\", \"cd\"]\n    assert one_upper_lower_case_sequence(\"\") == []\n    assert one_upper_lower_case_sequence(\"aaaaaaaaaa\") == [\"aaaaaaaaaa\"]"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "import re\n\ndef find_all_uppercase_sequences(s):\n    return re.findall('(?<=.{1})[A-Z]{1}(?=[A-Z])', s)\n\nif __name__ == '__main__':\n    s = 'AABCABCBABCD'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABAB'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABABCD'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABACD'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABCD'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABD'\n    print(find_all_uppercase_sequences(s))\n    s = 'ABABCD'\n    print(find_all_uppercase_sequences(s))"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def find_sequences(s):\n    pattern = r'[A-Z][a-z]+'\n    match = re.finditer(pattern, s)\n    for match in match:\n        yield match.group()\n\nif __name__ == \"__main__\":\n    s = \"AbCdEfGh\"\n    print(list(find_sequences(s)))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Solution:\n    def findSubsequences(self, s: str) -> List[str]:\n        res = []\n        m = len(s)\n        n = len(s)\n        for i in range(m):\n            if s[i]!= s[i + 1]:\n                res.append(s[i:i + 2])\n                i += 1\n        return res"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        regex = '[A-Z]+([a-z])'\n        for m in re.finditer(regex, s):\n            if m.group(1) == m.group(2):\n                result.append(m.group(1))\n        return result"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        regex = re.compile('([a-z])([A-Z])')\n        seqs = []\n        for m in regex.finditer(s):\n            seqs.append(''.join(m.groups()))\n        return seqs\n\nif __name__ == \"__main__\":\n    print Solution().findSubsequences(\"a1b2c3\")"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        pattern = '([A-Z])([a-z])'\n        m = re.search(pattern, s)\n        if m is None:\n            return []\n\n        s = s[m.end():]\n        result = []\n        while s:\n            m = re.search(pattern, s)\n            if m is None:\n                break\n            result.append(m.group(1) + m.group(2))\n            s = s[m.end():]\n\n        return result\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findSubsequences('ABaCdEfGhIjKlMnOpQrStUvWxYz')"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findUpperLower(self, s):\n        res = []\n        for i in xrange(len(s)):\n            if s[i] == s[i+1]:\n                if s[i] == s[i-1]:\n                    res.append(s[i-1:i+2])\n                else:\n                    res.append(s[i-1:i+1])\n        return res"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "# Definition for a string.\nclass String:\n    def __init__(self, s):\n        self.s = s\n\n    def __str__(self):\n        return self.s\n\nclass Solution:\n    def findSubsequences(self, s: String) -> List[List[str]]:\n        res = []\n        cnt = 0\n        for i in range(len(s)):\n            if s[i].isupper():\n                cnt += 1\n            else:\n                if cnt > 0:\n                    res.append([s[i]])\n                cnt = 0\n        return res\n\nif __name__ == \"__main__\":\n    assert Solution().findSubsequences(\"cbaebabacd\") == [['cbaeb'], ['cbaeb'], ['cbaeb'], ['cbaeb'], ['cbaeb']]"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpper(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for c in s:\n            if c.isupper():\n                return True\n            elif c.islower():\n                return False\n        return False\n        \n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not self.isOneUpper(s):\n            return []\n        \n        res = []\n        for i in range(1, len(s)):\n            if self.isOneUpper(s[i:]):\n                res.append(s[:i])\n        return res"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/regex-find-sequences/problem\n\ndef find_sequences(string):\n    if not string:\n        return []\n    # string = 'abcdefghijklmnopqrstuvwxyz'\n    regex = r'[a-z]+[A-Z]+'\n    result = []\n    for i in range(len(string)):\n        if string[i] == string[i+1]:\n            result.append(string[:i+1])\n    return result\n\nif __name__ == '__main__':\n    string = input()\n    result = find_sequences(string)\n    result.sort()\n    for i in range(len(result)):\n        print(result[i])"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperCase(self, s):\n        return all(ord(c) >= 65 and ord(c) <= 90 for c in s)\n\n    def isOneLowerCase(self, s):\n        return all(ord(c) >= 97 and ord(c) <= 122 for c in s)\n\n    def isOneUpperLowerCase(self, s):\n        return self.isOneUpperCase(s) and self.isOneLowerCase(s)\n\n    def isOneUpperLowerCase_regex(self, s):\n        return re.search('[A-Z]{2,}[a-z]{2,}', s)\n\n    def findOneSubsequence(self, s):\n        if not self.isOneUpperLowerCase(s):\n            return\n\n        start = 0\n        end = 0\n        for i in range(len(s)):\n            if self.isOneUpperLowerCase(s[i:]):\n                end = i + 1\n                break\n            start = i + 1\n\n        return s[start:end]\n\n    def findOneSubsequence_regex(self, s):\n        if not self.isOneUpperLowerCase_regex(s):\n            return\n\n        start = 0\n        end = 0\n        for i in range(len(s)):\n            if self.isOneUpperLowerCase_regex(s[i:]):\n                end = i + 1\n                break\n            start = i + 1\n\n        return s[start:end]\n\n\nif __name__ == '__main__':\n    print(Solution().findOneSubsequence('AAbbbbAAccccCCcccccccccccccC'))\n    print(Solution().findOneSubsequence('aaabbbbcccccccccccccccccccc'))\n    print(Solution().findOneSubsequence_regex('AAbbbbAAccccCCccccccccccccC'))\n    print(Solution().findOneSubsequence_regex('aaabbbbcccccccccccccccccc'))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findSubsequences(self, s):\n        result = []\n        re = '([a-z])([A-Z])'\n        matches = re.finditer(s)\n        for m in matches:\n            sub = m.group(1) + m.group(2)\n            if sub not in result:\n                result.append([sub])\n        return result\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findSubsequences('abcd')"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "# import timeit\n# import sys\n# import os\n# from string import ascii_lowercase\n\n# # https://www.tutorialspoint.com/python/python_regex_regex_matching.htm\n# # https://www.tutorialspoint.com/python/python_regex_regex_matching.htm\n# # https://www.tutorialspoint.com/python/python_regex_regex_matching.htm\n# # https://www.tutorialspoint.com/python/python_regex_regex_matching.htm\n# # https://www.tutorialspoint.com/python/python_regex_regex_matching.htm\n\n# # def find_all_upper_case(s):\n# #     regex = re.compile(r'([A-Z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #     regex = re.compile(r'([a-z])')\n# #     return regex.findall(s)\n\n# # def find_all_lower_case(s):\n# #"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isUpperCase(self, s):\n        return s.isupper()\n    \n    def isLowerCase(self, s):\n        return s.islower()\n    \n    def getLowerCaseLetters(self, s):\n        return s.lower()\n    \n    def getUpperCaseLetters(self, s):\n        return s.upper()\n    \n    def isMatch(self, s, p):\n        s = self.getLowerCaseLetters(s)\n        p = self.getLowerCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_2(self, s, p):\n        s = self.getLowerCaseLetters(s)\n        p = self.getUpperCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_3(self, s, p):\n        s = self.getUpperCaseLetters(s)\n        p = self.getLowerCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_4(self, s, p):\n        s = self.getUpperCaseLetters(s)\n        p = self.getUpperCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_5(self, s, p):\n        s = self.getUpperCaseLetters(s)\n        p = self.getLowerCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_6(self, s, p):\n        s = self.getUpperCaseLetters(s)\n        p = self.getUpperCaseLetters(p)\n        if s == p:\n            return True\n        return False\n    \n    def isMatch_7(self, s, p):\n        s = self.getUpperCaseLetters(s)\n        p = self.getUpperCaseLetters(p)\n        if s == p:\n            return True\n        return False"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "import re\n\ndef is_subsequence(s, t):\n    if t == '':\n        return True\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        elif s[i] < t[j]:\n            i += 1\n        else:\n            j += 1\n    return j == len(t)\n\ndef find_sequences(s):\n    sequences = []\n    for i in range(len(s)):\n        if is_subsequence(s, s[:i] + s[i+1:]) and s[i] not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            sequences.append(s[:i] + s[i+1:])\n    return sequences\n\ndef main():\n    s = 'aabbb'\n    print(find_sequences(s))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def find_uppercase_lowercase_sequences(s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    pattern = re.compile(\"[A-Z]{2,}[a-z]*\")\n    result = []\n    for i in range(len(s)):\n        if pattern.match(s[i:]) is not None:\n            result.append(s[i:])\n    return result\n\nif __name__ == '__main__':\n    s = \"AABCBADCDDEEFFGGHHIIJJKKLLLLLMMMNNNNOOPPQQRRRSSSSTTUUTVVWWXXYYZZ\"\n    print(find_uppercase_lowercase_sequences(s))"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        def isOneUpperToLower(s):\n            if len(s) < 2:\n                return False\n            if s[0] == s[-1]:\n                return False\n            \n            isUpper = False\n            for i in range(1, len(s) - 1):\n                if s[i] == s[i - 1]:\n                    isUpper = True\n                elif not isUpper:\n                    return False\n            return True\n        \n        return isOneUpperToLower(s)"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "import re\n\ndef find_sequences(s):\n    pattern = re.compile(r'^[A-Z]{1}[a-z]{1}[A-Z]{1}[a-z]{1}')\n    matches = pattern.findall(s)\n    if matches:\n        return matches\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    print(find_sequences(\"aabbccczzz\"))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        regex = re.compile('[A-Z]*[a-z]')\n        return regex.search(s) is not None"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return len(s) == 0 or s[0]!= s[-1] or s[0].isupper()!= s[0].islower()\n    \n    def isOneUpperToLower_regex(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s[0].isupper()!= s[0].islower() and len(s) > 1 and s[-1] == s[0] and s[0].isupper()!= s[-1].islower()"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "# https://www.youtube.com/watch?v=0uDwR3X6Fbw\n\ndef check_sequence(s):\n    sequence = ''\n    pattern = '([A-Z])[a-z]*'\n    for i in range(0, len(s)):\n        if i % 2 == 0:\n            sequence += s[i]\n        else:\n            if s[i] == sequence[0]:\n                if s[i - 1] == s[i]:\n                    sequence += s[i]\n                else:\n                    return sequence\n            else:\n                sequence = ''\n    return sequence\n\ns = 'Aaaab'\nprint(check_sequence(s))"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "def find_uppercase_lowercase(string):\n    \"\"\"\n    :type string: str\n    :rtype: List[str]\n    \"\"\"\n    # O(n)\n    uppercase_sequence = ''\n    lowercase_sequence = ''\n    for char in string:\n        if char.isupper():\n            uppercase_sequence += char\n        elif char.islower():\n            lowercase_sequence += char\n        else:\n            if uppercase_sequence:\n                uppercase_sequence = uppercase_sequence[:-1]\n            if lowercase_sequence:\n                lowercase_sequence = lowercase_sequence[:-1]\n            uppercase_sequence = ''\n            lowercase_sequence = ''\n    if uppercase_sequence:\n        uppercase_sequence = uppercase_sequence[:-1]\n    if lowercase_sequence:\n        lowercase_sequence = lowercase_sequence[:-1]\n    return [uppercase_sequence, lowercase_sequence]\n\n\nclass Solution(object):\n    def find_repeated_char(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # O(n)\n        uppercase_sequence = ''\n        lowercase_sequence = ''\n        for char in s:\n            if char.isupper():\n                uppercase_sequence += char\n            elif char.islower():\n                lowercase_sequence += char\n            else:\n                if uppercase_sequence:\n                    uppercase_sequence = uppercase_sequence[:-1]\n                if lowercase_sequence:\n                    lowercase_sequence = lowercase_sequence[:-1]\n                uppercase_sequence = ''\n                lowercase_sequence = ''\n        if uppercase_sequence:\n            uppercase_sequence = uppercase_sequence[:-1]\n        if lowercase_sequence:\n            lowercase_sequence = lowercase_sequence[:-1]\n        return [uppercase_sequence, lowercase_sequence]\n\n\nif __name__ == \"__main__\":\n    assert Solution().find_repeated_char(\"abcd\") == ['A','B','C"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isUpperCaseLetter(self, s):\n        return s[0].isupper()\n\n    def isLowerCaseLetter(self, s):\n        return s[0].islower()\n\n    def letterSeq(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        ret = []\n        for i in range(len(s)):\n            if self.isUpperCaseLetter(s[i:]):\n                if self.isLowerCaseLetter(s[i:]):\n                    ret.append(s[:i])\n                else:\n                    ret.append(s[:i] + \"*\")\n            else:\n                ret.append(s[i:])\n        return ret\n\n\nif __name__ == '__main__':\n    assert Solution().letterSeq(\"a\") == [\"a\"]\n    assert Solution().letterSeq(\"abbc\") == [\"a\", \"b\", \"c\"]\n    assert Solution().letterSeq(\"abbbccc\") == [\"a\", \"b\", \"c\", \"c\"]\n    assert Solution().letterSeq(\"abbbccccc\") == [\"a\", \"b\", \"c\", \"c\", \"c\"]\n    assert Solution().letterSeq(\"abc\") == [\"a\", \"b\", \"c\"]"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findSequence(self, s: str) -> List[str]:\n        ans = []\n        l, r = 0, 0\n        while l < len(s):\n            while r < len(s) and s[r]!= s[l]:\n                r += 1\n            ans.append(s[l:r])\n            if r < len(s):\n                l = r\n            else:\n                l += 1\n        return ans"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/letter-case-convert/\n\nclass Solution(object):\n    def convert(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def letter(c):\n            return c.isupper() and c.islower()\n\n        def letter_case(s):\n            return [letter(c) for c in s]\n\n        return letter_case(s)"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpper(self, s):\n        return s[0] == s[-1] and s[0].isupper()\n\n    def isOneLower(self, s):\n        return s[0] == s[-1] and s[0].islower()\n\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        m = [False] * 26\n        for c in s:\n            if c.isupper():\n                m[ord(c) - ord('A')] = True\n            elif c.islower():\n                m[ord(c) - ord('a')] = True\n        result = []\n        i = 0\n        while i < len(s):\n            if m[ord(s[i]) - ord('A')]:\n                result.append(s[i:])\n                i += 1\n            else:\n                i += 1\n        return result\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.findSequence(\"abcdefg\") == [\"abcdefg\"]\n    assert s.findSequence(\"aaabbbcccdddd\") == [\"aaabbbcccdddd\"]\n    assert s.findSequence(\"aabbbcccdddd\") == [\"aabbbcccdddd\"]\n    assert s.findSequence(\"abbbcccdddd\") == [\"abbbcccdddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd\"]\n    assert s.findSequence(\"abbbbcccdddddd\") == [\"abbbbcccdddddd"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "class Solution:\n    def findSubsequences(self, s: str) -> List[str]:\n        res = []\n        for i in range(len(s)):\n            if s[i] == s[i+1] and s[i] == s[i+2]:\n                res.append(s[i:i+3])\n        return res"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCasePermutation(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n        result = []\n        for l in letters:\n            result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)\n        result.append(l)"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperCaseLetterFollowedByLowerCaseLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        s = s.upper()\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                if s[i] == s[0]:\n                    return False\n                else:\n                    return True\n        return False"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        if not s[0].isalpha():\n            return False\n        if s[0].isupper():\n            return False\n        if s[0]!= s[1]:\n            return False\n        if not s[1].isalpha():\n            return False\n        if not s[1].islower():\n            return False\n        if s[1].isupper():\n            return False\n        return True\n\n    def isOneUpperToLower1(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        if not s[0].isalpha():\n            return False\n        if s[0].isupper():\n            return False\n        if s[0]!= s[1]:\n            return False\n        if not s[1].isalpha():\n            return False\n        if not s[1].islower():\n            return False\n        if s[1].isupper():\n            return False\n        return True\n\n    def isOneUpperToLower2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        if not s[0].isalpha():\n            return False\n        if s[0].isupper():\n            return False\n        if s[0]!= s[1]:\n            return False\n        if not s[1].isalpha():\n            return False\n        if not s[1].islower():\n            return False\n        if s[1].isupper():\n            return False\n        return True"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findSubsequences(self, s):\n        result = []\n        if s == \"\":\n            return result\n        \n        # case 1: find upper case letters followed by lower case letters\n        # we need to find upper case letters followed by lower case letters\n        # so we should have a list of upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case letters followed by lower case letters\n        # so we need to find upper case"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            for j in range(i):\n                if s[i:j] == s[j:i]:\n                    res.append([s[i:j]])\n                    break\n        return res"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        upper = re.compile(r'^[A-Z]$')\n        lower = re.compile(r'^[a-z]$')\n        return upper.match(s) and lower.match(s)\n\n    def isOneUpperToLower_2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        if s[0] == s[-1]:\n            return False\n        if s[0] == s[-1].upper():\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    print Solution().isOneUpperToLower(\"ABC\")\n    print Solution().isOneUpperToLower_2(\"ABC\")"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def findSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n\n        ret = []\n        start = 0\n        for i in range(len(s)):\n            if s[i] == 'a':\n                if start!= -1 and s[start:i] not in ret:\n                    ret.append(s[start:i])\n                start = i\n        if start!= -1 and s[start:i] not in ret:\n            ret.append(s[start:i])\n        return ret\n\n\nif __name__ == \"__main__\":\n    Solution().findSequence(\"aaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbccdddaabbbcc"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubstring(self, s, pattern):\n        \"\"\"\n        :type s: str\n        :type pattern: str\n        :rtype: List[str]\n        \"\"\"\n        if not s or not pattern:\n            return []\n        regex = r'\\b'+pattern+r'\\b'\n        r = re.compile(regex)\n        return r.findall(s)\n\n    def findSubstring_2(self, s, pattern):\n        \"\"\"\n        :type s: str\n        :type pattern: str\n        :rtype: List[str]\n        \"\"\"\n        if not s or not pattern:\n            return []\n        r = re.compile(pattern)\n        return r.findall(s)\n\n    def findSubstring_3(self, s, pattern):\n        \"\"\"\n        :type s: str\n        :type pattern: str\n        :rtype: List[str]\n        \"\"\"\n        if not s or not pattern:\n            return []\n        r = re.compile(pattern)\n        return [x for x in s if x in r]\n\n\nif __name__ == \"__main__\":\n    s = \"bbbab\"\n    p = \"b\"\n    print Solution().findSubstring(s, p)\n    print Solution().findSubstring_2(s, p)\n    print Solution().findSubstring_3(s, p)"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == 'a' and i > 0 and s[i - 1]!= 'a':\n                res.append(s[i:])\n            elif s[i] == 'A' and i < len(s) - 1 and s[i + 1]!= 'A':\n                res.append(s[i:])\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    s = \"A\"\n    print sol.findSubsequences(s)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if s == \"\":\n            return False\n        if s[0] == s[-1]:\n            return False\n        return True\n        \n    def isOneUpperToLower2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if s == \"\":\n            return False\n        if s[0] == s[-1]:\n            return True\n        return False\n        \n    def isOneUpperToLower3(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if s == \"\":\n            return False\n        if s[0] == s[-1]:\n            return True\n        if s[0] == s[-1]:\n            return True\n        return False"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findLadders(self, s, word):\n        if word == '':\n            return [[]]\n\n        path = [[]]\n        self.paths.append(path)\n        self.word = word\n        self.matches = {}\n        self.matches[s[0]] = 1\n        self.matches[word[0]] = 1\n\n        for i in range(1, len(s)):\n            if s[i] not in self.matches:\n                self.matches[s[i]] = 1\n            else:\n                self.matches[s[i]] += 1\n\n            if word[i-1] not in self.matches:\n                self.matches[word[i-1]] = 1\n            else:\n                self.matches[word[i-1]] += 1\n\n        for j in range(1, len(word)):\n            self.dfs(0, j, word[j-1])\n\n        return self.paths[-1]\n\n    def dfs(self, i, j, word):\n        if i == len(self.word) and j == len(word):\n            self.paths.append(self.path)\n            return\n\n        if i == len(self.word) and j < len(word):\n            self.paths.append(self.path)\n            self.path.append(word[j])\n            return\n\n        if i < len(self.word) and j == len(word):\n            self.paths.append(self.path)\n            self.path.append(self.word[i])\n            return\n\n        if i < len(self.word) and j < len(word):\n            if word[j] in self.matches:\n                self.matches[word[j]] += 1\n            else:\n                self.matches[word[j]] = 1\n\n            if self.matches[self.word[i]] == 1:\n                self.dfs(i+1, j, word)\n            if self.matches[word[j]] == 1:\n                self.dfs"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "# Your function should return a list of lists.\n# The length of the list will be 1 or more.\n# Each of the inner lists will be of length 2.\n# The first element of each inner list will be the start position of the sequence.\n# The second element of each inner list will be the end position of the sequence.\n# The end position will be less than or equal to the length of the given string.\n\n# Example 1:\n# Given s = \"AABBCCDD\",\n# Return [[0, 4], [4, 7], [7, 9], [9, 12]]\n# The first element of the returned list is the start position of the first sequence (0).\n# The second element of the returned list is the start position of the second sequence (4).\n# The third element of the returned list is the start position of the third sequence (7).\n# The forth element of the returned list is the start position of the fourth sequence (9).\n\n# Example 2:\n# Given s = \"Aabbccdd\",\n# Return [[0, 4], [4, 6], [6, 8], [8, 10]]\n# The first element of the returned list is the start position of the first sequence (0).\n# The second element of the returned list is the start position of the second sequence (4).\n# The third element of the returned list is the start position of the third sequence (6).\n# The forth element of the returned list is the start position of the fourth sequence (8).\n\n# Note:\n# The length of s will be at most 1000.\n# s will contain only lowercase letters, uppercase letters, and digits.\n# All letters are of the same length.\n\n# Note:\n# The range of the first element of each inner list will be [0, 1000].\n\n# Example 3:\n# Given s = \"aabbcc\",\n# Return [[0, 1], [1, 2], [2, 3]]\n# The first element of the returned list is the start position of the first sequence (0).\n# The second element of the returned list is the start position of the second sequence (1).\n# The third element of the returned list is the start position of the third sequence (2).\n\n# Note:\n# The range of the first element of each inner list"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isupper()\n\n    def isOneLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].islower()\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isupper() and s[0].islower()\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isupper() and s[0].islower()\n\n    def isOneUpperLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isupper()\n\n    def isOneLowerLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].islower()\n\n    def isOneLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isalpha()\n\n    def isOneLetterOrDigit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isalnum()\n\n    def isOneUpperLetterOrDigit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        return s[0].isupper() or s[0].isdig"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        return self.__letterCombinations(digits, [])\n\n    def __letterCombinations(self, digits, result):\n        if not digits:\n            return result\n        for i in range(len(digits)):\n            if digits[i] == 'a':\n                result.append('a')\n                self.__letterCombinations(digits[i + 1:], result)\n            else:\n                self.__letterCombinations(digits[i + 1:], result)\n        return result"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def solve(self, cipher):\n        \"\"\"\n        main solution function\n        :param cipher: the cipher\n        :return: the solutions\n        \"\"\"\n        cipher = cipher.upper()\n        for i in range(len(cipher)):\n            if cipher[i] == cipher[i+1]:\n                yield cipher[i:i+2]\n            else:\n                break\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    f = open(\"1.in\", \"r\")\n    # f = sys.stdin\n    solution = Solution()\n    testcases = int(f.readline().strip())\n\n    for t in xrange(testcases):\n        # construct cipher\n        cipher = f.readline().strip()\n\n        # solve\n        s = \"%s\\n\" % (solution.solve(cipher))\n        print s,\n\n    f.close()"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n        ret = []\n        self.dfs(digits, 0, ret, '', [])\n        return ret\n\n    def dfs(self, digits, pos, ret, pre, chars):\n        if pos == len(digits):\n            ret.append(''.join(chars))\n            return\n        for i in range(len(digits)):\n            if chars and len(chars) > 0:\n                self.dfs(digits, pos + 1, ret, ''.join(chars), chars[:])\n            chars.append(digits[pos])\n            self.dfs(digits, pos + 1, ret, ''.join(chars), chars[:])\n            chars.pop()"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "import re\n\ndef find_sequences(string):\n    pattern = re.compile(r'([A-Z])([a-z])')\n    result = []\n    for word in pattern.findall(string):\n        result.append(word)\n    return result\n\ndef test_case1():\n    assert find_sequences(\"abcd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case2():\n    assert find_sequences(\"Abcd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case3():\n    assert find_sequences(\"aBcD\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case4():\n    assert find_sequences(\"aBCd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case5():\n    assert find_sequences(\"abc\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case6():\n    assert find_sequences(\"abcd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case7():\n    assert find_sequences(\"Abcd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case8():\n    assert find_sequences(\"aBcD\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case9():\n    assert find_sequences(\"aBCd\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\ndef test_case10():\n    assert find_sequences(\"abc\") == [('A', 'B'), ('A', 'C'), ('A', 'D')]\n\nif __name__ == '__main__':\n    test_case1()\n    test_case2()\n    test_case3()\n    test_case4()\n    test"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isUpperCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(s)):\n            if s[i].isupper():\n                if s[i+1].islower():\n                    return True\n                if s[i+1].isupper():\n                    return False\n        return False\n\n    def isUpperCaseSequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        if s[0].isupper() and s[1].islower():\n            return True\n        return False\n\n    def isUpperCaseSequence2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) < 2:\n            return False\n        if s[0].isupper() and s[1].islower() and s[2].isupper():\n            return True\n        return False\n\n\nif __name__ == \"__main__\":\n    print Solution().isUpperCaseSequence(\"A\")\n    print Solution().isUpperCaseSequence(\"AA\")\n    print Solution().isUpperCaseSequence(\"AAB\")"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        return self.findSubsequences_recursive(s)\n\n    def findSubsequences_recursive(self, s):\n        if not s:\n            return []\n\n        result = []\n        for i in xrange(len(s)):\n            if s[i] == s[i-1]:\n                if s[i-1]!= s[i-2]:\n                    result.append([s[i-1]])\n            else:\n                result.append([s[i-1]])\n\n        for j in xrange(len(s)-2, -1, -1):\n            if s[j] == s[j+1]:\n                if s[j+1]!= s[j]:\n                    result.append([s[j+1]])\n            else:\n                result.append([s[j+1]])\n\n        return result\n\n\nif __name__ == \"__main__\":\n    s = \"ABACD\"\n    print Solution().findSubsequences(s)\n\n    s = \"AABBB\"\n    print Solution().findSubsequences(s)\n\n    s = \"ABAB\"\n    print Solution().findSubsequences(s)"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCasePermutation(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return self.permute(s)\n\n    def permute(self, s):\n        res = []\n        self.permute(s, res, 0)\n        return res\n\n    def permute(self, s, res, start):\n        if len(s) == 0:\n            return\n        if start == len(s):\n            res.append(s)\n            return\n        for i in range(start, len(s)):\n            self.permute(s[:start] + s[i+1:], res, start+1)"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isupper()\n\n    def isOneLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.islower()\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def isOneUpperLowerCaseLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.isOneUpperCaseLetter(s) and self.isOneLowerCaseLetter(s)\n\n    def"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/word-break-ii/\n# https://leetcode.com/problems/word-break/\n\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        dic = {x: False for x in wordDict}\n        ret = []\n        self.dfs(s, dic, ret, wordDict)\n        return ret\n\n    def dfs(self, s, dic, ret, wordDict):\n        if len(s) == 0:\n            return\n        if len(s) == 1:\n            if dic[s[0]]:\n                ret.append(wordDict[s[0]])\n            return\n        for i in range(1, len(s)):\n            if dic[s[i-1]] and dic[s[i]] and s[i-1] in dic:\n                continue\n            dic[s[i-1]] = True\n            self.dfs(s[:i], dic, ret, wordDict)\n            dic[s[i-1]] = False"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        if s[0]!= s[-1]:\n            return False\n        return self.isOneUpperToLower(s[1:])\n\n    def isOneUpperToLower2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) == 0:\n            return False\n        if s[0]!= s[-1]:\n            return False\n        return self.isOneUpperToLower(s[1:]) and self.isOneUpperToLower(s[:-1])"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findSubsequences(self, s):\n        return [self.parse(s, i) for i in range(len(s))]\n\n    def parse(self, s, i):\n        subseq = []\n        cur = i\n        while cur < len(s):\n            if s[cur].isupper():\n                subseq.append(s[cur])\n                cur += 1\n            else:\n                break\n        return subseq\n\n\nif __name__ == \"__main__\":\n    s = \"aabbb\"\n    print(Solution().findSubsequences(s))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        count = 0\n        for i in range(len(s)):\n            if s[i] == s[i + 1]:\n                count += 1\n                if count == 2:\n                    result.append(s[i:i + 2])\n                elif count > 2:\n                    result.append(s[i:i + 2])\n            else:\n                count = 0\n        return result"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpperToLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        pattern = r'(?<![a-z])([a-z])(?![a-z])'\n        return re.search(pattern, s) is not None\n\n    def isOneUpperToLower2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        pattern = r'(?<![a-z])([a-z])(?![a-z])'\n        return re.match(pattern, s) is not None\n\n    def isOneUpperToLower3(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return False\n        pattern = r'(?<![a-z])([a-z])(?![a-z])'\n        return re.search(pattern, s) is not None\n\n\nif __name__ == \"__main__\":\n    s = \"leetcode\"\n    print Solution().isOneUpperToLower(s)"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "import re\n\n# Your function should return a list of strings.\n\n# Example 1:\n# Given s = \"Hello, my name is John\",\n# Your function should return:\n# [\n#   \"Hello, my name is\",\n#   \"is John\"\n# ]\n\n# Example 2:\n# Given s = \"Hello, my name is John\",\n# Your function should return:\n# [\n#   \"Hello, my name is\",\n#   \"is John\"\n# ]\n\n# Example 3:\n# Given s = \"Hello, my name is John\",\n# Your function should return:\n# [\n#   \"Hello, my name is\",\n#   \"is John\"\n# ]\n\ndef find_upper_lower(s):\n    result = []\n    for i in range(len(s)):\n        if s[i] >= 'A' and s[i] <= 'Z':\n            result.append(s[:i] + s[i] + s[i+1:])\n    return result\n\nif __name__ == '__main__':\n    s = 'abcde'\n    print(find_upper_lower(s))\n    s = 'aBcDe'\n    print(find_upper_lower(s))\n    s = 'abcd'\n    print(find_upper_lower(s))\n    s = 'abcdee'\n    print(find_upper_lower(s))\n    s = 'abcdeee'\n    print(find_upper_lower(s))"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        ret = []\n        if not digits:\n            return ret\n        if len(digits) == 1:\n            ret.append(digits)\n            return ret\n        m = {'z': 'AZ', 'a': '', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E', 'f': 'F', 'g': 'G', 'h': 'H', 'i': 'I', 'j': 'J', 'k': 'K', 'l': 'L','m': 'M', 'n': 'N', 'o': 'O', 'p': 'P', 'q': 'Q', 'r': 'R','s': 'S', 't': 'T', 'u': 'U', 'v': 'V', 'w': 'W', 'x': 'X', 'y': 'Y', 'z': 'Z'}\n        for i in digits:\n            for ch in m[i]:\n                ret.append(''.join(m[i]))\n                ret.append(ch)\n        return ret\n\n\ndef main():\n    s = Solution()\n    print s.letterCombinations('23')\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        def get_combination(digits, index):\n            if index == len(digits):\n                return []\n            if index == 0:\n                return ['A']\n            ret = []\n            for i in range(0, index):\n                ret.append(digits[i] + get_combination(digits, index - 1))\n            return ret\n\n        ret = []\n        for i in range(0, len(digits)):\n            ret.append(get_combination(digits, i))\n        return ret"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-all-words-with-support-of-two-characters-in-a-string/discuss/96517/Java-Python-Regex-Solution\nclass Solution(object):\n    def findWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        words = []\n        word = ''\n        for c in s:\n            if c.isupper() and word:\n                if word[-1].islower():\n                    words.append(word)\n                word = ''\n            elif c.islower():\n                word += c\n        if word:\n            words.append(word)\n        return words\n\n    def findWords1(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        words = []\n        word = ''\n        for c in s:\n            if c.isupper() and word:\n                if word[-1].islower():\n                    words.append(word)\n                word = ''\n            elif c.islower():\n                word += c\n        if word:\n            words.append(word)\n        return words"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def is_upper_case(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(s)):\n            if s[i] >= 'A' and s[i] <= 'Z':\n                return True\n            else:\n                return False\n\n    def is_lower_case(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(s)):\n            if s[i] >= 'a' and s[i] <= 'z':\n                return True\n            else:\n                return False\n\n    def is_upper_lower_case(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        for i in range(len(s)):\n            if s[i] >= 'a' and s[i] <= 'z' and s[i] >= 'A' and s[i] <= 'Z':\n                return True\n            else:\n                return False\n\n    def find_sequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for i in range(len(s)):\n            if self.is_upper_case(s[i:]):\n                if self.is_lower_case(s[:i]):\n                    if self.is_upper_lower_case(s[i:]):\n                        result.append(s[:i] + s[i+1:])\n                else:\n                    result.append(s[:i] + s[i+1:])\n        return result\n\n\nif __name__ == '__main__':\n    s = \"CAT\"\n    s2 = \"CAT\"\n    s3 = \"CATG\"\n    s4 = \"CATGTA\"\n    s5 = \"CATGTAAT\"\n    s6 = \"CATGTAATCA\"\n    s7 = \"CATGTAATCAAT\"\n    s8 = \"CATGTAATCAATCA\""
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "import re\n\ns = \"CAGTTGTAATACCCGGGTAACACCCACAGAGGAG\"\n\ndef find_upper_lower_regex(s):\n    return re.findall(r'(?=[A-Z])', s)\n\ndef find_upper_lower_regex_count(s):\n    return len(re.findall(r'(?=[A-Z])', s))\n\ndef find_upper_lower_regex_list(s):\n    return list(re.findall(r'(?=[A-Z])', s))\n\ndef find_upper_lower_regex_iter(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c\n\ndef find_upper_lower_regex_iter_count(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield 1\n\ndef find_upper_lower_regex_iter_list(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c, 1\n\ndef find_upper_lower_regex_iter_list_count(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c, 1\n\ndef find_upper_lower_regex_iter_list_count2(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c, 1, 1\n\ndef find_upper_lower_regex_iter_list_count3(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c, 1, 1, 1\n\ndef find_upper_lower_regex_iter_list_count4(s):\n    for c in re.findall(r'(?=[A-Z])', s):\n        yield c, 1, 1, 1, 1\n\ndef find_upper_lower_regex_iter_list_count5(s):\n    for c in re."
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s:\n            return []\n\n        res = []\n        for i in range(len(s)):\n            if s[i] == s[i + 1]:\n                res.append(s[i:i + 2])\n        return res\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.findSubsequences(\"abcabc\"))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of strings\n    def findSubsequences(self, s):\n        if not s:\n            return []\n        \n        subseqs = []\n        cur_seq = []\n        for i in range(len(s)):\n            if s[i] == s[i + 1]:\n                cur_seq.append(s[i:i + 2])\n            else:\n                if cur_seq:\n                    subseqs.append(cur_seq)\n                cur_seq = []\n        \n        if cur_seq:\n            subseqs.append(cur_seq)\n        \n        return subseqs"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isUpperCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isupper()\n        \n    def findSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        # naive solution\n        result = []\n        for i in range(len(s)):\n            if i - k >= 0 and s[i] == s[i - k] and self.isUpperCase(s[i - k:i]):\n                result.append(s[i - k:i])\n        return result"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/132592/Easy-Regex-Replace-with-Python-and-Recursion\n\n# Definition for a string\nclass String:\n    def __init__(self, s):\n        self.s = s\n\n    # @return a list of strings\n    def anagrams(self):\n        res = []\n        if not self.s:\n            return res\n        s = self.s.lower()\n        for i in range(0, len(s)):\n            for j in range(i+1, len(s)):\n                t = s[i:j+1]\n                if t in s[j:]:\n                    res.append(t)\n        return res\n\n\n# Your String object will be instantiated and called as such:\n# obj = String(s)\n# param_1 = obj.anagrams()\n\nclass Solution(object):\n    def anagrams(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        s = s.lower()\n        res = []\n        for i in range(0, len(s)):\n            for j in range(i+1, len(s)):\n                t = s[i:j+1]\n                if t in s[j:]:\n                    res.append(t)\n        return res\n\nif __name__ == \"__main__\":\n    assert Solution().anagrams(\"aabcc\") == [\"a\", \"b\", \"c\"]\n    assert Solution().anagrams(\"abcd\") == [\"a\", \"b\", \"c\", \"d\"]\n    assert Solution().anagrams(\"abb\") == [\"a\", \"b\"]\n    assert Solution().anagrams(\"aabb\") == [\"a\", \"b\", \"a\", \"b\"]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if len(s) == 0:\n            return []\n        if len(s) == 1:\n            return [s]\n        \n        def rec(s, i):\n            if i == len(s):\n                return []\n            \n            result = []\n            for j in range(i, len(s)):\n                if s[j] == s[i]:\n                    result += [s[:i] + s[j + 1:]]\n                else:\n                    break\n            \n            return result + rec(s[i + 1:], i + 1)\n            \n        return rec(s, 0)"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findLadders(self, s, from_city, to_city):\n        return self.findPaths(s, from_city, to_city)\n\n    def findPaths(self, s, from_city, to_city):\n        from_city = list(from_city)\n        to_city = list(to_city)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        if len(s) < 2:\n            return []\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city)\n        # print('to_city:', to_city)\n        # print('s:', s)\n\n        # print('from_city:', from_city"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        if not s:\n            return []\n        res = []\n        for i in range(len(s)):\n            if s[i] == s[i+1]:\n                res.append([s[i]])\n            else:\n                res.append([])\n        for i in range(len(s) - 1):\n            res = self.find_subseq(s, res, i)\n        return res\n\n    def find_subseq(self, s, res, i):\n        for j in range(i+2, len(s)):\n            if s[j] == s[j+1]:\n                res[j-i].append(s[j])\n                if res[j-i][-1]!= res[j-i][0]:\n                    res.append([])\n                else:\n                    res.append([])\n                return res\n            else:\n                return res"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isUpperCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isupper()\n\n    def isLowerCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.islower()\n\n    def isLowerUpperCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.islower() and s.isupper()\n\n    def isLetterCase(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha()\n\n    def isLetterUpper(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.isupper()\n\n    def isLetterLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.islower()\n\n    def isLetterCaseUpper(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.isupper() and s.islower()\n\n    def isLetterCaseLower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.islower() and s.isupper()\n\n    def isLetterCaseMix(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.isupper() and s.islower() and s.isupper()\n\n    def isLetterCaseMixUpper(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s.isalpha() and s.isupper() and s.islower() and s.isupper() and s.islower()\n\n    def isLetterCaseMixLower(self, s):\n        \"\"\"\n        :type s"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        ans = []\n        for i in range(len(s)):\n            if i == 0 or s[i]!= s[i - 1]:\n                ans.append([s[i]])\n            elif len(ans) > 0:\n                ans[-1].append(s[i])\n            else:\n                ans.append([s[i]])\n        return ans"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of lists of string\n    def findLadders(self, s, word):\n        \n        # for each character\n        for i in range(len(s)):\n            # find all words that start with this character\n            paths = [self.findPaths(s, i, word)]\n            # for each word\n            for path in paths:\n                # find all words that end with this character\n                paths2 = [self.findPaths(s, i, word, reverse=True) for reverse in [False, True]]\n                # merge paths\n                paths.extend(paths2)\n            # return paths\n            yield paths\n            \n        \n    def findPaths(self, s, start, word, reverse=False):\n        paths = []\n        # for each character\n        for i in range(len(word)):\n            # for each character\n            for j in range(len(s)):\n                # if it's not the same character\n                if s[j]!= word[i] and (not reverse or s[j]!= word[-i-1]):\n                    # if the character is the same as the word\n                    if s[j] == word[0]:\n                        # if the character is not the same as the word\n                        if s[j]!= word[0] and not reverse:\n                            # if the character is not the same as the word\n                            # and the word is not the same as the start\n                            if s[j]!= word[1] and s[j]!= word[-1]:\n                                # if the character is not the same as the word\n                                # and the word is not the same as the start\n                                # and the start is not the same as the word\n                                # and the start is not the same as the word\n                                # and the word is not the same as the start\n                                # and the word is not the same as the start\n                                # and the start is not the same as the word\n                                # and the start is not the same as the word\n                                # and the word is not the same as the start\n                                # and the start is not the same as the word\n                                # and the word is"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def isOneUpper(self, s):\n        return s[0].isupper()\n\n    def isOneLower(self, s):\n        return s[0].islower()\n\n    def isOneLowerUpper(self, s):\n        return s[0].isalpha()\n\n    def oneUpperLower(self, s):\n        return s[0].isalpha() and s[0].isupper() and s[1:].isalpha() and s[1:].islower()\n\n    def oneLowerUpper(self, s):\n        return s[0].isalpha() and s[0].islower() and s[1:].isalpha() and s[1:].isupper()\n\n    def oneUpperLowerUpper(self, s):\n        return s[0].isalpha() and s[0].isupper() and s[1:].isalpha() and s[1:].isupper() and s[2:].isalpha() and s[2:].islower()\n\n    def oneLowerUpperUpper(self, s):\n        return s[0].isalpha() and s[0].islower() and s[1:].isalpha() and s[1:].isupper() and s[2:].isalpha() and s[2:].isupper() and s[3:].isalpha() and s[3:].islower()\n\n    def oneUpperLowerUpperUpper(self, s):\n        return s[0].isalpha() and s[0].isupper() and s[1:].isalpha() and s[1:].isupper() and s[2:].isalpha() and s[2:].isupper() and s[3:].isalpha() and s[3:].isupper() and s[4:].isalpha() and s[4:].islower()\n\n    def oneLowerUpperUpperUpper(self, s):\n        return s[0].isalpha() and s[0].islower() and s[1:].isalpha() and s[1:].isupper() and s[2:].isalpha() and s[2:].isupper() and s[3:].isalpha() and s[3:"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def findSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        ret = []\n        for i in range(len(s)):\n            if s[i]!= s[i+1]:\n                ret.append(s[i:i+2])\n                i += 1\n        return ret"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "import re\n\ndef find_upper_lower_sequences(s):\n    if not s:\n        return []\n    res = []\n    for i in range(len(s)):\n        if s[i] == s[i+1]:\n            res.append(s[i:i+2])\n    return res\n\ndef test():\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper_lower_sequences(\"abcABC\") == [u'abc', u'abc']\n    assert find_upper"
    }
  ]
}