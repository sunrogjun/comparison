{
  "timestamp": "2025-09-14T20:09:15.520948",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 375,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param s: A string\n    @return: An integer\n    \"\"\"\n    def minSwaps(self, s):\n        \"\"\"\n        Bracket balancing\n        \"\"\"\n        if s == \"\":\n            return 0\n\n        stack = []\n        i = 0\n        while i < len(s):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    return 0\n            i += 1\n\n        return len(stack)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.minSwaps(\"()())()()()(()(()()()()()()))\")\n    print s.minSwaps(\"()(())()()()()()()(())(()()())()()()()()()()()()()\")\n    print s.minSwaps(\"()()()()()()()()()(())(())(()()())()()()()()()()()()\")\n    print s.minSwaps(\"()()()()()()()()()(())(())(())(()()())()()()()()()()()\")"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        \n        n = len(s)\n        dp = [[0] * n for _ in xrange(n)]\n        \n        def dfs(i, j):\n            if i == j:\n                return 0\n            if dp[i][j] == 0:\n                dp[i][j] = 1 + dfs(i + 1, j - 1)\n                if i < j:\n                    dp[i][j] = min(dp[i][j], dfs(i + 1, j) + dfs(i, j - 1))\n            return dp[i][j]\n        \n        return dfs(0, n - 1)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def min_swaps(s):\n    \"\"\"\n    Bracket balancing is a problem that occurs when a string is balanced by brackets,\n    e.g. the string is [()[]][()] and we can do the following swaps:\n\n    [()][()] -> []()\n    [()] -> []()\n    []() -> []()\n    [()] -> []()\n\n    The minimum no of swaps required for this string is 1.\n    \"\"\"\n\n    if not s:\n        return 0\n\n    count = 0\n    stack = [0]\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            while stack[-1]!= i:\n                count += 1\n                stack.pop()\n            stack.pop()\n        else:\n            continue\n\n    return count\n\ns = \"()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "import math\n\ndef minimum_swaps(input_string):\n    \"\"\"\n    :type input_string: str\n    :rtype: int\n    \"\"\"\n    # Bracket balancing\n    count = 0\n    for i in range(len(input_string) - 1):\n        if input_string[i] == input_string[i + 1]:\n            count += 1\n        else:\n            count -= 1\n    return count\n\nif __name__ == \"__main__\":\n    assert minimum_swaps(\"abcde\") == 0\n    assert minimum_swaps(\"aabcd\") == 3\n    assert minimum_swaps(\"abcde\") == 0\n    assert minimum_swaps(\"aabbc\") == 2\n    assert minimum_swaps(\"abcd\") == 2\n    assert minimum_swaps(\"bcd\") == 1\n    assert minimum_swaps(\"abc\") == 0\n    assert minimum_swaps(\"abbc\") == 1\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2\n    assert minimum_swaps(\"babcb\") == 2"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/bracket-balancing/discuss/109927/Python-Python-DP-with-explanation-and-optimization\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        for i in range(1, len(s) + 1):\n            dp[i][0] = i\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(s) + 1):\n                if s[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j])\n        return dp[-1][-1]"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def min_swaps(string):\n    \"\"\"\n    string = \"aabbcc\"\n    Return the minimum number of swaps required for bracket balancing in the given string.\n    \"\"\"\n    \n    # Bracket balacing is a tricky problem.\n    # The idea is to split the string into two parts.\n    # The first part is the left side of the bracket.\n    # The second part is the right side of the bracket.\n    # The problem is that the left and right part can be swapped.\n    # To minimize the number of swaps required, we will keep track of the number of swaps required for each part.\n    # If we swap the first part with the second part, we will need to swap the number of swaps required for the left and right parts.\n    # If we swap the second part with the first part, we will need to swap the number of swaps required for the first and second parts.\n    # Hence, the minimum number of swaps required is the minimum number of swaps required for the left and right parts.\n    # The first part is the left side of the bracket.\n    # The second part is the right side of the bracket.\n    # If we have a balanced bracket, the number of swaps required is the sum of the number of swaps required for the left and right parts.\n    # For example, the balanced brackets are:\n    # aabbcc = 5 swaps\n    # aabbcc = 3 swaps\n    # aabbcc = 3 swaps\n    # aabbcc = 2 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps\n    # aabbcc = 1 swaps"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import sys\nimport time\nimport math\n\nstart_time = time.time()\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # base case\n        if len(s) <= 1:\n            return 0\n        # count the number of characters that can be swapped\n        n = len(s)\n        # calculate the number of swaps required\n        swaps = math.floor(math.log(n, 2))\n        # store the minimum number of swaps required\n        return swaps\n\nif __name__ == \"__main__\":\n    start = time.time()\n    s = Solution()\n    print s.minSwaps(\"abcd\")\n    print time.time() - start"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "import re\n\ndef find_min_no_of_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    swaps = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i+1]:\n            swaps += 1\n    return swaps\n\n\ndef find_min_no_of_swaps_recursive(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    swaps = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i+1]:\n            swaps += 1\n            if i > 0 and s[i-1] == s[i+1]:\n                swaps += 1\n    return swaps\n\n\nif __name__ == '__main__':\n    s = \"aabab\"\n    print(find_min_no_of_swaps(s))\n    print(find_min_no_of_swaps_recursive(s))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwapBracket(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return min(self.minSwapBracket(s[:i]+s[i+1:]) for i in range(len(s)-1))\n\n# 17ms 100%\nclass Solution(object):\n    def minSwapBracket(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i < j:\n                return i, j\n            elif i == j:\n                return i, j\n            else:\n                return i, j + 1\n\n        l, r = 0, len(s) - 1\n        while l < r:\n            m = (l + r) // 2\n            if s[m]!= s[l]:\n                l = m + 1\n            elif s[m]!= s[r]:\n                r = m\n            else:\n                return dfs(l, m)\n        return dfs(l, r)\n\n# 12ms 100%\nclass Solution(object):\n    def minSwapBracket(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s == \"()\":\n            return 0\n        if s[0] == \"(\":\n            return 1 + self.minSwapBracket(s[1:])\n        elif s[0] == \")\":\n            return self.minSwapBracket(s[1:]) + 1\n        else:\n            return self.minSwapBracket(s[1:]) + self.minSwapBracket(s[0:1])\n\nif __name__ == \"__main__\":\n    print(Solution().minSwapBracket(\"(()))\"))\n    print(Solution().minSwapBracket(\"()(())\"))\n    print(Solution().minSwapBracket(\"()(())()\"))\n    print(Solution().minSwapBracket(\"()(()))\"))\n    print(Solution().minSwapBracket(\"()()()\"))\n    print"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return 0\n\n        # find the first char that is different\n        # and the last char that is different\n        # then do a swap\n        first = s.find('a')\n        last = s.rfind('a')\n        if first < last:\n            return 1\n        else:\n            return 2\n\nif __name__ == \"__main__\":\n    print Solution().minSwap(\"aaabb\")"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n        from operator import itemgetter\n\n        def get_value(s):\n            return int(s)\n\n        def get_key(s):\n            return get_value(s)\n\n        def get_value_key(s):\n            return get_value(s), get_key(s)\n\n        sorted_chars = sorted(s, key=get_key)\n        sorted_chars.append(sorted_chars[0])\n        count = defaultdict(int)\n        for i in range(len(sorted_chars)):\n            if i > 0 and sorted_chars[i]!= sorted_chars[i - 1]:\n                count[sorted_chars[i]] += 1\n                count[sorted_chars[i - 1]] -= 1\n        return sum(count.values())\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.minSwap(\"(()()()(()()()(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(())(()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/bracket-balancing/problem\n\ndef min_swaps(str):\n    \"\"\"\n    Returns the minimum number of swaps required to balance brackets in the given string.\n    :param str: string\n    :return: minimum number of swaps\n    \"\"\"\n    # Bracket balancing in a string is done by swapping the first and last brackets\n    # First and last brackets are balanced by swapping the first and last brackets of the\n    # adjacent substrings.\n    # Thus, the minimum number of swaps required is the minimum number of swaps required\n    # for swapping the first and last brackets of adjacent substrings.\n    # To balance brackets, we should consider the following cases:\n    # 1. The first and last brackets of adjacent substrings are balanced.\n    # 2. The first and last brackets of adjacent substrings are unbalanced.\n    # 3. The first and last brackets of adjacent substrings are balanced, but they are not\n    #    the same.\n    # To balance brackets, we should consider the following cases:\n    # 1. The first and last brackets of adjacent substrings are balanced.\n    # 2. The first and last brackets of adjacent substrings are unbalanced.\n    # 3. The first and last brackets of adjacent substrings are balanced, but they are not\n    #    the same.\n    # In all these cases, the minimum number of swaps required is the number of swaps\n    # required to balance the first and last brackets of adjacent substrings.\n    # If the first and last brackets of adjacent substrings are not balanced,\n    # then the minimum number of swaps required is the number of swaps\n    # required to balance the first and last brackets of adjacent substrings.\n    # If the first and last brackets of adjacent substrings are the same, then the\n    # minimum number of swaps required is the number of swaps required\n    # to balance the first and last brackets of adjacent substrings.\n    # If the first and last brackets of adjacent substrings are unbalanced,\n    # then the minimum number of swaps required is the number of swaps\n    # required to balance the first and last brackets of adjacent substrings.\n    # If the first and last brackets of adjacent substrings are balanced,\n    # then the minimum number of swaps required is the number of swaps"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.minSwap2(s)\n\n    def minSwap2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        m = len(s)\n        # print(m)\n        if m == 0:\n            return 0\n        if m == 1:\n            return 1\n        if m == 2:\n            return 2\n        if s[0] == '(' and s[1] == ')':\n            return 2\n        if s[0] == '[' and s[1] == ']':\n            return 2\n        if s[0] == '{' and s[1] == '}':\n            return 2\n        if s[0] == ')' and s[1] == '(':\n            return 2\n        if s[0] == ']' and s[1] == '[':\n            return 2\n        if s[0] == '}' and s[1] == '{':\n            return 2\n        if s[0] == ')' and s[1] == '{':\n            return 2\n        if s[0] == ']' and s[1] == '[' or s[0] == ']' and s[1] == '[' or s[0] == ']' and s[1] == '[' or s[0] == '[' and s[1] == ']':\n            return 2\n        if s[0] == '[' and s[1] == '[' and s[2] == ']':\n            return 3\n        if s[0] == '[' and s[1] == '[' and s[2] == ']' or s[0] == '[' and s[1] == ']' and s[2] == ']' or s[0] == ']' and s[1] == ']' and s[2] == '[' or s[0] == ']' and s[1] == '[' and s[2] == ']' or s[0] == ']' and s[1] == ']' and s[2]"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minBalancedSwap(self, s):\n        if not s:\n            return 0\n        l, r = 0, len(s) - 1\n        while l < r:\n            if self.isBalanced(s, l, r):\n                return self.minBalancedSwap(s, l, r)\n            else:\n                m = self.minBalancedSwap(s, l + 1, r)\n                if m == 0:\n                    return 0\n                l += m\n                r -= m\n\n    def isBalanced(self, s, l, r):\n        if s[l] == s[r]:\n            return 1\n        for i in xrange(l + 1, r):\n            if s[i] == s[l]:\n                return 0\n        return 1\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.minBalancedSwap(\"abcd\")\n    print s.minBalancedSwap(\"abbc\")\n    print s.minBalancedSwap(\"abcba\")\n    print s.minBalancedSwap(\"abcd\")\n    print s.minBalancedSwap(\"aa\")"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "import sys\n\nclass Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n <= 1:\n            return 0\n\n        def check(i, j):\n            if i == 0 or j == n - 1:\n                return 0\n            return min(check(i - 1, j), check(i, j - 1)) + 1\n\n        return check(0, n - 1)\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = 'abcdef'\n    print sol.minSwap(s)\n    s = 'abcdefgh'\n    print sol.minSwap(s)"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/bracket-balancing/\n# https://oj.leetcode.com/discuss/10488/this-is-a-new-solution-for-bracket-balancing\n# https://oj.leetcode.com/discuss/9759/a-brief-introduction-to-bracket-balancing\n\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def minPositions(self, s):\n        if not s:\n            return 0\n        self.stack = []\n        self.left = []\n        self.right = []\n        self.count = 0\n        self.positions = {}\n        for i in range(len(s)):\n            if s[i] == '(':\n                self.stack.append(i)\n            elif s[i] == ')':\n                if self.stack:\n                    self.stack.pop()\n                else:\n                    self.left.append(i)\n            elif self.stack:\n                self.right.append(i)\n        self.positions[0] = self.stack[0]\n        self.positions[len(s)-1] = self.stack[-1]\n        self.count = len(self.left) + len(self.right)\n        for i in range(len(self.stack)):\n            self.count += 1\n            for j in range(i):\n                if self.positions[j] == self.stack[i]:\n                    self.count -= 1\n        return self.count\n\ns = Solution()\ns.minPositions('()())')\ns.minPositions('()()(())')\ns.minPositions('()()(()()()())()())()')\ns.minPositions('(())((()))')\ns.minPositions('()()()()')\ns.minPositions('()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def get_min_swap(s, start, end):\n            if start == end:\n                return 0\n            if start > end:\n                return get_min_swap(s, end, start)\n            if s[start] < s[end]:\n                return get_min_swap(s, start + 1, end)\n            else:\n                return get_min_swap(s, start, end - 1)\n\n        return get_min_swap(s, 0, len(s) - 1)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.minSwap(\"aab\"))\n    print(s.minSwap(\"ab\"))\n    print(s.minSwap(\"abb\"))\n    print(s.minSwap(\"bbb\"))\n    print(s.minSwap(\"\"))\n    print(s.minSwap(\"aabb\"))\n    print(s.minSwap(\"aab\"))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        i, j = 0, 0\n        while i < len(s):\n            while j < len(s) and s[i]!= s[j]:\n                j += 1\n            if j == len(s):\n                return 0\n            i += 1\n            j += 1\n        return 1 + min(self.minSwaps(s[:i]), self.minSwaps(s[i+1:]))\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.minSwaps(\"[abc[]]\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print(sol.minSwaps(\"[a]b[c]d\"))\n    print("
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "def min_swaps(s):\n    min_swaps_count = 0\n    for i in range(len(s) - 1):\n        if s[i] < s[i + 1]:\n            min_swaps_count += 1\n    return min_swaps_count\n\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))\nprint(min_swaps(\"(a)bbbbcccddddeee\"))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # write your code here\n        res = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    res += 1\n                else:\n                    res += 2\n        return res\n        \n\nif __name__ == '__main__':\n    s = \"abcd\"\n    s = \"acb\"\n    s = \"abb\"\n    s = \"aabb\"\n    s = \"aabbb\"\n    s = \"aabbbbbb\"\n    s = \"aabbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n    s = \"aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.minSwap1(s)\n\n    def minSwap1(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n        return dp[n][n]"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "class Solution:\n    def minimumSwap(self, s: str) -> int:\n        \"\"\"\n        Bracket balancing:\n        1. find the bracket left most\n        2. find the bracket right most\n        3. swap the two bracket\n        \"\"\"\n        stack = []\n        start = 0\n        end = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n                start = i\n            elif s[i] == ')':\n                end = i\n                stack.pop()\n            if start!= end and stack:\n                stack.append(i)\n        return min(end - start, len(stack) + 1)\n\n\nif __name__ == '__main__':\n    assert Solution().minimumSwap(\"()(())()())()()(()(()()()())()())(())(()()()()())()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minSwap(self, s):\n        m = len(s)\n        n = len(s[0])\n        nums = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i][j] == '(' or s[i][j] == ')' or s[i][j] == '[' or s[i][j] == ']':\n                    nums[i][j] = 1\n                else:\n                    nums[i][j] = 2\n        # print nums\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if nums[i][j] == 2:\n                    for k in range(i+1, m):\n                        for l in range(j+1, n):\n                            if s[k][l] == '(' or s[k][l] == ')' or s[k][l] == '[' or s[k][l] == ']':\n                                nums[k][l] = 0\n                                ans += 1\n        return ans\n\nif __name__ == \"__main__\":\n    print Solution().minSwap(\"(()\")"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        res = 0\n        n = len(s)\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                if s[i] == s[j] and s[i]!= s[j-1]:\n                    res += 1\n        return res"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "import sys\n\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = {'(': 0, ')': 0, '[': 0, ']': 0}\n        for i in range(len(s)):\n            if s[i] in '()':\n                count[s[i]] += 1\n            elif s[i] == '[':\n                count[s[i]] -= 1\n        return sum([max(0, count[c]) for c in '()[]'])\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    s = '()[]{}'\n    print(sol.minSwaps(s))\n    s = '()[]{}'\n    print(sol.minSwaps(s))"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 0\n        pairs = []\n        for i in xrange(len(s) - 1):\n            if s[i]!= s[i + 1]:\n                pairs.append((i, i + 1))\n        return min(self.minBalancedSwap(s[:pairs[0][0]]) + self.minBalancedSwap(s[pairs[0][1]:]),\n                   self.minBalancedSwap(s[:pairs[1][0]]) + self.minBalancedSwap(s[pairs[1][1]:]))\n\n\nif __name__ == \"__main__\":\n    s = \"aab\"\n    print Solution().minBalancedSwap(s)"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def minSwapBracket(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s: return 0\n        m = s.count('(')\n        n = s.count(')')\n        if m > n: return self.minSwapBracket(s[m:])\n        if m < n: return self.minSwapBracket(s[:m])\n        \n        return self.minSwapBracket(s[m:]) + self.minSwapBracket(s[:m])"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 0\n\n        dp = [1] * len(s)\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[i] == s[j]:\n                    dp[i] = min(dp[i], dp[j]) + 1\n\n        return min(dp)\n\ns = Solution()\nprint s.minSwap(\"[AB]\")\nprint s.minSwap(\"[ABAB]\")\nprint s.minSwap(\"[AB]\")"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def min_swaps(s):\n    d = {}\n    for c in s:\n        d[c] = d.get(c, 0) + 1\n\n    for i in range(len(d)):\n        for j in range(i+1, len(d)):\n            if d[i] > d[j]:\n                d[i], d[j] = d[j], d[i]\n                d[i], d[j] = d[j], d[i]\n\n    return sum(d.values())\n\nif __name__ == '__main__':\n    s = \"aabbccdd\"\n    print min_swaps(s)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "# https://www.hackerrank.com/challenges/bracket-balancing/problem\n\ndef min_no_of_swaps(s):\n    no_of_swaps = 0\n    for i in range(len(s)):\n        if s[i] == '(' and s[i-1] == ')':\n            no_of_swaps += 1\n        if s[i] == '{' and s[i-1] == '}':\n            no_of_swaps += 1\n        if s[i] == '[' and s[i-1] == ']':\n            no_of_swaps += 1\n        if s[i] == '(' and s[i-1] == ')':\n            no_of_swaps += 1\n        if s[i] == '{' and s[i-1] == '}':\n            no_of_swaps += 1\n        if s[i] == '[' and s[i-1] == ']':\n            no_of_swaps += 1\n        if s[i] == '(' and s[i-1] == ')':\n            no_of_swaps += 1\n        if s[i] == '{' and s[i-1] == '}':\n            no_of_swaps += 1\n        if s[i] == '[' and s[i-1] == ']':\n            no_of_swaps += 1\n        if s[i] == '(' and s[i-1] == ')':\n            no_of_swaps += 1\n        if s[i] == '{' and s[i-1] == '}':\n            no_of_swaps += 1\n        if s[i] == '[' and s[i-1] == ']':\n            no_of_swaps += 1\n    return no_of_swaps\n\nif __name__ == '__main__':\n    s = input().strip()\n    print(min_no_of_swaps(s))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def minSwapBracket(self, s):\n        if not s:\n            return 0\n        d = {}\n        for i in range(1, len(s) + 1):\n            d[s[i-1]] = i\n        for i in range(2, len(s) + 1):\n            d[s[i-2]] = i\n        n = len(s)\n        minn = n\n        for i in range(n):\n            if s[i] not in d:\n                minn = min(minn, i + 1)\n        return minn\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.minSwapBracket(\"()()\"))\n    print(s.minSwapBracket(\"(a)(a)\"))\n    print(s.minSwapBracket(\"(a(b)a)(a)\"))\n    print(s.minSwapBracket(\"(a(b)a)()\"))\n    print(s.minSwapBracket(\"()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "# A solution using a recursive algorithm\n# Time complexity: O(n^2)\ndef bracket_balanced(string):\n    if len(string) == 1:\n        return 0\n\n    # Get the length of the longest substring\n    max_len = len(string)\n    for i in range(1, max_len):\n        if string[i]!= string[0]:\n            break\n\n    # Find the minimum number of swaps for the longest substring\n    min_no_swaps = max_len - i\n    for j in range(1, max_len):\n        if string[j]!= string[0]:\n            break\n\n        # If the substring is not balanced, move one character\n        if string[i]!= string[j]:\n            min_no_swaps += 1\n\n    # Return the minimum number of swaps\n    return min_no_swaps\n\n# Time complexity: O(n^2)\ndef bracket_balanced_recursive(string):\n    if len(string) == 1:\n        return 0\n\n    # Find the length of the longest substring\n    max_len = len(string)\n    for i in range(1, max_len):\n        if string[i]!= string[0]:\n            break\n\n    # Find the minimum number of swaps for the longest substring\n    min_no_swaps = max_len - i\n    for j in range(1, max_len):\n        if string[j]!= string[0]:\n            break\n\n        # If the substring is not balanced, move one character\n        if string[i]!= string[j]:\n            min_no_swaps += 1\n\n    # Return the minimum number of swaps\n    return min_no_swaps\n\nif __name__ == '__main__':\n    string = \"abbcabbc\"\n    print bracket_balanced(string)\n    print bracket_balanced_recursive(string)"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def min_no_of_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    n = len(s)\n    dp = [1 for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i]!= s[j]:\n                dp[i] = min(dp[i], dp[j]+1)\n    return dp[0]\n\n\nif __name__ == '__main__':\n    assert min_no_of_swaps(\"abcd\") == 3\n    assert min_no_of_swaps(\"ab\") == 1\n    assert min_no_of_swaps(\"\") == 0"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def minimum_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    # https://leetcode.com/problems/minimum-swaps-to-make-string-balanced/discuss/240137/Python-Recursive-Solution-Solution-O(n)\n    if len(s) == 1:\n        return 0\n    if s[0] == s[1]:\n        return 1\n    return minimum_swaps(s[1:]) + minimum_swaps(s[:1])"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "# write your code here\ndef find_min_swaps(string):\n    swap_count = 0\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            if string[i] == string[j] and string[i]!= string[j-1]:\n                swap_count += 1\n    return swap_count\n\nif __name__ == \"__main__\":\n    string = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "import string\ndef min_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if s is None or len(s) == 0:\n        return 0\n    \n    s = s.lower()\n    s_list = s.split()\n    \n    s_list = [string.ascii_lowercase + string.ascii_uppercase + string.digits] + s_list\n    \n    s_list = list(set(s_list))\n    \n    n = len(s_list)\n    \n    swaps = 0\n    \n    for i in range(n):\n        for j in range(i):\n            if s_list[i] == s_list[j] and i!= j:\n                swaps += 1\n    \n    return swaps\n\nif __name__ == \"__main__\":\n    s = \"aaaabbbbcccddddeeeeee\"\n    print(min_swaps(s))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def find_min_no_swaps(str):\n    \"\"\"\n    :type str: str\n    :rtype: int\n    \"\"\"\n    min_no_swaps = 0\n    for i in range(len(str)):\n        for j in range(i+1, len(str)):\n            if str[i] > str[j]:\n                min_no_swaps += 1\n                str[i], str[j] = str[j], str[i]\n    return min_no_swaps\n\nif __name__ == '__main__':\n    s = 'abcabc'\n    print(find_min_no_swaps(s))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import sys\n\ndef get_min_no_of_swaps(s):\n    if s == '':\n        return 0\n    else:\n        return min(get_min_no_of_swaps(s[0:i]) for i in range(1, len(s))) + 1\n\nif __name__ == '__main__':\n    s = input()\n    print(get_min_no_of_swaps(s))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minPairs(self, s):\n        if len(s) < 2:\n            return 0\n        \n        left, right = 0, len(s)-1\n        \n        while left < right:\n            if s[left] > s[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        if left == right:\n            return 1\n        \n        return 2 + self.minPairs(s[left:right+1])\n\n\nif __name__ == \"__main__\":\n    s = \"aaabbbcccd\"\n    sol = Solution()\n    print(sol.minPairs(s))\n    print(sol.minPairs(\"aaaabbbccccd\"))\n    print(sol.minPairs(\"bbb\"))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def find_min_num_of_swaps(string):\n    \"\"\"\n    :type string: str\n    :rtype: int\n    \"\"\"\n    table = dict()\n    for i in range(len(string)):\n        if string[i] in table:\n            table[string[i]] += 1\n        else:\n            table[string[i]] = 1\n    for i in range(len(string)):\n        if string[i] in table:\n            if table[string[i]] > 1:\n                return i\n            else:\n                table.pop(string[i])\n    return len(string)\n\nif __name__ == '__main__':\n    string = \"abcd\"\n    print(find_min_num_of_swaps(string))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s == \"\":\n            return 0\n\n        # s[i] is a character in the string\n        # s[j] is the character before it\n        # s[k] is the character after it\n        # s[l] is the character after the character before it\n        # s[m] is the character after the character after it\n        # s[n] is the character after the character after the character before it\n        # s[o] is the character after the character after the character after the character before it\n        # s[p] is the character after the character after the character after the character after the character before it\n        # s[q] is the character after the character after the character after the character after the character after the character before it\n        # s[r] is the character after the character after the character after the character after the character after the character after the character before it\n        # s[s] is the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[t] is the character after the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[u] is the character after the character after the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[v] is the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[w] is the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[x] is the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character after the character before it\n        # s[y] is the character after the character after the character after the character after the character after the character after the character after the character after the character"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "# Bracket balancing\n# Bracket balancing can be solved by swapping a number of brackets.\n# This is the problem to solve.\n#\n# Bracket balancing is a particular case of string balancing.\n# The number of swaps required to balance the string is\n# the number of times the brackets are balanced.\n#\n# For example, given the string \"()()(()())()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "def find_min_swaps(s):\n    # Write your code here\n    swaps = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] > s[j]:\n                swaps += 1\n    return swaps\n\nif __name__ == '__main__':\n    s = \"ABAB\"\n    print(find_min_swaps(s))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "# https://leetcode.com/problems/bracket-balancing/\nclass Solution:\n    # @param s, a string\n    # @return an integer\n    def minSwaps(self, s):\n        num = len(s)\n        if num < 2:\n            return num\n        dp = [[0 for j in range(num + 1)] for i in range(num + 1)]\n        for i in range(1, num + 1):\n            for j in range(i):\n                if s[j] == s[i]:\n                    dp[j][i] = dp[j][i - 1] + 1\n                else:\n                    dp[j][i] = min(dp[j][i - 1], dp[j + 1][i])\n        return dp[0][num]"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "\"\"\"\nWe will use a stack to keep track of the current brackets.\n\"\"\"\ndef min_swap(s):\n    stack = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            top = stack.pop()\n            stack[-1] = min(stack[-1], top)\n    return stack[-1]"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "class Solution:\n    # @return an integer\n    def minBalanced(self, s):\n        if len(s) == 1:\n            return 0\n        def get_len(s):\n            return len(s)\n        def is_balanced(s):\n            length = get_len(s)\n            for i in range(length):\n                if s[i]!= s[length - i - 1]:\n                    return False\n            return True\n        def get_pos(s):\n            return [0] + [i for i in range(1, len(s) + 1)]\n        def get_min_swaps(s):\n            pos = get_pos(s)\n            pos_len = len(pos)\n            min_swaps = 0\n            for i in range(pos_len - 1):\n                if pos[i] + 1 < pos[i + 1]:\n                    min_swaps += 1\n                else:\n                    pos[i + 1] += 1\n                    if pos[i + 1] - pos[i] >= 2:\n                        pos[i] += 1\n                        pos[i + 1] -= 2\n            return min_swaps\n        def get_sorted_pos(s):\n            pos = get_pos(s)\n            sorted_pos = sorted(pos)\n            return sorted_pos\n        def get_min_swaps_sorted(s):\n            pos = get_sorted_pos(s)\n            return get_min_swaps(pos)\n        def get_sorted_pos_sorted(s):\n            pos = get_sorted_pos(s)\n            return get_pos(pos)\n        return min(get_min_swaps_sorted(s), get_min_swaps_sorted(sorted(s)))\n\n\nif __name__ == \"__main__\":\n    s = \"abbacaabb\"\n    print(Solution().minBalanced(s))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "import re\n\ndef find_min_swap(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    def get_min_swap(s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 1\n        pairs = []\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j] and i!= j:\n                    pairs.append((i, j))\n        return min(pairs)\n    return get_min_swap(s)\n\nif __name__ == \"__main__\":\n    s = \"aabbcccddddd\"\n    print(find_min_swap(s))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        length = len(s)\n        if length == 1:\n            return 0\n        dp = [[0] * (length+1) for i in range(length+1)]\n        dp[0][0] = 1\n        for i in range(1, length+1):\n            dp[i][0] = 1\n            for j in range(1, i+1):\n                if s[i-1] == s[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1])\n        return dp[length][length-1]"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from collections import Counter\n\ndef get_min_swap(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    swap_count = Counter(s)\n    swap_count = {key: value for key, value in swap_count.items() if value > 1}\n    swap_count = sorted(swap_count.items(), key=lambda x: x[1], reverse=True)\n    return swap_count[0][0]\n\n\nif __name__ == '__main__':\n    s = \"abcd\"\n    print(get_min_swap(s))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minSwapBracket(self, s):\n        l, r = 0, len(s) - 1\n        while l < r:\n            if s[l] == s[r]:\n                l += 1\n                r -= 1\n            elif s[l] < s[r]:\n                l += 1\n            else:\n                r -= 1\n        return r - l\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.minSwapBracket(\"aabcc\")\n    print s.minSwapBracket(\"abbcc\")\n    print s.minSwapBracket(\"abbbcc\")"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "# The main idea of the algorithm is to count the number of times a character in the given string is\n# encountered in a non-decreasing order. If the string is balanced, we can say that the number of times a character\n# in the string is encountered in a non-decreasing order is equal to the number of times a character in the string\n# is encountered in a non-increasing order.\n#\n# So, we can write the function as follows.\n#\n# def min_swaps(string):\n#     # Your code here\n#\n#\n# Test cases:\n#\n# \"abcd\"\n# \"abcde\"\n# \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abcde\", \"abc"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from string import ascii_lowercase\n\nclass Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s1, s2 = s[0], s[1]\n        if s1 > s2:\n            s1, s2 = s2, s1\n        for i in range(len(s) - 1):\n            if s1 > s2:\n                if s[i]!= s[i + 1]:\n                    return i + 1\n            else:\n                if s[i]!= s[i + 2]:\n                    return i + 2\n        return len(s)"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minSwap(self, s):\n        if not s:\n            return 0\n        \n        l = len(s)\n        stack = []\n        res = 0\n        \n        for i in range(l):\n            if s[i] == '(' or s[i] == '[' or s[i] == '{':\n                stack.append(i)\n            elif s[i] == ')' or s[i] == ']' or s[i] == '}':\n                if stack and i == stack[-1]:\n                    stack.pop()\n                else:\n                    return -1\n            \n        return len(stack)"
    },
    {
      "rank": 54,
      "score": 7.0,
      "candidate": "# https://www.hackerrank.com/challenges/bracket-balancing/problem\n\ndef get_bracket_balancing(s):\n    stack = []\n    min_bracket_balancing = len(s)\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            stack.pop()\n    return min(min_bracket_balancing, len(stack))\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for a0 in range(t):\n        s = input().strip()\n        print(get_bracket_balancing(s))"
    },
    {
      "rank": 55,
      "score": 4.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 1\n        \n        # count the number of swaps required for each character\n        cnt = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        for i in range(1, len(s)):\n            for j in range(i):\n                cnt[i][j] = cnt[j][i] = min(cnt[i-1][j] + 1, cnt[j][i-1] + 1)\n        \n        # compute the minimum no of swaps required for a string\n        min_cnt = 0\n        for i in range(len(s)):\n            min_cnt = max(min_cnt, cnt[i][i] - 1)\n        return min_cnt\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/bracket-balancing/solution/\n\n# 7ms 99.68%\nclass Solution {\n    public int minSwaps(String s) {\n        if (s.length() == 1) return 1;\n        int[] dp = new int[s.length()];\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                } else {\n                    left[i] = Math.min(left[i], dp[j] + 1);\n                    right[i] = Math.min"
    },
    {
      "rank": 56,
      "score": 3.0,
      "candidate": "# Time:  O(n^2)\n# Space: O(1)\n\n# Bracket balancing:\n# 1. If i < j, i < j-1, j-1 < j-2\n# 2. If i < j, i < j-1, j-1 < j-2, j-2 < j-3\n# 3. If i < j, i < j-1, j-1 < j-2, j-2 < j-3, j-3 < j-4\n# 4. If i < j, i < j-1, j-1 < j-2, j-2 < j-3, j-3 < j-4, j-4 < j-5\n#...\n# 5. If i < j, i < j-1, j-1 < j-2, j-2 < j-3,...\n#\n# Bracket balancing with fixed depth:\n# 1. If i < j, i < j-1, j-1 < j-2\n# 2. If i < j, i < j-1, j-1 < j-2, j-2 < j-3\n# 3. If i < j, i < j-1, j-1 < j-2, j-2 < j-3, j-3 < j-4\n# 4. If i < j, i < j-1, j-1 < j-2, j-2 < j-3,...\n# 5. If i < j, i < j-1, j-1 < j-2, j-2 < j-3,...\n#\n# Time complexity: O(n^2)\n# Space complexity: O(n)\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i > j:\n                return 0\n            if i == j:\n                return 1\n            if s[i] == s[j]:\n                return dfs(i + 1, j - 1) + 1\n            else:\n                return max(dfs(i + 1, j - 1), dfs(i + 1, j))"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution:\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 1:\n            return 0\n        dp = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 1\n        return dp[0][0]\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/bracket-balancing/solution/\n\n# 1ms 100%\nclass Solution {\n    public int minSwaps(String s) {\n        int n = s.length();\n        if (n == 1) return 0;\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return dp[0];\n    }\n}\n\n# 2ms 100%\nclass Solution {\n    public int minSwaps(String s) {\n        int n = s.length();\n        if (n == 1) return 0;\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (s"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n\n# The input will be a string consisting of lowercase letters and digits only.\n\n# Example 1:\n\n# Input: \"cba\"\n# Output: 1\n# Explanation: The string can be balanced in 3 different ways:\n#           1. \"cba\" -> \"bac\"\n#           2. \"cba\" -> \"abca\"\n#           3. \"cba\" -> \"abcba\"\n# Example 2:\n\n# Input: \"a\"\n# Output: 1\n# Explanation: The string can be balanced in 2 different ways:\n#           1. \"a\" -> \"aa\"\n#           2. \"a\" -> \"aaa\"\n# Example 3:\n\n# Input: \"aa\"\n# Output: 2\n# Explanation: The string can be balanced in 3 different ways:\n#           1. \"aa\" -> \"aaa\"\n#           2. \"aa\" -> \"a\"\n#           3. \"aa\" -> \"aa\"\n# Example 4:\n\n# Input: \"a\"\n# Output: 0\n# Explanation: The string is balanced.\n\n# Note:\n\n# The string consists of lowercase letters and digits only.\n# The length of the string will be in the range [1, 1000].\n# The input string will be given as the first line of input.\n# The output string will be in the form of \"Case #x: y\", where x is the test case number and y is the minimum number of swaps.\n\nclass Solution(object):\n    def minBalancedBrackets(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(' or s[i] == '{' or s[i] == '[':\n                max_len = max(max_len, i)\n            else:\n                max_len = max(max_len, i+1)\n\n        if max_len == len(s):\n            return 0\n\n        if max_len == 1:\n            return 1\n\n        return max(self.minBalancedBr"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        stack = []\n        for i in xrange(len(s)):\n            if s[i] == s[i+1]:\n                cnt += 1\n            else:\n                stack.append(s[i])\n                stack.append(s[i+1])\n        return cnt\n\n\ns = Solution()\ns.minBalancedSwap('abab')\nprint s.minBalancedSwap('abb')"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "import unittest\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        m = [[-1 for _ in xrange(len(s))] for _ in xrange(len(s))]\n        for i in xrange(len(s)):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    m[i][j] = m[j][i] = 0\n                else:\n                    m[i][j] = 1 + min(m[i+1][j], m[i][j-1])\n                    m[j][i] = 1 + min(m[j-1][i], m[j][i+1])\n        return min(m[0][len(s)-1])\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/bracket-balancing-string/solution/\n\n# DFS\n# 1ms 100%\nclass Solution {\n    public int minSwaps(String s) {\n        int[] dp = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                }\n            }\n            dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n        }\n        return dp[s.length() - 1];\n    }\n}\n\n# DFS + DP\n# 1ms 100%\nclass Solution {\n    public int minSwaps(String s) {\n        int[] dp = new int[s.length()];\n        for"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = defaultdict(int)\n        for i, c in enumerate(s):\n            count[c] += 1\n        dp = defaultdict(lambda: sys.maxsize)\n        for i, c in enumerate(s):\n            if count[c] == 1:\n                dp[c] = i\n        for i, c in enumerate(s):\n            if count[c] > 1:\n                dp[c] = min(dp[c], dp[c-1]+1)\n        return dp[s[-1]]"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "# Your code here\n\nclass Solution(object):\n    def minPairs(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) <= 1:\n            return 1\n        dp = [[1] * len(s) for _ in range(len(s))]\n        dp[0][0] = 1\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) <= 1:\n            return 0\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            mid = (left + right) / 2\n            if s[mid] == s[right]:\n                left = mid + 1\n            elif s[mid] > s[right]:\n                right = mid\n            elif s[mid] < s[right]:\n                left = mid + 1\n        return left"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 0\n        cnt = 0\n        for i in xrange(len(s)):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    cnt += 1\n                    s[i], s[j] = s[j], s[i]\n        return cnt"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def minBalancing(self, s):\n        def rec(i):\n            if i == len(s):\n                return 0\n            if s[i] == s[i - 1]:\n                return rec(i - 1)\n            if s[i] == s[i + 1]:\n                return rec(i + 1)\n            return max(rec(i - 1), rec(i + 1)) + 1\n        return rec(0)"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minPairs(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s[i] < s[j]:\n                    count += 1\n        return count"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # s is not empty\n        # s[0] is the first character\n        # s[1] is the second character\n        # s[2] is the third character\n        # s[3] is the fourth character\n        # s[4] is the fifth character\n        # s[5] is the sixth character\n        # s[6] is the seventh character\n        # s[7] is the eighth character\n        # s[8] is the ninth character\n        # s[9] is the tenth character\n        # s[10] is the eleventh character\n        # s[11] is the twelveth character\n        # s[12] is the thirteenth character\n        # s[13] is the fourteenth character\n        # s[14] is the fifteenth character\n        # s[15] is the sixteenth character\n        # s[16] is the seventeenth character\n        # s[17] is the eighteenth character\n        # s[18] is the nineteenth character\n        # s[19] is the twentieth character\n        # s[20] is the twentyth character\n        # s[21] is the twentyfirst character\n        # s[22] is the twentysecond character\n        # s[23] is the twentythird character\n        # s[24] is the twentyfourth character\n        # s[25] is the twentyfifth character\n        # s[26] is the twentysixth character\n        # s[27] is the twentyfirst character\n        # s[28] is the twentysecond character\n        # s[29] is the twentythird character\n        # s[30] is the twentyfourth character\n        # s[31] is the twentyfifth character\n        # s[32] is the twentysixth character\n        # s[33] is the twentyfirst character\n        # s[34] is the twentysecond character\n        # s[35] is the twentythird character\n        # s[36] is the twentyfourth character\n        # s[37] is the twentyfifth character\n        # s[38] is the twentysixth character\n        # s[39]"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "\"\"\"\nExample\nGiven \"abcde\", the minimum number of swaps is 1.\nGiven \"abcd\", the minimum number of swaps is 1.\nGiven \"bacd\", the minimum number of swaps is 3.\n\n\"\"\"\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass Solution(object):\n    def minSwap(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n\n        def helper(root):\n            if not root.left and not root.right:\n                return 0\n\n            if not root.left:\n                return max(helper(root.left), helper(root.right)) + 1\n\n            if not root.right:\n                return max(helper(root.left), helper(root.right)) + 1\n\n            return max(helper(root.left), helper(root.right)) + 1\n\n        return helper(root)\n\n\nif __name__ == '__main__':\n    tree = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))\n    print Solution().minSwap(tree)\n    print Solution().minSwap(None)"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "\"\"\"\nFor example:\nGiven \"aabcc\", the answer should be 1, because \"aabcc\" can be balanced by [\"a\", \"b\", \"c\"] or [\"a\", \"b\", \"c\", \"a\"]\n\"\"\"\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        length = len(s)\n        count = 0\n        for i in range(length):\n            if s[i] == s[(i + 1) % length]:\n                count += 1\n        return count"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minBalancedBrackets(self, s):\n        if s == '':\n            return 0\n        count = 0\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(' or s[i] == '[' or s[i] == '{':\n                stack.append(i)\n            elif s[i] == ')' or s[i] == ']' or s[i] == '}':\n                if len(stack) == 0:\n                    return 0\n                else:\n                    temp = stack.pop()\n                    if s[temp] == '(' and s[i]!= '(':\n                        count += 1\n                    elif s[temp] == '[' and s[i]!= '[':\n                        count += 1\n                    elif s[temp] == '{' and s[i]!= '{':\n                        count += 1\n                    else:\n                        stack.append(i)\n        return count"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param s: A string\n    @return: An integer\n    \"\"\"\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.minBalancedSwap1(s)\n\n    def minBalancedSwap1(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        count = 0\n        stack = []\n        for i in xrange(len(s)):\n            if s[i] == '(' or s[i] == '{':\n                stack.append(i)\n            elif s[i] == ')' or s[i] == '}':\n                if len(stack) == 0:\n                    return 0\n                else:\n                    top = stack.pop()\n                    if s[top] == '(' and s[i] == ')':\n                        count += 1\n                    elif s[top] == '{' and s[i] == '}':\n                        count += 1\n                    elif s[top] == '(' and s[i] == ')':\n                        count += 1\n                    elif s[top] == '{' and s[i] == '}':\n                        count += 1\n        return count"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # write your code here\n        return 0\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.minBalancedSwap(\"(()())\")"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param s: A string\n    @return: An integer\n    \"\"\"\n    def minBalanceBrackets(self, s):\n        # write your code here\n        if len(s) < 2:\n            return 0\n\n        brackets = []\n        for i in range(len(s)):\n            if s[i] == '[':\n                brackets.append(i)\n            elif s[i] == ']':\n                if len(brackets) < 2:\n                    brackets.pop()\n                else:\n                    brackets.pop()\n                    brackets.pop()\n        return len(brackets)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.minBalanceBrackets('[[]]')\n    print s.minBalanceBrackets('[[]]]')\n    print s.minBalanceBrackets('[[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]][[]][[]][[]][[]][[]][[]][[]]')\n    print s.minBalanceBrackets('[[]][[]][[]]"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef bracket_balancing(str):\n    \"\"\"\n    Bracket balancing requires that the brackets balance.\n    For example, the string \"({a})\" is balanced, but the string \"(({a}))\" is not balanced.\n    \"\"\"\n    bracket_map = defaultdict(int)\n    for char in str:\n        if char == \"(\":\n            bracket_map[char] += 1\n        elif char == \")\":\n            bracket_map[char] -= 1\n    return min(bracket_map.values())\n\nif __name__ == \"__main__\":\n    assert bracket_balancing(\"({a})({b})({c})\") == 2\n    assert bracket_balancing(\"({a})({b})\") == 1\n    assert bracket_balancing(\"({a})({b})({c})\") == 1\n    assert bracket_balancing(\"({a})({b})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"(({a})\") == 0\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({a})\") == 1\n    assert bracket_balancing(\"({"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return an integer\n    def minBalancedSwap(self, s):\n        n = len(s)\n        if n <= 1:\n            return 0\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            if s[i-1] == s[i]:\n                dp[i] += 1\n            if i < n - 1:\n                if s[i-1] == s[i+1]:\n                    dp[i] += 1\n        return min(dp)\n\n\nif __name__ == '__main__':\n    s = \"abacadabacabadabac\"\n    print(Solution().minBalancedSwap(s))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution:\n    def minNumSwaps(self, s: str) -> int:\n        m = [[0 for j in range(len(s))] for i in range(len(s))]\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i] == s[j]:\n                    m[i][j] = m[j][i] = 1\n                else:\n                    m[i][j] = m[j][i] = min(m[i][j-1], m[j+1][i]) + 1\n\n        return min(m[0][len(s)-1], m[len(s)-1][0])\n\ns = Solution()\nprint(s.minNumSwaps(\"abcccdd\"))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def min_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    if s[0] == '(' and s[-1] == ')':\n        return 1\n    if s[0] == ')' and s[-1] == '(':\n        return 1\n    if s[0] == '(' and s[-1] == ')':\n        return 1\n    if s[0] == ')' and s[-1] == '(':\n        return 1\n    if s[0] == '[' and s[-1] == ']':\n        return 1\n    if s[0] == ']' and s[-1] == '[':\n        return 1\n    if s[0] == '[' and s[-1] == ']':\n        return 1\n    if s[0] == ']' and s[-1] == '[':\n        return 1\n    if s[0] == '<' and s[-1] == '>':\n        return 1\n    if s[0] == '<' and s[-1] == '>':\n        return 1\n    if s[0] == '<' and s[-1] == '=':\n        return 1\n    if s[0] == '>' and s[-1] == '=':\n        return 1\n    if s[0] == '>' and s[-1] == '<':\n        return 1\n    if s[0] == '=' and s[-1] == '=':\n        return 1\n    if s[0] == '=' and s[-1] == '>':\n        return 1\n    if s[0] == '=' and s[-1] == '<':\n        return 1\n    if s[0] == '>' and s[-1] == '>':\n        return 1\n    if s[0] == '>' and s[-1] == '=':\n        return 1\n    if s[0] == '<' and s[-1] == '<':\n        return 1\n    if s[0] =="
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "\"\"\"\nInput:\nThe input string is given in the form of a list of characters.\n\"\"\"\ndef min_swaps(input_string):\n\t\"\"\"\n\tInput:\n\t\tinput_string: string\n\tOutput:\n\t\tminimum swaps: int\n\t\"\"\"\n\tinput_string = ''.join(input_string)\n\tstack = []\n\tstack_len = 0\n\tfor char in input_string:\n\t\tif char in stack:\n\t\t\tstack_len += 1\n\t\telse:\n\t\t\tstack.append(char)\n\t\t\tstack_len = 1\n\t\tif len(stack) == 2:\n\t\t\tif stack_len > 2:\n\t\t\t\tstack_len = 2\n\t\t\telse:\n\t\t\t\tstack_len = 1\n\t\tif stack_len == 2:\n\t\t\tstack_len += 1\n\treturn stack_len\n\n\"\"\"\nInput:\nThe input string is given in the form of a list of characters.\nOutput:\nThe minimum swaps required for bracket balancing in the given string.\n\"\"\"\ndef min_swaps_bracket(input_string):\n\t\"\"\"\n\tInput:\n\t\tinput_string: string\n\tOutput:\n\t\tminimum swaps: int\n\t\"\"\"\n\tinput_string = ''.join(input_string)\n\tstack = []\n\tstack_len = 0\n\tfor char in input_string:\n\t\tif char in stack:\n\t\t\tstack_len += 1\n\t\telse:\n\t\t\tstack.append(char)\n\t\t\tstack_len = 1\n\t\tif len(stack) == 2:\n\t\t\tif stack_len > 2:\n\t\t\t\tstack_len = 2\n\t\t\telse:\n\t\t\t\tstack_len = 1\n\t\tif stack_len == 2:\n\t\t\tstack_len += 1\n\treturn stack_len\n\n\"\"\"\nInput:\nThe input string is given in the form of a list of characters.\nOutput:\nThe minimum swaps required for bracket balancing in the given string.\n\"\"\"\ndef min_swaps_bracket_2(input_string):\n\t\"\"\"\n\tInput:\n\t\tinput_string: string\n\tOutput:\n\t\tminimum swaps: int\n\t\"\"\"\n\tinput_string = ''.join(input_string)\n\tstack = []\n\tstack_len = 0\n\tfor char in input_string:"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "# Bracket balancing\n# Write a function to find out the minimum no of swaps required for bracket balancing in the given string.\n#\n# Example\n#\n# Given s = \"((()))\", return 1.\n# Given s = \"()()())\", return 3.\n#\n# Challenge\n#\n# There are at most 2*n swaps required to balance brackets.\n#\n# Note\n#\n# The given string may contain open and close brackets of any length.\n# The given string may contain only lowercase alphabets.\n#\n# Related Topics\n# Stack\n#\n# Similar Questions\n# (M) Swap Pairs\n# (M) Minimum Moves to Equal\n# (M) Minimum Number of Arrows\n# (M) Minimum Number of Arrows II\n# (M) Minimum Number of Arrows III\n# (M) Minimum Number of Arrows IV\n# (M) Minimum Number of Arrows V\n# (M) Minimum Number of Arrows VI\n# (M) Minimum Number of Arrows VII\n# (M) Minimum Number of Arrows VIII\n# (M) Minimum Number of Arrows IX\n# (M) Minimum Number of Arrows X\n# (M) Minimum Number of Arrows XI\n# (M) Minimum Number of Arrows XII\n# (M) Minimum Number of Arrows XIII\n# (M) Minimum Number of Arrows XIV\n# (M) Minimum Number of Arrows XV\n# (M) Minimum Number of Arrows XVI\n# (M) Minimum Number of Arrows XVII\n# (M) Minimum Number of Arrows XVIII\n# (M) Minimum Number of Arrows XVIV\n# (M) Minimum Number of Arrows XVV\n# (M) Minimum Number of Arrows XVI\n# (M) Minimum Number of Arrows XVII\n# (M) Minimum Number of Arrows XVIII\n# (M) Minimum Number of Arrows XVIV\n# (M) Minimum Number of Arrows XVV\n# (M) Minimum Number of Arrows XVI\n# (M) Minimum Number of Arrows XVII\n# (M) Minimum Number of Arrows XVIII\n# (M) Minimum Number of Arrows XVIV\n# (M) Minimum Number of Arrows XVV\n# (M) Minimum Number of Arrows XVI\n# (M) Minimum Number of Arrows XVII\n# (M) Minimum Number of Arrows XVIII\n# (M) Minimum Number of Arrows XVIV\n# (M) Minimum Number"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # dp, left, right, last, max_len = {}, 0, 0, 0, 0\n        # for i in range(len(s)):\n        #     if i - left > max_len:\n        #         max_len = i - left\n        #     if i - right > max_len:\n        #         max_len = i - right\n        #     if s[i] == s[i - left]:\n        #         dp[i] = dp[i - left] + 1\n        #     if s[i] == s[i - right]:\n        #         dp[i] = dp[i - right] + 1\n        #     if dp[i] < max_len:\n        #         max_len = dp[i]\n        # return max_len\n        dp = [0] * (len(s) + 1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] == s[right]:\n                dp[left] = dp[right] = 1\n                left += 1\n                right -= 1\n            elif dp[left] < dp[right]:\n                dp[left] = dp[right] = dp[left] + 1\n                left += 1\n            else:\n                dp[right] = dp[left] = dp[right] + 1\n                right -= 1\n        return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert Solution().minSwap(\"aba\") == 2"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) < 2:\n            return 0\n        # store the current state\n        current = [s[0]]\n        # store the last two characters\n        last = [s[-1]]\n        # store the first two characters\n        first = [s[0]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last2 = [s[-2]]\n        # store the last three characters\n        last3 = [s[-3]]\n        # store the last four characters\n        last4 = [s[-4]]\n        # store the last two characters\n        last"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.lower()\n        n = len(s)\n        for i in range(n):\n            for j in range(i+1, n):\n                if s[i] == s[j] and (i!= j and s[i]!= s[j-1] and s[j]!= s[i+1]):\n                    return min(s[i], s[j]) + 1\n        return n\n\n\nif __name__ == \"__main__\":\n    assert Solution().minBalancedSwap(\"abbab\") == 4"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "class Solution:\n    def minimumSwap(self, s: str) -> int:\n        \"\"\"\n        Bracket balancing:\n        The problem is that we can swap the brackets around to make the string balanced.\n        We can do it in one pass by looking at the leftmost character and the rightmost character.\n        If the leftmost character is '(' and the rightmost character is ')', we can swap the brackets.\n        If the leftmost character is '[' and the rightmost character is ']', we can swap the brackets.\n        If the leftmost character is '{' and the rightmost character is '}', we can swap the brackets.\n        If the leftmost character is '(' and the rightmost character is ')', we can swap the brackets.\n        If the leftmost character is '[' and the rightmost character is ']', we can swap the brackets.\n        If the leftmost character is '{' and the rightmost character is '}', we can swap the brackets.\n        If the leftmost character is '(' and the rightmost character is ')', we can swap the brackets.\n        If the leftmost character is '[' and the rightmost character is ']', we can swap the brackets.\n        If the leftmost character is '{' and the rightmost character is '}', we can swap the brackets.\n        :param s: str\n        :return: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        if n <= 2:\n            return n\n        min = n\n        for i in range(1, n):\n            if s[i-1] == '(' and s[i] == ')' or \\\n               s[i-1] == '[' and s[i] == ']' or \\\n               s[i-1] == '{' and s[i] == '}' or \\\n               s[i-1] == '(' and s[i] == ')' or \\\n               s[i-1] == '[' and s[i] == ']' or \\\n               s[i-1] == '{' and s[i] == '}' or \\\n               s[i-1] == '(' and s[i] == ')' or \\"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "\"\"\"\nConstraints:\n\t1 <= len(s) <= 100\n\ts is a balanced string.\n\"\"\"\n\nclass Solution:\n\t\n\tdef minSwaps(self, s):\n\t\t\"\"\"\n\t\t:type s: str\n\t\t:rtype: int\n\t\t\"\"\"\n\t\tdef minSwaps(s):\n\t\t\tif len(s) == 1:\n\t\t\t\treturn 0\n\t\t\tn = len(s)\n\t\t\tm = n // 2\n\t\t\twhile m >= 1:\n\t\t\t\tif s[m] == s[n - m]:\n\t\t\t\t\treturn min(minSwaps(s[:m]) + 1, minSwaps(s[m + 1:n]))\n\t\t\t\telif s[m] > s[n - m]:\n\t\t\t\t\treturn minSwaps(s[:m])\n\t\t\t\tm = m // 2\n\t\t\treturn minSwaps(s[:1]) + 1\n\t\treturn minSwaps(s)"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i == 0 or j == len(s) - 1:\n                return 0\n            if s[i]!= s[j]:\n                return 1\n            return min(dfs(i - 1, j) + 1, dfs(i, j - 1) + 1)\n        return dfs(0, len(s) - 1)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.minSwap('ab'))"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "import unittest\nimport sys\nsys.path.append(\"../\")\nfrom quick_sort import partition\n\n\nclass Test(unittest.TestCase):\n\n    def test_partition(self):\n        self.assertEqual(partition(\"aabccd\", \"a\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"d\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"b\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"c\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"aacd\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"cccd\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"aabccd\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"aabcdd\"), (0, 1, 2, 3, 4))\n        self.assertEqual(partition(\"aabccd\", \"aabccdabcd\"), (0, 1, 2, 3, 4))\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        dp = [1] * n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i + 1, n):\n                if s[i]!= s[j] and s[i]!= s[i+1] and s[j]!= s[j-1]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[0]\n\n\nif __name__ == \"__main__\":\n    s = \"abbbbbbb\"\n    print(Solution().minSwap(s))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# This is a naive implementation.\n# We need to do better.\n\ndef min_swaps(s):\n    \"\"\"\n    Returns the minimum number of swaps required to make the string balanced.\n\n    :type s: str\n    :rtype: int\n    \"\"\"\n    def find_min_swaps(s, cur_pos):\n        \"\"\"\n        Returns the minimum number of swaps required to make the string balanced.\n\n        :type s: str\n        :type cur_pos: int\n        :rtype: int\n        \"\"\"\n        if s[cur_pos] == s[cur_pos+1]:\n            return 0\n\n        if s[cur_pos] == s[cur_pos+2]:\n            return 1\n\n        if s[cur_pos] == s[cur_pos+3]:\n            return 2\n\n        if s[cur_pos] == s[cur_pos+4]:\n            return 3\n\n        if s[cur_pos] == s[cur_pos+5]:\n            return 4\n\n        if s[cur_pos] == s[cur_pos+6]:\n            return 5\n\n        if s[cur_pos] == s[cur_pos+7]:\n            return 6\n\n        if s[cur_pos] == s[cur_pos+8]:\n            return 7\n\n        if s[cur_pos] == s[cur_pos+9]:\n            return 8\n\n        if s[cur_pos] == s[cur_pos+10]:\n            return 9\n\n        return 10\n\n    l = len(s)\n    cur_pos = 0\n    min_swaps = 0\n\n    while cur_pos < l:\n        min_swaps = min(min_swaps, find_min_swaps(s, cur_pos))\n        cur_pos += 1\n\n    return min_swaps\n\nif __name__ == \"__main__\":\n    assert(min_swaps(\"aabcccdaaa\") == 0)\n    assert(min_swaps(\"abbcccd\") == 0)\n    assert(min_swaps(\"abbcccd\") == 0)\n    assert(min_swaps(\"abbcccd\") == 0)\n    assert(min_swaps(\"abbcccd\") == 0"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "import unittest\nimport timeit\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 1:\n            return 0\n        num = len(s)\n        if len(s) == 2:\n            if s[0] == s[1]:\n                return 0\n            else:\n                return 1\n        if s[0] == s[1]:\n            return 0\n        else:\n            return 1 + self.minSwaps(s[2:])\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/bracket-balancing/solution/\n#\nApproach 1: Bracket Balancing\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the input string.\nSpace Complexity: O(1)\n\n# 8ms 98.73%\nclass Solution {\n    public int minSwaps(String s) {\n        if (s.length() == 1) return 0;\n        if (s.length() == 2) return 1;\n        if (s.charAt(0) == s.charAt(1)) return 0;\n        int res = 1;\n        for (int i = 2; i < s.length(); i++) {\n            if (s.charAt(i) == s.charAt(i - 1)) res++;\n            else res++;\n        }\n        return res;\n    }\n}\n\nApproach 2: Bracket Balancing\nComplexity Analysis\nTime Complexity: O(n), where n is the length of the input string.\nSpace Complexity: O(1)\n\n# 9ms 98.73%\nclass Solution {\n    public int minSwaps(String s) {\n        if (s.length() == 1) return 0;\n        if (s.length() == 2) return 1;\n        if (s.charAt("
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minBalanceBracket(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        # count number of left and right brackets\n        # count the number of characters on each side of the brackets\n        # for every character, count the number of brackets on either side\n        # if the number of brackets on either side is more than the other,\n        # then we need to swap the character\n        l = 0\n        r = 0\n        for i in xrange(len(s)):\n            if s[i] == '(':\n                l += 1\n            elif s[i] == ')':\n                r += 1\n        if l > r:\n            return self.minBalanceBracket(self.swap(s, l, r))\n        elif l < r:\n            return self.minBalanceBracket(self.swap(s, l, r))\n        else:\n            return 0\n\n    def swap(self, s, l, r):\n        return s[:l] + s[r:] + s[l:r] + s[l+1:r] + s[l+1:] + s[r+1:l] + s[r+1:] + s[r+1:] + s[l:r]\n\n\nif __name__ == \"__main__\":\n    assert Solution().minBalanceBracket(\"()())\") == 3\n    assert Solution().minBalanceBracket(\"()(())\") == 3\n    assert Solution().minBalanceBracket(\"())\") == 2\n    assert Solution().minBalanceBracket(\"((()))\") == 3\n    assert Solution().minBalanceBracket(\"(())()\") == 3"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nGiven a string, you are asked to balance brackets so that all the brackets are balanced.\n\nThe brackets can be balanced in one of the following ways:\n\nRemove the outermost bracket and make the next character be a bracket.\nIf the next character is a bracket, then remove the next character and make it the previous character.\nIf the next character is not a bracket, then remove the previous character and make the next character be a bracket.\n\nFor example, consider the string \"()())\". After removing the first set of parentheses, \"()\" is balanced.\nAfter removing the second set of parentheses, \"())()\" is balanced.\nAfter removing the third set of parentheses, \"()()()\" is balanced.\n\nGiven a string s, return the minimum number of swaps required to make s balanced.\n\nNote:\ns will consist only of the characters \"({[\".\n\n\"\"\"\n\nclass Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        stack = [0]\n        for i in xrange(1, len(s)):\n            if s[i-1] == '(' and s[i] == ')':\n                stack.append(i)\n            elif s[i-1] == ')':\n                while stack and stack[-1] >= i:\n                    stack.pop()\n            elif s[i-1] == '(' and s[i] == '[':\n                stack.append(i)\n            elif s[i-1] == '[' and s[i] == ']':\n                while stack and stack[-1] >= i:\n                    stack.pop()\n        return len(stack)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        dp = [0 for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i] = 1\n            for j in range(i):\n                if s[i] == s[j]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return dp[-1]\n\n\nif __name__ == \"__main__\":\n    s = \"aabcc\"\n    sol = Solution()\n    print(sol.minSwap(s))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minBalancedSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # http://www.cnblogs.com/yixue-ge/p/379879.html\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if s[i]!= s[j]:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        return min(dp[-1])"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        \"\"\"\n        Bracket balancing\n        Bracket balancing can be solved in two ways.\n        1. Use O(n^2) time and space\n        2. Use O(n) time and space\n        \"\"\"\n        if not s:\n            return 0\n\n        n = len(s)\n        dp = [0 for i in range(n)]\n\n        for i in range(1, n):\n            for j in range(i):\n                if s[i] == s[j] and dp[i] < dp[j]:\n                    dp[i] = dp[j] + 1\n        return dp[0]"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import unittest\nfrom solution import bracket_balancing\n\nclass TestBracketBalancing(unittest.TestCase):\n    def test_bracket_balancing(self):\n        self.assertEqual(bracket_balancing('{(a) (b) (c) (d) (e)}'), 3)\n        self.assertEqual(bracket_balancing('{(a) (b) (c)}'), 1)\n        self.assertEqual(bracket_balancing('{(a) (b)}'), 1)\n        self.assertEqual(bracket_balancing('{(a)}'), 1)\n        self.assertEqual(bracket_balancing('{(a) (b) (c) (d) (e)}'), 4)\n        self.assertEqual(bracket_balancing('{(a) (b) (c) (d)}'), 4)\n        self.assertEqual(bracket_balancing('{(a) (b) (c)}'), 4)\n        self.assertEqual(bracket_balancing('{(a) (b)}'), 4)\n        self.assertEqual(bracket_balancing('{(a)}'), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def min_swaps(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    dic = {}\n    for i in range(len(s)):\n        dic[s[i]] = i\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] < s[j]:\n                dic[s[i]] = min(dic[s[i]], dic[s[j]]+1)\n    return dic[s[0]]\n\n#Test case 1\ns = \"aabcc\"\nprint min_swaps(s)\n\n#Test case 2\ns = \"abbabaa\"\nprint min_swaps(s)"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return self.bracketBalancing(s, 0, len(s) - 1)\n\n    def bracketBalancing(self, s, i, j):\n        if i > j:\n            return 0\n\n        if i == j:\n            return 1\n\n        if s[i] == s[j]:\n            return self.bracketBalancing(s, i + 1, j - 1) + 1\n\n        return min(self.bracketBalancing(s, i + 1, j),\n                   self.bracketBalancing(s, i, j - 1))\n\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(1, n):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert Solution().minSwap(\"(()\") == 3\n    assert Solution().minSwap(\"(()()())\") == 4"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def minSwap(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        m = len(s)\n        if m == 0:\n            return 0\n        d = {s[0]: 0}\n        for i in range(1, m):\n            d[s[i]] = i\n        d[s[0]] = -1\n        visited = set()\n        res = 0\n        while len(visited) < m:\n            if d[s[0]] == -1:\n                visited.add(s[0])\n                d[s[0]] = 0\n                res = max(res, 1)\n            for i in range(1, m):\n                if s[i] not in visited and d[s[i]]!= -1:\n                    d[s[i]] = d[s[i]] + 1\n                    res = max(res, d[s[i]])\n                    visited.add(s[i])\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().minSwap(\"aabcc\") == 2\n    assert Solution().minSwap(\"abbac\") == 3\n    assert Solution().minSwap(\"aabcc\") == 2\n    assert Solution().minSwap(\"aabbc\") == 2"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def minSwaps(self, root: TreeNode) -> int:\n        \"\"\"\n        Brute Force.\n        :param root:\n        :return:\n        \"\"\"\n        if root is None:\n            return 0\n\n        stack = [root]\n        result = 0\n        while stack:\n            node = stack.pop()\n            if node.left is None and node.right is None:\n                result += 1\n            elif node.left is not None and node.right is not None:\n                stack.append(node.left)\n                stack.append(node.right)\n            elif node.left is not None:\n                stack.append(node.left)\n            elif node.right is not None:\n                stack.append(node.right)\n        return result\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.left.left.left = TreeNode(8)\n    root.left.left.right = TreeNode(9)\n    root.left.right.left = TreeNode(10)\n    root.left.right.right = TreeNode(11)\n    root.right.left.left = TreeNode(12)\n    root.right.left.right = TreeNode(13)\n    root.right.right.left = TreeNode(14)\n    root.right.right.right = TreeNode(15)\n\n    print(Solution().minSwaps(root))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minSwap(self, s: str) -> int:\n        \"\"\"\n        Bracket balancing\n        :param s: a string\n        :return: minimum no of swaps\n        \"\"\"\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(' or s[i] == '[' or s[i] == '{':\n                stack.append(i)\n            elif s[i] == ')' or s[i] == ']' or s[i] == '}':\n                if stack:\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n        return len(stack)\n\n\nif __name__ == '__main__':\n    s = '()[]{}()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()"
    }
  ]
}