{
  "timestamp": "2025-09-14T18:05:03.118768",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 97,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\nclass Solution:\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(lists)\n        res = []\n        for i in range(len(lists)):\n            while len(res) and lists[i][0] >= lists[res[-1][0]]:\n                heappop(res)\n            heappush(res, (lists[i][0], i))\n        return res\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    lists = [\n        [4,7,10,15],\n        [2,6,8,10],\n        [2,5,7,8],\n        [1,3,4,5],\n    ]\n    print(sol.merge(lists))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def merge(self, trees):\n        \"\"\"\n        :type trees: List[TreeNode]\n        :rtype: TreeNode\n        \"\"\"\n        heapq.heapify(trees)\n        while trees:\n            yield heapq.heappop(trees)\n        return\n\n    def buildTree(self, pre, cur):\n        if not pre:\n            return cur\n        if not cur:\n            return pre\n        if pre.val > cur.val:\n            pre.right = self.buildTree(pre.right, cur)\n            pre.val = cur.val\n            return pre\n        else:\n            pre.left = self.buildTree(pre.left, cur)\n            pre.val = cur.val\n            return pre\n\n\"\"\"\nSample Input:\n[\n    [3,2,1],\n    [4,1,1],\n    [5,5,1],\n]\n\nSample Output:\n[\n    [1,1,1],\n    [2,1,1],\n    [3,2,1],\n    [4,1,1],\n    [5,5,1],\n    [3,2,1],\n    [4,1,1],\n    [5,5,1],\n]\n\"\"\"\n\nimport unittest\n\nclass SolutionTest(unittest.TestCase):\n    def test_sample(self):\n        tree = TreeNode(3)\n        tree.left = TreeNode(2)\n        tree.right = TreeNode(1)\n        tree.right.left = TreeNode(1)\n        tree.right.right = TreeNode(1)\n        tree.right.right.left = TreeNode(1)\n        tree.right.right.right = TreeNode(1)\n        tree.right.right.right.left = TreeNode(1)\n        tree.right.right.right.right = TreeNode(1)\n        tree.right.right.right.right.left = Tree"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val):\n#         self.val = val\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 or n == 0:\n            return nums1\n        if m == 1 or n == 1:\n            return nums1 + nums2\n        if m == 0 or n == 0:\n            return nums1\n        if m == 1 or n == 1:\n            return nums1 + nums2\n        \n        ans = []\n        heap = [TreeNode(nums2[0])]\n        for i in range(1, n):\n            node = heap[0]\n            while len(heap) > 1 and nums1[i - 1] > node.val:\n                heap.remove(heap[0])\n                heap.insert(0, TreeNode(nums2[i]))\n            heap.insert(0, TreeNode(nums1[i - 1]))\n            ans.append(node.val)\n        \n        return ans"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        if not lists[0]:\n            return lists[0]\n        if len(lists) == 1:\n            return lists[0]\n        head = None\n        for node in lists[0]:\n            if head:\n                head.next = node\n            else:\n                head = node\n        for i in range(1, len(lists)):\n            node = ListNode(0)\n            cur = head\n            for node in lists[i]:\n                cur.next = node\n                cur = cur.next\n            if cur:\n                cur.next = head\n            else:\n                cur = head\n            head = cur\n        return head"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(nums1)\n        heapq.heapify(nums2)\n        result = []\n        while m > 0 and n > 0:\n            if nums1[0] > nums2[0]:\n                result.append(nums2[0])\n                heapq.heappop(nums2)\n                n -= 1\n            else:\n                result.append(nums1[0])\n                heapq.heappop(nums1)\n                m -= 1\n        while n > 0:\n            result.append(nums2[0])\n            heapq.heappop(nums2)\n            n -= 1\n        while m > 0:\n            result.append(nums1[0])\n            heapq.heappop(nums1)\n            m -= 1\n        return result"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode[]} sortedLists\n    # @return {ListNode}\n\n    def merge(self, sortedLists):\n        # write your code here\n        if not sortedLists:\n            return None\n\n        q = []\n        for l in sortedLists:\n            if l is None:\n                continue\n            q.append(l)\n        if len(q) == 1:\n            return q[0]\n\n        head = None\n        curr = None\n        for l in q:\n            if l is None:\n                continue\n            if curr is None:\n                curr = l\n                head = curr\n                continue\n            curr.next = l\n            curr = l\n        return head\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    l1 = [1, 3, 5]\n    l2 = [2, 4, 6]\n    l3 = [3, 5, 7]\n    print(sol.merge(l1))\n    print(sol.merge(l2))\n    print(sol.merge(l3))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import heapq\n\nclass Solution:\n    \"\"\"\n    @param: A list of sorted integer\n    @return: An integer iterator\n    \"\"\"\n    def merge(self, nums):\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums_size = len(nums)\n        if nums_size == 0:\n            return\n\n        if nums_size == 1:\n            return nums[0]\n\n        heapq.heapify(nums)\n        curr_index = 0\n        while curr_index < nums_size:\n            # get current value\n            curr_value = nums[curr_index]\n            # get next value\n            next_index = curr_index + 1\n            while next_index < nums_size and nums[next_index] < curr_value:\n                next_value = nums[next_index]\n                heapq.heapreplace(nums, next_value)\n                next_index += 1\n\n            # put current value back\n            heapq.heappush(nums, curr_value)\n            curr_index += 1\n\n        return nums[0]\n\n\nif __name__ == '__main__':\n    print Solution().merge([1, 2, 3, 4])"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in range(n):\n            heapq.heappush(heap, (nums1[i], i))\n        for i in range(m):\n            heapq.heappush(heap, (nums2[i], i))\n        output = []\n        while heap:\n            val, idx = heapq.heappop(heap)\n            output.append(val)\n        return output\n\nclass Solution2(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        for i in range(n):\n            output.append(nums1[i])\n        for i in range(m):\n            output.append(nums2[i])\n        return output\n\n\nif __name__ == \"__main__\":\n    print Solution().merge([], 0, [], 0)\n    print Solution().merge([1], 0, [2], 0)\n    print Solution().merge([1], 0, [2, 1], 1)\n    print Solution().merge([1, 2, 3, 4], 1, [2, 1], 3)\n    print Solution().merge([1, 2, 3, 4, 5, 6], 1, [2, 1, 5, 6], 4)"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\ndef merge_sorted_iterators(iterators):\n    \"\"\"\n    Merge multiple sorted iterators into a single sorted iterator.\n    :type iterators: List[Iterable[int]]\n    :rtype: Iterator[int]\n    \"\"\"\n    heap = []\n    for iterator in iterators:\n        for num in iterator:\n            heappush(heap, num)\n    return heap\n\n\n# Your MergeSortedIterators solution here.\ndef merge_sorted_iterators(iterators):\n    \"\"\"\n    Merge multiple sorted iterators into a single sorted iterator.\n    :type iterators: List[Iterable[int]]\n    :rtype: Iterator[int]\n    \"\"\"\n    heap = []\n    for iterator in iterators:\n        for num in iterator:\n            heappush(heap, num)\n    return heap\n\n\nif __name__ == '__main__':\n    assert merge_sorted_iterators([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]\n    assert merge_sorted_iterators([[1, 2], [3, 4], [5, 6, 7]]) == [1, 2, 3, 4, 5, 6, 7]\n    assert merge_sorted_iterators([[1, 2], [3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert merge_sorted_iterators([[1, 2, 3], [4, 5], [6, 7]]) == [1, 2, 3, 4, 5, 6, 7]"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        head = None\n        for l in lists:\n            if head is None:\n                head = l\n            else:\n                head.next = l\n                head = l\n        return head"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution:\n    def merge(self, A):\n        \"\"\"\n        :param A: List of lists\n        :return: List of lists\n        \"\"\"\n        if not A:\n            return []\n        if len(A[0]) == 0:\n            return A\n\n        l = len(A)\n        r = len(A[0])\n        p = [None] * l\n        heapq.heappush(p, (0, 0))\n        for i in range(l):\n            while p[i] and p[i][0] < r:\n                heapq.heappush(p, (heapq.heappop(p)[0] + heapq.heappop(p)[1], i))\n            heapq.heappush(p, (r, i))\n\n        ans = []\n        while p:\n            ans.append(p.pop())\n\n        return ans\n\n\nif __name__ == \"__main__\":\n    assert Solution().merge([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    assert Solution().merge([[1, 2], [4, 5]]) == [[1, 2], [4, 5]]\n    assert Solution().merge([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    # @param lists, a list of lists of integer\n    # @return a single list node\n    def mergeKLists(self, lists):\n        if len(lists) == 0:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        head = ListNode(0)\n        cur = head\n        for i in range(len(lists)):\n            cur.next = ListNode(0, lists[i][0])\n            cur = cur.next\n        cur.next = ListNode(0, lists[i][0])\n        cur = head\n        while cur.next:\n            cur = cur.next\n        return head.next\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    a1 = [[1,2,3],[4,5,6],[7,8,9]]\n    a2 = [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]\n    a3 = [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def merge(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int], nums5: List[int], nums6: List[int], nums7: List[int], nums8: List[int], nums9: List[int]) -> None:\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :type nums5: List[int]\n        :type nums6: List[int]\n        :type nums7: List[int]\n        :type nums8: List[int]\n        :type nums9: List[int]\n        :rtype: None\n        \"\"\"\n        nums1.extend(nums2)\n        nums3.extend(nums4)\n        nums5.extend(nums6)\n        nums7.extend(nums8)\n        nums9.extend(nums9)\n\n        nums1.sort()\n        nums3.sort()\n        nums5.sort()\n        nums7.sort()\n        nums9.sort()\n        \n        nums1 = list(reversed(nums1))\n        nums3 = list(reversed(nums3))\n        nums5 = list(reversed(nums5))\n        nums7 = list(reversed(nums7))\n        nums9 = list(reversed(nums9))\n\n        res = []\n        curr = nums1\n        prev = curr[0]\n        i = 1\n        while i < len(curr) and i < len(nums3) and nums3[i] < prev:\n            prev = nums3[i]\n            i += 1"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2):\n        heap = []\n        for num in nums1:\n            heap.append(num)\n            if len(heap) > 1:\n                heap[0] = max(heap[0], heap[1])\n        for num in nums2:\n            heap.append(num)\n            if len(heap) > 1:\n                heap[0] = max(heap[0], heap[1])\n        ans = []\n        while heap:\n            ans.append(heap.pop())\n        return ans"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in xrange(m):\n            heap.append(nums1[i])\n        for i in xrange(n):\n            heap.append(nums2[i])\n        ans = []\n        while heap:\n            ans.append(heap.pop(0))\n            if len(heap) > 0:\n                heap[0] = max(heap[0], heap[-1])\n        return ans"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(nums1)\n        heapq.heapify(nums2)\n        res = []\n        while m and n:\n            if nums1[0] < nums2[0]:\n                res.append(nums1.pop(0))\n                heapq.heappop(nums1)\n                heapq.heappop(nums2)\n                m -= 1\n            elif nums1[0] > nums2[0]:\n                res.append(nums2.pop(0))\n                heapq.heappop(nums2)\n                heapq.heappop(nums1)\n                n -= 1\n            else:\n                res.append(nums1.pop(0))\n                res.append(nums2.pop(0))\n                heapq.heappop(nums1)\n                heapq.heappop(nums2)\n                m -= 1\n                n -= 1\n        while m:\n            res.append(nums1.pop(0))\n            heapq.heappop(nums1)\n            m -= 1\n        while n:\n            res.append(nums2.pop(0))\n            heapq.heappop(nums2)\n            n -= 1\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().merge([1, 2, 3, 4], 2, [5, 6, 7], 3) == [1, 2, 3, 5, 6, 7]\n    assert Solution().merge([], 0, [], 0) == []"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1 and not l2:\n            return None\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, val=0, next=None):\n\t\tself.val = val\n\t\tself.next = next\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef mergeKLists(self, lists):\n\t\t\"\"\"\n\t\tK lists\n\t\t\"\"\"\n\t\tif not lists:\n\t\t\treturn None\n\t\thead = ListNode(-1)\n\t\tcur = head\n\t\twhile len(lists):\n\t\t\t# get the first list\n\t\t\tcur.next = lists.pop(0)\n\t\t\tcur = cur.next\n\t\treturn head.next\n\n\nif __name__==\"__main__\":\n\tsolution = Solution()\n\tl1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))).next\n\tl2 = ListNode(6, ListNode(7, ListNode(8, ListNode(9))))\n\tl3 = ListNode(10, ListNode(11, ListNode(12, ListNode(13))))\n\tl4 = ListNode(14, ListNode(15, ListNode(16, ListNode(17))))\n\tl5 = ListNode(18, ListNode(19, ListNode(20, ListNode(21))))\n\tl6 = ListNode(22, ListNode(23, ListNode(24)))\n\tl7 = ListNode(25, ListNode(26, ListNode(27, ListNode(28))))\n\tl8 = ListNode(29, ListNode(30, ListNode(31, ListNode(32))))\n\tl9 = ListNode(33, ListNode(34, ListNode(35, ListNode(36))))\n\tl10 = ListNode(37, ListNode(38, ListNode(39, ListNode(40))))\n\tl11 = ListNode(41, ListNode(42, ListNode(43, ListNode(44))))\n\tl12 = ListNode(45, ListNode(46, ListNode(47, ListNode(48))))\n\tl13 = ListNode(49, ListNode(50, ListNode(51, ListNode(52))))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> List[int]:\n        # Note: The solution is trivial to understand, but not correct.\n        # Since we have to merge m*n elements, but each element has only 1 value.\n        # We need to use a heap queue to store all the elements, and then sort them.\n        # Then we can just merge the m*n elements into one sorted list.\n        heap = []\n        for i in range(m):\n            heap.append(nums1[i])\n        for i in range(n):\n            heap.append(nums2[i])\n        result = []\n        while heap:\n            heap[0] = heap.pop(-1)\n            result.append(heap[0])\n        return result\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums2 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    nums3 = [3, 4, 5, 6, 7, 8, 9, 10]\n    nums4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums5 = [3, 4, 5, 6, 7, 8, 9, 10]\n    nums6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums7 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    nums9 = [1, 2, 3, 4, 5, 6, 7,"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def merge(self, lists: List[ListNode]) -> ListNode:\n        if not lists:\n            return None\n        head = ListNode(0)\n        tail = head\n        for l in lists:\n            cur = tail\n            while l:\n                cur.next = ListNode(l.val)\n                l = l.next\n                cur = cur.next\n            tail = cur\n        return head.next"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        h = []\n        h_end = len(nums1) + len(nums2) - 1\n        for i in range(m, h_end):\n            h.append(min(nums1[i], nums2[i]))\n        return h"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution:\n    def merge(self, A, B):\n        \"\"\"\n        :param A: a list of lists of int\n        :param B: a list of lists of int\n        :return: a list of int\n        \"\"\"\n        # base case\n        if not A:\n            return B\n        if not B:\n            return A\n\n        A_heap, B_heap = [], []\n        for i in range(len(A[0])):\n            A_heap.append(A[0][i])\n            B_heap.append(B[0][i])\n\n        while A_heap and B_heap:\n            if A_heap[0] <= B_heap[0]:\n                A_heap.pop(0)\n                B_heap.pop(0)\n            else:\n                A_heap[0] = max(A_heap[0], B_heap[0])\n                B_heap.pop(0)\n\n        return A_heap + B_heap\n\n\nif __name__ == \"__main__\":\n    assert Solution().merge([[1]], [[2]]) == [[1, 2]]\n    assert Solution().merge([[1]], [[2, 3]]) == [[1, 2, 3]]\n    assert Solution().merge([[1]], [[3, 2]]) == [[1, 3, 2]]"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "import heapq\n\ndef merge(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not arrays:\n        return []\n\n    min_heap = []\n    heap_queue = []\n    for arr in arrays:\n        for x in arr:\n            heapq.heappush(min_heap, x)\n    \n    while min_heap:\n        min_val = min_heap[0]\n        heap_queue.append(min_val)\n        del min_heap[0]\n        for arr in arrays:\n            if arr[0] == min_val:\n                arr.pop(0)\n                heapq.heappush(heap_queue, arr[0])\n                arr.pop(0)\n                heapq.heappush(min_heap, arr[0])\n                arr.pop(0)\n            elif arr[0] > min_val:\n                arr.pop(0)\n                heapq.heappush(min_heap, arr[0])\n            else:\n                break\n    return heap_queue[0]\n\n# Your MergeSortedIterator object will be instantiated and called as such:\n# obj = MergeSortedIterator(arr)\n# param_1 = obj.next()\n# param_2 = obj.next()\n# param_3 = obj.next()\n# param_4 = obj.next()\n# param_5 = obj.next()\n# param_6 = obj.next()\n\narr = [ [1,2,3], [4,5,6], [7,8,9], [10,11,12], [13,14,15] ]\n\nprint merge(arr)"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "# https://leetcode.com/problems/merge-sorted-array/description/\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def merge(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        if not head.next:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        while curr.next and curr.next.next:\n            curr = curr.next\n        curr.next = curr.next.next\n        curr.next = None\n        curr = dummy\n        while head.next:\n            curr = curr.next\n            head = head.next\n            curr.next = curr.next.next\n        curr.next = head\n        return dummy.next"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if l1 is None:\n            return l2\n        if l2 is None:\n            return l1\n        head = ListNode(0)\n        head.next = l1\n        cur = head\n        while l1 and l2:\n            if l1.val < l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        if l1 is not None:\n            cur.next = l1\n        if l2 is not None:\n            cur.next = l2\n        return head.next"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "import collections\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        q = collections.deque()\n        for i in xrange(m):\n            q.append((i, nums1[i]))\n        for i in xrange(n):\n            q.append((i, nums2[i]))\n        res = []\n        while q:\n            curr = q.popleft()\n            res.append(curr[1])\n            while q and q[0][1] == curr[1]:\n                q.popleft()\n        return res"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 or n == 0:\n            return nums2\n        if m == 1 or n == 1:\n            return nums1 + nums2\n        if m > n:\n            return self.merge(nums2, n, nums1, m-1)\n        if n > m:\n            return self.merge(nums1, m, nums2, n-1)\n        l = m + n - 1\n        r = m + n - 2\n        i = m - 1\n        j = n - 1\n        res = []\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                res.append(nums1[i])\n                i -= 1\n            elif nums1[i] < nums2[j]:\n                res.append(nums2[j])\n                j -= 1\n            else:\n                res.append(nums1[i])\n                i -= 1\n                j -= 1\n        while i >= 0:\n            res.append(nums1[i])\n            i -= 1\n        while j >= 0:\n            res.append(nums2[j])\n            j -= 1\n        return res\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums1 = [1, 2, 3]\n    m = 2\n    nums2 = [4, 5, 6]\n    n = 3\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    nums1 = [1, 2, 3"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        queue = []\n        for i in range(m+n):\n            if i >= m:\n                queue.append(nums2[i-m])\n            elif i >= n:\n                queue.append(nums1[i-n])\n            else:\n                queue.append(max(nums1[i-n], nums2[i-m]))\n\n        heapq.heappush(queue, queue[0])\n        res = []\n        while len(queue) > 0:\n            res.append(heapq.heappop(queue))\n\n        return res"
    },
    {
      "rank": 29,
      "score": 9.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @param nums3, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2, nums3):\n        heapq.heappush(nums1, -heapq.heappop(nums2))\n        for n in nums3:\n            heapq.heappush(nums1, n)\n        return nums1\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.merge([1, 3, 5], [2, 4], [6, 7, 8])\n    print sol.merge([], [], [])\n    print sol.merge([1], [2, 3], [4, 5])\n    print sol.merge([1], [2], [3, 4, 5])\n    print sol.merge([], [], [])"
    },
    {
      "rank": 30,
      "score": 9.0,
      "candidate": "from heapq import *\n\ndef merge(iterable):\n    \"\"\"\n    :type iterable: Iterable[int]\n    :rtype: Iterable[int]\n    \"\"\"\n    result = []\n\n    queue = []\n    for item in iterable:\n        if queue:\n            if item <= queue[-1]:\n                queue[-1] = max(item, queue[-1])\n            else:\n                heappush(queue, item)\n        else:\n            heappush(queue, item)\n        if len(queue) > 10:\n            heappop(queue)\n\n    while queue:\n        heappush(result, queue[0])\n        queue[0] = heappop(queue)\n\n    return result\n\nclass Solution:\n    # @param iterable, a list of integer\n    # @return a list of integer\n    def merge(self, iterable):\n        if not iterable:\n            return []\n        else:\n            queue = []\n            result = []\n            for item in iterable:\n                if queue:\n                    if item <= queue[-1]:\n                        queue[-1] = max(item, queue[-1])\n                    else:\n                        heappush(queue, item)\n                else:\n                    heappush(queue, item)\n                if len(queue) > 10:\n                    heappop(queue)\n\n            while queue:\n                heappush(result, queue[0])\n                queue[0] = heappop(queue)\n\n            return result\n\nif __name__ == \"__main__\":\n    assert Solution().merge([]) == []\n    assert Solution().merge([1]) == [1]\n    assert Solution().merge([1, 2]) == [1, 2]\n    assert Solution().merge([1, 2, 3]) == [1, 2, 3]\n    assert Solution().merge([1, 3, 5]) == [1, 3, 5]\n    assert Solution().merge([1, 3, 5, 7]) == [1, 3, 5, 7]\n    assert Solution().merge([2, 4, 5, 7]) == [2, 4, 5, 7]"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from collections import deque\n\nclass Solution(object):\n    def merge(self, iterators):\n        \"\"\"\n        :type iterators: List[Iterator]\n        :rtype: Iterator\n        \"\"\"\n        heap = []\n        for i in iterators:\n            heapq.heappush(heap, i)\n        \n        i = 0\n        while heap:\n            if i == len(iterators):\n                yield heap.pop()\n            else:\n                j = i\n                while j < len(iterators) and heapq.heappop(heap) < iterators[j]:\n                    j += 1\n                heapq.heappush(heap, iterators[j])\n                i += 1"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        heap = []\n        for list in lists:\n            while list:\n                heapq.heappush(heap, list.val)\n                list = list.next\n        while heap:\n            yield heapq.heappop(heap)"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(nums1)\n        heapq.heapify(nums2)\n\n        result = []\n        i = m-1\n        j = n-1\n\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                result.append(nums2[j])\n                j -= 1\n            elif nums1[i] < nums2[j]:\n                result.append(nums1[i])\n                i -= 1\n            else:\n                result.append(nums1[i])\n                heapq.heappop(nums1)\n                heapq.heappop(nums2)\n\n        while j >= 0:\n            result.append(nums2[j])\n            j -= 1\n\n        while i >= 0:\n            result.append(nums1[i])\n            i -= 1\n\n        return result\n\n    def merge_recursive(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 or n == 0:\n            return nums1 + nums2\n        if m == 1 or n == 1:\n            return nums1[0] + nums2[0]\n        if m > n:\n            return self.merge_recursive(nums2, n, nums1, m-1)\n        else:\n            return self.merge_recursive(nums1, m-1, nums2, n-1)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution()\n# param_"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef merge_sorted(iterators):\n    \"\"\"\n    Merge multiple sorted iterators into a single sorted iterator using heap queue algorithm.\n\n    :param iterators: list of iterators.\n    :return: iterator.\n    \"\"\"\n    iters = iter(iterators)\n    heapq.heappush(iters, next(iters))\n    for iterator in iters:\n        while heapq.heappop(iters) < iterator:\n            heapq.heappush(iters, next(iters))\n    return iters"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2):\n        # write your code here\n        if not nums1:\n            return nums2\n        if not nums2:\n            return nums1\n        if nums1[0] > nums2[0]:\n            return self.merge(nums2, nums1)\n        res = []\n        heap = []\n        heapq.heappush(heap, nums1[0])\n        for i in nums2:\n            while heap and nums1[0] > i:\n                heapq.heappop(heap)\n                res.append(heap[0])\n            heapq.heappush(heap, i)\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5]\n    print(sol.merge(nums1, nums2))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "import heapq\nclass Solution:\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for list in lists:\n            heapq.heappush(result, list[0])\n        while result:\n            yield heapq.heappop(result)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, iterators):\n        \"\"\"\n        :type iterators: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not iterators:\n            return []\n\n        # build heap queue\n        heap = []\n        for iterator in iterators:\n            heap.extend(iterator)\n\n        # sort heap\n        heap.sort(reverse=True)\n\n        # build list\n        result = []\n        while heap:\n            result.append(heap.pop(0))\n\n        return result"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) == 0 and len(nums2) == 0:\n            return []\n        if len(nums1) == 0:\n            return nums2\n        if len(nums2) == 0:\n            return nums1\n        q1 = Queue()\n        q2 = Queue()\n        q1.enqueue(TreeNode(nums1[0]))\n        q2.enqueue(TreeNode(nums2[0]))\n        for i in range(1, len(nums1)):\n            while q1.size() > 0 and q1.peek().val < nums1[i]:\n                q1.dequeue()\n            if q1.size() == 0:\n                break\n            q1.enqueue(TreeNode(nums1[i]))\n        while q2.size() > 0 and q2.peek().val < nums2[0]:\n            q2.dequeue()\n        if q2.size() == 0:\n            return q1.to_list()\n        for i in range(1, len(nums2)):\n            while q2.size() > 0 and q2.peek().val < nums2[i]:\n                q2.dequeue()\n            if q2.size() == 0:\n                break\n            q2.enqueue(TreeNode(nums2[i]))\n        return q1.to_list() + q2.to_list()"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @param nums3, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2, nums3):\n        # Write your code here\n        if len(nums1) == 0 or len(nums2) == 0 or len(nums3) == 0:\n            return []\n        l = len(nums1)\n        r = len(nums2)\n        s = len(nums3)\n        if l > r:\n            heapq.heapify(nums3)\n            i = 0\n            while i < r:\n                heapq.heappush(nums3, nums2[i])\n                i += 1\n        elif r > l:\n            heapq.heapify(nums3)\n            i = 0\n            while i < l:\n                heapq.heappush(nums3, nums1[i])\n                i += 1\n        else:\n            heapq.heapify(nums3)\n            i = 0\n            while i < l:\n                heapq.heappush(nums3, nums1[i])\n                i += 1\n            while i < r:\n                heapq.heappush(nums3, nums2[i])\n                i += 1\n\n        result = []\n        j = 0\n        while j < s:\n            heapq.heappush(result, heapq.heappop(nums3))\n            j += 1\n        return result\n\n    # @param nums, a list of integer\n    # @return a list of integer\n    def mergeSort(self, nums):\n        # Write your code here\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) / 2\n        left = self.mergeSort(nums[:mid])\n        right = self.mergeSort(nums[mid:])\n        return self.merge(left, right, nums)\n\n\nif __"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef merge(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    res = []\n    for arr in arrays:\n        for item in arr:\n            heappush(heap, item)\n    while heap:\n        res.append(heappop(heap))\n    return res\n\ndef test():\n    assert merge([[-1,4,-1,9], [2,6,10,15]]) == [-1, 4, 2, 6, 10, 15]\n    assert merge([[-1,4,-1,9], [2,6,10,15], [3,5,8,11]]) == [-1, 4, 2, 6, 10, 15, 3, 5, 8, 11]\n    assert merge([[2,6,10,15], [3,5,8,11]]) == [2, 6, 10, 15, 3, 5, 8, 11]\n    assert merge([[-1,4,-1,9], [2,6,10,15], [3,5,8,11], [1,7,13,16]]) == [-1, 4, 2, 6, 10, 15, 3, 5, 8, 11, 1, 7, 13, 16]\n    assert merge([[-1,4,-1,9], [2,6,10,15], [3,5,8,11], [1,7,13,16], [4,10,20,30]]) == [-1, 4, 2, 6, 10, 15, 3, 5, 8, 11, 1, 7, 13, 16, 4, 10, 20, 30]\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 or n == 0:\n            return nums1\n        if m > n:\n            return nums1\n        if m == 1:\n            return nums2\n        if n == 1:\n            return nums1 + nums2\n        heap = [(0, 0)]\n        for i in range(1, m+1):\n            heapq.heappush(heap, (nums1[i-1], i))\n        for i in range(1, n+1):\n            heapq.heappush(heap, (nums2[i-1], i))\n        result = []\n        while heap:\n            k, v = heapq.heappop(heap)\n            result.append(k)\n            m -= 1\n            n -= 1\n            if m == 0:\n                return result\n            if n == 0:\n                return result + nums1\n            if m > n:\n                return result + nums1\n            if n > m:\n                return result + nums1 + nums2\n            if m == 1:\n                return result + nums2\n            if n == 1:\n                return result + nums1\n            heapq.heappush(heap, (nums1[m-1], m))\n            heapq.heappush(heap, (nums2[n-1], n))\n        return result\n\n\nif __name__ == '__main__':\n    print Solution().merge([1,3], 2, [2,5], 3)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heap = [(x, i) for i, x in enumerate(nums1)]\n        for i in range(m):\n            heapq.heappush(heap, (nums2[i], i))\n        res = [heapq.heappop(heap)[1] for _ in range(n)]\n        return res"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        if len(lists) == 0:\n            return res\n        res.extend(lists[0])\n        for i in range(1, len(lists)):\n            while len(res) > 0 and lists[i][0] < res[-1]:\n                res.pop()\n            res.append(lists[i][0])\n        return res\n\nclass Solution2:\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if len(lists) == 0:\n            return []\n        res = []\n        for i in range(len(lists)):\n            while len(res) > 0 and lists[i][0] < res[-1]:\n                res.pop()\n            res.append(lists[i][0])\n        return res"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2):\n        heap = []\n        for num in nums1:\n            heap.append(num)\n        for num in nums2:\n            heap.append(num)\n        heapq.heapify(heap)\n\n        ans = []\n        while heap:\n            ans.append(heap.pop())\n\n        return ans"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        heap = [TreeNode(0)]\n        for i in range(n):\n            heapq.heappush(heap, nums2[i])\n        \n        heapq.heappush(heap, TreeNode(0))\n        \n        i = 0\n        j = 0\n        for i < m:\n            while i < m and j < n and heapq.heappop(heap):\n                heapq.heappush(heap, nums1[i])\n                i += 1\n            while i < m and j < n and nums1[i] <= nums2[j]:\n                heapq.heappush(heap, nums1[i])\n                i += 1\n            j += 1\n        \n        res = []\n        while i < m:\n            res.append(heapq.heappop(heap))\n            i += 1\n        return res"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from collections import deque\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heap = deque()\n        for i in xrange(m):\n            heap.append((nums1[i], i))\n\n        for i in xrange(n):\n            heap.append((nums2[i], i))\n\n        ret = []\n        while heap:\n            val, idx = heap.popleft()\n            ret.append(val)\n            if idx + 1 < m:\n                heap.append((nums1[idx + 1], idx + 1))\n\n        return ret\n\na = Solution()\nprint a.merge([1, 2, 3], 2, [1, 3], 3)\nprint a.merge([1, 2, 3, 4], 2, [5, 6], 2)\nprint a.merge([1, 2, 3, 4], 2, [5, 6], 3)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heap = [0] * n\n        for i in xrange(m):\n            heap[0] = nums1[i]\n            heapq.heappush(heap, nums2[i])\n        for i in xrange(n):\n            heap[i] = heapq.heappop(heap)\n        return heap\n\n    # def merge(self, nums1, m, nums2, n):\n    #     \"\"\"\n    #     :type nums1: List[int]\n    #     :type m: int\n    #     :type nums2: List[int]\n    #     :type n: int\n    #     :rtype: List[int]\n    #     \"\"\"\n    #     heap = [0] * n\n    #     for i in xrange(m):\n    #         heap[0] = nums1[i]\n    #         heapq.heappush(heap, nums2[i])\n    #     for i in xrange(n):\n    #         heap[i] = heapq.heappop(heap)\n    #     return heap\n\n\nif __name__ == '__main__':\n    print Solution().merge([1,2,3], 3, [4,5,6], 3)\n    print Solution().merge([1,2,3], 3, [4,5,6], 5)\n    print Solution().merge([1,2,3], 3, [4,5,6], 6)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @param nums3, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2, nums3):\n        if not nums1:\n            return nums2\n        if not nums2:\n            return nums3\n        if not nums3:\n            return nums1\n        q1 = PriorityQueue()\n        q2 = PriorityQueue()\n        q3 = PriorityQueue()\n        for n in nums1:\n            q1.put(n)\n        for n in nums2:\n            q2.put(n)\n        for n in nums3:\n            q3.put(n)\n        \n        res = []\n        while q1.size() or q2.size() or q3.size():\n            if q1.size():\n                res.append(q1.get())\n            if q2.size():\n                res.append(q2.get())\n            if q3.size():\n                res.append(q3.get())\n        return res\n\ns = Solution()\n\nnums1 = [2, 1, 3]\nnums2 = [1, 2]\nnums3 = [2, 3, 1, 1]\nprint(s.merge(nums1, nums2, nums3))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef merge(iterables):\n    \"\"\"Merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.\n\n    :param iterables: a list of sorted iterables.\n    :return: an iterator that returns the merged sorted elements.\n    \"\"\"\n    heap = []\n    for it in iterables:\n        for e in it:\n            heappush(heap, e)\n    heap.sort()\n    while heap:\n        yield heap.pop()\n\n\nif __name__ == '__main__':\n    assert merge([[3, 2, 1], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]\n    assert merge([[3, 2, 1], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert merge([[3, 2, 1], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        heap = []\n        for i in range(m):\n            heap.append(nums1[i])\n        for i in range(n):\n            heap.append(nums2[i])\n        while heap:\n            res.append(heap[0])\n            heapq.heappop(heap)\n        return res"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "class HeapQueue:\n    def __init__(self, arr):\n        self.heap = []\n        self.arr = arr\n        for i in arr:\n            self.insert(i)\n\n    def insert(self, val):\n        heapq.heappush(self.heap, val)\n\n    def extractMin(self):\n        return heapq.heappop(self.heap)\n\n    def isEmpty(self):\n        return len(self.heap) == 0\n\ndef merge(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    heap = HeapQueue(arr)\n    res = []\n    for i in arr:\n        if heap.extractMin() == i:\n            continue\n        heap.insert(i)\n        res.append(heap.extractMin())\n    return res"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        heap = []\n        for i in range(m):\n            heapq.heappush(heap, (nums1[i], i))\n\n        heap_end = m\n        while heap_end < n:\n            if heap_end > m:\n                heapq.heappush(heap, (nums2[heap_end], heap_end))\n            while heap_end > 0 and heapq.heappop(heap)[0] <= heapq.heappop(heap)[0]:\n                heap_end -= 1\n            while heap_end > 0 and heapq.heappop(heap)[0] > heapq.heappop(heap)[0]:\n                heapq.heappush(heap, (heapq.heappop(heap)[1], heapq.heappop(heap)[0]))\n                heap_end -= 1\n\n        res = []\n        for i in range(m):\n            res.append(heapq.heappop(heap)[1])\n\n        return res"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from collections import deque\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        heapq = deque()\n        heapq.extend(nums1[:m])\n        heapq.extend(nums2[:n])\n        heapq.extend([0] * (m + n - m - n + 1))\n        for i in range(m + n - 1, 0, -1):\n            if heapq[0] > heapq[1]:\n                heapq[0] = heapq[1]\n                heapq[1] = heapq[2]\n                heapq[2] = heapq[3]\n                heapq[3] = heapq[0]\n                heapq.popleft()\n            else:\n                heapq.popleft()\n        for i in range(m + n - 1, 0, -1):\n            result.append(heapq[i])\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().merge([1, 3, 5, 7], 3, [1, 2, 3], 4) == [1, 2, 3, 3, 5, 7]"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if nums1 is None or nums2 is None:\n            return []\n        if len(nums1) == 0:\n            return nums2\n        if len(nums2) == 0:\n            return nums1\n        \n        pq = []\n        heapq.heappush(pq, (nums1[0], 0))\n        heapq.heappush(pq, (nums2[0], 0))\n        \n        while len(pq) > 0:\n            cur = heapq.heappop(pq)\n            cur_len = cur[1]\n            \n            if len(nums1) - cur_len == 0:\n                nums1 = nums1[1:]\n            if len(nums2) - cur_len == 0:\n                nums2 = nums2[1:]\n            \n            heapq.heappush(pq, (nums1[cur_len], cur_len + 1))\n            heapq.heappush(pq, (nums2[cur_len], cur_len + 1))\n        \n        return pq"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @param nums3, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2, nums3):\n        res = []\n        heapq.heapify(res)\n        i, j = 0, 0\n        while i < len(nums1) or j < len(nums2) or j < len(nums3):\n            if i == len(nums1) or j == len(nums2) or j == len(nums3):\n                return res\n            elif nums1[i] > nums2[j] and nums2[j] > nums3[j]:\n                heapq.heappush(res, nums1[i])\n                i += 1\n            elif nums1[i] > nums2[j]:\n                heapq.heappush(res, nums2[j])\n                j += 1\n            else:\n                heapq.heappush(res, nums3[j])\n                j += 1\n        return res"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef merge(arrays):\n    q = deque()\n    for arr in arrays:\n        q.extend(arr)\n    return q\n\ndef merge_sort(arrays):\n    if not arrays:\n        return []\n    if len(arrays) == 1:\n        return arrays[0]\n    mid = len(arrays) / 2\n    left = merge_sort(arrays[:mid])\n    right = merge_sort(arrays[mid:])\n    return merge(left, right)\n\ndef merge_sort_iter(arrays):\n    if not arrays:\n        return []\n    if len(arrays) == 1:\n        return arrays[0]\n    mid = len(arrays) / 2\n    left = merge_sort_iter(arrays[:mid])\n    right = merge_sort_iter(arrays[mid:])\n    return merge(left, right)\n\nif __name__ == \"__main__\":\n    arrays = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    print(merge_sort(arrays))\n    print(merge_sort_iter(arrays))\n    print(merge_sort_iter(arrays))\n    arrays = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    print(merge_sort_iter(arrays))\n    print(merge_sort_iter(arrays))\n    arrays = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    print(merge_sort_iter(arrays))\n    print(merge_sort_iter(arrays))"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        q = []\n        heapq.heapify(q)\n        heapq.heapreplace(q, (m-1, nums1[m-1]))\n        \n        for i in range(n):\n            if len(heapq) == 0:\n                break\n            heapq.heappop(q)\n            heapq.heappush(q, (m+i, nums2[i]))\n        \n        return nums1[:m]+nums2[:n]"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, trees):\n        \"\"\"\n        :type trees: List[TreeNode]\n        :rtype: TreeNode\n        \"\"\"\n        def helper(trees, left, right):\n            if not trees:\n                return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:\n                    return None\n            if not trees[0]:\n                trees.pop(0)\n                if not trees:"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def merge(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        heap = []\n        heap.append(root1)\n        heap.append(root2)\n        while len(heap) > 1:\n            curr = heap[0]\n            heap[0] = heap[1]\n            heap[1] = curr\n            heap.pop(0)\n            if heap[0].left:\n                heap.append(heap[0].left)\n            if heap[0].right:\n                heap.append(heap[0].right)\n        return heap[0]"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "import heapq\n\ndef merge(arrs):\n    # write your code here\n    \"\"\"\n    :type arrs: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    # build heap\n    heap = [x for x in arrs]\n    heapq.heapify(heap)\n\n    # iterate\n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n\n    return result\n\nif __name__ == '__main__':\n    arrs = [[1,2,3,4,5,6], [1,2,3,4,5], [1,2,3,4,5,6], [1,2,3,4,5,6]]\n    print merge(arrs)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def mergeSorted(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for i in nums1:\n            heap.append(TreeNode(i))\n        for i in nums2:\n            heap.append(TreeNode(i))\n        for i in nums3:\n            heap.append(TreeNode(i))\n        result = []\n        while heap:\n            curr = heap.pop()\n            if curr.left is None:\n                result.append(curr.val)\n            else:\n                heapq.heappush(heap, curr.left)\n            if curr.right is None:\n                result.append(curr.val)\n            else:\n                heapq.heappush(heap, curr.right)\n        return result"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        if not lists:\n            return None\n        n = len(lists)\n        if n == 1:\n            return lists[0]\n\n        heap = []\n        heap_size = 0\n        for node in lists:\n            if node:\n                heap.append(node)\n                heap_size += 1\n\n        while heap_size > 1:\n            # get top element from heap\n            node = heap.pop()\n            # add top element to heap\n            heap_size -= 1\n            if not heap_size:\n                heap.append(node)\n                heap_size += 1\n            else:\n                # get right element from heap\n                right_node = heap[heap_size]\n                # put right element into top element\n                heap[0] = node\n                # add right element to heap\n                heap_size -= 1\n                heap.append(right_node)\n\n        # if there are only one element in heap, return that\n        if heap_size == 1:\n            return heap[0]\n        # if there are more than one element in heap, return None\n        return None\n\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists2(self, lists):\n        if not lists:\n            return None\n        n = len(lists)\n        if n == 1:\n            return lists[0]\n\n        result = []\n        p = result\n        for node in lists:\n            if node:\n                p.append(node)\n                p = p[-1]\n            else:\n                p.pop()\n\n        return result[0]\n\n# Note:\n# This is not the fastest way to solve this problem, but the easiest way.\n# The above is the fastest way to solve this problem.\n# The other way is to use a heap queue.\n# The heap queue is more easy to understand"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import heapq\n\ndef merge_sort(iterable):\n    if not iterable:\n        return iterable\n\n    heap = [iter(iterable)]\n    while heap:\n        heapq.heappush(heap, heapq.heappop(heap))\n    return iter(heap[0])\n\ndef test():\n    assert merge_sort([1,3,5,7,9,2,4,6,8]) == [1,2,3,4,5,6,7,8,9]\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return self.merge_sort(nums1, nums2)\n\n    def merge_sort(self, nums1, nums2):\n        if len(nums1) == 0 and len(nums2) == 0:\n            return []\n\n        if len(nums1) == 0:\n            return nums2\n        elif len(nums2) == 0:\n            return nums1\n\n        mid = len(nums1) / 2\n        left_list = self.merge_sort(nums1[:mid], nums2)\n        right_list = self.merge_sort(nums1[mid:], nums2)\n        return self.merge_lists(left_list, right_list)\n\n    def merge_lists(self, left, right):\n        # O(n)\n        result = []\n        i = 0\n        j = 0\n        k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n            k += 1\n        while i < len(left):\n            result.append(left[i])\n            i += 1\n        while j < len(right):\n            result.append(right[j])\n            j += 1\n        return result\n\nif __name__ == \"__main__\":\n    print Solution().merge([5,4,3,2,1], [2,3,4,5,6])"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        head = ListNode(0)\n        head.next = lists[0]\n\n        for i in range(1, len(lists)):\n            cur = head.next\n            while cur:\n                if lists[i].val <= cur.val:\n                    cur = cur.next\n                else:\n                    cur.next = lists[i]\n                    break\n            if cur is None:\n                cur = lists[i]\n        return head.next"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop, heapify\n\ndef merge(iterators):\n    \"\"\"\n    Merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.\n    :type iterators: List[Iterator[int]]\n    :rtype: Iterator[int]\n    \"\"\"\n    heap = []\n    for i in iterators:\n        heappush(heap, i.next())\n    \n    for i in iterators:\n        while len(heap) > 0 and i.next() < heap[0]:\n            heappush(heap, i.next())\n    \n    return heappop(heap)"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        return str(self.val)\n\nclass Solution:\n    def merge(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        heap = []\n        for l in lists:\n            while l:\n                heap.append(l.pop())\n        \n        head = None\n        while heap:\n            if not head:\n                head = heap[0]\n            else:\n                if heap[0].val < head.val:\n                    head = heap[0]\n                else:\n                    heap[0].next = heap[1]\n                    heap[1] = heap[0]\n                    heap[0] = heap[-1]\n                    heap.pop()\n                    \n        return head"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums1:\n            return nums2\n        if not nums2:\n            return nums1\n        if nums1[0] > nums2[0]:\n            return self.merge(nums2, nums1)\n        res = []\n        i = 0\n        j = 0\n        k = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                res.append(nums1[i])\n                i += 1\n            else:\n                res.append(nums2[k])\n                k += 1\n                j += 1\n        res.extend(nums1[i:])\n        res.extend(nums2[j:])\n        return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [2, 4, 1, 6, 3, 7]\n    nums2 = [1, 4, 5, 6, 6, 6]\n    print Solution().merge(nums1, nums2)\n    nums1 = [2, 4, 1, 6, 3, 7, 2]\n    nums2 = [1, 4, 5, 6, 6, 6, 6]\n    print Solution().merge(nums1, nums2)"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import heapq\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 or n == 0:\n            return nums1\n        if m == 1:\n            return nums2\n        if n == 1:\n            return nums1 + nums2\n\n        q1 = []\n        for i in range(m):\n            heapq.heappush(q1, (nums1[i], i))\n\n        q2 = []\n        for i in range(n - 1, -1, -1):\n            heapq.heappush(q2, (nums2[i], i))\n\n        res = []\n        for i in range(m):\n            while len(q1) > 0 and nums1[i] >= nums2[heapq.heappop(q1)[1]]:\n                res.append(nums1[i])\n            res.append(nums2[heapq.heappop(q2)[1]])\n\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.merge([1,2,3,4], 2, [1,2], 2)"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def merge(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if headA is None:\n            return headB\n        if headB is None:\n            return headA\n        if headA.val < headB.val:\n            headA.next = self.merge(headA.next, headB)\n            return headA\n        else:\n            headB.next = self.merge(headA, headB.next)\n            return headB"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def merge(self, head: ListNode, head2: ListNode) -> ListNode:\n        if not head:\n            return head2\n        if not head2:\n            return head\n        if head.val < head2.val:\n            head2.next = self.merge(head, head2.next)\n            return head\n        else:\n            head.next = self.merge(head.next, head2)\n            return head2\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    head = ListNode(1)\n    head2 = ListNode(2)\n    head2.next = ListNode(3)\n    head2.next.next = ListNode(4)\n    head2.next.next.next = ListNode(5)\n    head2.next.next.next.next = ListNode(6)\n    head2.next.next.next.next.next = ListNode(7)\n    head2.next.next.next.next.next.next = ListNode(8)\n    head2.next.next.next.next.next.next.next = ListNode(9)\n    head.next = head2\n    print(solution.merge(head, head2))"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0 and n == 0:\n            return nums1 + nums2\n        if m == 0:\n            return nums2\n        if n == 0:\n            return nums1\n        \n        head = TreeNode(0)\n        curr = head\n        for i in xrange(m):\n            curr.left = TreeNode(nums1[i])\n            curr = curr.left\n        for i in xrange(n):\n            curr.right = TreeNode(nums2[i])\n            curr = curr.right\n        \n        return nums1[:m] + [head.val] + nums2[n:]"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2):\n        if len(nums1) == 0:\n            return nums2\n        if len(nums2) == 0:\n            return nums1\n        heapq.heappush(heap, (len(nums1)+len(nums2), nums1+nums2))\n        while heapq.heappop(heap)[0] > 0:\n            heapq.heappush(heap, (heapq.heappop(heap)[0]-1, heapq.heappop(heap)[1]+heapq.heappop(heap)[2]))\n\n        return heap[0][1]"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if not m or not n:\n            return nums1 or nums2\n        if not nums1:\n            return nums2[:n]\n        if not nums2:\n            return nums1[:m]\n\n        q = []\n        for i in range(m + n):\n            if i < m:\n                q.append(nums1[i])\n            elif i < m + n:\n                q.append(nums2[i - m])\n        return q"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n\tdef __init__(self, val=0, next=None):\n\t\tself.val = val\n\t\tself.next = next\n\n\nclass Solution:\n\t# @param head, a ListNode\n\t# @return a ListNode\n\tdef mergeKLists(self, lists):\n\t\tif not lists:\n\t\t\treturn None\n\t\thead = lists[0]\n\t\tfor i in range(1, len(lists)):\n\t\t\thead = self.mergeTwoLists(head, lists[i])\n\t\treturn head\n\n\tdef mergeTwoLists(self, head1, head2):\n\t\tif not head1:\n\t\t\treturn head2\n\t\tif not head2:\n\t\t\treturn head1\n\t\thead1.next = self.mergeTwoLists(head1.next, head2)\n\t\treturn head1"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        heapq.heapify(nums1)\n        heapq.heapify(nums2)\n        result = []\n        i = 0\n        while i < m or i < n:\n            if i < m and nums1[i] <= nums2[i]:\n                heapq.heappush(result, nums1[i])\n                i += 1\n            elif i < n and nums1[i] > nums2[i]:\n                heapq.heappush(result, nums2[i])\n                i += 1\n            else:\n                heapq.heappop(result)\n        return result\n\n\nif __name__ == '__main__':\n    nums1 = [1, 3, 4, 5, 6, 7]\n    m = 3\n    nums2 = [2, 8, 9, 10]\n    n = 6\n    nums1 = Solution().merge(nums1, m, nums2, n)\n    print(nums1)"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def merge(self, trees):\n        \"\"\"\n        :type trees: List[TreeNode]\n        :rtype: TreeNode\n        \"\"\"\n        def heapify(root):\n            if root is None:\n                return\n\n            left_heap = []\n            right_heap = []\n            heap_size = 1\n            while root is not None:\n                if root.left is None and root.right is None:\n                    heap_size -= 1\n                    heap_push(left_heap, root.val, root.left, root.right)\n                    heap_push(right_heap, root.val, root.left, root.right)\n                elif root.left is not None and root.right is None:\n                    heap_size -= 1\n                    heap_push(left_heap, root.val, root.left, root.right)\n                elif root.left is None and root.right is not None:\n                    heap_size -= 1\n                    heap_push(right_heap, root.val, root.left, root.right)\n                else:\n                    heap_size += 1\n                    heap_push(left_heap, root.val, root.left, root.right)\n                    heap_push(right_heap, root.val, root.left, root.right)\n\n                root = root.left\n            heap_pop(left_heap)\n            heap_pop(right_heap)\n            heap_push(left_heap, trees[0].val, trees[0].left, trees[0].right)\n            heap_push(right_heap, trees[0].val, trees[0].left, trees[0].right)\n\n            while left_heap and right_heap:\n                if left_heap[0] < right_heap[0]:\n                    trees[0].left = left_heap.pop()\n                else:\n                    trees[0"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n        else:\n            return repr(self.next)\n\nclass Solution(object):\n    def merge(self, head1, head2):\n        \"\"\"\n        :type head1: ListNode\n        :type head2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head1:\n            return head2\n        if not head2:\n            return head1\n        if head1.val > head2.val:\n            head1.next = self.merge(head1.next, head2)\n            return head1\n        else:\n            head2.next = self.merge(head1, head2.next)\n            return head2"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param a list of TreeNode\n    # @return a TreeNode\n    def merge(self, a):\n        def merge_helper(a, b):\n            if not a:\n                return b\n            if not b:\n                return a\n            if a.val < b.val:\n                return merge_helper(a.right, b)\n            return merge_helper(a, b.left)\n\n        return merge_helper(a[0], a[0])\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    a = [TreeNode(1), TreeNode(2), TreeNode(3), TreeNode(4)]\n    print(sol.merge(a))"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if m == 0:\n            return nums2\n        if n == 0:\n            return nums1\n        if nums1 == None or nums2 == None:\n            return []\n        \n        # build heap\n        heap = []\n        heap.append((0, nums1[0]))\n        for i in range(1, m):\n            heap.append((heap[0][0]+heap[0][1], nums1[i]))\n        heapq.heapify(heap)\n        \n        # merge\n        for i in range(n-1, -1, -1):\n            while heap[0][0] <= nums2[i]:\n                heapq.heappop(heap)\n            heapq.heappush(heap, (heap[0][0]+heap[0][1], nums2[i]))\n        \n        # return\n        return [heapq.heappop(heap) for _ in range(n)]"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "import heapq\n\ndef merge(arrays):\n    \"\"\"\n    :type arrays: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    heap = []\n    for i in arrays:\n        heapq.heappush(heap, i[0])\n        for j in i[1:]:\n            heapq.heappush(heap, j)\n    return heap[0]\n\nif __name__ == '__main__':\n    arrays = [[3,1,2], [1,3,1,4], [1,1,1], [3,3,3]]\n    print(merge(arrays))"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "class HeapQueue:\n    def __init__(self):\n        self.q = []\n\n    def push(self, x):\n        self.q.append(x)\n\n    def pop(self):\n        return self.q.pop(0)\n\n    def is_empty(self):\n        return len(self.q) == 0\n\n    def peek(self):\n        return self.q[0]\n\n    def size(self):\n        return len(self.q)\n\n    def heap_sort(self):\n        heapify(self.q)\n        while not self.is_empty():\n            yield self.q.pop(0)\n        return\n\ndef heapify(q):\n    if len(q) == 0:\n        return\n    i = 0\n    while i < len(q):\n        if q[i].val < q[(i+1) % len(q)].val:\n            q[i], q[(i+1) % len(q)] = q[(i+1) % len(q)], q[i]\n            i += 1\n        else:\n            break\n\nif __name__ == '__main__':\n    q = HeapQueue()\n    q.push(5)\n    q.push(1)\n    q.push(3)\n    q.push(10)\n    q.push(7)\n    q.push(6)\n    q.push(9)\n\n    heapify(q)\n\n    for x in q.heap_sort():\n        print(x)\n\n    print(q.peek())"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param m, an integer\n    # @param B, a list of integers\n    # @param n, an integer\n    # @return a list of integers\n    def merge(self, A, m, B, n):\n        # Write your code here\n        res = []\n        heap = []\n        for i in range(m):\n            heap.append(A[i])\n        for i in range(n):\n            heapq.heappush(heap, B[i])\n        for i in range(m + n):\n            res.append(heapq.heappop(heap))\n        return res"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        heap = []\n        for i in xrange(m):\n            heapq.heappush(heap, (nums1[i], i))\n\n        for i in xrange(n):\n            if len(heap) == 0:\n                return []\n\n            heapq.heappush(heap, (nums2[i], i))\n\n        res = []\n        while len(heap) > 0:\n            res.append(heapq.heappop(heap)[1])\n\n        return res"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def merge(self, head1: List[TreeNode], head2: List[TreeNode], head3: List[TreeNode]) -> TreeNode:\n        \n        if not head1 or not head2 or not head3:\n            return None\n        \n        curr_head = TreeNode(head1[0].val)\n        \n        curr_head.left = self.merge(head1[1:], head2, head3)\n        curr_head.right = head3\n        \n        return curr_head"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @param nums3, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2, nums3):\n        heap = []\n        heapq.heapify(heap)\n        for i in nums1:\n            heap.append(i)\n            heapq.heappush(heap, i)\n        for i in nums2:\n            heap.append(i)\n            heapq.heappush(heap, i)\n        for i in nums3:\n            heap.append(i)\n            heapq.heappush(heap, i)\n        \n        result = []\n        while heap:\n            result.append(heapq.heappop(heap))\n        return result"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "import collections\nimport heapq\n\nclass SortedIterator(object):\n    def __init__(self, inputs):\n        self.heap = []\n        for input in inputs:\n            self.heap.append((input, input))\n        self.sorted_inputs = collections.deque()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.heap:\n            return self.heap.popleft()\n        return None\n\n    def append(self, input):\n        heapq.heappush(self.heap, (input, input))\n        self.sorted_inputs.append(input)\n\n    def __len__(self):\n        return len(self.sorted_inputs)\n\n    def __getitem__(self, index):\n        return self.sorted_inputs[index]"
    },
    {
      "rank": 88,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) <= 1:\n            return nums\n        \n        # heap queue\n        heapq.heapify(nums)\n        ans = []\n        \n        for i in xrange(len(nums)):\n            if nums[i] > nums[i-1]:\n                ans.append(nums[i])\n                heapq.heappop(nums)\n                \n        ans.append(nums[-1])\n        for i in xrange(len(nums)):\n            if nums[i] > nums[i-1]:\n                heapq.heappush(nums, nums[i])\n        return ans"
    },
    {
      "rank": 89,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        # write your code here\n        queue = []\n        for i in xrange(m):\n            queue.append([nums1[i], i])\n        for i in xrange(n):\n            queue.append([nums2[i], i])\n        heapq.heapify(queue)\n        ret = []\n        while queue:\n            # get smallest element from queue\n            (x, y) = heapq.heappop(queue)\n            ret.append(x)\n            if y + 1 < n:\n                heapq.heappush(queue, (nums2[y + 1], y + 1))\n        return ret"
    },
    {
      "rank": 90,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        p1 = l1\n        p2 = l2\n        head = None\n        while p1 and p2:\n            if p1.val < p2.val:\n                if not head:\n                    head = p1\n                p1 = p1.next\n            else:\n                if not head:\n                    head = p2\n                p2 = p2.next\n        if p1:\n            head.next = p1\n        if p2:\n            head.next = p2\n        return head\n\n\nclass Solution2(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        head = None\n        p1 = l1\n        p2 = l2\n        while p1 and p2:\n            if p1.val < p2.val:\n                if not head:\n                    head = p1\n                p1 = p1.next\n            else:\n                if not head:\n                    head = p2\n                p2 = p2.next\n        if p1:\n            head.next = p1\n        if p2:\n            head.next = p2\n        return head"
    },
    {
      "rank": 91,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integer\n    # @param nums2, a list of integer\n    # @return a list of integer\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        q1, q2 = [], []\n        for n1 in nums1:\n            if len(q1) == 0 or n1 < q1[-1]:\n                q1.append(n1)\n            else:\n                q2.append(n1)\n        for n2 in nums2:\n            if len(q2) == 0 or n2 < q2[-1]:\n                q2.append(n2)\n            else:\n                q1.append(n2)\n        return self.merge_sort(q1, q2)\n\n    def merge_sort(self, q1, q2):\n        if len(q1) == 0 or len(q2) == 0:\n            return []\n        if len(q1) < len(q2):\n            return self.merge_sort(q1, q2)\n        if len(q1) == 1:\n            return [q1[0]] + q2\n        if len(q2) == 1:\n            return q1 + [q2[0]]\n        return self.merge_sort(q1[:len(q1)/2], q2[:len(q2)/2]) + self.merge_sort(q1[len(q1)/2:], q2[len(q2)/2:])"
    },
    {
      "rank": 92,
      "score": 8.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        heapq.heappush(nums1, nums2[-1])\n        res = []\n        while nums1 or nums2:\n            if nums1 and nums2:\n                if nums1[0] <= nums2[0]:\n                    heapq.heappush(nums1, nums2[-1])\n                    nums2 = nums2[:-1]\n                else:\n                    heapq.heappush(nums2, nums1[-1])\n                    nums1 = nums1[:-1]\n            elif nums1:\n                heapq.heappush(nums1, nums2[-1])\n                nums2 = nums2[:-1]\n            else:\n                heapq.heappush(nums2, nums1[-1])\n                nums1 = nums1[:-1]\n        return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [4, 5, 1, 2]\n    nums2 = [6, 3, 1, 4]\n    print Solution().merge(nums1, nums2)"
    },
    {
      "rank": 93,
      "score": 8.0,
      "candidate": "import heapq\n\ndef merge_sorted(iterables, key=None):\n    \"\"\"\n    Merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.\n    :param iterables: a list of sorted inputs\n    :param key: a function to sort input iterables\n    :return: a single sorted iterator\n    \"\"\"\n    if key:\n        iterables = sorted(iterables, key=key)\n\n    heap = []\n    for iterable in iterables:\n        for item in iterable:\n            heapq.heappush(heap, item)\n    return iter(heap)"
    },
    {
      "rank": 94,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        h1 = []\n        h2 = []\n        \n        current1 = l1\n        current2 = l2\n        \n        while current1 and current2:\n            if current1.val < current2.val:\n                h1.append(current1)\n                current1 = current1.next\n            else:\n                h2.append(current2)\n                current2 = current2.next\n            \n        while current1:\n            h1.append(current1)\n            current1 = current1.next\n        \n        while current2:\n            h2.append(current2)\n            current2 = current2.next\n        \n        head = None\n        \n        for node in h1:\n            if head == None:\n                head = node\n            else:\n                head.next = node\n                \n        for node in h2:\n            if head == None:\n                head = node\n            else:\n                head.next = node\n                \n        return head"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2):\n        # write your code here\n        if not nums1 or not nums2:\n            return []\n        if len(nums1) < len(nums2):\n            return self.merge(nums2, nums1)\n        res = []\n        head = 0\n        tail = len(nums1)\n        while head < tail:\n            if nums1[head] < nums2[0]:\n                res.append(nums1[head])\n                head += 1\n            elif nums1[head] == nums2[0]:\n                res.append(nums1[head])\n                head += 1\n                res.append(nums2[0])\n                tail -= 1\n                nums2 = nums2[1:]\n            else:\n                res.append(nums2[0])\n                tail -= 1\n                nums2 = nums2[1:]\n        return res\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/merge-sorted-array/solution/\n#\nApproach #1: Two-pointer [Accepted]\nComplexity Analysis\nTime Complexity: O(n + m), where n is the number of elements in the first array and m is the number of elements in the second array.\nSpace Complexity: O(1)\n\n# 7ms 99.99%\nclass Solution {\n    public List<Integer> merge(List<Integer> nums1, List<Integer> nums2) {\n        if (nums1 == null || nums2 == null) return null;\n\n        int size = nums1.size() + nums2.size();\n        List<Integer> result = new ArrayList<>(size);"
    },
    {
      "rank": 96,
      "score": 1.5,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        Merge two sorted lists using heap queue\n        :param nums1: list\n        :param m: index of nums1\n        :param nums2: list\n        :param n: index of nums2\n        :return: merged list\n        \"\"\"\n        heap = [i for i in range(m+n)]\n        for i in range(m+n):\n            if i < m:\n                heap[i] = nums1[i]\n            elif i < m+n:\n                heap[i] = nums2[i-m]\n            else:\n                heap[i] = nums1[i-m-n]\n\n        i = 0\n        while i < n:\n            heap[i] = heap[0]\n            i += 1\n            heapq.heappop(heap)\n\n        return heap\n\n\nif __name__ == \"__main__\":\n    so = Solution()\n    nums1 = [1, 2, 3, 4, 5]\n    nums2 = [2, 3, 4, 5, 6]\n    nums3 = [1, 2, 3, 4, 5]\n    nums4 = [1, 2, 3, 4, 5]\n\n    print so.merge(nums1, 2, nums2, 4)"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def merge(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heapq.heappush(nums1, -nums2)\n        ret = []\n        while nums1 or nums2:\n            if nums1:\n                ret.append(nums1.pop())\n            elif nums2:\n                ret.append(nums2.pop())\n            else:\n                break\n            heapq.heappush(nums1, -ret[-1])\n        return ret\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5, 6]\n    nums3 = [7, 8, 9]\n    nums4 = [10, 11]\n    nums5 = [12, 13]\n    nums6 = [14, 15]\n    nums7 = [16, 17]\n    nums8 = [18, 19]\n    nums9 = [20, 21]\n    nums10 = [22, 23]\n    nums11 = [24, 25]\n    nums12 = [26, 27]\n    nums13 = [28, 29]\n    nums14 = [30, 31]\n    nums15 = [32, 33]\n    nums16 = [34, 35]\n    nums17 = [36, 37]\n    nums18 = [38, 39]\n    nums19 = [40, 41]\n    nums20 = [42, 43]\n    nums21 = [44, 45]\n    nums22 = [46, 47]\n    nums23 = [48, 49]\n    nums24 = [50, 51]\n    nums25 = [52, 53]\n    nums"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import heapq\n\nclass Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n\n    def merge(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            heapq.heappush(self.heap, (nums[left], left, nums[right]))\n            right -= 1\n            left += 1\n        return self.heap[0][2]\n\n    def heap(self, heap):\n        if len(heap) == 0:\n            return []\n        if len(heap) == 1:\n            return heap[0]\n        left = 0\n        right = len(heap) - 1\n        while left < right:\n            heapq.heappush(self.heap, (heap[left][0], left, heap[right][0]))\n            right -= 1\n            left += 1\n        return self.heap[0][2]\n\n    def merge1(self, nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            if nums[left] < nums[right]:\n                heapq.heappush(self.heap, (nums[left], left, nums[right]))\n                right -= 1\n            else:\n                heapq.heappush(self.heap, (nums[right], right, nums[left]))\n                left += 1\n        return self.heap[0][2]\n\n    def merge2(self, nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        left = 0\n        right = len(n"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def merge(self, iterators):\n        \"\"\"\n        :type iterators: List[Iterable[int]]\n        :rtype: Iterator[int]\n        \"\"\"\n        # heapq\n        # sorted_iterators = sorted(iterators, key=lambda x: x[0])\n        # sorted_iterators = [sorted(iterators[i], key=lambda x: x[1]) for i in range(len(iterators))]\n        # heapq.heapify(sorted_iterators)\n        # for i in range(len(sorted_iterators)):\n        #     for j in range(i, len(sorted_iterators)):\n        #         if sorted_iterators[i][0] <= sorted_iterators[j][0]:\n        #             heapq.heappop(sorted_iterators[i])\n        #             heapq.heappush(sorted_iterators[i], sorted_iterators[j][1])\n        # return sorted_iterators[0][0]\n        # binary_search\n        # sorted_iterators = sorted(iterators, key=lambda x: x[0])\n        # for i in range(len(sorted_iterators)):\n        #     for j in range(i, len(sorted_iterators)):\n        #         if sorted_iterators[i][0] <= sorted_iterators[j][0]:\n        #             heapq.heappop(sorted_iterators[i])\n        #             heapq.heappush(sorted_iterators[i], sorted_iterators[j][1])\n        # return sorted_iterators[0][0]\n        #\n        # binary_search\n        # sorted_iterators = sorted(iterators, key=lambda x: x[0])\n        # for i in range(len(sorted_iterators)):\n        #     for j in range(i, len(sorted_iterators)):\n        #         if sorted_iterators[i][0] <= sorted_iterators[j][0]:\n        #             heapq.heappop(sorted_iterators[i"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums1, a list of integers\n    # @param nums2, a list of integers\n    # @param nums3, a list of integers\n    # @return a list of integers\n    def merge(self, nums1, nums2, nums3):\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        \n        q = []\n        for i in range(len(nums1) + len(nums2) + len(nums3)):\n            if i >= len(nums1) and i >= len(nums2) and i >= len(nums3):\n                yield q.pop(0)\n            elif i >= len(nums1) and i >= len(nums2):\n                yield nums3[i - len(nums1)]\n            elif i >= len(nums2) and i >= len(nums3):\n                yield nums1[i - len(nums2)]\n            else:\n                yield nums2[i - len(nums1) - len(nums2)]\n        \n        for i in range(len(nums1)):\n            yield nums1[i]\n        for i in range(len(nums2)):\n            yield nums2[i]\n        for i in range(len(nums3)):\n            yield nums3[i]\n    \n    def merge_recursive(self, nums1, nums2, nums3):\n        if len(nums1) == 0 and len(nums2) == 0 and len(nums3) == 0:\n            return\n        if len(nums1) == 0 and len(nums2) == 0:\n            return nums3\n        if len(nums1) == 0:\n            return nums2 + nums3\n        if len(nums2) == 0:\n            return nums1 + nums3\n        if len(nums3) == 0:\n            return nums1 + nums2\n        \n        q = []\n        for i in range(len(nums"
    }
  ]
}