{
  "timestamp": "2025-09-14T20:56:26.505963",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 481,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        if not nums:\n            return -1\n        \n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/search-insert-position/\n# https://oj.leetcode.com/problems/search-in-rotated-sorted-array/\n# https://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/\n# https://oj.leetcode.com/problems/search-insert-position-ii/\n# https://oj.leetcode.com/problems/search-in-rotated-sorted-array-iii/\n# https://oj.leetcode.com/problems/search-insert-position-iii/\n# https://oj.leetcode.com/problems/search-in-sorted-array/\n# https://oj.leetcode.com/problems/search-insert-position/\n# https://oj.leetcode.com/problems/search-in-sorted-array-ii/\n# https://oj.leetcode.com/problems/search-insert-position-ii/\n# https://oj.leetcode.com/problems/search-in-sorted-array-iii/\n# https://oj.leetcode.com/problems/search-insert-position-iii/\n# https://oj.leetcode.com/problems/search-in-sorted-array/\n# https://oj.leetcode.com/problems/search-in-sorted-array-ii/\n# https://oj.leetcode.com/problems/search-in-sorted-array-iii/\n# https://oj.leetcode.com/problems/search-in-sorted-array/\n# https://oj.leetcode.com/problems/search-insert-position/\n# https://oj.leetcode.com/problems/search-in-sorted-array-ii/\n# https://oj.leetcode.com/problems/search-in-sorted-array-iii/\n# https://oj.leetcode.com/problems/search-in-sorted-array/\n# https://oj.leetcode.com/problems/search-in-rot"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    l = 0\n    r = len(arr)\n    while l < r:\n        mid = l + (r - l) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            l = mid + 1\n        else:\n            r = mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    arr = [3, 5, 7, 8, 10]\n    print(search(arr, 7))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def search(a, x):\n    left = 0\n    right = len(a) - 1\n    while left <= right:\n        mid = left + (right - left) / 2\n        if a[mid] == x:\n            return mid\n        elif a[mid] > x:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n\nif __name__ == '__main__':\n    a = [3, 2, 6, 7, 1, 4, 8, 5]\n    print(search(a, 6))\n    print(search(a, 7))\n    print(search(a, 4))\n    print(search(a, 2))\n    print(search(a, 1))\n    print(search(a, 3))\n    print(search(a, 8))\n    print(search(a, 5))\n    print(search(a, 9))\n    print(search(a, 0))\n    print(search(a, 10))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def binarySearch(self, nums, target):\n        n = len(nums)\n        l = 0\n        r = n-1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return -1\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(sol.binarySearch(nums, 8))\n    print(sol.binarySearch(nums, 3))\n    print(sol.binarySearch(nums, 10))\n    print(sol.binarySearch(nums, 1))\n    print(sol.binarySearch(nums, 5))\n    print(sol.binarySearch(nums, 7))\n    print(sol.binarySearch(nums, 0))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        if len(nums) == 1:\n            return 0 if nums[0] == target else -1\n        mid = len(nums) // 2\n        if target == nums[mid]:\n            return mid\n        if target < nums[0] or target > nums[-1]:\n            return -1\n        if target == nums[mid]:\n            return mid\n        if target < nums[0]:\n            return self.search(nums[:mid], target)\n        if target > nums[-1]:\n            return self.search(nums[mid:], target)\n        return self.search(nums[mid:], target) + mid\n\n# Note:\n# 1. Searching for an element in the array could be done in O(log n) time,\n# but this implementation uses binary search to achieve O(log n) time complexity.\n# 2. The time complexity of this algorithm is O(n)."
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binarySearch(nums, target, 0, len(nums) - 1)\n    \n    def binarySearch(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            elif nums[mid] > target:\n                right = mid - 1\n        return -1"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param target, an integer to be searched\n    # @return a boolean\n    def search(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not A:\n            return False\n        \n        if len(A) == 1:\n            return A[0] == target\n        \n        lo, hi = 0, len(A)-1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if A[mid] == target:\n                return True\n            elif A[mid] < target:\n                lo = mid + 1\n            elif A[mid] > target:\n                hi = mid - 1\n            \n        return False"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binarySearch(nums, target, 0, len(nums)-1)\n\n    def binarySearch(self, nums, target, left, right):\n        while left <= right:\n            mid = (left+right)/2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid+1\n            else:\n                right = mid-1\n        return -1"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "__author__ = 'Danyang'\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo, hi = 0, len(nums) - 1\n\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().search([1, 2, 3, 4, 5, 6, 7], 2)"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "\"\"\"\nDefinition for an interval.\n\"\"\"\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n    def __str__(self):\n        return str(self.start)+\"->\"+str(self.end)\n\nclass Solution:\n    \"\"\"\n    @param A: a list of Interval\n    @return: a list of Interval, the answer's elements are in lexicographical order\n    \"\"\"\n    def findInterval(self, A, target):\n        \"\"\"\n        :type A: List[Interval]\n        :type target: int\n        :rtype: List[Interval]\n        \"\"\"\n        left = 0\n        right = len(A) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if A[mid].start < target < A[mid].end:\n                right = mid - 1\n            elif A[mid].start > target:\n                left = mid + 1\n            else:\n                return A[mid]\n        return A[left]\n\nif __name__ == \"__main__\":\n    print Solution().findInterval([Interval(1, 3)], 1)"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        elif len(nums) == 1:\n            return nums[0] == target\n        elif nums[0] <= nums[len(nums) - 1]:\n            return self.search_range(nums, target, 0, len(nums) - 1)\n        elif nums[0] > nums[len(nums) - 1]:\n            return self.search_range(nums, target, 1, len(nums) - 1)\n        else:\n            return self.search_range(nums, target, 0, len(nums) - 1)\n\n    def search_range(self, nums, target, start, end):\n        if start > end:\n            return -1\n        mid = start + (end - start) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return self.search_range(nums, target, mid + 1, end)\n        else:\n            return self.search_range(nums, target, start, mid - 1)\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 6, 7, 8, 9]\n    print(Solution().search(nums, 8))\n    print(Solution().search(nums, 1))\n    print(Solution().search(nums, 2))\n    print(Solution().search(nums, 3))\n    print(Solution().search(nums, 4))\n    print(Solution().search(nums, 5))\n    print(Solution().search(nums, 6))\n    print(Solution().search(nums, 7))\n    print(Solution().search(nums, 8))\n    print(Solution().search(nums, 9))\n    print(Solution().search(nums, 10))\n    print(Solution().search(nums, 11))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "\"\"\"\nExample:\nGiven array = [1, 3, 5, 6],\n    1\n    3\n    5\n    6\n    8\n    10\n    12\n    14\n    15\n\nSearch 5 in array by using binary search:\n    -  [1, 3, 5, 6, 8, 10, 12, 14, 15]\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -  5\n    -"
    },
    {
      "rank": 15,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return -1"
    },
    {
      "rank": 16,
      "score": 8.0,
      "candidate": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search([1,2,3,4], 1)\n    print s.search([2,3,4,5], 3)\n    print s.search([1,2,3,4,5], 5)"
    },
    {
      "rank": 17,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_recur(nums, 0, len(nums) - 1, target)\n\n    def search_recur(self, nums, start, end, target):\n        if start > end:\n            return -1\n        mid = (start + end) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.search_recur(nums, start, mid - 1, target)\n        else:\n            return self.search_recur(nums, mid + 1, end, target)"
    },
    {
      "rank": 18,
      "score": 8.0,
      "candidate": "import random\n\ndef search(arr, value):\n    return binary_search(arr, value, 0, len(arr) - 1)\n\ndef binary_search(arr, value, start, end):\n    if start > end:\n        return -1\n    mid = start + (end - start) / 2\n    if arr[mid] < value:\n        return binary_search(arr, value, start, mid - 1)\n    elif arr[mid] > value:\n        return binary_search(arr, value, mid + 1, end)\n    else:\n        return mid\n\ndef main():\n    arr = [random.randint(1, 100) for i in range(100)]\n    print(search(arr, 5))\n    print(search(arr, -1))\n    print(search(arr, 1))\n    print(search(arr, 99))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "def binary_search(arr, target):\n    lo = 0\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n\n        if arr[mid] == target:\n            return mid\n\n        if arr[mid] < target:\n            lo = mid + 1\n\n        if arr[mid] > target:\n            hi = mid - 1\n\n    return -1"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, A, target):\n        if len(A) == 0:\n            return -1\n        \n        l = 0\n        r = len(A) - 1\n        \n        while l <= r:\n            mid = (l + r) / 2\n            if A[mid] == target:\n                return mid\n            \n            if A[mid] < A[r]:\n                if target <= A[l] and target >= A[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if target <= A[mid] and target >= A[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        \n        return -1\n\nif __name__ == \"__main__\":\n    A = [1, 2, 3, 4, 5]\n    target = 3\n    print Solution().search(A, target)"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "def search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    return search_aux(arr, target, 0, len(arr))\n\n\ndef search_aux(arr, target, start, end):\n    if start == end:\n        return start\n    if arr[start] < target:\n        return search_aux(arr, target, start + 1, end)\n    else:\n        return search_aux(arr, target, start, end - 1)\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 5, 7, 9, 11]\n    target = 3\n    print(search(arr, target))"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "def search(arr, value):\n    if len(arr) == 0:\n        return False\n\n    lo = 0\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        if arr[mid] == value:\n            return True\n        elif arr[mid] > value:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n\n    return False\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6]\n    print search(arr, 6)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "# The solution is based on the following code snippets:\n# https://www.youtube.com/watch?v=bB1hq1d9wZU\n# https://www.youtube.com/watch?v=bB1hq1d9wZU&index=5\n\ndef binary_search(arr, value):\n    \"\"\"\n    Search a given value in a given array.\n    :param arr: A list of integers.\n    :param value: A integer.\n    :return: The index of the element in the given array.\n    \"\"\"\n    # Step 1: find the lower bound of the array.\n    low = 0\n    high = len(arr) - 1\n\n    # Step 2: find the upper bound of the array.\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == value:\n            return mid\n        elif arr[mid] < value:\n            low = mid + 1\n        elif arr[mid] > value:\n            high = mid - 1\n\n    # Step 3: if the value is not found, return -1.\n    return -1\n\n\nif __name__ == '__main__':\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    print(binary_search(arr, 7))\n    print(binary_search(arr, 2))\n    print(binary_search(arr, 13))\n    print(binary_search(arr, 9))\n    print(binary_search(arr, 0))\n    print(binary_search(arr, 14))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1\n\nif __name__ == \"__main__\":\n    print Solution().search([1, 3, 5, 6], 1)"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print(Solution().search([1, 2, 3, 4, 5, 6], 3))"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binary_search(nums, target, 0, len(nums) - 1)\n\n    def binary_search(self, nums, target, low, high):\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_helper(nums, 0, len(nums) - 1, target)\n\n    def search_helper(self, nums, left, right, target):\n        if left > right:\n            return -1\n        mid = left + (right - left) / 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] < nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                return self.search_helper(nums, left, mid - 1, target)\n            return self.search_helper(nums, mid + 1, right, target)\n        if nums[mid] > target:\n            return self.search_helper(nums, mid + 1, right, target)\n        return self.search_helper(nums, left, mid - 1, target)\n\nif __name__ == '__main__':\n    nums = [1,3,5,6]\n    print Solution().search(nums, 6)\n    print Solution().search(nums, 1)\n    print Solution().search(nums, 7)\n    print Solution().search(nums, 4)"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def binarySearch(self, nums, target):\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = low + (high - low) / 2\n\n            if nums[mid] == target:\n                return mid\n\n            elif nums[mid] > target:\n                high = mid - 1\n\n            else:\n                low = mid + 1\n\n        return -1"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if target == arr[mid]:\n            return mid\n        elif target < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "class Solution:\n    # @param nums: a list of integers\n    # @param target: an integer\n    # @return: an integer\n    def binarySearch(self, nums, target):\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    print Solution().binarySearch([2, 5, 7, 9, 11, 13], 7)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        if len(nums) == 1:\n            return 0 if nums[0] == target else -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        \n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def search(arr, element):\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == element:\n            return mid\n        elif arr[mid] < element:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\nif __name__ == '__main__':\n    arr = [3, 2, 5, 1, 4, 6, 7]\n    print(search(arr, 4))"
    },
    {
      "rank": 35,
      "score": 3.0,
      "candidate": "import unittest\nimport timeit\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binary_search(nums, 0, len(nums) - 1, target)\n\n    def binary_search(self, nums, start, end, target):\n        if start > end:\n            return -1\n        mid = (start + end) / 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] > target:\n            return self.binary_search(nums, start, mid - 1, target)\n        return self.binary_search(nums, mid + 1, end, target)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-for-a-range/solution/\n\n# 1ms 100%\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int start = 0;\n        int end = nums.length - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] < target) start = mid + 1;\n            else end = mid - 1;\n        }\n        return -1;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int search(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > nums[low])"
    },
    {
      "rank": 36,
      "score": 2.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, A, target):\n        if A == []:\n            return -1\n        start = 0\n        end = len(A) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if A[mid] == target:\n                return mid\n            elif A[mid] < target:\n                start = mid + 1\n            elif A[mid] > target:\n                end = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search([1, 3, 5, 6], 7)"
    },
    {
      "rank": 37,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        l = 0\n        r = len(intervals) - 1\n        while l <= r:\n            mid = l + (r - l) / 2\n            if intervals[mid].end < target:\n                l = mid + 1\n            elif intervals[mid].start > target:\n                r = mid - 1\n            else:\n                return True\n        return False"
    },
    {
      "rank": 38,
      "score": 1.0,
      "candidate": "import collections\n\ndef search(arr, val):\n    return binary_search(arr, val, 0, len(arr) - 1)\n\ndef binary_search(arr, val, lo, hi):\n    if lo > hi:\n        return -1\n    mid = (lo + hi) / 2\n    if arr[mid] == val:\n        return mid\n    elif arr[mid] < val:\n        return binary_search(arr, val, mid + 1, hi)\n    else:\n        return binary_search(arr, val, lo, mid - 1)\n\ndef main():\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22, 24]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22, 24, 26]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22, 24, 26, 28]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22, 24, 26, 28, 30]\n    print(search(arr, 15))\n    arr = [1, 3, 5, 7, 9, 12, 14, 15, 17, 19, 20, 22, 24, 26, 28, 30, 32]\n    print(search(arr, 15))\n\nif __name"
    },
    {
      "rank": 39,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if len(intervals) == 0:\n            return False\n        if len(intervals) == 1:\n            return intervals[0].start <= target and target < intervals[0].end\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].start <= target and target < intervals[mid].end:\n                return True\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False"
    },
    {
      "rank": 40,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].end < target:\n                lo = mid + 1\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                return True\n        return False"
    },
    {
      "rank": 41,
      "score": 1.0,
      "candidate": "def binary_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    return binary_search_recursive(arr, target, 0, len(arr) - 1)\n\n\ndef binary_search_recursive(arr, target, start, end):\n    if start > end:\n        return -1\n    mid = (start + end) // 2\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, start, mid - 1)\n    else:\n        return binary_search_recursive(arr, target, mid + 1, end)"
    },
    {
      "rank": 42,
      "score": 1.0,
      "candidate": "def binary_search(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    lo, hi = 0, len(arr)-1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5]\n    print(binary_search(arr, 3))\n    print(binary_search(arr, 6))\n    print(binary_search(arr, -1))"
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "\"\"\"\nThe solution is like this:\n\ndef binary_search(array, target):\n    if len(array) == 0:\n        return -1\n    left = 0\n    right = len(array) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if array[mid] == target:\n            return mid\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"\"\"\n\n\"\"\"\nMy solution:\n\ndef binary_search(array, target):\n    if len(array) == 0:\n        return -1\n    left = 0\n    right = len(array) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if array[mid] == target:\n            return mid\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"\"\"\n\n\"\"\"\nMy solution:\n\ndef binary_search(array, target):\n    if len(array) == 0:\n        return -1\n    left = 0\n    right = len(array) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if array[mid] == target:\n            return mid\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"\"\"\n\n\"\"\"\nMy solution:\n\ndef binary_search(array, target):\n    if len(array) == 0:\n        return -1\n    left = 0\n    right = len(array) - 1\n    while left <= right:\n        mid = (left + right) / 2\n        if array[mid] == target:\n            return mid\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"\"\"\n\n\"\"\"\nMy solution:\n\ndef binary_search(array, target):\n    if len(array) == 0:\n        return -1\n    left = 0\n    right ="
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "import random\nimport bisect\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Do a binary search for the target\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        if nums[0] == target:\n            return 0\n        if nums[-1] == target:\n            return len(nums) - 1\n\n        i = bisect.bisect_left(nums, target)\n        j = bisect.bisect_right(nums, target)\n        if i == j:\n            return -1\n        return i if target < nums[i] else j\n\n\ndef main():\n    sol = Solution()\n    nums = [0, 1, 3, 4, 5, 6, 7]\n    print(sol.search(nums, 1))\n    print(sol.search(nums, 8))\n    print(sol.search(nums, 7))\n    print(sol.search(nums, 0))\n    print(sol.search(nums, 3))\n    print(sol.search(nums, 2))\n    print(sol.search(nums, 5))\n    print(sol.search(nums, 6))\n    print(sol.search(nums, 4))\n    print(sol.search(nums, 7))\n    print(sol.search(nums, 5))\n    print(sol.search(nums, 2))\n    print(sol.search(nums, 4))\n    print(sol.search(nums, 6))\n    print(sol.search(nums, 1))\n    print(sol.search(nums, 4))\n    print(sol.search(nums, 4))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "# -*- coding:utf-8 -*-\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        start, end = 0, len(nums)-1\n        while start<end:\n            mid = start + (end-start)/2\n            if nums[mid] < target:\n                start = mid+1\n            elif nums[mid] > target:\n                end = mid\n            else:\n                return mid\n        return -1\n\n\nif __name__ == '__main__':\n    print Solution().search([1, 2, 3, 3, 4, 5], 3)\n    print Solution().search([1, 2, 3, 3, 4, 5], 6)\n    print Solution().search([1, 2, 3, 3, 4, 5], -1)\n    print Solution().search([1, 2, 3, 3, 4, 5], 0)\n    print Solution().search([1, 2, 3, 3, 4, 5], 1)\n    print Solution().search([1, 2, 3, 3, 4, 5], 4)"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, A, target):\n        return self.binarySearch(A, 0, len(A)-1, target)\n\n    # use binary search to search an element in the array\n    def binarySearch(self, A, begin, end, target):\n        while begin <= end:\n            mid = (begin+end)/2\n            if A[mid] == target:\n                return mid\n            elif A[mid] < target:\n                begin = mid+1\n            else:\n                end = mid-1\n        return -1\n\n# test\nA = [1,2,3,4,5]\ntarget = 3\nob = Solution()\nprint(ob.search(A, target))\n\nA = [1,2,3,4,5,6,7,8,9,10]\ntarget = 5\nob = Solution()\nprint(ob.search(A, target))"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "# Your function should return 0 if the element is not found, and\n# return the index otherwise.\n#\n# Example:\n# Given nums = [4, 5, 6, 7, 0, 1, 2], and you are trying to find the value 6.\n#\n#     Your function should return the index 6, [4, 5, 6, 7, 0, 1, 2].\n#\n#     Example 2:\n#\n#     Given nums = [1, 3], and you are trying to find the value 3.\n#\n#     Your function should return the index 3, [1, 3].\n#\n#     Example 3:\n#\n#     Given nums = [1, 2], and you are trying to find the value 3.\n#\n#     Your function should return the index 0, [1, 2].\n\nclass Solution:\n    # @return a boolean\n    def search(self, nums, target):\n        # Write your code here\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return nums[0] == target\n        if nums[0] > nums[-1]:\n            return self.search(nums[:len(nums)/2], target) or self.search(nums[len(nums)/2:], target)\n        mid = len(nums) / 2\n        if nums[mid] > target:\n            return self.search(nums[:mid], target)\n        elif nums[mid] == target:\n            return True\n        else:\n            return self.search(nums[mid+1:], target)"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n\n    def search(self, nums, target):\n        return self.binarySearch(nums, target, 0, len(nums) - 1)\n\n    def binarySearch(self, nums, target, low, high):\n        if low == high:\n            return low\n        mid = low + (high - low) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return self.binarySearch(nums, target, low, mid - 1)\n        elif nums[mid] < target:\n            return self.binarySearch(nums, target, mid + 1, high)"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n    def __repr__(self):\n        return '[{}, {}]'.format(self.start, self.end)\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        if len(intervals) == 1:\n            return intervals[0].start <= target and target <= intervals[0].end\n        if intervals[0].start <= target and target <= intervals[-1].end:\n            return intervals[0].start <= target and target <= intervals[-1].end\n        if target <= intervals[0].start:\n            return self.search(intervals[:1], target)\n        if target > intervals[-1].end:\n            return self.search(intervals[-1::-1], target)\n        lo, hi = 0, len(intervals) - 1\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].start <= target and target <= intervals[mid].end:\n                return intervals[mid].start <= target and target <= intervals[mid].end\n            elif intervals[mid].start <= target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return intervals[lo].start <= target and target <= intervals[lo].end"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n        \n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].start <= target and target < intervals[mid].end:\n                return True\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            elif intervals[mid].end < target:\n                lo = mid + 1\n            else:\n                return False\n        return False"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l = 0\n        r = len(intervals) - 1\n        while l <= r:\n            m = (l + r) / 2\n            if intervals[m].end < target:\n                l = m + 1\n            elif intervals[m].start > target:\n                r = m - 1\n            else:\n                return m\n        return -1"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # the first and last element is the same\n        if len(intervals) == 0:\n            return -1\n\n        # binary search\n        i, j = 0, len(intervals) - 1\n        while i <= j:\n            mid = (i + j) // 2\n            if intervals[mid].end <= target:\n                i = mid + 1\n            else:\n                j = mid - 1\n        if intervals[i].start == target:\n            return i\n        else:\n            return -1"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param A, a list of integers\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, A, target):\n        if not A:\n            return -1\n        start = 0\n        end = len(A) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if A[mid] == target:\n                return mid\n            elif A[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        start, end = intervals[0].start, intervals[-1].end\n        if start == end:\n            return self.search_1(intervals, target, start)\n        mid = (start + end) // 2\n        if target <= mid:\n            return self.search(intervals[:mid], target)\n        else:\n            return self.search(intervals[mid+1:], target)\n\n    def search_1(self, intervals, target, start):\n        if intervals[0].start > target:\n            return -1\n        for i in range(len(intervals)):\n            if intervals[i].start <= start <= intervals[i].end:\n                return i\n            elif start < intervals[i].start:\n                return -1\n        return -1"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        if not intervals[0].start <= target <= intervals[0].end:\n            return -1\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].start <= target <= intervals[mid].end:\n                return mid\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return -1\n\n    def search2(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].start <= target <= intervals[mid].end:\n                return mid\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return -1\n\n\ns = Solution()\n\nprint s.search([Interval(0, 3), Interval(2, 6), Interval(7, 10)], 0)"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        return self.search_helper(intervals, target, 0, len(intervals) - 1)\n\n    def search_helper(self, intervals, target, start, end):\n        if start > end:\n            return -1\n\n        mid = (start + end) / 2\n        if intervals[mid].end < target:\n            return self.search_helper(intervals, target, start, mid - 1)\n        elif intervals[mid].start > target:\n            return self.search_helper(intervals, target, mid + 1, end)\n        else:\n            return mid"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # Use binary search to find the target.\n        # If found, return the first interval's start.\n        # If not found, return -1.\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if intervals[mid].end < target:\n                left = mid + 1\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                return intervals[mid].start\n        return -1\n\n    def search_2(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # Use binary search to find the target.\n        # If found, return the first interval's start.\n        # If not found, return -1.\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if intervals[mid].start <= target:\n                left = mid + 1\n            elif intervals[mid].end > target:\n                right = mid - 1\n            else:\n                return intervals[mid].start\n        return -1\n\n    def search_3(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # Use binary search to find the target.\n        # If found, return the first interval's start.\n        # If not found, return -1.\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if intervals[mid].start <= target:"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        # write your code here\n        return binary_search(nums, target, 0, len(nums) - 1)\n\n\ndef binary_search(nums, target, left, right):\n    if left > right:\n        return -1\n\n    middle = left + (right - left) / 2\n    if nums[middle] == target:\n        return middle\n\n    if nums[middle] < target:\n        return binary_search(nums, target, left, middle - 1)\n\n    return binary_search(nums, target, middle + 1, right)"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def search(self, head, target):\n        \"\"\"\n        :type head: ListNode\n        :type target: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return None\n        if head.val == target:\n            return head\n        if head.val > target:\n            return self.search(head.next, target)\n        start, end = 0, len(head.next) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if head.next[mid].val > target:\n                end = mid - 1\n            elif head.next[mid].val < target:\n                start = mid + 1\n            else:\n                return head.next[mid]\n        return None\n\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n    head.next.next.next.next.next = ListNode(6)\n    head.next.next.next.next.next.next = ListNode(7)\n    head.next.next.next.next.next.next.next = ListNode(8)\n    head.next.next.next.next.next.next.next.next = ListNode(9)\n    head.next.next.next.next.next.next.next.next.next = ListNode(10)\n    head.next.next.next.next.next.next.next.next.next.next = ListNode(11)\n    head.next.next.next.next.next.next.next.next.next.next.next = ListNode(12)\n    head.next.next.next.next.next.next.next.next.next.next.next.next = List"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/description/\n# time:O(n), space:O(1)\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print(Solution().search([1, 3, 5, 6], 3))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        \n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return -1\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 5, 7]\n    target = 3\n    print(Solution().search(nums, target))"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "import random\n\n# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        lo, hi = 0, len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].end < target:\n                lo = mid + 1\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                return True\n        return False\n\n    def search2(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        lo = 0\n        hi = len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].end < target:\n                lo = mid + 1\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                return True\n        return False\n\n    def search3(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        lo = 0\n        hi = len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if intervals[mid].end < target:\n                lo = mid + 1\n            elif intervals[mid].start > target:\n                hi = mid - 1\n            else:\n                return True\n        return False\n\n    def search4(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        lo = 0\n        hi = len(intervals) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "def search(arr, target):\n    if len(arr) == 0:\n        return False\n    if arr[0] > target:\n        return False\n    if arr[-1] < target:\n        return False\n    mid = (len(arr) - 1) / 2\n    if arr[mid] == target:\n        return True\n    if arr[mid] > target:\n        return False\n    if arr[mid] < target:\n        return True\n    return search(arr[:mid], target)\n\n\ndef test_search():\n    assert search([3, 4, 5, 6], 3)\n    assert search([1, 2, 3, 4, 5, 6], 3)\n    assert search([1, 2, 3, 4, 5, 6], 6)\n    assert search([1, 2, 3, 4, 5, 6], 0)\n    assert search([1, 2, 3, 4, 5, 6], 7)\n    assert search([1, 2, 3, 4, 5, 6], -1)\n    assert search([1, 2, 3, 4, 5, 6], -5)\n    assert search([1, 2, 3, 4, 5, 6], -6)\n    assert search([1, 2, 3, 4, 5, 6], -7)\n    assert search([1, 2, 3, 4, 5, 6], -8)\n    assert search([1, 2, 3, 4, 5, 6], -9)\n    assert search([1, 2, 3, 4, 5, 6], -10)\n\n\nif __name__ == \"__main__\":\n    test_search()"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "__author__ = 'Daniel'\n\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    assert Solution().search([1, 3, 5, 6], 5) == 1\n    assert Solution().search([1, 3, 5, 6], 7) == -1"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(intervals) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if intervals[mid].end < target:\n                low = mid + 1\n            elif intervals[mid].end > target:\n                high = mid - 1\n            else:\n                return mid\n        return -1"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l, r = 0, len(nums)-1\n        while l <= r:\n            m = l + (r-l)/2\n            if nums[m] == target:\n                return m\n            elif nums[m] > target:\n                r = m - 1\n            else:\n                l = m + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.search([2,3,5,6], 4)"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param intervals, a list of Interval\n    # @param e, an integer\n    # @return an integer\n    def search(self, intervals, e):\n        if not intervals:\n            return -1\n        lo = 0\n        hi = len(intervals) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if intervals[mid].end < e:\n                lo = mid + 1\n            elif intervals[mid].start > e:\n                hi = mid - 1\n            else:\n                return mid\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    intervals = [Interval(0, 2), Interval(3, 5), Interval(6, 10)]\n    print(sol.search(intervals, 3))\n    print(sol.search(intervals, 6))\n    print(sol.search(intervals, 0))\n    print(sol.search(intervals, 5))\n    print(sol.search(intervals, 7))"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_binary(nums, 0, len(nums) - 1, target)\n\n    def search_binary(self, nums, start, end, target):\n        if start > end:\n            return -1\n        if start == end:\n            return start\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.search_binary(nums, start, mid - 1, target)\n        else:\n            return self.search_binary(nums, mid + 1, end, target)"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/172794/Java-Binary-Search-Solution-with-O(logn)-Time-and-Space-Complexity\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_recursive(nums, target, 0, len(nums) - 1)\n\n    def search_recursive(self, nums, target, start, end):\n        if start > end:\n            return -1\n\n        mid = (start + end) / 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[mid] < target:\n            return self.search_recursive(nums, target, start, mid - 1)\n        else:\n            return self.search_recursive(nums, target, mid + 1, end)"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "import unittest\nimport timeit\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought:\n\n# 1ms 100%\nclass Solution {\n    public int search(int[] nums, int target) {\n        return binarySearch(nums, target);\n    }\n\n    private int binarySearch(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n}\n\n# 1ms 100"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def searchBinary(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if root is None:\n            return False\n        if root.val == target:\n            return True\n        elif root.val < target:\n            return self.searchBinary(root.left, target)\n        else:\n            return self.searchBinary(root.right, target)"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "\"\"\"\nThis is a good reference for binary search:\nhttp://www.geeksforgeeks.org/binary-search-algorithm-set-1-searching-an-array/\n\"\"\"\n\nimport unittest\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            elif nums[mid] > target:\n                hi = mid - 1\n        return -1\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/search-in-rotated-sorted-array/solution/\n# 1ms 100%\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        return binarySearch(nums, target);\n    }\n\n    public int binarySearch(int[] nums, int target) {\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        return -1;\n    }\n}\n'''"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    # @param A, a list of integer\n    # @param target, an integer to be searched\n    # @return an integer\n    def search(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.binary_search(A, 0, len(A) - 1, target)\n        \n    def binary_search(self, A, start, end, target):\n        if start > end:\n            return -1\n        mid = start + (end - start) / 2\n        if A[mid] == target:\n            return mid\n        if A[mid] < target:\n            return self.binary_search(A, mid + 1, end, target)\n        else:\n            return self.binary_search(A, start, mid - 1, target)"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# Your function should return -1 if the element is not found, otherwise return the index of the element.\n# The index should be guaranteed to be within the range of [0, len(arr)-1].\n# You can assume that the given array is sorted in ascending order.\n\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def binarySearch(self, nums, target):\n        if not nums:\n            return -1\n\n        low, high = 0, len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return -1\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3]\n    print(Solution().binarySearch(nums, 4))"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "# Definition for an interval.\nclass Interval:\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].end < target:\n                left = mid + 1\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                return mid\n        return -1"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        if not nums or len(nums) < 1:\n            return -1\n        if len(nums) == 1:\n            return nums[0] == target\n        if nums[0] > nums[len(nums) - 1]:\n            return -1\n        mid = int((len(nums) - 1) / 2)\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            return self.search(nums[:mid], target)\n        else:\n            return self.search(nums[mid + 1:], target)\n\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.search([1, 3, 5, 6], 7)\n    print s.search([1, 3, 5, 6], 1)\n    print s.search([1, 3, 5, 6], 2)"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        if nums[0] < target:\n            return self.search(nums[1:], target)\n        if nums[-1] > target:\n            return self.search(nums[:-1], target)\n        return self.binary_search(nums, target)\n    \n    def binary_search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @param val, a value to be searched\n    # @return a boolean\n    def search(self, root, val):\n        if root is None:\n            return False\n        if root.val == val:\n            return True\n        if root.val < val:\n            return self.search(root.right, val)\n        else:\n            return self.search(root.left, val)\n\n\nif __name__ == '__main__':\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.left.left.right = TreeNode(6)\n    root.left.left.left = TreeNode(7)\n    root.left.left.right.right = TreeNode(8)\n    root.left.right.left = TreeNode(9)\n    root.left.right.right = TreeNode(10)\n    root.left.right.right.right = TreeNode(11)\n    root.left.right.right.right.right = TreeNode(12)\n    root.left.right.right.right.right.right = TreeNode(13)\n    root.right.left = TreeNode(14)\n    root.right.left.left = TreeNode(15)\n    root.right.left.left.left = TreeNode(16)\n    root.right.left.right = TreeNode(17)\n    root.right.left.right.right = TreeNode(18)\n    root.right.right.left = TreeNode(19)\n    root.right.right.right = TreeNode(20)\n    root.right.right.right.right = TreeNode(21)\n    root.right.right.right.right.right = TreeNode(22)\n    root.right.right.right.right."
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "# Your function should return the index of the element that is 'x' in the given array.\n# If the element is not present, return -1.\n#\n# Example 1:\n# Input: nums = [1,5,6], x = 6\n# Output: 2\n# Example 2:\n# Input: nums = [1,2,3,4,5], x = 2\n# Output: 1\n# Note:\n# You may assume that the array does not change.\n# You can assume that the given x is always valid, that is, x is between [0, n) where n is the size of the array.\n\nclass Solution(object):\n    def search(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == x:\n                return mid\n            elif nums[mid] > x:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    assert Solution().search([1, 5, 6], 6) == 2\n    assert Solution().search([1, 2, 3, 4, 5], 2) == 1"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO: write your code here\n        if not intervals or not intervals[0].end:\n            return -1\n\n        low, high = 0, len(intervals) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if intervals[mid].end <= target:\n                low = mid + 1\n            elif intervals[mid].end > target:\n                high = mid - 1\n            else:\n                return mid\n        return -1"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_helper(nums, target, 0, len(nums)-1)\n\n    def search_helper(self, nums, target, start, end):\n        if start > end:\n            return -1\n\n        mid = (start + end) / 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return self.search_helper(nums, target, mid+1, end)\n        elif nums[mid] < target:\n            return self.search_helper(nums, target, start, mid-1)"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "def search(arr, element, left, right):\n    if left > right:\n        return False\n\n    mid = (left + right) // 2\n\n    if arr[mid] == element:\n        return True\n\n    if arr[mid] < element:\n        return search(arr, element, mid + 1, right)\n    else:\n        return search(arr, element, left, mid - 1)\n\n\ndef search_sorted(arr, element):\n    if len(arr) == 0:\n        return False\n    if arr[0] < element:\n        return search_sorted(arr[1:], element)\n    elif arr[-1] < element:\n        return search_sorted(arr[:-1], element)\n    else:\n        return arr[0] == element\n\ndef search_binary_search(arr, element):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == element:\n            return True\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef search_binary_search_sorted(arr, element):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == element:\n            return True\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef search_linear_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return True\n    return False\n\ndef search_linear_search_sorted(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return True\n    return False\n\ndef main():\n    arr = [1, 2, 3, 4, 5]\n    print(search(arr, 1, 0, len(arr) - 1))\n    print(search(arr, 6, 0, len("
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # TODO\n        return 0"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_internal(intervals, target, 0, len(intervals) - 1)\n    \n    def search_internal(self, intervals, target, start, end):\n        if start > end:\n            return -1\n        \n        mid = (start + end) / 2\n        \n        if intervals[mid].end <= target:\n            return self.search_internal(intervals, target, start, mid - 1)\n        elif intervals[mid].start > target:\n            return self.search_internal(intervals, target, mid + 1, end)\n        else:\n            return mid"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "\"\"\"\nExample:\nGiven nums = [4, 5, 6, 7], target = 7,\nreturn the index is 2, or the index is 1, or the index is -1.\n\nNote:\nYou may assume all elements in the array are non-negative.\n\"\"\"\n\nclass Solution:\n    # @param nums: A list of integers\n    # @param target: An integer\n    # @return: An integer\n    def binarySearch(self, nums, target):\n        start = 0\n        end = len(nums) - 1\n\n        while start <= end:\n            mid = (start + end) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [4, 5, 6, 7]\n    target = 7\n    print(sol.binarySearch(nums, target))"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return -1\n        \n        mid = 0\n        while mid < len(nums):\n            if nums[mid] == target:\n                return mid\n            elif target < nums[mid]:\n                mid += 1\n            else:\n                mid -= 1\n        \n        return mid"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def search(self, root: TreeNode, target: int) -> bool:\n        \"\"\"\n        @param root The root of binary tree.\n        @param target The target to be searched.\n        @return True if found the target, False otherwise.\n        \"\"\"\n        if not root:\n            return False\n        if root.val == target:\n            return True\n        if root.val < target:\n            return self.search(root.left, target)\n        return self.search(root.right, target)"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param nums: A list of integer\n    # @param target: An integer to be searched\n    # @return: An integer\n    def binarySearch(self, nums, target):\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1\n\n    def binarySearch2(self, nums, target):\n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = (start + end) / 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    print Solution().binarySearch([1, 3, 5, 6, 7], 3)\n    print Solution().binarySearch([1, 3, 5, 6, 7], 7)\n    print Solution().binarySearch([1, 3, 5, 6, 7], 8)\n    print Solution().binarySearch([1, 3, 5, 6, 7], 0)\n    print Solution().binarySearch([1, 3, 5, 6, 7], -1)"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def searchBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        if root.val == val:\n            return True\n        if root.val < val:\n            return self.searchBST(root.left, val)\n        else:\n            return self.searchBST(root.right, val)"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import unittest\n\nfrom search_in_rotated_sorted_array import search_in_rotated_sorted_array\n\n\nclass TestSearchInRotatedSortedArray(unittest.TestCase):\n    def test_search_in_rotated_sorted_array(self):\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 2), False)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 1), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 9), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], -1), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 10), False)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 5), True)\n        self.assertEqual(search_in_rotated_sorted_array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 6), True)\n        self.assertEqual(search_in_rotated_sorted_array(["
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid].end <= target:\n                left = mid + 1\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                return mid\n        return -1"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return -1\n        start, end = intervals[0].start, intervals[0].end\n        while start < end:\n            mid = start + (end - start) / 2\n            if target < mid:\n                end = mid\n            else:\n                start = mid + 1\n        return start"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/164486/Python-solution-with-explanation\n# In the sorted array, the elements are numbered from 0 to n-1.\n# The element searched for is at position i.\n# It is guaranteed that the array is sorted in ascending order.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val):\n#         self.val = val\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def search(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        if root.val == val:\n            return True\n        elif root.val < val:\n            return self.search(root.right, val)\n        else:\n            return self.search(root.left, val)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/binary-search/\n\nclass Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def binarySearch(self, nums, target):\n        lo = 0\n        hi = len(nums) - 1\n\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n\n        return -1"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def helper(start, end):\n            mid = (start + end) / 2\n            if mid == start or mid == end:\n                return mid\n            if nums[mid] < target:\n                return helper(start, mid - 1)\n            if nums[mid] > target:\n                return helper(mid + 1, end)\n        return helper(0, len(nums) - 1)\n\n\nif __name__ == '__main__':\n    print(Solution().search([1, 3, 5, 6], 2))\n    print(Solution().search([1, 3, 5, 6], 1))\n    print(Solution().search([1, 3, 5, 6], 7))"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "import collections\n\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Binary search\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.search_helper(nums, target, 0, len(nums))\n\n    def search_helper(self, nums, target, low, high):\n        if low >= high:\n            return -1\n        mid = low + (high - low) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return self.search_helper(nums, target, low, mid)\n        else:\n            return self.search_helper(nums, target, mid + 1, high)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums = [3, 4, 5, 6, 7]\n    print(sol.search(nums, 5))\n    print(sol.search(nums, 4))\n    print(sol.search(nums, 3))\n    print(sol.search(nums, 7))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for an interval.\n# class Interval:\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def search(self, intervals, target):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not intervals:\n            return False\n\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if intervals[mid].start <= target and target <= intervals[mid].end:\n                return True\n            elif intervals[mid].start > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return False\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    intervals = [Interval(1, 3), Interval(5, 6), Interval(8, 10)]\n    assert sol.search(intervals, 1) == True\n    assert sol.search(intervals, 7) == False"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import collections\n\ndef search(arr, target):\n    if not arr:\n        return None\n    if len(arr) == 1:\n        return arr[0] == target\n    if arr[0] > target:\n        return search(arr[1::], target)\n    if arr[-1] < target:\n        return search(arr[:-1], target)\n    return arr[0] == target\n\n# Your search algorithm should be in the form of a function that takes as input\n# an array of N elements and returns the index of the element you're looking for.\n\n# Test cases\n\n# arr = [4, 5, 6, 7, 8, 9, 10]\n# target = 8\n# Result: 4\n# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# target = 8\n# Result: None\n# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# target = 10\n# Result: None\n# arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# target = 8\n# Result: 4\n\narr = [4, 5, 6, 7, 8, 9, 10]\ntarget = 8\nprint(search(arr, target))\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 8\nprint(search(arr, target))\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 10\nprint(search(arr, target))\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 8\nprint(search(arr, target))\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 8\nprint(search(arr, target))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @param target: An integer to be searched\n    @return: A boolean\n    \"\"\"\n    def search(self, nums, target):\n        if not nums or len(nums) == 0:\n            return False\n        return self.search_recursive(nums, target)\n\n    def search_recursive(self, nums, target):\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) / 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return False"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "# https://leetcode.com/problems/search-in-rotated-sorted-array/description/\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return bisect.bisect_left(nums, target)\n\nclass Solution2(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return bisect.bisect_left(nums, target)\n\nclass Solution3(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return bisect.bisect_left(nums, target)\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().search(nums, 4))\n    print(Solution2().search(nums, 4))\n    print(Solution3().search(nums, 4))\n    print(Solution3().search(nums, -1))\n    print(Solution3().search(nums, 5))\n    print(Solution3().search(nums, 6))"
    }
  ]
}