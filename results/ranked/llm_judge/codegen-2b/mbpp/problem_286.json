{
  "timestamp": "2025-09-14T19:29:27.756787",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 286,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def flatten(self, root: Node) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        # if there is only one child, return it.\n        if root.left is None and root.right is None:\n            return\n\n        # if there are multiple children,\n        # 1. split the root into two subtrees,\n        # 2. recursively flatten the left subtree,\n        # 3. recursively flatten the right subtree,\n        # 4. merge the two subtrees together.\n        # The only thing to note is that we do not need to\n        # consider the case where the root is a leaf.\n        # The right subtree can be empty, and the left subtree\n        # can be empty, too.\n        root.left, root.right = root.right, root.left\n        self.flatten(root.left)\n        self.flatten(root.right)\n        root.left, root.right = root.right, root.left"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flattenRecu(nestedList, [])\n\n    def flattenRecu(self, nestedList, result):\n        if len(nestedList) == 0:\n            return result\n        for i in range(len(nestedList)):\n            self.flattenRecu(nestedList[i], result)\n        return result"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def flatten(self, root):\n        if root is None:\n            return\n\n        if root.left is None and root.right is None:\n            return root.val\n\n        if root.left is not None:\n            self.flatten(root.left)\n\n        if root.right is not None:\n            self.flatten(root.right)\n\n        root.left = None\n        root.right = None\n\n        if root.val is not None:\n            self.flatten(root.val)\n\nif __name__ == '__main__':\n    s = Solution()\n    root = Node(None, Node(1, Node(2), Node(3)), Node(4, Node(5), Node(6)))\n    root.left = Node(7, Node(8, Node(9), Node(10)), Node(11, Node(12), Node(13)))\n    root.right = Node(14, Node(15, Node(16), Node(17)), Node(18, Node(19), Node(20)))\n    print s.flatten(root)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        if root is None:\n            return result\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.left is None and node.right is None:\n                result.append(node.val)\n            else:\n                if node.left:\n                    stack.append(node.left)\n                if node.right:\n                    stack.append(node.right)\n        return result"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n#\n# class Solution:\n#     # @param head, a ListNode\n#     # @return a ListNode\n#     def flatten(self, head):\n#         if not head or not head.next:\n#             return head\n#         p = head\n#         while p.next:\n#             p = p.next\n#             while p.next:\n#                 p.next = p.next.next\n#\n#         return head\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a ListNode\n    def flatten(self, head):\n        if not head or not head.next:\n            return head\n        p = head\n        while p.next:\n            p = p.next\n            while p.next:\n                p.next = p.next.next\n        return head\n\nif __name__ == '__main__':\n    s = Solution()\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8, ListNode(9))))))))))\n    print s.flatten(head)"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n\n        return self.flatten_recur(nestedList, 0)\n\n    def flatten_recur(self, nestedList, currentIndex):\n        if not nestedList:\n            return []\n\n        if len(nestedList) == 1:\n            return nestedList[0]\n\n        result = []\n        for i in range(currentIndex, len(nestedList)):\n            result += self.flatten_recur(nestedList[i], currentIndex + 1)\n\n        return result"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children if children else []\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        res = []\n        self.dfs(root, res)\n        return res\n\n    def dfs(self, root, res):\n        if not root:\n            return\n        res.append(root.val)\n        for ch in root.children:\n            self.dfs(ch, res)\n\nif __name__ == '__main__':\n    s = Solution()\n    root = Node(1, [Node(2, [Node(3, [Node(4, [])]), Node(5, [])]), Node(6, [])])\n    print s.flatten(root)"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def flatten_recursive(lst):\n            if len(lst) == 0:\n                return []\n            flatten_lst = []\n            for el in lst:\n                if isinstance(el, list):\n                    flatten_lst += flatten_recursive(el)\n                else:\n                    flatten_lst.append(el)\n            return flatten_lst\n        return flatten_recursive(nestedList)"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param head, a list node\n    # @return a list node\n    def flatten(self, head):\n        if not head:\n            return None\n        cur, pre = head, None\n        while cur:\n            cur = cur.next\n            while cur and cur.next:\n                cur.next = cur.next.next\n                cur = cur.next\n            pre.next = cur\n            pre = cur\n        return head"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param root, a tree node\n    # @return a list of strings\n    def flatten(self, root):\n        if root is None:\n            return []\n        res = []\n        self.flatten(root, res)\n        return res\n        \n    def flatten(self, node, res):\n        if node.right is None:\n            res.append(node.val)\n        else:\n            self.flatten(node.right, res)\n            self.flatten(node.left, res)\n\nroot = [1, [2, [3, 4], 5], 6]\nprint Solution().flatten(root)"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n    def flatten(self, head):\n        if head == None:\n            return None\n        if head.next == None:\n            return head\n        head1 = head\n        head2 = head\n        while head2!= None:\n            head1 = head1.next\n            head2 = head2.next.next\n        head1.next = None\n        head = head1\n        while head.next!= None:\n            head = head.next\n        return head\n\nif __name__ == '__main__':\n    n1 = ListNode(1)\n    n2 = ListNode(2)\n    n3 = ListNode(3)\n    n4 = ListNode(4)\n    n5 = ListNode(5)\n    n6 = ListNode(6)\n    n7 = ListNode(7)\n    n8 = ListNode(8)\n    n9 = ListNode(9)\n    n10 = ListNode(10)\n    n11 = ListNode(11)\n    n12 = ListNode(12)\n    n13 = ListNode(13)\n    n14 = ListNode(14)\n    n15 = ListNode(15)\n    n16 = ListNode(16)\n    n17 = ListNode(17)\n    n18 = ListNode(18)\n    n19 = ListNode(19)\n    n20 = ListNode(20)\n    n21 = ListNode(21)\n    n22 = ListNode(22)\n    n23 = ListNode(23)\n    n24 = ListNode(24)\n    n25 = ListNode(25)\n    n26 = ListNode(26)\n    n27 = ListNode(27)\n    n28 = ListNode(28)\n    n29 = ListNode(29)\n    n30 = ListNode(30)\n    n31 = ListNode(31)\n    n32 = ListNode(32)\n    n33 = ListNode(33"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "import collections\n\nclass Solution:\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[Any]]\n        :rtype: List[Any]\n        \"\"\"\n        if not nestedList:\n            return []\n        result = []\n        stack = collections.deque()\n        for item in nestedList:\n            if isinstance(item, list):\n                stack.append(item)\n            else:\n                while stack and stack[-1]!= item:\n                    result.append(stack.pop())\n                stack.pop()\n                result.append(item)\n        while stack:\n            result.append(stack.pop())\n        return result"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n        else:\n            current = head\n            previous = None\n            next = head.next\n            while next:\n                current.next = next.next\n                current = current.next\n                next = next.next\n            current.next = None\n            return head"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Write your code here\n        if not nestedList:\n            return []\n        result = []\n        for item in nestedList:\n            if isinstance(item, list):\n                result += self.flatten(item)\n            else:\n                result.append(item)\n        return result"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param nestedList a list of lists of lists\n    # @return a list of lists\n    def flatten(self, nestedList):\n        if not nestedList:\n            return []\n\n        result = []\n        stack = []\n        for item in nestedList:\n            if isinstance(item, list):\n                stack.append(item)\n            else:\n                while stack:\n                    result.append(stack.pop())\n\n        return result"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a tree node\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        if not root:\n            return root\n        if not root.left and not root.right:\n            return root\n        \n        if root.left:\n            root.left = self.flatten(root.left)\n        if root.right:\n            root.right = self.flatten(root.right)\n        return root"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\nclass Solution:\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        if not head:\n            return None\n        node = head\n        while node:\n            if node.left:\n                node.left = self.flatten(node.left)\n            if node.right:\n                node.right = self.flatten(node.right)\n            node = node.next\n        return head"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if not head or not head.next:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        while slow.next:\n            fast = slow\n            slow = slow.next\n        fast.next = None\n        return head"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "from collections import deque\n\ndef flatten(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten(i) for i in iterable]\n\ndef flatten_recursive(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten_recursive(i) for i in iterable]\n\ndef flatten_recursive_2(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten_recursive_2(i) for i in iterable]\n\ndef flatten_recursive_3(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten_recursive_3(i) for i in iterable]\n\ndef flatten_recursive_4(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten_recursive_4(i) for i in iterable]\n\ndef flatten_recursive_5(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original\n    list, recursively.\n    \"\"\"\n    if not isinstance(iterable, list):\n        return iterable\n    return [flatten_recursive_5(i) for i in iterable]\n\ndef flatten_recursive_6(iterable):\n    \"\"\"\n    Given a list, returns a new list containing all elements of the original"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n    def __repr__(self):\n        return \"Node(%s, %s)\" % (self.val, self.children)\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            cur = stack.pop()\n            res.append(cur.val)\n            if cur.children:\n                stack.extend(cur.children)\n        return res\n\n\nif __name__ == '__main__':\n    s = Solution()\n    root = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))));\n    root = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))));\n    print s.flatten(root)"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "# Definition for a node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        if not root.children:\n            return [root.val]\n        result = []\n        stack = [root]\n        while stack:\n            node = stack.pop(0)\n            result.append(node.val)\n            if node.children:\n                stack.extend(node.children)\n        return result"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if head == None:\n            return None\n        \n        if head.next == None:\n            return head\n        \n        pre = head\n        cur = head.next\n        \n        while cur.next:\n            pre.next = cur\n            pre = cur\n            cur = cur.next\n            \n        pre.next = None\n        return head"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children else []\n\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of strings\n    def flatten(self, root):\n        if not root:\n            return []\n        \n        queue = [root]\n        \n        res = []\n        \n        while queue:\n            node = queue.pop(0)\n            if not node.children:\n                res.append(node.val)\n            else:\n                queue.extend(node.children)\n        \n        return res"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param nestedList a list of lists\n    # @return a list of lists\n    def flatten(self, nestedList):\n        if not nestedList:\n            return []\n        return self.flattenRecursive(nestedList, [])\n\n    def flattenRecursive(self, nestedList, result):\n        if not nestedList:\n            return result\n        for item in nestedList:\n            if isinstance(item, list):\n                result.append(item)\n                self.flattenRecursive(item, result)\n        return result"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "def flatten(l):\n    \"\"\"\n    >>> flatten([[1,2],3,[4,5,6]])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[1,2],3,[[4,5,6]]])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[[1,2],3],[[4,5,6]]])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[[[[1,2],3],[[4,5,6]]]]])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([1,2,3,4,5,6])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[[[[[[1,2],3],[[4,5,6]]]]]]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if type(l) is not list:\n        return l\n    if not l:\n        return l\n    else:\n        return [flatten(i) for i in l]\n\ndef test():\n    assert flatten([1,2,3]) == [1, 2, 3]\n    assert flatten([[1,2],3,[4,5,6]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([[[1,2],3],[[4,5,6]]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([[[[[1,2],3],[[4,5,6]]]]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([1,2,3,4,5,6]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([[[[[[[1,2],3],[[4,5,6]]]]]]]) == [1, 2, 3, 4, 5, 6]\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flatten(self, root: 'Node') -> 'Node':\n        if root is None:\n            return None\n        if root.left is None and root.right is None:\n            return root\n        if root.left is None:\n            return self.flatten(root.right)\n        if root.right is None:\n            return self.flatten(root.left)\n        return self.flatten(root.left) + self.flatten(root.right)\n\n\nif __name__ == '__main__':\n    root = Node(1, Node(2, Node(3), Node(4)), Node(5, Node(6)))\n    print(Solution().flatten(root))"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        curr = head\n        while curr:\n            tmp = curr.next\n            curr.next = None\n            curr = tmp\n        return head"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "def flatten(x):\n    if not x: return x\n    return [flatten(y) for y in x]\n\nif __name__ == '__main__':\n    lst = [[[1, 2, 3], [4, 5], [6], [7, 8, 9]]]\n    print(flatten(lst))"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return root\n        \n        if root.left:\n            root.left = self.flatten(root.left)\n        \n        if root.right:\n            root.right = self.flatten(root.right)\n        \n        if root.left and root.right:\n            return root\n        else:\n            return root.val"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "class Node(object):\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children if children else []\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        stack = []\n        result = []\n        self.flattenHelper(stack, root, result)\n        return result\n\n    def flattenHelper(self, stack, root, result):\n        if root.children is None or len(root.children) == 0:\n            stack.append(root)\n            return\n        for child in root.children:\n            self.flattenHelper(stack, child, result)\n        stack.pop()\n\nif __name__ == '__main__':\n    root = Node(1, [Node(2), Node(3), Node(4), Node(5, [Node(6), Node(7)]), Node(8, [Node(9), Node(10)]), Node(11, [Node(12)]), Node(13, [Node(14)]), Node(15, [Node(16), Node(17)]), Node(18, [Node(19)]), Node(20, [Node(21)]), Node(22, [Node(23)]), Node(24, [Node(25), Node(26), Node(27)]), Node(28), Node(29, [Node(30)]), Node(31), Node(32)]).children\n    root = Node(1, [Node(2, [Node(3, [Node(4, [Node(5, [Node(6, [Node(7, [Node(8, [Node(9, [Node(10, [Node(11, [Node(12, [Node(13, [Node(14, [Node(15, [Node(16, [Node(17, [Node(18, [Node(19, [Node(20, [Node(21, [Node(22, [Node(23, [Node(24, [Node(25, [Node(26, [Node(27, [Node(28, [Node(29, [Node(30, [Node(31, [Node(32, [Node"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        stack = []\n        for i in nestedList:\n            while len(stack) > 0 and i > stack[-1]:\n                stack.pop()\n            stack.append(i)\n        result = []\n        while len(stack) > 0:\n            result.append(stack.pop())\n        return result"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\nclass Solution:\n    def flatten(self, root: Node) -> None:\n        \"\"\"\n        :type root: Node\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        stack = []\n        stack.append(root)\n        while stack:\n            node = stack.pop()\n            if node.children:\n                stack.extend(node.children)\n            else:\n                node.children = stack\n                stack = []"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "class Solution:\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def flatten_recursive(l, i):\n            if i >= len(l):\n                return l\n            l[i] = ','.join(flatten_recursive(x, i+1) for x in l[i])\n            return l\n\n        return flatten_recursive([], 0)"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of flattened tree node\n    def flatten(self, root):\n        if root is None:\n            return []\n        if root.left is None and root.right is None:\n            return [root.val]\n        if root.left is not None:\n            self.flatten(root.left)\n        if root.right is not None:\n            self.flatten(root.right)\n        return [root.val] + self.flatten(root.left) + self.flatten(root.right)"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "# Definition for a nested list:\n# class NestedListNode:\n#     def __init__(self, val, next=None):\n#         self.val = val\n#         self.next = next\n\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: NestedListNode\n        :rtype: NestedListNode\n        \"\"\"\n        if not head:\n            return None\n\n        def _flatten(head):\n            if not head:\n                return None\n            head_list = []\n            while head:\n                head_list.append(head.val)\n                head = head.next\n            return head_list\n\n        def _flatten_rec(head, result):\n            if not head:\n                return result\n            _flatten_rec(head.next, result)\n            result.append(head.val)\n            return result\n\n        return _flatten_rec(head, [])\n\n\nif __name__ == \"__main__\":\n    assert Solution().flatten([[1, 2], [3, [4, 5], 6], [7, [8, 9], [10, 11], 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    assert Solution().flatten([]) == []\n    assert Solution().flatten([[]]) == []\n    assert Solution().flatten([1]) == [1]"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        result = []\n        self.flatten_helper(result, root)\n        return result\n\n    def flatten_helper(self, result, root):\n        if not root.children:\n            result.append(root.val)\n        else:\n            for child in root.children:\n                self.flatten_helper(result, child)\n\nif __name__ == '__main__':\n    print Solution().flatten([1, [2, 3], [4]])\n    print Solution().flatten([1, [2, [3, [4]]]])"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        return self.flatten_recur(root)\n\n    def flatten_recur(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        if root.children:\n            return self.flatten_recur(root.children) + [root.val]\n        else:\n            return [root.val]"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "def flatten(nested_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if not nested_list:\n        return []\n    return [x for sublist in nested_list for x in sublist]\n\nclass Solution:\n    # @param nestedList a list of lists of integers\n    # @return a list of integers\n    def flatten(self, nestedList):\n        if not nestedList:\n            return []\n        return [x for sublist in nestedList for x in sublist]"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        def flatten(root):\n            if not root:\n                return\n            flatten(root.children)\n            root.children = [root.val] + root.children\n        flatten(root)"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "from collections import deque\n\n\ndef flatten(nested_list):\n    \"\"\"\n    Given a nested list, returns a flat list of its elements.\n\n    >>> print flatten([[[1, 2], [3, 4], [5, 6]]])\n    [1, 2, 3, 4, 5, 6]\n    >>> print flatten([[[[1, 2], [3, 4]], [5, 6]]])\n    [1, 2, 3, 4, 5, 6]\n    >>> print flatten([1, [2, [3, [4, [5]]]]])\n    [1, 2, 3, 4, 5]\n    >>> print flatten([[[1], [2, [3, [4]]]]])\n    [1, 2, 3, 4]\n    >>> print flatten([[[1], [2, [3, [4]]]]])\n    [1, 2, 3, 4]\n    >>> print flatten([[[1], [2, [3, [4]]]]])\n    [1, 2, 3, 4]\n    >>> print flatten([[[1], [2, [3, [4]]]]])\n    [1, 2, 3, 4]\n    >>> print flatten([[[1], [2, [3, [4]]]]])\n    [1, 2, 3, 4]\n    \"\"\"\n    if not isinstance(nested_list, list):\n        return [nested_list]\n    else:\n        return [item for sublist in nested_list for item in flatten(sublist)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children else []\n\n    def __repr__(self):\n        return str(self.val) + \" \" + str(self.children)\n\n    def __str__(self):\n        return str(self.val) + \" \" + str(self.children)\n\nclass Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n\n        stack = []\n        result = []\n        while root:\n            stack.append(root)\n            root = root.children[0]\n        \n        while stack:\n            cur = stack.pop()\n            result.append(cur.val)\n            if cur.children:\n                stack.extend(cur.children)\n        \n        return result"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n\n        res = []\n        stack = [root]\n        while stack:\n            curr = stack.pop()\n            if curr.left:\n                stack.append(curr.left)\n            if curr.right:\n                stack.append(curr.right)\n            res.append(curr.val)\n\n        return res\n\n# Note:\n# https://leetcode.com/problems/flatten-nested-list/discuss/8814/C%2B%2BJava-O(N)-Solution"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        return [nestedList[0]] + self.flatten(nestedList[1:])"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        result = []\n        self.flattenHelper(nestedList, result)\n        return result\n\n    def flattenHelper(self, nestedList, result):\n        if not nestedList:\n            return\n        for element in nestedList:\n            if isinstance(element, list):\n                self.flattenHelper(element, result)\n            else:\n                result.append(element)"
    },
    {
      "rank": 45,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.next = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a tree node\n    def flatten(self, root):\n        if root is None:\n            return None\n        if root.left is None and root.right is None:\n            return root\n        if root.left is not None:\n            self.flatten(root.left)\n        if root.right is not None:\n            self.flatten(root.right)\n        newNode = Node(root.val)\n        if root.left is not None:\n            newNode.left = root.left\n        if root.right is not None:\n            newNode.right = root.right\n        return newNode"
    },
    {
      "rank": 46,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        if not root.right:\n            return [root.val] + self.flatten(root.left)\n        if not root.left:\n            return self.flatten(root.right) + [root.val]\n        return self.flatten(root.left) + self.flatten(root.right) + [root.val]"
    },
    {
      "rank": 47,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        if not root.children:\n            return [root.val]\n        return [root.val] + [self.flatten(child) for child in root.children]"
    },
    {
      "rank": 48,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children if children else []\n\n\nclass Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack = []\n        result = []\n        stack.append(root)\n        while stack:\n            node = stack.pop()\n            if node.children:\n                stack.extend(node.children)\n            else:\n                result.append(node.val)\n        return result"
    },
    {
      "rank": 49,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n\n    def flatten(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return head\n\n        slow = head\n        fast = head.next\n        while fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # slow is the end of the list\n        while slow.next:\n            slow = slow.next\n            fast = fast.next\n\n        # slow is the end of the list\n        while fast:\n            temp = fast.next\n            fast.next = slow.next\n            slow.next = fast\n            fast = temp\n\n        return head.next"
    },
    {
      "rank": 50,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.next = None\n\n\nclass Solution:\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head\n        # Create a new node.\n        node = Node(head.val)\n        # Move the data to the new node.\n        while head:\n            head = head.next\n            node.next = head\n            head = head.next\n        # Remove the first node.\n        node.next = None\n        return node\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    n = Node(1)\n    n.left = Node(2)\n    n.right = Node(3)\n    n.left.next = Node(4)\n    n.right.next = Node(5)\n    n.left.next.next = Node(6)\n    n.right.next.next = Node(7)\n    n.left.next.next.next = Node(8)\n    n.right.next.next.next = Node(9)\n    print(s.flatten(n))"
    },
    {
      "rank": 51,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if head == None:\n            return None\n        cur = head\n        while cur.next!= None:\n            cur = cur.next\n            if cur.next!= None:\n                cur.next = cur.next.next\n        return head\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef main():\n    head = ListNode(1)\n    head.next = ListNode(2, head)\n    head.next.next = ListNode(3, head.next)\n    head.next.next.next = ListNode(4, head.next.next)\n    print Solution().flatten(head)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 52,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class ListNode(object):\n#     def __init__(self, val):\n#         self.val = val\n#         self.next = None\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None:\n            return None\n        \n        if head.next is None:\n            return head\n        \n        prev = head\n        \n        while True:\n            if head.next is None:\n                prev.next = None\n                return head\n            \n            if head.next.next is None:\n                prev.next = head.next\n                return head\n            \n            prev = head.next\n            head.next = head.next.next\n        \n        return head"
    },
    {
      "rank": 53,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedInteger(object):\n    def __init__(self, value=None, lists=None):\n        \"\"\"\n        :type value: int\n        :type lists: List[NestedInteger]\n        \"\"\"\n        self.value = value\n        self.lists = lists if lists else []\n\n    def add(self, ele):\n        \"\"\"\n        :type ele: NestedInteger\n        :rtype: None\n        \"\"\"\n        self.value = ele.value if ele.value is not None else self.value\n        self.lists.append(ele.lists if ele.lists is not None else [])\n\n    def __str__(self):\n        return str(self.value)\n\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n\n        return self.flatten_recursive(nestedList)\n\n    def flatten_recursive(self, nestedList):\n        res = []\n        for ele in nestedList:\n            if not isinstance(ele, NestedInteger):\n                res.append(ele)\n                continue\n            res.extend(self.flatten_recursive(ele.lists))\n        return res"
    },
    {
      "rank": 54,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\n# class NestedList(object):\n#     def __init__(self, head=None, tail=None):\n#         self.head = head\n#         self.tail = tail\n\nclass Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: NestedList\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        head = nestedList.head\n        tail = nestedList.tail\n        res = []\n        while head:\n            if isinstance(head, NestedList):\n                res.append(head.head)\n                head = head.tail\n            else:\n                res.append(head)\n                head = None\n        res.append(tail)\n        return res"
    },
    {
      "rank": 55,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if not head:\n            return head\n        if head.next:\n            while head.next.next:\n                head = head.next\n            head.next = None\n        res = []\n        while head:\n            res.append(head.val)\n            head = head.next\n        return res"
    },
    {
      "rank": 56,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n#         self.next = None\n\nclass Solution:\n    # @param head, a list node\n    # @return a list node\n    def flatten(self, head):\n        if not head or not head.next:\n            return head\n        p = head\n        while p.next:\n            p = p.next\n            if not p.next:\n                break\n            p.next = p.next.next\n        \n        while p.next:\n            n = p.next\n            p.next = n.next\n            n.next = None\n            p = n\n        return head"
    },
    {
      "rank": 57,
      "score": 10.0,
      "candidate": "# Definition for a nested list.\nclass NestedListNode:\n    def __init__(self, val, children=[]):\n        self.val = val\n        self.children = children\n\n    def __str__(self):\n        if len(self.children) == 0:\n            return str(self.val)\n        else:\n            return str(self.val) + \" -> \" + \" -> \".join([str(child) for child in self.children])\n\nclass Solution:\n    def flatten(self, root: NestedListNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.flattenRec(root)\n\n    def flattenRec(self, root):\n        if root.children:\n            self.flattenRec(root.children[0])\n            root.children[0].val += root.children[0].val\n            root.children[0].children = [self.flattenRec(child) for child in root.children[0].children]\n            root.children = [root.children[0]] + root.children[1:]\n        else:\n            root.val += root.val\n            root.children = []"
    },
    {
      "rank": 58,
      "score": 10.0,
      "candidate": "import collections\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n    def __str__(self):\n        return str(self.val)\n\nclass Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if head is None:\n            return None\n        elif head.next is None:\n            return head\n        else:\n            newHead = self.flatten(head.next)\n            head.next = None\n            return newHead\n\nif __name__ == '__main__':\n    n1 = Node(1)\n    n2 = Node(2)\n    n3 = Node(3)\n    n4 = Node(4)\n    n5 = Node(5)\n    n6 = Node(6)\n    n7 = Node(7)\n    n8 = Node(8)\n    n9 = Node(9)\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    n4.next = n5\n    n5.next = n6\n    n6.next = n7\n    n7.next = n8\n    n8.next = n9\n    n9.next = None\n    s = Solution()\n    print(s.flatten(n1))\n    print(s.flatten(n1))\n    print(s.flatten(n1))\n    print(s.flatten(n1))\n    print(s.flatten(n1))\n    print(s.flatten(n1))\n    print(s.flatten(n1))"
    },
    {
      "rank": 59,
      "score": 10.0,
      "candidate": "from collections import namedtuple\n\nfrom utils.iterable import flatten\n\n# Definition for a node in a linked list.\nNode = namedtuple('Node', ['data', 'next'])\n\n\ndef flatten_list(node):\n    if not node:\n        return []\n\n    if node.next:\n        return flatten([node.data] + flatten_list(node.next))\n    else:\n        return [node.data]\n\n\nclass Solution:\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: List[int]\n        \"\"\"\n        if not head:\n            return []\n\n        return flatten_list(head)"
    },
    {
      "rank": 60,
      "score": 10.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def flatten(self, root: Node) -> List[int]:\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        if root.children:\n            return [root.val] + self.flatten(root.children)\n        return [root.val]"
    },
    {
      "rank": 61,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        # base case\n        if not head:\n            return head\n        \n        # recursive case\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # slow is the last node\n        new_head = slow.next\n        slow.next = None\n        \n        # copy the list\n        while head:\n            new_head = self.flatten(head)\n            head = head.next\n        \n        # return the new head\n        return new_head"
    },
    {
      "rank": 62,
      "score": 10.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        curr = head\n        while curr:\n            nxt = curr.next\n            curr.next = None\n            curr = nxt\n        return head"
    },
    {
      "rank": 63,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[Any]]\n        :rtype: List[Any]\n        \"\"\"\n        if not nestedList:\n            return []\n\n        res = []\n        def flatten(nestedList):\n            for l in nestedList:\n                if isinstance(l, list):\n                    flatten(l)\n                else:\n                    res.append(l)\n        flatten(nestedList)\n        return res"
    },
    {
      "rank": 64,
      "score": 9.0,
      "candidate": "from collections import defaultdict\n\ndef flatten(nested_list):\n    \"\"\"\n    Returns a new list with all nested lists flattened.\n\n    >>> list(flatten([[1, 2, [3, 4], 5], 6, [7, 8]]))\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> list(flatten([[[1, 2, [3, 4]], 5], 6, [7, 8]]))\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> list(flatten([[[[1, 2], 3], 4], 5, [6, 7]]))\n    [1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    if not nested_list:\n        return []\n    if len(nested_list) == 1:\n        return nested_list[0]\n    return [flatten(item) for item in nested_list]\n\ndef test_flatten():\n    assert flatten([[[1, 2], 3], 4, [5, 6]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([[[1, 2], [3, 4]], 5, [6, 7]]) == [1, 2, 3, 4, 5, 6, 7]\n    assert flatten([[[[1, 2], [3, 4]], 5], [6, 7]]) == [1, 2, 3, 4, 5, 6, 7]\n\nif __name__ == \"__main__\":\n    test_flatten()"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def flatten(node):\n    \"\"\"\n    >>> flatten([[1,2],3,[4,5],6])\n    [1, 2, 3, 4, 5, 6]\n    >>> flatten([[[1,2],3],4,[[5,6],7]])\n    [1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    if not isinstance(node, list):\n        return [node]\n    elif len(node) == 0:\n        return []\n    elif len(node) == 1:\n        return node[0]\n    else:\n        return [flatten(node[0])] + flatten(node[1:])\n\ndef main():\n    node = [[1,2],3,[4,5],6]\n    print(flatten(node))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "import re\n\n\ndef flatten(l):\n    if type(l) == list:\n        return [flatten(item) for item in l]\n    else:\n        return l\n\n\ndef main():\n    l = [[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]]\n    print(flatten(l))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n\n        def flatten(nestedList):\n            if len(nestedList) == 1:\n                return nestedList[0]\n            elif len(nestedList) == 0:\n                return []\n            else:\n                return [item for sublist in nestedList for item in sublist]\n\n        return flatten(nestedList)"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "def flatten(l):\n    \"\"\"\n    >>> flatten([[[1, 2], [3, 4], [5, 6]], 7, 8, [9, 10]])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> flatten(())\n    []\n    \"\"\"\n    if not l:\n        return l\n    return flatten(l[0]) + flatten(l[1:])\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flatten_helper(nestedList, [])\n    def flatten_helper(self, nestedList, result):\n        if len(nestedList) == 0:\n            return result\n        for i in range(len(nestedList)):\n            self.flatten_helper(nestedList[i], result)\n        return result"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flatten_rec(nestedList)\n        \n    def flatten_rec(self, nestedList):\n        if len(nestedList) == 0:\n            return []\n        result = []\n        for item in nestedList:\n            if type(item) is list:\n                result += self.flatten_rec(item)\n            else:\n                result.append(item)\n        return result"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "def flatten(x):\n    \"\"\"\n    Given a nested list, return a flat list of all its elements.\n\n    Example:\n    >>> print flatten([[1, 2], [3, [4, 5]]])\n    [1, 2, 3, 4, 5]\n    >>> print flatten([[[1, 2], [3, [4, 5]]]])\n    [1, 2, 3, 4, 5]\n    >>> print flatten([[[1, 2], [3, [4, 5]]], [6, [7]]])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> print flatten([[[1, 2], [3, [4, 5]]], [6, [7]]])\n    [1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n\n    def _flatten(x):\n        if isinstance(x, list):\n            for y in x:\n                _flatten(y)\n        else:\n            yield x\n    return list(_flatten(x))\n\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def flatten(list_of_lists):\n    \"\"\"\n    Input: list of lists\n    Output: list of elements\n    \"\"\"\n    return [e for sublist in list_of_lists for e in sublist]\n\ndef main():\n    print flatten([[[1,2], [3,4], [5,6]], [[7,8], [9,10], [11,12]]])\n    print flatten([[[1,2], [3,4], [5,6]], [[7,8], [9,10], [11,12]]])\n    print flatten([[[1,2], [3,4], [5,6]], [[7,8], [9,10], [11,12]]])\n    print flatten([[[1,2], [3,4], [5,6]], [[7,8], [9,10], [11,12]]])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def flatten(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return root"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    # @param root, a tree node\n    # @return a tree node\n    def flatten(self, root):\n        if root is None:\n            return None\n        if root.children is None or root.children == []:\n            return root\n        \n        p = root\n        while p.children is not None and len(p.children) > 1:\n            tmp = p.children[0]\n            p.children = p.children[1:]\n            p.children.append(tmp)\n            p = tmp\n        return p"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flatten_rec(nestedList, [])\n\n    def flatten_rec(self, nestedList, result):\n        if len(nestedList) == 0:\n            return result\n        for i in range(len(nestedList)):\n            self.flatten_rec(nestedList[i], result)\n        return result + [nestedList[i][0] for i in range(len(nestedList[0]))]"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "# Definition for a nested list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def flatten(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        \n        result = []\n        cur = head\n        while cur is not None:\n            result.append(cur)\n            cur = cur.next\n        \n        new_head = ListNode(0, None)\n        new_head.next = result[0]\n        \n        for i in range(len(result) - 1):\n            cur = result[i]\n            new_head.next = cur\n            new_head = cur\n        return new_head"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def flattenRec(nestedList):\n            if len(nestedList) == 0:\n                return []\n            if len(nestedList) == 1:\n                return nestedList[0]\n            flattenRec(nestedList[0])\n            flattenRec(nestedList[1:])\n            return nestedList[0] + nestedList[1:]\n\n        return flattenRec(nestedList)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.flatten([[[1,2], [3,4]], [[5,6], [7,8], [9,10]]])"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "def flatten(nested_list):\n    \"\"\"\n    :type nested_list: List[List[Any]]\n    :rtype: List[Any]\n    \"\"\"\n    return [item for sublist in nested_list for item in sublist]"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "def flatten(nested_list):\n    \"\"\"\n    Given a list of lists, returns a list of all flattened lists.\n    \"\"\"\n    return [item for sublist in nested_list for item in sublist]\n\nif __name__ == \"__main__\":\n    lst = [[1, [2, 3], [4, 5]], [[6, 7], 8], 9]\n    print(flatten(lst))"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def flatten(self, root):\n        if not root:\n            return\n        if not root.left and not root.right:\n            return\n        if root.left:\n            self.flatten(root.left)\n        if root.right:\n            self.flatten(root.right)\n        if root.left:\n            root.left = self.flatten(root.left)\n            root.left.right = root\n        if root.right:\n            root.right = self.flatten(root.right)\n            root.right.left = root\n        return root\n\nif __name__ == '__main__':\n    print Solution().flatten([[1],[2,3],[4],[5]])"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flattenRec(nestedList)\n\n    def flattenRec(self, nestedList):\n        if len(nestedList) == 0:\n            return []\n        result = []\n        for i in range(len(nestedList)):\n            if nestedList[i] == []:\n                result.extend(nestedList[i])\n            else:\n                result.extend(self.flattenRec(nestedList[i]))\n        return result\n\nif __name__ == \"__main__\":\n    assert Solution().flatten([[1, [2, [3]]]]) == [1, 2, 3]"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n\n        output = []\n        stack = []\n        for item in nestedList:\n            if type(item) is list:\n                stack.append(item)\n            else:\n                while stack:\n                    output.append(stack.pop())\n                output.append(item)\n        while stack:\n            output.append(stack.pop())\n        return output"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "from collections import deque\nfrom collections import namedtuple\n\nNode = namedtuple('Node', 'val children')\n\nclass Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n    def add_child(self, val):\n        self.children.append(Node(val))\n\ndef flatten(node):\n    \"\"\"\n    Flatten a given nested list structure into a flat list.\n    \"\"\"\n    if not isinstance(node, list):\n        return [node]\n    flat_list = []\n    for child in node:\n        if isinstance(child, list):\n            flat_list.extend(flatten(child))\n        else:\n            flat_list.append(child)\n    return flat_list\n\nif __name__ == \"__main__\":\n    nodes = [Node(0), Node(1), Node(2), Node(3), Node(4), Node(5)]\n    flat_nodes = flatten(nodes)\n    print(flat_nodes)"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flattenRec(nestedList, [])\n\n    def flattenRec(self, nestedList, result):\n        for item in nestedList:\n            if type(item) is list:\n                self.flattenRec(item, result)\n            else:\n                result.append(item)\n        return result"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "from collections import deque\n\n\ndef flatten(l):\n    \"\"\"\n    Example:\n\n    >>> flatten([[[1, 2], [3, 4]], [5, 6]])\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if l == []:\n        return l\n    elif type(l) == list:\n        return flatten(l[0]) + flatten(l[1:])\n    else:\n        return [l]\n\n\ndef main():\n    l = [[[[1, 2], [3, 4]], [5, 6]]]\n    print(flatten(l))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if len(nestedList) == 0:\n            return []\n\n        result = []\n        for item in nestedList:\n            if isinstance(item, list):\n                result.extend(self.flatten(item))\n            else:\n                result.append(item)\n\n        return result"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return self.flattenHelper(nestedList, [])\n\n    def flattenHelper(self, nestedList, flatList):\n        if len(nestedList) == 0:\n            return flatList\n        for i in xrange(len(nestedList)):\n            self.flattenHelper(nestedList[i], flatList)\n        return flatList"
    },
    {
      "rank": 88,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        res = []\n        stack = [nestedList[0]]\n        for i in range(1, len(nestedList)):\n            if isinstance(nestedList[i], list):\n                stack.append(nestedList[i])\n            else:\n                res.append(stack.pop())\n        return res"
    },
    {
      "rank": 89,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        return self.flatten_rec(nestedList, 0)\n\n    def flatten_rec(self, nestedList, level):\n        if len(nestedList) == 1:\n            return nestedList[0]\n        elif level == len(nestedList) - 1:\n            return [item for sublist in nestedList for item in sublist]\n        else:\n            return [item for sublist in nestedList for item in self.flatten_rec(sublist, level+1)]"
    },
    {
      "rank": 90,
      "score": 8.0,
      "candidate": "# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None:\n            return head\n        curr = head\n        while curr.next!= None:\n            next = curr.next\n            curr.next = curr.next.next\n            curr = next\n        head.next = None\n        return head\n\nif __name__ == '__main__':\n    sol = Solution()\n    l1 = ListNode(1)\n    l2 = ListNode(2)\n    l3 = ListNode(3)\n    l4 = ListNode(4)\n    l1.next = l2\n    l2.next = l3\n    l3.next = l4\n    print(sol.flatten(l1))"
    },
    {
      "rank": 91,
      "score": 8.0,
      "candidate": "def flatten(nested_list):\n    \"\"\"\n    :type nested_list: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    flatten_list = []\n    for i in nested_list:\n        if isinstance(i, list):\n            flatten_list += flatten(i)\n        else:\n            flatten_list.append(i)\n    return flatten_list\n\n\nif __name__ == '__main__':\n    nested_list = [[1, [2, [3]]], [[4, 5], [6, [7, [8, [9]]]]]]\n    print(flatten(nested_list))"
    },
    {
      "rank": 92,
      "score": 8.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, children=None):\n        self.val = val\n        self.children = children or []\n    def __repr__(self):\n        return \"Node(\" + str(self.val) + \")\"\n\n# Definition for a stack.\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    def push(self, node):\n        self.stack.append(node)\n    def pop(self):\n        return self.stack.pop()\n\ndef flatten(tree):\n    if isinstance(tree, list):\n        return tree\n    if not tree:\n        return []\n    stack = Stack()\n    for node in tree:\n        stack.push(node)\n        if isinstance(node, list):\n            for child in node:\n                stack.push(child)\n    while not stack.stack:\n        return []\n    return stack.pop().children\n\ntree = [ [1, [2, [3]]], [4, 5, [6]] ]\nprint(flatten(tree))"
    },
    {
      "rank": 93,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def flatten(self, nestedList):\n        \"\"\"\n        :type nestedList: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not nestedList:\n            return []\n        res = []\n        for l in nestedList:\n            if isinstance(l, list):\n                res.extend(self.flatten(l))\n            else:\n                res.append(l)\n        return res"
    },
    {
      "rank": 94,
      "score": 8.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flatten(self, root: Node) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n\n# Note:\n# 1. Flatten a tree to a list using recursion.\n# 2. Flatten a tree to a list using stack.\n# 3. Use a stack to track the stack level, use a list to track the level."
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import unittest\n\n\ndef flatten(l):\n    \"\"\"\n    Flatten a nested list.\n\n    :param l: a list\n    :return: a list\n    \"\"\"\n    if not isinstance(l, list):\n        return l\n    return [flatten(i) for i in l]\n\n\nclass Test(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(flatten([[1, 2, 3], [4, 5, 6]]), [1, 2, 3, 4, 5, 6])\n\n    def test_nested(self):\n        self.assertEqual(flatten([[1, 2, [3, 4], 5], 6]), [1, 2, 3, 4, 5, 6])\n\n    def test_empty(self):\n        self.assertEqual(flatten([]), [])\n\n    def test_none(self):\n        self.assertEqual(flatten(None), [])\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if not head or not head.next:\n            return head\n        p = head\n        q = head.next\n        while q:\n            p = p.next\n            q = q.next\n        n = p\n        while p.next:\n            p = p.next\n            n = n.next\n        n.next = None\n        p = head\n        while p:\n            q = p.next\n            p.next = n\n            n = p\n            p = q\n        return head\n\n\nif __name__ == '__main__':\n    cases = [\n        ([[1,2], [3,4]], [[1,2], [3,4]]),\n        ([[1], []], [[1]]),\n        ([[1,2], [3], [4,5]], [[1,2], [3], [4,5]]),\n        ([], []),\n    ]\n    for case in cases:\n        sol = Solution()\n        print(sol.flatten(case[0]))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return nothing\n    def flatten(self, root):\n        if root is None:\n            return\n\n        self.flatten(root.left)\n        self.flatten(root.right)\n        if root.left is not None:\n            root.left.right = root.right\n            root.right = root.left\n        root.left = None\n        root.right = None\n\n    def flatten2(self, root):\n        if root is None:\n            return\n\n        self.flatten2(root.left)\n        self.flatten2(root.right)\n        if root.left is not None:\n            root.left.right = root.right\n            root.right = root.left\n        root.left = None\n        root.right = None\n\n    def flatten3(self, root):\n        if root is None:\n            return\n\n        self.flatten3(root.left)\n        self.flatten3(root.right)\n        if root.left is not None:\n            root.left.right = root.right\n            root.right = root.left\n        root.left = None\n        root.right = None\n        if root.right is not None:\n            root.right.left = root.left\n            root.left = root.right\n        root.left = None\n        root.right = None\n\n    def flatten4(self, root):\n        if root is None:\n            return\n\n        self.flatten4(root.left)\n        self.flatten4(root.right)\n        if root.left is not None:\n            root.left.right = root.right\n            root.right = root.left\n        root.left = None\n        root.right = None\n        if root.right is not None:\n            root.right.left = root.left\n            root.left = root.right\n        root.left = None\n        root.right = None\n\n    def flatten5("
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n\n        if root.left:\n            self.flatten(root.left)\n\n        if root.right:\n            self.flatten(root.right)\n\n        while root.left or root.right:\n            if root.left:\n                root.right = root.left\n                root.left = None\n            else:\n                root.right = root.left\n                root.left = None\n\n\ns = Solution()\n\nprint(s.flatten([1, [2, [3, [4]]]]))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def flatten(self, head):\n        if not head:\n            return head\n        \n        cur = head\n        pre = None\n        while cur:\n            if not cur.next:\n                break\n            pre = cur\n            cur = cur.next\n        \n        # cur points to the last node\n        cur = head\n        while cur:\n            if not cur.next:\n                break\n            if cur.next.next:\n                pre.next = cur.next\n                cur = cur.next.next\n            else:\n                pre.next = cur\n                cur = None\n                \n        return head"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from collections import deque\n\ndef flatten(nested_list):\n    \"\"\"\n    >>> flatten([[1, 2], [3, [4, 5]]])\n    [1, 2, 3, 4, 5]\n    >>> flatten([[[[1]]]])\n    [1]\n    \"\"\"\n    result = []\n    for el in nested_list:\n        if isinstance(el, list):\n            result.extend(flatten(el))\n        else:\n            result.append(el)\n    return result\n\nclass NestedList:\n    def __init__(self, nested_list):\n        self.nested_list = nested_list\n\n    def __iter__(self):\n        return iter(self.nested_list)\n\ndef flatten_recursive(nested_list):\n    if not isinstance(nested_list, NestedList):\n        return [x for x in nested_list]\n    else:\n        result = []\n        for el in nested_list:\n            result.extend(flatten_recursive(el))\n        return result\n\ndef test():\n    assert flatten([[[[1]]]]) == [1]\n    assert flatten([[[1], [2]]]) == [1, 2]\n    assert flatten([[[[1], [2, 3]], [[4, 5], [6]]]]) == [1, 2, 3, 4, 5, 6]\n    assert flatten([[[[1], [2, 3]], [[4, 5], [6, 7]]]]) == [1, 2, 3, 4, 5, 6, 7]\n    assert flatten([[[[1], [2, 3]], [[4, 5], [6, 7]]], [[[8]], [[9], [10]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert flatten([[[[1], [2, 3]], [[4, 5], [6, 7]]], [[[8]], [[9], [10]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert flatten([[["
    }
  ]
}