{
  "timestamp": "2025-09-14T19:49:13.238450",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 330,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def convert_set_to_tuple(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    tuple_list = []\n    for i in range(len(set_)):\n        tuple_list.append((set_[i],))\n    return tuple_list\n\n# Time:  O(n)\n# Space: O(n)\ndef convert_set_to_tuple_2(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    tuple_list = []\n    for i in range(len(set_)):\n        tuple_list.append((set_[i],))\n    return tuple_list\n\n# Time:  O(n)\n# Space: O(1)\ndef convert_set_to_tuple_3(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    tuple_list = []\n    for i in range(len(set_)):\n        tuple_list.append((set_[i],))\n    return tuple_list"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of ordered tuples, [t1, t2, t3, t4]\n    def orderedSetToTuple(self, set):\n        res = []\n        while set:\n            res.append(set.pop())\n        return res"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def set_to_tuple(set_input):\n    tuple_output = []\n    for element in set_input:\n        tuple_output.append(element)\n    return tuple(tuple_output)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def set2tuple(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, x) for x in s]\n\n    def set2tuple2(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, x) for x in s]\n\n    def set2tuple3(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z) for x in s for y in s for z in s]\n\n    def set2tuple4(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z, x) for x in s for y in s for z in s]\n\n    def set2tuple5(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z, x, x) for x in s for y in s for z in s]\n\n    def set2tuple6(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z, x, y, x) for x in s for y in s for z in s]\n\n    def set2tuple7(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z, x, y, z, x) for x in s for y in s for z in s]\n\n    def set2tuple8(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return [(x, y, z, x, y, z, x, x) for x in s for y"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution:\n    def set2tuple(self, set):\n        \"\"\"\n        :type set: List[int]\n        :rtype: List[Tuple]\n        \"\"\"\n        if not set:\n            return []\n        return sorted(set, key=lambda t: t.x)"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "class Solution:\n    # @return a tuple, (index1, index2)\n    def getOrderedTuple(self, nums):\n        if not nums:\n            return None\n        # sort the list by the first element\n        nums.sort(key=lambda x: x[0])\n        # find the first element that is greater than the last one\n        i = 0\n        while i < len(nums) and nums[i] == nums[-1]:\n            i += 1\n        # find the first element that is smaller than the last one\n        j = len(nums) - 1\n        while j > 0 and nums[j] == nums[-1]:\n            j -= 1\n        # return the tuple (i, j)\n        return (i, j)\n\nif __name__ == '__main__':\n    print Solution().getOrderedTuple([2, 3, 4, 4, 3, 2, 4, 1, 1, 4, 3, 2, 3, 4, 4, 1, 3, 4, 3, 2, 1])"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/sparse-matrix/problem\n\ndef sparse_matrix_to_tuple(sparse_matrix):\n    \"\"\"\n    :type sparse_matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    # Create a list of lists to store the tuples.\n    # Note that the tuples are in the order of rows.\n    tuples = [[] for i in range(len(sparse_matrix[0]))]\n\n    # Iterate through each row of the matrix.\n    for row in sparse_matrix:\n        # Iterate through each column of the row.\n        for column in row:\n            # If the column is not empty, add it to the tuple.\n            if column!= 0:\n                tuples[column - 1].append(row[column - 1])\n\n    return tuples\n\nif __name__ == '__main__':\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    print(sparse_matrix_to_tuple(matrix))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def convertBST(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        self.convertBST(root.left)\n        self.convertBST(root.right)\n        self.reorder(root)\n\n    def reorder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None\n        \"\"\"\n        if not root:\n            return\n        if root.left:\n            self.reorder(root.left)\n        if root.right:\n            self.reorder(root.right)\n        if root.left:\n            root.left.val, root.right.val = root.right.val, root.left.val"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# https://oj.leetcode.com/problems/convert-a-number-to-hexadecimal/\n# tags: easy, array, hash-table, conversion\n\n\"\"\"\nExample:\n\nGiven num = 16, return [4, 3, 2, 9, 8, 7, 6, 5, 10, 9, 8, 7, 6, 5].\n\nNote:\n\nYou may assume the number of digits in the number string is in the range [1, 9].\n\"\"\"\n\n\nclass Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[str]\n        \"\"\"\n        if num == 0:\n            return [str(num)]\n\n        hex = []\n        while num:\n            num, rem = divmod(num, 16)\n            hex.append(str(rem))\n        return hex[::-1]\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.toHex(16))\n    print(sol.toHex(-16))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\n\nclass Solution:\n    # @param set, a set of integers\n    # @return a tuple, (k1, k2,.., kn)\n    def getTuple(self, set):\n        if not set:\n            return None\n        res = []\n        for i in range(len(set)):\n            res.append(set[i])\n            t = Tuple(set[i])\n            set[i] = t.next\n            t.next = None\n            t.next = res[i]\n        return tuple(res)\n\nif __name__ == '__main__':\n    s = Solution()\n    # s.getTuple([1,2,3])\n    s.getTuple([3,2,1])"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of tuples, each tuple contains [i, j, k]\n    def sortedSet2tuple(self, set):\n        \"\"\"\n        :type set: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        tuples = []\n        for i in range(len(set)):\n            for j in range(i+1, len(set)):\n                if set[i] > set[j]:\n                    tuples.append((set[i], set[j], set[j] - set[i]))\n                    break\n        return tuples\n\nif __name__ == '__main__':\n    s = Solution()\n    #print s.sortedSet2tuple([1, 2, 3])\n    print s.sortedSet2tuple([1, 3, 5, 7])\n    print s.sortedSet2tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    print s.sortedSet2tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def orderedSet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        d = defaultdict(list)\n        for n in nums:\n            d[n].append(n)\n        result = []\n        for k, v in d.items():\n            result.extend(sorted(v))\n        return result"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def convert(set):\n    \"\"\"\n    :type set: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    result = []\n    for number in set:\n        result.append((number,))\n    return result"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from typing import Set\n\nclass Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        # Sort the set\n        S.sort()\n        # Generate the tuple\n        t = []\n        for i in range(len(S)):\n            t.append(S[i])\n        return t"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# Definition for a point.\n# class Point(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def setToList(self, set):\n        \"\"\"\n        :type set: List[Point]\n        :rtype: List[tuple]\n        \"\"\"\n        list = []\n        for point in set:\n            list.append((point.x, point.y))\n        return list\n\nif __name__ == \"__main__\":\n    point = Point(1, 1)\n    point2 = Point(2, 2)\n    point3 = Point(3, 3)\n    point4 = Point(4, 4)\n    point5 = Point(5, 5)\n    point6 = Point(6, 6)\n    point7 = Point(7, 7)\n    point8 = Point(8, 8)\n    point9 = Point(9, 9)\n    point10 = Point(10, 10)\n    point11 = Point(11, 11)\n    point12 = Point(12, 12)\n    point13 = Point(13, 13)\n    point14 = Point(14, 14)\n    point15 = Point(15, 15)\n    point16 = Point(16, 16)\n    point17 = Point(17, 17)\n    point18 = Point(18, 18)\n    point19 = Point(19, 19)\n    point20 = Point(20, 20)\n    point21 = Point(21, 21)\n    point22 = Point(22, 22)\n    point23 = Point(23, 23)\n    point24 = Point(24, 24)\n    point25 = Point(25, 25)\n    point26 = Point(26, 26)\n    point27 = Point(27, 27)\n    point28 = Point(28, 28)\n    point29 = Point(29, 29)\n    point30 = Point(30, 30)\n    point31 = Point(31, 31)\n    point32 = Point(32, 32)\n    point33 = Point(33, 33)\n    point34 = Point(34, 34)\n    point35 = Point(35"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def to_tuples(set_of_ints):\n    \"\"\"\n    >>> to_tuples([1, 2, 3])\n    [(1,), (2,), (3,)]\n    \"\"\"\n    result = []\n    for i in set_of_ints:\n        result.append((i,))\n    return result\n\n\n\ndef test_to_tuples():\n    assert to_tuples([1, 2, 3]) == [(1,), (2,), (3,)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 9.975516558662687,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        \n        root = TreeNode(nums[0])\n        nums = nums[1:]\n        \n        while nums:\n            root.left = TreeNode(nums[0])\n            root.right = TreeNode(nums[1])\n            nums = nums[2:]\n            root = root.left if root.left else root.right\n        \n        return root\n\nclass Solution2:\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        \n        root = TreeNode(nums[0])\n        nums = nums[1:]\n        \n        while nums:\n            root.left = TreeNode(nums[0])\n            root.right = TreeNode(nums[1])\n            root.left.left = TreeNode(nums[2])\n            root.left.right = TreeNode(nums[3])\n            nums = nums[4:]\n            root = root.left if root.left else root.right\n        \n        return root"
    },
    {
      "rank": 18,
      "score": 9.960679583987998,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # Build the BST\n        root = None\n        for i in range(len(nums)):\n            if not root:\n                root = TreeNode(nums[i])\n            else:\n                if nums[i] < root.val:\n                    root.left = TreeNode(nums[i])\n                else:\n                    root.right = TreeNode(nums[i])\n        return root"
    },
    {
      "rank": 19,
      "score": 9.936875947934302,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def zigzagLevelOrder(self, root):\n        # write your code here\n        if root == None:\n            return []\n        \n        res = []\n        level = []\n        stack = [root]\n        while stack:\n            node = stack[-1]\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            level.append(node.val)\n            if len(stack) == 1:\n                res.append(level)\n                level = []\n                stack = stack[::-1]\n            else:\n                stack.pop()\n        return res\n\n\nif __name__ == \"__main__\":\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    print Solution().zigzagLevelOrder(root)"
    },
    {
      "rank": 20,
      "score": 9.923236057834577,
      "candidate": "from collections import OrderedDict\n\n# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution(object):\n    def __init__(self):\n        self.points = OrderedDict()\n\n    def insert(self, point):\n        self.points[point] = None\n\n    def find(self, point):\n        if point in self.points:\n            return self.points[point]\n        else:\n            return None\n\n    def delete(self, point):\n        del self.points[point]\n\n    def findAll(self, point):\n        return self.points.keys()\n\n    def getPoints(self):\n        return self.points.keys()\n\ndef main():\n    s = Solution()\n    s.insert(Point(1, 1))\n    s.insert(Point(2, 2))\n    s.insert(Point(3, 3))\n    s.insert(Point(4, 4))\n    s.insert(Point(5, 5))\n    s.insert(Point(6, 6))\n    s.insert(Point(7, 7))\n    s.insert(Point(8, 8))\n    s.insert(Point(9, 9))\n    s.insert(Point(10, 10))\n    s.insert(Point(11, 11))\n    s.insert(Point(12, 12))\n    s.insert(Point(13, 13))\n    s.insert(Point(14, 14))\n    s.insert(Point(15, 15))\n\n    print s.find(Point(1, 1))\n    print s.find(Point(5, 5))\n    print s.findAll(Point(1, 1))\n    print s.findAll(Point(5, 5))\n    print s.getPoints()\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 21,
      "score": 9.920393434637278,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n        self.next = None\n\nclass Solution(object):\n    def convert(self, nums, K):\n        \"\"\"\n        :type nums: List[int]\n        :type K: int\n        :rtype: List[Tuple]\n        \"\"\"\n        if len(nums) <= 0 or K <= 0:\n            return []\n        result = []\n        for i in range(len(nums)):\n            t = Tuple(nums[i])\n            while t.next:\n                t = t.next\n            t.next = Tuple(0)\n            result.append(t)\n        result.sort(key=lambda x: x.x)\n        return result[:K]\n\nif __name__ == \"__main__\":\n    print Solution().convert([1,2,3], 3)\n    print Solution().convert([1,2,3], 4)"
    },
    {
      "rank": 22,
      "score": 9.920387852594066,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a tuple of integers\n    def numTuple(self, set):\n        tuples = []\n        for i in set:\n            if i not in tuples:\n                tuples.append(i)\n        tuples.sort()\n        return tuple(tuples)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.numTuple([1, 2, 3])\n    print s.numTuple([3, 2, 1])\n    print s.numTuple([1, 2, 3, 4, 5])\n    print s.numTuple([1, 2, 3, 4, 5, 6, 7])\n    print s.numTuple([1, 2, 3, 4, 5, 6, 7, 8, 9])"
    },
    {
      "rank": 23,
      "score": 9.898337500841604,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        sorted_nums = sorted(nums)\n        root = TreeNode(sorted_nums[0])\n        root.left = self.sortedArrayToBST(sorted_nums[1:])\n        root.right = self.sortedArrayToBST(sorted_nums[:-1])\n        return root\n\n# Note:\n# 1. O(n) time\n# 2. O(n) space"
    },
    {
      "rank": 24,
      "score": 9.897624743499641,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return sorted(S)\n\n\ndef main():\n    solution = Solution()\n    S = [1, 2, 3, 4, 5]\n    S2 = [3, 1, 2, 4, 5]\n    S3 = [4, 1, 3, 5, 2]\n    print solution.orderedSetToTuple(S)\n    print solution.orderedSetToTuple(S2)\n    print solution.orderedSetToTuple(S3)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 25,
      "score": 9.843382817873673,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n    def __repr__(self):\n        return \"Point(\"+str(self.x)+\",\"+str(self.y)+\")\"\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Solution:\n    # @param points, a list of points\n    # @return a list of Points\n    def pointToList(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: List[Point]\n        \"\"\"\n        if not points:\n            return []\n\n        res = []\n        for i in range(len(points)):\n            p1 = points[i]\n            for j in range(i+1, len(points)):\n                p2 = points[j]\n                if p1.x == p2.x and p1.y == p2.y:\n                    continue\n                if p1.x > p2.x:\n                    p1, p2 = p2, p1\n                res.append(Point(p1.x, p1.y))\n                res.append(Point(p2.x, p2.y))\n                break\n        return res\n\nif __name__ == \"__main__\":\n    points = [Point(0, 0), Point(1, 1), Point(2, 2)]\n    print Solution().pointToList(points)"
    },
    {
      "rank": 26,
      "score": 9.840378708782117,
      "candidate": "def set_to_tuple(set_):\n    \"\"\"\n    Input: A set of integers\n    Output: A tuple of integers\n    \"\"\"\n    tuple_set = tuple(set_)\n    return tuple_set\n\ndef set_to_tuple2(set_):\n    \"\"\"\n    Input: A set of integers\n    Output: A tuple of integers\n    \"\"\"\n    tuple_set = tuple(set_)\n    return tuple_set\n\ndef set_to_tuple3(set_):\n    \"\"\"\n    Input: A set of integers\n    Output: A tuple of integers\n    \"\"\"\n    tuple_set = tuple(set_)\n    return tuple_set\n\ndef set_to_tuple4(set_):\n    \"\"\"\n    Input: A set of integers\n    Output: A tuple of integers\n    \"\"\"\n    tuple_set = tuple(set_)\n    return tuple_set\n\ndef set_to_tuple5(set_):\n    \"\"\"\n    Input: A set of integers\n    Output: A tuple of integers\n    \"\"\"\n    tuple_set = tuple(set_)\n    return tuple_set\n\nif __name__ == '__main__':\n    test_cases = [\n        [1,2,3,4],\n        [2,3,4,5],\n        [1,2,3,4,5],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6,7],\n        [1,2,3,4,5,6,7,8],\n        [1,2,3,4,5,6,7,8,9],\n        [1,2,3,4,5,6,7,8,9,10],\n        [1,2,3,4,5,6,7,8,9,10,11],\n        [1,2,3,4,5,6,7,8,9,10,11,12],\n        [1,2,3,4,5,6,7,8,9,10,11,12,13],\n        [1,2,3,4,5,6"
    },
    {
      "rank": 27,
      "score": 9.795419751842005,
      "candidate": "# https://leetcode.com/problems/convert-a-number-to-hexadecimal/discuss/84909/Python-solution-in-10-lines-of-code\n\nclass Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        hex_str = ''\n        while num!= 0:\n            hex_str = hex_str + str(num % 16)\n            num = num / 16\n        hex_str = hex_str[::-1]\n        return hex_str\n\n    def toDecimal(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        decimal_str = ''\n        for i in range(0, len(num) - 1):\n            decimal_str = decimal_str + str(int(num[i] + num[i + 1], 16))\n        return int(decimal_str)\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.toHex(123))\n    print(s.toHex(12345))\n    print(s.toDecimal('A'))\n    print(s.toDecimal('AA'))\n    print(s.toDecimal('A'))"
    },
    {
      "rank": 28,
      "score": 9.780659283434257,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return '<Point %r, %r>' % (self.x, self.y)\n\nclass Solution:\n    def pointsToTuple(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        result = []\n        for point in points:\n            result.append((point.x, point.y))\n        return result\n\n\nif __name__ == '__main__':\n    points = [Point(1, 2), Point(2, 2), Point(3, 3)]\n    points = [Point(3, 3), Point(3, 3), Point(3, 3)]\n    points = [Point(2, 2), Point(3, 3), Point(2, 2)]\n    points = [Point(1, 1), Point(2, 2), Point(2, 2)]\n    points = [Point(3, 3), Point(3, 3), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(1, 1), Point(1, 1), Point(1, 1)]\n    points = [Point(1, 1), Point(2, 2), Point(3, 3)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(3, 3)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point(2, 2), Point(2, 2), Point(2, 2)]\n    points = [Point"
    },
    {
      "rank": 29,
      "score": 9.769846519895975,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        def buildTree(left, right, root):\n            if not left and not right:\n                return root\n            if left and right:\n                root = TreeNode(nums[left])\n                root.left = buildTree(left, right - 1, root)\n                root.right = buildTree(left + 1, right, root)\n            return root\n\n        root = TreeNode(nums[0])\n        return buildTree(0, len(nums) - 1, root)"
    },
    {
      "rank": 30,
      "score": 9.62384610883795,
      "candidate": "class Solution(object):\n    def sortedSetToTuple(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(set) == 0:\n            return []\n        sorted_set = list(set)\n        sorted_set.sort()\n        return [sorted_set[i] for i in range(len(sorted_set))]"
    },
    {
      "rank": 31,
      "score": 9.593289747812571,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if nums == None or len(nums) == 0:\n            return None\n        return self.sortedArrayToBSTHelper(nums, 0, len(nums)-1)\n\n    def sortedArrayToBSTHelper(self, nums, start, end):\n        if start > end:\n            return None\n        mid = (start + end) / 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBSTHelper(nums, start, mid-1)\n        root.right = self.sortedArrayToBSTHelper(nums, mid+1, end)\n        return root\n\n# Note:\n# We can use a stack to store the nodes in the BST\n# Instead of recursion, we can use a queue"
    },
    {
      "rank": 32,
      "score": 9.584913159009853,
      "candidate": "class Solution(object):\n    def setToArray(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return sorted(set)\n\n    def setToArray2(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return [x for x in sorted(set)]\n\n    def setToArray3(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(sorted(set))\n\n    def setToArray4(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return sorted(set)\n\n    def setToArray5(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(set)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print s.setToArray(set())\n    print s.setToArray2(set())\n    print s.setToArray3(set())\n    print s.setToArray4(set())\n    print s.setToArray5(set())"
    },
    {
      "rank": 33,
      "score": 9.497302523275074,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __str__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def sortedSetToTuple(self, set):\n        \"\"\"\n        :type set: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        result = []\n        for e in set:\n            result.append(e)\n        result.sort()\n        return result"
    },
    {
      "rank": 34,
      "score": 9.333712157880877,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of ordered tuples, [ (num1, num2), (num3, num4) ]\n    def orderedSetToTuple(self, set):\n        if not set: return []\n        result = []\n        for number in set:\n            result.append((number,))\n        result.sort()\n        return result"
    },
    {
      "rank": 35,
      "score": 8.444444444444445,
      "candidate": "def set_to_tuple(set_to_convert):\n    \"\"\"\n    :type set_to_convert: List[int]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    tuple_list = []\n    for element in set_to_convert:\n        tuple_list.append((element,))\n    return tuple_list"
    },
    {
      "rank": 36,
      "score": 8.444444444444445,
      "candidate": "from collections import defaultdict\n\ndef set_to_tuple(set_input):\n    \"\"\"\n    Convert the given set into an ordered tuple.\n\n    :type set_input: set\n    :rtype: tuple\n    \"\"\"\n    d = defaultdict(list)\n    for element in set_input:\n        d[element].append(element)\n\n    return tuple(d.keys())\n\nif __name__ == '__main__':\n    assert set_to_tuple([1, 2, 3]) == (1, 2, 3)\n    assert set_to_tuple([1, 2, 3, 1]) == (1, 2, 3)\n    assert set_to_tuple([1, 2, 3, 4]) == (1, 2, 3, 4)\n    assert set_to_tuple([1, 2, 3, 4, 5, 6]) == (1, 2, 3, 4, 5, 6)"
    },
    {
      "rank": 37,
      "score": 8.444444444444445,
      "candidate": "def to_tuples(s):\n    return tuple(map(int, s))\n\nif __name__ == '__main__':\n    print(to_tuples('3,4,5'))\n    print(to_tuples('1,2,3'))\n    print(to_tuples('1,3,5'))\n    print(to_tuples('1,2,3,5'))\n    print(to_tuples('1,2,3,5,6'))"
    },
    {
      "rank": 38,
      "score": 8.444444444444445,
      "candidate": "def set_to_tuple(set_to_convert):\n    \"\"\"\n    Given a set of numbers, convert it into a tuple.\n\n    Example\n    >>> set_to_tuple({1, 2, 3})\n    (1, 2, 3)\n    >>> set_to_tuple({2, 3, 4, 1, 2})\n    (2, 3, 4, 1, 2)\n    >>> set_to_tuple({4, 1, 2})\n    (4, 1, 2)\n    \"\"\"\n    return tuple(sorted(set_to_convert))\n\ndef test_set_to_tuple():\n    assert set_to_tuple({1, 2, 3}) == (1, 2, 3)\n    assert set_to_tuple({2, 3, 4, 1, 2}) == (2, 3, 4, 1, 2)\n    assert set_to_tuple({4, 1, 2}) == (4, 1, 2)"
    },
    {
      "rank": 39,
      "score": 8.444444444444445,
      "candidate": "def set_to_tuple(set_):\n    tuple_ = []\n    for x in set_:\n        tuple_.append(x)\n    return tuple_\n\ndef tuple_to_set(tuple_):\n    set_ = []\n    for x in tuple_:\n        set_.append(x)\n    return set_\n\ndef main():\n    set_ = set(range(1, 7))\n    tuple_ = set_to_tuple(set_)\n    print(tuple_)\n    set_ = tuple_to_set(tuple_)\n    print(set_)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 40,
      "score": 8.444444444444445,
      "candidate": "def set2tuple(s):\n    \"\"\"\n    :type s: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return sorted(s)\n\nif __name__ == \"__main__\":\n    s = [1,2,3,4,5,6,7,8,9,10]\n    t = set2tuple(s)\n    print t\n    s = [1,2,3,4,5,6,7,8,9,10]\n    t = set2tuple(s)\n    print t"
    },
    {
      "rank": 41,
      "score": 8.444444444444445,
      "candidate": "import random\n\ndef get_random_tuple():\n    \"\"\"\n    Get a random tuple.\n    \"\"\"\n    return tuple(random.sample(range(1, 11), random.randint(1, 4)))\n\ndef convert_set_to_tuple(set_):\n    \"\"\"\n    Convert a set into a tuple.\n    \"\"\"\n    tuple_ = get_random_tuple()\n    while tuple_ in set_:\n        tuple_ = get_random_tuple()\n    set_.add(tuple_)\n    return tuple_\n\ndef convert_set_to_tuple_2(set_):\n    \"\"\"\n    Convert a set into a tuple.\n    \"\"\"\n    tuple_ = tuple(set_)\n    set_.remove(tuple_)\n    return tuple_\n\ndef convert_set_to_tuple_3(set_):\n    \"\"\"\n    Convert a set into a tuple.\n    \"\"\"\n    tuple_ = tuple(set_)\n    set_.remove(tuple_)\n    return tuple_\n\nif __name__ == '__main__':\n    set_ = set(range(1, 11))\n    for i in range(10000):\n        tuple_ = convert_set_to_tuple(set_)\n        print tuple_"
    },
    {
      "rank": 42,
      "score": 8.444444444444445,
      "candidate": "def convert_set_to_tuple(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for element in set_:\n        if element not in result:\n            result.append(element)\n    return result\n\n\nif __name__ == '__main__':\n    set_ = [1, 2, 3]\n    result = convert_set_to_tuple(set_)\n    print(result)"
    },
    {
      "rank": 43,
      "score": 8.444444444444445,
      "candidate": "class Solution(object):\n    def set2tuple(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in xrange(len(s)):\n            res.append(s[i])\n            res.append(i)\n        return res"
    },
    {
      "rank": 44,
      "score": 8.444444444444445,
      "candidate": "def to_tuple(set_):\n    return tuple(set_.pop())\n\ndef to_tuple_list(set_):\n    return list(set_.pop())\n\ndef to_tuple_dict(set_):\n    return dict(set_.pop())\n\ndef to_tuple_set(set_):\n    return set(set_.pop())\n\ndef to_tuple_str(set_):\n    return ','.join(set_.pop())\n\ndef to_tuple_str_dict(set_):\n    return ','.join('{}={}'.format(k,v) for k,v in set_.pop().items())\n\ndef to_tuple_str_list(set_):\n    return ','.join('{}'.format(v) for v in set_.pop())\n\ndef to_tuple_str_set(set_):\n    return ','.join(set_.pop())\n\nif __name__ == '__main__':\n    assert to_tuple(set()) == ()\n    assert to_tuple_list(set()) == []\n    assert to_tuple_dict(set()) == {}\n    assert to_tuple_set(set()) == set()\n    assert to_tuple_str(set()) == ''\n    assert to_tuple_str_dict(set()) == {}\n    assert to_tuple_str_list(set()) == []\n    assert to_tuple_str_set(set()) == set()\n    assert to_tuple_str_set(set(['a', 'b', 'c'])) == set(['a', 'b', 'c'])"
    },
    {
      "rank": 45,
      "score": 8.444444444444445,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of tuples, which are the elements of the original set sorted lexicographically\n    def sortedSet(self, set):\n        res = []\n        for i in set:\n            for j in res:\n                if i < j[0]:\n                    res.insert(i, j)\n                    break\n            else:\n                res.append((i,))\n        return res"
    },
    {
      "rank": 46,
      "score": 8.444444444444445,
      "candidate": "class Solution(object):\n    def set2tuple(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        return sorted(s, key=lambda x: x)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    s = [1,2,3,4,5]\n    t = sol.set2tuple(s)\n    print t"
    },
    {
      "rank": 47,
      "score": 8.444444444444445,
      "candidate": "def set_to_tuple(set):\n    return tuple(sorted(set))\n\ndef test_set_to_tuple():\n    assert set_to_tuple([1, 2, 3]) == (1, 2, 3)\n    assert set_to_tuple([1, 3, 2]) == (1, 2, 3)\n    assert set_to_tuple([2, 1, 3]) == (2, 1, 3)\n    assert set_to_tuple([3, 1, 2]) == (3, 1, 2)\n\nif __name__ == '__main__':\n    test_set_to_tuple()"
    },
    {
      "rank": 48,
      "score": 8.444444444444445,
      "candidate": "def set_to_tuple(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    tuple_list = []\n    for i in range(len(set_)):\n        tuple_list.append((set_[i],))\n    return tuple_list\n\nif __name__ == '__main__':\n    s = set([1, 2, 3])\n    print(set_to_tuple(s))"
    },
    {
      "rank": 49,
      "score": 8.444444444444445,
      "candidate": "import random\n\ndef ordered_tuples(items):\n    return [tuple(random.sample(items, i)) for i in range(1, len(items) + 1)]\n\nprint(ordered_tuples([1, 2, 3, 4]))\nprint(ordered_tuples(['a', 'b', 'c']))\nprint(ordered_tuples(['a', 'b', 'c', 'd']))"
    },
    {
      "rank": 50,
      "score": 8.444444444444445,
      "candidate": "# Definition for a point.\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\n    def __repr__(self):\n        return '<Point %r, %r>' % (self.x, self.y)\n\nclass Solution(object):\n    def __init__(self):\n        self.point_map = {}\n\n    def convert(self, points, n):\n        \"\"\"\n        :type points: List[Point]\n        :type n: int\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        if n == 1:\n            return [tuple(p) for p in points]\n        return self.convert(points[:-1], n-1) + [(points[-1].x, points[-1].y)]\n\n    def convert_recursive(self, points, n):\n        \"\"\"\n        :type points: List[Point]\n        :type n: int\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        if n == 1:\n            return [tuple(p) for p in points]\n        return [tuple(p) for p in self.convert_recursive(points[:-1], n-1)] + [(points[-1].x, points[-1].y)]\n\n    def convert_iterative(self, points, n):\n        \"\"\"\n        :type points: List[Point]\n        :type n: int\n        :rtype: List[Tuple[int, int]]\n        \"\"\"\n        if n == 1:\n            return [tuple(p) for p in points]\n        return [tuple(p) for p in points] + [(points[-1].x, points[-1].y)]\n\na = [Point(1, 1), Point(2, 1), Point(3, 1), Point(4, 1)]\nb = [Point(1, 2), Point(2, 2), Point(3, 2), Point(4, 2)]\nc = [Point(1, 3), Point(2, 3), Point(3, 3), Point(4, 3)]\nd"
    },
    {
      "rank": 51,
      "score": 3.926139092254469,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        return self.helper(nums)\n\n    def helper(self, nums):\n        if not nums:\n            return None\n        if len(nums) == 1:\n            return TreeNode(nums[0])\n        mid = len(nums) / 2\n        left = self.helper(nums[:mid])\n        right = self.helper(nums[mid:])\n        return TreeNode(nums[mid], left, right)"
    },
    {
      "rank": 52,
      "score": 3.782321827907003,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of tuples (one for each element in set),\n    # each tuple is in sorted order\n    def sortedSetToTuple(self, set):\n        return [ (x, i) for i, x in enumerate(set) ]\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.sortedSetToTuple([1, 3, 2]))"
    },
    {
      "rank": 53,
      "score": 3.7690182832329846,
      "candidate": "class Solution(object):\n    def orderedSet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i == 0:\n                res.append((nums[i],))\n            else:\n                res.append((nums[i], res[i-1][1]))\n        return res"
    },
    {
      "rank": 54,
      "score": 3.761514928204013,
      "candidate": "def to_tuple(s):\n    return tuple(s)\n\ndef to_tuple_2(s):\n    return tuple(s)\n\ndef to_tuple_3(s):\n    return tuple(s)\n\ndef to_tuple_4(s):\n    return tuple(s)\n\ndef to_tuple_5(s):\n    return tuple(s)\n\ndef to_tuple_6(s):\n    return tuple(s)\n\ndef to_tuple_7(s):\n    return tuple(s)\n\ndef to_tuple_8(s):\n    return tuple(s)\n\ndef to_tuple_9(s):\n    return tuple(s)\n\ndef to_tuple_10(s):\n    return tuple(s)\n\ndef to_tuple_11(s):\n    return tuple(s)\n\ndef to_tuple_12(s):\n    return tuple(s)\n\ndef to_tuple_13(s):\n    return tuple(s)\n\ndef to_tuple_14(s):\n    return tuple(s)\n\ndef to_tuple_15(s):\n    return tuple(s)\n\ndef to_tuple_16(s):\n    return tuple(s)\n\ndef to_tuple_17(s):\n    return tuple(s)\n\ndef to_tuple_18(s):\n    return tuple(s)\n\ndef to_tuple_19(s):\n    return tuple(s)\n\ndef to_tuple_20(s):\n    return tuple(s)\n\ndef to_tuple_21(s):\n    return tuple(s)\n\ndef to_tuple_22(s):\n    return tuple(s)\n\ndef to_tuple_23(s):\n    return tuple(s)\n\ndef to_tuple_24(s):\n    return tuple(s)\n\ndef to_tuple_25(s):\n    return tuple(s)\n\ndef to_tuple_26(s):\n    return tuple(s)\n\ndef to_tuple_27(s):\n    return tuple(s)"
    },
    {
      "rank": 55,
      "score": 3.738947022370758,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[Tuple[int]]\n        \"\"\"\n        return sorted(S)"
    },
    {
      "rank": 56,
      "score": 3.732824384460777,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of tuples, each tuple contains integers\n    def convert(self, set):\n        if not set:\n            return []\n\n        res = []\n        for num in set:\n            res.append((num,))\n            res.append(res[-1])\n        return res"
    },
    {
      "rank": 57,
      "score": 3.5154997612479755,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not nums:\n            return None\n        if len(nums) == 1:\n            return TreeNode(nums[0])\n        mid = len(nums) / 2\n        left = self.sortedArrayToBST(nums[:mid])\n        right = self.sortedArrayToBST(nums[mid:])\n        return TreeNode(nums[mid], left, right)"
    },
    {
      "rank": 58,
      "score": 3.501766448946012,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_2(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list[::-1]\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_3(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list[::-1]\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_4(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list[::-1]\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_5(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list[::-1]\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_6(self, set):\n        tuple_list = []\n        for value in set:\n            tuple_list.append(value)\n        tuple_list.sort()\n        return tuple_list[::-1]\n\n    # @param set, a set of integers\n    # @return a tuple\n    def sortedSet2Tuple_7(self, set):\n        tuple_list = []"
    },
    {
      "rank": 59,
      "score": 3.4112724560515946,
      "candidate": "# Definition for a tuple.\nclass Tuple:\n    def __init__(self, x):\n        self.x = x\n\n    def __lt__(self, other):\n        return self.x < other.x\n\n    def __repr__(self):\n        return str(self.x)\n\nclass Solution(object):\n    def tupleToArray(self, t):\n        \"\"\"\n        :type t: List[Tuple]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(t)):\n            res.append(t[i].x)\n        return res\n\nif __name__ == '__main__':\n    s = Solution()\n    # s.tupleToArray([(1, 2), (3, 4)])\n    s.tupleToArray([(1, 2), (3, 4)])"
    },
    {
      "rank": 60,
      "score": 3.410951252187612,
      "candidate": "from collections import OrderedDict\n\n\nclass Solution(object):\n    def set2tuple(self, set_):\n        \"\"\"\n        :type set_: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        return list(OrderedDict.fromkeys(set_))\n\n\nif __name__ == \"__main__\":\n    assert Solution().set2tuple([1, 2, 3]) == [\n        (1,),\n        (2,),\n        (3,),\n    ]\n    assert Solution().set2tuple([1, 2, 3, 4, 5]) == [\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 5),\n    ]"
    },
    {
      "rank": 61,
      "score": 3.3238442690503462,
      "candidate": "# Definition for a point.\n# class Point:\n#     def __init__(self, a=0, b=0):\n#         self.x = a\n#         self.y = b\n\nclass Solution:\n    # @param points, a list of Points\n    # @return a list of Points\n    def pointToTuple(self, points):\n        res = []\n        for p in points:\n            res.append((p.x, p.y))\n        return res"
    },
    {
      "rank": 62,
      "score": 3.305838144420434,
      "candidate": "from collections import defaultdict\n\nclass Solution(object):\n    def convertToArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        count = defaultdict(int)\n        for i in nums:\n            count[i] += 1\n        for i in nums:\n            if count[i] == 1:\n                res.append([i])\n            else:\n                res.append([i] + self.convertToArray(nums[i:]))\n        return res"
    },
    {
      "rank": 63,
      "score": 3.2712800217929825,
      "candidate": "import collections\ndef set_to_tuple(set_obj):\n    \"\"\"\n    >>> set_to_tuple(set(['a','b','c'])).sort()\n    ('a', 'b', 'c')\n    >>> set_to_tuple(set(['a','b','c'])).sort()\n    ('a', 'b', 'c')\n    \"\"\"\n    tuples = set_obj.copy()\n    tuples.discard(None)\n    tuples = sorted(tuples)\n    return tuple(tuples)\n\n# Example\nset_obj = set(['a','b','c'])\nprint(set_to_tuple(set_obj))"
    },
    {
      "rank": 64,
      "score": 3.2483570765056164,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a list of tuples\n    def orderedSetToTuple(self, set):\n        res = []\n        for i in set:\n            res.append(i)\n            if len(set) == 1:\n                return res\n        while len(set) > 1:\n            # get the last value\n            last = set.pop()\n            # get the first value\n            first = set.pop()\n            # set the last value to the first value\n            set.add(first)\n            # set the first value to the last value\n            set.add(last)\n            # add the last value to the res\n            res.append(last)\n            # add the first value to the res\n            res.append(first)\n            # add the last value to the res\n            res.append(last)\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print sol.orderedSetToTuple([1,2,3,4,5])"
    },
    {
      "rank": 65,
      "score": 3.1878490091728358,
      "candidate": "# https://leetcode.com/problems/convert-a-number-to-hexadecimal/discuss/172692/Python-C%2B%2B-with-an-explanation-for-a-solution\n# TODO: use built-in to_hex instead\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def convert(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        hex = []\n        for i in range(len(s)):\n            val = ord(s[i]) - ord('0')\n            hex.append(val)\n        res = []\n        while hex:\n            res.append(hex[0])\n            hex = hex[1:]\n        return res\n\ns = Solution()\nprint s.convert('0')\nprint s.convert('1')\nprint s.convert('2')\nprint s.convert('10')\nprint s.convert('11')\nprint s.convert('12')\nprint s.convert('123')\nprint s.convert('1234')\nprint s.convert('12345')\nprint s.convert('123456')\nprint s.convert('1234567')\nprint s.convert('12345678')\nprint s.convert('123456789')\nprint s.convert('1234567890')\nprint s.convert('12345678901')\nprint s.convert('123456789012')\nprint s.convert('1234567890123')\nprint s.convert('12345678901234')\nprint s.convert('123456789012345')\nprint s.convert('1234567890123456')\nprint s.convert('12345678901234567')\nprint s.convert('123456789012345678')\nprint s.convert('12345678901234567"
    },
    {
      "rank": 66,
      "score": 3.180818012523817,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a tuple, (list)\n    def sortedSet(self, set):\n        if set is None or set == []:\n            return []\n        result = []\n        for num in set:\n            while set.index(num)!= 0:\n                set.remove(set[0])\n            result.append(num)\n        return tuple(result)\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.sortedSet([2, 3, 4, 5, 6, 7])"
    },
    {
      "rank": 67,
      "score": 3.1620419846973977,
      "candidate": "def set_to_tuple(set_):\n    if not isinstance(set_, set):\n        return set(set_)\n    else:\n        return tuple(sorted(set_))\n\n# Test Cases\n# set_to_tuple({1,2,3})\n# set_to_tuple({1,2,3,4})\n# set_to_tuple({1,2,3,4,5})\n\n# Complete the setToTuple function below.\n\ndef set_to_tuple(set_):\n    if not isinstance(set_, set):\n        return set(set_)\n    else:\n        return tuple(sorted(set_))\n\nif __name__ == \"__main__\":\n    s = set([1,2,3])\n    print(set_to_tuple(s))"
    },
    {
      "rank": 68,
      "score": 3.157123666297637,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        sorted_set = sorted(S)\n        for i in sorted_set:\n            res.append(i)\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    assert sol.orderedSetToTuple([1,2,3,4,5]) == [1, 2, 3, 4, 5]"
    },
    {
      "rank": 69,
      "score": 3.0984306179345618,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a tuple, (index1, index2)\n    def convert(self, set):\n        if not set:\n            return ()\n        res = []\n        res.append(0)\n        res.append(0)\n        for i in set:\n            res.append(i)\n            res[-1] += 1\n        return tuple(res)\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.convert([1, 2, 3, 4, 5, 6, 7, 8]))"
    },
    {
      "rank": 70,
      "score": 3.055461294854933,
      "candidate": "from collections import OrderedDict\n\n\nclass Solution(object):\n    def orderedSetToTuple(self, set_):\n        \"\"\"\n        :type set_: List[int]\n        :rtype: List[int]\n        \"\"\"\n        d = OrderedDict()\n        for v in set_:\n            d[v] = d.get(v, 0) + 1\n        res = []\n        for v in d:\n            res.append((v, d[v]))\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().orderedSetToTuple([1, 2, 3]) == [(1, 1), (2, 1), (3, 1)]"
    },
    {
      "rank": 71,
      "score": 3.045880388267751,
      "candidate": "import unittest\n\n\n# O(N) time. O(N) space.\nclass Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[Tuple[int]]\n        \"\"\"\n        return sorted(S)\n\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/ordered-set-to-tuple/solution/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n *"
    },
    {
      "rank": 72,
      "score": 3.043523534119086,
      "candidate": "class Solution(object):\n    def setToArray(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        array = []\n        for i in range(len(set)):\n            array.append(set[i])\n        return array\n\n    def setToArray2(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return [set.pop() for _ in range(len(set))]\n\n    def setToArray3(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        array = []\n        while set:\n            array.append(set.pop())\n        return array\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.setToArray([1,2,3,4])\n    print sol.setToArray2([1,2,3,4])\n    print sol.setToArray3([1,2,3,4])\n    print sol.setToArray([1,2,3,4])"
    },
    {
      "rank": 73,
      "score": 2.993251387631033,
      "candidate": "def convert_set_to_tuple(set_to_convert):\n    \"\"\"\n    :type set_to_convert: List[int]\n    :rtype: List[Tuple[int,...]]\n    \"\"\"\n    if not set_to_convert:\n        return []\n\n    tuple_list = []\n    for element in set_to_convert:\n        tuple_list.append((element,))\n\n    return tuple_list"
    },
    {
      "rank": 74,
      "score": 2.982086980445024,
      "candidate": "import collections\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.encode(s)\n# codec.decode(t)\n\nclass Codec:\n\n    def __init__(self):\n        self.table = collections.OrderedDict()\n        self.table['0'] = '0'\n        self.table['1'] = '1'\n        self.table['2'] = '2'\n        self.table['3'] = '3'\n        self.table['4'] = '4'\n        self.table['5'] = '5'\n        self.table['6'] = '6'\n        self.table['7'] = '7'\n        self.table['8'] = '8'\n        self.table['9'] = '9'\n        self.table['A'] = 'A'\n        self.table['B'] = 'B'\n        self.table['C'] = 'C'\n        self.table['D'] = 'D'\n        self.table['E'] = 'E'\n        self.table['F'] = 'F'\n        self.table['G'] = 'G'\n        self.table['H'] = 'H'\n        self.table['I'] = 'I'\n        self.table['J'] = 'J'\n        self.table['K'] = 'K'\n        self.table['L'] = 'L'\n        self.table['M'] = 'M'\n        self.table['N'] = 'N'\n        self.table['O'] = 'O'\n        self.table['P'] = 'P'\n        self.table['Q'] = 'Q'\n        self.table['R'] = 'R'\n        self.table['S'] = 'S'\n        self.table['T'] = 'T'\n        self.table['U'] = 'U'\n        self.table['V'] = 'V'\n        self.table['W'] = 'W'\n        self.table['X'] = 'X'\n        self.table['Y'] = 'Y'\n        self.table['Z'] = 'Z'\n\n    def encode(self, s):"
    },
    {
      "rank": 75,
      "score": 2.930867849414408,
      "candidate": "# Definition for a tuple.\nclass Tuple(object):\n    def __init__(self, x):\n        self.x = x\n    def __lt__(self, other):\n        return self.x < other.x\n\nclass Solution(object):\n    def sortedTupleList(self, tuples):\n        \"\"\"\n        :type tuples: List[Tuple]\n        :rtype: List[Tuple]\n        \"\"\"\n        tuples.sort()\n        res = []\n        for t in tuples:\n            res.append(t)\n        return res\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.sortedTupleList([(1,2), (3,5), (4,5)]))\n    print(sol.sortedTupleList([(1,2), (3,4), (4,5)]))\n    print(sol.sortedTupleList([(1,2), (3,5), (4,4)]))"
    },
    {
      "rank": 76,
      "score": 2.890164056081244,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        result = []\n        for i in range(len(S)):\n            for j in range(i, len(S)):\n                if S[i] < S[j]:\n                    result.append((S[i], S[j]))\n                    break\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.orderedSetToTuple([1, 2, 3, 4, 5]))\n    print(sol.orderedSetToTuple([5, 3, 2, 1]))\n    print(sol.orderedSetToTuple([1, 2, 3, 4, 5, 6]))\n    print(sol.orderedSetToTuple([1, 2, 3, 4, 5, 6, 7]))"
    },
    {
      "rank": 77,
      "score": 2.8541531251033616,
      "candidate": "class Solution(object):\n    def set2tuple(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == '{':\n                res.append('{')\n            elif s[i] == '}':\n                res.append('}')\n            else:\n                res.append(s[i])\n        return res"
    },
    {
      "rank": 78,
      "score": 2.8453938120743927,
      "candidate": "class Solution(object):\n    def sortedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(S)\n        if n == 0:\n            return []\n        # sort S in ascending order\n        S.sort()\n        # construct the output\n        tuples = []\n        for i in range(0, n):\n            # if the current item in S is the first item in tuple\n            if i == 0:\n                tuples.append(S[i])\n            # if the current item in S is the second item in tuple\n            elif i == 1:\n                tuples.append(S[i])\n                tuples.append(S[i])\n            # if the current item in S is the third item in tuple\n            elif i == 2:\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n            # if the current item in S is the forth item in tuple\n            elif i == 3:\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n            # if the current item in S is the fifth item in tuple\n            elif i == 4:\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n                tuples.append(S[i])\n        return tuples\n\n\nif __name__ == \"__main__\":\n    print Solution().sortedSetToTuple([1,2,3,4,5])\n    print Solution().sortedSetToTuple([-1,1,2,3,4,5])"
    },
    {
      "rank": 79,
      "score": 2.8074588597918417,
      "candidate": "class Solution(object):\n    def setToTuple(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        return sorted(set)"
    },
    {
      "rank": 80,
      "score": 2.768291153593769,
      "candidate": "def set_to_tuple(set_):\n    \"\"\"\n    :type set_: List[int]\n    :rtype: List[int]\n    \"\"\"\n    return list(map(lambda x: x, set_))\n\n# Your SetToTuple solution here."
    },
    {
      "rank": 81,
      "score": 2.7671351232148718,
      "candidate": "class Solution:\n    # @param s, a string\n    # @return a list of tuples\n    def stringToTuple(self, s):\n        t = []\n        for i in range(len(s)):\n            if i == 0 or s[i - 1] == '(' or s[i] == ')':\n                t.append(s[i])\n        return t\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.stringToTuple('()())')\n    print sol.stringToTuple('(())')\n    print sol.stringToTuple('(()(())')"
    },
    {
      "rank": 82,
      "score": 2.760412881077355,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return sorted(S)"
    },
    {
      "rank": 83,
      "score": 2.7408648908631763,
      "candidate": "class Solution(object):\n    def setToArray(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in set:\n            result.append(x)\n        return result\n\n    def setToArray2(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in set:\n            if result and result[-1]!= x:\n                result.append(x)\n            else:\n                result.append(x)\n                result.append(x)\n        return result\n\n    def setToArray3(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in set:\n            result.append(x)\n        return result"
    },
    {
      "rank": 84,
      "score": 2.7278086377374087,
      "candidate": "class Solution:\n    # @param set, a set of integers\n    # @return a tuple\n    def setToTuple(self, set):\n        tuple_list = []\n        for item in set:\n            tuple_list.append(item)\n        return tuple(tuple_list)\n\n    def convert(self, nums, k):\n        if k == 0:\n            return self.setToTuple(nums)\n        else:\n            return self.convert(nums, k - 1) + self.convert(nums, k - 1)"
    },
    {
      "rank": 85,
      "score": 2.718856235379514,
      "candidate": "class Solution(object):\n    def sortedSet2tuple(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        i = 0\n        while i < len(set):\n            res.append(set[i])\n            i += 1\n        res.sort()\n        return res\n\nif __name__ == '__main__':\n    assert Solution().sortedSet2tuple([1, 2, 3]) == [1, 2, 3]\n    assert Solution().sortedSet2tuple([3, 2, 1]) == [1, 2, 3]"
    },
    {
      "rank": 86,
      "score": 2.6996806550405976,
      "candidate": "from collections import Counter\n\n\nclass Solution:\n    def orderedSet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[tuple]\n        \"\"\"\n        nums.sort()\n        count = Counter(nums)\n        result = []\n        for key in count.keys():\n            result.append((key, count[key]))\n        return result\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.orderedSet([1,2,3,4,5,6,7,8]))"
    },
    {
      "rank": 87,
      "score": 2.6400778958026456,
      "candidate": "import collections\n\nclass Solution:\n    def setToTuple(self, set_):\n        \"\"\"\n        :type set_: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not set_:\n            return []\n\n        # The idea is to use a heap to store all the items in the set\n        # when we remove them from the set, we need to make sure that\n        # we can find the correct position of the item in the set.\n        # That is, if we remove the first item from the set, we need\n        # to reorder the heap to make sure that the item we remove is\n        # the last one.\n        # Note that we do not use a sorted set because the sort is\n        # expensive.\n        heap = collections.deque()\n        for i in set_:\n            heap.append((i, i))\n\n        # Remove all the items from the set\n        while len(heap) > 1:\n            # Remove the first item\n            item, item_id = heap.popleft()\n\n            # Remove the second item\n            heap.popleft()\n\n            # Add the second item to the set\n            heap.append((item, item_id))\n\n        return [item for _, item in heap]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    set_ = [1, 2, 3, 4, 5]\n    print(s.setToTuple(set_))\n\n    set_ = [1, 2, 3, 4, 5, 6]\n    print(s.setToTuple(set_))\n\n    set_ = [1, 2, 3, 4, 5, 6, 7]\n    print(s.setToTuple(set_))\n\n    set_ = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(s.setToTuple(set_))"
    },
    {
      "rank": 88,
      "score": 2.580391238388681,
      "candidate": "def convert_set_to_ordered_tuple(set_input):\n    \"\"\"\n    :type set_input: List[int]\n    :rtype: List[Tuple[int, int]]\n    \"\"\"\n    return sorted(set_input, key=lambda x: x)\n\n\ndef test_convert_set_to_ordered_tuple():\n    assert convert_set_to_ordered_tuple([4, 3, 2, 1]) == [(1, 3), (2, 4), (3, 1)]"
    },
    {
      "rank": 89,
      "score": 2.5459879622393946,
      "candidate": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 1:\n            return [[int(s)]]\n        else:\n            return [\n                [int(s[i:i+numRows]) for i in range(0, len(s), numRows)]\n                for _ in range(numRows)\n            ]\n\ns = Solution()\ns.convert(\"PAYPALISHIRING\", 2)"
    },
    {
      "rank": 90,
      "score": 2.493584439832788,
      "candidate": "class Solution:\n    def setToArray(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        ret = []\n        ret.append(set.pop())\n        while set:\n            ret.append(set.pop())\n        return ret\n\n\nif __name__ == '__main__':\n    sol = Solution()\n    print(sol.setToArray(set(range(4))))\n    print(sol.setToArray(set(range(4))))"
    },
    {
      "rank": 91,
      "score": 2.4711445355220496,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def set2tuple(self, set_):\n        \"\"\"\n        :type set_: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(set_)\n        res = []\n        for i in range(n):\n            res.append((set_[i], i))\n\n        res.sort(key=lambda x: x[0])\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().set2tuple([1, 2, 3]) == [1, (2, 0), (3, 1)]\n    assert Solution().set2tuple([4, 1, 2, 3]) == [4, (1, 0), (2, 1), (3, 2)]\n    assert Solution().set2tuple([1, 2, 3, 4]) == [1, (2, 0), (3, 1), (4, 2)]"
    },
    {
      "rank": 92,
      "score": 2.4245032112888487,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def serialize(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        result = []\n        self.helper(root, result)\n        return '(' + ','.join(result) + ')'\n\n    def helper(self, root, result):\n        if root is None:\n            return\n        result.append(str(root.val))\n        self.helper(root.left, result)\n        self.helper(root.right, result)"
    },
    {
      "rank": 93,
      "score": 2.3359069755507846,
      "candidate": "# https://leetcode.com/problems/set-difference/\n\n\nclass Solution(object):\n    def set_difference(self, set1, set2):\n        \"\"\"\n        :type set1: List[int]\n        :type set2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not set1 or not set2:\n            return []\n        result = []\n        for elem in set1:\n            if elem not in set2:\n                result.append(elem)\n        return result\n\n\nif __name__ == '__main__':\n    assert Solution().set_difference([1, 2, 3], [2, 3]) == [1]\n    assert Solution().set_difference([1, 2, 3], [2, 3, 4]) == [1, 3]\n    assert Solution().set_difference([1, 2, 3, 4], [2, 3, 4]) == []"
    },
    {
      "rank": 94,
      "score": 2.293848149332354,
      "candidate": "def to_tuple(set_of_numbers):\n    \"\"\"\n    :type set_of_numbers: list[int]\n    :rtype: list[tuple[int]]\n    \"\"\"\n    return list(map(tuple, set_of_numbers))\n\nif __name__ == \"__main__\":\n    assert to_tuple([2, 4, 6, 8]) == [(2, 4, 6, 8)]\n    assert to_tuple([4, 8, 2, 1]) == [(4, 8, 2, 1)]\n    assert to_tuple([1, 2, 3, 4, 5, 6, 7, 8]) == [(1, 2, 3, 4, 5, 6, 7, 8)]\n    assert to_tuple([4, 6, 8, 2, 1]) == [(4, 6, 8, 2, 1)]\n    assert to_tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)]\n    assert to_tuple([4, 6, 8, 2, 1, 3, 5, 7, 9, 10]) == [(4, 6, 8, 2, 1, 3, 5, 7, 9, 10)]\n    assert to_tuple([4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11]) == [(4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11)]\n    assert to_tuple([4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11, 12]) == [(4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11, 12)]\n    assert to_tuple([4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11, 12, 13]) == [(4, 6, 8, 2, 1, 3, 5, 7, 9, 10, 11, 12, 13)]"
    },
    {
      "rank": 95,
      "score": 2.287625906893272,
      "candidate": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def convertBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def helper(root):\n            if not root:\n                return []\n            ans = []\n            ans.append(root.val)\n            ans.extend(helper(root.left))\n            ans.extend(helper(root.right))\n            return ans\n\n        return helper(root)"
    },
    {
      "rank": 96,
      "score": 2.137541083743484,
      "candidate": "class Solution(object):\n    def setToArray(self, set):\n        \"\"\"\n        :type set: Set[int]\n        :rtype: List[int]\n        \"\"\"\n        def convert(x):\n            return x,\n        return [convert(x) for x in set]"
    },
    {
      "rank": 97,
      "score": 2.118479922318633,
      "candidate": "def set_to_tuple(set_obj):\n    \"\"\"\n    :type set_obj: List[int]\n    :rtype: List[Tuple[int]]\n    \"\"\"\n    result = []\n    for elem in set_obj:\n        result.append((elem,))\n    return result\n\nif __name__ == \"__main__\":\n    set_obj = [1, 2, 3]\n    print(set_to_tuple(set_obj))"
    },
    {
      "rank": 98,
      "score": 2.043359877671101,
      "candidate": "class Solution:\n    \"\"\"\n    @param set: A set of integers\n    @return: An ordered list of integers\n    \"\"\"\n    def orderedList(self, set):\n        if set is None:\n            return []\n        # Use a map to store the index of the set, and then sort by the\n        # value of the set.\n        map_set = {}\n        for i in set:\n            map_set[i] = i\n        # Sort the set by the value.\n        return sorted(map_set.values(), reverse=True)\n\n\nclass Solution2:\n    \"\"\"\n    @param set: A set of integers\n    @return: An ordered list of integers\n    \"\"\"\n    def orderedList(self, set):\n        if set is None:\n            return []\n        # Use a map to store the index of the set, and then sort by the\n        # value of the set.\n        map_set = {}\n        for i in set:\n            map_set[i] = i\n        # Sort the set by the value.\n        return sorted(map_set.items(), reverse=True)"
    },
    {
      "rank": 99,
      "score": 2.006215542699554,
      "candidate": "class Solution(object):\n    def set2tuple(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not s:\n            return []\n        res = []\n        for num in s:\n            res.append(num)\n            res.append(s.index(num) + 1)\n        return res\n\n    def tuple2set(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not s:\n            return []\n        res = []\n        for num in s:\n            res.append(num)\n            res.append(s.index(num) + 1)\n        return res\n\n    def set2list(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            res.append(s[i])\n            res.append(i + 1)\n        return res\n\n    def list2set(self, s):\n        \"\"\"\n        :type s: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            res.append(s[i])\n            res.append(i + 1)\n        return res\n\n\nif __name__ == \"__main__\":\n    assert Solution().set2tuple([1, 2, 3]) == [1, 2, 3]\n    assert Solution().tuple2set([1, 2, 3]) == [1, 2, 3]\n    assert Solution().set2list([1, 2, 3]) == [1, 2, 3]\n    assert Solution().list2set([1, 2, 3]) == [1, 2, 3]"
    },
    {
      "rank": 100,
      "score": 1.6901274479551278,
      "candidate": "class Solution(object):\n    def orderedSetToTuple(self, S):\n        \"\"\"\n        :type S: List[int]\n        :rtype: List[Tuple[int]]\n        \"\"\"\n        res = []\n        for i in range(len(S)):\n            for j in range(i, len(S)):\n                if S[i] > S[j]:\n                    res.append((S[i], S[j]))\n                    S[i], S[j] = S[j], S[i]\n        res.sort()\n        return [t for t in res]\n\nif __name__ == '__main__':\n    sol = Solution()\n    print sol.orderedSetToTuple([1,2,3,4,5,6])"
    }
  ]
}