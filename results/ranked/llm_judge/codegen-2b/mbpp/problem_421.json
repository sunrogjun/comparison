{
  "timestamp": "2025-09-14T20:29:46.897406",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codegen-2b",
  "dataset": "mbpp",
  "problem_number": 421,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        if not nums1 or not nums2:\n            return float('nan')\n        m1 = len(nums1)\n        m2 = len(nums2)\n        l = m1 + m2\n        if l % 2:\n            return float('nan')\n        else:\n            l = l / 2\n            return (nums1[l-1] + nums2[l-1]) / 2.0"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# https://www.hackerrank.com/challenges/median-of-a-triangle\n\nimport math\n\ndef find_median_of_a_triangle(n):\n    if n == 0:\n        return None\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n % 2 == 0:\n        return find_median_of_a_triangle(n/2) + find_median_of_a_triangle(n/2)\n    else:\n        return find_median_of_a_triangle(n/2) + find_median_of_a_triangle(n/2+1)\n\n\nprint find_median_of_a_triangle(5)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: Return the median of all nodes.\n    \"\"\"\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        # find median of nums1\n        n1 = len(nums1)\n        if n1 == 0:\n            return None\n        m1 = nums1[n1 / 2]\n        # find median of nums2\n        n2 = len(nums2)\n        if n2 == 0:\n            return None\n        m2 = nums2[n2 / 2]\n        # find median of both nums1 and nums2\n        if n1 % 2 == 0:\n            if n2 % 2 == 0:\n                return (m1 + m2) / 2.0\n            else:\n                return m1\n        else:\n            if n2 % 2 == 0:\n                return m2\n            else:\n                return (m1 + m2) / 2.0"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# Definition for a  binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # @param {TreeNode} root\n    # @return {number}\n    def findMedianSortedArrays(self, root):\n        if root is None:\n            return 0\n        left = self.findMedianSortedArrays(root.left)\n        right = self.findMedianSortedArrays(root.right)\n        if left is None and right is None:\n            return root.val\n        if left is None:\n            return right\n        if right is None:\n            return left\n        if left+right > root.val:\n            return (left+right+root.val)/2\n        return (left+right)/2"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param A, a list of integers\n    # @return an integer\n    def findMedianSortedArrays(self, A):\n        if not A: return None\n        return self.findMedianSortedArrays(A[:len(A)/2], A[len(A)/2:])\n\n    def findMedianSortedArrays(self, A, B):\n        if not A: return None\n        if not B: return None\n        return (A[len(A)/2] + B[len(B)/2])/2"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# Your code here\n\n# https://www.hackerrank.com/challenges/median-of-a-trapezium/problem\n\n# Median of a trapezium is the average of the bottom and top\n# of the trapezium.\n# The median of a trapezium is the average of the bottom and top\n# of the trapezium.\n\ndef median_of_a_trapezium(arr):\n    return (arr[0] + arr[1] + arr[2]) / 3.0\n\nif __name__ == '__main__':\n    # arr = [1, 2, 3, 4, 5]\n    arr = [1, 2, 3, 4, 5, 6]\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from math import sqrt\n\nclass Solution:\n    # @return an integer\n    def findMedianSortedArrays(self, nums1, nums2):\n        nums1.sort()\n        nums2.sort()\n        m = len(nums1) + len(nums2)\n        if m % 2 == 1:\n            return (nums1[m/2] + nums2[m/2]) / 2\n        else:\n            return (nums1[m/2-1] + nums1[m/2]) / 2\n\n    # @return an integer\n    def findMedianSortedArrays2(self, nums1, nums2):\n        nums1.sort()\n        nums2.sort()\n        m = len(nums1) + len(nums2)\n        if m % 2 == 1:\n            return (nums1[m/2-1] + nums2[m/2-1]) / 2\n        else:\n            return (nums1[m/2] + nums2[m/2]) / 2\n\nif __name__ == '__main__':\n    s = Solution()\n    print s.findMedianSortedArrays([1,2,3], [4,5,6])\n    print s.findMedianSortedArrays([4,5,6], [1,2,3])\n    print s.findMedianSortedArrays([4,5,6], [1,2,3,4,5,6])"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from math import ceil\nfrom math import floor\n\n\ndef median(data):\n    n = len(data)\n    if n % 2 == 0:\n        return (ceil(data[n // 2 - 1] + data[n // 2]) / 2)\n    else:\n        return (data[n // 2])\n\n\ndef main():\n    test_cases = [\n        ([1, 2, 3, 4, 5], 3),\n        ([1, 2, 3, 4, 5], 5),\n        ([1, 2, 3, 4, 5], 7),\n        ([1, 2, 3, 4, 5], 9),\n        ([1, 2, 3, 4, 5], 10),\n        ([1, 2, 3, 4, 5], 15),\n        ([1, 2, 3, 4, 5], 20),\n        ([1, 2, 3, 4, 5], 25),\n        ([1, 2, 3, 4, 5], 30),\n        ([1, 2, 3, 4, 5], 35),\n        ([1, 2, 3, 4, 5], 40),\n        ([1, 2, 3, 4, 5], 45),\n        ([1, 2, 3, 4, 5], 50),\n        ([1, 2, 3, 4, 5], 55),\n        ([1, 2, 3, 4, 5], 60),\n        ([1, 2, 3, 4, 5], 65),\n        ([1, 2, 3, 4, 5], 70),\n        ([1, 2, 3, 4, 5], 75),\n        ([1, 2, 3, 4, 5], 80),\n        ([1, 2, 3, 4, 5], 85),\n        ([1, 2, 3, 4, 5], 90),\n        ([1, 2, 3, 4, 5], 95),\n        ([1, 2, 3, 4, 5], 100),\n        ([1, 2, 3, 4, 5], 105),\n        ([1, 2, 3, 4, 5], 110),\n        ([1, 2, 3, 4, 5], 115),\n        ([1, 2, 3, 4, 5], 120),\n        ([1, 2, 3, 4, 5], 125),\n        ([1, 2"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def find_median(a, b, c):\n    if (b-a) == (c-b):\n        return (a+c)/2\n    elif (b-a) > (c-b):\n        return find_median(a, b, c)\n    else:\n        return find_median(b, c, a)\n\ndef test():\n    assert find_median(1, 2, 3) == 2\n    assert find_median(3, 4, 5) == 3\n    assert find_median(6, 7, 8) == 7\n\nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        if len(nums1) + len(nums2) == 0:\n            return 0\n        if len(nums1) == 0:\n            return nums2[-1]\n        if len(nums2) == 0:\n            return nums1[-1]\n        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)\n        else:\n            return (nums1[len(nums1)//2] + nums2[len(nums2)//2]) / 2\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    nums1 = [1, 3, 2]\n    nums2 = [3, 4, 1]\n    print(sol.findMedianSortedArrays(nums1, nums2))\n    nums1 = [1, 2, 3, 4, 5]\n    nums2 = [2, 3, 4, 5, 1]\n    print(sol.findMedianSortedArrays(nums1, nums2))\n    nums1 = [1, 3, 2]\n    nums2 = [3, 4, 1]\n    print(sol.findMedianSortedArrays(nums1, nums2))\n    nums1 = [1, 2, 3, 4, 5]\n    nums2 = [3, 4, 5, 1, 2]\n    print(sol.findMedianSortedArrays(nums1, nums2))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def find_median_trapezium(a, b, c):\n    if (b - a) > (c - a):\n        return (a + c) / 2.0\n    else:\n        return (a + b) / 2.0\n\nprint find_median_trapezium(1, 5, 8)\n\n# Your code here."
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def find_median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] < arr[right]:\n            return arr[left]\n        else:\n            if arr[left] > arr[right]:\n                return arr[right]\n            else:\n                if arr[left] > arr[right]:\n                    left += 1\n                else:\n                    right -= 1\n    return arr[left]\n\n\n# Your MedianTrapezium function will be called like this:\n# arr = [2, 6, 4, 8, 1, 9]\n# find_median_trapezium(arr)\n# Your code will be run on an array of length 10.\n\nif __name__ == '__main__':\n    arr = [2, 6, 4, 8, 1, 9]\n    print(find_median_trapezium(arr))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[Point]\n        :type B: List[Point]\n        :rtype: float\n        \"\"\"\n        if not A:\n            return float('inf')\n        if not B:\n            return float('-inf')\n        n1, n2 = len(A), len(B)\n        if n1 < n2:\n            return self.findMedianSortedArrays(B, A)\n        if n1 == n2:\n            return (A[n1/2].x + B[n1/2].x)/2.0\n        mid = n1/2\n        if (n1/2)%2 == 1:\n            return (max(A[mid].x, B[mid].x) + min(A[mid].x, B[mid].x))/2.0\n        else:\n            return (max(A[mid].x, B[mid].x) + min(A[mid].x, B[mid].x))/2.0\n\nif __name__ == \"__main__\":\n    s = Solution()\n    A = [Point(1, 1), Point(2, 2), Point(3, 3), Point(4, 4)]\n    B = [Point(1, 1), Point(3, 3), Point(5, 5), Point(6, 6)]\n    print s.findMedianSortedArrays(A, B)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)\n        if len(nums1) == 0:\n            return nums2[0]\n        if len(nums2) == 0:\n            return nums1[0]\n        if len(nums1) % 2 == 1:\n            return nums1[len(nums1) / 2]\n        else:\n            return (nums1[len(nums1) / 2 - 1] + nums1[len(nums1) / 2]) / 2\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3]\n    nums2 = [4, 5]\n    s = Solution()\n    print s.findMedianSortedArrays(nums1, nums2)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def find_median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    i = len(arr) // 2\n    if len(arr) % 2 == 1:\n        return arr[i]\n    else:\n        return (arr[i] + arr[i + 1]) / 2\n\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(find_median_trapezium(arr))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution:\n    # @param {integer} height\n    # @return {integer}\n    def findMedianSortedArrays(self, height):\n        height = int(height)\n        if height < 1:\n            return 0\n        l = height / 2\n        r = height - l - 1\n        arr1 = [0] * l\n        arr2 = [0] * r\n        for i in range(l):\n            arr1[i] = i + 1\n        for i in range(r):\n            arr2[i] = l + i + 2\n        arr1.sort()\n        arr2.sort()\n        arr1.reverse()\n        arr2.reverse()\n        return (arr1[l] + arr2[r]) / 2"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution:\n    # @return a float\n    def findMedianSortedArrays(self, A, B):\n        if A is None or B is None:\n            return 0.0\n        if len(A) < len(B):\n            return self.findMedianSortedArrays(B, A)\n        if len(A) == len(B):\n            return (A[len(A) / 2] + B[len(B) / 2]) / 2.0\n        else:\n            return (max(A[len(A) / 2], B[len(B) / 2]) + min(A[len(A) / 2 + 1], B[len(B) / 2 + 1])) / 2.0"
    },
    {
      "rank": 18,
      "score": 9.994196193362688,
      "candidate": "def get_median(x, low, high):\n    if low == high:\n        return low\n    else:\n        return (x[low] + x[high]) / 2.0\n\nif __name__ == '__main__':\n    x = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(get_median(x, 0, len(x) - 1))"
    },
    {
      "rank": 19,
      "score": 9.984594803182722,
      "candidate": "from __future__ import print_function\n\ndef get_median(arr):\n    \"\"\"\n    Get median of a trapezium.\n    \"\"\"\n    arr = sorted(arr)\n    if len(arr) == 0:\n        return 0\n    if len(arr) % 2 == 1:\n        return arr[len(arr) / 2]\n    else:\n        return (arr[len(arr) / 2] + arr[len(arr) / 2 + 1]) / 2\n\n\ndef test():\n    \"\"\"\n    Test cases.\n    \"\"\"\n    assert get_median([1, 2, 3, 4, 5]) == 3\n    assert get_median([1, 2, 3, 4, 5, 6]) == 4\n    assert get_median([1, 2, 3, 4, 5, 6, 7]) == 5\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8]) == 6\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 7\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 8\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 9\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 10\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 10\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) == 10\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 10\n    assert get_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) == 10\n    assert get_median([1, 2,"
    },
    {
      "rank": 20,
      "score": 9.899321108511852,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        n1, n2 = len(nums1), len(nums2)\n        if n1 > n2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        if n1 == 0 or n2 == 0:\n            return 0\n        if n1 == 1 or n2 == 1:\n            return (nums1[0] + nums2[0]) / 2\n        mid = n1 + n2 // 2\n        if nums1[mid-1] > nums2[mid-1]:\n            return self.findMedianSortedArrays(nums1[:mid-1], nums2[:mid-1])\n        else:\n            return self.findMedianSortedArrays(nums1[mid-1:], nums2[mid-1:])"
    },
    {
      "rank": 21,
      "score": 9.899314048868966,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[Point]\n        :type B: List[Point]\n        :rtype: float\n        \"\"\"\n        # Two arrays, one is the bigger, the other is the smaller.\n        # The median is the sum of the two middle points.\n        # The average of two middle points is the average of the two arrays.\n        # The median is the average of two middle points.\n        # The average of two middle points is the average of the two arrays.\n        # The median of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        # The average of two sorted arrays is the average of two middle points.\n        #"
    },
    {
      "rank": 22,
      "score": 9.87457168758889,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        return (nums1[len(nums1)/2] + nums2[len(nums2)/2]) / 2.0\n\nif __name__ == \"__main__\":\n    Solution().findMedianSortedArrays([1,2,3], [1,2,3])"
    },
    {
      "rank": 23,
      "score": 9.871426839299676,
      "candidate": "class Solution:\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if len(height) == 0:\n            return 0\n        if len(height) == 1:\n            return height[0]\n        if len(height) == 2:\n            if height[0] < height[1]:\n                return height[0]\n            else:\n                return height[1]\n        mid = len(height) / 2\n        if height[mid] < height[mid - 1]:\n            return self.trap(height[:mid])\n        if height[mid] < height[mid + 1]:\n            return self.trap(height[mid:])\n        else:\n            return height[mid]"
    },
    {
      "rank": 24,
      "score": 9.867038678383977,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        return (nums1[len(nums1)/2] + nums2[len(nums2)/2])/2\n\n\nif __name__ == \"__main__\":\n    assert Solution().findMedianSortedArrays([2, 3, 4, 5], [3, 5, 6, 7]) == 3.5\n    assert Solution().findMedianSortedArrays([2, 3, 4, 5], [3, 7, 9, 10]) == 7.5\n    assert Solution().findMedianSortedArrays([2, 3, 4], [5, 6, 7]) == 3.5\n    assert Solution().findMedianSortedArrays([2, 3, 4, 5], [5, 6, 7, 8]) == 5.5\n    assert Solution().findMedianSortedArrays([2, 3, 4, 5, 6], [5, 6, 7, 8, 9]) == 6.5\n    assert Solution().findMedianSortedArrays([1, 2, 3, 4], [4, 5, 6, 7]) == 4.5\n    assert Solution().findMedianSortedArrays([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) == 5.5"
    },
    {
      "rank": 25,
      "score": 9.801925328487291,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if not A:\n            return float(B[-1])\n        if not B:\n            return float(A[-1])\n        if A[0] > B[0]:\n            return float(self.findMedianSortedArrays(B, A))\n        if A[-1] < B[-1]:\n            return float(self.findMedianSortedArrays(A, B))\n        mid = len(A) // 2\n        if A[-1] > B[-1]:\n            return float(A[mid])\n        if A[-1] < B[-1]:\n            return float(B[mid])\n        return float(self.findMedianSortedArrays(A[:mid], B[:mid]))\n\nif __name__ == \"__main__\":\n    assert Solution().findMedianSortedArrays([1, 2, 3], [2, 4, 5, 6]) == 2.5"
    },
    {
      "rank": 26,
      "score": 9.80073039209064,
      "candidate": "import math\nimport random\n\ndef find_median(nums):\n    \"\"\"\n    Find the median of a trapezium.\n\n    You should not modify the list passed as parameter.\n    \"\"\"\n    return (nums[0] + nums[1]) / 2.0\n\ndef test_median():\n    assert find_median([1,2,3]) == 2.5\n    assert find_median([1,3,5]) == 3.0\n    assert find_median([1,2,4]) == 2.5\n    assert find_median([1,2,4,5]) == 3.0\n    assert find_median([1,2,4,6]) == 4.5\n    assert find_median([1,2,4,6,7]) == 4.5\n    assert find_median([1,2,3,4,5]) == 2.5\n    assert find_median([1,2,3,4,5,6]) == 3.0\n    assert find_median([1,2,3,4,5,6,7]) == 4.5\n    assert find_median([1,2,3,4,5,6,7,8]) == 5.0\n    assert find_median([1,2,3,4,5,6,7,8,9]) == 4.5\n    assert find_median([1,2,3,4,5,6,7,8,9,10]) == 5.0\n\ndef test_median_random():\n    for i in range(1000):\n        nums = [random.randint(1,100) for _ in range(10)]\n        assert find_median(nums) == find_median(nums)\n\nif __name__ == '__main__':\n    test_median()\n    test_median_random()"
    },
    {
      "rank": 27,
      "score": 9.79973620596479,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '<Point({}, {})>'.format(self.x, self.y)\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return None\n        if len(A) > len(B):\n            return self.findMedianSortedArrays(B, A)\n        if len(A) == 1:\n            return A[0]\n        if len(B) == 1:\n            return B[0]\n        if A[0] > B[0]:\n            return self.findMedianSortedArrays(B, A[1:])\n        if A[-1] < B[-1]:\n            return (A[-1] + B[-1]) / 2.0\n        return (A[-1] + B[0]) / 2.0\n\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return None\n        if len(A) == 1:\n            return A[0]\n        if len(B) == 1:\n            return B[0]\n        if A[0] > B[0]:\n            return self.findMedianSortedArrays(B, A[1:])\n        if A[-1] < B[-1]:\n            return (A[-1] + B[-1]) / 2.0\n        return (A[-1] + B[0]) / 2.0\n\nif __name__ == \"__main__\":\n    A = [1, 3, 5, 7, 9]\n    B"
    },
    {
      "rank": 28,
      "score": 9.79812601404797,
      "candidate": "from collections import namedtuple\n\n\n# Definition for a point.\nPoint = namedtuple('Point', 'x y')\n\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        # Sort both lists.\n        A, B = sorted(A), sorted(B)\n\n        # Find the size of the largest list.\n        n = len(A) + len(B)\n\n        # If the two lists are equal in size, return the average of the two.\n        if n % 2 == 0:\n            return (A[n / 2] + B[n / 2]) / 2.0\n\n        # Otherwise, return the value of the point in the middle of the lists.\n        return (A[n / 2] + B[n / 2 - 1]) / 2.0\n\n\nif __name__ == '__main__':\n    A = [1, 2, 3, 4, 5, 6, 7]\n    B = [1, 2, 3, 4, 5, 6, 7]\n    C = [1, 2, 3, 4, 5, 6, 7]\n\n    print(Solution().findMedianSortedArrays(A, B))\n    print(Solution().findMedianSortedArrays(A, C))\n    print(Solution().findMedianSortedArrays(B, C))"
    },
    {
      "rank": 29,
      "score": 9.793955077726526,
      "candidate": "def find_median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    if len(arr) == 0:\n        return None\n\n    if len(arr) == 1:\n        return arr[0]\n\n    if len(arr) == 2:\n        return arr[0]\n\n    if len(arr) % 2 == 1:\n        return arr[(len(arr) - 1) / 2]\n\n    return (arr[(len(arr) - 1) / 2] + arr[len(arr) / 2]) / 2\n\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        if len(nums1) == 0 and len(nums2) == 0:\n            return None\n\n        if len(nums1) == 0:\n            return find_median_trapezium(nums2)\n\n        if len(nums2) == 0:\n            return find_median_trapezium(nums1)\n\n        if len(nums1) > len(nums2):\n            return find_median_trapezium(nums1)\n\n        if len(nums2) > len(nums1):\n            return find_median_trapezium(nums2)\n\n        if len(nums1) % 2 == 1:\n            return find_median_trapezium(nums1)\n\n        if len(nums2) % 2 == 1:\n            return find_median_trapezium(nums2)\n\n        return (find_median_trapezium(nums1) + find_median_trapezium(nums2)) / 2"
    },
    {
      "rank": 30,
      "score": 9.741725363334913,
      "candidate": "def median(l):\n    if len(l) % 2 == 1:\n        return l[len(l) / 2]\n    else:\n        return (l[len(l) / 2] + l[len(l) / 2 - 1]) / 2\n\n\ndef main():\n    l = [1, 2, 3, 4, 5, 6]\n    print(median(l))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 31,
      "score": 9.722598505519796,
      "candidate": "class Solution:\n    # @param num, a list of integers\n    # @return an integer\n    def findMedianSortedArrays(self, num):\n        return self.findMedianSortedArrays(num, 0, len(num) - 1)\n\n    def findMedianSortedArrays(self, num, l, r):\n        if l == r:\n            return num[l]\n        mid = (l + r) / 2\n        if (mid - l) % 2 == 1:\n            return (num[l] + num[mid]) / 2\n        else:\n            return (num[mid] + num[l]) / 2"
    },
    {
      "rank": 32,
      "score": 9.639136465014266,
      "candidate": "def find_median_trapezium(lst):\n    \"\"\"\n    Finds the median of a list of numbers.\n    :param lst: A list of numbers.\n    :return: The median of the numbers in the list.\n    \"\"\"\n    return sorted(lst)[len(lst)//2]\n\nif __name__ == \"__main__\":\n    lst = [1, 2, 3, 4, 5]\n    print(find_median_trapezium(lst))"
    },
    {
      "rank": 33,
      "score": 9.60954964752588,
      "candidate": "import math\n\ndef find_median_trapezium(arr):\n    \"\"\"\n    Find the median of a trapezium.\n    :param arr: An array of numbers\n    :return: The median\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        arr = sorted(arr)\n        if len(arr) % 2 == 0:\n            return (arr[len(arr) / 2] + arr[len(arr) / 2 - 1]) / 2\n        else:\n            return arr[len(arr) / 2]\n\n# Test cases\n\nprint find_median_trapezium([1, 3, 6])\nprint find_median_trapezium([4, 2, 1, 3])\nprint find_median_trapezium([1, 2, 3, 4, 5, 6])\nprint find_median_trapezium([])\nprint find_median_trapezium([-1, -2, -3, -4, -5, -6])\nprint find_median_trapezium([-1, -2, -3, -4, -5, -6, -7])\nprint find_median_trapezium([-1, -2, -3, -4, -5, -6, -7, -8, -9])\nprint find_median_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9])\nprint find_median_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\nprint find_median_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\nprint find_median_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])"
    },
    {
      "rank": 34,
      "score": 9.564482618256198,
      "candidate": "# Definition for a trapezium.\nclass Trapezium(object):\n    def __init__(self, left, right, height):\n        self.left = left\n        self.right = right\n        self.height = height\n\n    def __str__(self):\n        return \"Trapezium: \" + str(self.left) + \" \" + str(self.right) + \" \" + str(self.height)\n\n\nclass Solution(object):\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: float\n        \"\"\"\n        left = 0\n        right = len(arr1)\n        if len(arr2) < len(arr1):\n            left = 0\n            right = len(arr2)\n        mid = (left + right) / 2\n        while mid >= 0 and mid < len(arr1):\n            if arr1[mid] > arr2[mid]:\n                right = mid\n            elif arr1[mid] < arr2[mid]:\n                left = mid + 1\n            else:\n                return arr1[mid]\n            mid = (left + right) / 2\n        if mid >= 0:\n            if arr1[mid] < arr2[mid]:\n                return arr1[mid]\n            else:\n                return arr2[mid]\n        return arr2[mid]\n\n\nif __name__ == \"__main__\":\n    arr1 = [1, 3, 5, 7]\n    arr2 = [2, 4, 6, 8]\n    s = Solution()\n    print s.findMedianSortedArrays(arr1, arr2)\n    print s.findMedianSortedArrays([], arr2)\n    print s.findMedianSortedArrays(arr1, [])\n    print s.findMedianSortedArrays([], [])"
    },
    {
      "rank": 35,
      "score": 9.545184300548962,
      "candidate": "def median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: int\n    \"\"\"\n    if not arr:\n        return None\n    l = len(arr)\n    if l % 2 == 1:\n        return arr[l // 2]\n    else:\n        return (arr[l // 2] + arr[l // 2 - 1]) / 2\n\nclass Solution(object):\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        if not arr1 or not arr2:\n            return None\n        l = len(arr1)\n        r = len(arr2)\n        if l > r:\n            return self.findMedianSortedArrays(arr2, arr1)\n        if l == r:\n            return arr1[l / 2]\n        if l > r / 2:\n            return arr2[r - l]\n        else:\n            return arr1[l - r]"
    },
    {
      "rank": 36,
      "score": 9.524275961177407,
      "candidate": "\"\"\"\nThe following code is used to test your solution.\n\"\"\"\n\nfrom __future__ import print_function\n\ndef trapezium_median(l):\n    if len(l) == 0:\n        return None\n    \n    if len(l) == 1:\n        return l[0]\n    \n    low = l[0]\n    high = l[1]\n    \n    return (low + high) / 2.0\n    \ndef main():\n    print(trapezium_median([1, 2, 3, 4, 5]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7]))\n    \n    print(\"-\" * 80)\n    \n    print(trapezium_median([1, 2, 3, 4]))\n    print(trapezium_median([1, 2, 3, 4, 5]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7]))\n    \n    print(\"-\" * 80)\n    \n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\n    \n    print(\"-\" * 80)\n    \n    print(trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))\n    print(trapez"
    },
    {
      "rank": 37,
      "score": 9.485631151645311,
      "candidate": "# Definition for a trapezium.\nclass Trapezium(object):\n    def __init__(self, left, height, right):\n        \"\"\"\n        :type left: int\n        :type height: int\n        :type right: int\n        \"\"\"\n        self.left = left\n        self.height = height\n        self.right = right\n\n\nclass Solution(object):\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[Trapezium]\n        :type arr2: List[Trapezium]\n        :rtype: float\n        \"\"\"\n        arr1.sort()\n        arr2.sort()\n        return (arr1[len(arr1) // 2] + arr2[len(arr2) // 2]).height / 2"
    },
    {
      "rank": 38,
      "score": 9.475037230512461,
      "candidate": "# https://www.hackerrank.com/challenges/trapezoid/problem\n\n# from CommonClasses import * # hxl: comment out this line for submission\n\nclass Solution(object):\n\n    def median(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: float\n        \"\"\"\n        if not A:\n            return 0\n        else:\n            return (float(A[0] + A[len(A) - 1]) / 2) if len(A) % 2 else (float(A[0] + A[len(A) / 2]) / 2)\n\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return 0\n        if len(A) < len(B):\n            return self.findMedianSortedArrays(B, A)\n        elif len(A) > len(B):\n            return self.findMedianSortedArrays(A, B)\n        else:\n            if A[0] < B[0]:\n                return self.findMedianSortedArrays(B, A)\n            elif A[0] > B[0]:\n                return self.findMedianSortedArrays(A, B)\n            else:\n                return float(A[0] + B[0]) / 2\n\n\n# Note:\n# There are many possible solutions to this problem, but the following is the one I found that is most concise and complete."
    },
    {
      "rank": 39,
      "score": 9.392709408425825,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: float\n        \"\"\"\n        if not arr1 or not arr2:\n            return None\n        if len(arr1) < len(arr2):\n            return self.findMedianSortedArrays(arr2, arr1)\n        if len(arr1) == len(arr2):\n            return (arr1[len(arr1) / 2] + arr2[len(arr2) / 2]) / 2.0\n        else:\n            return arr1[len(arr1) / 2]\n\n\nif __name__ == \"__main__\":\n    print Solution().findMedianSortedArrays([1, 2, 3], [2, 3, 4])"
    },
    {
      "rank": 40,
      "score": 9.387358279928213,
      "candidate": "# Definition for a trapezium.\nclass Trapezium:\n    def __init__(self, left, right, height):\n        self.left = left\n        self.right = right\n        self.height = height\n\n\nclass Solution:\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if len(A) < len(B):\n            return self.findMedianSortedArrays(B, A)\n        \n        left_sum = 0\n        right_sum = 0\n        \n        for i in range(len(A)):\n            left_sum += A[i]\n            right_sum += B[i]\n            \n            if left_sum > right_sum:\n                return float(left_sum - right_sum) / 2\n        \n        return float(right_sum - left_sum) / 2"
    },
    {
      "rank": 41,
      "score": 9.364235544142007,
      "candidate": "def find_median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        if arr[0] > arr[len(arr)-1]:\n            arr = sorted(arr)\n        arr.sort()\n        if len(arr) % 2 == 0:\n            return (arr[len(arr)/2-1] + arr[len(arr)/2])/2.0\n        else:\n            return arr[len(arr)/2]\n\n# Your MedianTrapezium solution here."
    },
    {
      "rank": 42,
      "score": 9.258285332019396,
      "candidate": "def median(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) % 2 == 1:\n        return arr[len(arr) / 2]\n    else:\n        return (arr[len(arr) / 2] + arr[len(arr) / 2 - 1]) / 2\n\n\ndef test_median():\n    assert median([1, 2, 3]) == 2\n    assert median([4, 5, 6]) == 4.5\n    assert median([7, 8, 9, 10, 11, 12]) == 7.5\n    assert median([]) == None\n\nif __name__ == \"__main__\":\n    test_median()"
    },
    {
      "rank": 43,
      "score": 9.157341846731697,
      "candidate": "import math\n\n# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # Returns the midpoint of this point.\n    def mid(self):\n        return Point(self.x + (self.x - self.y)/2, self.y + (self.y - self.x)/2)\n\n\nclass Solution:\n    # @param points, a list of points\n    # @return the median point\n    def findMedianSortedArrays(self, points):\n        n = len(points)\n        if n == 0:\n            return None\n        if n == 1:\n            return points[0].mid()\n        if n % 2 == 0:\n            p1 = points[n/2 - 1]\n            p2 = points[n/2]\n            return (p1.mid() + p2.mid()) / 2\n        p1 = points[n/2]\n        p2 = points[n/2 + 1]\n        return (p1.mid() + p2.mid()) / 2"
    },
    {
      "rank": 44,
      "score": 9.039009033653768,
      "candidate": "from __future__ import print_function\nimport random\n\ndef trapezium_median(n):\n    \"\"\"\n    Returns the median of a trapezium of size n.\n    \"\"\"\n\n    if n == 1:\n        return 1\n\n    # Find the midpoint.\n    mid = n/2\n\n    # Find the first median.\n    first = trapezium_median(mid)\n\n    # Find the second median.\n    second = trapezium_median(mid+1)\n\n    # If the sum of the two medians is less than the sum of the\n    # trapezium, return the second median. Otherwise, return the\n    # first median.\n    if first + second < n:\n        return second\n    else:\n        return first\n\n\ndef test_trapezium_median():\n    assert trapezium_median(10) == 5\n\n\ndef main():\n    for _ in range(1000):\n        n = random.randint(1, 100)\n        print(trapezium_median(n))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 45,
      "score": 9.028898339701513,
      "candidate": "import random\n\ndef find_median(a, b, c):\n    \"\"\"\n    Find the median of a trapezium.\n    \"\"\"\n    if a >= b and b >= c:\n        return (a + b) / 2.0\n    elif b >= c:\n        return (b + c) / 2.0\n    else:\n        return (a + c) / 2.0\n\ndef main():\n    a = int(input('Enter the first number: '))\n    b = int(input('Enter the second number: '))\n    c = int(input('Enter the third number: '))\n    print(find_median(a, b, c))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 46,
      "score": 9.023195789879495,
      "candidate": "from collections import namedtuple\n\nTrapezium = namedtuple(\"Trapezium\", \"lower upper\")\n\n\ndef median_of_trapezium(arr):\n    \"\"\"\n    Given an array of integers, return the median of the\n    trapezium formed by the first, last, and middle elements.\n\n    The array may be empty, and in that case return None.\n\n    :param arr:\n    :return:\n    \"\"\"\n    if not arr:\n        return None\n    arr = sorted(arr)\n    if len(arr) == 1:\n        return arr[0]\n    return (arr[len(arr) / 2] + arr[len(arr) / 2 - 1]) / 2\n\n\nif __name__ == \"__main__\":\n    print(median_of_trapezium([1, 2, 3, 4]))\n    print(median_of_trapezium([5, 6, 7, 8]))\n    print(median_of_trapezium([1, 2, 3, 4, 5]))\n    print(median_of_trapezium([5, 6, 7, 8, 9]))\n    print(median_of_trapezium([1, 2, 3, 4, 5, 6]))"
    },
    {
      "rank": 47,
      "score": 9.001390976634635,
      "candidate": "def find_median(arr):\n    if len(arr) == 0:\n        return None\n    if len(arr) % 2 == 1:\n        return arr[len(arr) / 2]\n    else:\n        return (arr[len(arr) / 2] + arr[len(arr) / 2 + 1]) / 2\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6]\n    print(find_median(arr))\n    arr = [1, 2, 3]\n    print(find_median(arr))\n    arr = [1, 2, 3, 4, 5]\n    print(find_median(arr))"
    },
    {
      "rank": 48,
      "score": 8.959815655301357,
      "candidate": "import math\nimport random\n\ndef median(l):\n    if len(l) == 0:\n        raise ValueError(\"List is empty\")\n    if len(l) == 1:\n        return l[0]\n    else:\n        a = l[len(l) / 2]\n        b = l[len(l) - 1 - len(l) / 2]\n        if a > b:\n            return a\n        else:\n            return b\n\nif __name__ == \"__main__\":\n    with open(\"data.txt\", \"r\") as f:\n        data = [int(x.strip()) for x in f]\n        print(median(data))"
    },
    {
      "rank": 49,
      "score": 8.825786945643413,
      "candidate": "def find_median_trapezium(l):\n    \"\"\"\n    l: A list of integers.\n    Returns the median of the trapezium formed by l[0], l[1],..., l[len(l) - 1].\n    \"\"\"\n    # Your code here\n    if len(l) < 1:\n        return None\n    if len(l) == 1:\n        return l[0]\n    if len(l) == 2:\n        return (l[0] + l[1]) / 2\n    return (l[0] + l[1]) / 2\n\nprint(find_median_trapezium([1, 2, 3]))"
    },
    {
      "rank": 50,
      "score": 8.815151592750942,
      "candidate": "from collections import namedtuple\nimport math\n\nTrapezium = namedtuple('Trapezium', ['a', 'b', 'c', 'd'])\n\nclass Trapezium(object):\n    def __init__(self, a, b, c, d):\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    @property\n    def area(self):\n        return self.a * (self.b + self.c)\n\n    @property\n    def volume(self):\n        return self.b * self.c\n\n    @property\n    def width(self):\n        return self.b - self.a\n\n    @property\n    def height(self):\n        return self.c - self.d\n\n\ndef is_trapezium(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.area == rectangle.volume and \\\n        rectangle.width == rectangle.height\n\n\ndef is_trapezium_area(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.area == rectangle.volume\n\n\ndef is_trapezium_volume(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.area == rectangle.volume\n\n\ndef is_trapezium_width(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.width == rectangle.height\n\n\ndef is_trapezium_height(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.width == rectangle.height\n\n\ndef is_trapezium_area_height(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.area == rectangle.height\n\n\ndef is_trapezium_area_width(rectangle):\n    \"\"\"\n    Returns whether a rectangle is a trapezium.\n    \"\"\"\n    return rectangle.area == rectangle.width\n\n\ndef is_trapezium_area_width_height(rectangle):\n    \"\"\""
    },
    {
      "rank": 51,
      "score": 8.7983308897086,
      "candidate": "def find_median(arr):\n    \"\"\"\n    Given an array of integers, find the median of the array.\n    \"\"\"\n    if len(arr) < 1:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) % 2 == 1:\n        return arr[int(len(arr) / 2)]\n    else:\n        return (arr[int(len(arr) / 2) - 1] + arr[int(len(arr) / 2)]) / 2\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4]\n    print find_median(arr)"
    },
    {
      "rank": 52,
      "score": 8.757011511043656,
      "candidate": "def median(lst):\n    lst.sort()\n    return lst[len(lst)/2]\n\ndef test_median():\n    assert median([1,2,3,4,5]) == 3\n\nif __name__ == '__main__':\n    test_median()"
    },
    {
      "rank": 53,
      "score": 8.725061744842701,
      "candidate": "import math\n\ndef median(arr):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        mid = (left + right) / 2\n        if arr[mid] > arr[mid + 1]:\n            right = mid\n        else:\n            left = mid + 1\n    return arr[(left + right) / 2]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(median(arr))"
    },
    {
      "rank": 54,
      "score": 8.690566088922708,
      "candidate": "def get_median_of_trapezium(arr):\n    \"\"\"\n    Given an array of integers, return the median of the trapezium.\n    If there is no such trapezium, return the median of the array.\n    The trapezium is defined by the two elements (a, b) such that\n    a < b and a <= arr[i] <= b.\n    \"\"\"\n    \n    if len(arr) == 0:\n        return None\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    if len(arr) % 2 == 0:\n        a = arr[len(arr) / 2 - 1]\n        b = arr[len(arr) / 2]\n        if a > b:\n            a, b = b, a\n        return (a + b) / 2\n    else:\n        a = arr[len(arr) / 2]\n        b = arr[len(arr) / 2 + 1]\n        if a > b:\n            a, b = b, a\n        return (a + b) / 2\n    \n    \ndef test():\n    arr = [1, 2, 3, 4, 5]\n    print get_median_of_trapezium(arr)\n    \nif __name__ == '__main__':\n    test()"
    },
    {
      "rank": 55,
      "score": 8.650617261007111,
      "candidate": "def find_median_trapezium(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n    if n == 2:\n        return (arr[0] + arr[1]) / 2\n    l, r = 0, n - 1\n    while l <= r:\n        m = (l + r) / 2\n        if arr[m] > arr[r]:\n            r = m - 1\n        elif arr[m] < arr[r]:\n            l = m + 1\n        else:\n            return arr[m]\n    return arr[r]\n\n\nif __name__ == '__main__':\n    print(find_median_trapezium([2, 3, 4, 5]))\n    print(find_median_trapezium([1, 3, 4, 5]))\n    print(find_median_trapezium([4, 5, 6, 7]))\n    print(find_median_trapezium([3, 4, 5, 6, 7]))"
    },
    {
      "rank": 56,
      "score": 8.5872096914158,
      "candidate": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        if len(nums1) == 0 or len(nums2) == 0:\n            return float('-inf')\n\n        nums1.sort()\n        nums2.sort()\n        if len(nums1) == len(nums2):\n            return (nums1[len(nums1)/2] + nums2[len(nums2)/2]) / 2.0\n        elif len(nums1) > len(nums2):\n            return nums1[len(nums1)/2]\n        else:\n            return nums2[len(nums2)/2]"
    },
    {
      "rank": 57,
      "score": 8.581866133962546,
      "candidate": "def find_median_trapezium(numbers):\n    \"\"\"\n    :type numbers: List[int]\n    :rtype: float\n    \"\"\"\n    if not numbers:\n        return None\n\n    numbers.sort()\n    i = 0\n    j = len(numbers) - 1\n\n    if len(numbers) % 2 == 0:\n        median = (numbers[i] + numbers[j]) / 2\n        return median\n\n    while i < j:\n        if numbers[i] < numbers[j]:\n            i += 1\n        elif numbers[i] > numbers[j]:\n            j -= 1\n        else:\n            i += 1\n            j -= 1\n            median = (numbers[i] + numbers[j]) / 2\n            return median\n\n    median = numbers[i]\n    return median\n\nif __name__ == '__main__':\n    numbers = [2, 7, 8, 9]\n    print(find_median_trapezium(numbers))"
    },
    {
      "rank": 58,
      "score": 8.567596352814467,
      "candidate": "from __future__ import print_function\n\nimport random\n\n\ndef trapezium_median(arr):\n    \"\"\"\n    Trapezium median\n\n    :param arr: List of numbers\n    :return: Median of trapezium\n    \"\"\"\n    arr.sort()\n\n    # Check if even number of elements\n    if len(arr) % 2 == 0:\n        # Find middle element\n        mid = len(arr) / 2\n        return (arr[mid - 1] + arr[mid]) / 2\n    else:\n        # Find middle element\n        mid = len(arr) / 2\n        return arr[mid]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(trapezium_median(arr))"
    },
    {
      "rank": 59,
      "score": 8.523812610546251,
      "candidate": "from collections import namedtuple\n\nPoint = namedtuple(\"Point\", \"x y\")\n\nclass Trapezium:\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __str__(self):\n        return str(self.a) + \" \" + str(self.b) + \" \" + str(self.c)\n\n    def __repr__(self):\n        return str(self)\n\ndef median(points):\n    \"\"\"\n    Write a function median that takes a list of points and returns the\n    median of the points.\n    \"\"\"\n    points.sort(reverse=True)\n    if len(points) % 2 == 1:\n        return (points[len(points) / 2 - 1] + points[len(points) / 2]) / 2\n    else:\n        return (points[len(points) / 2] + points[len(points) / 2 + 1]) / 2\n\n\ndef main():\n    points = [Point(1, 1), Point(2, 2), Point(3, 3)]\n    print(median(points))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 60,
      "score": 8.486595028534193,
      "candidate": "def find_median(a, b, c):\n    \"\"\"\n    Find the median of a trapezium.\n    \"\"\"\n    return (a + c)/2"
    },
    {
      "rank": 61,
      "score": 8.47752233037495,
      "candidate": "import random\n\ndef find_median(arr):\n    \"\"\"\n    Find the median of a trapezium.\n\n    The inputs are a list of integers.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr[0]\n    else:\n        return (arr[0] + arr[len(arr) - 1]) / 2\n\n\ndef main():\n    arr = [random.randint(0, 100) for _ in range(100)]\n    print(find_median(arr))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 62,
      "score": 8.470105162225856,
      "candidate": "def find_median(arr):\n    if len(arr) == 0:\n        raise ValueError(\"Array is empty.\")\n\n    arr.sort()\n    if len(arr) % 2 == 0:\n        return (arr[len(arr) / 2] + arr[len(arr) / 2 - 1]) / 2\n    else:\n        return arr[len(arr) / 2]\n\nif __name__ == '__main__':\n    print find_median([1, 3, 5, 6])\n    print find_median([1, 3, 5, 6, 7])\n    print find_median([1, 3, 5, 6, 7, 9])"
    },
    {
      "rank": 63,
      "score": 8.417080598243917,
      "candidate": "def trapezium_median(arr):\n    \"\"\"\n    Find the median of a trapezium.\n\n    :param arr: A list of integers.\n    :return: The median of the trapezium.\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return (arr[0] + arr[1]) / 2\n    if len(arr) % 2:\n        return arr[len(arr) / 2 - 1]\n    else:\n        return (arr[len(arr) / 2] + arr[len(arr) / 2 + 1]) / 2\n\nif __name__ == '__main__':\n    test_cases = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                  [[1, 2, 3], [4, 5], [6, 7]],\n                  [[1, 2, 3], [4], [5, 6, 7]],\n                  [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]]\n\n    for arr in test_cases:\n        print(trapezium_median(arr))"
    },
    {
      "rank": 64,
      "score": 8.400498097136913,
      "candidate": "def find_median_trapezium(data):\n    \"\"\"\n    data = [2, 4, 6, 8, 10]\n    \"\"\"\n    n = len(data)\n    # print(data)\n    # print(data[0], data[-1])\n    if n == 1:\n        return data[0]\n    elif n == 2:\n        if data[0] < data[1]:\n            return data[0]\n        else:\n            return data[1]\n    else:\n        left = data[0]\n        right = data[n-1]\n        if left < right:\n            return (left + right) / 2\n        else:\n            return (right + left) / 2\n\nif __name__ == \"__main__\":\n    print(find_median_trapezium([1, 4, 6, 8, 10]))\n    # print(find_median_trapezium([2, 4, 6, 8, 10]))\n    # print(find_median_trapezium([2, 4, 6, 8, 10, 11]))"
    },
    {
      "rank": 65,
      "score": 8.391904009999395,
      "candidate": "def find_median(arr):\n    \"\"\"\n    Write a function to find the median of a trapezium.\n    \"\"\"\n    return sum(arr) / 2.0\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    print find_median(arr)"
    },
    {
      "rank": 66,
      "score": 8.373894033312194,
      "candidate": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def findMedianSortedArrays(self, nums1, nums2):\n        n = len(nums1)\n        if n > len(nums2):\n            n = len(nums2)\n        for i in range(n):\n            if nums2[i] < nums1[i]:\n                return self.findMedianSortedArrays(nums2, nums1[i:])\n        return (nums2[n/2] + nums1[n/2]) / 2"
    },
    {
      "rank": 67,
      "score": 8.36096912706619,
      "candidate": "import random\n\ndef trapezium_median(lst):\n    \"\"\"\n    Trapezium median\n\n    Input:\n    lst = list of numbers\n    Output:\n    The median of the trapezium.\n    \"\"\"\n    # If there is only one number, return it\n    if len(lst) == 1:\n        return lst[0]\n\n    # If there are two numbers, return the median of them\n    elif len(lst) == 2:\n        return (lst[0] + lst[1])/2\n\n    # If there are three numbers, return the median of them\n    elif len(lst) == 3:\n        return (lst[0] + lst[1] + lst[2])/3\n\n    # If there are four numbers, return the median of them\n    elif len(lst) == 4:\n        return (lst[0] + lst[1] + lst[2] + lst[3])/4\n\n    # If there are five or more numbers, return the median of them\n    else:\n        return (lst[0] + lst[1] + lst[2] + lst[3] + lst[4])/5\n\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    lst = [random.randint(0, 100) for _ in range(100)]\n    print(trapezium_median(lst))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 68,
      "score": 8.358649450259561,
      "candidate": "import math\n\ndef trapezium_median(arr):\n    \"\"\"\n    Median of trapezium\n    \"\"\"\n    \n    if len(arr) < 1:\n        return None\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    if len(arr) % 2 == 1:\n        return arr[int(len(arr)/2)]\n    \n    return (arr[int(len(arr)/2)] + arr[int(len(arr)/2) - 1]) / 2\n\ndef test_trapezium_median():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    print(trapezium_median(arr))\n    \nif __name__ == '__main__':\n    test_trapezium_median()"
    },
    {
      "rank": 69,
      "score": 8.330025040120514,
      "candidate": "import sys\n\ndef median_of_trapezium(l):\n    \"\"\"\n    >>> median_of_trapezium([1, 2, 3])\n    2\n    >>> median_of_trapezium([4, 5, 6, 7])\n    3\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return (l[1] + l[0]) / 2\n\ndef main():\n    if len(sys.argv) == 1:\n        print(\"Please input the list of numbers\")\n    else:\n        l = [int(x) for x in sys.argv[1].split(',')]\n        print(median_of_trapezium(l))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 70,
      "score": 8.298113177886245,
      "candidate": "import math\n\ndef find_median(a, b):\n    if (a + b) % 2 == 0:\n        return (a + b) / 2\n    else:\n        return (a + b) / 2 + 1\n\ndef main():\n    a = int(input())\n    b = int(input())\n    print(find_median(a, b))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 71,
      "score": 8.237579009124875,
      "candidate": "def find_median_of_trapezium(arr):\n    \"\"\"\n    Input: list of integers\n    Output: median of the list\n    \"\"\"\n\n    arr = sorted(arr)\n    if len(arr) < 1:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return (arr[0] + arr[1]) / 2\n    if len(arr) % 2 == 1:\n        return arr[len(arr) / 2]\n\n    return (arr[len(arr) / 2 - 1] + arr[len(arr) / 2]) / 2\n\ndef test_find_median_of_trapezium():\n    assert find_median_of_trapezium([1, 2, 3, 4, 5]) == 3\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6]) == 3.5\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7]) == 4\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8]) == 4.5\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 5\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5.5\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 6\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 6.5\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 7\n    assert find_median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9"
    },
    {
      "rank": 72,
      "score": 8.230775183332875,
      "candidate": "def median_trapezium(l):\n    if len(l) == 1:\n        return l[0]\n    else:\n        return (l[1] + l[0]) / 2.0\n\nprint(median_trapezium([1, 2, 3]))\nprint(median_trapezium([1, 3, 5]))\nprint(median_trapezium([1, 2, 4, 6]))\nprint(median_trapezium([2, 3, 4, 6]))"
    },
    {
      "rank": 73,
      "score": 8.215795931797274,
      "candidate": "# Your code here\n\ndef trapezium(a, b):\n    return (a + b) / 2.0\n\ndef find_median(nums):\n    if len(nums) < 1:\n        return 0.0\n    a = nums[0]\n    b = nums[len(nums) - 1]\n    if a > b:\n        return trapezium(a, b)\n    return trapezium(b, a)\n\nif __name__ == '__main__':\n    nums = [1, 2, 3, 4]\n    print find_median(nums)"
    },
    {
      "rank": 74,
      "score": 8.18721408432818,
      "candidate": "def trapezium(arr):\n    \"\"\"\n    Input: An array of integers.\n\n    Output: The median of the trapezium.\n\n    Time Complexity: O(n)\n    \"\"\"\n    if len(arr) < 1:\n        return None\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        middle = (left + right) // 2\n        if arr[middle] > arr[right]:\n            right = middle\n        elif arr[middle] < arr[left]:\n            left = middle\n        else:\n            return arr[middle]\n\n    if left < len(arr) // 2:\n        return arr[left]\n    else:\n        return arr[len(arr) - 1]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(trapezium(arr))\n    print(trapezium_median(arr))"
    },
    {
      "rank": 75,
      "score": 8.170903645254455,
      "candidate": "import numpy as np\n\ndef trapezium_median(data):\n    if len(data) <= 1:\n        return data[0]\n    else:\n        mid = int(len(data)/2)\n        if data[mid] > data[mid-1]:\n            return trapezium_median(data[:mid]+data[mid+1:])\n        else:\n            return (data[mid-1] + data[mid])/2.0\n\nif __name__ == \"__main__\":\n    data = [5, 1, 7, 6, 2, 4, 8]\n    print(trapezium_median(data))"
    },
    {
      "rank": 76,
      "score": 8.007066885023969,
      "candidate": "# Definition for a trapezium.\nclass Trapezium:\n    def __init__(self, left, bottom, right, top):\n        self.left = left\n        self.bottom = bottom\n        self.right = right\n        self.top = top\n\nclass Solution:\n    \"\"\"\n    @param: L: a list of integers\n    @return: the median of L\n    \"\"\"\n    def findMedianSortedArrays(self, L):\n        if len(L) < 1:\n            return None\n\n        if len(L) == 1:\n            return L[0]\n\n        mid = len(L) / 2\n        left = self.findMedianSortedArrays(L[:mid])\n        right = self.findMedianSortedArrays(L[mid:])\n\n        if left is None and right is None:\n            return None\n        elif left is None:\n            return right\n        elif right is None:\n            return left\n        else:\n            return (left + right) / 2"
    },
    {
      "rank": 77,
      "score": 7.939733745863041,
      "candidate": "def trapezium_median(arr):\n    \"\"\"\n    :param arr: A list of integers\n    :return: Median of the list\n    \"\"\"\n    if len(arr) < 1:\n        return None\n    elif len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        return (arr[0] + arr[1]) / 2.0\n    else:\n        if arr[0] < arr[-1]:\n            return (arr[0] + arr[-1]) / 2.0\n        else:\n            return (arr[-1] + arr[0]) / 2.0\n\nif __name__ == '__main__':\n    assert trapezium_median([1, 2, 3]) == 2, \"1\"\n    assert trapezium_median([3, 2, 1]) == 2, \"2\"\n    assert trapezium_median([3, 2, 4]) == 3, \"3\"\n    assert trapezium_median([4, 2, 3]) == 3, \"4\"\n    assert trapezium_median([2, 3, 4, 5]) == 3.5, \"5\"\n    assert trapezium_median([2, 3, 5, 4]) == 3.5, \"6\""
    },
    {
      "rank": 78,
      "score": 7.774489185406606,
      "candidate": "def find_median_trapezium(arr):\n    if not arr:\n        return None\n    length = len(arr)\n    if length == 1:\n        return arr[0]\n    if length == 2:\n        if arr[0] > arr[1]:\n            return arr[0]\n        else:\n            return arr[1]\n    if length % 2 == 1:\n        return arr[length / 2]\n    mid = length / 2\n    if arr[mid - 1] < arr[mid]:\n        return arr[mid - 1]\n    if arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    return (arr[mid] + arr[mid - 1]) / 2\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print find_median_trapezium(arr)\n    arr = [1, 2, 3, 4, 5]\n    print find_median_trapezium(arr)\n    arr = [1, 2, 3, 4, 5, 6]\n    print find_median_trapezium(arr)\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    print find_median_trapezium(arr)\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print find_median_trapezium(arr)"
    },
    {
      "rank": 79,
      "score": 7.7173979514744815,
      "candidate": "import sys\n\ndef get_median(arr):\n    \"\"\"\n    Given an array of integers, return the median.\n    \"\"\"\n    # Get the length of the array\n    length = len(arr)\n\n    # If the length is even, return the average of the two mid-numbers\n    if length % 2 == 0:\n        return (arr[length/2] + arr[length/2-1]) / 2\n\n    # If the length is odd, return the average of the two mid-numbers\n    else:\n        return (arr[length/2] + arr[length/2+1]) / 2\n\nif __name__ == \"__main__\":\n    # Get the input from the user\n    arr = [int(i) for i in input().split()]\n\n    # Get the median of the input\n    median = get_median(arr)\n\n    # Print the median\n    print(median)"
    },
    {
      "rank": 80,
      "score": 7.689168256896106,
      "candidate": "def find_median(arr):\n    \"\"\"\n    Given an array of integers, find the median of the array.\n    \"\"\"\n    arr = sorted(arr)\n    mid = int(len(arr)/2)\n    if len(arr) % 2 == 0:\n        return (arr[mid] + arr[mid-1]) / 2\n    else:\n        return arr[mid]\n\ndef test_find_median():\n    arr = [1,2,3,4,5,6]\n    assert(find_median(arr) == 3.5)\n    arr = [2,2,3,4,5,6]\n    assert(find_median(arr) == 3)\n    arr = [2,3,4,5,6,7]\n    assert(find_median(arr) == 4.5)\n    arr = [1,2,3,4,5,6,7,8]\n    assert(find_median(arr) == 5.5)\n    arr = [1,2,3,4,5,6,7,8,9]\n    assert(find_median(arr) == 6.5)\n    arr = [1,2,3,4,5,6,7,8,9,10]\n    assert(find_median(arr) == 7.5)\n    arr = [1,2,3,4,5,6,7,8,9,10,11]\n    assert(find_median(arr) == 8.5)\n    arr = [1,2,3,4,5,6,7,8,9,10,11,12]\n    assert(find_median(arr) == 9.5)\n    arr = [1,2,3,4,5,6,7,8,9,10,11,12,13]\n    assert(find_median(arr) == 10.5)\n    arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]\n    assert(find_median(arr) == 11.5)\n    arr = [1,2,3,4,5"
    },
    {
      "rank": 81,
      "score": 7.448941304890342,
      "candidate": "from math import ceil\n\ndef get_median(arr):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        median = (left + right) / 2\n        if arr[median] < arr[median - 1]:\n            right = median - 1\n        elif arr[median] > arr[median + 1]:\n            left = median + 1\n        elif arr[median] == arr[median - 1] and arr[median] == arr[median + 1]:\n            return arr[median]\n\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5]\n    print get_median(arr)"
    },
    {
      "rank": 82,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return 'Point({}, {})'.format(self.x, self.y)\n\nclass Solution:\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if not A or not B:\n            return float('nan')\n        \n        a_len = len(A)\n        b_len = len(B)\n        if a_len > b_len:\n            return self.findMedianSortedArrays(B, A)\n        elif a_len < b_len:\n            return self.findMedianSortedArrays(A, B)\n        else:\n            if A[a_len/2] > B[b_len/2]:\n                return A[a_len/2]\n            else:\n                return B[b_len/2]\n\n    def findMedianSortedArrays2(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if not A or not B:\n            return float('nan')\n\n        a_len = len(A)\n        b_len = len(B)\n        if a_len > b_len:\n            return self.findMedianSortedArrays2(B, A)\n        elif a_len < b_len:\n            return self.findMedianSortedArrays2(A, B)\n        else:\n            if A[a_len/2] > B[b_len/2]:\n                return A[a_len/2]\n            else:\n                return B[b_len/2]\n\n\ndef main():\n    # print(Solution().findMedianSortedArrays([1,2,3], [4,5,6]))\n    print(Solution().findMedianSortedArrays(["
    },
    {
      "rank": 83,
      "score": 3.0,
      "candidate": "from math import sqrt\n\n\ndef get_median(arr):\n    \"\"\"\n    Given an array of numbers, return the median of the array.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    else:\n        left = arr[0]\n        right = arr[n - 1]\n        if left > right:\n            return arr[(n - 1) // 2]\n        else:\n            return (left + right) / 2\n\n\ndef get_median_recursive(arr):\n    \"\"\"\n    Given an array of numbers, return the median of the array.\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        return (get_median_recursive(arr[:len(arr) // 2]) +\n                get_median_recursive(arr[len(arr) // 2:])) / 2\n\n\ndef get_median_iterative(arr):\n    \"\"\"\n    Given an array of numbers, return the median of the array.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    else:\n        left = arr[0]\n        right = arr[n - 1]\n        if left > right:\n            return arr[(n - 1) // 2]\n        else:\n            return (left + right) / 2\n\n\ndef get_median_recursive_iterative(arr):\n    \"\"\"\n    Given an array of numbers, return the median of the array.\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        mid = len(arr) // 2\n        if arr[mid] > arr[mid - 1]:\n            return arr[mid]\n        else:\n            return (arr[mid] + arr[mid - 1]) / 2\n\n\nif __name__ == \"__main__\":\n    arr = [3, 4,"
    },
    {
      "rank": 84,
      "score": 3.0,
      "candidate": "def trapezium_median(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: float\n    \"\"\"\n    if len(arr) < 1:\n        return float('NaN')\n\n    left_max = arr[0]\n    left_min = arr[0]\n    right_max = arr[0]\n    right_min = arr[0]\n\n    for x in arr[1:]:\n        if x < left_min:\n            left_min = x\n        if x > right_max:\n            right_max = x\n        if x > left_max:\n            left_max = x\n\n    if left_min > left_max:\n        return float('NaN')\n\n    if right_max < right_min:\n        return float('NaN')\n\n    if left_max == left_min:\n        return float(left_min)\n    if right_max == right_min:\n        return float(right_min)\n\n    return (left_max + right_max) / 2.0\n\n\nif __name__ == '__main__':\n    assert trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4.5\n    assert trapezium_median([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 3.5\n    assert trapezium_median([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -3.5\n    assert trapezium_median([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8]) == 2.5"
    },
    {
      "rank": 85,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution:\n    # @param points, a list of points\n    # @return a list of point\n    def findMedianSortedArrays(self, points):\n        if len(points) == 0:\n            return None\n        if len(points) % 2 == 1:\n            return self.findMedianSortedArraysHelper(points)\n        else:\n            return (self.findMedianSortedArraysHelper(points[:len(points) / 2]) +\n                    self.findMedianSortedArraysHelper(points[len(points) / 2:])) / 2.0\n        \n    def findMedianSortedArraysHelper(self, points):\n        if len(points) == 1:\n            return points[0]\n        \n        left, right = 0, len(points) - 1\n        while left < right:\n            mid = left + (right - left) / 2\n            if points[mid].y < points[left].y:\n                left = mid + 1\n            elif points[mid].y > points[left].y:\n                right = mid\n            else:\n                return (points[left].x + points[mid].x + points[right].x) / 3.0\n        \n        if points[left].y < points[right].y:\n            return points[left].x\n        else:\n            return points[right].x"
    },
    {
      "rank": 86,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution:\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[Point]\n        :type B: List[Point]\n        :rtype: float\n        \"\"\"\n        # sort A and B\n        A.sort()\n        B.sort()\n        if len(A) == 0:\n            return float(B[-1].y)\n        elif len(B) == 0:\n            return float(A[-1].x)\n        else:\n            return (A[-1].x + B[-1].x) / 2.0"
    },
    {
      "rank": 87,
      "score": 3.0,
      "candidate": "# Definition for a point.\n# class Point(object):\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        n = len(A)\n        m = len(B)\n        if n == 0 or m == 0:\n            return None\n        if n == 1 and m == 1:\n            return A[0] if A[0] < B[0] else B[0]\n        if n == 1:\n            return B[0]\n        if m == 1:\n            return A[0]\n        if n == m:\n            return (A[0] + B[0]) / 2.0\n        if n > m:\n            return self.findMedianSortedArrays(B, A[:m])\n        return self.findMedianSortedArrays(A[:n], B[:m])\n\n\nif __name__ == \"__main__\":\n    assert Solution().findMedianSortedArrays([1, 2, 3, 4], [1, 2, 3, 5]) == 2.5"
    },
    {
      "rank": 88,
      "score": 3.0,
      "candidate": "from math import ceil\n\n\ndef median_of_trapezium(arr):\n    \"\"\"\n    Find the median of a trapezium of a list.\n\n    :param arr: A list of integers.\n    :return: The median of the trapezium.\n    \"\"\"\n    if len(arr) < 1:\n        raise ValueError(\"Input is empty.\")\n\n    if len(arr) == 1:\n        return arr[0]\n\n    left_sum = 0\n    right_sum = 0\n    for i in range(len(arr)):\n        left_sum += arr[i]\n        right_sum += arr[i] - arr[i - 1]\n\n    return (left_sum + right_sum) / 2\n\n\ndef test_median_of_trapezium():\n    assert median_of_trapezium([1, 2, 3]) == 2.5\n    assert median_of_trapezium([1, 2, 3, 4]) == 2.5\n    assert median_of_trapezium([1, 2, 3, 4, 5]) == 3.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6]) == 3.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7]) == 4.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8]) == 4.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 4.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 5.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 6.5\n    assert median_of_trapezium([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,"
    },
    {
      "rank": 89,
      "score": 3.0,
      "candidate": "def trapezium_median(arr):\n    \"\"\"\n    Write a function to find the median of a trapezium.\n\n    For a trapezium with a length of L, the median is the\n    middle element between the two ends, which is the element\n    with the median index.\n\n    Assume that the given array is sorted in ascending order.\n\n    Input:\n    A list of integers.\n\n    Output:\n    The median of the trapezium.\n    \"\"\"\n\n    # find the mid point of the trapezium\n    mid = len(arr) // 2\n\n    if len(arr) % 2 == 1:\n        return arr[mid]\n\n    return (arr[mid] + arr[mid - 1]) / 2\n\nif __name__ == \"__main__\":\n    assert trapezium_median([5, 4, 3, 2, 1]) == 2.5\n    assert trapezium_median([1, 2, 3]) == 2\n    assert trapezium_median([2, 3, 4]) == 2.5\n    assert trapezium_median([1, 2, 3, 4]) == 2.5\n    assert trapezium_median([1, 2, 3, 4, 5]) == 3.5\n    assert trapezium_median([1, 2, 3, 4, 5, 6]) == 3.5\n    assert trapezium_median([1, 2, 3, 4, 5, 6, 7]) == 3.5\n    assert trapezium_median([1, 2, 3, 4, 5, 6, 7, 8]) == 3.5\n    assert trapezium_median([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 3.5"
    },
    {
      "rank": 90,
      "score": 3.0,
      "candidate": "class Solution:\n    # @param {integer[]} heights\n    # @return {integer}\n    def trap(self, heights):\n        if len(heights) < 2:\n            return float('inf')\n        return max(heights[0], min(heights[1], heights[2]))\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.trap([1, 2, 3]))\n    print(sol.trap([1, 2, 3, 4]))\n    print(sol.trap([1, 2, 3, 4, 5]))\n    print(sol.trap([1, 2, 3, 4, 5, 6]))"
    },
    {
      "rank": 91,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if not A or not B:\n            return 0\n\n        A.sort()\n        B.sort()\n        return (A[A.index(A[len(A)/2])] + B[B.index(B[len(B)/2])]) / 2.0"
    },
    {
      "rank": 92,
      "score": 3.0,
      "candidate": "# https://oj.leetcode.com/problems/median-of-two-sorted-arrays/\n# Total Accepted: 83883\n# Total Submissions: 246687\n# Difficulty: Medium\n# Contributor: LeetCode\n# Given two integer arrays nums1 and nums2,\n# return the median of the two.\n#\n# The median is the middle value in the sorted order.\n# If the lengths are not equal, then the larger one is the median.\n# Example 1:\n# Input:\n# nums1 = [1, 3]\n# nums2 = [2]\n#\n# Output: 2\n# Example 2:\n# Input:\n# nums1 = [1, 2]\n# nums2 = [3, 4]\n#\n# Output: 2.5\n# Note:\n# The length of both nums1 and nums2 would not exceed 1000.\n# The input type and output type are both integer.\n# The two arrays' indexes and values would not exceed 1000.\n# Hide Company Tags Google\n# Hide Tags Array\n\n# https://leetcode.com/problems/median-of-two-sorted-arrays/solution/\n# time:O(n*m)\n# space:O(n)\nclass Solution(object):\n    # https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/153814/C%2B%2B-Python-O(n+m)-solution-with-explanation\n    # https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/153814/Python-O(n+m)-solution-with-explanation\n    # https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/153814/Python-O(n+m)-solution-with-explanation\n    # https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/153814/C%2B%2B-Python-O(n+m)-s"
    },
    {
      "rank": 93,
      "score": 3.0,
      "candidate": "def find_median_trapezium(a, b, c, d):\n    \"\"\"\n    Given the four numbers a, b, c, and d in the range [a, b], find the\n    median of the trapezium with the side c and d.\n    \"\"\"\n    return ((a + b) / 2.0) + (((c + d) / 2.0) - (a + b) / 2.0)\n\nif __name__ == \"__main__\":\n    #These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_median_trapezium(1, 2, 3, 4) == 2.5, \"1st example\"\n    assert find_median_trapezium(5, 7, 3, 6) == 5.5, \"2nd example\"\n    assert find_median_trapezium(1, 2, 4, 5) == 2.0, \"3rd example\"\n    assert find_median_trapezium(1, 2, 5, 6) == 2.5, \"4th example\"\n    assert find_median_trapezium(1, 2, 6, 7) == 2.5, \"5th example\""
    },
    {
      "rank": 94,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[Point]\n        :type B: List[Point]\n        :rtype: float\n        \"\"\"\n        if len(A) == 0 or len(B) == 0:\n            return 0\n        if len(A) == 1:\n            return min(A[0].x, B[0].x)\n        if len(A) == 2:\n            return min(A[0].x, B[0].x)\n        if len(B) == 2:\n            return min(A[0].x, B[0].x)\n        if len(A) == 3:\n            return min(A[0].x, B[0].x)\n        if len(B) == 3:\n            return min(A[0].x, B[0].x)\n        if len(A) == 4:\n            return (min(A[0].x, B[0].x) + min(A[1].x, B[1].x) + min(A[2].x, B[2].x) + min(A[3].x, B[3].x)) / 2.0\n        if len(B) == 4:\n            return (min(A[0].x, B[0].x) + min(A[1].x, B[1].x) + min(A[2].x, B[2].x) + min(A[3].x, B[3].x)) / 2.0\n        if len(A) == 5:\n            return (min(A[0].x, B[0].x) + min(A[1].x, B[1].x) + min(A[2].x, B[2].x) + min(A[3].x, B[3].x) + min(A[4].x, B[4].x)) / 2.0\n        if len(B) == 5:\n            return (min"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "import unittest\n\nclass Solution:\n    # @param {integer[]} height\n    # @return {integer}\n\n    def findMedianSortedArrays(self, height):\n        if len(height) == 0:\n            return 0\n        if len(height) == 1:\n            return height[0]\n        if len(height) % 2 == 1:\n            return (height[0] + height[1]) / 2\n        else:\n            return (height[len(height) / 2] + height[len(height) / 2 - 1]) / 2\n\nclass TestMethods(unittest.TestCase):\n    def test_Local(self):\n        self.assertEqual(1, 1)\n\nif __name__ == '__main__':\n    unittest.main()\n\nJava = '''\n# Thought: https://leetcode.com/problems/median-of-two-sorted-arrays/solution/\n\n# 1ms 100%\nclass Solution {\n    public double findMedianSortedArrays(int[] height) {\n        int[] left = new int[height.length], right = new int[height.length];\n        for (int i = 0; i < height.length; i++) {\n            if (i == 0) {\n                left[i] = height[i];\n            } else {\n                left[i] = Math.max(height[i - 1], height[i]);\n            }\n\n            if (i == height.length - 1) {\n                right[i] = height[i];\n            } else {\n                right[i] = Math.min(height[i + 1], height[i]);\n            }\n        }\n\n        double res = (double) (left[height.length / 2] + right[height.length / 2]) / 2.0;\n        return res;\n    }\n}\n\n# 1ms 100%\nclass Solution {\n    public double findMedianSortedArrays(int[] height) {\n        if (height.length == 0) return 0;\n        if (height.length == 1) return height[0];\n        int mid = (height.length + 1) / 2;\n        int left"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "class Solution:\n    # @param {integer} height\n    # @return {integer}\n    def findMedianSortedArrays(self, height):\n        \"\"\"\n        :type height: int\n        :rtype: int\n        \"\"\"\n        n1, n2, n3 = 0, 0, 0\n        for i in range(height):\n            if i < height / 2:\n                n1 += 1\n            else:\n                n2 += 1\n            if i < height / 3:\n                n3 += 1\n        return (n1 + n2 + n3) / 3\n\n    def findMedianSortedArrays2(self, height):\n        \"\"\"\n        :type height: int\n        :rtype: int\n        \"\"\"\n        n1, n2, n3 = 0, 0, 0\n        for i in range(height):\n            if i < height / 2:\n                n1 += 1\n            elif i < height / 3:\n                n2 += 1\n            else:\n                n3 += 1\n        return (n1 + n2 + n3) / 3"
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "class Solution:\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: float\n        \"\"\"\n        n1 = len(arr1)\n        n2 = len(arr2)\n        if n1 > n2:\n            return self.findMedianSortedArrays(arr2, arr1)\n        if n1 == 0 or n2 == 0:\n            return 0\n        i = n1 / 2\n        j = n2 / 2\n        while i < n1 and j < n2:\n            if arr1[i] < arr2[j]:\n                i += 1\n            else:\n                j += 1\n        if i == n1 and j == n2:\n            return (arr1[i] + arr2[j]) / 2\n        elif i == n1:\n            return arr2[j]\n        elif j == n2:\n            return arr1[i]\n        else:\n            return (arr1[i] + arr2[j]) / 2\n\na = Solution()\narr1 = [1, 2, 3]\narr2 = [4, 5, 6]\nprint(a.findMedianSortedArrays(arr1, arr2))"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "# https://oj.leetcode.com/problems/median-of-two-sorted-arrays/\n# Given two arrays sorted in ascending order, compute and return the median of the two.\n# The two sorted arrays are passed as a linked list.\n#\n# The algorithm should run in linear time and in O(1) space.\n#\n# Example:\n#\n# Input:\n# arr1 = [1, 3]\n# arr2 = [2, 4]\n#\n# Output:\n# 3\n#\n# Explanation:\n# The sorted arrays are: arr1 = [1, 3], arr2 = [2, 4]\n#\n# The middle value is 3.\n#\n# Note:\n#\n# arr1 and arr2 will have the same length.\n# Every element in arr1 and arr2 will be an integer.\n# arr1 and arr2 are already sorted in ascending order.\n#\n#\n#\n#\n# Note:\n#\n# Recursive solution is trivial, could you do it iteratively?\n#\n#\n#\n#\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def findMedianSortedArrays(self, arr1, arr2):\n        \"\"\"\n        :type arr1: ListNode\n        :type arr2: ListNode\n        :rtype: float\n        \"\"\"\n        if len(arr1) == 0 or len(arr2) == 0:\n            return 0.0\n\n        l = len(arr1)\n        r = len(arr2)\n        if l > r:\n            arr1, arr2 = arr2, arr1\n\n        mid = (l + r) / 2\n        arr1 = self.mergeSortedList(arr1, arr2, mid)\n\n        if mid % 2 == 1:\n            return arr1.val\n\n        return (arr1.val + arr2.val) / 2\n\n    def mergeSortedList(self, head, next, mid):\n        if mid == 0:\n            return head\n\n        head1 = ListNode(head.val"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "import random\n\n\ndef find_median_trapezium(a, b, c, d):\n    \"\"\"\n    Find the median of a trapezium.\n\n    :param a: The lower bound of the trapezium.\n    :param b: The upper bound of the trapezium.\n    :param c: The middle point of the trapezium.\n    :param d: The lower bound of the trapezium.\n    :return: The median of the trapezium.\n    \"\"\"\n    if a > b:\n        return a\n    if c > b and c < d:\n        return c\n    if c < d:\n        return d\n    return b\n\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    assert find_median_trapezium(1, 2, 3, 4) == 2.5, \"1\"\n    assert find_median_trapezium(1, 2, 4, 6) == 3.5, \"2\"\n    assert find_median_trapezium(1, 3, 2, 4) == 2.5, \"3\"\n    assert find_median_trapezium(1, 4, 2, 3) == 3.5, \"4\"\n    assert find_median_trapezium(1, 2, 3, 5) == 3.5, \"5\"\n    assert find_median_trapezium(2, 3, 4, 5) == 4.5, \"6\"\n    assert find_median_trapezium(2, 3, 4, 6) == 4.5, \"7\"\n    assert find_median_trapezium(2, 3, 5, 6) == 5.0, \"8\"\n    assert find_median_trapezium(3, 4, 5, 6) == 5.0, \"9\"\n    assert find_median_trapezium(4, 5, 6, 7) == 5.0, \"10\"\n    assert find_median_trapezium(1, 2, 3, 4) == 2.5, \"11\"\n    assert find_"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "# Definition for a point.\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        return 'Point({!r}, {!r})'.format(self.x, self.y)\n\nclass Solution(object):\n    def findMedianSortedArrays(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: float\n        \"\"\"\n        if not A or not B:\n            return None\n        if len(A) == len(B):\n            return (A[len(A)//2] + B[len(B)//2]) / 2\n        if len(A) > len(B):\n            return self.findMedianSortedArrays(B, A)\n        if len(A) == 1:\n            return A[0]\n        if len(B) == 1:\n            return B[0]\n        mid = len(A)//2\n        left = A[:mid]\n        right = B[:mid]\n        return (left[len(left)//2] + right[len(right)//2]) / 2\n\nif __name__ == '__main__':\n    sol = Solution()\n    A = [1, 2, 3]\n    B = [4, 5, 6]\n    assert(sol.findMedianSortedArrays(A, B) == 3.0)\n    A = [1, 2, 3, 4]\n    B = [5, 6, 7, 8]\n    assert(sol.findMedianSortedArrays(A, B) == 4.5)\n    A = [1, 2, 3, 4, 5]\n    B = [6, 7, 8, 9, 10]\n    assert(sol.findMedianSortedArrays(A, B) == 6.5)\n    A = [1, 2, 3, 4, 5, 6]\n    B = [7, 8, 9, 10, 11, 12]\n    assert(sol.findMedianSortedArrays(A,"
    }
  ]
}