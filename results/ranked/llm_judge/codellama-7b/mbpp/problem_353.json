{
  "timestamp": "2025-09-15T00:58:15.844411",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 353,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def number_of_flips(string):\n    count = 0\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(number_of_flips(\"11111111\"))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def flip_alternate(s):\n    count = 0\n    prev = None\n    for ch in s:\n        if ch != prev:\n            prev = ch\n        else:\n            count += 1\n            prev = None\n    return count\n\n\ndef main():\n    print(\"Number of flips: \" + str(flip_alternate(\"AAABBB\")))\n    print(\"Number of flips: \" + str(flip_alternate(\"AAABBBB\")))\n    print(\"Number of flips: \" + str(flip_alternate(\"BAABBBAAA\")))\n\n\nmain()\n\n\n\"\"\"\nTime O(N)\nSpace O(1)\n\"\"\""
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def flip_string_to_alternate(binary_string):\n    \"\"\"\n    Returns the number of flips required to make the binary string alternate.\n\n    >>> flip_string_to_alternate('01101100110111111110101111010001010101101110001')\n    2\n    >>> flip_string_to_alternate('0011')\n    0\n    \"\"\"\n    flips = 0\n    binary_string_list = list(binary_string)\n    for i in range(len(binary_string_list)):\n        if i % 2 == 0 and binary_string_list[i] == \"1\":\n            binary_string_list[i] = \"0\"\n            flips += 1\n        elif i % 2 == 1 and binary_string_list[i] == \"0\":\n            binary_string_list[i] = \"1\"\n            flips += 1\n    return flips\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def number_of_flip_alternate(bstring):\n    \"\"\"\n    >>> number_of_flip_alternate('AABBCCDDEEFF')\n    2\n    >>> number_of_flip_alternate('AAABBBCDDD')\n    2\n    >>> number_of_flip_alternate('AAABBBCDDDA')\n    2\n    >>> number_of_flip_alternate('AAABBBCDDDAABBBCDDD')\n    4\n    >>> number_of_flip_alternate('AAABBBCDDDAABBBCDDDAAABBBCDDD')\n    6\n    >>> number_of_flip_alternate('AAABBBCDDDAABBBCDDDAAABBBCDDDAAABBBCDDD')\n    8\n    >>> number_of_flip_alternate('AAABBBCDDDAABBBCDDDAAABBBCDDDAAABBBCDDDAAABBBCDDD')\n    10\n    \"\"\"\n    flips = 0\n    for i in range(1, len(bstring)):\n        if bstring[i] == bstring[i-1]:\n            flips += 1\n    return flips\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def alternate_flips(str):\n    if len(str) % 2 == 0:\n        return 0\n    else:\n        count = 0\n        for i in range(0, len(str)-1, 2):\n            if str[i] != str[i+1]:\n                count += 1\n        return count\n\nprint(alternate_flips(\"11111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# O(n) time | O(1) space\ndef alternate_binary_string(binary_string):\n    flips = 0\n    previous_bit = None\n    for bit in binary_string:\n        if previous_bit is not None and previous_bit != bit:\n            flips += 1\n        previous_bit = bit\n    return flips"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def flip_binary(binary_string):\n    count = 0\n    for i in range(1, len(binary_string)):\n        if binary_string[i] == binary_string[i - 1]:\n            count += 1\n    return count\n\n\ndef main():\n    print(flip_binary(\"11110000\"))\n    print(flip_binary(\"00010101\"))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def minFlipsMonoIncr(S):\n    \"\"\"\n    :type S: str\n    :rtype: int\n    \"\"\"\n    # initialise\n    n = len(S)\n    flips = 0\n    # print(\"n: \", n)\n\n    # sum up all 1s\n    ones = sum(1 for i in S if i == '1')\n    # print(\"ones: \", ones)\n\n    # flip the ones\n    flips += ones\n    # print(\"flips: \", flips)\n\n    # get the number of flips required to make the string monotonically increasing\n    flips += get_flips(S)\n\n    return flips\n\ndef get_flips(S):\n    \"\"\"\n    :type S: str\n    :rtype: int\n    \"\"\"\n    # initialise\n    n = len(S)\n    flips = 0\n    i = 0\n    j = 1\n    # print(\"n: \", n)\n\n    # sum up all 1s\n    while j < n:\n        if S[i] == '0' and S[j] == '1':\n            flips += 1\n            i += 1\n            j += 1\n        elif S[i] == '1' and S[j] == '0':\n            flips += 1\n            i += 1\n            j += 1\n        elif S[i] == '1' and S[j] == '1':\n            i += 1\n            j += 1\n        elif S[i] == '0' and S[j] == '0':\n            i += 1\n            j += 1\n    return flips\n\n\n\nif __name__ == \"__main__\":\n    S = \"001011101\"\n    print(minFlipsMonoIncr(S))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def alternating_bits(binary_string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    n = length of binary string\n    \"\"\"\n    count = 0\n    flips = 0\n    for i in range(len(binary_string)):\n        if binary_string[i] == binary_string[i - 1]:\n            count += 1\n            if count > 1:\n                flips += count\n        else:\n            count = 0\n    return flips\n\n\nif __name__ == \"__main__\":\n    print(alternating_bits(\"11111111\"))\n    print(alternating_bits(\"10101010\"))\n    print(alternating_bits(\"10101011\"))"
    },
    {
      "rank": 10,
      "score": 9.234050852198141,
      "candidate": "def flip_alternate_characters(s):\n    count = 0\n    prev = s[0]\n    for i in range(1, len(s)):\n        if s[i] == prev:\n            count += 1\n        prev = s[i]\n    return count\n\n\nprint(flip_alternate_characters(\"AA\"))\nprint(flip_alternate_characters(\"AAAABBB\"))\nprint(flip_alternate_characters(\"AAAABBBAABB\"))\n\n\n\"\"\"\nTime complexity: O(n)\nSpace complexity: O(1)\n\"\"\""
    },
    {
      "rank": 11,
      "score": 9.226766272351448,
      "candidate": "def flip_count(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    Parameters\n    ----------\n    s : str\n        binary string\n\n    Returns\n    -------\n    int\n        number of flips required to make the given binary string a sequence of alternate characters\n    \"\"\"\n\n    flip_count = 0\n    prev = s[0]\n    for i in range(1, len(s)):\n        if s[i] == prev:\n            flip_count += 1\n        prev = s[i]\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(flip_count(\"1100011000\"))"
    },
    {
      "rank": 12,
      "score": 9.183391466815202,
      "candidate": "def flips(s):\n    count = 0\n    for i in range(len(s)-1):\n        if s[i] == s[i+1]:\n            count += 1\n    return count\n\n\nprint(flips(\"101010101\"))"
    },
    {
      "rank": 13,
      "score": 9.177268828905222,
      "candidate": "def flip_binary_string(s):\n    \"\"\"\n    :param s: str - string\n    :return: int - flips\n    \"\"\"\n    return s.count('01')\n\n\nprint(flip_binary_string('1010'))\nprint(flip_binary_string('1100'))\nprint(flip_binary_string('0010'))"
    },
    {
      "rank": 14,
      "score": 8.932217008005624,
      "candidate": "def min_flips(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    flip_count = 0\n    prev_char = s[0]\n    for i in range(1, len(s)):\n        if s[i] == prev_char:\n            flip_count += 1\n        prev_char = s[i]\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(min_flips(\"00110\"))\n    print(min_flips(\"10111\"))\n    print(min_flips(\"010110\"))"
    },
    {
      "rank": 15,
      "score": 8.902145503295483,
      "candidate": "def flip_alternate_characters(binary_string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    total_flips = 0\n    for i in range(1, len(binary_string)):\n        if binary_string[i - 1] == binary_string[i]:\n            total_flips += 1\n    return total_flips"
    },
    {
      "rank": 16,
      "score": 8.855395696632057,
      "candidate": "def alternate(s):\n    count = 0\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] == '0':\n            count += 1\n        elif i % 2 == 1 and s[i] == '1':\n            count += 1\n    return count\n\n\nprint(alternate('111000'))\nprint(alternate('0011100'))\nprint(alternate('1010111101'))\nprint(alternate('10101111010'))\nprint(alternate('0000'))\nprint(alternate('1111'))"
    },
    {
      "rank": 17,
      "score": 8.8281618090209,
      "candidate": "def flips(s):\n    return len(s) - max(0, len(s) - 2 * s.count('01'))\n\nprint(flips('111001'))\nprint(flips('10010'))\nprint(flips('10011'))\nprint(flips('10010010'))"
    },
    {
      "rank": 18,
      "score": 8.692801520950061,
      "candidate": "def flip_sequence(input_string):\n    count = 0\n    for i in range(len(input_string) - 1):\n        if input_string[i] == input_string[i + 1]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(flip_sequence(\"11100010\"))\n    print(flip_sequence(\"00111\"))"
    },
    {
      "rank": 19,
      "score": 8.632293453617281,
      "candidate": "def alternate_flips(binary_string):\n    flips = 0\n    for i in range(len(binary_string) - 1):\n        if binary_string[i] == binary_string[i + 1]:\n            flips += 1\n\n    return flips\n\nprint(alternate_flips('11000'))\nprint(alternate_flips('10010'))\nprint(alternate_flips('10110'))"
    },
    {
      "rank": 20,
      "score": 8.625262456968262,
      "candidate": "def flip_bits(binary_string):\n    \"\"\"\n    Flips bits to get binary string with no consecutive 1s\n\n    Args:\n       binary_string(string): Binary String representing the number\n    Returns:\n       int: Number of flips to make the binary string an alternate sequence\n    \"\"\"\n    flips = 0\n    flip = False\n\n    for i in range(len(binary_string)-1):\n        if flip == binary_string[i]:\n            flips += 1\n            flip = not flip\n\n    return flips\n\nprint(flip_bits('1011100010111'))"
    },
    {
      "rank": 21,
      "score": 8.625142247198651,
      "candidate": "def num_flip_to_alternating(string):\n    if len(string) <= 1:\n        return 0\n    if string[0] == string[1]:\n        return 1 + num_flip_to_alternating(string[1:])\n    else:\n        return num_flip_to_alternating(string[1:])\n\n\ndef main():\n    print(num_flip_to_alternating('01010'))\n    print(num_flip_to_alternating('010100'))\n    print(num_flip_to_alternating('11111111'))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 22,
      "score": 8.623000730200317,
      "candidate": "def flip_bit_counter(binary_string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    flip_count = 0\n    flip_count += 1 if binary_string[0] == \"1\" else 0\n    for index in range(1, len(binary_string)):\n        if binary_string[index] == binary_string[index - 1]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(flip_bit_counter(\"111000111000\"))"
    },
    {
      "rank": 23,
      "score": 8.616253589228675,
      "candidate": "from collections import Counter\n\n\ndef alternate_flipping(s):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    c = Counter(s)\n\n    # if string is empty\n    if len(s) == 0:\n        return 0\n\n    # if the string contains only 0's\n    if c[0] == len(s):\n        return 0\n\n    # if the string contains only 1's\n    if c[1] == len(s):\n        return 0\n\n    # if the string contains 1's and 0's\n    return s.count(\"10\") + s.count(\"01\")\n\n\nif __name__ == \"__main__\":\n    print(alternate_flipping(\"010011101000101110111\"))"
    },
    {
      "rank": 24,
      "score": 8.610076160146226,
      "candidate": "def alternating_function(binary_string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param binary_string: str\n    :return: int\n    \"\"\"\n    count = 0\n    last_char = binary_string[0]\n\n    for char in binary_string[1:]:\n        if char == last_char:\n            count += 1\n        last_char = char\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(alternating_function(\"11111111\"))"
    },
    {
      "rank": 25,
      "score": 8.608819999274287,
      "candidate": "from collections import Counter\n\n\ndef count_flips(binary_string):\n    flips = 0\n    count = Counter(binary_string)\n    if count['0'] > count['1']:\n        flips += count['0'] - count['1']\n    elif count['0'] < count['1']:\n        flips += count['1'] - count['0']\n\n    return flips\n\n\nif __name__ == '__main__':\n    assert count_flips('1111') == 0\n    assert count_flips('1101') == 2\n    assert count_flips('1011') == 2\n    assert count_flips('1110') == 2\n    assert count_flips('0101') == 1\n    assert count_flips('0110') == 1\n    assert count_flips('0011') == 2\n    assert count_flips('0000') == 0"
    },
    {
      "rank": 26,
      "score": 8.606486429141842,
      "candidate": "from typing import List\n\n\nclass AlternateString:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    @staticmethod\n    def get_num_flips(input_string: str) -> int:\n        if not input_string:\n            return 0\n        flips = 0\n        flip_count = 0\n        for char in input_string:\n            if char == \"0\":\n                flip_count += 1\n            else:\n                flips += flip_count\n                flip_count = 0\n        return flips\n\n\nclass AlternateStringV2:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    @staticmethod\n    def get_num_flips(input_string: str) -> int:\n        if not input_string:\n            return 0\n        flips = 0\n        flip_count = 0\n        prev_char = None\n        for char in input_string:\n            if prev_char == \"0\" and char == \"1\":\n                flips += flip_count\n                flip_count = 0\n            else:\n                flip_count += 1\n            prev_char = char\n        return flips\n\n\nif __name__ == \"__main__\":\n    strings: List[str] = [\"0001\", \"1100\", \"0110\", \"1010\"]\n    for string in strings:\n        print(AlternateStringV2.get_num_flips(string))"
    },
    {
      "rank": 27,
      "score": 8.60156811074208,
      "candidate": "def flip_string(s):\n    i = 0\n    count = 0\n    while i < len(s) - 1:\n        if s[i] == s[i + 1]:\n            i += 1\n            count += 1\n        i += 1\n    return count\n\nif __name__ == '__main__':\n    print(flip_string(\"10101\"))\n    print(flip_string(\"1010110101\"))\n    print(flip_string(\"1100110011\"))\n    print(flip_string(\"10101010101\"))"
    },
    {
      "rank": 28,
      "score": 8.565425580227462,
      "candidate": "def alternating_flip(text):\n    flips = 0\n    for i in range(1, len(text)):\n        if text[i-1] == text[i]:\n            flips += 1\n            text = text[:i] + '0' + text[i+1:]\n    return flips\n\n\nprint(alternating_flip('111100001010'))\nprint(alternating_flip('10101'))\nprint(alternating_flip('00110011'))"
    },
    {
      "rank": 29,
      "score": 8.548876241946822,
      "candidate": "def alternating_bits(binary_string):\n    flip_count = 0\n    for i in range(len(binary_string) - 1):\n        if binary_string[i] == binary_string[i + 1]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(alternating_bits(\"0010111111\"))"
    },
    {
      "rank": 30,
      "score": 8.492983219118464,
      "candidate": "def binary_flip(binary_string):\n    count = 0\n    for i in range(1, len(binary_string)):\n        if binary_string[i - 1] == binary_string[i]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(binary_flip(\"101010\"))"
    },
    {
      "rank": 31,
      "score": 8.490324832712195,
      "candidate": "def flip_alternate(s):\n    flip_count = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            flip_count += 1\n            if s[i] == '0':\n                s = s[:i] + '1' + s[i + 1:]\n            else:\n                s = s[:i] + '0' + s[i + 1:]\n    return s, flip_count\n\n\ndef main():\n    print(flip_alternate(\"10010100101010101110100000000\"))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 32,
      "score": 8.48796797856353,
      "candidate": "def flip_bit(num):\n    return num ^ 1\n\n\ndef flip_bits(num):\n    flipped = 0\n    for i in range(len(num)):\n        if num[i] != num[i - 1]:\n            flipped += 1\n    return flipped\n\n\ndef flip_bits_alt(num):\n    flipped = 0\n    if len(num) <= 1:\n        return flipped\n\n    prev = num[0]\n    for i in range(1, len(num)):\n        if num[i] != prev:\n            flipped += 1\n            prev = num[i]\n    return flipped\n\n\nif __name__ == \"__main__\":\n    num = \"0110100011\"\n    print(flip_bits_alt(num))"
    },
    {
      "rank": 33,
      "score": 8.426531424889468,
      "candidate": "def flips(string):\n    count = 0\n    for i in range(len(string) - 1):\n        if string[i] == string[i + 1]:\n            count += 1\n    return count\n\n\nprint(flips(\"AAABB\"))\nprint(flips(\"ABAB\"))"
    },
    {
      "rank": 34,
      "score": 8.408439383654278,
      "candidate": "def flip_count(s):\n    # Flip the string s\n    # O(N)\n    flip_count = 0\n    for i in range(len(s)-1):\n        if s[i] == s[i+1]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(flip_count(\"AAABBBCC\"))\n    print(flip_count(\"AABBBC\"))\n    print(flip_count(\"AABAAB\"))\n    print(flip_count(\"AAABBBCCCC\"))\n    print(flip_count(\"AAABBBCCCCCC\"))\n    print(flip_count(\"AAABBBCCCCCCCCCC\"))"
    },
    {
      "rank": 35,
      "score": 8.375312293858853,
      "candidate": "def flip_string(s):\n    flip_count = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            flip_count += 1\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(flip_string(\"10101011100\"))\n    print(flip_string(\"00101011100\"))\n    print(flip_string(\"00100011100\"))\n    print(flip_string(\"10100011100\"))\n    print(flip_string(\"01010011100\"))\n    print(flip_string(\"01000011100\"))"
    },
    {
      "rank": 36,
      "score": 8.334608500525688,
      "candidate": "def flip_count(binary: str) -> int:\n    flips = 0\n    prev = binary[0]\n    for i in range(1, len(binary)):\n        if binary[i] == prev:\n            flips += 1\n            prev = binary[i] if prev == \"1\" else \"1\"\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert flip_count(\"0100\") == 1\n    assert flip_count(\"1010\") == 2\n    assert flip_count(\"1100\") == 1\n    assert flip_count(\"0000\") == 0"
    },
    {
      "rank": 37,
      "score": 8.327367757082776,
      "candidate": "def flip_string(string):\n    count = 0\n    current_char = string[0]\n    for i in range(1, len(string)):\n        if string[i] == current_char:\n            count += 1\n        current_char = string[i]\n    return count\n\nprint(flip_string('10101010111'))\nprint(flip_string('11001011111'))\nprint(flip_string('10011110111'))"
    },
    {
      "rank": 38,
      "score": 8.298597569547805,
      "candidate": "def num_flips(arr: list[str]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    count = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i - 1]:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    assert num_flips([\"0\", \"1\", \"0\", \"1\", \"1\", \"0\", \"1\", \"1\"]) == 3"
    },
    {
      "rank": 39,
      "score": 8.294940769211511,
      "candidate": "def countFlips(str1):\n    count = 0\n    for i in range(len(str1)-1):\n        if str1[i] == str1[i+1]:\n            count += 1\n    return count\n\nprint(countFlips(\"1010010101\"))"
    },
    {
      "rank": 40,
      "score": 8.2938925966498,
      "candidate": "def flip_sequence(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    i, j = 0, 1\n    count = 0\n\n    while j < len(s):\n        if s[i] == s[j]:\n            count += 1\n            i = j\n        j += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    print(flip_sequence(\"AA\"))"
    },
    {
      "rank": 41,
      "score": 8.289838256518838,
      "candidate": "def get_flips(s):\n    flips = 0\n    prev = None\n    for c in s:\n        if prev is None:\n            prev = c\n            continue\n\n        if prev == c:\n            flips += 1\n        prev = c\n\n    return flips\n\nprint(get_flips(\"0101\"))\nprint(get_flips(\"111000\"))\nprint(get_flips(\"101010101010101010\"))"
    },
    {
      "rank": 42,
      "score": 8.214125058964552,
      "candidate": "def make_alternating_string(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    flip_count = 0\n    last_char = s[0]\n\n    for i in range(1, len(s)):\n        if s[i] == last_char:\n            flip_count += 1\n        last_char = s[i]\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(make_alternating_string(\"AAAA\"))\n    print(make_alternating_string(\"AAAAA\"))\n    print(make_alternating_string(\"BBBBB\"))\n    print(make_alternating_string(\"ABABABAB\"))\n    print(make_alternating_string(\"BABABA\"))"
    },
    {
      "rank": 43,
      "score": 8.2048573255218,
      "candidate": "def flip_count(s):\n    count = 0\n    if s[0] == '0':\n        count += 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n    return count\n\n\nif __name__ == '__main__':\n    print(flip_count('010010110100110'))"
    },
    {
      "rank": 44,
      "score": 8.193565922652176,
      "candidate": "def make_alternate(string):\n    count = 0\n    flips = 0\n    for i in range(len(string)):\n        if string[i] == '0':\n            if i == 0:\n                count += 1\n            elif string[i - 1] == '0':\n                count += 1\n            else:\n                flips += count\n                count = 1\n        else:\n            if i == 0:\n                count += 1\n            elif string[i - 1] == '1':\n                count += 1\n            else:\n                flips += count\n                count = 1\n    return flips + count\n\n\nif __name__ == \"__main__\":\n    print(make_alternate('10110011100'))\n    print(make_alternate('1111'))"
    },
    {
      "rank": 45,
      "score": 8.172253082181854,
      "candidate": "def flip_alternate(binary_string):\n    count = 0\n    flip = 0\n\n    for i in range(len(binary_string) - 1):\n        if binary_string[i] == binary_string[i + 1]:\n            if flip == 0:\n                flip = 1\n                count += 1\n            else:\n                flip = 0\n                count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(flip_alternate(\"10010101\"))"
    },
    {
      "rank": 46,
      "score": 8.163300679823958,
      "candidate": "def number_of_flips(binary_string):\n    # write your code here\n    return 0\n\nif __name__ == \"__main__\":\n    print(number_of_flips(\"10101\"))\n    print(number_of_flips(\"11001010\"))"
    },
    {
      "rank": 47,
      "score": 8.143591138329747,
      "candidate": "def flip_bit(num, index):\n    return num ^ (1 << index)\n\ndef flip_bits(num):\n    index = 0\n    while num:\n        if num & 1:\n            num = flip_bit(num, index)\n        num >>= 1\n        index += 1\n    return num\n\ndef make_sequence(num):\n    if not num:\n        return 0\n    if num & 1:\n        return 0\n    return 1 + make_sequence(flip_bits(num))\n\nprint(make_sequence(11))"
    },
    {
      "rank": 48,
      "score": 8.040197642997851,
      "candidate": "def flip_sequence(binary_string):\n    \"\"\"\n    >>> flip_sequence(\"1111\")\n    2\n    >>> flip_sequence(\"0000\")\n    0\n    >>> flip_sequence(\"1100\")\n    2\n    >>> flip_sequence(\"1010\")\n    2\n    >>> flip_sequence(\"0010\")\n    3\n    >>> flip_sequence(\"0100\")\n    3\n    >>> flip_sequence(\"0011\")\n    3\n    >>> flip_sequence(\"0110\")\n    3\n    >>> flip_sequence(\"0101\")\n    3\n    >>> flip_sequence(\"1011\")\n    3\n    \"\"\"\n    count = 0\n    current_char = binary_string[0]\n    for i in range(1, len(binary_string)):\n        if binary_string[i] != current_char:\n            count += 1\n            current_char = binary_string[i]\n    return count\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 8.024835682833125,
      "candidate": "def flip_bit(num):\n    return num ^ 1\n\n\ndef count_flip(binary_string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    flip = 0\n    prev = None\n    for bit in binary_string:\n        if prev is None:\n            prev = bit\n        elif prev != bit:\n            prev = flip_bit(prev)\n            flip += 1\n        else:\n            prev = bit\n    return flip\n\n\nif __name__ == \"__main__\":\n    print(count_flip(\"0101011\"))"
    },
    {
      "rank": 50,
      "score": 7.990432406683839,
      "candidate": "def count_flip(s):\n    # Your code goes here\n    flips = 0\n    i = 0\n    j = 1\n    while i < len(s):\n        if j >= len(s):\n            flips += j-i\n            break\n        if s[i] != s[j]:\n            flips += 1\n            i = j\n            j = j + 1\n        else:\n            j += 1\n    return flips"
    },
    {
      "rank": 51,
      "score": 7.915588979966494,
      "candidate": "# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef alternate_sequence(input_string: str) -> int:\n    flips = 0\n    prev_char = input_string[0]\n\n    for i in range(1, len(input_string)):\n        if prev_char != input_string[i]:\n            flips += 1\n            prev_char = input_string[i]\n    return flips\n\n\nif __name__ == \"__main__\":\n    print(alternate_sequence(\"001011101\"))"
    },
    {
      "rank": 52,
      "score": 7.868947655733293,
      "candidate": "def alternate_flips(string):\n    count = 0\n    flips = 0\n    for i in range(len(string)):\n        if string[i] == \"0\" and string[i+1] == \"0\":\n            flips += 1\n        elif string[i] == \"1\" and string[i+1] == \"1\":\n            flips += 1\n        count += flips\n    return count\n\nprint(alternate_flips(\"1110000100011101\"))"
    },
    {
      "rank": 53,
      "score": 7.84634113240411,
      "candidate": "def flip_count(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    s = \"10101\"\n    result = flip_count(s)\n    print(result)"
    },
    {
      "rank": 54,
      "score": 7.780351419995229,
      "candidate": "def countFlips(s):\n    count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n    return count\n\nprint(countFlips(\"00000000\"))"
    },
    {
      "rank": 55,
      "score": 7.738292593776799,
      "candidate": "def flip_to_alternate(binary_string):\n    flips = 0\n    prev = None\n    for char in binary_string:\n        if prev is None:\n            prev = char\n        else:\n            if prev == char:\n                flips += 1\n            prev = char\n    return flips\n\n\nprint(flip_to_alternate(\"11000\"))\nprint(flip_to_alternate(\"10101\"))\nprint(flip_to_alternate(\"111000\"))\nprint(flip_to_alternate(\"11100011000\"))\nprint(flip_to_alternate(\"000111\"))"
    },
    {
      "rank": 56,
      "score": 7.7320703513377165,
      "candidate": "def flip_alternate_characters(string):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    prev = string[0]\n    count = 0\n\n    for i in range(1, len(string)):\n        if prev == string[i]:\n            count += 1\n        prev = string[i]\n\n    return count"
    },
    {
      "rank": 57,
      "score": 7.705183449260731,
      "candidate": "def flip_count(s: str) -> int:\n    count = 0\n    prev_char = s[0]\n    for char in s[1:]:\n        if char == prev_char:\n            count += 1\n        prev_char = char\n    return count\n\n\nif __name__ == \"__main__\":\n    assert flip_count(\"1100\") == 2\n    assert flip_count(\"0101\") == 4\n    assert flip_count(\"0000\") == 0"
    },
    {
      "rank": 58,
      "score": 7.4878043221155455,
      "candidate": "def flip_bits(arr):\n    return sum(arr[i] != arr[i + 1] for i in range(len(arr) - 1))\n\n\nprint(flip_bits([1, 1, 0, 0, 1, 0]))"
    },
    {
      "rank": 59,
      "score": 7.464609382504557,
      "candidate": "def alternate_flips(s: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(alternate_flips(\"00110110\"))"
    },
    {
      "rank": 60,
      "score": 3.7594340556486645,
      "candidate": "def count_flip(string: str) -> int:\n    \"\"\"\n    We can use two pointers to scan the string.\n    The first pointer will scan from left to right,\n    while the second pointer will scan from right to left.\n    We can also use a stack, and pop off the top element\n    whenever we encounter a character which is the same\n    as the top of the stack.\n    The number of flips will be the length of the stack\n    when we are done.\n    \"\"\"\n    flips = 0\n    stack = []\n\n    for char in string:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return len(stack)\n\n\nif __name__ == \"__main__\":\n    assert count_flip(\"101010\") == 2\n    assert count_flip(\"111111\") == 0\n    assert count_flip(\"10101\") == 2"
    },
    {
      "rank": 61,
      "score": 3.6305949922510474,
      "candidate": "def flip_alternating_characters(string):\n    flips = 0\n    for i in range(1, len(string)):\n        if string[i-1] == string[i]:\n            flips += 1\n    return flips\n\n\nimport unittest\n\n\nclass TestFirst(unittest.TestCase):\n    def test_first(self):\n        # self.assertEqual(flip_alternating_characters('AAAA'), 0)\n        self.assertEqual(flip_alternating_characters('AABCBABABAA'), 2)\n        self.assertEqual(flip_alternating_characters('BABABA'), 0)\n        self.assertEqual(flip_alternating_characters('AAABBB'), 4)\n        self.assertEqual(flip_alternating_characters('ABABABABABAB'), 0)\n        self.assertEqual(flip_alternating_characters('ABBABBABBABBABBBABBABBABBBBBBBBBBBBBBBBBBBBABBABBABBABBABBBBBBBBBBBBBBABABABABABBABBABBABBABBABBABBBBBBBBBBABBABBABBABBABBABBBBBBABBABBABBABBABBABBABBBB'), 2)\n        self.assertEqual(flip_alternating_characters('ABBABBABBABBABBBABBABBABBBBBBBBBBBBBBBBBBBBABBABBABBABBABBBBBBBBBBBBBBABABABABABBABBABBABBABBABBABBBBBBBBBBABBABBABBABBABBABBABBBB'), 2)\n        self.assertEqual(flip_alternating_characters('ABBABBABBABBABBBABBABBABBBBBBBBBBBBBBBBBBBBABBABBABBABBABBBBBBBBBBBBBBABABABABABBABBABBABBABBABBABBBBBBBBBBABBABBABBABBABBAB"
    },
    {
      "rank": 62,
      "score": 3.6244422411272903,
      "candidate": "class Solution:\n    def flip_count(self, s):\n        \"\"\"\n        :param s: str - binary string\n        :return: int - number of flips\n\n        >>> Solution().flip_count(\"11111111\")\n        0\n        >>> Solution().flip_count(\"00110011\")\n        2\n        >>> Solution().flip_count(\"01010101\")\n        4\n        >>> Solution().flip_count(\"00101101\")\n        4\n        >>> Solution().flip_count(\"01010000\")\n        3\n        >>> Solution().flip_count(\"10101010\")\n        3\n        >>> Solution().flip_count(\"10000000\")\n        6\n        \"\"\"\n        return s.count(\"01\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 63,
      "score": 3.5560584117140372,
      "candidate": "\"\"\"Question:\nWrite a function to find the number of flips required to make the given binary string a sequence of alternate characters.\nExample:\nInput: 10101111110000101011111\nOutput: 2\n\"\"\"\n\nclass Solution:\n    def binaryFlipping(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        #Solution 1\n        # def flip(num):\n        #     return num^1\n        # count=0\n        # for i in range(len(a)):\n        #     if a[i]!=b[i]:\n        #         count+=1\n        #     if a[i]!=flip(b[i]):\n        #         count+=1\n        # return count\n\n        #Solution 2\n        return bin(int(a,2)^int(b,2)).count('1')\n        # return len(bin(int(a,2)^int(b,2))[2:].split('1'))\n\n        #Solution 3\n        # return sum(map(lambda x,y: x^y, map(int, a), map(int, b)))"
    },
    {
      "rank": 64,
      "score": 3.4334201127497552,
      "candidate": "def count_flips(binary_string):\n    \"\"\"\n    >>> count_flips('1100000000')\n    1\n    >>> count_flips('1100000001')\n    2\n    >>> count_flips('1100000010')\n    1\n    >>> count_flips('1000000000')\n    0\n    >>> count_flips('1000000001')\n    0\n    \"\"\"\n    flip_count = 0\n    for i in range(1, len(binary_string)):\n        if binary_string[i - 1] == binary_string[i]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 65,
      "score": 3.4227098042233397,
      "candidate": "def count_flip(binary_string):\n    \"\"\"\n    >>> count_flip(\"1010\")\n    1\n    >>> count_flip(\"0011\")\n    2\n    >>> count_flip(\"0101\")\n    2\n    >>> count_flip(\"0110\")\n    2\n    >>> count_flip(\"1011\")\n    1\n    \"\"\"\n    if len(binary_string) == 0:\n        return 0\n    if len(binary_string) == 1:\n        return 0\n    if len(binary_string) == 2:\n        if binary_string[0] == binary_string[1]:\n            return 0\n        else:\n            return 1\n    if binary_string[0] == binary_string[1]:\n        return count_flip(binary_string[1:])\n    else:\n        return 1 + count_flip(binary_string[1:])\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 3.41144848813573,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def alternating_bits(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count\n\n    def alternating_bits_2(self, num: int) -> int:\n        return bin(num).count(\"1\") - bin(num).count(\"01\")\n\n    def alternating_bits_3(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count\n\n    def alternating_bits_4(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count\n\n    def alternating_bits_5(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count\n\n    def alternating_bits_6(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count\n\n    def alternating_bits_7(self, num: int) -> int:\n        count = 0\n        prev = num & 1\n        while num != 0:\n            num >>= 1\n            if num & 1 == prev:\n                count += 1\n            prev = num & 1\n        return count"
    },
    {
      "rank": 67,
      "score": 3.3818248488376415,
      "candidate": "from typing import List\n\n\ndef flip_binary_string(input_string: str) -> int:\n    \"\"\"\n    >>> flip_binary_string(\"111000100110\")\n    2\n    >>> flip_binary_string(\"00111\")\n    0\n    >>> flip_binary_string(\"00110\")\n    1\n    >>> flip_binary_string(\"00101\")\n    3\n    \"\"\"\n\n    # number of flips\n    num_flip: int = 0\n\n    # iterate through the string\n    for i in range(len(input_string) - 1):\n\n        # if adjacent characters are not alternating\n        if input_string[i] == input_string[i + 1]:\n\n            # flip the adjacent characters\n            input_string = (\n                input_string[:i] + input_string[i + 1] + input_string[i] + input_string[i + 2 :]\n            )\n            num_flip += 1\n\n    return num_flip\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 68,
      "score": 3.3372434139623075,
      "candidate": "def flip_alternate(input_str: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    flips = 0\n\n    if len(input_str) <= 1:\n        return flips\n\n    prev = input_str[0]\n\n    for char in input_str[1:]:\n        if char != prev:\n            flips += 1\n            prev = char\n\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert flip_alternate(\"10010\") == 1\n    assert flip_alternate(\"10101\") == 2\n    assert flip_alternate(\"01010\") == 2\n    assert flip_alternate(\"00000\") == 0\n    assert flip_alternate(\"11111\") == 0\n    assert flip_alternate(\"11001\") == 1"
    },
    {
      "rank": 69,
      "score": 3.333135587181621,
      "candidate": "from collections import Counter\n\n\ndef flips(input_str: str) -> int:\n    \"\"\"\n    >>> flips(\"0100\")\n    2\n    >>> flips(\"1111\")\n    0\n    >>> flips(\"01001110\")\n    3\n    >>> flips(\"010100\")\n    3\n    \"\"\"\n    if not input_str:\n        return 0\n\n    count = Counter(input_str)\n    if count[\"0\"] > count[\"1\"]:\n        return count[\"0\"] - count[\"1\"]\n    elif count[\"0\"] < count[\"1\"]:\n        return count[\"1\"] - count[\"0\"]\n    else:\n        return 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 70,
      "score": 3.302771297798118,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def min_flips_mono_incr(self, s: str) -> int:\n        flips = 0\n        prev = 0\n        for i in range(len(s)):\n            if s[i] == '0':\n                prev = prev + 1\n            else:\n                flips += min(prev, 1)\n                prev = 0\n        return flips + prev\n\n    def min_flips_mono_decr(self, s: str) -> int:\n        flips = 0\n        prev = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == '0':\n                prev = prev + 1\n            else:\n                flips += min(prev, 1)\n                prev = 0\n        return flips\n\n    def min_flips_mono_incr_2(self, s: str) -> int:\n        flips = 0\n        prev = 0\n        for i in range(len(s)):\n            if s[i] == '0':\n                prev = prev + 1\n            else:\n                flips += min(prev, 1)\n                prev = 0\n        return flips + prev\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.min_flips_mono_incr(\"010011101\") == 3\n    assert s.min_flips_mono_incr(\"11111110\") == 2\n    assert s.min_flips_mono_incr(\"001011101\") == 3\n    assert s.min_flips_mono_incr(\"101011101\") == 2\n    assert s.min_flips_mono_incr(\"010011100\") == 3\n    assert s.min_flips_mono_incr(\"101011100\") == 2\n    assert s"
    },
    {
      "rank": 71,
      "score": 3.265552300621284,
      "candidate": "def flip_count(string: str) -> int:\n    \"\"\"\n    >>> flip_count(\"01010\")\n    2\n    >>> flip_count(\"10011\")\n    2\n    >>> flip_count(\"11111\")\n    0\n    \"\"\"\n    if not string:\n        return 0\n\n    flip_count = 0\n\n    for i in range(1, len(string)):\n        if string[i] == string[i - 1]:\n            flip_count += 1\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 72,
      "score": 3.250787278424756,
      "candidate": "def make_alternate(s: str) -> int:\n    \"\"\"\n    >>> make_alternate(\"01000\")\n    1\n    >>> make_alternate(\"01000100\")\n    2\n    >>> make_alternate(\"0100010011\")\n    3\n    >>> make_alternate(\"01000100111\")\n    3\n    >>> make_alternate(\"010001001111\")\n    3\n    >>> make_alternate(\"0100010011110\")\n    3\n    \"\"\"\n    return s.count(\"10\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 73,
      "score": 3.2224496178702453,
      "candidate": "def flip_count(s):\n    flip_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            flip_count += 1\n    return flip_count\n\n\ndef flip_count_2(s):\n    flip_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    print(flip_count(\"00000\"))"
    },
    {
      "rank": 74,
      "score": 3.210439647576476,
      "candidate": "def flips_alternating(binary):\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 111010101010111101010101111010101\n    # 1110101010101111"
    },
    {
      "rank": 75,
      "score": 3.0807131067063405,
      "candidate": "from typing import List\n\n\ndef alternate_flipping(seq: str) -> int:\n    \"\"\"\n    >>> alternate_flipping('101')\n    0\n    >>> alternate_flipping('1001')\n    1\n    >>> alternate_flipping('1010')\n    1\n    >>> alternate_flipping('11010')\n    2\n    >>> alternate_flipping('010110')\n    2\n    >>> alternate_flipping('011010')\n    2\n    >>> alternate_flipping('1100101')\n    2\n    >>> alternate_flipping('01100101')\n    3\n    \"\"\"\n    flips = 0\n\n    for i in range(1, len(seq)):\n        if seq[i] == seq[i - 1]:\n            flips += 1\n    return flips\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 76,
      "score": 3.070260995287888,
      "candidate": "class Solution:\n    def alternating_bits(self, num: int) -> int:\n        count = 0\n        while num:\n            if num & 1:\n                if num & 2:\n                    count += 1\n                else:\n                    return -1\n            num >>= 1\n        return count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    assert s.alternating_bits(1152) == 2\n    assert s.alternating_bits(1280) == 0\n    assert s.alternating_bits(1) == 0\n    assert s.alternating_bits(4) == -1"
    },
    {
      "rank": 77,
      "score": 3.045478261781045,
      "candidate": "def flip_bits(number):\n    \"\"\"\n    Flips the bits of the given number\n    \"\"\"\n    return bin(number ^ (1 << (len(bin(number)) - 2)))[2:]\n\ndef flip_alternate(number):\n    \"\"\"\n    Flips the bits of the given number\n    \"\"\"\n    return bin(number ^ (1 << (len(bin(number)) - 3)))[2:]\n\ndef make_alternate(number):\n    \"\"\"\n    Returns the number of flips required to make the given number an alternate number\n    \"\"\"\n    if number % 2 == 1:\n        number = flip_bits(number)\n    if number % 4 == 2:\n        number = flip_bits(number)\n    return number\n\ndef make_alternate_reverse(number):\n    \"\"\"\n    Returns the number of flips required to make the given number an alternate number\n    \"\"\"\n    if number % 2 == 0:\n        number = flip_bits(number)\n    if number % 4 == 1:\n        number = flip_bits(number)\n    return number\n\ndef find_flips(binary_string):\n    \"\"\"\n    Returns the number of flips required to make the given binary string an alternate number\n    \"\"\"\n    number = int(binary_string, 2)\n    return find_flips_number(number)\n\ndef find_flips_number(number):\n    \"\"\"\n    Returns the number of flips required to make the given number an alternate number\n    \"\"\"\n    if number < 2:\n        return number\n    return find_flips_number(make_alternate(number)) + 1\n\ndef find_flips_reverse(binary_string):\n    \"\"\"\n    Returns the number of flips required to make the given binary string an alternate number\n    \"\"\"\n    number = int(binary_string, 2)\n    return find_flips_reverse_number(number)\n\ndef find_flips_reverse_number(number):\n    \"\"\"\n    Returns the number of flips required to make the given number an alternate number\n    \"\"\"\n    if number < 2:"
    },
    {
      "rank": 78,
      "score": 3.0276865639220487,
      "candidate": "\"\"\"Question:\nWrite a function to find the number of flips required to make the given binary string a sequence of alternate characters.\nExample:\nInput: 110001\nOutput: 2\n\"\"\"\n\nclass Solution(object):\n    def binaryFlips(self, a):\n        \"\"\"\n        :type a: str\n        :rtype: int\n        \"\"\"\n        # #Method 1:\n        count=0\n        for i in range(len(a)):\n            if i>0 and a[i]==a[i-1]:\n                count=count+1\n        return count\n\n        # #Method 2:\n        count=0\n        for i in range(len(a)-1):\n            if a[i]==a[i+1]:\n                count=count+1\n        return count"
    },
    {
      "rank": 79,
      "score": 2.9944661378574473,
      "candidate": "def flip_bit(b: int, i: int):\n    return b ^ (1 << i)\n\n\ndef flip_bit_to_0(b: int, i: int):\n    return b & ~(1 << i)\n\n\ndef flip_bit_to_1(b: int, i: int):\n    return b | (1 << i)\n\n\ndef alternate_characters(s: str) -> int:\n    if len(s) == 0:\n        return 0\n\n    flips = 0\n    prev_bit = int(s[0])\n    for i, c in enumerate(s[1:], start=1):\n        current_bit = int(c)\n        if current_bit != prev_bit:\n            flips += 1\n            prev_bit = current_bit\n        else:\n            prev_bit = flip_bit_to_0(prev_bit, i)\n\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert alternate_characters(\"001011\") == 4\n    assert alternate_characters(\"10101\") == 2\n    assert alternate_characters(\"01010\") == 0\n    assert alternate_characters(\"11111111\") == 0"
    },
    {
      "rank": 80,
      "score": 2.9525842042208215,
      "candidate": "def flip_bits(binary_string: str) -> int:\n    \"\"\"\n    >>> flip_bits('00111010')\n    2\n    >>> flip_bits('11111111')\n    0\n    >>> flip_bits('01010101')\n    4\n    \"\"\"\n    counter = 0\n    for i in range(len(binary_string) - 1):\n        if binary_string[i] == binary_string[i + 1]:\n            counter += 1\n    return counter\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 81,
      "score": 2.923879819567835,
      "candidate": "def flip_count(arr):\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n    return count\n\n\ndef flip_count_v2(arr):\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n    return count\n\n\ndef flip_count_v3(arr):\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n    return count\n\n\ndef main():\n    arr = [1, 0, 0, 1, 1]\n    result = flip_count(arr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 82,
      "score": 2.9074317168005206,
      "candidate": "def flip_alternate(s):\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    assert flip_alternate(\"AAAABBBB\") == 2\n    assert flip_alternate(\"ABAB\") == 0\n    assert flip_alternate(\"BABAB\") == 0\n    assert flip_alternate(\"AAABBB\") == 2\n    assert flip_alternate(\"AAAABBBBABAB\") == 4\n    assert flip_alternate(\"AAAAABBBBABAB\") == 4\n    assert flip_alternate(\"AAAAABBBBBBBBBBBBBB\") == 6"
    },
    {
      "rank": 83,
      "score": 2.904003847650836,
      "candidate": "def flips_to_make_alternating(arr: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    flips = 0\n\n    prev_char = None\n    for char in arr:\n        if prev_char is None:\n            prev_char = char\n        elif prev_char == char:\n            flips += 1\n            prev_char = char\n\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert flips_to_make_alternating(\"AAABBB\") == 1\n    assert flips_to_make_alternating(\"AA\") == 0\n    assert flips_to_make_alternating(\"AAB\") == 1\n    assert flips_to_make_alternating(\"AABBBAA\") == 2\n    assert flips_to_make_alternating(\"ABAB\") == 2"
    },
    {
      "rank": 84,
      "score": 2.8421162650293104,
      "candidate": "def count_flip(string):\n    \"\"\"\n    >>> count_flip('10101010')\n    2\n    >>> count_flip('01010101')\n    1\n    >>> count_flip('11111111')\n    0\n    >>> count_flip('10101011')\n    0\n    \"\"\"\n    count = 0\n    prev = string[0]\n    for ch in string[1:]:\n        if ch != prev:\n            count += 1\n            prev = ch\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 85,
      "score": 2.8099987459468903,
      "candidate": "def flip_bit(number):\n    return number ^ 1\n\ndef flip_bits(binary_string):\n    \"\"\"\n    :param binary_string: str\n    :return: int\n    \"\"\"\n    if binary_string is None or len(binary_string) == 0:\n        return 0\n    if len(binary_string) == 1:\n        return 0 if binary_string == \"0\" else 1\n\n    flip_count = 0\n\n    if binary_string[0] == \"0\":\n        flip_count += 1\n\n    for i in range(1, len(binary_string)):\n        if binary_string[i] == binary_string[i - 1]:\n            flip_count += 1\n\n    return flip_count\n\n\ndef test_function(test_case):\n    binary_string = test_case[0]\n    solution = test_case[1]\n    output = flip_bits(binary_string)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\nbinary_string = \"0011100110\"\nsolution = 2\ntest_case = [binary_string, solution]\ntest_function(test_case)"
    },
    {
      "rank": 86,
      "score": 2.8090508010361948,
      "candidate": "\"\"\"\nInput: 1011101\nOutput: 2\n\nInput: 11110000000\nOutput: 3\n\nInput: 10001010100\nOutput: 4\n\nInput: 00001111111\nOutput: 0\n\nInput: 10101000000\nOutput: 3\n\"\"\"\n\ndef flip_binary(binary_string):\n    # find the first non-zero bit\n    flips = 0\n    for i in range(len(binary_string)):\n        if binary_string[i] == '1':\n            break\n    # compare the rest of the string to the first non-zero bit\n    for j in range(i + 1, len(binary_string)):\n        if binary_string[j] != binary_string[i]:\n            flips += 1\n    return flips\n\nassert flip_binary('1011101') == 2\nassert flip_binary('11110000000') == 3\nassert flip_binary('10001010100') == 4\nassert flip_binary('00001111111') == 0\nassert flip_binary('10101000000') == 3"
    },
    {
      "rank": 87,
      "score": 2.8075155017666695,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def minFlips(self, target: str) -> int:\n        \"\"\"\n        Time complexity: O(n) where n is the length of target\n        Space complexity: O(1)\n        \"\"\"\n        flip_count = 0\n        prev = 0\n        for c in target:\n            flip = 1 if c == '1' else 0\n            if flip != prev:\n                flip_count += 1\n            prev = flip\n        return flip_count\n\n\nif __name__ == '__main__':\n    s = Solution()\n    target = \"01001110110\"\n    print(s.minFlips(target))"
    },
    {
      "rank": 88,
      "score": 2.7875092105078045,
      "candidate": "def flip_sequence(s):\n    flips = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            flips += 1\n    return flips\n\n\ndef test_flip_sequence():\n    assert flip_sequence(\"0011\") == 0\n    assert flip_sequence(\"0101\") == 2\n    assert flip_sequence(\"0000\") == 0\n    assert flip_sequence(\"0111\") == 2\n    assert flip_sequence(\"1000\") == 2\n    assert flip_sequence(\"1111\") == 0\n    assert flip_sequence(\"0001\") == 1\n    assert flip_sequence(\"0010\") == 1\n    assert flip_sequence(\"0100\") == 1\n    assert flip_sequence(\"1001\") == 1\n    assert flip_sequence(\"1010\") == 1\n    assert flip_sequence(\"1100\") == 1\n    assert flip_sequence(\"1001\") == 1\n    assert flip_sequence(\"10011\") == 2\n    assert flip_sequence(\"10010\") == 1\n    assert flip_sequence(\"10100\") == 1\n    assert flip_sequence(\"10011\") == 2\n    assert flip_sequence(\"10100\") == 1\n    assert flip_sequence(\"10100110\") == 1\n    assert flip_sequence(\"10011010\") == 1\n\n\nif __name__ == '__main__':\n    test_flip_sequence()"
    },
    {
      "rank": 89,
      "score": 2.782798316455514,
      "candidate": "def find_flips(s):\n    flip_count = 0\n    flip_idx = 0\n    for i in range(len(s)):\n        if i != 0 and s[i] == s[i-1]:\n            flip_idx = i\n            break\n    for i in range(flip_idx, len(s)):\n        if s[i] != s[i-1]:\n            flip_count += 1\n    return flip_count\n\n\nprint(find_flips(\"AAABBB\"))\nprint(find_flips(\"AA\"))\nprint(find_flips(\"ABABABABAB\"))"
    },
    {
      "rank": 90,
      "score": 2.75373813713329,
      "candidate": "def flip_string(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(string) <= 1:\n        return 0\n\n    flips = 0\n\n    previous = string[0]\n    for character in string[1:]:\n        if previous == character:\n            flips += 1\n        previous = character\n\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert flip_string(\"AAABBB\") == 2\n    assert flip_string(\"AA\") == 0\n    assert flip_string(\"ABBBB\") == 1"
    },
    {
      "rank": 91,
      "score": 2.735500900611899,
      "candidate": "from typing import List\n\n\ndef flip_count(binary_string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    flips = 0\n    prev_bit = None\n\n    for bit in binary_string:\n        if bit == prev_bit:\n            flips += 1\n        prev_bit = bit\n\n    return flips\n\n\ndef flip_count_alt(binary_string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    flip_count = 0\n    flip_map = {}\n\n    for i, bit in enumerate(binary_string):\n        if bit in flip_map and flip_map[bit] == i:\n            flip_count += 1\n        else:\n            flip_map[bit] = i\n\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    assert flip_count(\"1010\") == 2\n    assert flip_count(\"0101\") == 4\n    assert flip_count(\"0000\") == 0\n    assert flip_count(\"10101010\") == 4\n    assert flip_count(\"1010101010101010\") == 6\n\n    assert flip_count_alt(\"1010\") == 2\n    assert flip_count_alt(\"0101\") == 4\n    assert flip_count_alt(\"0000\") == 0\n    assert flip_count_alt(\"10101010\") == 4\n    assert flip_count_alt(\"1010101010101010\") == 6"
    },
    {
      "rank": 92,
      "score": 2.722461979874557,
      "candidate": "def alternate_binary_string(binary_string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    flip_count = 0\n    for i in range(1, len(binary_string)):\n        if binary_string[i] == binary_string[i - 1]:\n            flip_count += 1\n    return flip_count\n\n\nif __name__ == \"__main__\":\n    assert alternate_binary_string(\"0111001010111\") == 3"
    },
    {
      "rank": 93,
      "score": 2.7048638745581695,
      "candidate": "def alternating_characters(s):\n    # First character is always the first char, so we start from 1\n    count = 0\n    # We iterate from the second character onwards\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n    return count\n\n\ns = \"AAABBB\"\nprint(alternating_characters(s))"
    },
    {
      "rank": 94,
      "score": 2.5847392406628864,
      "candidate": "def flips_to_alternating_chars(binary_string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(binary_string) <= 1:\n        return 0\n\n    flips = 0\n    prev_char = binary_string[0]\n\n    for char in binary_string[1:]:\n        if prev_char == char:\n            flips += 1\n\n        prev_char = char\n\n    return flips\n\n\nif __name__ == \"__main__\":\n    assert flips_to_alternating_chars(\"1100\") == 2\n    assert flips_to_alternating_chars(\"1111\") == 0\n    assert flips_to_alternating_chars(\"1010\") == 2\n    assert flips_to_alternating_chars(\"0101\") == 2\n    assert flips_to_alternating_chars(\"0000\") == 0"
    },
    {
      "rank": 95,
      "score": 2.5464026606575283,
      "candidate": "def alternating_bits(bits: str) -> int:\n    \"\"\"\n    Alternating bits\n    >>> alternating_bits(\"010011\")\n    3\n    >>> alternating_bits(\"1111\")\n    2\n    >>> alternating_bits(\"0010\")\n    2\n    >>> alternating_bits(\"0000\")\n    0\n    >>> alternating_bits(\"11110000\")\n    2\n    >>> alternating_bits(\"01010101\")\n    4\n    >>> alternating_bits(\"11000100\")\n    2\n    >>> alternating_bits(\"10011\")\n    1\n    >>> alternating_bits(\"11111\")\n    0\n    >>> alternating_bits(\"00000\")\n    0\n    >>> alternating_bits(\"01001100\")\n    2\n    >>> alternating_bits(\"111100000\")\n    2\n    >>> alternating_bits(\"00000000\")\n    0\n    >>> alternating_bits(\"010101010\")\n    4\n    >>> alternating_bits(\"110001000\")\n    2\n    >>> alternating_bits(\"000000000\")\n    0\n    \"\"\"\n    # To find the number of flips required to make the given binary string a sequence of alternate characters\n    # we have to count the number of times the bits alternate.\n    # To count the number of times the bits alternate we can use the XOR operation\n    # XOR operation can be used to find the number of bits that are different from the previous bit.\n    # So, we can use XOR operation to count the number of bits that are different from the previous bit\n    # and the count of times the bits alternate will be the number of times the XOR operation gives 1.\n\n    flip = 0\n    prev = int(bits[0])\n\n    for i in range(1, len(bits)):\n        if prev != int(bits[i]):\n            flip += 1\n        prev = int"
    },
    {
      "rank": 96,
      "score": 2.499454103511881,
      "candidate": "def number_of_flips(arr):\n    return len([1 for i in range(len(arr)-1) if arr[i] == arr[i+1]])\n\n\ndef test_number_of_flips():\n    assert number_of_flips(\"000\") == 0\n    assert number_of_flips(\"001\") == 1\n    assert number_of_flips(\"110\") == 1\n    assert number_of_flips(\"111\") == 0\n    assert number_of_flips(\"11101011\") == 4\n    assert number_of_flips(\"10101\") == 2\n    assert number_of_flips(\"01010\") == 2\n    assert number_of_flips(\"0101000101\") == 3\n    assert number_of_flips(\"10101010\") == 2\n    assert number_of_flips(\"10010010\") == 2\n    assert number_of_flips(\"10101101\") == 2\n    assert number_of_flips(\"11010101\") == 2\n    assert number_of_flips(\"11010010\") == 2\n    assert number_of_flips(\"000000000000\") == 0\n    assert number_of_flips(\"000000000001\") == 1\n    assert number_of_flips(\"111111111111\") == 0\n    assert number_of_flips(\"111111111110\") == 1\n    assert number_of_flips(\"0000000000000000000000000000000000000000000000000000000000000000\") == 0\n    assert number_of_flips(\"0000"
    },
    {
      "rank": 97,
      "score": 2.2927836886696564,
      "candidate": "class Solution:\n    def flip_alternate_bit(self, s: str) -> int:\n        s = [int(bit) for bit in s]\n        flips = 0\n        for i in range(1, len(s)):\n            if (s[i] == 1 and s[i-1] == 0) or (s[i] == 0 and s[i-1] == 1):\n                s[i] = 1 - s[i]\n                s[i-1] = 1 - s[i-1]\n                flips += 2\n        return flips\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.flip_alternate_bit(\"01000101000101000101\")"
    },
    {
      "rank": 98,
      "score": 2.277153536301279,
      "candidate": "def make_sequence(str):\n    count = 0\n    flag = 0\n    for i in range(len(str)):\n        if flag == 0:\n            flag = 1\n        else:\n            flag = 0\n        if flag == 1:\n            if str[i] == '1':\n                count += 1\n            else:\n                flag = 0\n        else:\n            if str[i] == '0':\n                count += 1\n            else:\n                flag = 1\n    return count\n\n\nprint(make_sequence('1100'))"
    },
    {
      "rank": 99,
      "score": 2.185096745013634,
      "candidate": "# O(n) time | O(1) space\ndef alternate_string(s):\n    flips = 0\n    last_flip = 0\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] == \"0\":\n            flips += 1\n            last_flip = i\n        elif i % 2 == 1 and s[i] == \"1\":\n            flips += 1\n            last_flip = i\n    return flips\n\n\nprint(alternate_string(\"1000\"))\nprint(alternate_string(\"0100\"))\nprint(alternate_string(\"1100\"))\nprint(alternate_string(\"0000\"))\nprint(alternate_string(\"1010\"))\nprint(alternate_string(\"0110\"))\nprint(alternate_string(\"1110\"))\nprint(alternate_string(\"0001\"))\nprint(alternate_string(\"1001\"))\nprint(alternate_string(\"0101\"))\nprint(alternate_string(\"1101\"))\nprint(alternate_string(\"0011\"))\nprint(alternate_string(\"1011\"))\nprint(alternate_string(\"0111\"))\nprint(alternate_string(\"1111\"))"
    },
    {
      "rank": 100,
      "score": 1.9259045073232048,
      "candidate": "from collections import Counter\n\n\ndef flip_seq(string: str) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    counter = Counter(string)\n    return len(string) - max(counter[\"0\"], counter[\"1\"])\n\n\nif __name__ == \"__main__\":\n    assert flip_seq(\"11100010\") == 2"
    }
  ]
}