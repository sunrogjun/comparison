{
  "timestamp": "2025-09-15T01:46:29.240254",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 458,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\ndef max_profit_k_times(prices, k):\n    # TODO: Write your code here\n    pass\n\ndef max_profit_k_times_brute(prices, k):\n    \"\"\"\n    Brute force solution\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n    max_profit = 0\n    for i in range(len(prices)):\n        for j in range(i+1, len(prices)):\n            diff = prices[j] - prices[i]\n            if diff > max_profit:\n                max_profit = diff\n    return max_profit\n\ndef max_profit_k_times_dp(prices, k):\n    \"\"\"\n    DP solution\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n    # create a table with k rows and n-1 columns\n    # first row is the max profit\n    # first column is the max profit\n    # calculate the max profit\n    # for every row, find the max profit\n    # for every column, find the max profit\n    # row 1: max profit\n    # row 2: max profit\n    # row 3: max profit\n    # row 4: max profit\n    # ...\n    # row k: max profit\n    # column 1: max profit\n    # column 2: max profit\n    # column 3: max profit\n    # column 4: max profit\n    # ...\n    # column n-1: max profit\n    #\n    # 1 2 3 4 5 6 7 8 9 10\n    # 1 2 3 4 5 6 7 8 9 10\n    # 1 2 3 4 5 6 7 8 9 10\n    # 1 2 3 4 5 6 7 8 9 10\n    # 1 2 3 4 5 6 7 8 9 10\n    # 1 2 3 4 5 6 7 8 9 10"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# 1. Naive approach\ndef max_profit_naive(prices, k):\n    # Time Complexity: O(n^2)\n    # Space Complexity: O(n)\n    if k == 0:\n        return 0\n\n    if k == 1:\n        return max_profit_naive_1_trans(prices)\n\n    max_profit = 0\n    for i in range(len(prices)-1):\n        for j in range(i+1, len(prices)):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n\n    return max_profit\n\ndef max_profit_naive_1_trans(prices):\n    # Time Complexity: O(n)\n    # Space Complexity: O(1)\n    min_price = prices[0]\n    max_profit = 0\n\n    for i in range(1, len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        if prices[i] - min_price > max_profit:\n            max_profit = prices[i] - min_price\n\n    return max_profit\n\n# 2. Dynamic Programming\ndef max_profit(prices, k):\n    # Time Complexity: O(n*k)\n    # Space Complexity: O(n*k)\n    if k == 0:\n        return 0\n\n    if k == 1:\n        return max_profit_1_trans(prices)\n\n    # dp[i][j] stores the max profit from 0 to i with j transactions\n    dp = [[0 for _ in range(k)] for _ in range(len(prices))]\n\n    for i in range(1, len(prices)):\n        for j in range(1, k+1):\n            # dp[i][j] = max(dp[i-1][j-1] + prices[i] - prices[i-1], dp[i-1][j])\n            dp"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def max_profit(prices, k):\n    n = len(prices)\n    max_profit = 0\n    for i in range(k):\n        min_price = prices[0]\n        max_profit_from_k = 0\n        for j in range(1, n):\n            max_profit_from_k += max(0, prices[j] - min_price)\n            min_price = min(min_price, prices[j])\n        max_profit = max(max_profit, max_profit_from_k)\n    return max_profit\n\n\ndef main():\n    prices = [2, 5, 7, 1, 4, 3, 1, 3]\n    k = 3\n    print(max_profit(prices, k))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(prices)\n    if k >= n/2:\n        return max_profit_k_or_less(prices)\n\n    # find the maximum profit by dividing the stocks into k groups\n    max_profit_per_group = [0] * (k+1)\n    max_group_profit = -1\n\n    # for each group, find the maximum profit\n    for group in range(1, k+1):\n        # find the minimum price in the group\n        min_price_in_group = prices[0]\n        group_profit = 0\n        for i in range(group, n, k):\n            min_price_in_group = min(min_price_in_group, prices[i])\n            group_profit += prices[i] - min_price_in_group\n        max_group_profit = max(max_group_profit, group_profit)\n        max_profit_per_group[group] = max_group_profit\n\n    # for each group, find the maximum profit\n    # if the current group's profit is greater than the previous group's profit,\n    # then we can sell the stocks in the current group\n    max_profit = 0\n    for group in range(1, k):\n        if max_profit_per_group[group] > max_profit_per_group[group-1]:\n            max_profit = max(max_profit, max_profit_per_group[group])\n    return max_profit\n\n\ndef max_profit_k_or_less(prices):\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(prices)\n    # use a list of length n to store the maximum profit at each index\n    profits = [0] * n\n\n    # use a list of length n to store the minimum price at each index\n    min_prices ="
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_profit(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(1)\n    \"\"\"\n    if not prices:\n        return 0\n\n    if k >= len(prices) // 2:\n        return sum(max(prices[i + 1] - prices[i] for i in range(len(prices) - 1)) for _ in range(k))\n\n    profits = [0] * len(prices)\n\n    for _ in range(k):\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            profits[i] += prices[i] - min_price\n\n        min_price = prices[-1]\n        for i in range(len(prices) - 2, -1, -1):\n            min_price = min(min_price, prices[i])\n            profits[i] += prices[i] - min_price\n\n        prices = profits\n\n    return max(profits)\n\n\nif __name__ == \"__main__\":\n    assert max_profit(2, [2, 4, 1]) == 2"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if k > len(prices) // 2:\n        return sum_profit(prices)\n\n    max_profit = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            max_profit = max(max_profit, sum_profit(prices[i:j + 1]))\n\n    return max_profit\n\n\ndef sum_profit(prices: List[int]) -> int:\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit += max(prices[i] - prices[i - 1], 0)\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit([2, 4, 1], 2) == 2"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def max_profit(stocks, k):\n    n = len(stocks)\n    if k >= n:\n        return 0\n    if k <= 0:\n        return 0\n\n    max_profit = 0\n    for i in range(k):\n        max_profit += max(stocks[i:] + stocks[:i])\n\n    return max_profit\n\n\nprint(max_profit([5, 1, 3, 2, 6, 4, 1, 2, 1, 2], 3))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    Time complexity: O(k*n)\n    Space complexity: O(k)\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    profits = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            profits[i][j] = max(\n                profits[i - 1][j],\n                prices[i - 1] + max(profits[i - 2][j - 1], profits[0][j - 1])\n            )\n\n    return profits[n][k]\n\n\ndef max_profit_2(prices, k):\n    \"\"\"\n    Time complexity: O(k*n)\n    Space complexity: O(k)\n    \"\"\"\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    profits = [[0] * (k + 1) for _ in range(2)]\n\n    min_price = prices[0]\n    for i in range(1, n + 1):\n        min_price = min(min_price, prices[i - 1])\n        profits[0][i % (k + 1)] = max(\n            profits[0][(i - 1) % (k + 1)],\n            prices[i - 1] - min_price\n        )\n\n    max_price = prices[n - 1]\n    for i in range(1, n + 1):\n        max_price = max(max_price, prices[n - i])\n        profits[1][i % (k + 1)] = max(\n            profits[1][(i - 1) % (k + 1)],\n            max_price - prices[n - i]\n        )\n\n    result = 0\n    for i in range(1, k + 1):\n        result = max(result, profits"
    },
    {
      "rank": 9,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n    \"\"\"\n\n    if len(prices) <= 1:\n        return 0\n\n    if k >= len(prices) // 2:\n        return sum(\n            prices[i + 1] - prices[i] for i in range(len(prices) - 1) if prices[i] < prices[i + 1]\n        )\n\n    max_profit = 0\n\n    for i in range(k):\n        min_price = prices[0]\n        max_profit_per_k = 0\n        for j in range(1, len(prices)):\n            max_profit_per_k += max(prices[j] - min_price, 0)\n            min_price = min(min_price, prices[j])\n\n        max_profit = max(max_profit, max_profit_per_k)\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit([10, 22, 5, 75, 65, 80], 2) == 87"
    },
    {
      "rank": 10,
      "score": 8.0,
      "candidate": "def max_profit_k_times(prices, k):\n    \"\"\"\n    :param prices: list of prices in order\n    :param k: number of transactions\n    :return: maximum profit\n\n    Time Complexity: O(n*k)\n    Space Complexity: O(n)\n    \"\"\"\n    if k >= len(prices) // 2:\n        return max_profit_unlimited_transactions(prices)\n\n    # Calculate the max profit for k/2 transactions\n    # The max profit for k transactions can be achieved by\n    # buying a stock at the lowest price and selling at the highest price\n    # among the profits of buying a stock at the i-th price and selling at the (k - i)-th price\n    # We can find the maximum profit for k/2 transactions and subtract the minimum profit\n    # between buying a stock at the first and selling at the last price\n\n    # Create a list of profits of buying a stock at the i-th price and selling at the (k - i)-th price\n    profits = [0] * len(prices)\n    for i in range(len(prices)):\n        for j in range(i, len(prices) - k + i + 1):\n            profits[i] += prices[j] - prices[i]\n\n    # Find the maximum profit for k/2 transactions\n    max_profit_half = max(profits)\n\n    # Calculate the minimum profit between buying a stock at the first and selling at the last price\n    min_profit = prices[-1] - prices[0]\n    for i in range(1, len(prices) - k + 1):\n        min_profit = min(min_profit, prices[i + k - 1] - prices[i])\n\n    # Return the maximum profit for k transactions\n    return max_profit_half - min_profit\n\n\ndef max_profit_unlimited_transactions(prices):\n    \"\"\"\n    :param prices: list of prices in order\n    :return: maximum profit\n\n    Time Complexity: O(n)\n    Space Complexity: O("
    },
    {
      "rank": 11,
      "score": 8.0,
      "candidate": "def max_profit_k_times(arr, k):\n\t\"\"\"\n\tTime Complexity: O(nlogn)\n\tSpace Complexity: O(1)\n\t\"\"\"\n\tif len(arr) < 2:\n\t\treturn 0\n\n\tarr.sort()\n\tprofit = 0\n\tfor i in range(len(arr) - 1):\n\t\tprofit += arr[i + 1] - arr[i]\n\treturn profit\n\n\nif __name__ == \"__main__\":\n\tprint(max_profit_k_times([5, 3, 7, 4], 2))\n\tprint(max_profit_k_times([1, 3, 4, 5, 6, 2, 7], 3))\n\tprint(max_profit_k_times([1, 3, 4, 5, 6, 2, 7], 1))\n\tprint(max_profit_k_times([1, 3, 4, 5, 6, 2, 7], 7))"
    },
    {
      "rank": 12,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_profit(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(n)\n    \"\"\"\n    if not prices:\n        return 0\n\n    n: int = len(prices)\n\n    if k > n // 2:\n        return sum_max_profit(prices)\n\n    # create a dp table to store the maximum profit from 0 to i stocks\n    dp: List[int] = [0] * (n + 1)\n\n    # if we don't have to trade, we don't have to do anything\n    dp[0] = 0\n\n    # if we have to trade, we can either buy or sell, and we can't sell before buying\n    for i in range(1, n + 1):\n        # if we have to sell, we can only sell at the current price\n        dp[i] = max(dp[i - 1], prices[i - 1])\n\n    # find the max profit for all possible ways of k stocks\n    max_profit: int = 0\n    for i in range(1, n - k + 1):\n        # buy at prices[i - 1] and sell at prices[i + k - 1]\n        max_profit = max(max_profit, dp[i - 1] + prices[i + k - 1] - prices[i - 1])\n\n    return max_profit\n\n\ndef sum_max_profit(prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    profit: int = 0\n    min_price: int = prices[0]\n\n    for i in range(1, len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        elif prices[i] - min_price > profit:\n            profit = prices[i] - min_price\n\n    return profit\n\n\nif __name__ == \""
    },
    {
      "rank": 13,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# O(nk)\ndef max_profit_k_times(stock_prices: List[int], k: int) -> int:\n    n = len(stock_prices)\n\n    # k = 0\n    # max_profit = 0\n    # for i in range(n - 1):\n    #     for j in range(i + 1, n):\n    #         max_profit = max(max_profit, stock_prices[j] - stock_prices[i])\n    # return max_profit\n\n    # k >= 1\n    # dp[i][j][k] = max(dp[i][j][k], dp[i][k - 1][k - 1] + prices[j] - prices[i])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i][k - 1][k - 1])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j][k - 1] - prices[i])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j][k])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k - 1] + prices[j] - prices[i])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k - 1])\n    # dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k])\n\n    # dp[i][j][k] = max(dp[i][j][k], dp[i - 1][k -"
    },
    {
      "rank": 14,
      "score": 8.0,
      "candidate": "def max_profit(k, prices):\n    if not prices:\n        return 0\n\n    if k >= len(prices) // 2:\n        return max_profit_helper(prices)\n\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            if j - i > k:\n                break\n            max_profit = max(max_profit, max_profit_helper(prices[i : j + 1]))\n\n    return max_profit\n\n\ndef max_profit_helper(prices):\n    profit = 0\n    for i in range(len(prices) - 1):\n        profit += max(0, prices[i + 1] - prices[i])\n    return profit\n\n\nprint(max_profit(2, [1, 3, 9, 11, 5, 10, 6]))\nprint(max_profit(3, [1, 3, 9, 11, 5, 10, 6]))\nprint(max_profit(4, [1, 3, 9, 11, 5, 10, 6]))\nprint(max_profit(5, [1, 3, 9, 11, 5, 10, 6]))\nprint(max_profit(6, [1, 3, 9, 11, 5, 10, 6]))\nprint(max_profit(7, [1, 3, 9, 11, 5, 10, 6]))"
    },
    {
      "rank": 15,
      "score": 8.0,
      "candidate": "def get_max_profit(stock_prices, k):\n    \"\"\"\n    :param stock_prices: list of stock prices\n    :param k: number of transactions\n    :return: max profit\n    \"\"\"\n    if not stock_prices:\n        return 0\n\n    if k >= len(stock_prices):\n        return max(stock_prices[1:]) - min(stock_prices[:-1])\n\n    min_price = stock_prices[0]\n    max_profit = 0\n    for price in stock_prices[1:]:\n        if price > min_price:\n            max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    print(get_max_profit([10, 8, 5, 7, 15, 12, 75, 65, 37, 80], 2))"
    },
    {
      "rank": 16,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    # This problem can be solved by either using dynamic programming or recursion\n    # Recursion can be solved by finding the max profit from the current index to the last index,\n    # then find the max profit from the first index to the current index\n    # Then return the max of the two\n    if k < 1 or len(prices) < 2:\n        return 0\n\n    max_profit_from_current_to_last = max_profit(prices[1:], k)\n    max_profit_from_first_to_current = 0\n\n    for i in range(1, len(prices)):\n        if prices[i] - prices[i - 1] > max_profit_from_first_to_current:\n            max_profit_from_first_to_current = prices[i] - prices[i - 1]\n\n    return max(max_profit_from_current_to_last, max_profit_from_first_to_current)\n\n\nprint(max_profit([1, 2, 3, 0, 2], 2))\nprint(max_profit([2, 4, 1], 2))\nprint(max_profit([3, 2, 6, 5, 0, 3], 2))"
    },
    {
      "rank": 17,
      "score": 8.0,
      "candidate": "from typing import List\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    if k > n/2:\n        return sum_profit(prices)\n\n    max_profit = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n\n    return max_profit\n\n\ndef sum_profit(prices: List[int]) -> int:\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i-1], 0)\n\n    return profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit([2, 1, 2, 1, 0, 1, 2], 2) == 6\n    assert max_profit([2, 1, 2, 1, 0, 1, 2], 3) == 9\n    assert max_profit([2, 1, 2, 1, 0, 1, 2], 4) == 12\n    assert max_profit([2, 1, 2, 1, 0, 1, 2], 5) == 12\n    assert max_profit([2, 1, 2, 1, 0, 1, 2], 6) == 12"
    },
    {
      "rank": 18,
      "score": 8.0,
      "candidate": "def find_max_profit(prices, k):\n    max_profit = 0\n\n    if k == 0:\n        return max_profit\n\n    if k == 1:\n        for i in range(len(prices) - 1):\n            if prices[i + 1] - prices[i] > 0:\n                max_profit += prices[i + 1] - prices[i]\n        return max_profit\n\n    for i in range(k):\n        min_price = float(\"inf\")\n        max_profit_i = 0\n        for j in range(len(prices) - 1):\n            if prices[j] < min_price:\n                min_price = prices[j]\n            if prices[j + 1] - min_price > max_profit_i:\n                max_profit_i = prices[j + 1] - min_price\n        max_profit += max_profit_i\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]\n    print(find_max_profit(prices, 2))"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    max_profit = 0\n    if k > len(prices) / 2:\n        return get_max_profit(prices)\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n    return max_profit\n\ndef get_max_profit(prices):\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        if prices[i] < prices[i+1]:\n            max_profit += prices[i+1] - prices[i]\n    return max_profit\n\nprint(max_profit([5, 11, 3, 50, 60, 90], 2))"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    if len(prices) < 2:\n        return 0\n\n    n = len(prices)\n\n    # Create 2D DP table where dp[i][j] is max profit using 0 to i-1 stocks\n    # and j transactions left\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n\n    # Fill dp[0][0] with 0 as we have no stocks and 0 transactions left\n    for i in range(1, n):\n        dp[i][0] = 0\n\n    # Fill dp[i][1] as max profit using all stocks and 1 transactions left\n    for i in range(1, n):\n        dp[i][1] = max(dp[i - 1][1], prices[i] - prices[i - 1])\n\n    # Fill dp[i][j] using dp[i-1][j] and dp[i-1][j-1]\n    for i in range(2, n):\n        for j in range(2, k + 1):\n            dp[i][j] = max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1])\n\n    # Return max profit using all stocks and k transactions left\n    return dp[-1][-1]\n\n\ndef main():\n    print(\"Maximum profit: \" + str(max_profit([310, 315, 275, 295, 260, 270, 290, 230, 255, 250], 2)))\n    print(\"Maximum profit: \" + str(max_profit([100, 200, 400, 600, 100, 50, 60, 70, 80], 3)))\n\n\nmain()"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    if not prices:\n        return 0\n\n    n = len(prices)\n    max_profit = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for profit in range(prices[i], prices[j] + 1):\n                if (j - i) == k:\n                    max_profit = max(max_profit, profit)\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    print(max_profit([5, 11, 3, 50, 60, 90], 2))"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "# This is the function from the lecture\ndef max_profit(prices, k=2):\n    if not prices:\n        return 0\n\n    # max_k_profits[i][j] is the maximum profit earned if we have done no more than j transactions and are at prices[i]\n    # We can get to prices[i] in two ways: from prices[i-1] (which is the previous day), or from prices[i-2] (which is two days ago)\n    # For each way, we can either not do anything (skip prices[i]) or buy (holding_profit[i][j]) and sell (profit[i][j])\n    # If we have no more than j transactions, then we can get to prices[i] from either prices[i-1] or prices[i-2]\n    # But if we have more than j transactions, then we can only get to prices[i] from prices[i-1]\n    # So max_k_profits[i][j] = max(max_k_profits[i-1][j], max_k_profits[i-2][j], max_k_profits[i-1][j-1] + prices[i] - prices[i-2])\n\n    # max_k_profits[i][j] is the maximum profit earned if we have done no more than j transactions and are at prices[i]\n    # max_k_profits[i-1][j] is the maximum profit earned if we have done no more than j transactions and are at prices[i-1]\n    # max_k_profits[i-2][j] is the maximum profit earned if we have done no more than j transactions and are at prices[i-2]\n    # max_k_profits[i-1][j-1] is the maximum profit earned if we have done no more than j-1 transactions and are at prices[i-1]\n    #                                                                                                                (and bought on the previous day)\n    # prices[i] - prices[i-2] is the profit earned from buying on prices[i-2] and selling on prices[i]\n\n    # We can get to prices"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "def max_profit(prices, k=2):\n    \"\"\"\n    :param prices:\n    :param k:\n    :return:\n    \"\"\"\n    # k = 0, 1, 2\n    # k = 0: max_profit = 0\n    # k = 1: max_profit = max(profit)\n    # k = 2: max_profit = max(profit1 + profit2)\n    # k = 3: max_profit = max(profit1 + profit2 + profit3)\n    # k = 4: max_profit = max(profit1 + profit2 + profit3 + profit4)\n    # k = 5: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5)\n    # k = 6: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5 + profit6)\n    # k = 7: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5 + profit6 + profit7)\n    # k = 8: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5 + profit6 + profit7 + profit8)\n    # k = 9: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5 + profit6 + profit7 + profit8 + profit9)\n    # k = 10: max_profit = max(profit1 + profit2 + profit3 + profit4 + profit5 + profit6 + profit7 + profit8 + profit9 + profit10)\n    #\n    # 1. k = 0: 0\n    # 2. k = 1: max(profit)\n    # 3. k = 2: max(profit1 + profit2)\n    # 4. k = 3: max(profit1 + profit2 + profit3)\n    # 5. k = 4: max(profit1 + profit2 + profit3 + profit4)\n    # 6. k = 5: max(profit1 + profit2"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    if not prices:\n        return 0\n    # the answer is in the difference between the max prices\n    # for selling and the min prices for buying\n    min_prices = [prices[0]]\n    max_profits = [0]\n    for price in prices[1:]:\n        min_prices.append(min(min_prices[-1], price))\n        max_profits.append(max(max_profits[-1], price - min_prices[-1]))\n    return max(max_profits[-1], sum(prices) - min_prices[-1])\n\n\ndef max_profit_with_k_transactions(prices, k):\n    if not prices or k == 0:\n        return 0\n    # the answer is in the difference between the max prices\n    # for selling and the min prices for buying\n    min_prices = [prices[0]]\n    max_profits = [0]\n    for price in prices[1:]:\n        min_prices.append(min(min_prices[-1], price))\n        max_profits.append(max(max_profits[-1], price - min_prices[-1]))\n    if k == 1:\n        return max_profits[-1]\n    if k == len(prices):\n        return sum(prices) - min_prices[-1]\n    return max_profit_with_k_transactions(max_profits, k - 1)\n\n\nif __name__ == \"__main__\":\n    print(max_profit([1, 2, 3, 4, 5], 2))\n    print(max_profit([2, 4, 1], 2))\n    print(max_profit([3, 2, 6, 5, 0, 3], 2))\n    print(max_profit([2, 4, 1], 2))\n    print(max_profit([3, 3, 5, 0, 0, 3, 1, 4], 3))"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    Time complexity: O(nk)\n    Space complexity: O(n)\n    \"\"\"\n    if not prices:\n        return 0\n\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        min_price = prices[i]\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - min_price\n            if profit > max_profit:\n                max_profit = profit\n\n    return max_profit\n\nif __name__ == '__main__':\n    print max_profit([310, 315, 275, 295, 260, 270, 290, 230, 255, 250], 2)\n\n    prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        min_price = prices[i]\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - min_price\n            if profit > max_profit:\n                max_profit = profit\n\n    print max_profit\n\n    prices = [310, 315, 275, 295, 260, 270, 290, 230, 255, 250]\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        min_price = prices[i]\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - min_price\n            if profit > max_profit:\n                max_profit = profit\n\n    print max_profit"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def max_profit(arr, k):\n    \"\"\"\n    O(nk)\n    \"\"\"\n    if k >= len(arr) / 2:\n        return max_profit_helper(arr)\n\n    profit = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > profit:\n                profit = arr[j] - arr[i]\n\n    return profit\n\n\ndef max_profit_helper(arr):\n    profit = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] - arr[i] > profit:\n                profit = arr[j] - arr[i]\n    return profit\n\n\ndef main():\n    print(max_profit([5, 11, 3, 50, 60, 90], 2))\n    print(max_profit([5, 11, 3, 50, 60, 90], 3))\n    print(max_profit([1, 2, 3, 4, 5], 1))\n\n\nmain()"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list of prices\n    :param k: number of transactions\n    :return: maximum profit\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n    if k == 1:\n        return max(prices) - min(prices)\n\n    max_profit = -prices[0]\n    min_buy = prices[0]\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - min_buy)\n        min_buy = min(min_buy, prices[i])\n\n    return max_profit\n\n\nif __name__ == '__main__':\n    print(max_profit([1, 3, 2, 8, 4, 9], 2))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param prices: list of prices\n    :param k: number of transactions\n    :return: max profit\n    \"\"\"\n    # base case\n    if not prices or k < 1:\n        return 0\n\n    # max profit will be equal to difference between the highest price and the lowest price\n    # we can make k transactions\n    max_profit = prices[-1] - prices[0]\n\n    # if we have only 1 transaction, then the max profit will be the same as the max difference between two prices\n    # in the prices array\n    if k == 1:\n        return max_profit\n\n    # sort the prices array\n    prices = sorted(prices)\n\n    # if we have more than 1 transaction, then the max profit will be equal to the max profit from the max profit\n    # from the max profit from the max profit from the max profit from the max profit from the max profit from\n    # the max profit from the max profit from the max profit from the max profit from the max profit from\n    # the max profit from the max profit from the max profit from the max profit from the max profit from the\n    # max profit from the max profit from the max profit from the max profit from the max profit from the max\n    # profit from the max profit from the max profit from the max profit from the max profit from the max profit\n    # from the max profit from the max profit from the max profit from the max profit from the max profit from\n    # the max profit from the max profit from the max profit from the max profit from the max profit from the\n    # max profit from the max profit from the max profit from the max profit from the max profit from the max\n    # profit from the max profit from the max profit from the max profit from the max profit from the max profit\n    # from the max profit from the max profit from the max profit from the max profit from the max profit from\n    # the max profit from the max profit from the max profit from the max profit from the max profit from the\n    # max profit from the max profit from the max"
    },
    {
      "rank": 29,
      "score": 4.0,
      "candidate": "def max_profit(k, prices):\n    # TODO: Write your code here\n    return 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ng"
    },
    {
      "rank": 30,
      "score": 3.0,
      "candidate": "from typing import List\n\n\ndef max_profit_k_times(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(k)\n    \"\"\"\n    if k >= len(prices):\n        return max_profit(prices)\n\n    buy: List[int] = [prices[0]]\n    profit: List[int] = [0]\n\n    for i in range(1, len(prices)):\n        buy.append(min(buy[i - 1], prices[i]))\n        profit.append(prices[i] - buy[i])\n\n    # greedy algorithm\n    max_profit_sum: int = profit[0]\n\n    for i in range(k, len(prices)):\n        max_profit_sum = max(\n            max_profit_sum,\n            profit[i] + profit[i - k],\n        )\n\n    return max_profit_sum\n\n\ndef max_profit(prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n^2)\n    Space Complexity: O(1)\n    \"\"\"\n    profit: int = 0\n\n    for i in range(1, len(prices)):\n        profit += max(0, prices[i] - prices[i - 1])\n\n    return profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit_k_times(2, [2, 4, 1]) == 2\n    assert max_profit_k_times(3, [3, 2, 6, 5, 0, 3]) == 4"
    },
    {
      "rank": 31,
      "score": 3.0,
      "candidate": "from functools import lru_cache\n\n\ndef max_profit(prices, k):\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(n*k)\n    \"\"\"\n    # max_profit_k_transactions(prices, 0, k)\n    # return max_profit_k_transactions_dp(prices, k)\n    return max_profit_k_transactions_dp_2(prices, k)\n\n\n@lru_cache(maxsize=None)\ndef max_profit_k_transactions(prices, current_index, k):\n    if k == 0:\n        return 0\n    if current_index == len(prices) - 1:\n        return 0\n\n    max_profit = -prices[current_index]\n    for i in range(current_index + 1, len(prices)):\n        max_profit = max(max_profit, prices[i] - prices[current_index] + max_profit_k_transactions(prices, i + 1, k - 1))\n\n    return max_profit\n\n\n@lru_cache(maxsize=None)\ndef max_profit_k_transactions_dp(prices, k):\n    max_profit = [0] * (k + 1)\n    for i in range(1, len(prices)):\n        for j in range(1, k + 1):\n            max_profit[j] = max(prices[i] + max_profit[j - 1], max_profit[j])\n\n    return max_profit[k]\n\n\n@lru_cache(maxsize=None)\ndef max_profit_k_transactions_dp_2(prices, k):\n    if k == 0:\n        return 0\n    if len(prices) < 2:\n        return 0\n\n    max_profit = [0] * len(prices)\n    for i in range(1, len(prices)):\n        max_profit[i] = max(prices"
    },
    {
      "rank": 32,
      "score": 3.0,
      "candidate": "def max_profit_dp(arr, k):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    dp = [[0] * len(arr) for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_so_far = -1 * float(\"inf\")\n        for j in range(1, len(arr)):\n            max_so_far = max(max_so_far, dp[i - 1][j - 1] - arr[j - 1])\n            dp[i][j] = max(dp[i][j - 1], max_so_far + arr[j])\n\n    return dp[k][-1]\n\n\ndef max_profit_greedy(arr, k):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    def get_max_profit(arr, k):\n        profit = 0\n        for i in range(k):\n            min_price = float(\"inf\")\n            for j in range(len(arr)):\n                min_price = min(min_price, arr[j])\n                profit = max(profit, arr[j] - min_price)\n        return profit\n\n    return get_max_profit(arr, k)\n\n\nif __name__ == \"__main__\":\n    prices = [1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\n    k = 2\n\n    assert max_profit_dp(prices, k) == 8\n    assert max_profit_greedy(prices, k) == 8"
    },
    {
      "rank": 33,
      "score": 3.0,
      "candidate": "import unittest\n\n\ndef max_profit(prices, k):\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(k)\n    \"\"\"\n    n = len(prices)\n\n    if k > n // 2:\n        return unbounded_knapsack(prices)\n\n    # dp[i][j] max profit from first i-1 transactions with at most j transactions\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n\n    # base case\n    for j in range(1, k + 1):\n        dp[0][j] = 0\n\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            # take the max of profit from previous transaction and profit from current transaction\n            dp[i][j] = max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1])\n\n    return dp[n - 1][k]\n\n\ndef unbounded_knapsack(prices):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(prices)\n\n    # dp[i] max profit from first i transactions\n    dp = [0 for _ in range(n)]\n\n    # base case\n    dp[0] = 0\n\n    for i in range(1, n):\n        # take the max of profit from previous transaction and profit from current transaction\n        dp[i] = max(dp[i - 1], prices[i] + dp[i - 1])\n\n    return dp[n - 1]\n\n\nclass Test(unittest.TestCase):\n    def test_case_1(self):\n        k = 2\n        prices = [2, 4, 1]\n        result = 2\n        self.assertEqual(max_profit(prices, k), result)\n\n    def test_case_2(self):\n        k = 3\n        prices = [3, 2,"
    },
    {
      "rank": 34,
      "score": 3.0,
      "candidate": "def max_profit(prices, k):\n    n = len(prices)\n\n    if k >= n/2:\n        # if k is greater than or equal to the number of days\n        # then we can do as many transactions as we want\n        # but only one transaction is possible at a time\n        # so we can buy at the lowest price and sell at the highest price\n        buy = prices[0]\n        sell = prices[-1]\n        return sell - buy\n\n    # the idea is to buy and sell at the lowest and highest prices\n    # and then calculate the profit of that transaction\n    # and then compare it with all the other transactions\n    # and return the maximum profit\n\n    # the idea is to use 2 pointers buy and sell\n    # and calculate the profit and then compare it with the maximum profit\n    # we have encountered so far\n\n    # buy = 0\n    # sell = n - 1\n    # profit = sell - buy\n\n    # while buy < sell:\n    #     if prices[buy] < prices[sell]:\n    #         profit = max(profit, sell - buy)\n    #         buy += 1\n    #     else:\n    #         sell -= 1\n    # return profit\n\n    # there are 2*k transactions possible\n    # so we can find the maximum profit by\n    # finding the maximum profit from k buys and k sells\n    # and then taking the maximum of these two\n\n    # this is because we can buy and sell at the same day\n    # so we can do k transactions in a day\n    # and then the next day we can do the other k transactions\n    # so we can do 2k transactions in total\n\n    # the idea is to keep track of the maximum profit of\n    # buying on the first day and selling on the first day\n    # and then the maximum profit of buying on the second day\n    # and selling on the second day and so on\n    # and then take the maximum of these two\n\n    # we can do this by creating a 2d array of size k x k\n    # and initializing it to 0\n    # and then updating it as we go along\n\n    # let's say"
    },
    {
      "rank": 35,
      "score": 3.0,
      "candidate": "from functools import lru_cache\nfrom typing import List\n\n\ndef max_profit_dp(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Dynamic Programming:\n    Let's say we have an array of stock prices and we can only make at most k transactions.\n    We can have an array of size k + 1 where each index represents the maximum profit we can make\n    after i transactions.\n    If we can make i transactions, then the maximum profit we can make is equal to the max\n    of (1) the maximum profit we can make after i - 1 transactions, (2) the difference between the\n    current price and the minimum price we've seen so far.\n    The base case is when i = 0, in this case we can't do any transactions so we return 0.\n    \"\"\"\n    if not prices:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices[1:]:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\n\n@lru_cache(maxsize=None)\ndef max_profit_k_memoization(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Memoization\n    We can use a dictionary to memoize our results.\n    The key of the dictionary will be the number of transactions we have left and the value\n    will be the maximum profit we can make.\n    The base case is when i = 0, in this case we can't do any transactions so we return 0.\n    \"\"\"\n    if not prices:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices[1:]:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\n\n@lru_cache(maxsize=None)\ndef max_profit_k_bottom_up(k: int, prices: List"
    },
    {
      "rank": 36,
      "score": 3.0,
      "candidate": "# O(n^2) time | O(n) space\ndef maxProfitWithKTransactions(prices, k):\n    # k can be 0\n    if k == 0:\n        return 0\n\n    # we only need to consider the difference between the prices\n    # to find the max profit\n    # therefore, we only need to find the max difference between any two prices\n\n    # we can use this to find the max difference between any two prices\n    # get the min price and subtract it from every price\n    # to find the max profit\n    minPrice = min(prices)\n    prices = [price - minPrice for price in prices]\n\n    # we can now use this to find the max difference between any two prices\n    # to find the max profit\n    # use a dp table\n    # dp[i][j] means the max profit from 0 to i with j transactions\n    # dp[i][j] = max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1])\n    # dp[i][0] = 0\n    # dp[0][j] = 0\n    # we can initialize the dp table with 0\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(prices))]\n    # we can also initialize the dp table with 0\n    for i in range(1, len(prices)):\n        dp[i][0] = 0\n\n    # we can now start filling out the table\n    # we start at 1 because we only need to fill out the table for i > 0\n    for i in range(1, len(prices)):\n        # we can start at 1 because we only need to fill out the table for j > 0\n        for j in range(1, k + 1):\n            # if we can make a transaction, we can add the price to the max profit\n            if i - 1 >= 0:\n                dp[i][j] = max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1])\n            #"
    },
    {
      "rank": 37,
      "score": 3.0,
      "candidate": "def max_profit(prices, k):\n    # write your code here\n\n    if not prices:\n        return 0\n\n    # k = 1\n    # buy_price = prices[0]\n    # max_profit = 0\n    # for price in prices[1:]:\n    #     if price > buy_price:\n    #         max_profit = max(max_profit, price - buy_price)\n    #     else:\n    #         buy_price = price\n    # return max_profit\n\n    # k = 2\n    # buy_price_1 = prices[0]\n    # buy_price_2 = prices[1]\n    # max_profit_1 = 0\n    # max_profit_2 = 0\n    # for price in prices[2:]:\n    #     if price > buy_price_1:\n    #         max_profit_1 = max(max_profit_1, price - buy_price_1)\n    #     else:\n    #         buy_price_1 = price\n    #\n    #     if price > buy_price_2:\n    #         max_profit_2 = max(max_profit_2, price - buy_price_2)\n    #     else:\n    #         buy_price_2 = price\n    # return max(max_profit_1, max_profit_2)\n\n    # k = 2\n    # buy_price_1 = prices[0]\n    # buy_price_2 = prices[1]\n    # max_profit_1 = 0\n    # max_profit_2 = 0\n    # for price in prices[2:]:\n    #     if price > buy_price_1:\n    #         max_profit_1 = max(max_profit_1, price - buy_price_1)\n    #     else:\n    #         buy_price_1 = price\n    #\n    #     if price > buy_price_2:\n    #         max_profit_2 = max(max_profit_2, price - buy_price_2)\n    #     else:"
    },
    {
      "rank": 38,
      "score": 3.0,
      "candidate": "def find_max_profit(prices, k):\n    if len(prices) < 2 or k < 1:\n        return 0\n\n    # We will use dynamic programming to find the maximum profit\n    # We will use a dp[i][j] table to find the maximum profit\n    # earned from 0 to i transactions\n    # dp[i][j] means the maximum profit earned with j transactions\n    # in the subarray prices[0...i]\n    #\n    # dp[i][j] = max(dp[i - 1][j - 1] + max(prices[i - 1] - prices[j - 1], 0), dp[i - 1][j])\n    #\n    # dp[i][j] means the maximum profit earned with j transactions\n    # in the subarray prices[0...i]\n    #\n    # dp[i][j] = max(dp[i - 1][j - 1] + max(prices[i - 1] - prices[j - 1], 0), dp[i - 1][j])\n    #\n    # Time complexity O(nk)\n    # Space complexity O(nk)\n    #\n    # dp[i][j] = max(dp[i - 1][j - 1] + max(prices[i - 1] - prices[j - 1], 0), dp[i - 1][j])\n    #\n    # dp[i][j] means the maximum profit earned with j transactions\n    # in the subarray prices[0...i]\n    #\n    # dp[i][j] = max(dp[i - 1][j - 1] + max(prices[i - 1] - prices[j - 1], 0), dp[i - 1][j])\n    #\n    # Time complexity O(nk)\n    # Space complexity O(nk)\n\n    n = len(prices)\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n\n    for i in range(1, k"
    },
    {
      "rank": 39,
      "score": 2.0,
      "candidate": "def max_profit(prices, k):\n    # Get the max profit with only one transaction\n    max_profit_one_transaction = get_max_profit(prices)\n\n    # Get the max profit with k transactions\n    max_profit_k_transactions = get_max_profit_k_transactions(prices, k)\n\n    # Return the max profit between the two\n    return max(max_profit_one_transaction, max_profit_k_transactions)\n\n\ndef get_max_profit(prices):\n    \"\"\"\n    Returns the max profit possible from one transaction.\n    \"\"\"\n    max_profit = 0\n\n    for i in range(len(prices) - 1):\n        # Get the difference between the current price and the next price\n        difference = prices[i + 1] - prices[i]\n\n        # If the difference is positive, add it to the max profit\n        if difference > 0:\n            max_profit += difference\n\n    return max_profit\n\n\ndef get_max_profit_k_transactions(prices, k):\n    \"\"\"\n    Returns the max profit possible from k transactions.\n    \"\"\"\n    # Initialize the max profit with the first transaction\n    max_profit = prices[-1] - prices[0]\n\n    # Get the length of the prices list\n    length = len(prices)\n\n    # Iterate over each possible combination of k transactions\n    for i in range(2, k + 1):\n        # Initialize the max profit for this combination\n        max_profit_i_transactions = 0\n\n        # Get the length of each possible combination of k transactions\n        combinations_length = length - i + 1\n\n        # Iterate over each possible combination of k transactions\n        for j in range(combinations_length):\n            # Get the max profit for this combination\n            profit_i_transactions = get_max_profit_i_transactions(prices, j, i)\n\n            # Add it to the max profit\n            max_profit_i_transactions += profit_i_transactions\n\n        # Update the max profit\n        max"
    },
    {
      "rank": 40,
      "score": 2.0,
      "candidate": "def max_profit_k_times(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    # sort prices from low to high\n    prices = sorted(prices)\n    # initialize a list to store the max profit of k transactions\n    max_profit = [0] * k\n    # initialize a list to store the min price of k transactions\n    min_price = [0] * k\n    # initialize a list to store the max price of k transactions\n    max_price = [0] * k\n    # initialize a list to store the index of the min price of k transactions\n    min_index = [0] * k\n    # initialize a list to store the index of the max price of k transactions\n    max_index = [0] * k\n\n    # find the max profit of k transactions\n    for i in range(len(prices)):\n        for j in range(k):\n            # if the min price is 0\n            if min_price[j] == 0:\n                # set the min price and index\n                min_price[j] = prices[i]\n                min_index[j] = i\n            # if the max price is 0\n            if max_price[j] == 0:\n                # set the max price and index\n                max_price[j] = prices[i]\n                max_index[j] = i\n            # if the price of current stock is lower than the min price\n            if prices[i] < min_price[j]:\n                # set the min price and index\n                min_price[j] = prices[i]\n                min_index[j] = i\n            # if the price of current stock is higher than the max price\n            if prices[i] > max_price[j]:\n                # set the max price and index\n                max_price[j] = prices[i]\n                max_index[j] = i\n            # if the price of current stock is higher than the max price and lower than the min price\n            if prices[i] > max_price[j] and prices[i] < min_price[j]:\n                # set"
    },
    {
      "rank": 41,
      "score": 2.0,
      "candidate": "def max_profit_k_times(prices, k):\n    # get the max profit from one transaction\n    max_profit = get_max_profit(prices)\n    # get the max profit from k transactions\n    return get_max_profit_k_times(prices, k, max_profit)\n\n\ndef get_max_profit(prices):\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        profit = prices[i + 1] - prices[i]\n        if profit > max_profit:\n            max_profit = profit\n    return max_profit\n\n\ndef get_max_profit_k_times(prices, k, max_profit):\n    # base case\n    if k == 0:\n        return 0\n\n    # get the max profit from one transaction\n    max_profit_one_transaction = get_max_profit(prices)\n\n    # get the max profit from k transactions\n    max_profit_k_transactions = 0\n    for i in range(len(prices) - 1):\n        # get the profit from i to end\n        profit = prices[i + 1] - prices[i]\n\n        # get the max profit from the rest of the prices\n        profit_from_rest = get_max_profit_k_times(prices[i + 1:], k - 1, max_profit)\n\n        # get the profit from the max profit one transaction\n        profit_from_one_transaction = max_profit * (k - 1)\n\n        # get the max profit\n        profit = max(profit, profit_from_rest, profit_from_one_transaction)\n\n        # get the max profit from k transactions\n        if profit > max_profit_k_transactions:\n            max_profit_k_transactions = profit\n\n    return max_profit_k_transactions\n\n\ndef test_get_max_profit_k_times():\n    assert get_max_profit_k_times([10, 8, 5, 7,"
    },
    {
      "rank": 42,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit_dp(arr: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*k)\n    \"\"\"\n\n    # Initialize the list of max_profit with 0s\n    max_profit: List[int] = [0] * (k + 1)\n\n    # Initialize the list of min_price with 0s\n    min_price: List[int] = [0] * (k + 1)\n\n    # Initialize the list of max_price with 0s\n    max_price: List[int] = [0] * (k + 1)\n\n    # Initialize min_price and max_price with the first element of the array\n    min_price[0] = arr[0]\n    max_price[0] = arr[0]\n\n    # Initialize max_profit with the first element of the array\n    max_profit[0] = 0\n\n    # Traverse the array from the second element to the last\n    for i in range(1, len(arr)):\n\n        # Update min_price[i]\n        min_price[i] = min(min_price[i - 1], arr[i])\n\n        # Update max_price[i]\n        max_price[i] = max(max_price[i - 1], arr[i])\n\n        # Update max_profit[i]\n        for j in range(1, k + 1):\n            max_profit[j] = max(\n                max_profit[j],\n                max_price[i] - min_price[i - j]\n            )\n\n    return max_profit[k]\n\n\nif __name__ == \"__main__\":\n    print(max_profit_dp([10, 22, 5, 75, 65, 80], 2))\n    print(max_profit_dp([100, 18, 22, 91, 1, 200, 100000], 3))"
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n\n    # initialize\n    size = len(prices)\n    max_profit = 0\n    max_buy = prices[0]\n    max_sell = prices[0]\n    min_buy = prices[0]\n    min_sell = prices[0]\n\n    # iterate through each day\n    for i in range(1, size):\n        # update min_buy and min_sell\n        if prices[i] < min_buy:\n            min_buy = prices[i]\n        elif prices[i] < min_sell:\n            min_sell = prices[i]\n        # update max_buy and max_sell\n        if prices[i] - min_buy > max_profit:\n            max_profit = prices[i] - min_buy\n            max_buy = min_buy\n            max_sell = prices[i]\n        elif prices[i] - min_sell > max_profit:\n            max_profit = prices[i] - min_sell\n            max_buy = min_sell\n            max_sell = prices[i]\n    return max_profit\n\n\nprint(max_profit([10, 5, 3, 2, 1], 2))\nprint(max_profit([10, 5, 3, 2, 1], 1))\nprint(max_profit([10, 5, 3, 2, 1], 3))\nprint(max_profit([10, 5, 3, 2, 1], 4))\nprint(max_profit([10, 5, 3, 2, 1], 5))\nprint(max_profit([10, 5, 3, 2, 1], 10))\nprint(max_profit([10, 5, 3, 2, 1], 100))\nprint(max_"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "def max_profit(k, prices):\n    if not prices:\n        return 0\n\n    profits = [0] * (len(prices) - 1)\n    for i in range(1, len(prices)):\n        max_diff = 0\n        for j in range(i):\n            max_diff = max(max_diff, prices[i] - prices[j])\n        profits[i - 1] = max_diff\n\n    profits.sort(reverse=True)\n    return sum(profits[:k])\n\n\nif __name__ == '__main__':\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(2, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(3, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(4, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(5, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(6, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(7, prices))\n    prices = [10, 4, 8, 3, 5, 7, 12, 14]\n    print(max_profit(8, prices))"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    if k >= len(prices) / 2:\n        return sum(prices) - min(prices)\n\n    max_profit = 0\n    for i in range(k):\n        min_price = float('inf')\n        for j in range(i + 1, len(prices)):\n            diff = prices[j] - min_price\n            if diff > max_profit:\n                max_profit = diff\n            min_price = min(min_price, prices[j])\n    return max_profit\n\n\ndef main():\n    prices = [2, 4, 6, 2, 5]\n    k = 2\n    print(max_profit(prices, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    if k >= n / 2:\n        return sum(prices) - prices[0] - prices[-1]\n\n    max_profit = 0\n    for i in range(k):\n        min_price = prices[i]\n        max_profit_k = 0\n        for j in range(i + 1, n):\n            if prices[j] < min_price:\n                min_price = prices[j]\n            if prices[j] - min_price > max_profit_k:\n                max_profit_k = prices[j] - min_price\n        max_profit += max_profit_k\n    return max_profit\n\n\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 8\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == 16\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 24\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 24\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 24\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 6) == 24\n\nassert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 7) == 24\nassert max_profit(["
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit_k_times(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(k*n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def max_profit_k_transactions(prices: List[int]) -> int:\n        profit: int = 0\n        buy_price: int = prices[0]\n\n        for i in range(1, len(prices)):\n            profit += max(0, prices[i] - buy_price)\n            buy_price = min(buy_price, prices[i])\n\n        return profit\n\n    if k == 0:\n        return 0\n\n    max_profit: int = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            if j - i > k:\n                break\n            max_profit = max(max_profit, max_profit_k_transactions(prices[i:j + 1]))\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit_k_times([5, 11, 3, 50, 60, 90], 2) == 93\n    assert max_profit_k_times([1, 2, 3, 4, 5], 1) == 4\n    assert max_profit_k_times([1, 2, 3, 4, 5], 2) == 4\n    assert max_profit_k_times([7, 1, 5, 3, 6, 4], 2) == 5\n    assert max_profit_k_times([7, 6, 4, 3, 1], 0) == 0\n    assert max_profit_k_times([1], 0) == 0"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef max_profit(prices, k):\n    if k >= len(prices) // 2:\n        return max_profit_helper(prices, 0, float(\"-inf\"))\n\n    max_profit = 0\n\n    for i in range(k + 1):\n        max_profit = max(max_profit, max_profit_helper(prices, i, float(\"-inf\")))\n\n    return max_profit\n\n\n@lru_cache(maxsize=None)\ndef max_profit_helper(prices, current_buys, current_sell):\n    if not prices:\n        return current_sell - current_buys\n\n    current_buy = float(\"-inf\")\n    current_sell = float(\"-inf\")\n\n    for i in prices:\n        current_buy = max(current_buy, current_sell - i)\n        current_sell = max(current_sell, current_buy + i)\n\n    return max_profit_helper(prices[1:], current_buy, current_sell)\n\n\nif __name__ == \"__main__\":\n    print(max_profit([10, 22, 5, 75, 65, 80], 2))\n    print(max_profit([10, 22, 5, 75, 65, 80], 3))"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "def max_profit_with_k_transactions(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    # init a dp table to store the max profit from 0 to i\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(prices))]\n\n    # init the first column with 0\n    for i in range(len(dp)):\n        dp[i][0] = 0\n\n    # init the first row with -inf\n    for j in range(1, k + 1):\n        dp[0][j] = float('-inf')\n\n    for i in range(1, len(prices)):\n        for j in range(1, k + 1):\n            # max profit from 0 to i with k-1 transactions\n            max_profit_with_k_minus_1_transactions = dp[i - 1][j - 1]\n            # max profit from 0 to i with k transactions\n            max_profit_with_k_transactions = dp[i - 1][j]\n            # max profit from 0 to i with k-1 transactions\n            max_profit_with_k_minus_1_transactions = max(max_profit_with_k_minus_1_transactions,\n                                                         dp[i - 1][j - 1] - prices[i - 1])\n            # max profit from 0 to i with k transactions\n            max_profit_with_k_transactions = max(max_profit_with_k_transactions,\n                                                 dp[i - 1][j] + prices[i])\n            dp[i][j] = max(max_profit_with_k_minus_1_transactions, max_profit_with_k_transactions)\n\n    return dp[len(prices) - 1][k]\n\n\ndef main():\n    prices = [310, 315, 275, 295, 260, 2"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            profit = (prices[j] - prices[i])\n            if profit > max_profit:\n                max_profit = profit\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 9"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    # keep track of the max profit\n    max_profit = 0\n    # keep track of the current max price\n    cur_max_price = float('-inf')\n    # keep track of the current min price\n    cur_min_price = float('inf')\n\n    for price in prices:\n        cur_max_price = max(cur_max_price, price)\n        cur_min_price = min(cur_min_price, price)\n\n        # we have to check if we can make a profit from the current min price and max price\n        max_profit = max(max_profit, cur_max_price - cur_min_price)\n\n    return max_profit\n\n\nassert max_profit([2, 4, 1], 2) == 2\nassert max_profit([3, 2, 6, 5, 0, 3], 2) == 7"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "def max_profit(stock_prices, k):\n    \"\"\"\n    Returns the maximum profit from k transactions\n    :param stock_prices: a list of stock prices\n    :param k: the number of transactions\n    :return: the maximum profit\n    \"\"\"\n    if len(stock_prices) < k:\n        return 0\n\n    # we can assume that the first price is the minimum\n    min_price = stock_prices[0]\n    max_profit = 0\n\n    for i in range(k, len(stock_prices)):\n        profit = stock_prices[i] - min_price\n        if profit > max_profit:\n            max_profit = profit\n        if stock_prices[i] < min_price:\n            min_price = stock_prices[i]\n\n    return max_profit"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    if not prices:\n        return 0\n\n    num_transactions = [0] * (k + 1)\n\n    for price in prices:\n        for i in range(k, 0, -1):\n            num_transactions[i] = max(\n                num_transactions[i],\n                num_transactions[i - 1] - price,\n            )\n\n    return num_transactions[k] + prices[0]\n\n\nif __name__ == \"__main__\":\n    print(max_profit([2, 4, 1], 2))\n    print(max_profit([3, 2, 6, 5, 0, 3], 2))\n    print(max_profit([], 2))\n    print(max_profit([3, 3, 5, 0, 0, 3, 1, 4], 0))"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "# def max_profit(prices, k=2):\n#     # O(n*k)\n#     if not prices or len(prices) <= 1:\n#         return 0\n\n#     max_profit = 0\n#     for i in range(len(prices) - 1):\n#         for j in range(i + 2, len(prices)):\n#             max_profit = max(max_profit, prices[j] - prices[i])\n\n#     return max_profit\n\ndef max_profit(prices, k=2):\n    # O(n*k)\n    if not prices or len(prices) <= 1:\n        return 0\n\n    # init a k*2 array, where each row is a transaction, and each col is buy or sell\n    # 0th col is buy, 1st col is sell\n    # [\n    #     [buy1, sell1],\n    #     [buy2, sell2]\n    # ]\n    transactions = [[float('-inf'), float('-inf')] for _ in range(k)]\n    # init the first transaction\n    transactions[0][0] = prices[0]\n\n    for i in range(1, len(prices)):\n        # update the max profit\n        max_profit = float('-inf')\n        for j in range(k):\n            # sell\n            transactions[j][1] = max(transactions[j][1], prices[i] + transactions[j][0])\n            # buy\n            max_profit = max(max_profit, transactions[j][1] - prices[i])\n            transactions[j][0] = max(transactions[j][0], prices[i] - transactions[j][1])\n\n        # update the max profit\n        max_profit = max(max_profit, transactions[0][1] - prices[i])\n\n    return max_profit\n\n\nif __name__ == '__main__':\n    prices = [310, 315, 275, 295, 260, 270, 290"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "def get_max_profit(prices, k):\n    \"\"\"\n    >>> get_max_profit([2, 4, 1], 2)\n    2\n    >>> get_max_profit([3, 2, 6, 5, 0, 3], 2)\n    4\n    >>> get_max_profit([1, 2], 1)\n    1\n    >>> get_max_profit([1, 2, 3, 4, 5], 1)\n    4\n    >>> get_max_profit([1, 2, 3, 4, 5], 2)\n    4\n    >>> get_max_profit([7, 1, 5, 3, 6, 4], 2)\n    5\n    >>> get_max_profit([7, 6, 4, 3, 1], 1)\n    0\n    >>> get_max_profit([1], 1)\n    0\n    \"\"\"\n    if not prices or len(prices) < 2:\n        return 0\n    n = len(prices)\n    if n == 2:\n        return prices[1] - prices[0]\n\n    # dp[i][j] means the max profit earned by doing at most j transactions from day 0 to day i (inclusive)\n    # dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j] + prices[i])\n    # dp[i][j - 1] + prices[i] means we do one more transaction at day i\n    # dp[i - 1][j - 1] means we don't do any transaction at day i\n\n    dp = [[0] * (k + 1) for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])\n\n    return dp["
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "import sys\n\n\ndef max_profit_k_times(prices, k):\n    if k > len(prices):\n        return 0\n    max_profit = 0\n    min_price = sys.maxsize\n\n    for i in range(len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n\n    return max_profit\n\n\nprint(max_profit_k_times([10, 22, 5, 75, 65, 80], 2))\nprint(max_profit_k_times([10, 22, 5, 75, 65, 80], 3))\nprint(max_profit_k_times([10, 22, 5, 75, 65, 80], 4))\nprint(max_profit_k_times([10, 22, 5, 75, 65, 80], 5))\nprint(max_profit_k_times([10, 22, 5, 75, 65, 80], 6))"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "def max_profit_k_times(stock_prices, k):\n    \"\"\"\n    :param stock_prices: list of stock prices\n    :param k: number of transactions\n    :return: maximum profit earned\n    \"\"\"\n    if len(stock_prices) < 2:\n        return 0\n\n    if k == 0:\n        return 0\n\n    if k >= len(stock_prices) / 2:\n        return max_profit(stock_prices)\n\n    max_profit_from_k_transactions = -1\n    for i in range(k):\n        max_profit_from_k_transactions = max(\n            max_profit_from_k_transactions,\n            max_profit_k_times(stock_prices[:i] + stock_prices[i + 1:], k - 1) + stock_prices[i]\n        )\n\n    return max_profit_from_k_transactions\n\n\ndef max_profit(stock_prices):\n    \"\"\"\n    :param stock_prices: list of stock prices\n    :return: maximum profit earned\n    \"\"\"\n    min_price = stock_prices[0]\n    max_profit = 0\n\n    for i in range(1, len(stock_prices)):\n        max_profit = max(max_profit, stock_prices[i] - min_price)\n        min_price = min(min_price, stock_prices[i])\n\n    return max_profit\n\n\ndef test_max_profit_k_times():\n    assert max_profit_k_times([1, 5, 3, 2, 6], 2) == 5\n    assert max_profit_k_times([1, 5, 3, 2, 6], 3) == 7\n    assert max_profit_k_times([1, 5, 3, 2, 6], 4) == 9\n    assert max_profit_k_times([1, 5, 3, 2, 6], 5) == 10"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list of prices of the stock\n    :param k: number of transactions\n    :return: max profit\n\n    Time complexity: O(n*k)\n    Space complexity: O(n)\n    \"\"\"\n    if k > len(prices) // 2:\n        return max_profit_rec(prices)\n\n    n = len(prices)\n    max_profits = [0] * n\n    for i in range(n - 1):\n        max_profits[i + 1] = max(0, max_profits[i] + prices[i + 1] - prices[i])\n\n    max_profit_k = 0\n    for i in range(n - k):\n        max_profit_k = max(max_profit_k, max_profits[i] + max_profits[i + k])\n\n    return max_profit_k\n\n\ndef max_profit_rec(prices):\n    \"\"\"\n    :param prices: list of prices of the stock\n    :return: max profit\n\n    Time complexity: O(2^n)\n    Space complexity: O(n)\n    \"\"\"\n    if not prices:\n        return 0\n\n    return max(prices[-1] - prices[0] + max_profit_rec(prices[:-1]),\n               max_profit_rec(prices[:-1]))\n\n\nif __name__ == \"__main__\":\n    assert max_profit([10, 5, 3, 1, 3, 5, 7], 2) == 8\n    assert max_profit([10, 5, 3, 1, 3, 5, 7], 3) == 10\n    assert max_profit([10, 5, 3, 1, 3, 5, 7], 4) == 10\n    assert max_profit([10, 5, 3, 1, 3, 5, 7], 5) == 10\n    assert max_pro"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list of stock prices\n    :param k: number of transactions\n    :return: maximum profit\n\n    Time complexity: O(n*k)\n    Space complexity: O(k)\n    \"\"\"\n    if not prices:\n        return 0\n\n    # k transactions, each with 2 states: buy and sell\n    # buy[i][k] = max(buy[i - 1][j] - prices[i], sell[i - 1][j])\n    # sell[i][k] = max(sell[i - 1][j] + prices[i], buy[i - 1][j])\n    # start from the last day\n    buy = [[0] * (k + 1) for _ in range(len(prices))]\n    sell = [[0] * (k + 1) for _ in range(len(prices))]\n\n    buy[len(prices) - 1][0] = -prices[len(prices) - 1]\n\n    for i in range(len(prices) - 2, -1, -1):\n        for j in range(1, k + 1):\n            # buy[i][j] = max(buy[i - 1][j - 1] - prices[i], sell[i - 1][j])\n            buy[i][j] = max(buy[i][j - 1] - prices[i], sell[i - 1][j])\n\n            # sell[i][j] = max(sell[i - 1][j - 1] + prices[i], buy[i - 1][j])\n            sell[i][j] = max(sell[i][j - 1] + prices[i], buy[i - 1][j])\n\n    return max(sell[0])\n\n\ndef test_max_profit_1():\n    k = 2\n    prices = [2, 4, 1]\n    assert max_profit(prices, k) == 2\n\n\ndef test_max_profit_2():\n    k"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(prices) <= 1:\n        return 0\n    n = len(prices)\n    max_profit = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            max_profit += max(prices[j] - prices[i], 0)\n    return max_profit / k\n\n\nif __name__ == \"__main__\":\n    assert max_profit([1, 2, 3, 4, 5], 1) == 4\n    assert max_profit([1, 2, 3, 4, 5], 2) == 4\n    assert max_profit([1, 2, 3, 4, 5], 3) == 3\n    assert max_profit([1, 2, 3, 4, 5], 4) == 2\n    assert max_profit([1, 2, 3, 4, 5], 5) == 1\n    assert max_profit([1, 2, 3, 4, 5], 6) == 0\n    assert max_profit([1, 2, 3, 4, 5], 7) == 0\n    assert max_profit([1, 2, 3, 4, 5], 0) == 0\n    assert max_profit([1, 2, 3, 4, 5], 10) == 0\n    assert max_profit([2, 3, 4, 5, 6], 1) == 0\n    assert max_profit([2, 3, 4, 5, 6], 2) == 0\n    assert max_profit([2, 3, 4, 5, 6], 3) == 0\n    assert max_profit([2, 3, 4, 5, 6], 4) == 0"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(k*n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n\n    if k > n:\n        return max(prices[i + 1] - prices[i] for i in range(n - 1))\n\n    profit = 0\n\n    # greedily buy on first day and sell on last day\n    min_price = prices[0]\n    max_profit = prices[-1] - min_price\n\n    # iterate through all days\n    for day in range(1, n):\n        # update min price\n        min_price = min(min_price, prices[day])\n\n        # update max profit\n        profit = max(profit, prices[day] - min_price)\n\n    # iterate through all days\n    for day in range(n - 2, 0, -1):\n        # update min price\n        min_price = min(min_price, prices[day])\n\n        # update max profit\n        profit = max(profit, prices[day] - min_price)\n\n    return profit\n\n\nif __name__ == \"__main__\":\n    assert max_profit(3, [3, 3, 5, 0, 0, 3, 1, 4]) == 4\n    assert max_profit(2, [1, 2, 3, 4, 5]) == 4\n    assert max_profit(2, [7, 1, 5, 3, 6, 4]) == 5\n    assert max_profit(1, [7, 6, 4, 3, 1]) == 0"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "from typing import List\n\n\n# This solution is not optimal because it will try every possible combination\n# There is a dynamic programming approach that can be used to solve this problem in O(n)\n# See https://www.youtube.com/watch?v=7VeOGwWUHKY\ndef find_max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Find the maximum profit earned from a maximum of k stock transactions\n\n    Args:\n        prices: list of stock prices\n        k: number of transactions\n\n    Returns:\n        maximum profit\n\n    Raises:\n        AssertionError if prices is empty or k < 0\n\n    >>> find_max_profit([10, 5, 2, 3, 7], 2)\n    6\n    >>> find_max_profit([10, 5, 2, 3, 7], 1)\n    7\n    >>> find_max_profit([10, 5, 2, 3, 7], 0)\n    0\n    >>> find_max_profit([10, 5, 2, 3, 7], 10)\n    7\n    >>> find_max_profit([10, 5, 2, 3, 7], 100)\n    7\n    >>> find_max_profit([10, 5, 2, 3, 7], 1000)\n    7\n    \"\"\"\n    assert prices and k >= 0, \"Invalid input\"\n\n    # If we can buy and sell on the same day, we can make an infinite profit\n    if k == 0:\n        return 0\n\n    # The maximum profit is the difference between the maximum price and the minimum price\n    max_profit = max(prices) - min(prices)\n\n    # If we can only buy and sell once, we can't make a profit\n    if k == 1:\n        return max_profit\n\n    # If we can buy and sell any number of times, we can make a profit as long as\n    # the number of transactions is less than the number of prices"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "def max_profit_k_times(stock_prices, k):\n    if k >= len(stock_prices) / 2:\n        return max_profit_unlimited(stock_prices)\n\n    max_profit = 0\n    for i in range(len(stock_prices)):\n        for j in range(i + 1, len(stock_prices)):\n            if j - i > k:\n                continue\n            profit = stock_prices[j] - stock_prices[i]\n            if profit > max_profit:\n                max_profit = profit\n\n    return max_profit\n\ndef max_profit_unlimited(stock_prices):\n    max_profit = 0\n    min_price = stock_prices[0]\n    for price in stock_prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n\n    return max_profit\n\ndef max_profit_unlimited_optimized(stock_prices):\n    max_profit = 0\n    min_price = stock_prices[0]\n    for price in stock_prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n\n    return max_profit\n\ndef max_profit_k_times_optimized(stock_prices, k):\n    if k >= len(stock_prices) / 2:\n        return max_profit_unlimited_optimized(stock_prices)\n\n    max_profit = 0\n    for i in range(len(stock_prices)):\n        for j in range(i + 1, len(stock_prices)):\n            if j - i > k:\n                continue\n            profit = stock_prices[j] - stock_prices[i]\n            if profit > max_profit:\n                max_profit = profit\n\n    return max_profit\n\ndef max_pro"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "def get_max_profit(prices, k):\n    \"\"\"\n    Time complexity: O(nk)\n    Space complexity: O(n)\n    \"\"\"\n    if k >= len(prices) / 2:\n        return get_max_profit_dp(prices)\n\n    profit = 0\n    for i in range(len(prices)):\n        max_profit = 0\n        for j in range(i + 1, len(prices)):\n            diff = prices[j] - prices[i]\n            if diff > max_profit:\n                max_profit = diff\n        profit += max_profit\n\n    return profit\n\n\ndef get_max_profit_dp(prices):\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    if len(prices) <= 1:\n        return 0\n\n    min_price = prices[0]\n    profit = 0\n    for price in prices[1:]:\n        if price < min_price:\n            min_price = price\n        if price - min_price > profit:\n            profit = price - min_price\n\n    return profit\n\n\nif __name__ == '__main__':\n    print(get_max_profit([3, 2, 6, 5, 0, 3], 2))\n    print(get_max_profit([3, 3, 5, 0, 0, 3, 1, 4], 0))"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    n = len(prices)\n    if k >= n/2:\n        return max_profit_all(prices)\n    else:\n        return max_profit_k(prices, k)\n\n\ndef max_profit_k(prices, k):\n    n = len(prices)\n    if n <= 1:\n        return 0\n    if k == 1:\n        return max_profit_all(prices)\n    # max_buy[i] = max profit from 0 to i-1\n    # max_sell[i] = max profit from 0 to i-1\n    # max_buy[i] = max(max_buy[i-1], max_sell[i-2] - prices[i-1])\n    # max_sell[i] = max(max_sell[i-1], max_buy[i-1] + prices[i])\n    max_buy = [0] * n\n    max_sell = [0] * n\n    max_buy[0] = 0\n    max_buy[1] = -prices[0]\n    max_sell[0] = 0\n    max_sell[1] = prices[1] - prices[0]\n    for i in range(2, n):\n        max_buy[i] = max(max_buy[i-1], max_sell[i-2] - prices[i-1])\n        max_sell[i] = max(max_sell[i-1], max_buy[i-1] + prices[i])\n    return max_sell[-1]\n\n\ndef max_profit_all(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            max_profit += prices[i] - prices[i-1]\n    return max_profit\n\n\nassert max_profit([1, 2, 3, 0, 2],"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "from typing import List\n\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n\n    # initialize the table\n    # f[i][k][j] means the max profit in the ith day with k transactions left\n    # and the jth transaction is made\n    f = [[[0] * (k+1) for _ in range(n+1)] for _ in range(k+1)]\n\n    # base case: the max profit in the ith day with 0 transaction left is 0\n    for i in range(1, n+1):\n        f[0][i][0] = 0\n\n    # base case: the max profit in the 0th day with 1 to k transactions left is 0\n    for j in range(1, k+1):\n        f[j][0][1] = 0\n\n    # dp\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            for t in range(1, n+1):\n                if t > i:\n                    f[j][i][t] = max(f[j][i-1][t], f[j-1][i][t-1] + prices[i-1])\n                else:\n                    f[j][i][t] = f[j][i-1][t]\n\n    return f[k][n][k]\n\n\nif __name__ == \"__main__\":\n    assert max_profit([1, 2, 3, 0, 2], 2) == 3"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "from typing import List\n\n\n# O(n^2)\ndef max_profit(prices: List[int], k: int) -> int:\n    \"\"\"\n    >>> max_profit([2, 4, 1], 2)\n    2\n    >>> max_profit([3, 2, 6, 5, 0, 3], 2)\n    4\n    >>> max_profit([], 2)\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    if k > n // 2:\n        return sum(prices) - min(prices) * n\n\n    # profit = [0] * (k + 1)\n    #\n    # for i in range(n):\n    #     for j in range(1, k + 1):\n    #         profit[j] = max(profit[j], prices[i] + profit[j - 1] - prices[i - 1])\n    #\n    # return profit[k]\n\n    # O(k)\n    # O(nk)\n    # O(nk)\n    profit = [0] * (k + 1)\n    min_price = prices[0]\n\n    for i in range(1, n):\n        min_price = min(min_price, prices[i])\n        for j in range(1, k + 1):\n            profit[j] = max(profit[j], prices[i] - min_price + profit[j - 1])\n\n    return profit[k]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "def max_profit(stock_prices, k):\n    if len(stock_prices) < 2:\n        return 0\n    if k >= len(stock_prices):\n        return max_profit_naive(stock_prices)\n\n    max_profit = 0\n    for i in range(k):\n        max_profit_with_ith_transaction = 0\n        min_price = stock_prices[i]\n        for j in range(i+1, len(stock_prices)):\n            if stock_prices[j] < min_price:\n                min_price = stock_prices[j]\n            max_profit_with_ith_transaction += stock_prices[j] - min_price\n        max_profit = max(max_profit, max_profit_with_ith_transaction)\n    return max_profit\n\n\ndef max_profit_naive(stock_prices):\n    max_profit = 0\n    for i in range(len(stock_prices)-1):\n        max_profit += max(0, stock_prices[i+1]-stock_prices[i])\n    return max_profit\n\nprint(max_profit([3, 2, 6, 5, 0, 3], 2))\nprint(max_profit([1, 2, 3, 4, 5], 1))\nprint(max_profit([1, 2, 3, 4, 5], 2))\nprint(max_profit([1, 2, 3, 4, 5], 3))\nprint(max_profit([1, 2, 3, 4, 5], 4))\nprint(max_profit([1, 2, 3, 4, 5], 5))\nprint(max_profit([1, 2, 3, 4, 5], 6))\nprint(max_profit([1, 2, 3, 4, 5], 7))\n\nprint(max_profit([3, 2, 6,"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "def max_profit(arr, k):\n    if not arr or k > len(arr):\n        return 0\n\n    # sort the array in decreasing order\n    arr = sorted(arr, reverse=True)\n    # k stores the maximum number of transactions we can make\n    # i stores the index of the current element\n    # profit stores the current profit\n    profit = 0\n    i = 0\n    while k > 0:\n        # check if there is a profit at all\n        if i + 1 < len(arr):\n            # if the next element is same as the current element\n            if arr[i] == arr[i + 1]:\n                # skip the element\n                i += 1\n            else:\n                # else update the index and profit\n                i += 1\n                profit += arr[i] - arr[i - 1]\n                # update the k to check for transactions\n                k -= 1\n        else:\n            # break if we have reached the end of the array\n            break\n\n    return profit\n\n\nif __name__ == \"__main__\":\n    print(max_profit([2, 1, 2, 0, 1], 2))\n    print(max_profit([3, 2, 6, 5, 0, 3], 2))"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    O(nk) time complexity and O(k) space complexity\n    \"\"\"\n    if k == 0 or len(prices) < 2:\n        return 0\n\n    # calculate max possible profits from k-1 transactions\n    profit_from_k_minus_1 = max_profit(prices, k - 1)\n\n    # calculate max possible profits from 1 transaction\n    max_profit_from_one_transaction = 0\n    min_price = prices[0]\n    for i in range(1, len(prices)):\n        max_profit_from_one_transaction = max(max_profit_from_one_transaction, prices[i] - min_price)\n        min_price = min(min_price, prices[i])\n\n    return max(max_profit_from_one_transaction, profit_from_k_minus_1 + max_profit_from_one_transaction)\n\n\nif __name__ == '__main__':\n    print max_profit([2, 4, 1], 2)\n    print max_profit([3, 2, 6, 5, 0, 3], 2)"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "# def max_profit(stock_prices, k):\n#     max_profit = 0\n#     if k >= len(stock_prices):\n#         for i in range(1, len(stock_prices)):\n#             if stock_prices[i] > stock_prices[i - 1]:\n#                 max_profit += stock_prices[i] - stock_prices[i - 1]\n#     return max_profit\n\n\ndef max_profit(stock_prices, k):\n    # max_profit = 0\n    # if k >= len(stock_prices):\n    #     for i in range(1, len(stock_prices)):\n    #         if stock_prices[i] > stock_prices[i - 1]:\n    #             max_profit += stock_prices[i] - stock_prices[i - 1]\n    # return max_profit\n    max_profit = 0\n    for i in range(1, len(stock_prices)):\n        if stock_prices[i] > stock_prices[i - 1]:\n            max_profit += stock_prices[i] - stock_prices[i - 1]\n    return max_profit\n\n\ndef max_profit_2(stock_prices, k):\n    max_profit = 0\n    for i in range(1, len(stock_prices)):\n        if stock_prices[i] > stock_prices[i - 1]:\n            max_profit += stock_prices[i] - stock_prices[i - 1]\n    return max_profit\n\n\ndef max_profit_3(stock_prices, k):\n    max_profit = 0\n    for i in range(1, len(stock_prices)):\n        if stock_prices[i] > stock_prices[i - 1]:\n            max_profit += stock_prices[i] - stock_prices[i - 1]\n    return max_profit\n\n\nstock_prices = [310, 3"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    n = len(prices)\n    # dp[i][j] means max profit with i transactions and ending at day j\n    dp = [[0 for _ in range(n)] for _ in range(k + 1)]\n    # dp[i][j] = max(dp[i - 1][j - 1], dp[i][j - 1]) + prices[j]\n    for i in range(1, k + 1):\n        max_profit_with_i_transactions = float('-inf')\n        for j in range(1, n):\n            max_profit_with_i_transactions = max(max_profit_with_i_transactions,\n                                                 dp[i - 1][j - 1] + prices[j])\n            dp[i][j] = max(dp[i][j - 1], max_profit_with_i_transactions)\n    return dp[k][n - 1]\n\n\ndef main():\n    prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(max_profit(prices, 2))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from collections import namedtuple\n\n\ndef max_profit(prices, k=2):\n    \"\"\"\n    :param prices: List of stock prices\n    :param k: Number of transactions\n    :return: Maximum profit\n    \"\"\"\n\n    # Validate input\n    if not isinstance(prices, list) or not all(isinstance(p, int) for p in prices):\n        raise TypeError(\"prices must be a list of integers\")\n    if len(prices) < 2:\n        raise ValueError(\"prices must contain at least 2 elements\")\n    if not isinstance(k, int) or k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n\n    # If there are no transactions, return 0\n    if k == 0:\n        return 0\n\n    # If there is only one transaction, return max profit\n    if k == 1:\n        return max(prices) - min(prices)\n\n    # If there are 2 transactions, return max profit from 2 transactions\n    if k == 2:\n        return max(prices[1:] - prices[:-1])\n\n    # Create a named tuple for keeping track of profit\n    Profit = namedtuple(\"Profit\", [\"min\", \"max\"])\n\n    # Create a list to keep track of profit at each transaction\n    profit = [Profit(min=prices[0], max=0)]\n\n    # Iterate over the rest of the prices\n    for price in prices[1:]:\n        # If price is less than min, update min and max\n        if price < profit[-1].min:\n            profit.append(Profit(min=price, max=0))\n        # If price is greater than max, update max\n        elif price > profit[-1].max:\n            profit[-1] = Profit(min=profit[-1].min, max=price)\n\n    # Return the maximum profit\n    return max(p.max - p.min for p in profit)\n\n\n# Test cases\nprint(max_profit([2, 4, 1], 2))\nprint(max_profit([3, 2, 6, 5, 0,"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def max_profit(stock_prices, k):\n    \"\"\"\n    Let's say we have 5 stock prices for a stock and we can buy and sell the stock\n    multiple times. We have to find the maximum profit earned.\n    stock_prices = [10, 22, 5, 75, 65]\n    k = 2\n    \"\"\"\n    # sort the list of stock prices in ascending order\n    stock_prices.sort()\n    # the last element is the maximum profit\n    max_profit = stock_prices[-1]\n    # the minimum price is the first element\n    min_price = stock_prices[0]\n    # the maximum price is the last element\n    max_price = stock_prices[-1]\n    # we have to buy and sell the stock k times\n    for i in range(k):\n        # if the first element is greater than the last element, return 0\n        if stock_prices[0] > stock_prices[-1]:\n            return 0\n        # if the first element is less than the last element,\n        # then we have to sell the stock at the maximum price\n        elif stock_prices[0] < stock_prices[-1]:\n            # find the maximum price\n            max_price = max(stock_prices)\n            # find the minimum price\n            min_price = min(stock_prices)\n            # find the maximum profit\n            max_profit = max_profit - min_price\n            # find the index of the maximum price\n            index = stock_prices.index(max_price)\n            # remove the maximum price from the list\n            stock_prices.remove(max_price)\n            # if there are still prices in the list\n            if stock_prices:\n                # find the minimum price\n                min_price = min(stock_prices)\n                # find the maximum profit\n                max_profit = max_profit - min_price\n    return max_profit\n\nif __name__ == '__main__':\n    # stock_prices = [10, 22, 5, 75, 65]\n    # k ="
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    n = len(prices)\n    # \u5b9a\u4e49f[i][j]\uff0c\u7b2ci\u5929\u7ed3\u675f\u65f6\uff0c\u6301\u6709j\u652f\u80a1\u7968\u7684\u6700\u5927\u6536\u76ca\n    f = [[0] * (k + 1) for _ in range(n)]\n\n    # \u521d\u59cb\u72b6\u6001\n    for i in range(1, k + 1):\n        f[0][i] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            # \u5f53\u524d\u72b6\u6001\n            f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] - prices[i])\n\n    return f[n - 1][k]\n\n\nif __name__ == '__main__':\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n    print(max_profit(prices, k))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    n = len(prices)\n    if n < 2:\n        return 0\n    # dp[i][j] max profit up to i transactions on day j\n    dp = [[0 for _ in range(n)] for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_profit_from_i_transactions = float(\"-inf\")\n        for j in range(1, n):\n            # buy on day j\n            buy = prices[j] + dp[i - 1][j - 1]\n            # sell on day j\n            sell = dp[i][j - 1] - prices[j]\n            max_profit_from_i_transactions = max(max_profit_from_i_transactions, buy, sell)\n        dp[i][j] = max_profit_from_i_transactions\n    return dp[k][n - 1]\n\n\nassert max_profit([5, 1, 3, 2, 4, 3], 2) == 4\nassert max_profit([1, 2, 3, 4, 5], 1) == 4"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    # initialize\n    max_profit = 0\n    # sort prices\n    prices.sort()\n\n    for i in range(len(prices) - 1):\n        # compare prices\n        if prices[i] < prices[i + 1]:\n            max_profit += prices[i + 1] - prices[i]\n\n    return max_profit\n\n\n# Tests\n\ndef test(prices, k, expected):\n    result = max_profit(prices, k)\n    if result == expected:\n        print('PASSED: max_profit({}, {}) returned {}'.format(prices, k, result))\n    else:\n        print('FAILED: max_profit({}, {}) returned {}, expected {}'.format(prices, k, result, expected))\n\n\ntest([1, 3, 7, 5, 10, 3], 2, 10)\ntest([1, 2, 3, 4, 5], 1, 4)\ntest([1, 2, 3, 4, 5], 2, 7)\ntest([1, 2, 3, 4, 5], 3, 10)\ntest([1, 2, 3, 4, 5], 4, 10)\ntest([1, 2, 3, 4, 5], 5, 10)\ntest([1, 2, 3, 4, 5], 6, 10)\ntest([1, 2, 3, 4, 5], 10, 10)\ntest([1, 2, 3, 4, 5], 0, 0)\ntest([1, 2, 3, 4, 5], 100000, 10)"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    # TODO: Write your code here\n    pass"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def get_max_profit(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    if k >= len(prices) // 2:\n        return sum([prices[i + 1] - prices[i] for i in range(len(prices) - 1)])\n\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n\n    return max_profit\n\n\ndef get_max_profit_v2(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    if k >= len(prices) // 2:\n        return sum([prices[i + 1] - prices[i] for i in range(len(prices) - 1)])\n\n    max_profit = 0\n    for i in range(len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n\n    return max_profit"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "import heapq\nfrom typing import List\n\n\ndef find_max_profit(arr: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if k > len(arr) // 2:\n        return find_max_profit_greedy(arr)\n\n    min_heap = [-val for val in arr]\n    heapq.heapify(min_heap)\n\n    max_heap = []\n\n    for _ in range(k):\n        max_heap.append(-heapq.heappop(min_heap))\n\n    for val in arr:\n        heapq.heappush(min_heap, -val)\n        if min_heap and -min_heap[0] > max_heap[0]:\n            heapq.heappop(max_heap)\n            heapq.heappush(max_heap, -min_heap[0])\n\n    return max_heap[0]\n\n\ndef find_max_profit_greedy(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n^2)\n    Space Complexity: O(1)\n    \"\"\"\n    max_profit = 0\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[j] > arr[i]:\n                max_profit += arr[j] - arr[i]\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    assert find_max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == 11\n    assert find_max_profit([2, 1, 2, 0, 1], 2) == 2"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    # Base Case\n    if k == 0 or len(prices) - 1 <= k:\n        return 0\n\n    # Hypothesis\n    max_profit_from_i_to_end = max_profit(prices[1:], k)\n\n    # Induction\n    max_profit_from_0_to_i = 0\n    max_price_so_far = prices[0]\n    for i in range(1, len(prices)):\n        max_price_so_far = max(max_price_so_far, prices[i])\n        max_profit_from_0_to_i = max(max_profit_from_0_to_i, max_price_so_far - prices[i])\n\n    return max(max_profit_from_i_to_end, max_profit_from_0_to_i)"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "def max_profit(stocks, k):\n    max_profit = 0\n    for i in range(len(stocks) - 1):\n        for j in range(i + 1, len(stocks)):\n            if stocks[j] > stocks[i]:\n                max_profit += stocks[j] - stocks[i]\n    return max_profit\n\n\ndef max_profit_dp(stocks, k):\n    # Initialize DP table\n    # The first column is max profit without selling\n    # The first row is max profit without buying\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(stocks))]\n\n    # Populate DP table\n    for i in range(1, len(stocks)):\n        for j in range(1, k + 1):\n            dp[i][j] = max(\n                dp[i - 1][j],\n                dp[i - 1][j - 1] + stocks[i]\n            )\n\n    return dp[-1][-1]\n\n\ndef max_profit_dp_2(stocks, k):\n    # Initialize DP table\n    # The first column is max profit without selling\n    # The first row is max profit without buying\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(stocks))]\n\n    # Populate DP table\n    for i in range(1, len(stocks)):\n        for j in range(1, k + 1):\n            dp[i][j] = max(\n                dp[i - 1][j],\n                dp[i - 1][j - 1] + stocks[i]\n            )\n\n    return dp[-1][-1]\n\n\ndef max_profit_dp_3(stocks, k):\n    # Initialize DP table\n    # The first column is max profit without selling\n    # The first row is max profit without buying\n    dp = [[0 for _ in range(k + 1)] for _ in range(len(stock"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit_k_times(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n    \"\"\"\n    # TODO: implement\n    return 0\n\n\ndef max_profit_k_times_dp(prices: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n    \"\"\"\n    # TODO: implement\n    return 0\n\n\nif __name__ == \"__main__\":\n    # TODO: implement\n    pass"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "def max_profit(prices, k=2):\n    \"\"\"\n    :param prices: a list of price of the stocks in the given interval\n    :param k: the maximum number of transactions\n    :return: the maximum profit\n    \"\"\"\n    # first we sort the prices in descending order\n    prices.sort(reverse=True)\n    # then we keep the first k elements in the list\n    prices = prices[:k]\n    # we now use dynamic programming to find the maximum profit\n    profit = 0\n    for i in range(len(prices) - 1):\n        profit += prices[i] - prices[i + 1]\n    return profit\n\n\nif __name__ == '__main__':\n    print(max_profit([2, 3, 1, 10, 5]))\n    print(max_profit([2, 3, 1, 10, 5], 3))\n    print(max_profit([2, 3, 1, 10, 5], 4))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "def max_profit_with_k_transactions(prices, k):\n    \"\"\"\n    :param prices: list of prices\n    :param k: number of transactions\n    :return: max profit from k transactions\n    \"\"\"\n    # Write your code here\n    pass\n\n\ndef max_profit_with_k_transactions_v2(prices, k):\n    \"\"\"\n    :param prices: list of prices\n    :param k: number of transactions\n    :return: max profit from k transactions\n    \"\"\"\n    # Write your code here\n    pass"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# 0/1 knapsack problem\n\n# O(k*n) time | O(n) space - where n is the number of days, and k is the number of transactions\ndef maxProfitWithKTransactions(prices, k):\n\t# If k is 0, we can't do any transactions\n\tif k == 0:\n\t\treturn 0\n\n\t# If k is 1, we can only do 1 transaction and we'll just buy and sell on the same day\n\tif k == 1:\n\t\treturn maxSingleTransactionProfit(prices)\n\n\t# If k is equal to the length of the prices array, we can do a transaction for every day\n\tif k == len(prices):\n\t\treturn getMaxProfit(prices)\n\n\t# If k is greater than the length of the prices array, then we can only do 1 transaction\n\t# and it has to be the maxSingleTransactionProfit\n\tif k >= len(prices):\n\t\treturn maxSingleTransactionProfit(prices)\n\n\t# If k is less than the length of the prices array, we can do a transaction for every day\n\t# except the last k - 1 days, and that will be our base case\n\tmax_profit = 0\n\tfor day in range(k - 1):\n\t\tprofit_for_day = maxSingleTransactionProfit(prices[day : len(prices)])\n\t\tif profit_for_day > max_profit:\n\t\t\tmax_profit = profit_for_day\n\treturn max_profit\n\n\ndef maxSingleTransactionProfit(prices):\n\tmax_profit = 0\n\tmin_price = float('inf')\n\tfor price in prices:\n\t\tif price < min_price:\n\t\t\tmin_price = price\n\t\tprofit = price - min_price\n\t\tif profit > max_profit:\n\t\t\tmax_profit = profit\n\treturn max_profit\n\n\ndef getMaxProfit(prices):\n\tmax_profit = 0\n\tfor i in range(len(prices) - 1):\n\t\tprofit = prices"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    n = len(prices)\n    if n <= 1:\n        return 0\n\n    if k > n / 2:\n        return max_profit_all_transactions(prices)\n\n    max_profit_k_transactions = 0\n    for i in range(n):\n        min_price = prices[i]\n        max_profit_transaction = 0\n        for j in range(i + 1, n):\n            profit = prices[j] - min_price\n            if profit > max_profit_transaction:\n                max_profit_transaction = profit\n        max_profit_k_transactions += max_profit_transaction\n    return max_profit_k_transactions\n\n\ndef max_profit_all_transactions(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit\n\n\nprint(max_profit([10, 22, 5, 75, 65, 80], 2))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    if not prices:\n        return 0\n    elif k >= len(prices) / 2:\n        return max_profit_all(prices)\n    else:\n        return max_profit_k(prices, k)\n\n\ndef max_profit_all(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit\n\n\ndef max_profit_k(prices, k):\n    # dp[i][j] means maximum profit from 0 to i transactions with at most j transactions\n    # dp[i][j] = max(dp[i - 1][j], prices[i] - min_price + dp[i - 1][j - 1])\n    # min_price = prices[i]\n    # for j in range(i):\n    #     if prices[j] < min_price:\n    #         min_price = prices[j]\n    # dp[i][j] = max(dp[i - 1][j], prices[i] - min_price + dp[i - 1][j - 1])\n    # dp[i][j] = max(dp[i - 1][j], prices[i] - prices[i - 1] + dp[i - 1][j - 1])\n    dp = [[0] * (k + 1) for _ in range(len(prices))]\n    for i in range(1, len(prices)):\n        for j in range(1, k + 1):\n            if i == 1:\n                dp[i][j] = max(dp[i - 1][j], prices[i] - prices[i - 1])\n            else:\n                dp[i][j] = max(dp[i - 1][j], prices[i] - prices[i - 1"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def max_profit(stock_prices, k):\n    \"\"\"\n    :param stock_prices: list of stock prices\n    :param k: number of transactions\n    :return: maximum profit earned\n\n    >>> max_profit([10, 22, 5, 75, 65, 80], 2)\n    73\n    >>> max_profit([10, 22, 5, 75, 65, 80], 3)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 4)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 5)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 6)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 7)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 8)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 9)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 10)\n    91\n    >>> max_profit([10, 22, 5, 75, 65, 80], 11)\n    91\n    \"\"\"\n    if k == 0:\n        return 0\n\n    if k > len(stock_prices) // 2:\n        return max_profit_k_or_more_transactions(stock_prices)\n\n    max_profit_transactions = 0\n    for buy_day in range(len(stock_prices)):\n        max_profit_trans"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    # k = 0: buy and sell at the same day\n    # k = 1: buy and sell at the same day\n    # k > 1: buy and sell at different days\n    # k = -1: buy and sell at different days\n\n    # k = 0: buy and sell at the same day\n    # k = 1: buy and sell at the same day\n    # k > 1: buy and sell at different days\n    # k = -1: buy and sell at different days\n    if k == 0:\n        return max(prices) - min(prices)\n\n    # k = 0: buy and sell at the same day\n    # k = 1: buy and sell at the same day\n    # k > 1: buy and sell at different days\n    # k = -1: buy and sell at different days\n    if k == 1:\n        max_diff = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                diff = prices[j] - prices[i]\n                max_diff = max(max_diff, diff)\n        return max_diff\n\n    # k = 0: buy and sell at the same day\n    # k = 1: buy and sell at the same day\n    # k > 1: buy and sell at different days\n    # k = -1: buy and sell at different days\n    if k == -1:\n        min_diff = prices[0]\n        max_diff = 0\n        for i in range(1, len(prices)):\n            diff = prices[i] - min_diff\n            max_diff = max(max_diff, diff)\n            min_diff = min(min_diff, prices[i])\n        return max_diff\n\n    # k = 0: buy and sell at the same day\n    # k = 1: buy and sell at the same day\n    # k > 1: buy and sell at different days\n    # k"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    # Write your code here.\n\t# get the length of the prices array\n\tlength = len(prices)\n\t\n\t# if the length is less than 2, then return 0\n\tif length < 2:\n\t\treturn 0\n\t\n\t# if k is greater than the length of prices, then return 0\n\tif k > length:\n\t\treturn 0\n\t\n\t# create a dp array\n\tdp = [[0 for x in range(length)] for y in range(k + 1)]\n\t\n\t# for every transaction, we can only buy and sell once\n\t# so we only need to iterate through the array once\n\tfor i in range(length):\n\t\t# if i == 0, then we can't buy anything\n\t\t# so profit is 0\n\t\tif i == 0:\n\t\t\tdp[0][i] = 0\n\t\t# if we can only buy and sell once, then we can't sell anything\n\t\t# so profit is 0\n\t\tif i == 1:\n\t\t\tdp[1][i] = 0\n\t\t\n\t\t# if we can buy and sell, then we can either buy or sell\n\t\t# so we need to check the dp values from the previous day\n\t\tif i >= 2:\n\t\t\tdp[0][i] = max(dp[0][i-1], prices[i] - prices[i-2])\n\t\t\tdp[1][i] = max(dp[1][i-1], prices[i] - prices[i-1])\n\t\t\t\n\t\t\t# if the dp[0][i-1] is greater than the dp[1][i-1],\n\t\t\t# then we can buy on the first day and sell on the second day\n\t\t\tif dp[0][i-1] > dp[1][i-1]:\n\t\t\t\t# then we need to check the previous days of dp[0][i-2]\n\t\t\t\tdp[2][i] = max(dp[2][i-1], dp[0][i"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :type prices: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not prices:\n        return 0\n\n    n = len(prices)\n    # dp[i][j] means max profit can be gained from 0 to i prices with j transactions\n    # dp[i][j] = max(dp[i-1][j], prices[i] - min(prices[:i]) + dp[0][j-1])\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j > i:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], prices[i - 1] - min(prices[:i]) + dp[0][j - 1])\n    return dp[-1][-1]\n\n\nif __name__ == '__main__':\n    print(max_profit([3,2,6,5,0,3], 2))\n    print(max_profit([3,3,5,0,0,3,1,4], 3))\n    print(max_profit([2,4,1], 2))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: list of prices of a stock\n    :param k: maximum number of transactions\n    :return: maximum profit\n\n    Time complexity: O(n * k)\n    Space complexity: O(n)\n    \"\"\"\n    # k transactions, each with 2 states: buy/sell\n    # buy: prices[i - 1]\n    # sell: prices[i]\n    # dp[i][j] represents max profit earned from first i transactions with j transactions remaining\n    # dp[i][j] = max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j])\n    n = len(prices)\n    if n < 2:\n        return 0\n\n    # dp[i][j] represents max profit earned from first i transactions with j transactions remaining\n    # dp[i][j] = max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j])\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            dp[i][j] = max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j])\n    return dp[n - 1][k]\n\n\ndef test_max_profit():\n    assert max_profit([5, 4, 3, 2, 1], 2) == 4\n\n\nif __name__ == '__main__':\n    test_max_profit()"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    if k >= len(prices):\n        return max_profit_k_transactions(prices)\n    return max_profit_k_transactions(prices[:-k]) + prices[-k]\n\n\ndef max_profit_k_transactions(prices):\n    if not prices:\n        return 0\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            profit += prices[i] - prices[i-1]\n    return profit\n\n\nassert max_profit([10, 22, 5, 75, 65, 80], 2) == 87\nassert max_profit([10, 22, 5, 75, 65, 80], 3) == 92\nassert max_profit([10, 22, 5, 75, 65, 80], 4) == 92"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def max_profit(k: int, prices: [int]) -> int:\n    \"\"\"\n    K transactions\n    :param k: number of transactions\n    :param prices: list of prices\n    :return: max profit\n    >>> max_profit(2, [2, 4, 1])\n    2\n    >>> max_profit(2, [3, 2, 6, 5, 0, 3])\n    4\n    \"\"\"\n    # max_profit[i][j] = max profit when i transactions left and jth stock is bought\n    # max_profit[0][j] = 0, max_profit[i][0] = 0\n    max_profit = [[0] * len(prices) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        for j in range(1, len(prices)):\n            max_profit[i][j] = max(max_profit[i][j - 1], prices[j] - prices[j - 1] + max_profit[i - 1][j - 1])\n\n    return max_profit[k][len(prices) - 1]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def find_max_profit(prices, k):\n    # TODO: Write your code here\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(buy_sell(prices))\n    max_profit = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            max_profit += max(buy_sell(prices[i:j]))\n    return max_profit\n\n\ndef buy_sell(prices):\n    profit = 0\n    min_price = prices[0]\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        if price - min_price > profit:\n            profit = price - min_price\n    return profit\n\n\nprices = [2, 1, 4, 3, 6, 5]\nprint(find_max_profit(prices, 2))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from typing import List, Optional\n\n\ndef get_max_profit(stock_prices: List[int], k: int) -> Optional[int]:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(k)\n    \"\"\"\n    if not stock_prices or len(stock_prices) < 2:\n        return None\n\n    max_profit_from_k_transactions: List[int] = [0] * (k + 1)\n    min_price_so_far: int = stock_prices[0]\n\n    for i in range(1, len(stock_prices)):\n        min_price_so_far = min(min_price_so_far, stock_prices[i])\n        for j in range(1, k + 1):\n            max_profit_from_k_transactions[j] = max(\n                max_profit_from_k_transactions[j],\n                stock_prices[i] - min_price_so_far,\n                max_profit_from_k_transactions[j - 1],\n            )\n\n    return max_profit_from_k_transactions[k]\n\n\nif __name__ == \"__main__\":\n    assert get_max_profit([10, 8, 5, 7, 15, 12, 75, 41], 2) == 60"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "def max_profit(prices, k):\n    \"\"\"\n    :param prices: List[int]\n    :param k: int\n    :return: int\n    \"\"\"\n    # k = number of transactions\n    # if k == 0, then we can't do any transaction, thus profit is 0\n    if k == 0:\n        return 0\n    # if k == 1, then we can do only 1 transaction, and that is the max profit\n    if k == 1:\n        return max(prices)\n    # if k == len(prices), then we can do only len(prices) transactions, and that is the max profit\n    if k == len(prices):\n        return sum(prices) - min(prices)\n    # if k > len(prices), then we can do len(prices) transactions\n    if k > len(prices):\n        k = len(prices)\n    # at most k-2 transactions can be done\n    # we can do k-1 transactions and buy at the first price and sell at the last price\n    if k == 2:\n        return sum(prices) - 2 * min(prices)\n    # at most k-3 transactions can be done\n    if k == 3:\n        return max(prices[0] + prices[1], prices[0] + prices[-1], prices[-2] + prices[-1])\n    # at most k-4 transactions can be done\n    if k == 4:\n        return max(prices[0] + prices[1] + prices[2], prices[0] + prices[1] + prices[-1], prices[0] + prices[-2] + prices[-1], prices[-3] + prices[-2] + prices[-1])\n    # at most k-5 transactions can be done\n    if k == 5:\n        return max(prices[0] + prices[1] + prices[2] + prices[3], prices[0] + prices[1] + prices[2] + prices[-1], prices[0] + prices[1] + prices[-2] + prices[-1], prices[0] + prices[-3] + prices[-2] + prices"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_profit(k: int, prices: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(k)\n    \"\"\"\n\n    if k >= len(prices) // 2:\n        profit = 0\n        for i in range(1, len(prices)):\n            profit += max(prices[i] - prices[i - 1], 0)\n        return profit\n\n    max_profit_list = [0] * k\n\n    for i in range(k):\n        max_profit_list[i] = -prices[0]\n\n    for i in range(1, len(prices)):\n        for j in range(k):\n            max_profit_list[j] = max(max_profit_list[j], prices[i] + max_profit_list[j - 1])\n\n    return max_profit_list[-1]\n\n\nif __name__ == \"__main__\":\n    assert max_profit(3, [3, 2, 6, 5, 0, 3]) == 6"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "def max_profit(k, prices):\n    # TODO: Write your code here\n    return 0"
    }
  ]
}