{
  "timestamp": "2025-09-15T01:25:44.839150",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 412,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def find_gold(m, n, gm):\n    dp = [[0] * n for _ in range(m)]\n    for j in range(n):\n        if gm[0][j] != 0:\n            dp[0][j] = gm[0][j]\n\n    for i in range(1, m):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j] + gm[i][j])\n            elif j == n - 1:\n                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j])\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + gm[i][j],\n                               dp[i - 1][j + 1])\n    return dp[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gm = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n    print(find_gold(4, 4, gm))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def gold_mine(grid):\n    \"\"\"\n    :param grid: 2D array\n    :return: max gold we can collect\n    \"\"\"\n    # initializing the dp table\n    dp = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\n\n    # initializing the max_gold variable\n    max_gold = 0\n\n    # filling dp table\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n            max_gold = max(max_gold, dp[i][j])\n\n    return max_gold\n\n\ndef main():\n    grid = [[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1]]\n    print(gold_mine(grid))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    >>> gold_mine([\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ... ])\n    0\n\n    >>> gold_mine([\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 1],\n    ... ])\n    1\n\n    >>> gold_mine([\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0, 0, 0, 0, 0, 0, 0],\n    ...   [0,"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def gold_mine(gold, m, n):\n    \"\"\"\n    Gold mine problem\n    :param gold: 2D matrix containing gold in each cell\n    :param m: number of rows\n    :param n: number of columns\n    :return: maximum amount of gold that can be collected when starting from top-left cell\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n    if m == 1 and n == 1:\n        return gold[0][0]\n\n    # top row\n    for j in range(1, n):\n        gold[0][j] += gold[0][j - 1]\n\n    # left column\n    for i in range(1, m):\n        gold[i][0] += gold[i - 1][0]\n\n    # rest of the matrix\n    for i in range(1, m):\n        for j in range(1, n):\n            gold[i][j] += max(gold[i - 1][j], gold[i][j - 1])\n\n    return gold[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold = [[1, 3, 1, 5],\n            [2, 2, 4, 1],\n            [5, 0, 2, 3],\n            [0, 6, 1, 2]]\n    m = 4\n    n = 4\n    print(gold_mine(gold, m, n))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def gold_mine(gold, m, n):\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i == 1 and j == 1:\n                gold[i][j] = gold[i][j]\n            elif i == 1:\n                gold[i][j] = gold[i][j] + gold[i][j - 1]\n            elif j == 1:\n                gold[i][j] = gold[i][j] + gold[i - 1][j]\n            else:\n                gold[i][j] = gold[i][j] + max(gold[i - 1][j], gold[i][j - 1])\n    return gold[m][n]\n\n\ngold = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\nm = 3\nn = 4\nprint(gold_mine(gold, m, n))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def gold_mine(gold_mine_arr):\n    if not gold_mine_arr:\n        return 0\n    m = len(gold_mine_arr)\n    n = len(gold_mine_arr[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_mine_arr[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_mine_arr[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_mine_arr[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_mine_arr[i][j]\n    return dp[-1][-1]\n\n\ndef main():\n    gold_mine_arr = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    print(gold_mine(gold_mine_arr))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def gold_mine(gold_map):\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_map[row][col]\n            elif row == 0:\n                dp[row][col] = dp[row][col - 1] + gold_map[row][col]\n            elif col == 0:\n                dp[row][col] = dp[row - 1][col] + gold_map[row][col]\n            else:\n                dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + gold_map[row][col]\n\n    return dp[rows - 1][cols - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 6, 6],\n                [7, 2, 6, 9]]\n\n    print(gold_mine(gold_map))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map has +10 to the right, -10 to the left, +10 down, -10 up.\n    \"\"\"\n    rows = len(gold_map)\n    columns = len(gold_map[0])\n    dp = [[0 for _ in range(columns)] for _ in range(rows)]\n\n    # Gold at the bottom right corner.\n    dp[rows - 1][columns - 1] = gold_map[rows - 1][columns - 1]\n\n    for row in range(rows - 2, -1, -1):\n        for column in range(columns - 1, -1, -1):\n            if column == columns - 1:\n                dp[row][column] = max(\n                    dp[row + 1][column] - 10, gold_map[row][column]\n                )\n            elif column == 0:\n                dp[row][column] = max(\n                    dp[row + 1][column] - 10, gold_map[row][column]\n                )\n            else:\n                dp[row][column] = max(\n                    dp[row + 1][column] - 10,\n                    dp[row + 1][column + 1] - 10,\n                    gold_map[row][column],\n                )\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [[0, 3, 1, 1], [2, 2, 1, 5], [1, 3, 1, 0], [1, 1, 1, 4]]\n        )\n        == 12\n    )\n    assert (\n        gold_mine(\n            [[0, 3, 1, 1], [2, 2, 1, 5], [1, 3, 1, 0], [1, 1, 1, 4]]\n        )"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map:\n    [\n        [0, 6, 0, 0],\n        [5, 8, 7, 0],\n        [0, 9, 0, 8]\n    ]\n    \"\"\"\n    # O(n*m) time\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for col in range(cols - 1, -1, -1):\n        for row in range(rows):\n            if col == cols - 1:\n                dp[row][col] = gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row][col + 1],\n                    gold_map[row][col],\n                )\n\n    for col in range(cols - 1, -1, -1):\n        for row in range(rows - 1, -1, -1):\n            if col == cols - 1:\n                dp[row][col] = max(\n                    gold_map[row][col],\n                    gold_map[row][col] + dp[row + 1][col],\n                )\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row][col + 1],\n                    gold_map[row][col],\n                    gold_map[row][col] + dp[row + 1][col],\n                )\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert get_max_gold([[0, 6, 0, 0], [5, 8, 7, 0], [0, 9, 0, 8]]) == 42"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def gold_mine(arr):\n    m = len(arr)\n    n = len(arr[0])\n    for i in range(1, m):\n        arr[i][0] += arr[i - 1][0]\n    for j in range(1, n):\n        arr[0][j] += arr[0][j - 1]\n    for i in range(1, m):\n        for j in range(1, n):\n            arr[i][j] += max(arr[i - 1][j], arr[i][j - 1])\n    return arr[-1][-1]\n\n\nif __name__ == \"__main__\":\n    arr = [[1, 3, 1], [2, 2, 4], [5, 1, 5]]\n    print(gold_mine(arr))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def gold_mine(gold_map):\n    n = len(gold_map)\n    m = len(gold_map[0])\n\n    # dp[i][j] means the maximum gold amount that can be collected\n    # if we start the process from i-th row and j-th column\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n\n    # start from the last column\n    for j in range(m-1, -1, -1):\n        # start from the last row\n        for i in range(n-1, -1, -1):\n            if i == n-1 and j == m-1:\n                dp[i][j] = gold_map[i][j]\n            else:\n                if i < n-1:\n                    dp[i][j] += dp[i+1][j]\n                if j < m-1:\n                    dp[i][j] += dp[i][j+1]\n                if i < n-1 and j < m-1:\n                    dp[i][j] -= gold_map[i+1][j+1]\n                    dp[i][j] += gold_map[i][j]\n\n                dp[i][j] = max(dp[i][j], 0)\n\n    return dp[0][0]\n\n\ngold_map = [\n    [1, 3, 1, 5],\n    [2, 2, 4, 1],\n    [5, 0, 2, 3],\n    [0, 6, 1, 2]\n]\nprint(gold_mine(gold_map))\n\ngold_map = [\n    [1, 3, 2],\n    [2, 2, 4],\n    [5, 0, 2]\n]\nprint(gold_mine(gold_map))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map can be represented as a 2D array where m is the number of rows and n is the number of columns.\n    Gold Map contains values with the maximum amount of gold that can be collected from that particular cell.\n    Gold Map[i][j] = 0 if there is no gold in that cell.\n    Gold Map[i][j] > 0 if there is gold in that cell.\n    Gold Map[i][j] = value of maximum amount of gold that can be collected from that cell.\n    Gold Map[i][j] = value of maximum amount of gold that can be collected from that cell if we collect gold from\n    that cell and move to the adjacent cells.\n\n    Gold Map is a square matrix.\n    Gold Map is at least 3x3.\n\n    Gold Map doesn't contain negative values.\n\n    Examples:\n    Input:\n    Gold Map:\n        1 0 7 0 0\n        2 0 4 2 2\n        0 0 2 4 0\n        0 6 0 2 4\n        1 0 2 3 1\n\n    Output: 12\n    Gold Map:\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n\n    Input:\n    Gold Map:\n        5 3 0 2 1\n        12 0 4 11 14\n        11 0 2 5 14\n        10 13 14 14 5\n        11 12 9 14 13\n\n    Output: 28\n    Gold Map:\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n        0 0 0 0 0\n\n    @param gold_map:"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def get_optimal_value(gold_mine):\n    \"\"\"\n    :param gold_mine: list of list of integers\n    :return: optimal value\n\n    Find the most amount of gold that can be collected when each move either\n    goes to the next row or to the next column.\n\n    >>> get_optimal_value([[1, 3, 1, 5],\n    ...                    [2, 2, 4, 1],\n    ...                    [5, 0, 2, 3],\n    ...                    [0, 2, 1, 1]])\n    12\n    >>> get_optimal_value([[1, 3, 1, 5],\n    ...                    [2, 2, 4, 1],\n    ...                    [5, 0, 2, 3],\n    ...                    [2, 2, 1, 1]])\n    12\n    \"\"\"\n    rows = len(gold_mine)\n    columns = len(gold_mine[0])\n    for row in range(rows):\n        for column in range(columns):\n            if row == 0 and column == 0:\n                continue\n            elif row == 0:\n                gold_mine[row][column] += gold_mine[row][column - 1]\n            elif column == 0:\n                gold_mine[row][column] += gold_mine[row - 1][column]\n            else:\n                gold_mine[row][column] += max(\n                    gold_mine[row - 1][column], gold_mine[row][column - 1]\n                )\n    return gold_mine[-1][-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Gold Mine Problem\n\n    :param gold_map: 2D array of integers\n    :return: integer\n    \"\"\"\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    @lru_cache(maxsize=None)\n    def dp(i, j):\n        if i == m or j == n:\n            return 0\n\n        left = dp(i, j + 1)\n        top = dp(i + 1, j)\n        return max(left, top) + gold_map[i][j]\n\n    return dp(0, 0)\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 12"
    },
    {
      "rank": 15,
      "score": 9.979837165957507,
      "candidate": "def gold_mine(gold, n):\n    gold_matrix = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            gold_matrix[i][j] = gold[i][j]\n\n    for i in range(1, n):\n        for j in range(n):\n            if j - 1 >= 0:\n                gold_matrix[i][j] = max(gold_matrix[i][j], gold_matrix[i-1][j] + gold_matrix[i][j])\n\n            if j + 1 < n:\n                gold_matrix[i][j] = max(gold_matrix[i][j], gold_matrix[i][j+1] + gold_matrix[i][j])\n\n    return gold_matrix[n-1][0]\n\n\ngold = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\nn = 4\nprint(gold_mine(gold, n))"
    },
    {
      "rank": 16,
      "score": 9.967618480931293,
      "candidate": "def gold_mine(gold_map, n, m):\n    for i in range(1, n):\n        for j in range(1, m):\n            gold_map[i][j] += max(gold_map[i - 1][j - 1], gold_map[i - 1][j], gold_map[i - 1][j + 1])\n    return gold_map[n - 1][m - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[0, 3, 1, 0, 0],\n                [2, 2, 0, 2, 4],\n                [0, 0, 0, 3, 1],\n                [0, 0, 1, 3, 2],\n                [1, 0, 3, 0, 4]]\n    print(gold_mine(gold_map, 5, 5))"
    },
    {
      "rank": 17,
      "score": 9.961285995672068,
      "candidate": "def gold_mine(gold_mine):\n    \"\"\"\n    Gold Mine problem\n    :param gold_mine: 2D matrix representing gold mine\n    :return: max amount of gold that can be collected\n\n    >>> gold_mine = [[0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 2], [2, 0, 2, 2]]\n    >>> gold_mine_2 = [[1, 0, 1, 0], [2, 0, 2, 2], [3, 0, 3, 3], [4, 0, 4, 4]]\n    >>> gold_mine_3 = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]\n    >>> gold_mine_4 = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n    >>> gold_mine_5 = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]\n    >>> gold_mine_6 = [[1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n    >>> gold_mine_7 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]]\n    >>> gold_mine_8 = [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]\n    >>> gold_mine_9 ="
    },
    {
      "rank": 18,
      "score": 9.934441652054229,
      "candidate": "def gold_mine(gold_mine):\n    \"\"\"\n    Gold Mine Problem\n    \"\"\"\n\n    if not gold_mine or not gold_mine[0]:\n        return 0\n\n    rows = len(gold_mine)\n    cols = len(gold_mine[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_mine[row][col]\n            elif row == 0:\n                dp[row][col] = gold_mine[row][col] + dp[row][col - 1]\n            elif col == 0:\n                dp[row][col] = gold_mine[row][col] + dp[row - 1][col]\n            else:\n                dp[row][col] = gold_mine[row][col] + max(\n                    dp[row - 1][col], dp[row][col - 1]\n                )\n\n    return dp[-1][-1]"
    },
    {
      "rank": 19,
      "score": 9.918325750057882,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(1)\n    \"\"\"\n    m, n = len(gold_map), len(gold_map[0])\n\n    for row in range(m):\n        gold_map[row][0] = gold_map[row][0] + gold_map[row - 1][0] if row > 0 else gold_map[row][0]\n\n    for col in range(1, n):\n        gold_map[0][col] = gold_map[0][col] + gold_map[0][col - 1] if col > 0 else gold_map[0][col]\n\n    for row in range(1, m):\n        for col in range(1, n):\n            gold_map[row][col] = max(\n                gold_map[row - 1][col], gold_map[row][col - 1]) + gold_map[row][col]\n\n    return gold_map[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 20,
      "score": 9.915690965235,
      "candidate": "from collections import namedtuple\n\nGoldMine = namedtuple(\"GoldMine\", [\"w\", \"h\", \"gold\"])\n\n\ndef get_max_gold(gold_mine: GoldMine) -> int:\n    \"\"\"\n    >>> get_max_gold(GoldMine(w=3, h=2, gold=[1, 3, 1, 3, 2, 2]))\n    6\n    \"\"\"\n    if gold_mine.w == 0 or gold_mine.h == 0:\n        return 0\n    dp = [0] * gold_mine.w\n    for i in range(gold_mine.h):\n        for j in range(gold_mine.w):\n            if i == 0:\n                dp[j] = gold_mine.gold[i * gold_mine.w + j]\n            else:\n                dp[j] = max(\n                    dp[j],\n                    gold_mine.gold[i * gold_mine.w + j] + dp[max(j - 1, 0)],\n                )\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.871021144131259,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map is a 2D matrix of size m * n. Each cell in this map represents cost to reach that cell.\n    Starting from the top left corner (row 0, column 0), how much gold can be collected from this map?\n\n    Gold Map can be of any size.\n    Gold Map doesn't have 0's on the border.\n    Gold Map doesn't have 0's in the corner.\n\n    Example:\n    >>> gold_mine([[1, 3, 1, 1], [2, 2, 4, 2], [0, 0, 2, 4], [1, 0, 2, 0]])\n    12\n    \"\"\"\n    if not gold_map:\n        raise ValueError(\"Gold Map is empty.\")\n    m, n = len(gold_map), len(gold_map[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_map[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_map[i][j]\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.85166714294523,
      "candidate": "def get_max_gold(gold_map):\n    \"\"\"\n    Gold Map will be a 2D matrix of m * n size.\n    Each cell in gold_map will contain either -1, 0 or an\n    integer > 0.\n\n    Gold Map will represent the gold in cells with positive\n    integer value.\n\n    Value 0 in gold map represents a cell from which\n    gold cannot be collected.\n\n    -1 in gold map represents a cell from which\n    gold cannot be collected, but you can jump to\n    another cell with more gold.\n\n    You are allowed to move to exactly one cell with\n    more gold (or same amount of gold).\n\n    You have to return the path, in which you collect\n    maximum amount of gold. You can either start\n    from the top row or from the leftmost column.\n\n    You cannot visit any cell more than once.\n\n    You can assume that you can reach the bottom right\n    corner of the grid.\n\n    >>> get_max_gold([[1, 0, 7], [2, -1, 3], [0, 3, 6]])\n    [[0, 0], [1, 2]]\n    >>> get_max_gold([[1, 3, 3, 3, 3], [3, -1, -1, 3, 3], [3, -1, -1, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]])\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.810461839914332,
      "candidate": "def gold_mine(gold_map):\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    for i in range(1, m):\n        gold_map[i][0] += gold_map[i - 1][0]\n\n    for j in range(1, n):\n        gold_map[0][j] += gold_map[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold_map[i][j] += max(gold_map[i - 1][j], gold_map[i][j - 1])\n\n    return gold_map[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 12\n\n    gold_map = [\n        [1, 3, 15, 3, 2],\n        [2, 10, 11, 12, 1],\n        [11, 12, 14, 16, 5],\n        [7, 18, 13, 17, 4],\n        [5, 4, 2, 1, 11]\n    ]\n    assert gold_mine(gold_map) == 51"
    },
    {
      "rank": 24,
      "score": 9.765019093497662,
      "candidate": "def gold_mine(gold_map):\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols):\n            if row == rows - 1:\n                dp[row][col] = gold_map[row][col]\n            else:\n                dp[row][col] = max(dp[row + 1][col], gold_map[row][col])\n\n            if col == 0:\n                dp[row][col] += dp[row][col + 1]\n            elif col == cols - 1:\n                dp[row][col] += dp[row][col - 1]\n            else:\n                dp[row][col] += max(dp[row][col + 1], dp[row][col - 1])\n\n    return dp[0][0]\n\n\nif __name__ == '__main__':\n    assert gold_mine([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 25,
      "score": 9.665062145257412,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    >>> gold_mine([[0, 6, 0, 0], [5, 8, 7, 0], [0, 9, 0, 8], [2, 0, 3, 4]])\n    (24, (1, 1))\n    \"\"\"\n    m, n = len(gold_map), len(gold_map[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = gold_map[i][j]\n            elif i == m - 1:\n                dp[i][j] = gold_map[i][j] + dp[i][j + 1]\n            elif j == n - 1:\n                dp[i][j] = gold_map[i][j] + dp[i + 1][j]\n            else:\n                dp[i][j] = gold_map[i][j] + max(\n                    dp[i + 1][j],\n                    dp[i][j + 1],\n                )\n    return max(dp[0]), (m - 1, n - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 9.658163778008113,
      "candidate": "def gold_mine(arr):\n    m, n = len(arr), len(arr[0])\n\n    for i in range(1, m):\n        arr[i][0] += arr[i - 1][0]\n    for j in range(1, n):\n        arr[0][j] += arr[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            arr[i][j] += max(arr[i - 1][j], arr[i][j - 1])\n    return arr[-1][-1]\n\n\nif __name__ == \"__main__\":\n    arr = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    print(gold_mine(arr))"
    },
    {
      "rank": 27,
      "score": 9.464281531495816,
      "candidate": "def get_max_gold(gold_map):\n    \"\"\"\n    :param gold_map: 2D list of integers\n    :return: Integer\n    \"\"\"\n    # Write your code here\n    m, n = len(gold_map), len(gold_map[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[m - 1][n - 1] = gold_map[m - 1][n - 1]\n\n    for i in range(m - 2, -1, -1):\n        dp[i][n - 1] = max(dp[i + 1][n - 1], gold_map[i][n - 1])\n\n    for i in range(n - 2, -1, -1):\n        dp[m - 1][i] = max(dp[m - 1][i + 1], gold_map[m - 1][i])\n\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 2, -1, -1):\n            dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]) + gold_map[i][j]\n\n    return dp[0][0]\n\n\ngold_map = [\n    [18, 32, 17, 27, 24, 31],\n    [39, 12, 14, 22, 28, 29],\n    [20, 35, 19, 10, 16, 33],\n    [21, 23, 34, 1, 18, 15],\n    [11, 2, 6, 9, 13, 36],\n    [25, 38, 26, 4, 5, 37],\n]\nprint(get_max_gold(gold_map))"
    },
    {
      "rank": 28,
      "score": 9.451292365313662,
      "candidate": "def gold_mine(arr, m, n):\n    for i in range(1, m):\n        arr[i][0] += arr[i - 1][0]\n\n    for i in range(1, n):\n        arr[0][i] += arr[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            arr[i][j] += max(arr[i - 1][j], arr[i][j - 1])\n\n    return arr[-1][-1]\n\n\nif __name__ == \"__main__\":\n    arr = [[1, 3, 1, 5],\n           [2, 2, 4, 1],\n           [5, 0, 2, 3],\n           [0, 6, 1, 2]]\n    m = len(arr)\n    n = len(arr[0])\n    print(gold_mine(arr, m, n))"
    },
    {
      "rank": 29,
      "score": 8.444444444444445,
      "candidate": "def gold_mine(gold, m, n):\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = gold[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold[i][j]\n\n    return dp[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    print(gold_mine([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1]], 4, 3))"
    },
    {
      "rank": 30,
      "score": 8.444444444444445,
      "candidate": "from collections import namedtuple\n\nGold = namedtuple(\"Gold\", ['value', 'weight'])\n\n\ndef get_max_value(capacity, weights):\n    \"\"\"\n    :param capacity: capacity of knapsack\n    :param weights: list of Gold namedtuples\n    :return: max profit\n    \"\"\"\n    if not weights:\n        return 0\n\n    # dp[i][w] stores the max profit with capacity w and first i items\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(len(weights) + 1)]\n\n    for i in range(len(weights) + 1):\n        for w in range(capacity + 1):\n            if i == 0 or w == 0:\n                dp[i][w] = 0\n            elif weights[i - 1].weight > w:\n                # exclude the item\n                dp[i][w] = dp[i - 1][w]\n            else:\n                # include the item\n                dp[i][w] = max(\n                    dp[i - 1][w],\n                    weights[i - 1].value + dp[i - 1][w - weights[i - 1].weight]\n                )\n\n    return dp[-1][-1]\n\n\nif __name__ == '__main__':\n    weights = [\n        Gold(3, 2),\n        Gold(2, 4),\n        Gold(4, 3),\n        Gold(6, 5),\n        Gold(10, 7),\n        Gold(14, 6),\n        Gold(17, 4),\n        Gold(20, 9),\n        Gold(21, 10),\n    ]\n    assert get_max_value(30, weights) == 67"
    },
    {
      "rank": 31,
      "score": 8.444444444444445,
      "candidate": "from collections import namedtuple\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Gold Mine Problem\n    https://www.geeksforgeeks.org/minimum-cost-to-collect-all-gold-coins-in-a-given-grid/\n\n    Gold Mine Problem is a problem where you are given a 2D grid of size m\u00d7n,\n    each cell of which contains a positive integer which is the amount of gold in that cell.\n    You start at the top-left corner of the grid and are trying to reach the bottom-right corner.\n    You can only move either left, right, up or down. You can pick up any positive integer amount of gold,\n    but you can\u2019t move into a cell until you have picked up the gold in that cell.\n    In how many ways can you collect maximum of gold?\n\n    Time Complexity: O(m\u00d7n)\n    Space Complexity: O(m\u00d7n)\n    \"\"\"\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    # dp[i][j] is the maximum gold collected from the cell (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    # We can reach the source cell (0, 0) with 1 way\n    dp[0][0] = gold_map[0][0]\n\n    # Fill the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + gold_map[i][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + gold_map[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            # We can take maximum of two cells: (i - 1, j) or (i, j - 1)\n            dp[i][j] = max(dp[i - 1][j] + gold_map[i][j], dp[i][j -"
    },
    {
      "rank": 32,
      "score": 8.444444444444445,
      "candidate": "def get_max_gold(gold_map: list[list[int]]) -> int:\n    \"\"\"\n    Gold Map:\n    0 - Empty space\n    1 - Impassable rock\n    2 - Has gold\n\n    Gold Map example:\n    [\n        [0, 0, 0],\n        [0, 2, 0],\n        [0, 0, 0]\n    ]\n\n    Time Complexity: O(rows * cols)\n    Space Complexity: O(rows * cols)\n    \"\"\"\n\n    def get_neighbours(\n        row: int, col: int, rows: int, cols: int, gold_map: list[list[int]]\n    ) -> list[tuple[int, int]]:\n        \"\"\"\n        Get all the neighbours in the 8 directions (not including diagonals)\n        of a given cell in the gold_map.\n\n        Return a list of tuples with the row and col of the neighbour cell.\n        \"\"\"\n        neighbours = []\n\n        # Add top cell\n        if row > 0 and gold_map[row - 1][col] == 2:\n            neighbours.append((row - 1, col))\n\n        # Add bottom cell\n        if row < rows - 1 and gold_map[row + 1][col] == 2:\n            neighbours.append((row + 1, col))\n\n        # Add left cell\n        if col > 0 and gold_map[row][col - 1] == 2:\n            neighbours.append((row, col - 1))\n\n        # Add right cell\n        if col < cols - 1 and gold_map[row][col + 1] == 2:\n            neighbours.append((row, col + 1))\n\n        return neighbours\n\n    def gold_dfs(\n        row: int, col: int, rows: int, cols: int, gold_map: list[list[int]]\n    ) -> int:\n        \"\"\"\n        Gold DFS:\n        Go through every cell in the gold_map.\n        If the current cell has gold:\n            - Add gold value to the total.\n            -"
    },
    {
      "rank": 33,
      "score": 8.444444444444445,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    gold_map is a 2d array of size m * n.\n    m is the number of rows and n is the number of columns.\n    Gold_map[i][j] contains the amount of gold in that field.\n    \"\"\"\n    if not gold_map:\n        return 0\n\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    for i in range(1, m):\n        gold_map[i][0] += gold_map[i - 1][0]\n\n    for j in range(1, n):\n        gold_map[0][j] += gold_map[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold_map[i][j] += max(gold_map[i - 1][j], gold_map[i][j - 1])\n\n    return gold_map[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n    print(gold_mine(gold_map))"
    },
    {
      "rank": 34,
      "score": 8.444444444444445,
      "candidate": "from heapq import heappop, heappush\nfrom typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem\n    https://www.geeksforgeeks.org/minimum-cost-to-collect-all-gold-coins-in-a-given-grid/\n\n    Gold Map:\n    -1 represents wall\n    0 represents empty cell\n    > 0 represents gold coin\n\n    Gold Map:\n    -1 0 -1 0\n    0 -1 0 -1\n    0 -1 0 -1\n    0 -1 0 -1\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 -1 0 -1\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 -1 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 -1 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 -1 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 0 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 0 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 0 0\n\n    Gold Map:\n    0 -1 0 -1\n    -1 0 -1 0\n    0 -1 0 -1\n    0 0 0 0\n\n    Gold Map:\n    0 -1 0"
    },
    {
      "rank": 35,
      "score": 8.444444444444445,
      "candidate": "from collections import deque\n\ndef get_max_gold(mine):\n    \"\"\"\n    :param mine: 2D matrix of size M * N\n    :return: Integer\n    \"\"\"\n    if not mine:\n        return 0\n\n    M, N = len(mine), len(mine[0])\n    dp = [[0] * N for _ in range(M)]\n    max_gold = 0\n    for i in range(M - 1, -1, -1):\n        for j in range(N):\n            if i == M - 1:\n                dp[i][j] = mine[i][j]\n            elif j == 0:\n                dp[i][j] = mine[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])\n            elif j == N - 1:\n                dp[i][j] = mine[i][j] + min(dp[i + 1][j - 1], dp[i + 1][j])\n            else:\n                dp[i][j] = mine[i][j] + min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1])\n\n            max_gold = max(max_gold, dp[i][j])\n\n    return max_gold\n\n\ndef main():\n    mine = [[1, 3, 1, 5],\n            [2, 2, 4, 1],\n            [5, 0, 2, 3],\n            [0, 6, 1, 2]]\n    print(\"Maximum Gold: \" + str(get_max_gold(mine)))\n\n\nmain()"
    },
    {
      "rank": 36,
      "score": 3.926139092254469,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + gold_map[i][j]\n    \"\"\"\n    if not gold_map:\n        return 0\n    m, n = len(gold_map), len(gold_map[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_map[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_map[i][j]\n    return dp[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1, 1], [2, 2, 4, 4], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 37,
      "score": 3.782321827907003,
      "candidate": "from collections import defaultdict\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Let's assume that the gold_map is m * n.\n    We can define a state as (x, y, k), where x, y are the coordinates\n    in the gold_map and k is the amount of gold collected so far.\n    We can define the transition function as:\n        (x, y, k) -> (x+1, y, k+gold_map[x][y]) if x < m and y < n\n        (x, y, k) -> (x, y+1, k+gold_map[x][y]) if x < m and y < n\n        (x, y, k) -> (x, y, k) otherwise\n    \"\"\"\n    m = len(gold_map)\n    n = len(gold_map[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    gold_collected = [[0 for _ in range(n)] for _ in range(m)]\n\n    gold_collected[m - 1][n - 1] = gold_map[m - 1][n - 1]\n    visited[m - 1][n - 1] = True\n\n    queue = [(m - 1, n - 1, 0)]\n    while queue:\n        x, y, k = queue.pop(0)\n        for dx, dy in [(x - 1, y), (x, y - 1)]:\n            if 0 <= dx < m and 0 <= dy < n and not visited[dx][dy]:\n                visited[dx][dy] = True\n                gold_collected[dx][dy] = k + gold_map[dx][dy]\n                queue.append((dx, dy, k + gold_map[dx][dy]))\n\n    return gold_collected\n\n\nif __name__ == '__main__':\n    gold_map = [[1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 2, 3],\n                [0, 6, 1"
    },
    {
      "rank": 38,
      "score": 3.738947022370758,
      "candidate": "from typing import List\n\n\ndef get_optimal_value(gold_mines: List[List[int]]) -> int:\n    \"\"\"\n    Gold mines problem.\n\n    :param gold_mines: List of lists with gold mines and their values\n    :return: Max value that can be collected\n    \"\"\"\n    rows = len(gold_mines)\n    cols = len(gold_mines[0])\n    # dp[i][j] will store the max value that can be collected from that cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # If the cell is at the right most or bottom most, the value collected from\n    # that cell is just the value of that cell\n    for i in range(rows):\n        for j in range(cols):\n            if i == rows - 1:\n                dp[i][j] = gold_mines[i][j]\n            elif j == cols - 1:\n                dp[i][j] = gold_mines[i][j]\n            else:\n                # Collect the max value from either right or bottom\n                dp[i][j] = max(\n                    gold_mines[i][j] + min(dp[i + 1][j], dp[i][j + 1]),\n                    gold_mines[i][j],\n                )\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert (\n        get_optimal_value(\n            [\n                [1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 2, 3],\n                [0, 6, 1, 2],\n            ]\n        )\n        == 12\n    )"
    },
    {
      "rank": 39,
      "score": 3.5154997612479755,
      "candidate": "def find_max_gold(gold_map):\n    \"\"\"\n    :param gold_map: a matrix with gold values\n    :return: the maximum gold value\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    max_gold = -1\n    for row in range(rows):\n        for col in range(cols):\n            if gold_map[row][col] == 0:\n                continue\n            # go right\n            max_gold_right = find_max_gold_util(gold_map, row, col + 1, rows, cols)\n            # go left\n            max_gold_left = find_max_gold_util(gold_map, row, col - 1, rows, cols)\n            # go up\n            max_gold_up = find_max_gold_util(gold_map, row - 1, col, rows, cols)\n            # go down\n            max_gold_down = find_max_gold_util(gold_map, row + 1, col, rows, cols)\n            max_gold = max(max_gold, max_gold_right, max_gold_left, max_gold_up, max_gold_down)\n    return max_gold\n\n\ndef find_max_gold_util(gold_map, row, col, rows, cols):\n    \"\"\"\n    :param gold_map: a matrix with gold values\n    :param row: the row index of the current gold\n    :param col: the col index of the current gold\n    :param rows: the number of rows of the matrix\n    :param cols: the number of columns of the matrix\n    :return: the maximum gold value\n    \"\"\"\n    if row < 0 or row >= rows or col < 0 or col >= cols or gold_map[row][col] == 0:\n        return 0\n    gold_map[row][col] = 0\n    # go right\n    max_gold_right = find_max_gold_util(gold_map, row, col + 1, rows, cols"
    },
    {
      "rank": 40,
      "score": 3.501766448946012,
      "candidate": "from typing import List\n\n\ndef get_optimal_value(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map is a matrix where each cell contains amount of gold in that cell.\n    There is a path from top left to bottom right.\n    Find the maximum amount of gold you can collect when you move through the path.\n    You can move only to right or down.\n    \"\"\"\n\n    rows = len(gold_map)\n    columns = len(gold_map[0])\n\n    for row in range(1, rows):\n        for column in range(1, columns):\n            gold_map[row][column] += max(\n                gold_map[row - 1][column], gold_map[row][column - 1]\n            )\n\n    return gold_map[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert get_optimal_value([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 41,
      "score": 3.4877725635611796,
      "candidate": "def gold_mine(gold_map):\n    for row in range(len(gold_map)):\n        for col in range(len(gold_map[0])):\n            if row == 0:\n                if col == 0:\n                    gold_map[row][col] += gold_map[row][col + 1] + gold_map[row + 1][col]\n                elif col == len(gold_map[0]) - 1:\n                    gold_map[row][col] += gold_map[row][col - 1] + gold_map[row + 1][col]\n                else:\n                    gold_map[row][col] += gold_map[row][col - 1] + gold_map[row + 1][col]\n                    gold_map[row][col] += gold_map[row][col + 1] + gold_map[row + 1][col]\n            elif row == len(gold_map) - 1:\n                if col == 0:\n                    gold_map[row][col] += gold_map[row][col + 1] + gold_map[row - 1][col]\n                elif col == len(gold_map[0]) - 1:\n                    gold_map[row][col] += gold_map[row][col - 1] + gold_map[row - 1][col]\n                else:\n                    gold_map[row][col] += gold_map[row][col - 1] + gold_map[row][col + 1]\n                    gold_map[row][col] += gold_map[row - 1][col] + gold_map[row - 1][col]\n            else:\n                if col == 0:\n                    gold_map[row][col] += gold_map[row][col + 1] + gold_map[row - 1][col] + gold_map[row + 1][col]\n                elif col == len(gold_map[0]) - 1:\n                    gold_map[row][col] += gold_map[row][col - 1] + gold_map["
    },
    {
      "rank": 42,
      "score": 3.4843224952664444,
      "candidate": "from collections import defaultdict\n\n\ndef gold_mine(g):\n    \"\"\"\n    Gold Mine Problem\n    \"\"\"\n    m = len(g)\n    n = len(g[0])\n    dp = defaultdict(lambda: float(\"-inf\"))\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if i == n - 1:\n                dp[i, j] = g[j][i]\n            else:\n                dp[i, j] = max(dp[i + 1, j], dp[i + 1, j - 1]) + g[j][i]\n    return dp[0, m - 1]\n\n\nif __name__ == \"__main__\":\n    g = [[1, 3, 1, 5],\n         [2, 2, 4, 1],\n         [5, 0, 2, 3],\n         [0, 6, 1, 2]]\n    assert gold_mine(g) == 12"
    },
    {
      "rank": 43,
      "score": 3.4656400595580994,
      "candidate": "from collections import defaultdict\n\ndef get_min_cost(cost, m, n):\n    \"\"\"\n    :param cost: 2d array of integers\n    :param m: number of rows in cost\n    :param n: number of columns in cost\n    :return: an integer\n    \"\"\"\n    # Write your code here\n    dp = defaultdict(lambda: float('inf'))\n    dp[0,0] = cost[0][0]\n    for i in range(1, n+1):\n        dp[0,i] = dp[0,i-1] + cost[0][i]\n    for i in range(1, m+1):\n        dp[i,0] = dp[i-1,0] + cost[i][0]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i,j] = min(dp[i-1,j], dp[i,j-1]) + cost[i][j]\n    return dp[m, n]\n\ndef test_get_min_cost():\n    assert get_min_cost([[5, 3, 2], [4, 1, 2], [2, 2, 1]], 2, 2) == 9\n    assert get_min_cost([[1, 3, 1], [2, 2, 4], [5, 1, 1]], 2, 3) == 14\n\nif __name__ == '__main__':\n    test_get_min_cost()"
    },
    {
      "rank": 44,
      "score": 3.4112724560515946,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    Gold mine problem.\n    \"\"\"\n    m, n = len(gold_map), len(gold_map[0])\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            if i == m - 1:\n                gold_map[i][j] += 0\n            else:\n                gold_map[i][j] += max(\n                    gold_map[i + 1][j - 1] if j - 1 >= 0 else 0,\n                    gold_map[i + 1][j]\n                )\n    return gold_map[0][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    print(gold_mine(gold_map))"
    },
    {
      "rank": 45,
      "score": 3.3837173645764542,
      "candidate": "def gold_mine(gold, m, n):\n    for i in range(1, m):\n        gold[i][0] += gold[i - 1][0]\n\n    for i in range(1, n):\n        gold[0][i] += gold[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold[i][j] += max(gold[i - 1][j], gold[i][j - 1])\n\n    return gold[m - 1][n - 1]\n\n\ngold = [[0, 0, 0, 0, 0],\n        [0, 0, 6, 5, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 2, 0],\n        [0, 0, 0, 0, 0]]\n\nm, n = 5, 5\n\nprint(gold_mine(gold, m, n))"
    },
    {
      "rank": 46,
      "score": 3.3692332899977053,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not gold_map:\n        return 0\n\n    m: int = len(gold_map)\n    n: int = len(gold_map[0])\n\n    dp: List[List[int]] = [[0] * n for _ in range(m)]\n    dp[0][0] = gold_map[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + gold_map[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + gold_map[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_map[i][j]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert get_max_gold([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 47,
      "score": 3.305838144420434,
      "candidate": "from collections import deque\n\ndef get_min_steps(gold_map, m, n):\n    \"\"\"\n    :param gold_map: 2D array where each cell contains an integer representing the maximum amount of gold that cell can hold\n    :param m: integer representing number of rows in gold_map\n    :param n: integer representing number of columns in gold_map\n    :return: integer representing minimum number of steps required to collect all the gold\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n\n    queue = deque()\n    queue.append((0, 0, 0))\n\n    visited = set()\n\n    while queue:\n        x, y, steps = queue.popleft()\n\n        if (x, y) in visited:\n            continue\n\n        visited.add((x, y))\n\n        if x == m - 1 and y == n - 1:\n            return steps\n\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if 0 <= i < m and 0 <= j < n and (i, j) not in visited:\n                    if gold_map[i][j] > 0:\n                        queue.append((i, j, steps + 1))\n                        gold_map[i][j] = 0\n\n    return -1\n\nif __name__ == \"__main__\":\n\n    gold_map = [[1, 3, 1, 1],\n                [2, 2, 1, 2],\n                [0, 0, 0, 4],\n                [1, 0, 2, 2]]\n\n    m = 4\n    n = 4\n\n    print(get_min_steps(gold_map, m, n))"
    },
    {
      "rank": 48,
      "score": 3.2712800217929825,
      "candidate": "def get_max_gold(gold_map):\n    \"\"\"\n    :param gold_map: matrix containing gold in each cell\n    :return: maximum amount of gold\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows - 1, -1, -1):\n        for j in range(cols):\n            if i == rows - 1:\n                dp[i][j] = gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = max(dp[i + 1][j], gold_map[i][j])\n            elif j == cols - 1:\n                dp[i][j] = max(dp[i + 1][j - 1], gold_map[i][j])\n            else:\n                dp[i][j] = max(dp[i + 1][j - 1], dp[i + 1][j], gold_map[i][j])\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 6, 6],\n                [0, 6, 7, 8]]\n    assert get_max_gold(gold_map) == 24"
    },
    {
      "rank": 49,
      "score": 3.256633716556678,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    Gold mine problem.\n\n    :param gold_map: list of strings representing gold mine.\n    :return: max amount of gold that can be collected.\n    \"\"\"\n    if not gold_map:\n        return 0\n    m = len(gold_map)\n    n = len(gold_map[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = gold_map[i][j]\n            elif i == m - 1:\n                dp[i][j] = gold_map[i][j] + dp[i][j + 1]\n            elif j == n - 1:\n                dp[i][j] = gold_map[i][j] + dp[i + 1][j]\n            else:\n                dp[i][j] = gold_map[i][j] + max(dp[i + 1][j], dp[i][j + 1])\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        \"GSGG\",\n        \"GGGG\",\n        \"GGSG\",\n    ]\n    assert gold_mine(gold_map) == 7"
    },
    {
      "rank": 50,
      "score": 3.2483570765056164,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Return max gold that can be collected.\n    \"\"\"\n    if not gold_map:\n        return 0\n\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    # dp[i][j] is max gold that can be collected from (i, j) to (n - 1, m - 1)\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_map[row][col]\n            elif row == 0:\n                dp[row][col] = dp[row][col - 1] + gold_map[row][col]\n            elif col == 0:\n                dp[row][col] = dp[row - 1][col] + gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    dp[row - 1][col], dp[row][col - 1]) + gold_map[row][col]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1]]) == 12\n    assert gold_mine([[5, 3, 7, 2], [2, 1, 0, 0]]) == 12"
    },
    {
      "rank": 51,
      "score": 3.1878490091728358,
      "candidate": "def gold_mine(gold_mine):\n    n = len(gold_mine)\n    m = len(gold_mine[0])\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                gold_mine[i][j] += 0\n            if i > 0:\n                gold_mine[i][j] += gold_mine[i-1][j]\n            if j > 0:\n                gold_mine[i][j] += gold_mine[i][j-1]\n            if i > 0 and j > 0:\n                gold_mine[i][j] -= gold_mine[i-1][j-1]\n    return gold_mine[n-1][m-1]\n\n\nif __name__ == \"__main__\":\n    gold_mine_matrix = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_mine_matrix) == 12"
    },
    {
      "rank": 52,
      "score": 3.180818012523817,
      "candidate": "def gold_mine(gold_mine):\n    \"\"\"\n    Gold Mine Problem\n    :param gold_mine: 2d matrix\n    :return: maximum gold you can collect\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    rows = len(gold_mine)\n    cols = len(gold_mine[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_mine[row][col]\n            elif row == 0:\n                dp[row][col] = gold_mine[row][col] + dp[row][col - 1]\n            elif col == 0:\n                dp[row][col] = gold_mine[row][col] + dp[row - 1][col]\n            else:\n                dp[row][col] = gold_mine[row][col] + max(\n                    dp[row - 1][col], dp[row][col - 1])\n\n    return dp[rows - 1][cols - 1]\n\n\nif __name__ == \"__main__\":\n    gold_mine_matrix = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    print(gold_mine(gold_mine_matrix))"
    },
    {
      "rank": 53,
      "score": 3.180697802754207,
      "candidate": "from collections import deque\n\n\ndef gold_mine(gold_map):\n    if not gold_map:\n        return 0\n\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols):\n            if row == rows - 1:\n                dp[row][col] = gold_map[row][col]\n            elif col == 0:\n                dp[row][col] = dp[row + 1][col] + gold_map[row][col]\n            elif col == cols - 1:\n                dp[row][col] = dp[row + 1][col - 1] + gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    dp[row + 1][col - 1] + gold_map[row][col],\n                    dp[row + 1][col] + gold_map[row][col]\n                )\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1, 5],\n                      [2, 2, 4, 1],\n                      [5, 0, 2, 3],\n                      [0, 6, 1, 2]]) == 12\n    assert gold_mine([[1, 3, 15, 3, 1],\n                      [2, 1, 5, 9, 9],\n                      [1, 3, 1, 1, 9],\n                      [1, 8, 1, 1, 2],\n                      [1, 1, 5, 1, 1]]) == 24"
    },
    {
      "rank": 54,
      "score": 3.178556285755873,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map is a 2D array of size m * n. Each cell in this map has an integer value.\n    You need to get maximum amount of gold you can collect under the following conditions:\n\n    - Starting point is top-left corner\n    - Ending point is bottom-right corner\n    - Movements can only be either left -> right or up -> down\n\n    >>> get_max_gold([[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]])\n    28\n    >>> get_max_gold([[0, 0, 1], [2, 0, 0], [0, 0, 1], [2, 0, 0], [0, 0, 1]])\n    2\n    >>> get_max_gold([[0, 6, 0], [5, 8, 7], [0, 9, 0]])\n    9\n    \"\"\"\n    # Gold Map is a 2D array of size m * n. Each cell in this map has an integer value.\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    # Starting point is top-left corner\n    # Ending point is bottom-right corner\n    # Movements can only be either left -> right or up -> down\n\n    # 1. For every cell, calculate maximum gold collected if we include that cell\n    # 2. Return maximum of all such collected gold\n\n    # dp[i][j] contains maximum gold collected if we include cell gold_map[i][j]\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # Since starting cell is top-left corner, i = 0 and j = 0\n    dp[0][0] = gold_map[0][0]\n\n    # Fill dp[i][0..n-1] in bottom to top order"
    },
    {
      "rank": 55,
      "score": 3.1718091447842305,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_mine: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem can be solved using dp.\n    Time Complexity: O(n*m)\n    Space Complexity: O(m)\n    \"\"\"\n    if not gold_mine:\n        return 0\n\n    rows, cols = len(gold_mine), len(gold_mine[0])\n\n    dp = [0] * cols\n\n    for col in range(cols - 1, -1, -1):\n        for row in range(rows):\n            if row == 0:\n                dp[col] = gold_mine[row][col]\n            else:\n                dp[col] = max(\n                    dp[col],\n                    gold_mine[row][col] + dp[col - 1] if col - 1 >= 0 else 0,\n                )\n    return dp[cols - 1]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [\n                [1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 2, 3],\n                [0, 6, 1, 2],\n            ]\n        )\n        == 12\n    )"
    },
    {
      "rank": 56,
      "score": 3.1620419846973977,
      "candidate": "from collections import namedtuple\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Gold Mine Problem\n    Finds maximum amount of gold that can be collected\n    when moving left, right, up and down\n    \"\"\"\n\n    Gold = namedtuple(\"Gold\", \"x y amount\")\n\n    # find the longest row or column\n    max_gold = max(gold_map)\n\n    # initialize a table to store intermediate results\n    # we need a table of size (m+2)x(n+2)\n    dp_table = [[0] * (len(gold_map[0]) + 2)\n                for _ in range(len(gold_map) + 2)]\n\n    # fill dp_table in bottom up manner\n    for row in range(len(gold_map) - 1, -1, -1):\n        for col in range(len(gold_map[0]) - 1, -1, -1):\n            # check if it is a valid position\n            if gold_map[row][col] == 0:\n                continue\n\n            # find maximum amount on all the 4 directions\n            dp_table[row][col] = max(\n                dp_table[row + 1][col] if row + 1 < len(gold_map) else 0,\n                dp_table[row][col + 1] if col + 1 < len(gold_map[0]) else 0,\n                dp_table[row][col + 2] if col + 2 < len(gold_map[0]) else 0,\n                dp_table[row + 2][col] if row + 2 < len(gold_map) else 0\n            ) + gold_map[row][col]\n\n    return dp_table[0][0]\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]], 12),"
    },
    {
      "rank": 57,
      "score": 3.157123666297637,
      "candidate": "def gold_mine(gold, m, n):\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if i == 1 and j == 1:\n                gold[i][j] = gold[i][j]\n            elif i == 1:\n                gold[i][j] = gold[i][j] + gold[i][j-1]\n            elif j == 1:\n                gold[i][j] = gold[i][j] + gold[i-1][j]\n            else:\n                gold[i][j] = gold[i][j] + max(gold[i-1][j], gold[i][j-1])\n    return gold[m][n]\n\n\nif __name__ == \"__main__\":\n    gold = [[1, 3, 1, 5],\n            [2, 2, 4, 1],\n            [5, 0, 2, 3],\n            [0, 6, 1, 2]]\n    m = 3\n    n = 4\n    assert gold_mine(gold, m, n) == 12\n\n    gold = [[1, 3, 1, 5],\n            [2, 2, 4, 1],\n            [5, 0, 2, 3],\n            [0, 6, 1, 2]]\n    m = 3\n    n = 4\n    assert gold_mine(gold, m, n) == 12\n\n    gold = [[0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]]\n    m = 5\n    n = 6\n    assert gold_mine("
    },
    {
      "rank": 58,
      "score": 3.1209811357830173,
      "candidate": "from typing import List\n\n\ndef get_gold_coins(arr: List[int], n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    # dp[i] means max gold coins collected when the position is i\n    dp = [0] * n\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i] = max(dp[i], arr[j] + dp[j])\n\n    return dp[0]\n\n\nif __name__ == \"__main__\":\n    assert get_gold_coins([1, 3, 2], 3) == 4\n    assert get_gold_coins([1, 3, 2, 3, 4, 3], 6) == 12\n    assert get_gold_coins([3, 5, 12, 10, 8, 15, 12, 5, 10], 9) == 40"
    },
    {
      "rank": 59,
      "score": 3.104431797502378,
      "candidate": "from pprint import pprint\n\n\ndef gold_mine(gold_map):\n    n = len(gold_map)\n    m = len(gold_map[0])\n\n    gold_map = [[0] * m for i in range(n)]\n\n    # gold_map[i][j] = max(gold_map[i-1][j], gold_map[i][j-1])\n    for i in range(1, n):\n        for j in range(1, m):\n            gold_map[i][j] = max(gold_map[i-1][j], gold_map[i][j-1])\n\n    return gold_map[n-1][m-1]\n\n\nif __name__ == '__main__':\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n\n    assert 12 == gold_mine(gold_map)"
    },
    {
      "rank": 60,
      "score": 3.085684140594985,
      "candidate": "from typing import List\n\n\ndef get_max_coins(gold_map: List[List[int]], m: int, n: int) -> int:\n    \"\"\"\n    Dynamic Programming.\n    Time Complexity: O(m*n).\n    Space Complexity: O(m*n).\n    \"\"\"\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = gold_map[i][j]\n            elif i == m - 1:\n                dp[i][j] = gold_map[i][j] + dp[i][j + 1]\n            elif j == n - 1:\n                dp[i][j] = gold_map[i][j] + dp[i + 1][j]\n            else:\n                dp[i][j] = gold_map[i][j] + max(dp[i][j + 1], dp[i + 1][j])\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert (\n        get_max_coins(\n            gold_map=[[0, 3, 1, 1], [2, 2, 1, 2], [1, 3, 1, 2], [1, 1, 1, 2]], m=4, n=4\n        )\n        == 9\n    )"
    },
    {
      "rank": 61,
      "score": 3.0485387746740202,
      "candidate": "from collections import defaultdict\n\n\ndef get_min_cost(cost, m, n):\n    \"\"\"\n    :param cost: 2D array of size m*n\n    :param m: number of rows\n    :param n: number of columns\n    :return: minimum cost to collect all gold\n    \"\"\"\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = cost[i][j]\n            elif i == m - 1:\n                dp[i][j] = dp[i][j + 1] + cost[i][j]\n            elif j == n - 1:\n                dp[i][j] = dp[i + 1][j] + cost[i][j]\n            else:\n                dp[i][j] = min(\n                    dp[i + 1][j],\n                    dp[i][j + 1]) + cost[i][j]\n    return dp[0][0]\n\n\ndef get_min_cost_memo(cost, m, n):\n    \"\"\"\n    :param cost: 2D array of size m*n\n    :param m: number of rows\n    :param n: number of columns\n    :return: minimum cost to collect all gold\n    \"\"\"\n    dp = defaultdict(lambda: defaultdict(int))\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = cost[i][j]\n            elif i == m - 1:\n                dp[i][j] = dp[i][j + 1] + cost[i][j]\n            elif j == n - 1:\n                dp[i][j] = dp[i + 1][j] + cost"
    },
    {
      "rank": 62,
      "score": 3.045880388267751,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Mine problem - https://en.wikipedia.org/wiki/Gold_mine_problem\n    Find the max gold collected from given gold_map.\n    Gold map is a grid with gold values in cells.\n\n    :param gold_map: Gold map\n    :return: Max gold collected\n    >>> gold_mine([[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]])\n    28\n    >>> gold_mine([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    0\n    >>> gold_mine([[1, 3, 1], [0, 0, 0], [2, 0, 4]])\n    3\n    >>> gold_mine([[0, 3, 1], [2, 2, 1], [0, 5, 1], [0, 3, 1]])\n    10\n    >>> gold_mine([[0, 3, 1], [2, 0, 1], [0, 5, 1], [0, 3, 1]])\n    7\n    \"\"\"\n    rows, cols = len(gold_map), len(gold_map[0])\n    dp = [[0] * cols for _ in range(rows)]\n    # Bottom-up approach\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            if row == rows - 1 and col == cols - 1:\n                dp[row][col] = gold_map[row][col]\n            elif row == rows - 1:\n                dp[row][col] = gold_map[row][col] + dp[row][col + 1]\n            elif col == cols - 1:\n                dp"
    },
    {
      "rank": 63,
      "score": 3.043523534119086,
      "candidate": "def gold_mine(arr):\n    \"\"\"\n    We have a gold mine of n*m dimensions.\n    Each cell in the mine contains a positive integer which is the amount of gold in that cell.\n    We are allowed to move one gold coin from a cell to any of its 4 adjacent cell.\n    But the movement can't be diagonal.\n    Find the maximum amount of gold that can be collected.\n    \"\"\"\n    if not arr:\n        return 0\n\n    row = len(arr)\n    col = len(arr[0])\n\n    # dp[i][j] contains maximum gold that can be collected from (i, j)\n    dp = [[0 for _ in range(col)] for _ in range(row)]\n\n    # At each cell, we can move to maximum 4 adjacent cells.\n    # So, for each cell, we are going to store 4 values -\n    # the maximum gold that can be collected from each of the 4 adjacent cells.\n    # Since we are only allowed to move gold coin from one cell to any of the 4 adjacent cells,\n    # we can calculate the maximum gold that can be collected from each of the 4 adjacent cells\n    # using dp[i][j] and dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]\n    for i in range(row):\n        for j in range(col):\n            # We can move to left cell.\n            # So, we are going to store the maximum gold that can be collected from the left cell\n            # in the first element of the list.\n            if i - 1 >= 0:\n                dp[i][j].append(arr[i - 1][j] + dp[i - 1][j][0])\n            else:\n                dp[i][j].append(arr[i][j])\n\n            # We can move to top cell.\n            # So, we are going to store the maximum gold that can be collected from the top cell\n            # in the second element of the list.\n            if j - 1 >= 0:\n                dp[i][j].append(arr[i]["
    },
    {
      "rank": 64,
      "score": 3.033764102343962,
      "candidate": "from typing import List\n\n\ndef get_min_cost(cost: List[int], m: int, n: int) -> int:\n    \"\"\"\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = cost[i - 1][j - 1] + min(\n                dp[i - 1][j - 1],\n                dp[i - 1][j],\n                dp[i][j - 1],\n            )\n\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    cost = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2],\n    ]\n    assert get_min_cost(cost, 3, 4) == 7\n\n    cost = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2],\n    ]\n    assert get_min_cost(cost, 4, 4) == 8\n\n    cost = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2],\n    ]\n    assert get_min_cost(cost, 3, 3) == 7"
    },
    {
      "rank": 65,
      "score": 2.993251387631033,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Mine Problem\n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols):\n            if row == rows - 1:\n                dp[row][col] = gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row + 1][col],\n                    dp[row + 1][col],\n                )\n\n    for col in range(cols - 1, -1, -1):\n        for row in range(rows):\n            if col == cols - 1:\n                dp[row][col] = max(\n                    gold_map[row][col],\n                    dp[row][col + 1],\n                )\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row][col + 1],\n                    dp[row][col + 1],\n                )\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1], [2, 2, 4], [5, 1, 5]]) == 12"
    },
    {
      "rank": 66,
      "score": 2.982086980445024,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    This is a Gold Mine problem.\n    We are given a 2D grid of size m * n.\n    Each cell in this grid can have values between 0 and 9 inclusive.\n    Each cell can also be one of three types:\n        - Safe(0)\n        - Treasure(9)\n        - Snake(1)\n\n    We need to start from the top left corner of the map and reach the treasure.\n    We can move to any of the 8 adjacent cells if they don't have a snake and they are not out of bounds.\n    We can move diagonally.\n    We can pick up maximum of two gold at a time.\n    If we reach a cell which has a snake, we lose the gold we have collected from that move.\n    We can also choose not to move at all when there are no safe cells around.\n    The objective is to find the maximum gold we can collect.\n    \"\"\"\n    # Write your code here\n    # create 2d array to keep track of the maximum gold collected from each cell\n    m = len(gold_map)\n    n = len(gold_map[0])\n    dp = [[0] * n for _ in range(m)]\n\n    # initialize the first row and first column\n    for i in range(1, m):\n        for j in range(1, n):\n            # if the cell is safe\n            if gold_map[i][j] == 0:\n                # pick the max of left and top cell and add the current cell\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_map[i][j]\n            # if the cell is not safe\n            else:\n                dp[i][j] = 0\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 0"
    },
    {
      "rank": 67,
      "score": 2.9071705116680913,
      "candidate": "from typing import List\n\n\n# O(n) time | O(n) space\ndef gold_mine(gold_mine_matrix: List[List[int]]) -> int:\n    \"\"\"\n    Gold Mine Problem\n    Gold Mine is a matrix of N * M. In which each cell either has gold or is empty.\n    Gold amount in each cell is between 0 and 100.\n    We are at first cell which is empty. We can move only right or down.\n    Our goal is to reach the last cell with maximum gold amount.\n    \"\"\"\n    if not gold_mine_matrix or not gold_mine_matrix[0]:\n        return 0\n\n    row_count = len(gold_mine_matrix)\n    column_count = len(gold_mine_matrix[0])\n\n    # dp[i][j] means max gold amount at cell i, j\n    dp = [[0 for _ in range(column_count)] for _ in range(row_count)]\n\n    # fill dp table\n    for i in range(row_count):\n        for j in range(column_count):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_mine_matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_mine_matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_mine_matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_mine_matrix[i][j]\n\n    return dp[row_count - 1][column_count - 1]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1]]) == 12\n    ), \"Should be 12\""
    },
    {
      "rank": 68,
      "score": 2.890164056081244,
      "candidate": "def solve_gold_mine(gold_mine):\n    \"\"\"\n    :param gold_mine: list of lists\n    :return: int\n    \"\"\"\n    rows = len(gold_mine)\n    cols = len(gold_mine[0])\n\n    for i in range(1, rows):\n        gold_mine[i][0] += gold_mine[i - 1][0]\n\n    for j in range(1, cols):\n        gold_mine[0][j] += gold_mine[0][j - 1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            gold_mine[i][j] += max(\n                gold_mine[i - 1][j], gold_mine[i][j - 1])\n\n    return gold_mine[rows - 1][cols - 1]\n\n\nif __name__ == '__main__':\n    gold_mine = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n    assert solve_gold_mine(gold_mine) == 16\n\n    gold_mine = [[1, 3, 1, 5, 1], [2, 2, 4, 1, 1], [5, 0, 2, 3, 1], [0, 6, 1, 2, 1]]\n    assert solve_gold_mine(gold_mine) == 18\n\n    gold_mine = [[1, 3, 1, 5, 1], [2, 2, 4, 1, 1], [5, 0, 2, 3, 1], [0, 6, 1, 2, 1], [2, 4, 2, 3, 1]]\n    assert solve_gold_mine(gold_mine) == 20"
    },
    {
      "rank": 69,
      "score": 2.887111849756732,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem.\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    m, n = len(gold_map), len(gold_map[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = gold_map[i][j]\n            elif i == m - 1:\n                dp[i][j] = dp[i][j + 1]\n            elif j == n - 1:\n                dp[i][j] = dp[i + 1][j]\n            else:\n                dp[i][j] = max(\n                    dp[i + 1][j], dp[i][j + 1]) + gold_map[i][j]\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1, 1], [2, 2, 4, 4], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 70,
      "score": 2.882923312638332,
      "candidate": "def gold_mine(gold_map):\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_map[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + gold_map[i][j]\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1]], 12),\n        ([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1], [4, 2, 1]], 16),\n        ([[1, 3, 1], [2, 2, 4], [5, 1, 5], [2, 2, 1], [4, 2, 1], [5, 5, 5]], 18),\n    ]\n\n    for inp, res in test_cases:\n        assert gold_mine(inp) == res, 'Failed'"
    },
    {
      "rank": 71,
      "score": 2.8504963247670663,
      "candidate": "from typing import List\n\n\n# O(n*m)\ndef gold_mine_problem(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem is to find maximum amount of gold that can be collected\n    when a gold miner steps on each cell of the m * n matrix.\n    Each cell has a value denoting the amount of gold in that cell.\n    Gold miner can move to adjacent cells (up, down, left, right)\n    but not to diagonally adjacent cells.\n    \"\"\"\n    m = len(gold_map)\n    n = len(gold_map[0])\n\n    for i in range(1, n):\n        gold_map[0][i] += gold_map[0][i - 1]\n\n    for i in range(1, m):\n        gold_map[i][0] += gold_map[i - 1][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold_map[i][j] += max(\n                gold_map[i - 1][j],\n                gold_map[i][j - 1]\n            )\n\n    return gold_map[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine_problem([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 72,
      "score": 2.8453938120743927,
      "candidate": "def gold_mine(gold_mine_matrix, m, n):\n    \"\"\"\n    :param gold_mine_matrix: 2D array of integers\n    :param m: number of rows\n    :param n: number of columns\n    :return: max gold that you can collect\n    \"\"\"\n\n    # base case\n    if m == 0 or n == 0:\n        return 0\n\n    # initialize dp array\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    # populate first row and first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + gold_mine_matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + gold_mine_matrix[0][j]\n\n    # populate rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + gold_mine_matrix[i][j]\n\n    # return the max gold collected\n    return dp[-1][-1]\n\n\ndef main():\n\n    gold_mine_matrix = [[1, 3, 1, 5],\n                        [2, 2, 4, 1],\n                        [5, 0, 2, 3],\n                        [0, 6, 1, 2]]\n\n    print(gold_mine(gold_mine_matrix, 4, 4))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 73,
      "score": 2.8074588597918417,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]], m: int, n: int) -> int:\n    \"\"\"\n    Gold Map:\n    1 - Empty\n    2 - Obstacle\n    0 - Gold\n    \"\"\"\n\n    def get_max_gold_dp(i, j):\n        if dp[i][j] != float(\"-inf\"):\n            return dp[i][j]\n\n        if i == m - 1 and j == n - 1:\n            return 0\n\n        left = right = top = bottom = float(\"-inf\")\n\n        if i - 1 >= 0:\n            left = get_max_gold_dp(i - 1, j)\n\n        if i + 1 < m:\n            right = get_max_gold_dp(i + 1, j)\n\n        if j - 1 >= 0:\n            top = get_max_gold_dp(i, j - 1)\n\n        if j + 1 < n:\n            bottom = get_max_gold_dp(i, j + 1)\n\n        dp[i][j] = max(\n            gold_map[i][j] + min(left, right, top, bottom),\n            left,\n            right,\n            top,\n            bottom,\n        )\n\n        return dp[i][j]\n\n    dp = [[float(\"-inf\") for _ in range(n)] for _ in range(m)]\n    return get_max_gold_dp(0, 0)\n\n\nif __name__ == \"__main__\":\n    assert (\n        get_max_gold([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]], 4, 4)\n        == 12\n    )\n    assert (\n        get_max_gold([[1, 3, 1, 5], [2, 2, 4, 1], [5,"
    },
    {
      "rank": 74,
      "score": 2.768291153593769,
      "candidate": "from collections import defaultdict\n\n\ndef get_neighbours(row, col, row_count):\n    \"\"\"Get neighbour cells\"\"\"\n    return [\n        (row - 1, col),\n        (row + 1, col),\n        (row, col - 1),\n        (row, col + 1),\n        (row - 1, col - 1),\n        (row - 1, col + 1),\n        (row + 1, col - 1),\n        (row + 1, col + 1),\n    ]\n\n\ndef gold_mine(mine_map, row_count, col_count):\n    # Create an empty dp table\n    dp = defaultdict(lambda: defaultdict(int))\n\n    # If we are in the first row, we can only move down\n    for col in range(col_count):\n        dp[0][col] = mine_map[0][col]\n\n    # If we are in the first column, we can only move right\n    for row in range(1, row_count):\n        dp[row][0] = dp[row - 1][0] + mine_map[row][0]\n\n    # Fill in the dp table\n    for row in range(1, row_count):\n        for col in range(1, col_count):\n            dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + mine_map[row][col]\n\n    return dp[row_count - 1][col_count - 1]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]],\n            4,\n            4,\n        )\n        == 12\n    )\n    assert gold_mine([[1]], 1, 1) == 1\n    assert gold_mine([[1, 3], [2, 2]], 2"
    },
    {
      "rank": 75,
      "score": 2.7671351232148718,
      "candidate": "from typing import List\n\n\ndef get_max_value_of_gold(gold_map: List[List[int]]) -> int:\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    def get_max_value_of_gold_helper(row: int, col: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return 0\n\n        if gold_map[row][col] == -1:\n            return 0\n\n        if dp[row][col] != -1:\n            return dp[row][col]\n\n        dp[row][col] = max(\n            get_max_value_of_gold_helper(row, col + 1),\n            get_max_value_of_gold_helper(row, col - 1),\n            get_max_value_of_gold_helper(row - 1, col),\n            get_max_value_of_gold_helper(row + 1, col),\n        ) + gold_map[row][col]\n\n        return dp[row][col]\n\n    dp = [[-1] * cols for _ in range(rows)]\n    return get_max_value_of_gold_helper(rows - 1, 0)\n\n\nif __name__ == \"__main__\":\n    assert (\n        get_max_value_of_gold(\n            [\n                [1, 3, 1, 1],\n                [2, -1, 3, 4],\n                [5, 3, -1, 3],\n                [1, 3, 1, -1],\n            ]\n        )\n        == 12\n    )\n    assert (\n        get_max_value_of_gold(\n            [\n                [-1, 3, -3],\n                [9, -1, 0],\n                [-2, -1, -2],\n            ]\n        )\n        == 7\n    )"
    },
    {
      "rank": 76,
      "score": 2.765262807032524,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    Gold Mine problem\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    # dp[i][j] = max gold we can collect when we are at row i and col j\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # first row\n    for j in range(cols):\n        dp[0][j] = gold_map[0][j]\n\n    # first col\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + gold_map[i][0]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + gold_map[i][j]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n    assert gold_mine(gold_map) == 12"
    },
    {
      "rank": 77,
      "score": 2.760412881077355,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem.\n    >>> gold_mine([[0, 6, 0, 0], [5, 8, 7, 0], [0, 9, 0, 0]])\n    24\n    >>> gold_mine([[0, 0, 0], [6, 0, 0], [0, 0, 0]])\n    6\n    >>> gold_mine([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9], [9, 9, 9, 9, 0, 0], [9, 9, 9, 9, 0, 0]])\n    9\n    >>> gold_mine([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9], [9, 9, 9, 9, 0, 0], [9, 9, 9, 9, 0, 0]])\n    9\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    # dp[i][j] is max gold we can collect from the cell at (i, j)\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_map["
    },
    {
      "rank": 78,
      "score": 2.749121478207732,
      "candidate": "def get_gold_amount(gold_map):\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in reversed(range(rows)):\n        for col in reversed(range(cols)):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_map[row][col]\n            elif row == 0:\n                dp[row][col] = gold_map[row][col] + dp[row][col - 1]\n            elif col == 0:\n                dp[row][col] = gold_map[row][col] + dp[row - 1][col]\n            else:\n                dp[row][col] = gold_map[row][col] + max(\n                    dp[row - 1][col],\n                    dp[row][col - 1]\n                )\n\n    return dp[-1][-1]\n\n\nif __name__ == '__main__':\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n\n    print(get_gold_amount(gold_map))"
    },
    {
      "rank": 79,
      "score": 2.7408648908631763,
      "candidate": "from collections import defaultdict\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Gold mine problem.\n    \"\"\"\n    if not gold_map:\n        return 0\n\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    # dp[i][j] will store max gold we can collect from (i, j)\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # First row and first column\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = gold_map[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + gold_map[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + gold_map[i][j]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + gold_map[i][j]\n\n    return dp[-1][-1]\n\n\ndef main():\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 12\n\n    gold_map = [\n        [1, 3, 15, 3, 2],\n        [2, 1, 0, 0, 0],\n        [3, 2, 5, 3, 4],\n        [5, 0, 2, 3, 2],\n        [0, 6, 1, 2, 3]\n    ]\n    assert gold_mine(gold_map) == 19\n\n\nif __name__ == '__"
    },
    {
      "rank": 80,
      "score": 2.7278086377374087,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    if not gold_map:\n        return 0\n\n    rows, cols = len(gold_map), len(gold_map[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[0][0] = gold_map[0][0]\n            elif row == 0:\n                dp[0][col] = dp[0][col - 1] + gold_map[0][col]\n            elif col == 0:\n                dp[row][0] = dp[row - 1][0] + gold_map[row][0]\n            else:\n                dp[row][col] = max(\n                    dp[row][col - 1], dp[row - 1][col]\n                ) + gold_map[row][col]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [\n                [1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 2, 3],\n                [0, 6, 1, 2]\n            ]\n        )\n        == 12\n    )"
    },
    {
      "rank": 81,
      "score": 2.718856235379514,
      "candidate": "def get_max_gold(gold_map):\n    # Write your code here\n    n = len(gold_map)\n    m = len(gold_map[0])\n    gold = [[0] * m for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if i == n - 1:\n                gold[i][j] = gold_map[i][j]\n            elif j == 0:\n                gold[i][j] = gold_map[i][j] + gold[i + 1][j]\n            elif j == m - 1:\n                gold[i][j] = gold_map[i][j] + gold[i + 1][j - 1]\n            else:\n                gold[i][j] = gold_map[i][j] + max(gold[i + 1][j], gold[i + 1][j - 1])\n    return gold[0][0]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    gold = get_max_gold(gold_map)\n    print(gold)"
    },
    {
      "rank": 82,
      "score": 2.6996806550405976,
      "candidate": "def get_max_gold(gold_map):\n    def get_gold(i, j):\n        return gold_map[i][j]\n\n    def get_max_gold_from(i, j):\n        if i < 0 or i >= len(gold_map) or j < 0 or j >= len(gold_map[0]):\n            return 0\n\n        if visited[i][j]:\n            return 0\n\n        visited[i][j] = True\n\n        max_gold = get_gold(i, j)\n        max_gold += max(get_max_gold_from(i-1, j), get_max_gold_from(i+1, j), get_max_gold_from(i, j-1), get_max_gold_from(i, j+1))\n\n        visited[i][j] = False\n\n        return max_gold\n\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n\n    max_gold = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            max_gold = max(max_gold, get_max_gold_from(i, j))\n\n    return max_gold\n\n\nif __name__ == '__main__':\n    gold_map = [[1, 3, 1, 5],\n                [2, 2, 4, 1],\n                [5, 0, 6, 6],\n                [0, 6, 7, 8]]\n\n    assert get_max_gold(gold_map) == 28\n\n    gold_map = [[1, 3, 15, 3, 1],\n                [2, 10, 4, 2, 1],\n                [11, 5, 6, 6, 6],\n                [7, 13, 8, 12, 0]]\n\n    assert get"
    },
    {
      "rank": 83,
      "score": 2.6991466938853015,
      "candidate": "def gold_mine(gold_mine):\n    \"\"\"\n    Gold mine problem solution.\n    :param gold_mine: list of lists, representing gold mine.\n    :return: maximum amount of gold that can be collected.\n    \"\"\"\n    for i in range(1, len(gold_mine)):\n        for j in range(len(gold_mine[i])):\n            gold_mine[i][j] += max(\n                gold_mine[i - 1][j - 1] if j - 1 >= 0 else 0,\n                gold_mine[i - 1][j] if j >= 0 else 0,\n                gold_mine[i - 1][j + 1] if j + 1 < len(gold_mine[i]) else 0,\n            )\n    return gold_mine[-1][-1]\n\n\nif __name__ == \"__main__\":\n    gold_mine_ = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2],\n    ]\n    assert gold_mine(gold_mine_) == 12"
    },
    {
      "rank": 84,
      "score": 2.677440122697438,
      "candidate": "def get_max_gold(gold_map):\n    m, n = len(gold_map), len(gold_map[0])\n\n    def dfs(i, j, visited, gold_map):\n        if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or gold_map[i][j] == 0:\n            return 0\n\n        visited.add((i, j))\n\n        up = dfs(i - 1, j, visited, gold_map)\n        down = dfs(i + 1, j, visited, gold_map)\n        left = dfs(i, j - 1, visited, gold_map)\n        right = dfs(i, j + 1, visited, gold_map)\n\n        max_gold = gold_map[i][j] + max(up, down, left, right)\n\n        visited.remove((i, j))\n\n        return max_gold\n\n    max_gold = 0\n\n    for i in range(m):\n        for j in range(n):\n            if gold_map[i][j] != 0:\n                visited = set()\n                local_max = dfs(i, j, visited, gold_map)\n                max_gold = max(local_max, max_gold)\n\n    return max_gold\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 0, 7],\n        [2, 0, 6],\n        [3, 4, 5],\n    ]\n    assert get_max_gold(gold_map) == 12"
    },
    {
      "rank": 85,
      "score": 2.648973453061324,
      "candidate": "from typing import List\n\n\ndef get_max_gold(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Map:\n    -1 - No Gold\n    0 - Empty\n    >= 1 - Amount of Gold\n\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows - 1, -1, -1):\n        for j in range(cols):\n            if i == rows - 1:\n                dp[i][j] = gold_map[i][j]\n            elif gold_map[i][j] != -1:\n                dp[i][j] = max(gold_map[i][j] + dp[i + 1][j], dp[i + 1][j])\n\n    for i in range(rows):\n        for j in range(cols - 1, -1, -1):\n            if i == 0:\n                dp[i][j] = max(gold_map[i][j] + dp[i][j - 1], dp[i][j - 1])\n            elif gold_map[i][j] != -1:\n                dp[i][j] = max(gold_map[i][j] + dp[i][j - 1], dp[i][j - 1], dp[i - 1][j])\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert get_max_gold([[1, 3, 1, 1], [2, -1, 3, 4], [0, 2, 0, 2], [ -1, -2, -3, -2]]) == 12\n    assert get_max_gold([[0, 0, 0, 0], [0, -1, 0, 0"
    },
    {
      "rank": 86,
      "score": 2.6400778958026456,
      "candidate": "def gold_mine(gold, m, n):\n    gold_matrix = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        gold_matrix[i] = list(map(int, gold[i].strip().split()))\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = gold_matrix[i][j]\n            elif i == m - 1:\n                dp[i][j] = gold_matrix[i][j] + dp[i][j + 1]\n            elif j == n - 1:\n                dp[i][j] = gold_matrix[i][j] + dp[i + 1][j]\n            else:\n                dp[i][j] = gold_matrix[i][j] + max(dp[i + 1][j], dp[i][j + 1])\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    gold = [\"5 3 3 2\", \"1 3 3 3\", \"1 3 3 3\", \"1 3 3 2\"]\n    m = 4\n    n = 4\n    print(gold_mine(gold, m, n))"
    },
    {
      "rank": 87,
      "score": 2.5957531985534064,
      "candidate": "def get_min_cost(gold_map, m, n):\n    for i in range(1, m):\n        gold_map[i][0] += gold_map[i - 1][0]\n\n    for j in range(1, n):\n        gold_map[0][j] += gold_map[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold_map[i][j] += min(\n                gold_map[i - 1][j],\n                gold_map[i][j - 1]\n            )\n\n    return gold_map[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    m = len(gold_map)\n    n = len(gold_map[0])\n    print(get_min_cost(gold_map, m, n))"
    },
    {
      "rank": 88,
      "score": 2.5459879622393946,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold Mine Problem\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row == 0 and col == 0:\n                dp[row][col] = gold_map[row][col]\n            elif row == 0:\n                dp[row][col] = gold_map[row][col] + dp[row][col - 1]\n            elif col == 0:\n                dp[row][col] = gold_map[row][col] + dp[row - 1][col]\n            else:\n                dp[row][col] = gold_map[row][col] + max(\n                    dp[row][col - 1], dp[row - 1][col]\n                )\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [\n                [1, 3, 1, 1],\n                [2, 2, 4, 4],\n                [5, 1, 7, 8],\n                [1, 7, 4, 1],\n            ]\n        )\n        == 12\n    )"
    },
    {
      "rank": 89,
      "score": 2.493584439832788,
      "candidate": "def gold_mine(gold_map):\n    \"\"\"\n    Find maximum gold amount that can be collected.\n\n    gold_map: 2D list of integers\n    return: max amount of gold that can be collected (int)\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    if rows <= 0 or cols <= 0:\n        return 0\n\n    # create table to store gold amount\n    gold_table = [[0] * cols for i in range(rows)]\n\n    # fill gold table with maximum amount of gold from each cell\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                gold_table[i][j] = gold_map[i][j]\n            elif i == 0:\n                gold_table[i][j] = gold_table[i][j-1] + gold_map[i][j]\n            elif j == 0:\n                gold_table[i][j] = gold_table[i-1][j] + gold_map[i][j]\n            else:\n                gold_table[i][j] = max(\n                    gold_table[i][j-1] + gold_map[i][j],\n                    gold_table[i-1][j] + gold_map[i][j]\n                )\n\n    return gold_table[rows-1][cols-1]\n\n\nif __name__ == '__main__':\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    print(gold_mine(gold_map))"
    },
    {
      "rank": 90,
      "score": 2.4711445355220496,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    rows, cols = len(gold), len(gold[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows - 1, -1, -1):\n        for j in range(cols - 1, -1, -1):\n            if i == rows - 1 and j == cols - 1:\n                dp[i][j] = gold[i][j]\n            elif i == rows - 1:\n                dp[i][j] = gold[i][j] + dp[i][j + 1]\n            elif j == cols - 1:\n                dp[i][j] = gold[i][j] + dp[i + 1][j]\n            else:\n                dp[i][j] = gold[i][j] + max(dp[i + 1][j], dp[i][j + 1])\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert (\n        gold_mine(\n            [\n                [1, 3, 1, 1],\n                [2, 2, 4, 4],\n                [5, 1, 3, 1],\n                [2, 4, 2, 2],\n            ]\n        )\n        == 12\n    )"
    },
    {
      "rank": 91,
      "score": 2.446832512996986,
      "candidate": "def gold_mine(gold_map):\n    m = len(gold_map)\n    n = len(gold_map[0])\n    for i in range(1, m):\n        gold_map[i][0] += gold_map[i - 1][0]\n    for j in range(1, n):\n        gold_map[0][j] += gold_map[0][j - 1]\n    for i in range(1, m):\n        for j in range(1, n):\n            gold_map[i][j] += max(gold_map[i - 1][j], gold_map[i][j - 1])\n    return gold_map[-1][-1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [\n        [1, 3, 1, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 12\n\n    gold_map = [\n        [1, 3, 15, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 24\n\n    gold_map = [\n        [0, 3, 15, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold_map) == 22\n\n    gold_map = [\n        [0, 3, 15, 5],\n        [2, 2, 4, 1],\n        [5, 0, 2, 3],\n        [0, 6, 1, 2]\n    ]\n    assert gold_mine(gold"
    },
    {
      "rank": 92,
      "score": 2.4245032112888487,
      "candidate": "def gold_mine(gold, m, n):\n    \"\"\"\n    Gold Mine Problem\n    :param gold: 2D array of gold values\n    :param m: number of rows\n    :param n: number of columns\n    :return: max gold\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n\n    for i in range(1, m):\n        gold[i][0] += gold[i - 1][0]\n\n    for j in range(1, n):\n        gold[0][j] += gold[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            gold[i][j] += max(gold[i - 1][j], gold[i][j - 1])\n\n    return gold[m - 1][n - 1]\n\n\nif __name__ == \"__main__\":\n    gold = [[1, 3, 1, 5],\n            [2, 2, 4, 1],\n            [5, 0, 2, 3],\n            [0, 6, 1, 2]]\n    m = len(gold)\n    n = len(gold[0])\n    print(gold_mine(gold, m, n))"
    },
    {
      "rank": 93,
      "score": 2.3359069755507846,
      "candidate": "def get_max_profit(arr, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if arr[i-1][j-1] == 0:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1] + arr[i-1][j-1])\n    return dp[m][n]\n\n\nif __name__ == '__main__':\n    arr = [[1, 3, 7, 9, 9, 10, 12, 17, 20],\n           [3, 4, 6, 8, 10, 12, 15, 18, 20],\n           [1, 5, 11, 12, 18, 20, 23, 30, 34],\n           [2, 6, 9, 13, 19, 25, 30, 36, 40]]\n    m = 4\n    n = 8\n    print(get_max_profit(arr, m, n))"
    },
    {
      "rank": 94,
      "score": 2.293848149332354,
      "candidate": "from functools import lru_cache\n\n\ndef gold_mine(gold_map):\n    \"\"\"\n    Gold Map:\n    [\n      [1, 3, 7, 11],\n      [2, 0, 0, 16],\n      [3, 2, 1,  2],\n      [2, 4, 2,   0]\n    ]\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def dp(i, j):\n        if i == 0 and j == 0:\n            return gold_map[0][0]\n        if i < 0 or j < 0:\n            return float(\"-inf\")\n\n        return max(gold_map[i][j] + dp(i - 1, j - 1),\n                   dp(i - 1, j),\n                   gold_map[i][j] + dp(i, j - 1))\n\n    return dp(len(gold_map) - 1, len(gold_map[0]) - 1)\n\n\nif __name__ == '__main__':\n    gold_map = [\n        [1, 3, 7, 11],\n        [2, 0, 0, 16],\n        [3, 2, 1,  2],\n        [2, 4, 2,   0]\n    ]\n    assert gold_mine(gold_map) == 28"
    },
    {
      "rank": 95,
      "score": 2.287625906893272,
      "candidate": "def gold_mine(gold_map, m, n):\n    for i in range(1, n):\n        for j in range(1, m):\n            gold_map[i][j] += max(gold_map[i - 1][j], gold_map[i][j - 1])\n\n    return gold_map[n - 1][m - 1]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]\n    m = len(gold_map)\n    n = len(gold_map[0])\n    print(gold_mine(gold_map, m, n))"
    },
    {
      "rank": 96,
      "score": 2.260739004816286,
      "candidate": "def get_max_gold(gold_map, m, n):\n    \"\"\"\n    :param gold_map: 2d array\n    :param m: rows\n    :param n: columns\n    :return: max gold\n    \"\"\"\n    gold_map = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            gold_map[i][j] = gold_map[i][j] + gold_map[i - 1][j]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            gold_map[i][j] = gold_map[i][j] + gold_map[i + 1][j]\n\n    for i in range(m):\n        for j in range(n):\n            gold_map[i][j] = gold_map[i][j] - gold_map[i][j - 1]\n\n    for i in range(m):\n        for j in range(n - 1, -1, -1):\n            gold_map[i][j] = gold_map[i][j] - gold_map[i][j + 1]\n\n    return gold_map[0][0]\n\n\nif __name__ == \"__main__\":\n    gold_map = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 6, 0], [0, 6, 7, 8]]\n    print(get_max_gold(gold_map, 4, 4))"
    },
    {
      "rank": 97,
      "score": 2.137541083743484,
      "candidate": "def gold_mine(arr):\n    \"\"\"\n    Gold mine problem:\n    Given a 2D grid of size m * n. Each cell in this grid has a gold value (0, n)\n    which can be collected. A player can move horizontally (right) or vertically (up)\n    to get the gold. In this problem, we aim to get maximum gold amount.\n    \"\"\"\n    m = len(arr)\n    n = len(arr[0])\n    if m == 0 or n == 0:\n        return 0\n\n    # dp[i][j] is the maximum gold amount we can get from cell (i, j)\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    # Initialize the first column\n    for i in range(m):\n        dp[i][0] = arr[i][0]\n\n    # Initialize the first row\n    for j in range(n):\n        dp[0][j] = arr[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            # Get the maximum gold amount from (i - 1, j) and (i, j - 1)\n            left_up = dp[i - 1][j] if i > 0 and j > 0 else 0\n            right_up = dp[i][j - 1] if j > 0 else 0\n\n            # Get the maximum gold amount from (i - 1, j - 1)\n            left_up_left = dp[i - 1][j - 1] if i > 0 and j > 0 else 0\n\n            # Get the maximum gold amount from (i, j)\n            dp[i][j] = max(arr[i][j] + left_up, arr[i][j] + right_up, arr[i][j] + left_up_left)\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    arr = [\n        [1, 3, 1, 5],\n        [2, 2,"
    },
    {
      "rank": 98,
      "score": 2.118479922318633,
      "candidate": "def gold_mine(gold, m, n):\n    for i in range(1, n):\n        for j in range(1, m):\n            gold[i][j] += max(gold[i - 1][j], gold[i][j - 1])\n    return gold[n - 1][m - 1]\n\n\nif __name__ == \"__main__\":\n    gold = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]\n    m = 5\n    n = 7\n    print(gold_mine(gold, m, n))"
    },
    {
      "rank": 99,
      "score": 2.006215542699554,
      "candidate": "from typing import List\n\n\ndef get_optimal_value(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for col in range(cols - 1, -1, -1):\n        for row in range(rows):\n            if col == cols - 1:\n                dp[row][col] = gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row][col + 1],\n                    gold_map[row][col],\n                )\n\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols):\n            if row == rows - 1:\n                dp[row][col] = gold_map[row][col]\n            else:\n                dp[row][col] = max(\n                    gold_map[row][col] + dp[row + 1][col],\n                    dp[row][col],\n                )\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    assert get_optimal_value([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 12"
    },
    {
      "rank": 100,
      "score": 1.6901274479551278,
      "candidate": "from typing import List\n\n\ndef gold_mine(gold_map: List[List[int]]) -> int:\n    \"\"\"\n    Gold mine problem.\n    Time Complexity: O(n*m)\n    Space Complexity: O(1)\n    \"\"\"\n    rows = len(gold_map)\n    cols = len(gold_map[0])\n\n    for i in range(1, rows):\n        gold_map[i][0] += gold_map[i - 1][0]\n\n    for i in range(1, cols):\n        gold_map[0][i] += gold_map[0][i - 1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            gold_map[i][j] += max(gold_map[i - 1][j], gold_map[i][j - 1])\n\n    return gold_map[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert gold_mine([[1, 3, 1], [2, 2, 4], [5, 1, 5]]) == 12\n    assert gold_mine([[5, 3], [2, 2]]) == 10"
    }
  ]
}