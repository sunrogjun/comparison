{
  "timestamp": "2025-09-15T00:25:11.312919",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 280,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def num_of_ways_to_paint_fence(n, k):\n    if n <= 0 or k <= 0:\n        return 0\n    elif n == 1:\n        return k\n    elif n == 2:\n        return k**2\n\n    dp = [0 for _ in range(n)]\n    dp[0] = k\n    dp[1] = k**2\n\n    for i in range(2, n):\n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])\n\n    return dp[n - 1]\n\nprint(num_of_ways_to_paint_fence(3, 2))\nprint(num_of_ways_to_paint_fence(4, 2))\n\n\"\"\"\nTime O(N)\nSpace O(N)\n\"\"\""
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n, k):\n    if n <= 2:\n        return k ** n\n    return k * num_ways(n - 1, k) + k * num_ways(n - 2, k)\n\n\nif __name__ == \"__main__\":\n    print(num_ways(4, 2))\n    print(num_ways(3, 2))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def num_of_ways(n, k):\n    # Bottom-up DP\n    dp = [[0] * k for _ in range(n)]\n    dp[0] = [1] * k\n    for i in range(1, n):\n        for j in range(k):\n            dp[i][j] = sum(dp[i - 1][:j])\n    return sum(dp[n - 1])\n\n\ndef test_solution():\n    assert num_of_ways(3, 2) == 6\n    assert num_of_ways(2, 3) == 4\n    assert num_of_ways(1, 5) == 1\n    assert num_of_ways(4, 2) == 10\n\nif __name__ == '__main__':\n    test_solution()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def count_painted_fences(n, k):\n    if n < 2:\n        return k\n\n    dp = [0 for _ in range(n + 1)]\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] += dp[j] * (k - 1)\n\n    return dp[n]"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def num_of_painted_fence(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[j] += dp[j - 1]\n        for j in range(2, k + 1):\n            dp[j] += dp[j - 1]\n    return dp[-1]\n\nprint(num_of_painted_fence(4, 2))\nprint(num_of_painted_fence(4, 3))\nprint(num_of_painted_fence(5, 4))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n\n    return k * (num_of_ways(n - 1, k) + num_of_ways(n - 2, k))\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(1, 1))\n    print(num_of_ways(2, 1))\n    print(num_of_ways(3, 1))\n    print(num_of_ways(4, 1))\n    print(num_of_ways(5, 1))\n    print(num_of_ways(6, 1))\n    print(num_of_ways(7, 1))\n    print(num_of_ways(8, 1))\n    print(num_of_ways(9, 1))\n    print(num_of_ways(10, 1))\n    print(num_of_ways(11, 1))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return k\n\n    if n == 2:\n        return k * k\n\n    return (k * num_of_ways(n - 1, k)) + (k * (k - 1) * num_of_ways(n - 2, k))\n\n\ndef main():\n    print(num_of_ways(1, 4))\n    print(num_of_ways(2, 4))\n    print(num_of_ways(3, 4))\n    print(num_of_ways(4, 4))\n    print(num_of_ways(5, 4))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from itertools import product\n\n\ndef num_painted_fence(n, k):\n    if n <= 0 or k <= 0:\n        return 0\n\n    if n <= 2:\n        return k ** n\n\n    res = 0\n\n    for color in product(range(1, k+1), repeat=2):\n        if color[0] == color[1]:\n            continue\n        res += 1\n\n    return res * k ** 2\n\n\nprint(num_painted_fence(2, 2))\nprint(num_painted_fence(3, 3))\nprint(num_painted_fence(4, 4))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def num_ways(n, k):\n    \"\"\"\n    This is a classic dynamic programming problem.\n    We define a table `dp[n][k]` where `dp[i][j]` is the number of ways of\n    painting the fence such that at most 2 adjacent posts have the same color\n    for the given fence with `i` posts and `j` colors.\n\n    We have the following recurrence relation:\n\n    `dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]`\n\n    where `dp[i - 1][j]` means the number of ways of painting the fence such\n    that at most 2 adjacent posts have the same color for the given fence with\n    `i - 1` posts and `j` colors.\n\n    The reason we have `dp[i - 1][j - 1]`, `dp[i - 1][j]` and `dp[i - 1][j + 1]`\n    is because the last post can be painted with any color.\n    \"\"\"\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[1][1] = 2\n    for i in range(2, n + 1):\n        for j in range(1, k):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]\n    return dp[-1][-1]\n\n\ndef test(n, k, expected_answer):\n    answer = num_ways(n, k)\n\n    if answer != expected_answer:\n        raise Exception(\n            f\"Answer {answer} is wrong. Expected answer is {expected_answer}\"\n        )\n\n\nif __name__ == \"__main__\":\n    test(1, 2, 1)\n    test(2, 2, 3)\n    test(2, 3, 4)\n    test(3, 2, 5)\n    test"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def num_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n == 3:\n        return k * (k * k + k)\n\n    ways = [0] * (n + 1)\n    ways[0] = 0\n    ways[1] = k\n    ways[2] = k * k\n    ways[3] = k * (k * k + k)\n    for i in range(4, n + 1):\n        ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])\n    return ways[n]\n\n\nif __name__ == \"__main__\":\n    print(num_ways(1, 2))\n    print(num_ways(2, 2))\n    print(num_ways(3, 2))\n    print(num_ways(4, 2))\n    print(num_ways(5, 2))\n    print(num_ways(6, 2))\n    print(num_ways(7, 2))\n    print(num_ways(8, 2))\n    print(num_ways(9, 2))\n    print(num_ways(10, 2))\n    print(num_ways(11, 2))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    return (num_ways(n - 1, k) + 2 * num_ways(n - 2, k) + num_ways(n - 3, k)) % (10 ** 9 + 7)\n\n\nif __name__ == '__main__':\n    for i in range(4):\n        print(num_ways(i, 3))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def num_paintings(n, k):\n    # fence with 1 post has 1 way to paint\n    if n == 1: return 1\n    # fence with 2 posts has k ways to paint\n    if n == 2: return k\n\n    # fence with 3 posts has k * (k - 1) ways to paint\n    if n == 3: return k * (k - 1)\n\n    # fence with 4 posts has k * (k - 1) * (k - 2) ways to paint\n    if n == 4: return k * (k - 1) * (k - 2)\n\n    # fence with 5 posts has k * (k - 1) * (k - 2) * (k - 3) ways to paint\n    if n == 5: return k * (k - 1) * (k - 2) * (k - 3)\n\n    # fence with 6 posts has k * (k - 1) * (k - 2) * (k - 3) * (k - 4) ways to paint\n    if n == 6: return k * (k - 1) * (k - 2) * (k - 3) * (k - 4)\n\n    # fence with 7 posts has k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) ways to paint\n    if n == 7: return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5)\n\n    # fence with 8 posts has k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) ways to paint\n    if n == 8: return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6)\n\n    # fence"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def num_ways(n, k):\n    if n <= 1:\n        return n\n    if k <= 1:\n        return 0\n\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n\n    return sum(num_of_ways(n - 1, k) for i in range(k)) + \\\n        sum(num_of_ways(n - 2, k) for i in range(k - 1))\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(1, 2))\n    print(num_of_ways(2, 2))\n    print(num_of_ways(3, 2))\n    print(num_of_ways(4, 2))\n    print(num_of_ways(5, 2))\n    print(num_of_ways(6, 2))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution:\n    def num_of_painted_fence(self, n: int, k: int) -> int:\n        if n <= 2:\n            return n\n        dp = [0] * k\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, n):\n            for j in range(k):\n                if j == 0:\n                    dp[j] = 1 + dp[1]\n                elif j == 1:\n                    dp[j] = 1 + dp[0]\n                else:\n                    dp[j] += dp[j - 1]\n        return sum(dp)\n\n\nif __name__ == \"__main__\":\n    inp = 3\n    k = 2\n    out = 4\n    res = Solution().num_of_painted_fence(inp, k)\n    assert res == out, (res, out)\n\n    inp = 2\n    k = 3\n    out = 10\n    res = Solution().num_of_painted_fence(inp, k)\n    assert res == out, (res, out)\n\n    inp = 1\n    k = 2\n    out = 1\n    res = Solution().num_of_painted_fence(inp, k)\n    assert res == out, (res, out)"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def num_paintings(n, k):\n    dp = [[0] * k for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for i in range(1, n):\n        for j in range(1, k):\n            for l in range(i):\n                dp[i][j] += dp[l][j - 1]\n    return dp[-1][-1]"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef fence_painting(n, k):\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    return fence_painting(n - 2, k) * k + fence_painting(n - 1, k)\n\n\nif __name__ == \"__main__\":\n    for n in range(1, 6):\n        for k in range(1, 6):\n            print(fence_painting(n, k))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef count_painted_fence(n: int, k: int) -> int:\n    dp = [0] * (k + 1)\n    dp[0] = 1\n\n    for i in range(1, k + 1):\n        dp[i] = 2\n\n    for i in range(2, n):\n        for j in range(1, k):\n            dp[j] += dp[j - 1]\n\n    return dp[k - 1]\n\n\nif __name__ == \"__main__\":\n    assert count_painted_fence(5, 3) == 5"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_painted_fences(n, k):\n    if n < 0 or k < 0:\n        return 0\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n >= 3:\n        return (num_painted_fences(n-1, k) +\n                num_painted_fences(n-2, k) * (k-1) +\n                num_painted_fences(n-3, k) * (k-1) * (k-2))\n\n\nif __name__ == \"__main__\":\n    print(num_painted_fences(0, 2))\n    print(num_painted_fences(1, 2))\n    print(num_painted_fences(2, 2))\n    print(num_painted_fences(3, 2))\n    print(num_painted_fences(4, 2))\n    print(num_painted_fences(5, 2))\n    print(num_painted_fences(6, 2))\n    print(num_painted_fences(7, 2))\n    print(num_painted_fences(8, 2))\n    print(num_painted_fences(9, 2))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef num_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    Let f[i][j] be the number of ways to paint the fence with i posts and j colors.\n    We have two cases:\n    - If the first post is painted with color j, then we have f[i][j] = f[i-1][j-1]\n    - If the first post is painted with color k, then we have f[i][k] = f[i-1][k] + f[i-1][k-1]\n    \"\"\"\n    fence = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            fence[i][j] = fence[i - 1][j - 1] + fence[i - 1][j]\n    return fence[n][k]\n\n\nif __name__ == \"__main__\":\n    assert num_of_ways(2, 2) == 3\n    assert num_of_ways(3, 2) == 4\n    assert num_of_ways(3, 3) == 5\n    assert num_of_ways(4, 2) == 12\n    assert num_of_ways(4, 3) == 18\n    assert num_of_ways(4, 4) == 24\n    assert num_of_ways(5, 2) == 34\n    assert num_of_ways(5, 3) == 50\n    assert num_of_ways(5, 4) == 66\n    assert num_of_ways(6, 2) == 98\n    assert num_of_ways(6, 3) == 140\n    assert num_of_ways(6, 4) == 194\n    assert num_of_ways(6, 5) == 248"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def num_of_ways(n, k):\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n    return dp[n]"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "def num_painted_post(n, k):\n    if n < 2 or k < 2:\n        return 0\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    for i in range(k):\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(k):\n            for l in range(k):\n                if l != j:\n                    dp[i][j] += dp[i-1][l]\n    return dp[n-1][k-1]\n\n\nprint(num_painted_post(2, 3))\nprint(num_painted_post(3, 2))\nprint(num_painted_post(3, 3))\nprint(num_painted_post(4, 2))"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n == 3:\n        return k * k * k\n    return num_ways(n-1, k) + num_ways(n-2, k) + num_ways(n-3, k)\n\n\nif __name__ == \"__main__\":\n    print(num_ways(1, 2))\n    print(num_ways(2, 2))\n    print(num_ways(3, 2))\n    print(num_ways(4, 2))\n    print(num_ways(5, 2))"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 1\n\n    if n == 1:\n        return k\n\n    if n == 2:\n        return k * k\n\n    if n == 3:\n        return k * k * k\n\n    return (k * (k - 1) ** 2) * num_of_ways(n - 2, k)\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (0, 3),\n        (1, 3),\n        (2, 3),\n        (3, 3),\n        (4, 3),\n        (5, 3),\n        (6, 3),\n        (7, 3),\n        (8, 3),\n    ]\n    for n, k in test_cases:\n        print(num_of_ways(n, k))"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "def num_of_paintings(n, k):\n\t# Write your code here.\n\treturn get_ways(n, k, {})\n\ndef get_ways(n, k, memo):\n\tif n == 0:\n\t\treturn 0\n\tif n == 1:\n\t\treturn k\n\tif n == 2:\n\t\treturn k\n\tif n in memo:\n\t\treturn memo[n]\n\ttotal = 0\n\tfor i in range(1, k+1):\n\t\ttotal += get_ways(n-1, k, memo)\n\t\ttotal += get_ways(n-2, k, memo)\n\tmemo[n] = total\n\treturn total"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef get_ways(n, k):\n    if n < 2:\n        return 0\n    if n == 2:\n        return k\n\n    res = 0\n\n    for i in range(1, k+1):\n        res += get_ways(n-1, k)\n        if i > 1:\n            res -= get_ways(n-2, i-1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(get_ways(4, 2))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def num_of_painting(n, k):\n\tif n == 0: return 0\n\tif n == 1: return k\n\tif n == 2: return k*k\n\n\tdp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n\n\tfor i in range(1, k+1):\n\t\tdp[1][i] = 1\n\tfor i in range(2, n+1):\n\t\tfor j in range(1, k+1):\n\t\t\tdp[i][j] += dp[i-1][j]\n\t\t\tif i > 1: dp[i][j] += dp[i-2][j]\n\treturn dp[n][k]\n\nprint(num_of_painting(5, 2))"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def num_painted_fence(n, k):\n    if n == 0 or k == 0:\n        return 0\n    dp = [0 for _ in range(n)]\n    dp[0] = k\n    dp[1] = k - 1\n    for i in range(2, n):\n        dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n    return dp[-1]"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def num_of_ways(n, k):\n    if n==0: return 0\n    if n==1: return k\n    if n==2: return k*k\n    dp = [0]*(n+1)\n    dp[1], dp[2] = k, k*k\n    for i in range(3, n+1):\n        for j in range(1, i):\n            dp[i] += dp[j]*dp[i-j]\n    return dp[-1]\n\nif __name__ == \"__main__\":\n    print num_of_ways(3, 3)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def num_of_paintings(n, k):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    elif n == 2:\n        return k * k\n    elif k == 1:\n        return 0\n    elif k == 2:\n        return (n - 1) * 2\n\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n    for i in range(3, n + 1):\n        for j in range(1, k + 1):\n            if i - j > 1:\n                dp[i] += dp[i - j]\n\n    return dp[n]\n\nprint(num_of_paintings(2, 1))\nprint(num_of_paintings(2, 2))\nprint(num_of_paintings(3, 2))\nprint(num_of_paintings(3, 3))\nprint(num_of_paintings(4, 2))\nprint(num_of_paintings(4, 3))\nprint(num_of_paintings(5, 2))\nprint(num_of_paintings(5, 3))\nprint(num_of_paintings(5, 4))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_painted_fence(n: int, k: int) -> int:\n    if n < 0 or k < 1 or k > n:\n        return 0\n    elif n == 0 or k == 1:\n        return 1\n\n    return num_of_painted_fence(n - 1, k - 1) + num_of_painted_fence(n - 1, k)\n\n\nif __name__ == \"__main__\":\n    assert num_of_painted_fence(5, 3) == 5"
    },
    {
      "rank": 32,
      "score": 2.0,
      "candidate": "def num_of_ways(n, k):\n    if k == 1:\n        return n\n    if n == 1:\n        return 1\n    if n == 2:\n        return k\n\n    return num_of_ways(n - 1, k) * k + num_of_ways(n - 2, k) * k\n\n\nprint(num_of_ways(2, 2))\nprint(num_of_ways(3, 2))\nprint(num_of_ways(3, 3))\nprint(num_of_ways(4, 2))"
    },
    {
      "rank": 33,
      "score": 1.0,
      "candidate": "def number_of_ways(n, k):\n    # Create an array of size k that keeps track of the number of ways to paint the first post\n    dp = [0] * k\n    dp[0] = 1\n\n    # For each post, we can either paint it the same color as the previous post or a different color\n    for i in range(1, n):\n        for j in range(k):\n            # If the post is different from the previous post, we can paint it using the number of ways to paint the previous post\n            if j != 0:\n                dp[j] += dp[j - 1]\n            # If the post is the same as the previous post, we can paint it using the number of ways to paint the previous post\n            else:\n                dp[j] += 1\n    \n    return dp[-1]\n\nprint(number_of_ways(3, 2))\nprint(number_of_ways(4, 2))"
    },
    {
      "rank": 34,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n, k):\n    if n == 1:\n        return k\n\n    if n == 2:\n        return k * k\n\n    ways = 0\n\n    for i in range(1, k + 1):\n        ways += num_ways(n - 1, k)\n\n    return ways\n\n\ndef main():\n    print(\"Total number of ways: \" + str(num_ways(2, 2)))\n    print(\"Total number of ways: \" + str(num_ways(3, 2)))\n\n\nmain()"
    },
    {
      "rank": 35,
      "score": 1.0,
      "candidate": "def number_of_ways_to_paint_the_fence(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return k\n    if k == 1:\n        return n\n    if n == 2:\n        return k\n    if k == 2:\n        return (n-1)\n    if n == 3:\n        return k * (k-1)\n    if k == 3:\n        return (n-2)\n    if n == 4:\n        return k * (k-1) * (k-2)\n    if k == 4:\n        return (n-3)\n    if n == 5:\n        return k * (k-1) * (k-2) * (k-3)\n    if k == 5:\n        return (n-4)\n\n    return k * (k-1) * (k-2) * (k-3) * (k-4)\n\nprint(number_of_ways_to_paint_the_fence(3, 4))"
    },
    {
      "rank": 36,
      "score": 1.0,
      "candidate": "def num_of_painted_fence(n, k):\n    # base case\n    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n\n    # recursive case\n    return (k * num_of_painted_fence(n-1, k)) + (k * (k - 1) * num_of_painted_fence(n-2, k))\n\n\nprint(num_of_painted_fence(3, 2))\nprint(num_of_painted_fence(4, 2))\nprint(num_of_painted_fence(5, 2))\nprint(num_of_painted_fence(6, 2))\nprint(num_of_painted_fence(7, 2))\nprint(num_of_painted_fence(8, 2))\nprint(num_of_painted_fence(9, 2))\nprint(num_of_painted_fence(10, 2))"
    },
    {
      "rank": 37,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n\tif n == 0:\n\t\treturn 0\n\tif n == 1:\n\t\treturn k\n\tif n == 2:\n\t\treturn k * (k-1)\n\tif n == 3:\n\t\treturn k * (k-1) * (k-2)\n\treturn k * (k-1) * (k-2) * (k-3)\n\n\nprint(num_of_ways(0, 4))\nprint(num_of_ways(1, 4))\nprint(num_of_ways(2, 4))\nprint(num_of_ways(3, 4))\nprint(num_of_ways(4, 4))"
    },
    {
      "rank": 38,
      "score": 1.0,
      "candidate": "def fence_painting(n, k):\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n\n    # Initialization\n    dp[0][0] = 1\n    for i in range(1, k):\n        dp[0][i] = 1\n\n    # Bottom-up computation\n    for i in range(1, n):\n        for j in range(k):\n            for h in range(k):\n                if h == j:\n                    continue\n                dp[i][j] += dp[i-1][h]\n    return dp[-1][-1]\n\ndef test_fence_painting():\n    assert fence_painting(2, 2) == 2\n    assert fence_painting(3, 2) == 4\n    assert fence_painting(3, 3) == 5\n    assert fence_painting(4, 2) == 12\n\nif __name__ == '__main__':\n    test_fence_painting()"
    },
    {
      "rank": 39,
      "score": 1.0,
      "candidate": "def num_painted_post_same_color_adjacent(n, k):\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n+1):\n        for j in range(1, k+1):\n            dp[i] += dp[i-1]\n            dp[i] %= 1000000007\n\n        dp[i] += dp[i-2]\n        dp[i] %= 1000000007\n\n    return dp[n]\n\nprint(num_painted_post_same_color_adjacent(4, 2))\nprint(num_painted_post_same_color_adjacent(3, 2))\nprint(num_painted_post_same_color_adjacent(3, 3))\nprint(num_painted_post_same_color_adjacent(1, 3))"
    },
    {
      "rank": 40,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * (k-1)\n    if n == 3:\n        return k * (k-1) * (k-2)\n    if k == 1:\n        return 1\n    if k == 2:\n        return n\n    if k == 3:\n        return n * (n-1)\n    if k == 4:\n        return n * (n-1) * (n-2)\n    if n == 4 and k == 5:\n        return 24\n    if n == 4 and k == 6:\n        return 30\n    if n == 5 and k == 6:\n        return 42\n    if n == 6 and k == 6:\n        return 56\n    if n == 7 and k == 6:\n        return 72\n    if n == 8 and k == 6:\n        return 90\n    if n == 9 and k == 6:\n        return 108\n    if n == 10 and k == 6:\n        return 126\n    if n == 11 and k == 6:\n        return 144\n    if n == 12 and k == 6:\n        return 162\n    if n == 13 and k == 6:\n        return 180\n    if n == 14 and k == 6:\n        return 198\n    if n == 15 and k == 6:\n        return 216\n    if n == 16 and k == 6:\n        return 234\n    if n == 17 and k == 6:\n        return 252\n    if n == 18 and k == 6:\n        return 270\n    if n == 19 and k == 6:\n        return 288\n    if n == 20 and k == 6:\n        return 306"
    },
    {
      "rank": 41,
      "score": 1.0,
      "candidate": "def num_painted_fence(n, k):\n    if n <= 2:\n        return n\n    if k <= 2:\n        return k\n\n    if n <= 0 or k <= 0:\n        return 0\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n\n    result = 0\n    for i in range(2, k+1):\n        result = (result + dp[n-i+1]) % 1000000007\n\n    return result\n\nprint(num_painted_fence(4, 3))\nprint(num_painted_fence(3, 2))\nprint(num_painted_fence(1, 1))\nprint(num_painted_fence(1, 2))\nprint(num_painted_fence(1, 3))\nprint(num_painted_fence(2, 3))\nprint(num_painted_fence(4, 4))"
    },
    {
      "rank": 42,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_of_paint_ways(n: int, k: int) -> int:\n    \"\"\"\n    Let's denote F(n, k) as the number of ways of painting the fence such that at most 2 adjacent posts have the same color\n    for the given fence with n posts and k colors.\n    We can find the number of ways of painting the fence with n posts and k colors.\n    F(n, k) = F(n - 1, k) + F(n - 1, k - 1) + F(n - 1, k - 2)\n    where we can take the last post as either color 1, color 2 or color 3.\n    \"\"\"\n    if n <= 0 or k <= 0:\n        return 0\n\n    if n == 1:\n        return k\n\n    dp = [0] * k\n    dp[0] = 1\n\n    for i in range(1, n):\n        for j in range(k):\n            if j == 0:\n                dp[j] = 1\n            elif j == 1:\n                dp[j] = dp[j - 1] + dp[j]\n            else:\n                dp[j] = dp[j - 1] + dp[j - 2] + dp[j]\n\n    return dp[-1]\n\n\n# Tests\nassert num_of_paint_ways(0, 0) == 0\nassert num_of_paint_ways(1, 0) == 0\nassert num_of_paint_ways(1, 1) == 1\nassert num_of_paint_ways(1, 2) == 2\nassert num_of_paint_ways(2, 1) == 1\nassert num_of_paint_ways(2, 2) == 3\nassert num_of_paint_ways(3, 2) == 5\nassert num_of_paint_ways(4, 2) == 11"
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_painted_fences(n: int, k: int) -> int:\n    if n == 1:\n        return k\n\n    return sum(num_painted_fences(n - 1, k - 1) for _ in range(k))\n\n\nif __name__ == \"__main__\":\n    assert num_painted_fences(3, 2) == 5"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def num_painted_fences(self, n: int, k: int) -> int:\n        if n == 0 or k == 0:\n            return 0\n        if n == 1:\n            return k\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(n):\n            tmp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                tmp[j] += dp[j]\n                if i > 0:\n                    tmp[j] += dp[j - 1]\n                if i > 1:\n                    tmp[j] += dp[j - 2]\n            dp = tmp\n        return dp[-1]\n\n\nif __name__ == \"__main__\":\n    n = 1\n    k = 1\n    out = 1\n    res = Solution().num_painted_fences(n, k)\n    assert out == res, (out, res)\n\n    n = 3\n    k = 4\n    out = 5\n    res = Solution().num_painted_fences(n, k)\n    assert out == res, (out, res)\n\n    n = 4\n    k = 4\n    out = 12\n    res = Solution().num_painted_fences(n, k)\n    assert out == res, (out, res)"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_of_painted_fence(n: int, k: int) -> int:\n    if n <= 1:\n        return k\n\n    dp = [0] * k\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, k):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    for i in range(2, n):\n        prev = dp[0]\n        dp[0] = dp[1]\n        for j in range(1, k):\n            dp[j] = prev + dp[j]\n            prev = dp[j]\n\n    return dp[k - 1] + dp[k - 2]\n\n\nn = 3\nk = 2\nassert num_of_painted_fence(n, k) == 5\n\nn = 4\nk = 2\nassert num_of_painted_fence(n, k) == 12\n\nn = 3\nk = 3\nassert num_of_painted_fence(n, k) == 16\n\nn = 4\nk = 3\nassert num_of_painted_fence(n, k) == 24"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "def num_of_painted_fence(n, k):\n    if n < 2:\n        return 0\n\n    dp = [0] * k\n    dp[0] = 1\n    dp[1] = 2\n    for i in range(2, n):\n        for j in range(k):\n            if j == 0:\n                dp[j] = dp[j + 1] + dp[j]\n            elif j == 1:\n                dp[j] = dp[j - 1] + dp[j + 1] + dp[j]\n            else:\n                dp[j] = dp[j - 1] + dp[j + 1] + dp[j] - dp[j - 2]\n    return dp[k - 1]\n\n\nprint(num_of_painted_fence(3, 2))"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "def num_ways(n, k):\n    \"\"\"\n    :param: n - number of posts\n    :param: k - number of colors\n    return number of ways of painting the fence such that at most 2 adjacent posts have the same color\n    \"\"\"\n    # Write your code here.\n    if k == 0 or n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return k\n    if n == 3:\n        return k * (k - 1)\n    ways = [0] * (n + 1)\n    ways[0] = 0\n    ways[1] = 1\n    ways[2] = k\n    ways[3] = k * (k - 1)\n    for i in range(4, n + 1):\n        ways[i] = k * (k - 1) * (i - 1)\n        for j in range(2, i):\n            ways[i] += (ways[j - 1] + ways[j]) * (k - 1)\n    return ways[-1]\n\n\nprint(num_ways(2, 2))"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "def num_of_painted_fence(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n == 0 or k == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return k\n    if n == 3:\n        return k * k\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n    for i in range(3, n + 1):\n        dp[i] = k * (k - 1) * (dp[i - 1] + dp[i - 2])\n    return dp[-1]\n\n\nprint(num_of_painted_fence(4, 2))"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "def number_of_ways(n, k):\n    if n == 0 or k == 0:\n        return 0\n    elif n == 1:\n        return k\n    elif n == 2:\n        return k * (k - 1)\n    else:\n        return (k * (k - 1)) ** 2\n\n\ndef test_number_of_ways():\n    assert number_of_ways(0, 0) == 0\n    assert number_of_ways(1, 0) == 0\n    assert number_of_ways(1, 1) == 1\n    assert number_of_ways(2, 1) == 0\n    assert number_of_ways(2, 2) == 2\n    assert number_of_ways(3, 2) == 6\n    assert number_of_ways(4, 2) == 24\n    assert number_of_ways(5, 2) == 80\n    assert number_of_ways(6, 2) == 240\n    assert number_of_ways(7, 2) == 720\n    assert number_of_ways(8, 2) == 2184\n\n\nif __name__ == '__main__':\n    test_number_of_ways()"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "def num_painted_fence(n, k):\n    \"\"\"\n    :param n: number of posts in the fence\n    :param k: number of colors\n    :return: number of ways of painting the fence such that at most 2 adjacent posts have the same color\n    \"\"\"\n    # Initialize dp with 1 for the edge case of 1 post\n    dp = [1]\n\n    # Fill the remaining dp values\n    for i in range(1, n):\n        # Initialize dp[i] to 0\n        dp.append(0)\n\n        # For each color, add the number of ways of painting the previous i-1 posts\n        for j in range(1, k + 1):\n            dp[i] += dp[i - 1] if j == 1 else 0\n\n    return dp[-1]\n\n\ndef test_case(k, n, expected_answer):\n    answer = num_painted_fence(n, k)\n    if answer != expected_answer:\n        raise Exception(\n            f\"Answer {answer} is wrong! Expected answer is {expected_answer}\")\n\n\nif __name__ == \"__main__\":\n    test_case(3, 4, 10)\n    test_case(2, 5, 30)"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "def number_of_ways(n, k):\n    \"\"\"\n    :param: n - number of posts\n    :param: k - number of colors\n    return: total number of ways of painting the fence\n    TODO: complete this function and return the number of ways of painting the fence\n    NOTE: The n is equal to the number of posts and k is equal to the number of colors\n    \"\"\"\n    return 0\n\n\nprint(number_of_ways(1, 1))\nprint(number_of_ways(2, 2))\nprint(number_of_ways(3, 3))\nprint(number_of_ways(4, 4))\nprint(number_of_ways(5, 5))"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    if n == 1:\n        return k\n    elif n == 2:\n        return k * k\n    elif n == 3:\n        return k * k * k\n    elif n == 4:\n        return k * k * k * k\n    else:\n        return num_of_ways(n-1, k) + num_of_ways(n-2, k) + num_of_ways(n-3, k)\n\nn = 3\nk = 2\nprint(num_of_ways(n, k))"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef number_of_painted_fence(n: int, k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(n*k)\n\n    :param n: number of posts\n    :param k: number of colors\n    :return: number of ways of painting the fence\n    \"\"\"\n    if n < 2 or k < 2:\n        return [1]\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert number_of_painted_fence(2, 2) == [1, 2]\n    assert number_of_painted_fence(2, 3) == [1, 4, 5]\n    assert number_of_painted_fence(3, 2) == [1, 3, 5]\n    assert number_of_painted_fence(3, 3) == [1, 4, 10, 13]\n    assert number_of_painted_fence(5, 2) == [1, 3, 10, 21, 35, 50]\n    assert number_of_painted_fence(5, 3) == [1, 4, 13, 40, 105, 274, 673]"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "def num_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k*k\n    if n < 2:\n        return 0\n\n    dp = [0]*(n+1)\n    dp[1] = k\n    dp[2] = k*k\n\n    for i in range(3, n+1):\n        for j in range(1, i):\n            dp[i] += dp[j]*dp[i-j]\n\n    return dp[n]\n\nif __name__ == \"__main__\":\n    print(num_ways(3, 2))"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n: int, k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(n*k)\n    \"\"\"\n    if n <= 1:\n        return k\n\n    if n == 2:\n        return k * k\n\n    return num_ways(n - 1, k) * k + num_ways(n - 2, k) * (k - 1)\n\n\nif __name__ == \"__main__\":\n    assert num_ways(0, 1) == 0\n    assert num_ways(1, 1) == 1\n    assert num_ways(2, 1) == 1\n    assert num_ways(3, 1) == 2\n    assert num_ways(4, 1) == 3\n    assert num_ways(5, 1) == 5\n    assert num_ways(6, 1) == 8\n    assert num_ways(7, 1) == 13\n    assert num_ways(8, 1) == 21\n    assert num_ways(9, 1) == 34\n    assert num_ways(10, 1) == 55\n\n    assert num_ways(10, 2) == 14\n    assert num_ways(10, 3) == 19\n    assert num_ways(10, 4) == 26\n    assert num_ways(10, 5) == 35\n    assert num_ways(10, 6) == 46\n    assert num_ways(10, 7) == 58\n    assert num_ways(10, 8) == 72\n    assert num_ways(10, 9) == 88\n    assert num_ways(10, 10) == 105\n\n    assert num_ways(10, 11) == 132\n    assert num_ways(10, 12) == 161"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    if n < 0:\n        return 0\n\n    dp = [1] * (n + 1)\n\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            if i == 2:\n                dp[i] += dp[i - 2]\n            elif i == 3:\n                dp[i] += dp[i - 3]\n            else:\n                dp[i] += dp[i - j] + dp[i - 2 * j]\n\n    return dp[-1]\n\n\nprint(num_of_ways(3, 2))\nprint(num_of_ways(4, 2))"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "def count_paintings(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1] = [1] * (k + 1)\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            for l in range(1, j + 1):\n                dp[i][j] += dp[i - 1][l]\n    return dp[n][k]\n\nprint(count_paintings(4, 2))"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef count_paint_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    @lru_cache(maxsize=None)\n    def paint(n, k):\n        if n == 1:\n            return k\n        if n == 2:\n            return k * k\n        return (paint(n - 1, k) * k + paint(n - 2, k) * (k - 1)) % (10 ** 9 + 7)\n    return paint(n, k)\n\n\nif __name__ == '__main__':\n    print(count_paint_ways(3, 2))"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_of_painted_ways(n: int, k: int) -> int:\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n\n    return dp[n][k]\n\n\nif __name__ == \"__main__\":\n    assert num_of_painted_ways(3, 2) == 5"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n > 2:\n        return (k * (k - 1)) * num_of_ways(n - 2, k)\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(0, 4))\n    print(num_of_ways(1, 4))\n    print(num_of_ways(2, 4))\n    print(num_of_ways(3, 4))\n    print(num_of_ways(4, 4))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            dp[i] += dp[i - 1]\n\n        if i % 2 == 0:\n            dp[i] -= dp[i // 2]\n\n    return dp[n]\n\n\nprint(num_of_ways(4, 2))"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "def number_of_ways(n, k):\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    dp[1][1] = 1\n    for i in range(2, n+1):\n        for j in range(1, k+1):\n            if j == 1:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert number_of_ways(4, 2) == 5"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_painted_fence(n: int, k: int) -> int:\n    if n == 1:\n        return k\n\n    dp = [0] * k\n    dp[0] = 1\n\n    for i in range(1, n):\n        new_dp = [0] * k\n\n        for j in range(k):\n            if j == 0:\n                new_dp[j] += dp[j]\n            elif j == k - 1:\n                new_dp[j] += dp[j - 1]\n            else:\n                new_dp[j] += dp[j - 1] + dp[j]\n\n        dp = new_dp\n\n    return dp[k - 1]\n\n\nif __name__ == \"__main__\":\n    assert num_painted_fence(4, 2) == 6\n    assert num_painted_fence(4, 3) == 14\n    assert num_painted_fence(4, 4) == 30\n    assert num_painted_fence(5, 3) == 42"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef num_of_ways(n, k):\n    \"\"\"\n    :param: n - no of posts\n    :param: k - no of colors\n    return - number of ways of painting the fence\n    \"\"\"\n    return num_of_ways_dp(n, k)\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways_dp(n, k):\n    if n == 1:\n        return k\n\n    if n == 2:\n        return k * k\n\n    if n == 3:\n        return k * k * k\n\n    return num_of_ways_dp(n - 1, k) + (k - 1) * num_of_ways_dp(n - 2, k) + (k - 1) * (k - 1) * num_of_ways_dp(n - 3, k)\n\n\ndef main():\n    print(\"Total number of ways: \" + str(num_of_ways(5, 2)))\n    num_of_ways.cache_clear()\n    print(\"Total number of ways: \" + str(num_of_ways(5, 2)))\n\n\nmain()"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n == 3:\n        return k * (k * k + k * k)\n\n    return k * (num_ways(n - 1, k) + num_ways(n - 2, k))\n\n\n@lru_cache(maxsize=None)\ndef num_ways_dp(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n == 3:\n        return k * (k * k + k * k)\n\n    return k * (num_ways_dp(n - 1, k) + num_ways_dp(n - 2, k))\n\n\ndef main():\n    print(num_ways(5, 2))\n    print(num_ways_dp(5, 2))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "def fence_painting(n, k):\n    # create a dp table\n    table = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    table[0][0] = 1\n\n    # fill the table\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if i == 1:\n                table[i][j] = 1\n            else:\n                # if the previous post was same as current,\n                # then we can only paint the current post\n                # in the same color as previous\n                if j == 1:\n                    table[i][j] = table[i-1][j]\n                else:\n                    # we can either paint the current post in\n                    # a different color or same color as previous\n                    table[i][j] = table[i-1][j-1] + table[i-1][j]\n    return table[n][k]\n\n\nn = 2\nk = 2\nprint(fence_painting(n, k))"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    dp = [[0] * k for _ in range(n)]\n\n    dp[0][0] = 1\n    for i in range(1, n):\n        for j in range(k):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j < k - 1:\n                dp[i][j] += dp[i - 1][j + 1]\n\n    return dp[-1][-1]"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def num_of_painted_fence(self, n: int, k: int) -> int:\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(n):\n            new_dp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp[j] += dp[j]\n                if i > 0:\n                    new_dp[j] += dp[j - 1]\n            dp = new_dp\n        return sum(dp) % (10 ** 9 + 7)\n\n\nif __name__ == \"__main__\":\n    n = 4\n    k = 3\n    out = 13\n    res = Solution().num_of_painted_fence(n, k)\n    assert res == out, (res, out)\n\n    n = 1\n    k = 1\n    out = 1\n    res = Solution().num_of_painted_fence(n, k)\n    assert res == out, (res, out)\n\n    n = 3\n    k = 3\n    out = 16\n    res = Solution().num_of_painted_fence(n, k)\n    assert res == out, (res, out)\n\n    n = 2\n    k = 4\n    out = 3\n    res = Solution().num_of_painted_fence(n, k)\n    assert res == out, (res, out)"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    >>> num_of_ways(2, 2)\n    5\n    >>> num_of_ways(3, 2)\n    11\n    >>> num_of_ways(4, 2)\n    23\n    >>> num_of_ways(5, 2)\n    42\n    >>> num_of_ways(6, 2)\n    77\n    >>> num_of_ways(7, 2)\n    132\n    >>> num_of_ways(8, 2)\n    243\n    >>> num_of_ways(1, 2)\n    1\n    >>> num_of_ways(10, 4)\n    2115\n    >>> num_of_ways(10, 5)\n    12155\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    return sum(\n        num_of_ways(n - 2, k) for i in range(1, k + 1)\n    )  # 1st paint post with i, then for the rest, we have i - 1 colors to choose from\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    return (k * num_of_ways(n - 1, k)) + (k * (k - 1) * num_of_ways(n - 2, k))\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(5, 2))\n    print(num_of_ways(3, 3))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "def num_of_painted_fences(n, k):\n    \"\"\"\n    Let's start with an array of 3 elements: [0, 0, 0]. We are going to use this array to count the number of ways\n    of painting the fence with 3 posts. We can paint all 3 posts the same color or we can paint 2 posts the same\n    color and the last post differently.\n\n    We can generalize this approach to count the number of ways of painting n posts by using an array of n elements.\n\n    We can count the number of ways of painting n posts by using an array of n elements.\n    Let's say we have an array of n elements and we want to paint the fence with n posts. We can paint all n posts\n    the same color or we can paint n - 1 posts the same color and the last post differently.\n\n    The number of ways of painting n posts with n colors is the sum of the number of ways of painting n posts with\n    n - 1 colors and the number of ways of painting n posts with n - 2 colors.\n    \"\"\"\n    if n == 1:\n        return k\n\n    fence = [0] * (n + 1)\n    fence[0] = 0\n    fence[1] = k\n    fence[2] = k * k\n\n    for i in range(3, n + 1):\n        fence[i] = (fence[i - 1] + fence[i - 2]) * (k - 1)\n\n    return fence[n]\n\n\nassert num_of_painted_fences(3, 2) == 5\nassert num_of_painted_fences(3, 3) == 10\nassert num_of_painted_fences(4, 2) == 14"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "from itertools import combinations\n\n\ndef number_of_ways(n, k):\n    result = 0\n\n    for n in range(1, n):\n        result += len(list(combinations(range(k), n)))\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(number_of_ways(4, 2))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "def num_painted_fence(n, k):\n    # base case\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n\n    # init\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    dp[1] = k\n\n    # state\n    for i in range(2, n + 1):\n        # choice: 0, 1\n        for j in range(k):\n            if j == 0:\n                dp[j] += 1\n            elif j == k - 1:\n                dp[j] += 1\n            else:\n                dp[j] += 2\n\n        # update\n        for j in range(k - 1):\n            dp[j + 1] += dp[j]\n\n    return dp[k - 1]\n\n\nif __name__ == \"__main__\":\n    print(num_painted_fence(2, 3))"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_ways(n: int, k: int) -> int:\n    \"\"\"\n    Time Complexity: O(nk)\n    Space Complexity: O(nk)\n\n    n: total posts\n    k: total colors\n    \"\"\"\n    if k > n:\n        return 0\n\n    dp = [[0] * k for _ in range(n)]\n\n    # base case: 1st post has k choices\n    for i in range(k):\n        dp[0][i] = 1\n\n    # fill the first row with k, the number of choices\n    for i in range(1, k):\n        dp[i][i] = 1\n\n    # fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(k):\n            # if this post is same as the last post, only 1 choice\n            if j == i - 1:\n                dp[i][j] = 1\n            # else, we have k choices\n            else:\n                dp[i][j] = sum(dp[i - 1][:k])\n\n    return sum(dp[-1])\n\n\nif __name__ == \"__main__\":\n    assert num_ways(3, 2) == 5\n    assert num_ways(5, 3) == 15"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef number_of_ways(n: int, k: int) -> int:\n    @lru_cache(maxsize=None)\n    def _helper(n: int, k: int, prev: int) -> int:\n        if n == 0:\n            return 1\n        count = 0\n        for i in range(1, k + 1):\n            if i != prev:\n                count += _helper(n - 1, k, i)\n        return count\n\n    return _helper(n, k, 0)\n\n\nif __name__ == \"__main__\":\n    assert number_of_ways(2, 2) == 3\n    assert number_of_ways(3, 2) == 4\n    assert number_of_ways(4, 2) == 7"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def num_of_ways_to_paint(n, k):\n    # edge cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n\n    # init table\n    table = [[0 for _ in range(k)] for _ in range(n)]\n\n    # init base cases\n    table[0][0] = 1\n    table[1][0] = 1\n    table[1][1] = 1\n\n    # fill table\n    for i in range(2, n):\n        for j in range(k):\n            table[i][j] += table[i - 1][j]\n            if j - 1 >= 0:\n                table[i][j] += table[i - 1][j - 1]\n\n    return table[n - 1][k - 1]\n\n\n\nprint(num_of_ways_to_paint(3, 2))\nprint(num_of_ways_to_paint(4, 3))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_ways_to_paint(n, k):\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    return (k - 1) * (num_ways_to_paint(n - 1, k) + num_ways_to_paint(n - 2, k))\n\n\n@lru_cache(maxsize=None)\ndef num_ways_to_paint_dp(n, k):\n    dp = [0 for _ in range(n + 1)]\n    dp[0] = 1\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert num_ways_to_paint(0, 3) == 1\n    assert num_ways_to_paint(1, 3) == 3\n    assert num_ways_to_paint(2, 3) == 9\n    assert num_ways_to_paint(3, 3) == 27\n\n    assert num_ways_to_paint_dp(0, 3) == 1\n    assert num_ways_to_paint_dp(1, 3) == 3\n    assert num_ways_to_paint_dp(2, 3) == 9\n    assert num_ways_to_paint_dp(3, 3) == 27"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "def num_of_painted_fence(n, k):\n    # Write your code here\n    dp = [[0] * k for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(1, n):\n        for j in range(k):\n            if j == 0:\n                dp[i][j] += dp[i - 1][k - 1]\n            elif j == k - 1:\n                dp[i][j] += dp[i - 1][0]\n            else:\n                dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j]\n    return sum(dp[n - 1]) % 1000000007\n\n\nprint(num_of_painted_fence(4, 2))"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    return k * (num_of_ways(n - 1, k) + num_of_ways(n - 2, k))\n\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(num_of_ways(n, k))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef num_painted_fence(n: int, k: int) -> int:\n    \"\"\"\n    Time Complexity: O(k*n)\n    Space Complexity: O(k)\n    \"\"\"\n    memo = [0] * k\n    memo[0] = 1\n\n    for i in range(1, n):\n        for j in range(k):\n            if j > 0:\n                memo[j] += memo[j - 1]\n            if j < k - 1:\n                memo[j] += memo[j + 1]\n\n    return memo[k - 1]\n\n\ndef num_painted_fence_dp(n: int, k: int) -> int:\n    \"\"\"\n    Time Complexity: O(k*n)\n    Space Complexity: O(k)\n    \"\"\"\n\n    def num_painted_fence_dp_helper(n: int, k: int, memo: List[int]) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return k\n\n        if memo[n - 1] != 0:\n            return memo[n - 1]\n\n        memo[n - 1] = k\n\n        for i in range(k):\n            if i > 0:\n                memo[n - 1] += num_painted_fence_dp_helper(n - 1, k - 1, memo)\n            if i < k - 1:\n                memo[n - 1] += num_painted_fence_dp_helper(n - 1, k - 1, memo)\n\n        return memo[n - 1]\n\n    memo = [0] * k\n    return num_painted_fence_dp_helper(n, k, memo)\n\n\nif __name__ == \"__main__\":\n    assert num_painted_fence(3, 2) == 5\n    assert num_painted_fence(3, 3) =="
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def num_painted_fences(n, k):\n    dp = [1] + [0] * n\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if i == 1:\n                dp[i] += dp[i-1]\n            elif i == 2:\n                dp[i] += dp[i-1]\n            elif i == 3:\n                dp[i] += dp[i-1]\n            else:\n                dp[i] += dp[i-1] * 2\n    return dp[n]"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "def num_of_ways_to_paint_fence(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    if n > 2:\n        return (k * k) * num_of_ways_to_paint_fence(n - 2, k)\n\n\nprint(num_of_ways_to_paint_fence(2, 2))\nprint(num_of_ways_to_paint_fence(3, 2))\nprint(num_of_ways_to_paint_fence(4, 2))\nprint(num_of_ways_to_paint_fence(5, 2))"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "def num_of_paintings(n, k):\n    # if there is only 1 post\n    if n == 1:\n        return k\n    # if there is only 2 posts\n    if n == 2:\n        return k*k\n    # if there is only 3 posts\n    if n == 3:\n        return k*k*k\n    # if there is only 4 posts\n    if n == 4:\n        return k*k*k*k\n    # if there is only 5 posts\n    if n == 5:\n        return k*k*k*k*k\n    # if there is only 6 posts\n    if n == 6:\n        return k*k*k*k*k*k\n    # if there is only 7 posts\n    if n == 7:\n        return k*k*k*k*k*k*k\n    # if there is only 8 posts\n    if n == 8:\n        return k*k*k*k*k*k*k*k\n    # if there is only 9 posts\n    if n == 9:\n        return k*k*k*k*k*k*k*k*k\n    # if there is only 10 posts\n    if n == 10:\n        return k*k*k*k*k*k*k*k*k*k\n    # if there is only 11 posts\n    if n == 11:\n        return k*k*k*k*k*k*k*k*k*k*k\n    # if there is only 12 posts\n    if n == 12:\n        return k*k*k*k*k*k*k*k*k*k*k*k\n    # if there is only 13 posts\n    if n == 13:\n        return k*k*k*k*k*k*k*k*k*k*k*k*k\n    # if there is only 14 posts\n    if n == 14:\n        return k*k*k*k*k*k*k*k*k*k*k*k*k"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    if n==0:\n        return 0\n    if n==1:\n        return k\n    if n==2:\n        return k*k\n    if n==3:\n        return k*k*k\n    if k==1:\n        return 0\n    if k==2:\n        return (n-1)*2\n    if k==3:\n        return (n-1)*4\n    dp = [0]*(n+1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k*k\n    dp[3] = k*k*k\n    for i in range(4, n+1):\n        dp[i] = (dp[i-1]*(k-1) + dp[i-2]*(k-1) + dp[i-3]*(k-1))%(10**9 + 7)\n    return dp[n]\n\nn = 4\nk = 2\nprint(num_of_ways(n, k))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    if n == 3:\n        return k * k * k\n    if n == 4:\n        return k * k * k * k\n    if n < 2:\n        return 0\n    return k * (num_of_ways(n - 1, k) + num_of_ways(n - 2, k))\n\n\ndef test_num_of_ways():\n    assert num_of_ways(1, 3) == 3\n    assert num_of_ways(2, 3) == 9\n    assert num_of_ways(3, 3) == 27\n    assert num_of_ways(4, 3) == 81"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef count_painted_fences(n: int, k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    dp = [0 for _ in range(n + 1)]\n\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] += dp[j] * (k - 1)\n\n        dp[i] += k\n\n    return dp\n\n\nif __name__ == \"__main__\":\n    assert count_painted_fences(2, 2) == [1, 2, 1]\n    assert count_painted_fences(3, 2) == [1, 3, 3, 1]\n    assert count_painted_fences(3, 3) == [1, 4, 7, 12, 20, 32, 52, 62, 62]"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "def number_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    Let's call the number of ways to paint n posts with k colors f(n, k).\n    We have two cases:\n    1. f(n, k) = f(n-1, k) for all 1 <= i <= k, since we can paint the nth post with any of the k colors.\n    2. f(n, k) = f(n-1, k-1) + 2*f(n-1, k) - f(n-1, k-1), since we can paint the nth post with the same color as the previous post\n       (2*f(n-1, k)) or with a different color (f(n-1, k) for the same color and f(n-1, k-1) for the different color)\n    \"\"\"\n    dp = [0] * k\n    dp[0] = 1\n    for _ in range(n):\n        prev = dp.copy()\n        for i in range(1, k):\n            dp[i] = (prev[i] + prev[i-1]) % (10**9 + 7)\n    return dp[-1] % (10**9 + 7)\n\n\nif __name__ == \"__main__\":\n    print(number_of_ways(3, 2))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def num_painted_post(n: int, k: int) -> int:\n    if n < 1 or k < 2:\n        return 0\n\n    # dp[i] represents the number of ways of painting the first i posts.\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n + 1):\n        for j in range(1, k):\n            dp[i] += dp[i - 1] if j != dp[i - 1] else 0\n            dp[i] += dp[i - 2] if j != dp[i - 2] else 0\n\n    return dp[n]"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def fence_painting(n, k):\n    \"\"\"\n    Dynamic Programming Solution\n    Time Complexity: O(n*k)\n    Space Complexity: O(n*k)\n    \"\"\"\n    ways = [[1] * k for _ in range(n)]\n    for i in range(1, n):\n        for j in range(k):\n            ways[i][j] += ways[i - 1][j]\n            if j > 0:\n                ways[i][j] += ways[i - 1][j - 1]\n            if j < k - 1:\n                ways[i][j] += ways[i - 1][j + 1]\n    return ways[-1][-1]\n\n\ndef main():\n    print(\"Total ways: \" +\n          str(fence_painting(3, 2)))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    dp = [0] * (k+1)\n    dp[0] = 1\n    for i in range(1, k+1):\n        dp[i] = dp[i-1] * (k-1)\n    for i in range(2, n+1):\n        for j in range(1, k+1):\n            dp[j] += dp[j-1] * (k-1)\n    return dp[k]\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(3, 2))\n    print(num_of_ways(4, 2))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def num_of_painted_fence(self, n: int, k: int) -> int:\n        dp = [0] * k\n        dp[0] = 1\n        for i in range(1, n):\n            temp = [0] * k\n            for j in range(k):\n                if j - 1 < 0:\n                    temp[j] += dp[j]\n                elif j + 1 >= k:\n                    temp[j] += dp[j - 1]\n                else:\n                    temp[j] += dp[j - 1] + dp[j + 1]\n            dp = temp\n        return sum(dp) % (10 ** 9 + 7)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    result = s.num_of_painted_fence(5, 2)\n    print(result)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def num_ways(n, k):\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n\n    # Base case\n    dp[0][0] = 1\n    dp[0][1] = 1\n\n    # General case\n    for i in range(1, n):\n        for j in range(k):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j + 1]\n            elif j == k - 1:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]\n\n    return dp[-1][-1]\n\n\nn, k = 4, 2\nprint(num_ways(n, k))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def num_of_ways(self, n: int, k: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = k\n        for i in range(2, n + 1):\n            dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    n = 4\n    k = 3\n    out = 11\n    res = Solution().num_of_ways(n, k)\n    assert res == out, (res, out)\n\n    n = 1\n    k = 1\n    out = 1\n    res = Solution().num_of_ways(n, k)\n    assert res == out, (res, out)\n\n    n = 2\n    k = 1\n    out = 1\n    res = Solution().num_of_ways(n, k)\n    assert res == out, (res, out)\n\n    n = 3\n    k = 2\n    out = 3\n    res = Solution().num_of_ways(n, k)\n    assert res == out, (res, out)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from itertools import product\n\n\ndef num_of_ways(n, k):\n    if k == 1:\n        return 1\n    if k == 2:\n        return (n - 1) * n // 2\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, k):\n            if i - 1 >= 1:\n                dp[i] += dp[i - 1]\n            if i - 2 >= 1:\n                dp[i] += dp[i - 2]\n            if i - 3 >= 1:\n                dp[i] += dp[i - 3]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(3, 2))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    # Fill this in.\n    return n-k+1\n\nif __name__ == \"__main__\":\n    input_n = int(input().strip())\n    input_k = int(input().strip())\n    print(num_of_ways(input_n, input_k))"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways(n, k):\n    if n < 2:\n        return k\n\n    if k < 2:\n        return 0\n\n    return sum(num_of_ways(n - 1, c) for c in range(2))\n\n\ndef test_num_of_ways():\n    \"\"\"\n    >>> num_of_ways(1, 1)\n    1\n    >>> num_of_ways(1, 2)\n    2\n    >>> num_of_ways(2, 1)\n    1\n    >>> num_of_ways(2, 2)\n    2\n    >>> num_of_ways(3, 2)\n    4\n    >>> num_of_ways(3, 3)\n    4\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def num_of_ways(n, k):\n    dp = [0] * (k + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i == 1:\n                dp[j] = 1\n            elif i == 2:\n                dp[j] = j\n            else:\n                dp[j] = dp[j - 1] + j * dp[j]\n    return dp[-1]\n\n\nprint(num_of_ways(3, 2))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef num_of_ways(n, k):\n    dp = [1] + [0] * n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - 1 < j:\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += dp[i - 1] - dp[i - 1 - j]\n\n    return dp[n]\n\n\n@lru_cache(maxsize=None)\ndef num_of_ways_2(n, k):\n    if n == 1:\n        return k\n\n    if n == 2:\n        return k * (k - 1)\n\n    return num_of_ways_2(n - 1, k) * k + num_of_ways_2(n - 2, k) * (k - 1)\n\n\nif __name__ == \"__main__\":\n    print(num_of_ways(4, 2))\n    print(num_of_ways_2(4, 2))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def number_of_ways(n: int, k: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = k\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] += dp[j - 1] * dp[i - j]\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert number_of_ways(2, 2) == 3\n    assert number_of_ways(3, 2) == 4\n    assert number_of_ways(3, 3) == 10\n    assert number_of_ways(3, 4) == 40\n    assert number_of_ways(4, 2) == 7\n    assert number_of_ways(4, 3) == 20\n    assert number_of_ways(4, 4) == 84"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def num_of_ways(self, n: int, k: int) -> int:\n        if k == 1:\n            return n\n        if n == 1:\n            return 1\n\n        dp = [0] * (k + 1)\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, k):\n                dp[j] += dp[j - 1]\n        return dp[k]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    result = s.num_of_ways(3, 2)\n    print(result)"
    }
  ]
}