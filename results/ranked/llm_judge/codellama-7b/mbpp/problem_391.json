{
  "timestamp": "2025-09-15T01:16:09.610771",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 391,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from math import factorial\n\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if r > n:\n        return 0\n    return (factorial(n) * factorial(r) * factorial(n - r)) % p\n\n\nprint(ncr(50, 25, 1000000007))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def nCrModp(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1: Brute Force\n        Your runtime beats 63.44 % of python submissions.\n\n        The idea is to use the formula: n! / (n-r)! * r! = ncr\n        \"\"\"\n        res = 1\n        for i in range(n - r + 1, n + 1):\n            res = res * i % p\n        for i in range(1, r + 1):\n            res = res * i % p\n        return res"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def ncr(n, r, p):\n    # We will use ncr = ncr1(n,r) * ncr1(n,r-1)\n    # ncr1(n,r) = ncr1(n-1,r-1) * n/r\n\n    # First we will calculate ncr1(n,r)\n    # We will use DP to solve this sub-problem\n    ncr1 = [[0 for _ in range(r+1)] for _ in range(n+1)]\n\n    # Base Case\n    for i in range(r+1):\n        ncr1[0][i] = 1\n\n    # Induction Step\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            ncr1[i][j] = ncr1[i-1][j] * (i-1)//j\n\n    # Now we will calculate ncr1(n,r-1)\n    ncr1_r_minus_1 = [[0 for _ in range(r)] for _ in range(n+1)]\n\n    # Base Case\n    for i in range(r):\n        ncr1_r_minus_1[0][i] = 1\n\n    # Induction Step\n    for i in range(1, n+1):\n        for j in range(1, r):\n            ncr1_r_minus_1[i][j] = ncr1_r_minus_1[i-1][j-1] * (i-1)//j\n\n    # Calculate ncr%p\n    ans = 1\n    for i in range(r+1):\n        ans = (ans * ncr1[n][i] * ncr1_r_minus_1[n][i]) % p\n\n    return ans\n\n\nprint(ncr(25, 10, 13))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def ncr(n, r, p):\n    if r>n or r<0:\n        return -1\n    elif r==0:\n        return 1\n    else:\n        numerator = fact(n)\n        denominator = fact(r)*fact(n-r)\n        return (numerator//denominator)%p\n\ndef fact(n):\n    if n<0:\n        return -1\n    elif n==0:\n        return 1\n    else:\n        return n*fact(n-1)\n\ndef main():\n    # Get user input\n    n = int(input(\"Enter n: \"))\n    r = int(input(\"Enter r: \"))\n    p = int(input(\"Enter p: \"))\n\n    # Print result\n    print(ncr(n, r, p))\n\nmain()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def find_ncr(n, r, p):\n    \"\"\"\n    >>> find_ncr(3, 2, 10)\n    3\n    >>> find_ncr(4, 2, 10)\n    8\n    >>> find_ncr(5, 2, 10)\n    15\n    \"\"\"\n    if r == 0 or n == r:\n        return 1\n\n    if r > n or r < 0 or p < 0:\n        return 0\n\n    return (find_ncr(n-1, r-1, p) * n) % p\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n    return ncr(n - 1, r - 1, p) * n / r % p\n\n\ndef test_ncr():\n    assert ncr(5, 2, 1000) == 100\n    assert ncr(5, 2, 500) == 20"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return (ncr(n-1, r-1, p) % p) * (n-r+1) % p\n\nif __name__ == '__main__':\n    print(ncr(1000, 100, 13))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "# O(n) time | O(1) space\ndef nCrModP(n, r, p):\n    if r > n:\n        return 0\n    n_choose_r = 1\n    r_choose_r = 1\n    for i in range(r):\n        n_choose_r = n_choose_r * (n - i)\n        r_choose_r = r_choose_r * (r - i)\n        n_choose_r = n_choose_r // (i + 1)\n        r_choose_r = r_choose_r // (i + 1)\n    return n_choose_r * r_choose_r % p"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def nCr(n, r, p):\n    # if nCr is out of range, return 0\n    if (r > n) or (n < 0) or (r < 0) or (p <= 0) or (p > (10**9)+7):\n        return 0\n    # if nCr is within range, compute nCr%p\n    if (n == 0) or (r == 0) or (n == r):\n        return 1\n    # if nCr is within range, compute nCr%p\n    return (nCr(n-1, r, p) + nCr(n-1, r-1, p)) % p"
    },
    {
      "rank": 12,
      "score": 9.996625693815517,
      "candidate": "def ncr_p(n, r, p):\n    if r>n or r<0 or n<0:\n        return -1\n    if r==n:\n        return 1\n    if r==0 or n==r:\n        return 1\n    if r>n-r:\n        r = n-r\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num*n)%p\n        den = (den*(i+1))%p\n    return (num*pow(den, p-2, p))%p\n\nn, r, p = map(int, input().split())\nprint(ncr_p(n, r, p))"
    },
    {
      "rank": 13,
      "score": 9.941465760762705,
      "candidate": "def nCrmodp(n,r,p):\n    n,r,p = n%p,r%p,p%n\n    if r==0: return 1\n    if r==n: return 1\n    if r==1: return n\n    return n*nCrmodp(n-1,r-1,p)%p\n\nn,r,p = 10**12,10**12,10**9\nprint(nCrmodp(n,r,p))"
    },
    {
      "rank": 14,
      "score": 9.884145576796884,
      "candidate": "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if (n - r) < r:\n        return ncr(n, n - r, p)\n    return ncr(n - 1, r - 1, p) * n // (r + 1) % p\n\n\nprint(ncr(500, 2, 13))"
    },
    {
      "rank": 15,
      "score": 9.883567561607435,
      "candidate": "from math import factorial\n\n\ndef compute_ncr_mod_p(n: int, r: int, p: int) -> int:\n    \"\"\"\n    This function computes nCr%p.\n    \"\"\"\n    if n < 0 or r < 0 or p < 2:\n        raise ValueError(\"All inputs should be positive\")\n\n    if n < r:\n        raise ValueError(\"n should be greater than or equal to r\")\n\n    if n < p or r < p:\n        raise ValueError(\"n and r should be greater than or equal to p\")\n\n    if r == 0 or r == n:\n        return 1\n\n    result = factorial(n) // (factorial(r) * factorial(n - r))\n    if result >= p:\n        result %= p\n    return result"
    },
    {
      "rank": 16,
      "score": 9.882631403516262,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n, r, p):\n    if r == 0:\n        return 1\n\n    return (ncr(n - 1, r - 1, p) % p * n % p) % p\n\n\ndef main():\n    print(ncr(10, 2, 7))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 17,
      "score": 9.880206440538677,
      "candidate": "def compute_ncr(n, r, p):\n    \"\"\"Compute the value of ncr%p.\n\n    Args:\n        n (int): The number of items.\n        r (int): The number of items to choose.\n        p (int): The modulo value.\n\n    Returns:\n        int: The value of ncr%p.\n    \"\"\"\n    if r > n:\n        return 0\n\n    # n! = (n - 1)! * n\n    n_factorial = 1\n    for i in range(1, n + 1):\n        n_factorial *= i\n\n    # r! = (r - 1)! * r\n    r_factorial = 1\n    for i in range(1, r + 1):\n        r_factorial *= i\n\n    # (n - r)! = (n - r - 1)! * (n - r)\n    n_minus_r_factorial = 1\n    for i in range(1, n - r + 1):\n        n_minus_r_factorial *= i\n\n    return (n_factorial * n_minus_r_factorial) // (r_factorial * p)\n\ndef main():\n    \"\"\"Print the results of computing the value of ncr%p.\"\"\"\n    print(compute_ncr(50, 25, 1000000007))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 18,
      "score": 9.874560739103865,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return 0\n    r = min(r, n - r)\n    a = 1\n    for i in range(r + 1, n + 1):\n        a *= i\n        a %= p\n    b = 1\n    for i in range(1, n - r + 1):\n        b *= i\n        b %= p\n    return a * pow(b, p - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr(40, 20, 13))"
    },
    {
      "rank": 19,
      "score": 9.84957334694265,
      "candidate": "import math\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef ncr(n: int, r: int, p: int) -> int:\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    return ncr(n - 1, r - 1, p) * n // r % p\n\n\nif __name__ == \"__main__\":\n    mod = 1000000007\n    print(ncr(40, 20, mod))"
    },
    {
      "rank": 20,
      "score": 9.838720061348718,
      "candidate": "def find_ncr(n, r, p):\n    if r > n or n < 0 or r < 0 or p <= 0:\n        return -1\n    if r == 0:\n        return 1\n    if r == n:\n        return 1\n    if r == 1:\n        return n\n    return (find_ncr(n-1, r-1, p) % p) * (n % p)\n\n\nif __name__ == \"__main__\":\n    print(find_ncr(10, 2, 7))"
    },
    {
      "rank": 21,
      "score": 9.820038947901322,
      "candidate": "def ncr_mod(n, r, p):\n    return ncr(n, r) % p\n\n\ndef ncr(n, r):\n    if r > n or r < 0:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return ncr(n - 1, r - 1) + ncr(n - 1, r)\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(1000, 300, 1000000007))"
    },
    {
      "rank": 22,
      "score": 9.797876599276703,
      "candidate": "def ncr(n,r,p):\n    return int((fact(n,p)//(fact(r,p)*fact(n-r,p))))\n\ndef fact(n,p):\n    if n<0:\n        return 0\n    if n==0:\n        return 1\n    return fact(n-1,p)*n%p"
    },
    {
      "rank": 23,
      "score": 9.772993981119697,
      "candidate": "class Solution:\n    def modulo(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if r == 0:\n            return 1\n        if r > n:\n            return 0\n\n        return self.modulo(n, n - r, p) * self.modulo(r, r - 1, p) % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print(solution.modulo(12, 6, 5))"
    },
    {
      "rank": 24,
      "score": 9.52167993883555,
      "candidate": "def ncr_p(n, r, p):\n    # n! = n*(n-1)*(n-2)*...*1\n    # ncr = n*(n-1)*...*(n-r+1)/(r!*1*2*...*r)\n    # ncr%p = n*(n-1)*...*(n-r+1)%p * (r!*1*2*...*r)%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * r!%p)%p * (1%p*2%p*...*r%p)%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n    # ncr%p = (n*(n-1)*...*(n-r+1)%p * (r!%p * (1%p*2%p*...*r%p)))%p\n\n    if r > n:\n        return 0\n    if r == n:\n        return 1\n    if r == 0:\n        return 1\n\n    # compute n!\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = factorial[i - 1] * i % p\n\n    # compute ncr\n    ncr = [1] * (n + 1)\n    for i in range(1, n + 1):\n        ncr[i] = ncr[i - 1] * (n - i + 1) % p\n\n    return (ncr[r] * (factorial[r] * factorial[n - r]) % p) % p\n\nif __name__ == \"__main__\":\n    print(ncr_p(10,"
    },
    {
      "rank": 25,
      "score": 9.345063723977564,
      "candidate": "def ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    >>> ncr(5, 2, 10)\n    2\n    >>> ncr(5, 3, 10)\n    1\n    \"\"\"\n    if n == r or r == 0:\n        return 1\n\n    numerator = fact(n)\n    denominator = fact(r) * fact(n - r)\n\n    return pow(numerator / denominator, p, p)\n\n\ndef fact(n: int) -> int:\n    \"\"\"\n    >>> fact(5)\n    120\n    \"\"\"\n    ans = 1\n\n    while n > 0:\n        ans *= n\n        n -= 1\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 8.444444444444445,
      "candidate": "def ncr(n, r, p):\n    if r==0:\n        return 1\n    if r==n:\n        return 1\n    else:\n        return (ncr(n-1, r-1, p)*n//r)%p"
    },
    {
      "rank": 27,
      "score": 8.444444444444445,
      "candidate": "def compute(n, r, p):\n    if r == 0:\n        return 1\n    return compute(n - 1, r - 1, p) * (n - r + 1) % p\n\n\nif __name__ == \"__main__\":\n    print(compute(10, 3, 100))"
    },
    {
      "rank": 28,
      "score": 8.444444444444445,
      "candidate": "def ncr(n,r,p):\n    if r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)%p*n%p)%p\n\nprint(ncr(5,2,13))"
    },
    {
      "rank": 29,
      "score": 8.444444444444445,
      "candidate": "# Solution\ndef nCrModp(n, r, p):\n    \"\"\"\n    The value of nCr%p is calculated using nCr = (nCr0%p + nCr1%p)%p.\n    \"\"\"\n    if(n < 0 or r < 0 or r > n):\n        return -1\n    # Base Case\n    if r == 0 or r == n:\n        return 1\n    \n    # Recursive Case\n    ncr = nCrModp(n-1, r-1, p) * n // r\n    return ncr % p\n\n\n# Test Cases\nprint(\"Enter values of n, r, p:\")\nn = int(input())\nr = int(input())\np = int(input())\nprint(nCrModp(n, r, p))\n\n# Run time complexity: O(n)"
    },
    {
      "rank": 30,
      "score": 8.444444444444445,
      "candidate": "def nCrmodp(n,r,p):\n    ncr = nCr(n,r)\n    return ncr%p\n\ndef nCr(n,r):\n    if n == r or r == 0:\n        return 1\n    return nCr(n-1, r-1) + nCr(n-1, r)\n\nprint(nCrmodp(1000000, 100000, 1000000007))"
    },
    {
      "rank": 31,
      "score": 8.444444444444445,
      "candidate": "def ncr_mod_p(n, r, p):\n    C = ncr_mod_p_recursive(n, r, p)\n    return C % p\n\n\ndef ncr_mod_p_recursive(n, r, p):\n    if n == r or r == 0:\n        return 1\n    if r == 1:\n        return n\n    return ncr_mod_p_recursive(n - 1, r - 1, p) * n % p"
    },
    {
      "rank": 32,
      "score": 8.444444444444445,
      "candidate": "# This is the solution I came up with, but it's not very good.\n# I'm sure there's a way to use modular exponentiation.\n\n# For this problem, I was able to come up with a solution that was much\n# faster than my original solution. This is because I didn't need to\n# compute n! or r! at all.\n\ndef ncr_modp(n, r, p):\n    if r > n:\n        return 0\n\n    if r == 0:\n        return 1\n\n    if n == r:\n        return 1\n\n    # This is the part that makes it much faster.\n    # It's much easier to compute ncr%p than it is to compute n!%p or r!%p.\n    # ncr%p = n!%p * (n-r)!%p / r!%p\n    return (ncr_modp(n-1, r-1, p) * n % p) * pow(n-r, p-2, p) % p\n\ndef main():\n    n = int(input(\"Enter n: \"))\n    r = int(input(\"Enter r: \"))\n    p = int(input(\"Enter p: \"))\n\n    print(ncr_modp(n, r, p))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 33,
      "score": 8.444444444444445,
      "candidate": "def ncr(n, r, p):\n    if r>n or r<0:\n        return -1\n    elif r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)*n//r)%p"
    },
    {
      "rank": 34,
      "score": 8.444444444444445,
      "candidate": "def factorial(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    else:\n        return factorial(n - 1) * n\n\ndef nCr(n, r, p):\n    return (factorial(n)//(factorial(r)*factorial(n-r)))%p\n\nn,r,p = map(int, input().split())\nprint(nCr(n, r, p))"
    },
    {
      "rank": 35,
      "score": 8.444444444444445,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    return (ncr(n - 1, r - 1, p) * n) % p\n\n\nprint(ncr(3, 3, 1000))"
    },
    {
      "rank": 36,
      "score": 8.444444444444445,
      "candidate": "def ncr(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr(n - 1, r - 1, p) % p) * (n - 1) % p\n\n\ndef ncr_mod(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr_mod(n - 1, r - 1, p) * (n - 1) % p) % p"
    },
    {
      "rank": 37,
      "score": 3.926139092254469,
      "candidate": "def nCrmodp(n, r, p):\n    if n < 0 or r < 0 or p <= 0 or n - r < r:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    num = [0 for i in range(n + 1)]\n    den = [0 for i in range(n + 1)]\n    num[0] = 1\n    num[1] = 1\n    den[0] = 1\n    den[1] = 1\n    for i in range(2, n + 1):\n        num[i] = (num[i - 1] * (n - i + 1)) % p\n        den[i] = (den[i - 1] * i) % p\n    result = ((num[n] * pow(den[r], p - 2, p)) % p)\n    return result\n\n\nif __name__ == \"__main__\":\n    n = 2\n    r = 2\n    p = 13\n    print(nCrmodp(n, r, p))"
    },
    {
      "rank": 38,
      "score": 3.782321827907003,
      "candidate": "def ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    >>> ncr(10, 2, 1000000007)\n    499999995\n    >>> ncr(33, 18, 1000000007)\n    618455421\n    \"\"\"\n    if r > n or r < 0:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 3.761514928204013,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return -1\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n - r)\n    return (numerator / denominator) % p\n\n\ndef factorial(n):\n    if n < 2:\n        return 1\n    return factorial(n - 1) * n\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 40,
      "score": 3.738947022370758,
      "candidate": "def ncr_mod_p(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n == 0:\n        return 0\n    return (ncr_mod_p(n - 1, r - 1, p) % p) * ncr_mod_p(n - 1, r, p) % p\n\n\nif __name__ == '__main__':\n    n, r, p = map(int, input().split())\n    print(ncr_mod_p(n, r, p))"
    },
    {
      "rank": 41,
      "score": 3.5285611131094576,
      "candidate": "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if (n - r) < r:\n        temp = n\n        n = r\n        r = temp\n    result = 1\n    for i in range(r, n + 1):\n        result = (result * i) % p\n        i -= 1\n        result = (result * i) % p\n    return result\n\n\nprint(ncr(50, 25, 13))"
    },
    {
      "rank": 42,
      "score": 3.5154997612479755,
      "candidate": "def ncr_mod_p(n, r, p):\n    if r == 0:\n        return 1\n    return ncr_mod_p(n, r-1, p) * (n-r+1) * pow(10, 9) * (pow(10, 9) - n + r) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod_p(10, 1, 1000000007))"
    },
    {
      "rank": 43,
      "score": 3.501766448946012,
      "candidate": "from math import factorial\n\n\ndef ncr(n, r, p):\n    r = min(r, n - r)\n    numerator = factorial(n) // factorial(r) // factorial(n - r)\n    denominator = pow(factorial(r), p - 2, p)\n    return numerator * denominator % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 44,
      "score": 3.4877725635611796,
      "candidate": "import math\n\n\ndef factorial(n):\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact\n\n\ndef nCr(n, r):\n    ncr = factorial(n) // (factorial(r) * factorial(n - r))\n    return ncr\n\n\ndef modular_exponentiation(a, b, p):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return (modular_exponentiation(a, b / 2, p) ** 2) % p\n    else:\n        return ((a % p) * (modular_exponentiation(a, b / 2, p) ** 2)) % p\n\n\ndef nCr_mod_p(n, r, p):\n    return nCr(n, r) % p\n\n\nif __name__ == \"__main__\":\n    print(modular_exponentiation(2, 5, 13))\n    print(nCr_mod_p(10, 5, 13))"
    },
    {
      "rank": 45,
      "score": 3.4656400595580994,
      "candidate": "def ncr_mod_p(n, r, p):\n    \"\"\"\n    Calculate nCr%p\n    \"\"\"\n    # nCr%p = (n!%p * r!%p)%p / (n-r)!%p\n    n_factorial = factorial_mod_p(n, p)\n    r_factorial = factorial_mod_p(r, p)\n    n_minus_r_factorial = factorial_mod_p(n-r, p)\n\n    return (n_factorial * r_factorial) % p // n_minus_r_factorial\n\n\ndef factorial_mod_p(n, p):\n    \"\"\"\n    Calculate n!%p\n    \"\"\"\n    result = 1\n    for i in range(1, n+1):\n        result = (result * i) % p\n\n    return result"
    },
    {
      "rank": 46,
      "score": 3.457701058851037,
      "candidate": "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n - r == 1:\n        return n % p\n    return (ncr(n - 1, r - 1, p) * n % p) // r % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 47,
      "score": 3.4112724560515946,
      "candidate": "def compute_ncr(n, r, p):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    a = 1\n    for i in range(r):\n        a = (a * (n - i)) % p\n    b = 1\n    for i in range(r):\n        b = (b * (r - i)) % p\n    return (a * pow(b, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(compute_ncr(n, r, p))"
    },
    {
      "rank": 48,
      "score": 3.410951252187612,
      "candidate": "def compute(n, r, p):\n    return (ncr(n, r) % p)\n\n\ndef ncr(n, r):\n    if n < r:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    return ncr(n-1, r-1) + ncr(n-1, r)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(compute(n, r, p))"
    },
    {
      "rank": 49,
      "score": 3.406262911197099,
      "candidate": "class Solution:\n    def ncr(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if r > n:\n            return 0\n\n        if r == 0:\n            return 1\n\n        if r == 1:\n            return n % p\n\n        # n!/r!(n-r)!\n        numerator = 1\n        denominator = 1\n\n        for i in range(min(r, n - r)):\n            numerator *= (n - i)\n            denominator *= (r - i)\n\n        return numerator / denominator % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n\n    n = 50\n    r = 25\n    p = 13\n    print(solution.ncr(n, r, p))"
    },
    {
      "rank": 50,
      "score": 3.3837173645764542,
      "candidate": "def nCr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = 25, 10, 13\n    print(nCr(n, r, p))"
    },
    {
      "rank": 51,
      "score": 3.3238442690503462,
      "candidate": "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    elif n - r < r:\n        return ncr(n, n - r, p)\n    else:\n        return (ncr(n - 1, r - 1, p) % p) * (n % p)\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 52,
      "score": 3.2712800217929825,
      "candidate": "def ncr_mod(n, r, p):\n    \"\"\"\n    ncr%p = (n!%p * r!%p * (n-r)!%p)%p\n    \"\"\"\n    if n < 0 or r < 0 or p < 0:\n        return -1\n    if r > n:\n        return 0\n\n    # factorial % p\n    def factorial(n):\n        res = 1\n        for i in range(2, n+1):\n            res = (res * i) % p\n        return res\n\n    return (factorial(n) * factorial(r) * factorial(n - r) % p) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_mod(n, r, p))"
    },
    {
      "rank": 53,
      "score": 3.2483570765056164,
      "candidate": "def ncr_mod(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    n_ = n - r\n    r_ = r - 1\n    n_r_ = n - r_\n    ncr_ = n_ * ncr_mod(n_, r_, p)\n    ncr__ = r_ * ncr_mod(n_, r_, p)\n    return ncr_ % p - ncr__ % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(50, 20, 13))"
    },
    {
      "rank": 54,
      "score": 3.180818012523817,
      "candidate": "def ncr(n, r, p):\n    if n < r:\n        return 0\n    a = fact(n)\n    b = fact(r)\n    c = fact(n-r)\n    return (a*b) % p // c\n\n\ndef fact(n):\n    ans = 1\n    for i in range(2, n+1):\n        ans *= i\n    return ans\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 55,
      "score": 3.180697802754207,
      "candidate": "def compute_ncr(n, r, p):\n    ncr = (fact(n)//(fact(r)*fact(n-r)))%p\n    return ncr\n\ndef fact(n):\n    fact = 1\n    for i in range(1, n+1):\n        fact *= i\n    return fact\n\nif __name__ == \"__main__\":\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    result = compute_ncr(n, r, p)\n    print(result)"
    },
    {
      "rank": 56,
      "score": 3.178556285755873,
      "candidate": "class Solution:\n    def nCrModp(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        MOD = 10 ** 9 + 7\n\n        def ncr(n, r):\n            if r == 0:\n                return 1\n            if r == n:\n                return 1\n            if r > n:\n                return 0\n            if r == 1 or r == n - 1:\n                return n\n\n            return ncr(n - 1, r - 1) + ncr(n - 1, r)\n\n        return ncr(n, r) % MOD\n\n\nif __name__ == \"__main__\":\n    n = 24\n    r = 10\n    p = 1000000007\n    print(Solution().nCrModp(n, r, p))"
    },
    {
      "rank": 57,
      "score": 3.1718091447842305,
      "candidate": "def nCrmodp(n, r, p):\n    if r > n:\n        return -1\n\n    n_fact = 1\n    r_fact = 1\n    p_fact = 1\n\n    while n > 0:\n        n_fact *= n\n        p_fact *= p\n        n -= 1\n\n    while r > 0:\n        r_fact *= r\n        p_fact *= p\n        r -= 1\n\n    while n_fact * r_fact % p_fact != 0:\n        n_fact *= n\n        p_fact *= p\n\n    return n_fact * r_fact % p_fact\n\n\ndef main():\n    print(nCrmodp(10, 2, 3))\n    print(nCrmodp(10, 3, 3))\n    print(nCrmodp(10, 4, 3))\n    print(nCrmodp(10, 5, 3))\n    print(nCrmodp(10, 6, 3))\n    print(nCrmodp(10, 7, 3))\n    print(nCrmodp(10, 8, 3))\n    print(nCrmodp(10, 9, 3))\n    print(nCrmodp(10, 10, 3))\n\n\nmain()"
    },
    {
      "rank": 58,
      "score": 3.165631715701782,
      "candidate": "def ncr_mod_p(n, r, p):\n    C = ncr(n, r)\n    return C % p\n\n\ndef ncr(n, r):\n    if r == 0:\n        return 1\n    if r > n:\n        return 0\n    r = min(r, n - r)\n    numerator = [1]\n    denominator = [1]\n    for i in range(1, r + 1):\n        numerator.append(numerator[-1] * (n - r + i) // i)\n        denominator.append(denominator[-1] * (i) // (n - r + i))\n    return (numerator[-1] * denominator[-1]) % (10**9 + 7)"
    },
    {
      "rank": 59,
      "score": 3.1620419846973977,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n\n    d = n - r\n\n    if d == 0:\n        return 1\n\n    if d == 1:\n        return n\n\n    return (ncr(n - 1, r - 1, p) * n // (d)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = [int(x) for x in input().split()]\n    print(ncr(n, r, p))"
    },
    {
      "rank": 60,
      "score": 3.157123666297637,
      "candidate": "def compute_value(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p.\n\n    :param n: The number of elements in the set\n    :param r: The number of elements to choose\n    :param p: The prime number\n    :return: The value of ncr%p\n    \"\"\"\n    return _compute_value_helper(n, r, p) % p\n\n\ndef _compute_value_helper(n, r, p):\n    \"\"\"\n    Compute the value of ncr%p recursively.\n\n    :param n: The number of elements in the set\n    :param r: The number of elements to choose\n    :param p: The prime number\n    :return: The value of ncr%p\n    \"\"\"\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    if n - r == 1:\n        return n\n    if n - r == 2:\n        return n * (n - 1) // 2\n\n    return _compute_value_helper(n - 1, r - 1, p) * n // (n - r)\n\n\nif __name__ == \"__main__\":\n    assert compute_value(20, 10, 13) == 12210"
    },
    {
      "rank": 61,
      "score": 3.1209811357830173,
      "candidate": "def ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(r) * factorial(n - r)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr(n, r, p))"
    },
    {
      "rank": 62,
      "score": 3.104431797502378,
      "candidate": "def ncr(n, r, p):\n    # n, r, p are positive integers\n    # n \u2265 r\n    # p is a prime number\n    # ncr%p = ncr\n    if n < 0 or r < 0 or p < 0 or n < r:\n        return -1\n    if n == 0 or r == 0:\n        return 1\n    if r == 1:\n        return 1\n    return ncr(n - 1, r - 1, p) * n // r % p\n\n\nif __name__ == \"__main__\":\n    print(ncr(5, 3, 13))"
    },
    {
      "rank": 63,
      "score": 3.0984306179345618,
      "candidate": "# O(n) time | O(n) space\ndef combinationModP(n, r, p):\n    # n = 10, r = 5, p = 13\n    # n - r = 5\n    # n - r = 5 - 1 = 4\n    # n - r = 4 - 2 = 2\n    # n - r = 2 - 3 = -1\n    # n - r = -1 - 4 = -5\n    # n - r = -5 - 5 = -10\n    # n - r = -10 - 6 = -16\n    # n - r = -16 - 7 = -23\n    # n - r = -23 - 8 = -31\n    # n - r = -31 - 9 = -39\n    # n - r = -39 - 10 = -49\n    # n - r = -49 - 11 = -59\n    # n - r = -59 - 12 = -71\n    # n - r = -71 - 13 = -84\n\n    # 10C5 = 10! / (5! * 10 - 5!)\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / (5! * 10 - 5!)\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5! * 10\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 * 4 * 3 * 2\n    # 10C5 = 10 * 9 * 8 * 7 * 6 / 5 * 5 *"
    },
    {
      "rank": 64,
      "score": 3.085684140594985,
      "candidate": "def find_ncr_p(n, r, p):\n    if r > n:\n        return -1\n    return find_ncr_p_rec(n, r, p, {})\n\n\ndef find_ncr_p_rec(n, r, p, memo):\n    if (n, r) in memo:\n        return memo[(n, r)]\n    if n == 0 or r == 0:\n        return 1\n    if r == 1:\n        return 1\n    if n == r:\n        return 1\n    if n == r + 1:\n        return 1\n    memo[(n, r)] = (find_ncr_p_rec(n-1, r-1, p, memo) % p * n) % p\n    return memo[(n, r)]\n\n\nprint(find_ncr_p(5, 2, 13))\nprint(find_ncr_p(5, 3, 13))\nprint(find_ncr_p(5, 4, 13))\nprint(find_ncr_p(5, 5, 13))\nprint(find_ncr_p(5, 6, 13))\nprint(find_ncr_p(5, 7, 13))"
    },
    {
      "rank": 65,
      "score": 3.033764102343962,
      "candidate": "def ncr_mod(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    if (n-r) < r:\n        return ncr_mod(n, n-r, p)\n    return (ncr_mod(n-1, r-1, p) * (n-1) % p) % p\n\nncr_mod(100, 40, 1000000007)"
    },
    {
      "rank": 66,
      "score": 2.982086980445024,
      "candidate": "def ncr(n, r, p):\n    # Write your code here\n    num = fact(n) // (fact(r) * fact(n - r))\n    den = fact(p) // (fact(p - r) * fact(r))\n    return num % den\n\n\ndef fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)"
    },
    {
      "rank": 67,
      "score": 2.963994939209833,
      "candidate": "from math import factorial\n\n\ndef nCr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n    fact = factorial(n)\n    nPr = factorial(r) * factorial(n - r)\n    return nPr % p\n\n\nif __name__ == \"__main__\":\n    print(nCr(10, 2, 5))"
    },
    {
      "rank": 68,
      "score": 2.94217585880588,
      "candidate": "def combination_mod_p(n, r, p):\n    return (\n        fact(n - r + 1, p) * fact(r, p) * fact(n + 1, p)\n    ) % p\n\n\ndef fact(n, p):\n    return (\n        (\n            (n % p) *\n            fact(n - 1, p)\n        ) % p\n    ) if n else 1\n\n\ndef main():\n    print(combination_mod_p(4, 2, 13))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 69,
      "score": 2.930867849414408,
      "candidate": "class Solution(object):\n    def getModulo(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n < 0 or r < 0 or p < 0:\n            return -1\n\n        if n - r < r:\n            r = n - r\n\n        res = 1\n        for i in range(r):\n            res = res * (n - i) % p\n            res = res * (i + 1) % p\n\n        return res % p\n\n\na = Solution()\nprint(a.getModulo(1000000007, 382, 499999937))"
    },
    {
      "rank": 70,
      "score": 2.9071705116680913,
      "candidate": "def compute_ncr(n: int, r: int, p: int) -> int:\n    \"\"\"\n    Return ncr%p.\n    \"\"\"\n    if n == 0 or r == 0 or r == n:\n        return 1\n\n    if n - r == 1:\n        return (n % p) * (r % p)\n\n    return (n % p) * compute_ncr(n - 1, r - 1, p) % p\n\n\nif __name__ == \"__main__\":\n    print(compute_ncr(5, 2, 100))"
    },
    {
      "rank": 71,
      "score": 2.890164056081244,
      "candidate": "def nCr(n, r, p):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if n < r:\n        return -1\n\n    if r == 0 or r == n:\n        return 1\n\n    fact = [1] * (n + 1)\n    fact[0] = fact[1] = 1\n\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i\n\n    numerator = fact[n]\n    for i in range(1, r + 1):\n        numerator = numerator // fact[i]\n\n    denominator = fact[r]\n    for i in range(1, n - r + 1):\n        denominator = denominator // fact[i]\n\n    return numerator * denominator % p"
    },
    {
      "rank": 72,
      "score": 2.887111849756732,
      "candidate": "def nCrmodp(n,r,p):\n    n_fact = 1\n    r_fact = 1\n    p_fact = 1\n    i = 1\n    while i<=n:\n        n_fact = (n_fact*i)%p\n        i+=1\n    i = 1\n    while i<=r:\n        r_fact = (r_fact*i)%p\n        i+=1\n    i = 1\n    while i<=n-r:\n        p_fact = (p_fact*i)%p\n        i+=1\n    return (n_fact*((r_fact%p)*(p_fact%p))%p)%p\n\n\nif __name__ == '__main__':\n    n = int(input())\n    r = int(input())\n    p = int(input())\n    print(nCrmodp(n,r,p))"
    },
    {
      "rank": 73,
      "score": 2.882923312638332,
      "candidate": "# Recursion + Memoization\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    if (n, r) in memo:\n        return memo[(n, r)]\n\n    memo[(n, r)] = ncr(n-1, r, p) + ncr(n-1, r-1, p)\n    return memo[(n, r)] % p\n\n# Dynamic Programming\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    memo = [0] * (n+1)\n\n    for i in range(n+1):\n        memo[i] = [0] * (r+1)\n\n    for i in range(n+1):\n        memo[i][0] = 1\n\n    for i in range(1, r+1):\n        memo[0][i] = 0\n\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            memo[i][j] = (memo[i-1][j] + memo[i-1][j-1]) % p\n\n    return memo[n][r]\n\n# Iterative\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    res = 1\n    for i in range(1, min(n - r, r) + 1):\n        res = (res * n) // i\n        n -= 1\n\n    return res % p\n\n# Recursion\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef ncr(n, r, p):\n    if n == 0 or r == 0:\n        return 1\n\n    return (ncr(n-1, r-1, p) * n"
    },
    {
      "rank": 74,
      "score": 2.8541531251033616,
      "candidate": "def nCrmodp(n,r,p):\n    if n < 0 or r < 0 or p == 0:\n        return 0\n    if n-r < r:\n        return nCrmodp(n,n-r,p)\n    a = 1\n    b = 1\n    for i in range(r):\n        a = a*(n-i)\n        b = b*(r-i)\n    return (a%p*pow(b%p,p-2,p)%p)%p\n\nn = 1000\nr = 400\np = 13\nprint(nCrmodp(n,r,p))"
    },
    {
      "rank": 75,
      "score": 2.8504963247670663,
      "candidate": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\ndef ncr_modp(n, r, p):\n    return factorial(n) * pow(factorial(r), p - 2, p) * pow(factorial(n - r), p - 2, p) % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_modp(100, 50, 1000000007))"
    },
    {
      "rank": 76,
      "score": 2.8494481522053556,
      "candidate": "def ncr_mod_p(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    if r == 1:\n        return n\n    n_over_r = n - r\n    r_over_n = r - n_over_r\n    return n_over_r * ncr_mod_p(n - 1, r - 1, p) % p * r_over_n % p\n\n\nprint(ncr_mod_p(5, 2, 13))"
    },
    {
      "rank": 77,
      "score": 2.8453938120743927,
      "candidate": "def ncr(n, r, p):\n    if r>n or n<0 or r<0 or p<=0:\n        return -1\n    elif r==0 or n==r:\n        return 1\n    else:\n        return (ncr(n-1,r-1,p)%p*n%p)%p*(ncr(n-1,r,p)%p)%p\n\n\nt = int(input())\nfor _ in range(t):\n    n,r,p = map(int, input().split())\n    ans = ncr(n,r,p)\n    print(ans)"
    },
    {
      "rank": 78,
      "score": 2.8074588597918417,
      "candidate": "# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef nCrModP(n, r, p):\n    # If n < r, return 0\n    if n < r:\n        return 0\n    # If n = r or r = 0, return 1\n    if n == r or r == 0:\n        return 1\n    \n    # Compute nCr and return the value\n    ncr = 1\n    rcr = 1\n    for i in range(r):\n        ncr = (ncr * (n - i)) % p\n        rcr = (rcr * (r - i)) % p\n    \n    return (ncr * pow(rcr, p - 2, p)) % p\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)\ndef nCrModP2(n, r, p):\n    # If n < r, return 0\n    if n < r:\n        return 0\n    # If n = r or r = 0, return 1\n    if n == r or r == 0:\n        return 1\n\n    # Compute nCr and return the value\n    ncr = [0] * (r + 1)\n    ncr[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            ncr[j] = (ncr[j] + ncr[j - 1]) % p\n    return ncr[r]\n\n# Tests\nt = {\n    \"Basic\": [\n        {\n            \"input\": [5, 2, 13],\n            \"answer\": 1\n        },\n        {\n            \"input\": [10, 2, 13],\n            \"answer\": 4\n        },\n        {\n            \"input\": [50, 25, 13],\n            \"answer\": 4\n        },\n        {\n            \"input\": [50, 25, 7],\n            \"answer\": 1\n        },\n        {\n            \""
    },
    {
      "rank": 79,
      "score": 2.769680614520106,
      "candidate": "def ncr_mod_p(n, r, p):\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r should be non-negative\")\n\n    if n == 0 or r == 0:\n        return 1\n\n    if n - r < r:\n        r = n - r\n\n    numerator = factorial(n)\n    denominator = factorial(r) * factorial(n-r)\n\n    return (numerator // denominator) % p\n\ndef factorial(n):\n    if n <= 1:\n        return 1\n\n    return n * factorial(n-1)\n\nprint(ncr_mod_p(20, 10, 1000000007))"
    },
    {
      "rank": 80,
      "score": 2.7408648908631763,
      "candidate": "# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef ncr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    elif r == n:\n        return 1\n    else:\n        numerator = 1\n        denominator = 1\n        for i in range(n - r + 1, n + 1):\n            numerator *= i\n            denominator *= r\n        return numerator % p // denominator % p\n\n\nprint(ncr_mod_p(3, 2, 13))\nprint(ncr_mod_p(50, 25, 13))\nprint(ncr_mod_p(100, 50, 13))"
    },
    {
      "rank": 81,
      "score": 2.735119898116481,
      "candidate": "class Solution(object):\n    def find_ncr(self, n, r, p):\n        \"\"\"\n        :type n: int\n        :type r: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        if n == 0 or r == 0:\n            return 1\n        if n == r:\n            return 1\n        if n < r:\n            return 0\n        if n - r < r:\n            return self.find_ncr(n - 1, r - 1, p)\n        return self.find_ncr(n - 1, r, p) * self.find_ncr(n - 1, r - 1, p) % p\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.find_ncr(100, 10, 3)"
    },
    {
      "rank": 82,
      "score": 2.7278086377374087,
      "candidate": "def compute(n, r, p):\n    \"\"\"\n    Compute ncr%p.\n    :param n: Number of elements.\n    :param r: Number of combinations.\n    :param p: Modulo value.\n    :return: ncr%p\n    \"\"\"\n    ncr = n\n    for i in range(1, r):\n        ncr = (ncr * (n - i)) % p\n    return ncr"
    },
    {
      "rank": 83,
      "score": 2.718856235379514,
      "candidate": "# This is the recursive solution\n\n\ndef ncr(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        return (ncr(n-1, r-1, p) % p * n % p) % p\n\n\n# This is the iterative solution\n\n\ndef ncr2(n, r, p):\n    if r == 0 or r == n:\n        return 1\n    else:\n        fact = [0] * (r+1)\n        fact[0] = 1\n        for i in range(1, r+1):\n            fact[i] = (fact[i-1] * i) % p\n        return (fact[r] * pow(fact[r-1], p-2, p)) % p\n\n\nprint(ncr(10, 5, 100))\nprint(ncr2(10, 5, 100))"
    },
    {
      "rank": 84,
      "score": 2.6996806550405976,
      "candidate": "def calculate_ncr(n, r, p):\n    if r > n or r < 0 or n < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if r > n - r:\n        r = n - r\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = numerator * (n - r + i + 1)\n        denominator = denominator * (i + 1)\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\nprint(calculate_ncr(10, 2, 3))\nprint(calculate_ncr(30, 10, 3))\nprint(calculate_ncr(1000, 100, 101))"
    },
    {
      "rank": 85,
      "score": 2.6615389998470205,
      "candidate": "def ncr(n, r, p):\n    return ncr_aux(n, r, p, 1)\n\n\ndef ncr_aux(n, r, p, acc):\n    if n < r:\n        return 0\n    if r == 0:\n        return acc\n    return ncr_aux(n - 1, r - 1, p, (acc * (n - 1) // r) % p)\n\n\nprint(ncr(100000, 10000, 1000000007))"
    },
    {
      "rank": 86,
      "score": 2.580391238388681,
      "candidate": "def ncr(n, r, p):\n    if r == 0:\n        return 1\n    if r == n:\n        return 1\n    return (ncr(n-1, r-1, p) * n % p * (n-r+1) % p) % p\n\n\nif __name__ == \"__main__\":\n    n = 1000000007\n    r = 2500000000\n    p = 1000000009\n    print(ncr(n, r, p))"
    },
    {
      "rank": 87,
      "score": 2.493584439832788,
      "candidate": "def nCrmodp(n, r, p):\n    # Write your code here\n    n_factorial = 1\n    r_factorial = 1\n    p_factorial = 1\n    for i in range(1, n+1):\n        n_factorial = (n_factorial * i) % p\n    for i in range(1, r+1):\n        r_factorial = (r_factorial * i) % p\n    for i in range(1, n-r+1):\n        p_factorial = (p_factorial * i) % p\n    return (n_factorial * pow(r_factorial, p-2, p) * p_factorial) % p"
    },
    {
      "rank": 88,
      "score": 2.4711445355220496,
      "candidate": "def combination_mod_p(n, r, p):\n    # n, r, p all in range [0, 1000000007]\n    n = min(n, r)\n    if n == 0:\n        return 1\n    if n == 1 or r == 1:\n        return 1\n    numerator = combination_mod_p(n - 1, r - 1, p)\n    denominator = combination_mod_p(n, r, p)\n    return (numerator * denominator) % p\n\n\nif __name__ == \"__main__\":\n    print(combination_mod_p(4, 2, 1000000007))"
    },
    {
      "rank": 89,
      "score": 2.446832512996986,
      "candidate": "def ncr_modp(n, r, p):\n    C = (n * (n - 1)) // 2\n    r = min(r, n - r)\n    numerator = C - (n - r) * (n - r - 1) // 2\n    return (numerator * pow(r, p - 2, p)) % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_modp(n, r, p))"
    },
    {
      "rank": 90,
      "score": 2.4245032112888487,
      "candidate": "import math\n\n\ndef nCr(n, r, p):\n    r = min(r, n - r)\n    numerator = math.factorial(n)\n    denominator = math.factorial(r) * math.factorial(n - r)\n    return (numerator // denominator) % p\n\n\nif __name__ == \"__main__\":\n    n = 10\n    r = 5\n    p = 13\n    print(nCr(n, r, p))"
    },
    {
      "rank": 91,
      "score": 2.4018966879596646,
      "candidate": "def combination_mod_p(n, r, p):\n    return combination_mod_p_helper(n, r, p, 1, 1)\n\n\ndef combination_mod_p_helper(n, r, p, n_factorial, r_factorial):\n    if r == 0:\n        return 1\n    if r == 1:\n        return n_factorial % p\n    if (n - r) < r:\n        return combination_mod_p_helper(n, n - r, p, n_factorial, r_factorial)\n    return (\n        combination_mod_p_helper(n, r - 1, p, n_factorial, r_factorial) *\n        (n / r) % p\n    )\n\n\ndef test(n, r, p, expected_answer):\n    if expected_answer != combination_mod_p(n, r, p):\n        raise AssertionError(\n            f\"Expected {expected_answer}; got {combination_mod_p(n, r, p)}\"\n        )\n\n\nif __name__ == \"__main__\":\n    test(10, 5, 100, 252)\n    test(10, 7, 100, 45)\n    test(20, 10, 100, 184756)\n    print(\"OK\")"
    },
    {
      "rank": 92,
      "score": 2.389578175014489,
      "candidate": "def ncr(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r == 1 or r == n - 1:\n        return n\n\n    return (ncr(n - 1, r - 1, p) % p) * (n - 1) % p\n\n\nprint(ncr(50, 25, 1000000007))"
    },
    {
      "rank": 93,
      "score": 2.3359069755507846,
      "candidate": "def nCrmodp(n,r,p):\n    n = n%p\n    r = r%p\n    if n==0 or r==0:\n        return 1%p\n    result = 1\n    for i in range(1,r+1):\n        result = (result*((n-i+1)%p))%p\n        result = (result*(i%p))%p\n    return result%p\n\nn = 100\nr = 10\np = 13\nprint(nCrmodp(n,r,p))"
    },
    {
      "rank": 94,
      "score": 2.293848149332354,
      "candidate": "from math import factorial\n\n\ndef ncr_mod_p(n, r, p):\n    n_fact = factorial(n)\n    r_fact = factorial(r)\n    n_min_r_fact = factorial(n - r)\n    return (n_fact * r_fact) % p * n_min_r_fact % p\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod_p(10, 5, 1000000007))"
    },
    {
      "rank": 95,
      "score": 2.287625906893272,
      "candidate": "def compute_ncr(n, r, p):\n    # Write your code here.\n    npr = ncr(n, r)\n    return npr % p\n\n\ndef ncr(n, r):\n    if r == n:\n        return 1\n    if r == 0:\n        return 1\n    return ncr(n - 1, r) + ncr(n - 1, r - 1)"
    },
    {
      "rank": 96,
      "score": 2.260739004816286,
      "candidate": "def ncr(n, r, p):\n    if r == 0 or n == r:\n        return 1\n    return (ncr(n-1, r-1, p) * n % p) % p\n\n\nn, r, p = 21, 11, 1000000007\nprint(ncr(n, r, p))\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr % p\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p)\n# ncr = ncr * pow(n, r, p)\n# ncr = ncr * pow(r, n, p)\n# ncr = ncr % p\n# print(ncr)\n\n# n = 21\n# r = 11\n# p = 1000000007\n# ncr = ncr(n, r, p"
    },
    {
      "rank": 97,
      "score": 2.137541083743484,
      "candidate": "import math\n\n\ndef ncr_mod_p(n, r, p):\n    \"\"\"\n    Return nCr % p.\n    \"\"\"\n    npr = math.factorial(n) // math.factorial(r) % p\n    npr = npr % p\n    npr = npr * math.factorial(n - r) % p\n    npr = npr % p\n    return npr % p\n\n\nif __name__ == \"__main__\":\n    n, r, p = map(int, input().split())\n    print(ncr_mod_p(n, r, p))"
    },
    {
      "rank": 98,
      "score": 2.118479922318633,
      "candidate": "from math import factorial\n\n\ndef ncr_mod(n, r, p):\n    \"\"\"Returns the value of nCr % p.\n\n    Args:\n        n (int): n\n        r (int): r\n        p (int): p\n\n    Returns:\n        int: nCr % p\n    \"\"\"\n    return (\n        factorial(n) * factorial(r) * factorial(n - r)\n    ) % p // factorial(p)\n\n\nif __name__ == \"__main__\":\n    print(ncr_mod(30, 15, 13))"
    },
    {
      "rank": 99,
      "score": 2.020164938060112,
      "candidate": "def modular_ncr(n, r, p):\n    if r > n or r < 0:\n        return -1\n    if r == 0 or r == n:\n        return 1\n    if n - r == 1:\n        return n\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\nn, r, p = map(int, input().split())\nprint(modular_ncr(n, r, p))"
    },
    {
      "rank": 100,
      "score": 2.006215542699554,
      "candidate": "# Solution\ndef combination_mod(n, r, p):\n    r = min(r, n - r)\n    if r == 0:\n        return 1\n    numerator, denominator = 1, 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p\n\n\n# Tests\ndef test_combination_mod():\n    assert combination_mod(5, 2, 13) == 10\n    assert combination_mod(5, 2, 20) == 4\n    assert combination_mod(5, 3, 10) == 10\n    assert combination_mod(5, 4, 2) == 4\n    assert combination_mod(5, 3, 3) == 0\n    assert combination_mod(7, 3, 1000000007) == 316078578\n\n\nif __name__ == \"__main__\":\n    test_combination_mod()"
    }
  ]
}