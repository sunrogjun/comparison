{
  "timestamp": "2025-09-15T00:33:00.240038",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 297,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_products(numbers1: List[int], numbers2: List[int], length: int) -> List[int]:\n    \"\"\"\n    This function finds the largest products from two lists.\n    :param numbers1: list of numbers.\n    :param numbers2: list of numbers.\n    :param length: length of the list of products.\n    :return: list of largest products.\n    >>> max_products([1, 2, 3, 4], [2, 3, 4, 5], 3)\n    [24, 30, 24]\n    >>> max_products([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 4)\n    [120, 180, 120, 150]\n    >>> max_products([-1, -2, -3, -4], [2, 3, 4, 5], 3)\n    [-6, -12, -6]\n    \"\"\"\n    if len(numbers1) != len(numbers2):\n        raise ValueError(\"Two lists should be of same length\")\n    if length > len(numbers1):\n        raise ValueError(\"The length should be smaller than the length of the lists\")\n    if length <= 0:\n        raise ValueError(\"The length should be greater than zero\")\n    if not numbers1 or not numbers2:\n        raise ValueError(\"The lists should not be empty\")\n\n    products = []\n\n    for index1, value1 in enumerate(numbers1):\n        for index2, value2 in enumerate(numbers2):\n            if index1 < index2:\n                product = value1 * value2\n                products.append(product)\n\n    return sorted(products, reverse=True)[:length]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from collections import defaultdict\nfrom typing import List\n\n\ndef find_largest_products(list_one: List[int], list_two: List[int], num: int) -> List[int]:\n    \"\"\"\n    We can use two pointers to find the largest product of the two lists.\n    To find the largest product, we can sort the two lists and then iterate through\n    them from the end to find the largest product.\n\n    The problem is that we can't sort the two lists in-place, so we have to make\n    copies of them.\n    \"\"\"\n    list_one_copy = list_one[:]\n    list_two_copy = list_two[:]\n\n    list_one_copy.sort(reverse=True)\n    list_two_copy.sort(reverse=True)\n\n    largest_products = []\n\n    for index in range(num):\n        largest_products.append(\n            list_one_copy[index] * list_two_copy[index]\n        )\n\n    return largest_products\n\n\ndef find_largest_products_in_place(list_one: List[int], list_two: List[int], num: int) -> List[int]:\n    \"\"\"\n    We can use two pointers to find the largest product of the two lists.\n    To find the largest product, we can sort the two lists and then iterate through\n    them from the end to find the largest product.\n\n    The problem is that we can't sort the two lists in-place, so we have to make\n    copies of them.\n    \"\"\"\n    list_one_copy = list_one[:]\n    list_two_copy = list_two[:]\n\n    list_one_copy.sort(reverse=True)\n    list_two_copy.sort(reverse=True)\n\n    largest_products = []\n\n    for index in range(num):\n        largest_products.append(\n            list_one_copy[index] * list_two_copy[index]\n        )\n\n    return largest_products\n\n\ndef find_largest_products_in_place_better(list_one: List[int], list_two: List[int], num: int) -> List"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def largest_product(list1, list2, k):\n    \"\"\"\n    Return k largest products from two given lists.\n\n    >>> largest_product([1, 2, 3], [1, 2, 3], 1)\n    [[6]]\n    >>> largest_product([-1, 2, 3], [1, 2, 3], 1)\n    [[6]]\n    >>> largest_product([1, 2, 3], [1, 2, 3], 2)\n    [[6, 9], [6, 12]]\n    >>> largest_product([1, 2, 3], [1, 2, 3], 3)\n    [[6, 9], [6, 12], [6, 18]]\n    >>> largest_product([1, 2, 3], [1, 2, 3], 4)\n    [[6, 9], [6, 12], [6, 18], [6, 24]]\n    >>> largest_product([1, 2, 3], [1, 2, 3], 5)\n    [[6, 9], [6, 12], [6, 18], [6, 24], [6, 36]]\n    \"\"\"\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort()\n    return products[-k:]\n\n\ndef test_largest_product():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    test_largest_product()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from functools import reduce\nfrom typing import List\n\n\ndef find_largest_products(lists: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(k)\n    \"\"\"\n    if k == 0:\n        return []\n\n    products = []\n\n    for i in range(len(lists[0])):\n        product = lists[0][i] * lists[1][i]\n        products.append((product, i))\n\n    return [\n        lists[0][idx] * lists[1][idx]\n        for _, idx in sorted(products, key=lambda x: x[0], reverse=True)[:k]\n    ]\n\n\ndef find_largest_products_with_reduce(lists: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(k)\n    \"\"\"\n    if k == 0:\n        return []\n\n    def get_product(x, y):\n        return (x[0] * y[0], x[1] * y[1])\n\n    products = reduce(get_product, zip(lists[0], lists[1]))\n    return [\n        lists[0][idx] * lists[1][idx]\n        for _, idx in sorted(products, key=lambda x: x[0], reverse=True)[:k]\n    ]\n\n\nif __name__ == \"__main__\":\n    assert find_largest_products([[1, 2, 3], [4, 5, 6]], 2) == [12, 18]\n    assert find_largest_products([[1, 2, 3], [4, 5, 6]], 1) == [18]\n    assert find_largest_products([[1, 2, 3], [4, 5, 6]], 3) == [18, 16, 12]\n    assert find_largest_products([[1, 2, 3], [4, 5, 6]],"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def largest_products(nums1, nums2):\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    Args:\n        nums1: List[int]\n        nums2: List[int]\n\n    Returns:\n        List[int]\n\n    Examples:\n        >>> assert largest_products([1, 2, 3, 4, 5], [2, 4, 6, 8, 10]) == [30, 24, 18, 12, 6]\n        >>> assert largest_products([-10, 1, 2, 3, 4], [2, 3, 4, 5, 6]) == [60, 40, 30, 24, 18]\n    \"\"\"\n    nums1.sort()\n    nums2.sort()\n    return [\n        nums1[-i] * nums2[-i]\n        for i in range(1, len(nums1) + 1)\n    ]\n\n\nif __name__ == '__main__':\n    print(largest_products([1, 2, 3, 4, 5], [2, 4, 6, 8, 10]))\n    print(largest_products([-10, 1, 2, 3, 4], [2, 3, 4, 5, 6]))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def max_products(list1, list2, k):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if not list1 or not list2 or k < 1:\n        return []\n    if k > len(list1) * len(list2):\n        return []\n\n    products = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n\n    products.sort(reverse=True)\n    return products[:k]\n\n\nif __name__ == \"__main__\":\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 3))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 2))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 1))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 0))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 10))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 5))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 6))\n    print(max_products([1,2,3,4,5], [2,3,4,5,6], 7))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from functools import reduce\nfrom itertools import product\n\n\n# Time complexity: O(n*m)\ndef largest_product_naive(list1, list2):\n    return sorted(\n        [(a, b) for a, b in product(list1, list2)], key=lambda x: x[0] * x[1], reverse=True\n    )[:n]\n\n\n# Time complexity: O(n*m)\ndef largest_product(list1, list2):\n    res = []\n\n    for i, num1 in enumerate(list1):\n        for j, num2 in enumerate(list2):\n            res.append((i, j, num1 * num2))\n\n    return sorted(res, key=lambda x: x[2], reverse=True)[:n]\n\n\n# Time complexity: O(n*m)\n# Space complexity: O(n*m)\ndef largest_product_dp(list1, list2):\n    res = [[0 for _ in range(len(list1))] for _ in range(len(list2))]\n\n    for i, num1 in enumerate(list1):\n        for j, num2 in enumerate(list2):\n            if i == 0 or j == 0:\n                res[i][j] = num1 * num2\n            else:\n                res[i][j] = max(res[i - 1][j], res[i][j - 1], res[i - 1][j - 1]) * num1 * num2\n\n    return [\n        (i + 1, j + 1, res[i][j])\n        for i in range(len(list1))\n        for j in range(len(list2))\n        if res[i][j] != 0\n    ][:n]\n\n\n# Time complexity: O(n*m)\n# Space complexity: O(n*m)\ndef largest_product_dp_v2(list1, list2):\n    res = [[0 for _ in range(len(list1))] for _ in range(len(list2))]\n\n    for i, num1 in enumerate(list1):\n        for j, num2 in enumerate("
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef find_largest_products(lists: List[List[int]], count: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n)\n    \"\"\"\n    if not lists or count < 1:\n        return []\n\n    size = len(lists)\n    if size == 1:\n        return []\n\n    lists = sorted(lists, key=lambda x: x[-1], reverse=True)\n\n    def find_product(lists: List[List[int]], count: int) -> List[int]:\n        if count == 0:\n            return []\n\n        max_product = lists[0][-1] * lists[1][-1]\n        if count == 1:\n            return [max_product]\n\n        next_product = find_product(lists[2:], count - 1)\n        return [max_product] + next_product\n\n    return find_product(lists, count)\n\n\nif __name__ == \"__main__\":\n    assert find_largest_products([[1, 2], [2, 3], [3, 4]], 2) == [12, 16]\n    assert find_largest_products([[1, 2], [2, 3], [3, 4]], 3) == [12, 16, 12]\n    assert find_largest_products([[1, 2], [2, 3], [3, 4]], 4) == [12, 16, 12, 9]\n    assert find_largest_products([[1, 2], [2, 3], [3, 4]], 5) == [12, 16, 12, 9, 8]"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef largest_product_of_two(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    numbers.sort()\n\n    return max(\n        numbers[-i] * numbers[-i - 1]\n        for i in range(1, k + 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert largest_product_of_two([2, 4, 6, 2, 5], 3) == 120"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def max_product(list_a, list_b, max_count):\n    \"\"\"\n    :param list_a: list of numbers\n    :param list_b: list of numbers\n    :param max_count: int\n    :return: list of max products\n    :rtype: list\n    \"\"\"\n    # 1. get the products of the lists\n    products = []\n    for a in list_a:\n        for b in list_b:\n            products.append(a * b)\n\n    # 2. sort the products list and return the max_count\n    sorted_products = sorted(products, reverse=True)\n    return sorted_products[:max_count]\n\n\nif __name__ == \"__main__\":\n    list_a = [1, 2, 3, 4, 5]\n    list_b = [100, 200, 300, 400, 500]\n    print(max_product(list_a, list_b, 3))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef max_products(list_a, list_b, n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    products = []\n\n    for a in list_a:\n        for b in list_b:\n            products.append(a * b)\n\n    products.sort(reverse=True)\n    return products[:n]\n\n\ndef max_products_heap(list_a, list_b, n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    products = []\n\n    for a in list_a:\n        for b in list_b:\n            heappush(products, a * b)\n\n    return [heappop(products) for _ in range(n)]\n\n\nif __name__ == \"__main__\":\n    assert max_products([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 3) == [120, 180, 300]\n    assert max_products([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 4) == [360, 360, 360, 360]\n    assert max_products_heap([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 3) == [120, 180, 300]\n    assert max_products_heap([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 4) == [360, 360, 360, 360]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    >>> largest_product([1, 2, 3], [1, 2, 3], 1)\n    [6]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 1)\n    [12]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 2)\n    [12, 24]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 3)\n    [12, 24, 24]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 4)\n    [12, 24, 24, 16]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 5)\n    [12, 24, 24, 16, 16]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 6)\n    [12, 24, 24, 16, 16, 12]\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4], 0)\n    []\n    \"\"\"\n    products = []\n\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    products.sort(reverse=True)\n\n    return products[:n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef largest_product(lists: List[int], size: int) -> List[int]:\n    \"\"\"\n    :param lists: list of numbers\n    :param size: size of list to return\n    :return: list of largest products\n    >>> largest_product([1, 2, 3, 4, 5], 3)\n    [12, 18, 24]\n    >>> largest_product([1, 2, 3, 4, 5], 1)\n    [5]\n    >>> largest_product([1, 2, 3, 4, 5], 5)\n    [120, 180, 240, 300, 360]\n    \"\"\"\n    lists.sort(reverse=True)\n    return [\n        lists[i] * lists[i + 1]\n        for i in range(len(lists) - 1)\n    ][:size]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef find_products(array_1: List[int], array_2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    array_1.sort(reverse=True)\n    array_2.sort(reverse=True)\n    return [array_1[i] * array_2[i] for i in range(n)]\n\n\nif __name__ == \"__main__\":\n    print(find_products([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], 2))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "from itertools import product\n\n\ndef find_largest_product(list1, list2, number):\n    \"\"\"\n    >>> find_largest_product([1, 2, 3], [2, 3, 4], 3)\n    [12, 18, 24]\n    \"\"\"\n    return sorted([x * y for x, y in product(list1, list2)], reverse=True)[:number]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_product_of_two(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n    \"\"\"\n    >>> max_product_of_two([-10, -10, 5, 2], [-10, -1, 2, 2], 3)\n    [-10, -10, 5]\n    \"\"\"\n    products = []\n\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n\n    return sorted(products, reverse=True)[:k]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "from functools import reduce\nfrom typing import List\n\n\ndef find_largest_product(array_1: List[int], array_2: List[int], k: int) -> List[int]:\n    \"\"\"\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 1)\n    [6]\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 3)\n    [6, 9, 18]\n    \"\"\"\n    result = []\n\n    for i in array_1:\n        for j in array_2:\n            result.append(i * j)\n\n    return sorted(result, reverse=True)[:k]\n\n\ndef find_largest_product_reduce(array_1: List[int], array_2: List[int], k: int) -> List[int]:\n    \"\"\"\n    >>> find_largest_product_reduce([1, 2, 3], [1, 2, 3], 1)\n    [6]\n    >>> find_largest_product_reduce([1, 2, 3], [1, 2, 3], 3)\n    [6, 9, 18]\n    \"\"\"\n    result = []\n\n    def _product(x: int, y: int) -> int:\n        return x * y\n\n    for i in array_1:\n        for j in array_2:\n            result.append(reduce(_product, (i, j)))\n\n    return sorted(result, reverse=True)[:k]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "from functools import reduce\n\n\ndef product_of_two_lists(a, b):\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Args:\n        a (list): First list\n        b (list): Second list\n\n    Examples:\n        >>> product_of_two_lists([1, 2, 3], [10, 20, 30])\n        [60, 60, 30]\n    \"\"\"\n    products = []\n    for x in a:\n        for y in b:\n            products.append(x * y)\n\n    return sorted(products, reverse=True)[: len(a)]\n\n\ndef product_of_two_lists_optimized(a, b):\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Args:\n        a (list): First list\n        b (list): Second list\n\n    Examples:\n        >>> product_of_two_lists_optimized([1, 2, 3], [10, 20, 30])\n        [60, 60, 30]\n    \"\"\"\n    return (\n        sorted(\n            reduce(lambda x, y: x + y, [[x * y for x in a] for y in b]),\n            reverse=True,\n        )\n        [: len(a)]\n    )\n\n\nif __name__ == \"__main__\":\n    print(product_of_two_lists([1, 2, 3], [10, 20, 30]))\n    print(product_of_two_lists_optimized([1, 2, 3], [10, 20, 30]))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "from typing import List\n\n\n# O(N + M) time | O(M) space\ndef largest_products(numbers: List[int], length: int) -> List[int]:\n    # First we need to know the length of the numbers list.\n    # If the length is less than or equal to 0, then we can't find the largest products,\n    # so we return an empty list.\n    if len(numbers) <= 0 or length <= 0:\n        return []\n\n    # If the length is greater than the length of the numbers list,\n    # then we can't find the largest products, so we return an empty list.\n    if length > len(numbers):\n        return []\n\n    # We need to create two lists to store the products of the numbers.\n    # We also need to create a list to store the largest products.\n    products = []\n    largest_products = []\n\n    # We need to loop through the numbers list.\n    for number in numbers:\n        # We need to multiply the number by each number in the numbers list.\n        products.append([number * x for x in numbers])\n\n    # We need to loop through the products list.\n    for product in products:\n        # We need to sort the products list.\n        product.sort()\n\n        # We need to loop through the length of the length variable.\n        for _ in range(length):\n            # If the length of the largest products list is less than the length variable,\n            # then we need to add the product to the largest products list.\n            if len(largest_products) < length:\n                largest_products.append(product[-1])\n\n            # Otherwise, we need to check if the product is greater than the last product\n            # in the largest products list. If it is, then we need to replace the last\n            # product in the largest products list with the product.\n            elif product[-1] > largest_products[-1]:\n                largest_products[-1] = product[-1]\n\n    return largest_products\n\n\nprint(largest_products([1, 2, 3, 4, 5], 3))\nprint(largest_products([1, 2, 3, 4,"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef largest_product_in_lists(list_a: List[int], list_b: List[int], n: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    n - is the size of list_a\n    m - is the size of list_b\n    \"\"\"\n    products = []\n    for i in range(len(list_a)):\n        for j in range(len(list_b)):\n            products.append(list_a[i] * list_b[j])\n\n    products.sort(reverse=True)\n    return products[:n]\n\n\nif __name__ == \"__main__\":\n    assert largest_product_in_lists([1, 2, 3], [1, 2, 3], 2) == [6, 6]\n    assert largest_product_in_lists([1, 2, 3], [-1, 2, 3], 2) == [6, 6]"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], num: int) -> List[int]:\n    \"\"\"\n    >>> largest_product([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 3)\n    [60, 120, 180]\n    >>> largest_product([1, 2, 3], [2, 3, 4], 3)\n    [6, 9, 12]\n    >>> largest_product([1, 2, 3], [2, 3, 4], 4)\n    []\n    \"\"\"\n    res = []\n    for i, v1 in enumerate(list1):\n        for j, v2 in enumerate(list2):\n            res.append(v1 * v2)\n\n    res.sort(reverse=True)\n\n    if num > len(res):\n        return []\n\n    return res[:num]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "from itertools import product\n\ndef largest_products(list1, list2, k):\n    \"\"\"\n    >>> largest_products([1,2,3,4], [5,6,7,8], 1)\n    [16]\n    >>> largest_products([1,2,3,4], [5,6,7,8], 2)\n    [16, 18]\n    >>> largest_products([1,2,3,4], [5,6,7,8], 3)\n    [16, 18, 16]\n    \"\"\"\n    # your code here\n    product_list = list(product(list1, list2))\n    return sorted(product_list, key=lambda x: x[0] * x[1], reverse=True)[:k]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], size: int) -> List[int]:\n    \"\"\"\n    The idea is to find the largest product of two numbers in the two given lists.\n    Then, we repeat this process size times.\n    \"\"\"\n    if not list1 or not list2:\n        raise ValueError(\"Input lists cannot be empty\")\n\n    if size < 1:\n        raise ValueError(\"Size of the result cannot be less than one\")\n\n    if len(list1) < size or len(list2) < size:\n        raise ValueError(\n            f\"Size of the result cannot be greater than the length of the lists\"\n        )\n\n    res = []\n    for _ in range(size):\n        max_product = -1\n        for i in list1:\n            for j in list2:\n                product = i * j\n                if product > max_product:\n                    max_product = product\n\n        res.append(max_product)\n\n        list1.remove(max(list1))\n        list2.remove(max(list2))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert largest_product([1, 2, 3, 4], [3, 4, 5, 6], 2) == [24, 12]\n    assert largest_product([1, 2, 3, 4], [3, 4, 5, 6], 3) == [24, 12, 24]\n    assert largest_product([1, 2, 3], [3, 4, 5, 6], 2) == [12, 12]"
    },
    {
      "rank": 24,
      "score": 9.0,
      "candidate": "from typing import List\n\n\ndef find_largest_products(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    return [\n        max(list1[i] * list2[i], list1[i] * list2[len(list2) - 1 - i])\n        for i in range(k)\n    ]\n\n\nif __name__ == \"__main__\":\n    assert find_largest_products([1, 2, 3, 4], [5, 6, 7, 8], 3) == [32, 24, 16]"
    },
    {
      "rank": 25,
      "score": 9.0,
      "candidate": "from typing import List\n\n\ndef max_products(list_a: List[int], list_b: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*m)\n    \"\"\"\n    res = []\n    list_a.sort(reverse=True)\n    list_b.sort(reverse=True)\n\n    while len(list_a) > 0 and len(list_b) > 0:\n        product = list_a[0] * list_b[0]\n        res.append(product)\n        list_a.pop(0)\n        list_b.pop(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(max_products([-10, 0, 5, 3], [-1000, 2, 3, 4]))\n    print(max_products([-10, 0, 5, 3], [-1000, 2, 3, 4]))\n    print(max_products([-10, 0, 5, 3], [-1000, 2, 3, 4]))\n    print(max_products([-10, 0, 5, 3], [-1000, 2, 3, 4]))"
    },
    {
      "rank": 26,
      "score": 9.0,
      "candidate": "from heapq import nlargest\n\ndef largest_product(lst1, lst2):\n    lst1 = lst1[:]\n    lst2 = lst2[:]\n    lst1.sort(reverse=True)\n    lst2.sort(reverse=True)\n    return nlargest(len(lst1) * len(lst2), ((lst1[i] * lst2[j], i, j) for i in range(len(lst1)) for j in range(len(lst2))))"
    },
    {
      "rank": 27,
      "score": 9.0,
      "candidate": "def largest_product(list1, list2, size):\n    \"\"\"Return the size largest products from list1 and list2.\n\n    >>> largest_product([1, 2, 3, 4], [5, 6, 7, 8], 2)\n    [48, 32]\n    \"\"\"\n\n    result = []\n\n    for i in list1:\n        for j in list2:\n            result.append(i * j)\n\n    result.sort(reverse=True)\n    return result[:size]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_products(lists: List[int], lists_len: int, max_prods_len: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if not lists or not lists_len or lists_len < 2:\n        return []\n\n    lists.sort(reverse=True)\n\n    max_prods = []\n\n    for i in range(lists_len - max_prods_len + 1):\n        product = lists[i]\n\n        for j in range(i + 1, lists_len):\n            product *= lists[j]\n\n            if len(max_prods) < max_prods_len or max_prods[-1] < product:\n                max_prods.append(product)\n\n            if len(max_prods) == max_prods_len:\n                break\n\n        if len(max_prods) == max_prods_len:\n            break\n\n    return max_prods\n\n\nif __name__ == \"__main__\":\n    assert max_products([1, 2, 3, 4, 5, 6, 7], 7, 3) == [21, 18, 15]\n    assert max_products([1, 2, 3, 4, 5, 6, 7], 7, 4) == [28, 24, 18, 15]\n    assert max_products([1, 2, 3, 4, 5, 6, 7], 7, 5) == [36, 28, 24, 18, 15]\n    assert max_products([1, 2, 3, 4, 5, 6, 7], 7, 6) == [45, 36, 28, 24, 18, 15]"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_product_of_two(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*k)\n    Space Complexity: O(k)\n    \"\"\"\n    if len(numbers) < 2:\n        return 0\n\n    product = 1\n    for num in numbers:\n        product *= num\n\n    products = [product]\n\n    for _ in range(k - 1):\n        product = 1\n        for num in numbers:\n            product *= num\n            products.append(product)\n\n    return max(products)\n\n\nif __name__ == \"__main__\":\n    assert largest_product_of_two([1, 2, 3, 4], 3) == 24\n    assert largest_product_of_two([1, 2, 3, 4], 2) == 12"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def largest_product(lst1, lst2):\n    # Find largest product in list 1\n    largest_product_lst1 = 1\n    for num1 in lst1:\n        for num2 in lst2:\n            product = num1 * num2\n            if product > largest_product_lst1:\n                largest_product_lst1 = product\n\n    # Find largest product in list 2\n    largest_product_lst2 = 1\n    for num1 in lst1:\n        for num2 in lst2:\n            product = num1 * num2\n            if product > largest_product_lst2:\n                largest_product_lst2 = product\n\n    return largest_product_lst1, largest_product_lst2\n\n\nprint(largest_product([3, 1, 5], [3, 2, 1]))\nprint(largest_product([3, 1, 5], [3, 2, 2]))\nprint(largest_product([3, 1, 5], [3, 2, 4]))\nprint(largest_product([3, 1, 5], [3, 2, 8]))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from heapq import nlargest\nfrom typing import List\n\n\ndef largest_product_from_lists(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from_lists([-10, -10, 5, 2], [-10, -10, 5, 2])\n    [50, 25, 20, 10]\n    >>> largest_product_from"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_products(lists, k):\n    largest = nlargest(k, ((lists[i][j] * lists[i + 1][j], i, j) for i in range(len(lists) - 1) for j in range(len(lists[0]))))\n    return [i for i, j, k in largest]\n\n\nprint(largest_products([[1, 2, 3], [3, 2, 1]], 3))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from typing import List, Tuple\n\n\ndef find_largest_products(lists: List[int], size: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds the specified number of largest products from two given lists.\n\n    Args:\n        lists (List[int]): two lists of integers\n        size (int): number of largest products to return\n\n    Examples:\n        >>> find_largest_products([1, 2, 3], 2)\n        [(6, 1), (6, 2)]\n        >>> find_largest_products([1, 2, 3], 3)\n        [(6, 1), (6, 2), (6, 3)]\n        >>> find_largest_products([1, 2, 3], 1)\n        [(6, 1)]\n        >>> find_largest_products([1, 2, 3], 0)\n        []\n    \"\"\"\n    if size < 1:\n        return []\n    if len(lists) < 2:\n        return []\n\n    lists = sorted(lists, reverse=True)\n    result = []\n    for i in range(len(lists) - 1):\n        for j in range(i + 1, len(lists)):\n            result.append((lists[i] * lists[j], lists[i], lists[j]))\n\n    return sorted(result, reverse=True)[:size]\n\n\nif __name__ == \"__main__\":\n    print(find_largest_products([1, 2, 3], 2))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def largest_product_in_lists(list_1, list_2, k):\n    \"\"\"\n    >>> largest_product_in_lists([1, 2, 3, 4], [1, 2, 3, 4], 2)\n    [12, 18]\n    >>> largest_product_in_lists([1, 2, 3, 4], [1, 2, 3, 4], 4)\n    [12, 18, 24, 32]\n    \"\"\"\n    list_1.sort(reverse=True)\n    list_2.sort(reverse=True)\n    if k > len(list_1) or k > len(list_2):\n        raise Exception(\"Invalid Input\")\n    result = []\n    for i in range(k):\n        result.append(list_1[i] * list_2[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list_one: List[int], list_two: List[int], size: int) -> List[int]:\n    \"\"\"\n    The brute force approach is to generate all possible products and then sort the list.\n    However, the number of products will be n * m. We can reduce this by generating only\n    the largest products.\n\n    For example, if the lists are [1, 2, 3] and [1, 2, 3], the largest products are:\n\n    1 * 1 = 1\n    1 * 2 = 2\n    1 * 3 = 3\n    2 * 1 = 2\n    2 * 2 = 4\n    2 * 3 = 6\n    3 * 1 = 3\n    3 * 2 = 6\n    3 * 3 = 9\n\n    If we consider the sublists of the two lists, we can find the largest products.\n    For example, the largest products of the sublists are:\n\n    [1, 2, 3] * [1, 2] = [1, 2, 3, 2, 6]\n    [1, 2, 3] * [3, 2, 1] = [3, 6, 9, 6, 3]\n    [1, 2] * [1, 2, 3] = [1, 2, 2, 4, 6]\n    [1, 2] * [3, 2, 1] = [3, 6, 6, 4, 3]\n    [3, 2, 1] * [1, 2, 3] = [3, 6, 6, 4, 3]\n    [3, 2, 1] * [3, 2, 1] = [9, 6, 9, 6, 3]\n\n    The largest products are 9, 6, 6, 6, and 3.\n\n    Complexity:\n\n        n = len(list_one)\n        m = len(list_two)\n        Time: O(n + m)"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_products(lists, k):\n    if k == 0:\n        return []\n\n    largest = nlargest(k, ((lists[0][i] * lists[1][i], i) for i in range(len(lists[0]))))\n\n    return [lists[0][i] * lists[1][i] for _, i in largest]"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product(list1, list2):\n    res = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            res.append(list1[i] * list2[j])\n    return nlargest(2, res)\n\n\nif __name__ == \"__main__\":\n    assert largest_product([1, 2, 3], [2, 3, 4]) == [12, 16]\n    assert largest_product([1, 2, 3, 4], [2, 3, 4, 5]) == [20, 24]"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_products(lists, n):\n    if n == 0:\n        return []\n    elif len(lists) < 2:\n        return []\n    elif n > len(lists[0]) * len(lists[1]):\n        return nlargest(n, lists[0])\n\n    largest_list = []\n    for i in range(len(lists[0])):\n        for j in range(len(lists[1])):\n            product = lists[0][i] * lists[1][j]\n            if len(largest_list) < n:\n                largest_list.append(product)\n            elif product > largest_list[0]:\n                largest_list[0] = product\n                largest_list.sort(reverse=True)\n    return largest_list\n\n\nif __name__ == '__main__':\n    print(largest_products([5, 1, 3, 2, 4], 3))\n    print(largest_products([-5, -1, -3, -2, -4], 3))\n    print(largest_products([5, 1, 3, 2, 4], 0))\n    print(largest_products([5, 1, 3, 2, 4], 5))\n    print(largest_products([5, 1, 3, 2, 4], 2))\n    print(largest_products([5, 1, 3, 2, 4], 1))\n    print(largest_products([5, 1, 3, 2, 4], 6))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Greedy approach, time complexity: O(n^2), space complexity: O(n)\n    \"\"\"\n    if not list1 or not list2 or k <= 0:\n        return []\n\n    max_products = []\n\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(max_products) < k:\n                max_products.append(product)\n            else:\n                if max_products[-1] < product:\n                    max_products[-1] = product\n                    max_products.sort(reverse=True)\n\n    return max_products\n\n\nif __name__ == \"__main__\":\n    assert largest_product([-10, 5, 10, 20], [-1, 4, 10, 2], 3) == [-40, -20, 20]"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product(list1, list2):\n    return nlargest(3, ((a * b, a, b) for a in list1 for b in list2))\n\n\nif __name__ == \"__main__\":\n    print(largest_product([2, 3, 4], [1, 2, 3]))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef max_product_sublists(a, b, k):\n    \"\"\"Returns a list of the k largest products of elements from a and b.\"\"\"\n    return sorted(\n        [reduce(lambda x, y: x * y, a[i : i + k]) * reduce(lambda x, y: x * y, b[j : j + k]) for i in range(len(a) - k + 1) for j in range(len(b) - k + 1)],\n        reverse=True\n    )[:k]\n\n\nprint(max_product_sublists([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], 3))\nprint(max_product_sublists([1, 2, 3, 4], [6, 7, 8, 9, 10], 3))\nprint(max_product_sublists([1, 2, 3, 4], [6, 7, 8, 9, 10], 2))\nprint(max_product_sublists([1, 2, 3, 4], [6, 7, 8, 9, 10], 1))\nprint(max_product_sublists([1, 2, 3, 4], [6, 7, 8, 9, 10], 0))\nprint(max_product_sublists([1, 2, 3, 4], [6, 7, 8, 9, 10], 10))"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def max_product(nums1, nums2, k):\n    result = []\n    for num1 in nums1:\n        for num2 in nums2:\n            result.append(num1*num2)\n    return sorted(result, reverse=True)[:k]\n\n\nprint(max_product([-10, 0, 5, 3], [-100, 2, 3, 4], 3))"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef product_list(nums: list[int]) -> list[int]:\n    return list(reduce(lambda a, b: a + [a[-1] * b], nums, [1]))[1:]\n\n\ndef largest_product(nums1: list[int], nums2: list[int], n: int) -> list[int]:\n    products = list(zip(product_list(nums1), product_list(nums2)))\n    return sorted(products, key=lambda p: p[0] * p[1])[-n:]\n\n\nif __name__ == \"__main__\":\n    print(largest_product([1, 2, 3], [-3, -2], 2))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def get_largest_products(list1, list2, n):\n    list1 = sorted(list1, reverse=True)\n    list2 = sorted(list2, reverse=True)\n    result = []\n    for i in range(n):\n        result.append(list1[i] * list2[i])\n    return result\n\n\nif __name__ == '__main__':\n    print(get_largest_products([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], 2))"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "from itertools import product\n\n\ndef find_largest_products(list_a, list_b, number):\n    products = []\n    for pair in product(list_a, list_b):\n        products.append(pair[0] * pair[1])\n    return sorted(products, reverse=True)[:number]\n\n\ndef main():\n    result = find_largest_products([-10, 1, 2, 3, 100], [\n                                   4, 5, 6, 100, 101], 3)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "# Time complexity: O(n)\n# Space complexity: O(1)\ndef largest_product(list1, list2, num):\n    result = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            result.append(list1[i] * list2[j])\n\n    result.sort(reverse=True)\n\n    return result[:num]\n\n\nprint(largest_product([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 3))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "def find_largest_product(list1, list2, k):\n    \"\"\"\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 1)\n    [[6]]\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 2)\n    [[6], [3, 6]]\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 3)\n    [[6], [3, 6], [1, 2, 3]]\n    >>> find_largest_product([1, 2, 3], [1, 2, 3], 4)\n    [[6], [3, 6], [1, 2, 3], [1, 2, 3, 6]]\n    \"\"\"\n    if k > len(list1) * len(list2):\n        return None\n\n    pairs = []\n\n    for a in list1:\n        for b in list2:\n            pairs.append([a, b])\n\n    pairs.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n    return [pairs[i : i + k] for i in range(0, len(pairs), k)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef max_product(nums1, nums2):\n    \"\"\"\n    >>> max_product([-10, 0, 5, 3], [-100, 2, 3, 4])\n    [-100, 0, 30, 30]\n    >>> max_product([-10, 0, 5, 3], [-100, 2, 3, 4])\n    [-100, 0, 30, 30]\n    >>> max_product([-10, 0, 5, 3], [-100, 2, 3, 4])\n    [-100, 0, 30, 30]\n    \"\"\"\n    if len(nums1) > len(nums2):\n        return max_product(nums2, nums1)\n\n    if len(nums1) == 0:\n        return []\n\n    nums1_product = [reduce(lambda x, y: x * y, nums1[: i + 1]) for i in range(len(nums1))]\n    nums2_product = [reduce(lambda x, y: x * y, nums2[: i + 1]) for i in range(len(nums2))]\n\n    max_products = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            max_products.append(nums1_product[i] * nums2_product[j])\n\n    return sorted(max_products, reverse=True)[: len(nums1)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from functools import reduce\nfrom itertools import permutations\n\n\ndef largest_product(list_a, list_b):\n    \"\"\"\n    :param list_a: list of int\n    :param list_b: list of int\n    :return: list of int\n    \"\"\"\n    permutations_list = list(permutations(list_a, len(list_b)))\n    list_of_products = []\n    for item in permutations_list:\n        list_of_products.append(reduce(lambda x, y: x * y, item))\n\n    return sorted(list_of_products, reverse=True)[:len(list_b)]\n\n\nif __name__ == '__main__':\n    assert largest_product([1, 2, 3], [0, 4, 5]) == [120, 60, 40], \"First test failed\"\n    assert largest_product([1, 2, 3, 4, 5], [6, 7, 8, 9]) == [324, 280, 240, 216, 192], \"Second test failed\""
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\n# Time Complexity O(n*m)\ndef find_largest_products(lists, k):\n    if len(lists) < 2:\n        return\n\n    res = []\n    for i in range(len(lists[0])):\n        for j in range(len(lists[1])):\n            res.append(lists[0][i] * lists[1][j])\n\n    return nlargest(k, res)\n\n\nif __name__ == \"__main__\":\n    print(find_largest_products([[1, 2, 3], [2, 3, 4]], 3))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from itertools import product\n\n\ndef find_largest_products(list_1, list_2, count):\n    \"\"\"Finds count largest products from two given lists.\n\n    Args:\n        list_1: first list\n        list_2: second list\n        count: number of largest products to find\n    Returns:\n        list of largest products\n    \"\"\"\n    return sorted(\n        [\n            product_\n            for product_ in product(list_1, list_2)\n            if product_[0] * product_[1] > 0\n        ],\n        key=lambda x: x[0] * x[1],\n        reverse=True,\n    )[:count]"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from itertools import product\nfrom typing import List, Tuple\n\n\ndef find_largest_products(list_a: List[int], list_b: List[int],\n                          number_of_products: int) -> List[Tuple[int, int]]:\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Args:\n        list_a (List[int]): The first list.\n        list_b (List[int]): The second list.\n        number_of_products (int): The number of products to return.\n\n    Examples:\n        >>> find_largest_products([1, 2, 3], [1, 2, 3], 1)\n        [(6, (3, 3))]\n\n        >>> find_largest_products([-1, 2, 3], [-1, 2, 3], 1)\n        [(6, (3, 3))]\n\n        >>> find_largest_products([1, 2, 3], [-1, 2, 3], 1)\n        [(6, (3, 3))]\n\n        >>> find_largest_products([-1, 2, 3], [1, 2, 3], 1)\n        [(6, (3, 3))]\n\n        >>> find_largest_products([-1, -2, -3], [1, 2, 3], 1)\n        [(6, (-3, 3))]\n\n        >>> find_largest_products([1, 2, 3], [1, 2, 3], 2)\n        [(6, (3, 3)), (9, (3, 3))]\n\n        >>> find_largest_products([-1, -2, -3], [1, 2, 3], 2)\n        [(6, (-3, 3)), (9, (-3, 3))]\n\n        >>> find_largest_products([1, 2, 3], [-1, -2, -3], 2)\n        [(6, (3, -3)), (9, (3, -3))]\n\n        >>> find_largest_"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    First sort both the lists in descending order.\n    Then start with the smallest element of both the lists and multiply them.\n    Keep multiplying the largest element of both the lists till the product is greater than the\n    smallest product.\n\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(1)\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both the lists should be of same length.\")\n\n    if n <= 0:\n        raise ValueError(\"'n' should be greater than 0.\")\n\n    if n > len(list1):\n        raise ValueError(\"'n' should not be greater than length of list1.\")\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    result = []\n    i = 0\n    while len(result) < n:\n        product = list1[i] * list2[i]\n        if product >= result[0] if result else -1:\n            result.append(product)\n        i += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(largest_product([1, 2, 3, 4], [1, 2, 3, 4], 2))\n    print(largest_product([1, 2, 3, 4], [1, 2, 3, 4], 3))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n+m)\n    \"\"\"\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    result = []\n\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            result.append(nums1[i] * nums2[j])\n\n    return sorted(result, reverse=True)[:2]\n\n\nif __name__ == \"__main__\":\n    print(max_product([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]))\n    print(max_product([-1, -2, -3], [-2, -3, -4]))"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def max_products(list1, list2, count):\n    list1.sort()\n    list2.sort()\n    result = []\n    for i in range(len(list1)-1, len(list1)-count-1, -1):\n        for j in range(len(list2)-1, len(list2)-count-1, -1):\n            result.append(list1[i] * list2[j])\n    return result"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_products(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n    \"\"\"\n    O(n) & O(1)\n    \"\"\"\n    if k == 0:\n        return []\n\n    products = []\n\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            products.append(product)\n\n    products.sort(reverse=True)\n\n    return products[:k]\n\n\nif __name__ == \"__main__\":\n    assert max_products([1, 2], [3, 4], 1) == [12]\n    assert max_products([2, 5], [3, 4], 2) == [20, 10]"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(array_1: List[int], array_2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(array_1) != len(array_2):\n        raise ValueError(\"array_1 and array_2 must have the same length\")\n    if k > len(array_1):\n        raise ValueError(\"k must be less or equal to length of array_1 and array_2\")\n\n    array_1.sort(reverse=True)\n    array_2.sort(reverse=True)\n\n    return [\n        array_1[i] * array_2[i]\n        for i in range(k)\n    ]\n\n\nif __name__ == \"__main__\":\n    print(max_product([-10, -10, 5, 2], [-10, -10, -5, 2], 3))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def largest_product(list1, list2, n):\n    \"\"\"\n    :param list1: list of numbers\n    :param list2: list of numbers\n    :param n: number of largest products to return\n    :return: n largest products\n    \"\"\"\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    return sorted(products, reverse=True)[:n]\n\n\nprint(largest_product([1, 2, 3], [10, 20, 30, 40, 50], 2))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "from itertools import product\n\n\ndef find_largest_products(lists, n):\n\n    def product_list(nums):\n        return [x * y for x, y in product(nums, repeat=2)]\n\n    products = product_list(lists[0])\n    for i in range(1, len(lists)):\n        products.extend(product_list(lists[i]))\n\n    products = sorted(products, reverse=True)\n\n    return products[:n]\n\n\nif __name__ == \"__main__\":\n    print(find_largest_products([[1, 2], [3, 4], [5, 6], [7, 8]], 3))\n    print(find_largest_products([[1, 2], [-3, 4], [5, -6], [7, 8]], 3))\n    print(find_largest_products([[-1, 1, -1], [1, -1, 1], [-1, 1, -1]], 3))"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef largest_product(list_1, list_2, count):\n    if count < 0:\n        return None\n\n    largest_products = []\n\n    for first_element in list_1:\n        for second_element in list_2:\n            product = first_element * second_element\n            largest_products.append(product)\n\n    largest_products.sort(reverse=True)\n    return largest_products[:count]\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef largest_product_reduce(list_1, list_2, count):\n    if count < 0:\n        return None\n\n    def product(x, y):\n        return x * y\n\n    return reduce(product, [first_element * second_element for first_element in list_1 for second_element in list_2])\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef largest_product_reduce_2(list_1, list_2, count):\n    if count < 0:\n        return None\n\n    def product(product, number):\n        return max(product, number)\n\n    return reduce(product, [first_element * second_element for first_element in list_1 for second_element in list_2])"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef max_products(nums1, nums2, k):\n    products = [(x * y, x, y) for x in nums1 for y in nums2]\n    return [product for product, _, _ in nlargest(k, products, key=lambda x: x[0])]\n\n\nprint(max_products([1, 2, 3], [2, 3, 4, 5], 3))\nprint(max_products([2, 3, 4, 5], [1, 2, 3], 3))\nprint(max_products([1, 2, 3], [2, 3, 4, 5], 3))\nprint(max_products([2, 3, 4, 5], [1, 2, 3], 3))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def find_largest_products(lists, n):\n    \"\"\"\n    Find n largest products from two given lists.\n\n    :param lists: lists of numbers\n    :param n: number of largest products to find\n    :return: n largest products\n    :rtype: list\n    \"\"\"\n    # Create a list of lists with the products of each pair\n    products = []\n    for i in range(0, len(lists[0])):\n        for j in range(0, len(lists[1])):\n            products.append([lists[0][i] * lists[1][j], i, j])\n\n    # Sort the products by the product\n    products.sort(key=lambda x: x[0], reverse=True)\n\n    # Create a list with the largest products\n    largest_products = []\n    for i in range(0, n):\n        largest_products.append(products[i])\n\n    # Return the list of largest products\n    return largest_products\n\n\nif __name__ == '__main__':\n    lists = [[1, 2, 3], [3, 4, 5]]\n    print(find_largest_products(lists, 3))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "def max_product(list_a, list_b, k):\n    list_a.sort(reverse=True)\n    list_b.sort(reverse=True)\n    result = []\n    for i in range(k):\n        result.append(list_a[i] * list_b[i])\n    return result\n\n\nprint(max_product([-1, -3, -5, -7], [7, 5, 3, 1], 3))\nprint(max_product([-1, -3, -5, -7], [-7, -5, -3, -1], 3))\nprint(max_product([-1, -3, -5, -7], [-7, -5, -3, -1], 4))\nprint(max_product([-1, -3, -5, -7], [-7, -5, -3, -1], 2))\nprint(max_product([-1, -3, -5, -7], [-7, -5, -3, -1], 1))\nprint(max_product([-1, -3, -5, -7], [-7, -5, -3, -1], 0))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef find_products(a, b, n):\n    \"\"\"\n    :param a: List[int]\n    :param b: List[int]\n    :param n: int\n    :return: List[int]\n    \"\"\"\n    def find_largest_product(a, b):\n        return a * b\n\n    def find_all_products(a, b):\n        return [find_largest_product(a, b) for a in a for b in b]\n\n    def find_top_products(products, n):\n        return sorted(products, reverse=True)[:n]\n\n    return find_top_products(find_all_products(a, b), n)\n\n\ndef test_find_products():\n    assert find_products([1, 2, 3], [1, 2, 3], 3) == [6, 6, 6]\n    assert find_products([2, 2, 3], [1, 2, 3], 3) == [6, 6, 6]\n    assert find_products([2, 3, 4], [1, 2, 3], 3) == [6, 8, 12]\n    assert find_products([2, 3, 4], [1, 2, 3], 2) == [6, 8]\n    assert find_products([2, 3, 4], [1, 2, 3], 1) == [6]\n    assert find_products([2, 3, 4], [1, 2, 3], 0) == []\n\n\nif __name__ == '__main__':\n    test_find_products()"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def find_products(list1, list2):\n    return sorted(list(zip(list1, list2)), key=lambda x: x[0] * x[1])[-5:]"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def max_products(list1, list2, number):\n    \"\"\"\n    >>> max_products([-10, -10, 5, 2], [-1, 7, 3], 3)\n    [-10, -1, 35]\n    \"\"\"\n    list1.sort()\n    list2.sort()\n    max_products = []\n    while len(max_products) < number:\n        max_products.append(list1.pop() * list2.pop())\n    return max_products\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def largest_product(nums1, nums2, k):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    nums1_len = len(nums1)\n    nums2_len = len(nums2)\n    nums1_index = 0\n    nums2_index = 0\n    nums1_max = nums1_len - 1\n    nums2_max = nums2_len - 1\n    result = []\n    while nums1_index < nums1_len and nums2_index < nums2_len:\n        if nums1[nums1_index] * nums2[nums2_index] > result[k - 1]:\n            result.append(nums1[nums1_index] * nums2[nums2_index])\n        if nums1[nums1_index] * nums2[nums2_index] <= result[k - 1] and nums1_index < nums1_max:\n            nums1_index += 1\n        if nums1[nums1_index] * nums2[nums2_index] <= result[k - 1] and nums2_index < nums2_max:\n            nums2_index += 1\n    return sorted(result, reverse=True)"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "from functools import reduce\nfrom itertools import permutations\n\n\ndef largest_product(list1, list2):\n    if len(list1) == len(list2) == 0:\n        return 0\n\n    products = []\n    for i, j in permutations(list1, 2):\n        products.append(i * j)\n\n    return reduce(lambda x, y: x if x > y else y, products)\n\n\nprint(largest_product([-10, 1, 2, 3, 4], [-100, 2, 3, 4]))\nprint(largest_product([1, 2, 3, 4], [-100, 2, 3, 4]))\nprint(largest_product([1, 2, 3, 4], [1, 2, 3, 4]))\nprint(largest_product([1, 2, 3, 4], [1, 2, 3]))"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "from itertools import product\n\n\ndef largest_products(list_a, list_b, count):\n    \"\"\"\n    :param list_a: list\n    :param list_b: list\n    :param count: int\n    :return: list\n    \"\"\"\n    products = [a * b for a, b in product(list_a, list_b)]\n    return sorted(products, reverse=True)[:count]"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_products(lists: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    O(N + M) time, O(N + M) space\n    \"\"\"\n    products = []\n    for l1 in lists:\n        for l2 in lists:\n            for i in range(len(l1)):\n                for j in range(len(l2)):\n                    products.append(l1[i] * l2[j])\n\n    products.sort(reverse=True)\n\n    return products[:k]\n\n\nif __name__ == \"__main__\":\n    assert largest_products([[1, 2], [3, 4], [5, 6], [7, 8]], 3) == [56, 56, 48]"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef find_largest_products(lists, num):\n    return reduce(lambda x, y: x + y, sorted(lists)[:num])\n\n\n# Tests\nassert find_largest_products([1, 2, 3], 2) == 6\nassert find_largest_products([1, 2, 3, 4], 2) == 12\nassert find_largest_products([1, 2, 3, 4, 5], 2) == 20"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def get_largest_product(list1, list2, num):\n    return sorted(list(zip(list1, list2)), key=lambda x: x[0]*x[1], reverse=True)[:num]\n\n\nprint(get_largest_product([1, 2, 3], [2, 4, 6], 2))\nprint(get_largest_product([1, 2, 3], [2, 4, 6], 3))\nprint(get_largest_product([1, 2, 3], [2, 4, 6], 4))"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product(nums_list_1, nums_list_2):\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    >>> largest_product([-10, -10, 5, 2], [-1, 7, 2])\n    [-70, -20, 100]\n    >>> largest_product([-1, -2, -3, -4, -5], [1, 2, 3, 4, 5])\n    [-120, -60, -30, -15, -5]\n    >>> largest_product([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    [120, 60, 30, 15, 5]\n    >>> largest_product([-1, -2, -3, -4, -5], [-1, -2, -3, -4, -5])\n    [120, 60, 30, 15, 5]\n    \"\"\"\n    # Calculate the products of each pair of elements in the two lists.\n    products_list = [(nums_list_1[i] * nums_list_2[j], i, j)\n                     for i in range(len(nums_list_1)) for j in range(len(nums_list_2))]\n    # Return the specified number of largest products.\n    return [product[0] for product in nlargest(5, products_list, key=lambda x: x[0])]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "from functools import reduce\nfrom itertools import product\n\n\ndef product_list(nums):\n    return [reduce(lambda x, y: x * y, list(pair)) for pair in product(nums, repeat=2)]\n\n\ndef largest_products(nums1, nums2, k):\n    products = sorted(product_list(nums1) + product_list(nums2), reverse=True)\n    return products[:k]\n\n\nprint(largest_products([1, 2, 3], [0, -1, 2, 3], 2))\nprint(largest_products([1, 2, 3], [0, -1, 2, 3], 1))\nprint(largest_products([1, 2, 3], [0, -1, 2, 3], 3))\nprint(largest_products([1, 2, 3], [0, -1, 2, 3], 4))"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef largest_product(list1: List[int], list2: List[int], size: int) -> List[int]:\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Args:\n        list1: list of int\n        list2: list of int\n        size: size of the largest products\n\n    Examples:\n        >>> largest_product([1, 2, 3], [1, 2, 3], 1)\n        [6]\n        >>> largest_product([1, 2, 3], [1, 2, 3], 2)\n        [6, 6]\n        >>> largest_product([1, 2, 3], [1, 2, 3], 3)\n        [6, 6, 6]\n    \"\"\"\n    res = []\n    if len(list1) == 0 or len(list2) == 0:\n        return res\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            res.append(list1[i] * list2[j])\n\n    res.sort(reverse=True)\n\n    return res[:size]\n\n\nif __name__ == \"__main__\":\n    print(largest_product([1, 2, 3], [1, 2, 3], 1))\n    print(largest_product([1, 2, 3], [1, 2, 3], 2))\n    print(largest_product([1, 2, 3], [1, 2, 3], 3))"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "from functools import reduce\n\n\ndef multiply(a, b):\n    return reduce(lambda x, y: x * y, [a, b])\n\n\ndef get_largest_products(lists, k):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if k > len(lists) - 1:\n        raise ValueError(\"k can't be greater than len(lists) - 1\")\n\n    largest_products = []\n    lists_copy = lists.copy()\n\n    while k > 0:\n        max_product = 0\n\n        for i in range(len(lists_copy) - 1):\n            product = multiply(lists_copy[i], lists_copy[i + 1])\n            if product > max_product:\n                max_product = product\n                lists_copy[i], lists_copy[i + 1] = (\n                    lists_copy[i + 1],\n                    lists_copy[i],\n                )\n\n        largest_products.append(max_product)\n        k -= 1\n\n    return largest_products\n\n\nif __name__ == \"__main__\":\n    print(get_largest_products([1, 2, 3, 4, 5], 3))"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# O(nlogn)\ndef max_products_from_lists(\n    list_a: List[int], list_b: List[int], number_of_products: int\n) -> List[int]:\n    \"\"\"Returns the specified number of largest products from two given lists.\n\n    Args:\n        list_a (List[int]): first list of integers\n        list_b (List[int]): second list of integers\n        number_of_products (int): number of largest products\n\n    Returns:\n        List[int]: list of largest products\n\n    Examples:\n        >>> max_products_from_lists([1, 2, 3, 4], [3, 4, 5, 6], 2)\n        [12, 18]\n    \"\"\"\n\n    def _find_largest_products_from_lists(\n        list_a: List[int], list_b: List[int], number_of_products: int\n    ) -> List[int]:\n        \"\"\"Returns the specified number of largest products from two given lists.\n\n        Args:\n            list_a (List[int]): first list of integers\n            list_b (List[int]): second list of integers\n            number_of_products (int): number of largest products\n\n        Returns:\n            List[int]: list of largest products\n        \"\"\"\n        product_list = []\n\n        for a in list_a:\n            for b in list_b:\n                product_list.append(a * b)\n\n        return sorted(product_list, reverse=True)[:number_of_products]\n\n    def _merge_lists(\n        list_a: List[int], list_b: List[int], number_of_products: int\n    ) -> List[int]:\n        \"\"\"Returns the specified number of largest products from two given lists.\n\n        Args:\n            list_a (List[int]): first list of integers\n            list_b (List[int]): second list of integers\n            number_of_products (int): number of largest products\n\n        Returns:\n            List[int]: list of largest products\n        \"\"\""
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef find_largest_product(lists: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n\n    def get_product(index_1: int, index_2: int) -> int:\n        return lists[index_1][index_2] * lists[index_1][index_2 + 1]\n\n    def get_largest_product(index_1: int, index_2: int) -> int:\n        product = get_product(index_1, index_2)\n        if index_2 + 1 < len(lists[index_1]) - 1:\n            product = max(product, get_largest_product(index_1, index_2 + 1))\n        return product\n\n    max_product = []\n    for i in range(len(lists) - 1):\n        max_product.append(get_largest_product(i, 0))\n\n    return sorted(max_product, reverse=True)[:k]\n\n\nif __name__ == \"__main__\":\n    assert find_largest_product([[1, 2, 3, 4, 5], [2, 5, 6, 7, 8]], 3) == [32, 24, 16]"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "from collections import deque\n\n\ndef largest_product(list_a, list_b, num_largest):\n    \"\"\"\n    :param list_a: List[int]\n    :param list_b: List[int]\n    :param num_largest: int\n    :return: List[int]\n    \"\"\"\n    products = deque()\n\n    for a in list_a:\n        for b in list_b:\n            products.append(a * b)\n\n    products.sort()\n\n    return products[-num_largest:]\n\n\nprint(largest_product([2, 4, 7], [-1, 2, 3], 3))\nprint(largest_product([5, 1, 3], [2, 1, 4], 2))"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "def find_largest_products(nums_a, nums_b, num_largest):\n    \"\"\"\n    >>> find_largest_products([1, 2, 3], [1, 2, 3], 2)\n    [6, 6]\n    >>> find_largest_products([2, 3, 4], [1, 2, 3], 2)\n    [12, 12]\n    >>> find_largest_products([-1, 2, 3], [1, 2, 3], 2)\n    [6, 6]\n    >>> find_largest_products([1, 2, 3], [-1, 2, 3], 2)\n    [6, 6]\n    >>> find_largest_products([1, 2, 3], [1, 2, 3], 4)\n    Traceback (most recent call last):\n    ...\n    ValueError: num_largest must be less than or equal to the length of nums_a and nums_b\n    \"\"\"\n    if num_largest > len(nums_a) or num_largest > len(nums_b):\n        raise ValueError(\n            \"num_largest must be less than or equal to the length of nums_a and nums_b\"\n        )\n\n    products = []\n    for i in range(len(nums_a)):\n        for j in range(len(nums_b)):\n            products.append(nums_a[i] * nums_b[j])\n    return sorted(products, reverse=True)[:num_largest]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "def max_products(lists, k):\n    res = []\n    if k == 0:\n        return res\n    if len(lists) == 0 or len(lists[0]) == 0:\n        return res\n    max_products_from_first_list = []\n    max_products_from_second_list = []\n    for item in lists[0]:\n        max_products_from_first_list.append(max([item*i for i in lists[1]]))\n    for item in lists[1]:\n        max_products_from_second_list.append(max([i*item for i in lists[0]]))\n    max_products_from_first_list.sort(reverse=True)\n    max_products_from_second_list.sort(reverse=True)\n    res = max_products_from_first_list[:k] + max_products_from_second_list[:k]\n    res.sort(reverse=True)\n    return res\n\n\nprint(max_products([[1, 2, 3], [2, 3, 4]], 2))\nprint(max_products([[1, 2, 3], [3, 4, 5]], 2))\nprint(max_products([[1, 2, 3], [3, 4, 5]], 3))\nprint(max_products([[1, 2, 3], [3, 4, 5]], 4))\nprint(max_products([[1, 2, 3], [3, 4, 5]], 5))"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "def max_products(nums_a, nums_b):\n    nums_a = sorted(nums_a, reverse=True)\n    nums_b = sorted(nums_b, reverse=True)\n    return max_products_recursive(nums_a, nums_b, 0, 0, [])\n\n\ndef max_products_recursive(nums_a, nums_b, i, j, products):\n    if i == len(nums_a) or j == len(nums_b):\n        return products\n    else:\n        product_1 = nums_a[i] * nums_b[j]\n        product_2 = nums_a[i] * nums_b[j + 1]\n        product_3 = nums_a[i + 1] * nums_b[j]\n        product_4 = nums_a[i + 1] * nums_b[j + 1]\n\n        max_product = max(product_1, product_2, product_3, product_4)\n        products.append(max_product)\n\n        return max_products_recursive(nums_a, nums_b, i + 1, j, products)\n\n\nprint(max_products([1, 2, 3, 4, 5, 6], [1, 2, 3, 4]))\nprint(max_products([1, 2, 3, 4], [1, 2, 3, 4, 5, 6]))\nprint(max_products([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]))\nprint(max_products([1, 2, 3, 4, 5, 6], [1, 2, 3]))"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "from collections import deque\n\n\ndef largest_product(nums1, nums2):\n    \"\"\"\n    :param nums1: list of integers\n    :param nums2: list of integers\n    :return: list of integers\n    \"\"\"\n    nums1_deque = deque(nums1)\n    nums2_deque = deque(nums2)\n\n    def product(nums):\n        \"\"\"\n        :param nums: list of integers\n        :return: list of integers\n        \"\"\"\n        products = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                products.append(nums[i] * nums[j])\n        return products\n\n    def max_product(products, n):\n        \"\"\"\n        :param products: list of integers\n        :param n: integer\n        :return: list of integers\n        \"\"\"\n        products = sorted(products, reverse=True)\n        return products[:n]\n\n    products = product(nums1_deque) + product(nums2_deque)\n    return max_product(products, 4)\n\n\ndef test_largest_product():\n    \"\"\"\n    >>> test_largest_product()\n    True\n    \"\"\"\n    assert largest_product([1, 2, 3], [1, 2, 3]) == [1, 2, 3, 2]\n    assert largest_product([1, 2, 3], [3, 2, 1]) == [3, 2, 3, 1]\n    assert largest_product([3, 2, 1], [3, 2, 1]) == [3, 2, 3, 2]\n    assert largest_product([3, 2, 1], [1, 2, 3]) == [3, 2, 3, 1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "def max_product(a, b, k):\n    \"\"\"\n    :param a: int list\n    :param b: int list\n    :param k: int\n    :return: int\n    \"\"\"\n    # Time Complexity: O(nlog(n))\n    # Space Complexity: O(1)\n    a.sort()\n    b.sort()\n    return _max_product(a, b, k)\n\n\ndef _max_product(a, b, k):\n    if k == 1:\n        return a[-1] * b[-1]\n    elif k == 2:\n        return max(a[-1] * b[-1], a[-1] * b[-2], a[-2] * b[-1], a[-2] * b[-2])\n    else:\n        return max(_max_product(a, b, k - 1), a[-1] * b[-1] * _max_product(a[:-1], b[:-1], k - 1),\n                   a[-1] * b[-2] * _max_product(a[:-1], b[1:], k - 1), a[-2] * b[-1] * _max_product(a[1:], b[:-1], k - 1),\n                   a[-2] * b[-2] * _max_product(a[1:], b[1:], k - 1))\n\n\nif __name__ == '__main__':\n    print(max_product([1, 2, 3, 4], [5, 6, 7, 8], 2))"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "def max_product(nums1, nums2, k):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    products.sort(reverse=True)\n    return products[:k]\n\n\n# Test cases:\nprint(max_product([-10, 0, 5, 3], [-1000, 2, 3, 4], 3))"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_products(list_a: List[int], list_b: List[int], k: int) -> List[int]:\n    \"\"\"\n    This is the solution I came up with.\n    The problem is that it's O(n^2) time complexity,\n    and it's not very elegant.\n    \"\"\"\n    products = []\n    for index, a in enumerate(list_a):\n        for b in list_b:\n            products.append(a * b)\n    return sorted(products, reverse=True)[:k]\n\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    b = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print(max_products(a, b, 5))"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product(list1, list2):\n    \"\"\"\n    :param list1: list of numbers\n    :param list2: list of numbers\n    :return: largest products\n    Uses the fact that the product of two positive numbers is always positive\n    \"\"\"\n    largest_products = []\n    for number1 in list1:\n        for number2 in list2:\n            largest_products.append(number1 * number2)\n    return nlargest(2, largest_products)\n\n\nprint(largest_product([1, 2, 3], [3, 2, 1]))\nprint(largest_product([-1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, -1]))"
    },
    {
      "rank": 88,
      "score": 8.0,
      "candidate": "from functools import reduce\nfrom itertools import combinations\n\ndef largest_product(list1, list2):\n    \"\"\"\n    Return the specified number of largest products from two given lists.\n\n    >>> largest_product([1, 2, 3], [4, 5])\n    [6, 10, 15]\n    >>> largest_product([2, 5, 7], [3, 1, 4])\n    [14, 10, 14]\n    \"\"\"\n    # Calculate all possible products of list1 and list2\n    products = [reduce(lambda x, y: x * y, prod) for prod in combinations(list1, len(list1))]\n    products.extend(reduce(lambda x, y: x * y, prod) for prod in combinations(list2, len(list2)))\n    # Sort and return the specified number of largest products\n    return sorted(products, reverse=True)[:len(list1) * len(list2)]\n\ndef test_largest_product():\n    \"\"\"Test\"\"\"\n    assert largest_product([1, 2, 3], [4, 5]) == [6, 10, 15]\n    assert largest_product([2, 5, 7], [3, 1, 4]) == [14, 10, 14]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def largest_product(list1, list2):\n    \"\"\"\n    Return the largest products of two lists.\n    \"\"\"\n    # list1 = [1, 2, 3, 4, 5]\n    # list2 = [6, 7, 8, 9, 10]\n    # output: [50, 40, 30, 20, 10]\n    # O(n) time | O(n) space\n    # n = len(list1)\n    # if n != len(list2):\n    #     return []\n    # products = []\n    # for i in range(n):\n    #     for j in range(i, n):\n    #         product = list1[i] * list2[j]\n    #         products.append(product)\n    # return sorted(products, reverse=True)[:n]\n\n    # O(n) time | O(1) space\n    # n = len(list1)\n    # if n != len(list2):\n    #     return []\n    # products = []\n    # for i in range(n):\n    #     for j in range(i, n):\n    #         product = list1[i] * list2[j]\n    #         products.append(product)\n    # return sorted(products, reverse=True)[:n]\n\n    # O(n) time | O(n) space\n    # n = len(list1)\n    # if n != len(list2):\n    #     return []\n    # products = []\n    # for i in range(n):\n    #     for j in range(n):\n    #         product = list1[i] * list2[j]\n    #         products.append(product)\n    # return sorted(products, reverse=True)[:n]\n\n    # O(n) time | O(1) space\n    # n = len(list1)\n    # if n != len(list2):\n    #     return []\n    # products = []\n    # for i in range(n):\n    #     for j in range(n):\n    #         product = list1[i"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "from itertools import permutations\nfrom typing import List, Tuple\n\n\ndef two_large_numbers_product(a: List[int], b: List[int], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(k)\n    Space Complexity: O(1)\n    \"\"\"\n    products: List[int] = []\n\n    for value_a, value_b in permutations(a + b, 2):\n        if len(products) >= k:\n            break\n\n        products.append(value_a * value_b)\n\n    products.sort(reverse=True)\n\n    return products[:k]\n\n\nif __name__ == \"__main__\":\n    assert two_large_numbers_product([5, 2, 2], [2, 7, 4], 3) == [16, 8, 6]"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "from functools import reduce\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_products(list_a, list_b, num_largest=1):\n    # Convert to negative list\n    list_a_neg = list(map(lambda x: -x, list_a))\n    list_b_neg = list(map(lambda x: -x, list_b))\n\n    # Find the max products from the two negative lists\n    max_products_neg = max_products_helper(list_a_neg, list_b_neg, num_largest)\n\n    # Convert the max products to the right sign\n    max_products_pos = list(map(lambda x: -x, max_products_neg))\n\n    return max_products_pos\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_products_helper(list_a, list_b, num_largest=1):\n    # Create a list to store the max products\n    max_products = []\n\n    # Iterate through the list\n    for i in range(len(list_a)):\n        # Iterate through the list\n        for j in range(len(list_b)):\n            # Find the max product\n            product = list_a[i] * list_b[j]\n\n            # Add the max product to the list\n            max_products.append(product)\n\n            # Sort the list in descending order\n            max_products.sort(reverse=True)\n\n            # Remove the smallest value if the number of largest products is exceeded\n            if len(max_products) > num_largest:\n                max_products.pop()\n\n    return max_products\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_products_reduce(list_a, list_b, num_largest=1):\n    # Create a list to store the max products\n    max_products = []\n\n    # Iterate through the list\n    for i in range(len(list_a)):\n        # Iterate through the list\n        for j in range(len(list_b)):"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product_in_lists(nums1, nums2):\n    # Time Complexity: O(nlogk), where n is the number of items in nums1 and k is the number of items in nums2.\n    # Space Complexity: O(k)\n    return nlargest(len(nums1), (nums1[i] * nums2[i] for i in range(len(nums2))), key=abs)\n\n\nprint(largest_product_in_lists([1, 2, 3, 4, 5], [6, 5, 4, 3, 2]))\nprint(largest_product_in_lists([1, 2, 3], [5, 6, 7]))\nprint(largest_product_in_lists([2, 4, 5], [1, 2, 3]))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from heapq import nlargest\n\n\ndef largest_product(lst1, lst2, count):\n    \"\"\"Returns largest count of products between two lists.\n\n    Args:\n        lst1: list of integers\n        lst2: list of integers\n        count: number of largest products to return\n\n    Returns:\n        list of largest count of products between two lists\n    \"\"\"\n    # create list of all possible products\n    products = []\n\n    for i in lst1:\n        for j in lst2:\n            products.append(i * j)\n\n    return nlargest(count, products)\n\n\nprint(largest_product([1, 2, 3, 4, 5], [2, 3, 4, 5, 6], 3))"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from heapq import nlargest\nfrom typing import List, Tuple\n\n\ndef largest_product(lists: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    largest: List[int] = nlargest(k, (lists[0][i] * lists[1][i] for i in range(len(lists[0]))))\n\n    return largest\n\n\nif __name__ == \"__main__\":\n    assert largest_product(lists=[[1, 2, 3], [4, 5, 6]], k=2) == [12, 18]"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "from functools import reduce\n\n\n# def largest_product(list1, list2):\n#     \"\"\"\n#     >>> largest_product([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n#     120\n#     >>> largest_product([1, 2, 3, 4, 5], [1, 2, 3, 4])\n#     90\n#     >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4, 5])\n#     90\n#     >>> largest_product([-1, -2], [1, 2, 3, 4])\n#     -6\n#     \"\"\"\n#     # get all combinations of 2 elements from each list\n#     # calculate product of each combination\n#     # return largest products\n#     pass\n\n\ndef largest_product(list1, list2):\n    \"\"\"\n    >>> largest_product([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    120\n    >>> largest_product([1, 2, 3, 4, 5], [1, 2, 3, 4])\n    90\n    >>> largest_product([1, 2, 3, 4], [1, 2, 3, 4, 5])\n    90\n    >>> largest_product([-1, -2], [1, 2, 3, 4])\n    -6\n    \"\"\"\n    # get all combinations of 2 elements from each list\n    # calculate product of each combination\n    # return largest products\n    return reduce(\n        lambda x, y: x if x > y else y,\n        [\n            product\n            for i in range(len(list1))\n            for product in (list1[i] * list2[i], list1[i] * list2[-i], list1[-i] * list2[i], list1[-i] * list2[-i])\n        ],\n        0,\n    )\n\n\nif __name__ =="
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from functools import reduce\nfrom itertools import combinations\nfrom typing import List\n\n\n# Time complexity: O(n * m)\n# Space complexity: O(n * m)\ndef largest_products(list1: List[int], list2: List[int], num: int) -> List[int]:\n    \"\"\"\n    Find specified number of largest products from two lists.\n    :param list1: list of integers\n    :param list2: list of integers\n    :param num: number of largest products\n    :return: list of largest products\n    >>> largest_products([1, 2, 3, 4], [1, 2, 3, 4], 2)\n    [24, 18]\n    >>> largest_products([1, 2, 3], [-1, -2], 1)\n    [-2]\n    >>> largest_products([1, 2, 3], [1, 2, 3], 2)\n    [6, 6]\n    \"\"\"\n    # Generate all possible products between two lists\n    products = [\n        reduce(lambda x, y: x * y, product)\n        for product in combinations(list1 + list2, 2)\n    ]\n\n    # Return largest products\n    return sorted(products, reverse=True)[:num]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from functools import reduce\nfrom itertools import product\n\n\ndef largest_product(list1, list2, num):\n    \"\"\"Return the largest products from two lists.\n\n    Args:\n        list1: A list of numbers.\n        list2: A list of numbers.\n        num: Number of largest products to return.\n\n    Returns:\n        A list of the largest products from two lists.\n    \"\"\"\n    return sorted(\n        reduce(lambda x, y: x + y, product(list1, list2)),\n        reverse=True,\n    )[:num]"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from functools import reduce\n\n\n# Time complexity: O(n * m)\ndef get_largest_products(lists, k):\n    if k == 0:\n        return []\n    # Time complexity: O(n)\n    products = []\n    for i in range(len(lists[0])):\n        # Time complexity: O(m)\n        products.append([lists[0][i] * lists[1][j] for j in range(len(lists[1]))])\n    # Time complexity: O(n * m)\n    return reduce(lambda a, b: a + b, products)\n\n\n# Time complexity: O(n * m)\ndef get_largest_products_optimized(lists, k):\n    if k == 0:\n        return []\n    # Time complexity: O(n)\n    products = []\n    for i in range(len(lists[0])):\n        # Time complexity: O(m)\n        products.append([lists[0][i] * lists[1][j] for j in range(len(lists[1]))])\n    # Time complexity: O(n * m)\n    return reduce(lambda a, b: a + b, products)\n\n\n# Time complexity: O(n * m)\ndef get_largest_products_optimized_2(lists, k):\n    if k == 0:\n        return []\n    # Time complexity: O(n)\n    products = []\n    for i in range(len(lists[0])):\n        # Time complexity: O(m)\n        products.append([lists[0][i] * lists[1][j] for j in range(len(lists[1]))])\n    # Time complexity: O(n * m)\n    return reduce(lambda a, b: a + b, products)\n\n\n# Time complexity: O(n * m)\ndef get_largest_products_optimized_3(lists, k):\n    if k == 0:\n        return []\n    # Time complexity: O(n)\n    products = []\n    for i in range(len(lists[0])):\n        # Time complexity: O(m)\n        products.append([lists["
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def max_product(nums1, nums2, k):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums1) == 0 or len(nums2) == 0 or k == 0:\n        return []\n\n    from queue import PriorityQueue\n    import heapq\n\n    heap = PriorityQueue()\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, nums1[i] * nums2[j])\n            if heap.qsize() > k:\n                heapq.heappop(heap)\n\n    result = []\n    while k:\n        result.append(heap.get())\n        k -= 1\n\n    return result\n\n\ndef max_product_v2(nums1, nums2, k):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if len(nums1) == 0 or len(nums2) == 0 or k == 0:\n        return []\n\n    from queue import PriorityQueue\n    import heapq\n\n    heap = PriorityQueue()\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, nums1[i] * nums2[j])\n            if heap.qsize() > k:\n                heapq.heappop(heap)\n\n    result = []\n    while k:\n        result.append(heap.get())\n        k -= 1\n\n    return result\n\n\ndef test_max_product():\n    assert max_product([-4, -3, -2, -1, 0, 1, 2, 3, 4], [-1, 1], 3) == [-1"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef largest_products(lists: List[int], k: int) -> List[int]:\n    \"\"\"Returns the largest products of the specified number of largest products.\n\n    Args:\n        lists (List[int]): A list of integers.\n        k (int): The number of largest products to return.\n\n    Examples:\n        >>> largest_products([1, 2, 3, 4, 5], 3)\n        [12, 10, 6]\n\n    Returns:\n        List[int]: The largest products of the specified number of largest products.\n    \"\"\"\n    lists.sort()\n    return list(map(lambda x: x[0] * x[1], lists[-k:]))\n\n\nif __name__ == \"__main__\":\n    print(largest_products([1, 2, 3, 4, 5], 3))"
    }
  ]
}