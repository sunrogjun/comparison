{
  "timestamp": "2025-09-14T23:47:49.102862",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 198,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    heappush(heap, item)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    print(delete_smallest([1, 2, 3], 4))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap: list, new_item: int) -> list:\n    \"\"\"Deletes the smallest item from a heap and inserts a new item.\n\n    Args:\n        heap: a list representing a heap\n        new_item: a new item to be inserted\n\n    Returns:\n        a list representing a heap with the smallest item deleted\n        and a new_item inserted\n    \"\"\"\n    if heap:\n        if heap[0] < new_item:\n            heappop(heap)\n        else:\n            heap[0] = new_item\n            heappush(heap, heap[0])\n    return heap\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(delete_and_insert(heap, 0))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    if not heap:\n        return\n\n    if item < heap[0]:\n        heap[0] = item\n        heappop(heap)\n\n\nif __name__ == '__main__':\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    item = 0\n    delete_smallest(heap, item)\n    print(heap)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    smallest = heappop(heap)\n\n    if smallest > item:\n        heappush(heap, smallest)\n        return\n\n    heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 3, 5, 4, 10, 12, 8, 7]\n    delete_smallest(heap, 6)\n    print(heap)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def delete_smallest_and_insert(heap, item):\n    return heapq.nsmallest(1, heap + [item])[-1]\n\n\nif __name__ == \"__main__\":\n    print(delete_smallest_and_insert([1, 2, 3, 4], 5))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    return heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    delete_and_insert(heap, 0)\n    print(heap)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def delete_smallest(heap, new_item):\n    \"\"\"\n    We can solve this problem by deleting the smallest item from the heap and then inserting the new item.\n    However, this is an O(n) operation.\n    We can solve this in O(log n) using a binary heap.\n    We can use the same idea of heap sort to solve this problem.\n    We can delete the smallest item from the heap and then insert the new item.\n    The new item will be placed at the top of the heap.\n    \"\"\"\n    smallest_item = heap.pop()\n    if heap:\n        heap_sort(heap)\n    heap.append(new_item)\n    heapify(heap)\n    return heap\n\n\ndef heapify(heap):\n    \"\"\"\n    We can use the same idea of heap sort to solve this problem.\n    We can delete the smallest item from the heap and then insert the new item.\n    The new item will be placed at the top of the heap.\n    \"\"\"\n    for i in range(len(heap) - 1, -1, -1):\n        parent_index = (i - 1) // 2\n        while i > 0 and heap[i] < heap[parent_index]:\n            heap[i], heap[parent_index] = heap[parent_index], heap[i]\n            i = parent_index\n\n\ndef heap_sort(heap):\n    \"\"\"\n    We can use the same idea of heap sort to solve this problem.\n    We can delete the smallest item from the heap and then insert the new item.\n    The new item will be placed at the top of the heap.\n    \"\"\"\n    for i in range(len(heap) - 1, -1, -1):\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i])"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def delete_smallest(heap, item):\n    smallest = heap[0]\n    heap[0] = item\n    i = 0\n    while True:\n        if i == 0:\n            break\n        parent = (i - 1) // 2\n        if heap[parent] <= heap[i]:\n            break\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n\n\nheap = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\ndelete_smallest(heap, 3)\nprint(heap)"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    heappop(heap)\n    heappush(heap, item)\n\n\ndef main():\n    heap = [10, 15, 12, 14, 19, 17, 16, 20, 13, 20]\n    delete_and_insert(heap, 18)\n    print(heap)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    if len(heap) == 1:\n        return [item]\n\n    top_item = heappop(heap)\n    if top_item > item:\n        return [top_item] + [item] + heap\n    else:\n        return [item] + heap\n\n\nif __name__ == \"__main__\":\n    h = [10, 20, 15, 30, 40, 35]\n    print(delete_and_insert(h, 25))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "import heapq\n\n\ndef delete_smallest(heap, item):\n    heap.remove(min(heap))\n    heapq.heappush(heap, item)\n\n\ndef main():\n    heap = [2, 1, 4, 10, 20]\n    print(heap)\n    delete_smallest(heap, 5)\n    print(heap)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from heap_priority_queue import HeapPriorityQueue\n\ndef delete_smallest_and_insert(heap, item):\n    # heap.delete_smallest()\n    heap.insert(item)\n\nheap = HeapPriorityQueue()\nheap.insert(4)\nheap.insert(5)\nheap.insert(1)\nheap.insert(2)\nheap.insert(3)\nheap.insert(6)\nheap.insert(7)\nheap.insert(8)\nheap.insert(9)\nheap.insert(0)\nheap.insert(10)\nheap.insert(11)\nheap.insert(12)\nheap.insert(13)\nheap.insert(14)\nheap.insert(15)\nheap.insert(16)\nheap.insert(17)\nheap.insert(18)\nheap.insert(19)\nheap.insert(20)\nheap.insert(21)\nheap.insert(22)\nheap.insert(23)\nheap.insert(24)\nheap.insert(25)\nheap.insert(26)\nheap.insert(27)\nheap.insert(28)\nheap.insert(29)\nheap.insert(30)\nheap.insert(31)\nheap.insert(32)\nheap.insert(33)\nheap.insert(34)\nheap.insert(35)\nheap.insert(36)\nheap.insert(37)\nheap.insert(38)\nheap.insert(39)\nheap.insert(40)\nheap.insert(41)\nheap.insert(42)\nheap.insert(43)\nheap.insert(44)\nheap.insert(45)\nheap.insert(46)\nheap.insert(47)\nheap.insert(48)\nheap.insert(49)\nheap.insert(50)\nheap"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def delete_and_insert(heap, new_item):\n    \"\"\"\n    >>> heap = [3, 5, 4, 7, 1, 0, 8, 2]\n    >>> delete_and_insert(heap, 6)\n    >>> heap\n    [3, 5, 4, 7, 1, 6, 8, 2]\n    \"\"\"\n    heap.pop(heap.index(min(heap)))\n    heap.append(new_item)\n    heapify(heap)\n\n\ndef heapify(heap):\n    \"\"\"\n    >>> heap = [3, 5, 4, 7, 1, 0, 8, 2]\n    >>> heapify(heap)\n    >>> heap\n    [0, 1, 2, 4, 5, 7, 8, 3]\n    \"\"\"\n    for i in range(len(heap) // 2, 0, -1):\n        sift_down(heap, i)\n\n\ndef sift_down(heap, i):\n    \"\"\"\n    >>> heap = [3, 5, 4, 7, 1, 0, 8, 2]\n    >>> sift_down(heap, 1)\n    >>> heap\n    [0, 1, 2, 4, 5, 7, 8, 3]\n    \"\"\"\n    left = i * 2\n    right = (i * 2) + 1\n    largest = i\n    if left < len(heap) and heap[left] > heap[largest]:\n        largest = left\n    if right < len(heap) and heap[right] > heap[largest]:\n        largest = right\n    if largest != i:\n        heap[largest], heap[i] = heap[i], heap[largest]\n        sift_down(heap, largest)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_and_insert(heap: list, item: int) -> list:\n    \"\"\"Deletes the smallest element from the given heap and then inserts a new item.\n\n    Args:\n        heap (list): The heap from which the smallest element will be deleted.\n        item (int): The new item to be inserted into the heap.\n\n    Examples:\n        >>> delete_and_insert([1, 2, 3, 4, 5], 6)\n        [2, 4, 6, 3, 5]\n        >>> delete_and_insert([1, 2, 3, 4, 5], 0)\n        [2, 4, 0, 3, 5]\n    \"\"\"\n    if heap:\n        new_heap = [item] + [\n            heap[0] for heap in [heap[1:], [heap[0]]] if heap\n        ]\n        heapify(new_heap)\n        return new_heap\n    return [item]\n\n\nif __name__ == \"__main__\":\n    print(delete_and_insert([1, 2, 3, 4, 5], 6))\n    print(delete_and_insert([1, 2, 3, 4, 5], 0))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    if len(heap) == 0:\n        heappush(heap, item)\n        return heap\n    smallest = heappop(heap)\n    if smallest > item:\n        heappush(heap, smallest)\n        heappush(heap, item)\n        return heap\n    heappush(heap, item)\n    return heap\n\n\nif __name__ == \"__main__\":\n    h = [2, 3, 4, 1]\n    print(delete_smallest(h, 5))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def delete_smallest(heap: list, value: int) -> None:\n    \"\"\"\n    delete the smallest element from the given heap and then insert a new item\n    >>> heap = [1, 2, 3, 4, 5]\n    >>> delete_smallest(heap, 6)\n    >>> heap\n    [2, 4, 5, 6, 1]\n    \"\"\"\n    heap[1] = value\n    heapify(heap, len(heap))\n    if heap[1] < heap[2]:\n        heap[1], heap[2] = heap[2], heap[1]\n\n\ndef heapify(heap: list, n: int) -> None:\n    \"\"\"\n    heapify the heap\n    >>> heap = [1, 2, 3, 4, 5]\n    >>> heapify(heap, 5)\n    >>> heap\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        heapify_down(heap, i, n)\n\n\ndef heapify_down(heap: list, i: int, n: int) -> None:\n    \"\"\"\n    heapify the heap down\n    >>> heap = [1, 2, 3, 4, 5]\n    >>> heapify_down(heap, 1, 5)\n    >>> heap\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    while 2 * i <= n:\n        child = 2 * i\n        if child + 1 <= n and heap[child + 1] < heap[child]:\n            child += 1\n        if heap[i] < heap[child]:\n            heap[i], heap[child] = heap[child], heap[i]\n        else:\n            break\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, new_element):\n    return heappush(heap, new_element)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6]\n    print(delete_and_insert(heap, 7))\n    print(heap)"
    },
    {
      "rank": 18,
      "score": 9.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_insert(heap, item):\n    return [heappush(heap, item), heappop(heap)]\n\n\nif __name__ == \"__main__\":\n    heap = [2, 3, 5, 1, 7]\n    print(delete_min_insert(heap, 6))"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_smallest_and_insert(heap, new_item):\n    smallest = heappop(heap)\n    heappush(heap, new_item)\n\n\nheap = [2, 3, 1, 5, 4]\nheapify(heap)\nprint(heap)\ndelete_smallest_and_insert(heap, 0)\nprint(heap)"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "import heapq\n\ndef delete_smallest_element_and_insert(heap, item):\n    # Your code here\n    if not heap:\n        heapq.heappush(heap, item)\n        return\n    temp = heapq.heappop(heap)\n    heapq.heappush(heap, item)\n    if temp == heap[0]:\n        heapq.heappop(heap)\n        heapq.heappush(heap, item)\n\n\nif __name__ == '__main__':\n    h = []\n    delete_smallest_element_and_insert(h, 5)\n    delete_smallest_element_and_insert(h, 3)\n    delete_smallest_element_and_insert(h, 6)\n    delete_smallest_element_and_insert(h, 4)\n    delete_smallest_element_and_insert(h, 2)\n    delete_smallest_element_and_insert(h, 1)\n    print(h)"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "def delete_and_insert(heap, item):\n    heap.pop(0)\n    heap.append(item)\n    heapify(heap)\n\n\ndef heapify(heap):\n    for i in range(len(heap)//2 - 1, -1, -1):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        smallest = i\n        if left < len(heap) and heap[left] < heap[smallest]:\n            smallest = left\n        if right < len(heap) and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            heap[i], heap[smallest] = heap[smallest], heap[i]\n            heapify(heap)"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\nclass Heap:\n    def __init__(self, items=None):\n        self.items = items or []\n        heapq.heapify(self.items)\n\n    def delete_min(self):\n        return heappop(self.items)\n\n    def insert(self, item):\n        heappush(self.items, item)\n\n\ndef delete_and_insert(heap, item):\n    \"\"\"\n    :param heap: Heap class\n    :param item: item to be inserted\n    :return:\n    \"\"\"\n    smallest_item = heap.delete_min()\n    heap.insert(item)\n    return smallest_item\n\n\nif __name__ == \"__main__\":\n    heap = Heap([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    print(heap.items)\n    print(delete_and_insert(heap, 10))\n    print(heap.items)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "from heap_priority_queue import HeapPriorityQueue\n\n\ndef delete_smallest(heap: HeapPriorityQueue, item):\n    smallest = heap.extract_min()\n    return heap.insert(smallest, item)"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "from heap_priority_queue_class import HeapPriorityQueue\n\n\ndef delete_and_insert(heap, new_item):\n    \"\"\"\n    Delete the smallest item from the given heap and then insert a new item.\n\n    @param heap: The heap to delete from.\n    @type heap: HeapPriorityQueue\n    @param new_item: The item to insert.\n    @type new_item: any\n    @return: The new heap.\n    @rtype: HeapPriorityQueue\n    \"\"\"\n    if heap.is_empty():\n        raise Exception('Heap is empty.')\n\n    return heap.insert(heap.delete_min() + new_item)\n\n\ndef main():\n    h = HeapPriorityQueue()\n    h.insert(1)\n    h.insert(3)\n    h.insert(5)\n    h.insert(7)\n    h.insert(9)\n    print h\n    print delete_and_insert(h, 2)\n    print h\n    print delete_and_insert(h, 4)\n    print h\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "import heapq\n\ndef delete_min_and_insert_new(heap, item):\n    \"\"\"Delete the smallest element from the heap and insert new item.\"\"\"\n    heapq.heappush(heap, item)\n    return heapq.heappop(heap)\n\ndef main():\n    heap = [1, 3, 5, 7, 9, 11]\n    item = 4\n    print(delete_min_and_insert_new(heap, item))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, elements=None):\n        self.elements = elements or []\n        self.heap_size = len(self.elements)\n\n    def _parent_index(self, child_index):\n        return (child_index - 1) // 2\n\n    def _left_child_index(self, parent_index):\n        return 2 * parent_index + 1\n\n    def _right_child_index(self, parent_index):\n        return 2 * parent_index + 2\n\n    def _swap(self, i, j):\n        self.elements[i], self.elements[j] = self.elements[j], self.elements[i]\n\n    def _upheap(self, child_index):\n        if child_index == 0:  # Heap is empty\n            return\n\n        parent_index = self._parent_index(child_index)\n        if self.elements[parent_index] < self.elements[child_index]:\n            self._swap(child_index, parent_index)\n            self._upheap(parent_index)\n\n    def _downheap(self, parent_index):\n        left_child_index = self._left_child_index(parent_index)\n        right_child_index = self._right_child_index(parent_index)\n        smaller_child_index = left_child_index\n        if left_child_index < self.heap_size and \\\n                self.elements[left_child_index] < self.elements[smaller_child_index]:\n            smaller_child_index = left_child_index\n\n        if right_child_index < self.heap_size and \\\n                self.elements[right_child_index] < self.elements[smaller_child_index]:\n            smaller_child_index = right_child_index\n\n        if smaller_child_index != parent_index:\n            self._swap(parent_index, smaller_child_index)\n            self._downheap(smaller_child_index)\n\n    def push(self, item):\n        self.elements.append(item)\n        self."
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def delete_smallest(heap, new_item):\n    if len(heap) == 0:\n        heap.append(new_item)\n        return\n    if new_item < heap[0]:\n        heap[0] = new_item\n        heapq._siftup(heap, 0)\n    else:\n        heapq.heappushpop(heap, new_item)\n\n\nif __name__ == \"__main__\":\n    import heapq\n    heap = []\n    delete_smallest(heap, 2)\n    delete_smallest(heap, 3)\n    delete_smallest(heap, 1)\n    delete_smallest(heap, 4)\n    delete_smallest(heap, 0)\n    print(heap)"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "import heapq\n\n\nclass Heap:\n  def __init__(self):\n    self.heap = []\n\n  def delete_and_insert(self, item):\n    # if heap is empty, just insert\n    if len(self.heap) == 0:\n      heapq.heappush(self.heap, item)\n      return\n\n    # if heap is not empty, delete smallest item, and insert\n    smallest_item = heapq.heappop(self.heap)\n    heapq.heappush(self.heap, item)\n\n  def get_smallest(self):\n    return self.heap[0]\n\n\nheap = Heap()\nheap.delete_and_insert(1)\nheap.delete_and_insert(2)\nheap.delete_and_insert(3)\nheap.delete_and_insert(4)\nheap.delete_and_insert(5)\nprint(heap.get_smallest())"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def delete_and_insert(heap, new_item):\n    \"\"\"Delete smallest item from heap and insert new item.\"\"\"\n    return [heap[0], *heap[1:]], new_item\n\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap, new_item = delete_and_insert(heap, 10)\n    print(heap)\n    print(new_item)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, new_element):\n    return heappush(heap, new_element)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(delete_smallest(heap, 0))\n    print(heap)\n    print(delete_smallest(heap, 0))\n    print(heap)"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min(heap, val):\n    \"\"\"\n    :param heap: input heap\n    :param val: element to be inserted\n    :return: new heap\n\n    Time complexity: O(logn)\n    Space complexity: O(1)\n    \"\"\"\n    # Remove min and push new item\n    heappop(heap)\n    heappush(heap, val)\n\n    return heap\n\n\n# Tests\nassert delete_min([1, 2, 3, 4, 5], 6) == [2, 3, 4, 5, 6]"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def heap_delete_insert(heap, x):\n    \"\"\"\n    >>> heap = [3, 9, 17, 19, 25, 29, 31, 33, 35, 37]\n    >>> heap_delete_insert(heap, 23)\n    >>> heap\n    [17, 9, 25, 19, 31, 29, 33, 23, 35, 37]\n    \"\"\"\n    heap.remove(min(heap))\n    heap.append(x)\n    heapify(heap)\n\ndef heapify(heap):\n    \"\"\"\n    >>> heap = [3, 9, 17, 19, 25, 29, 31, 33, 35, 37]\n    >>> heapify(heap)\n    >>> heap\n    [9, 3, 17, 19, 25, 29, 31, 33, 35, 37]\n    \"\"\"\n    heap_size = len(heap)\n    for i in range(heap_size - 1, -1, -1):\n        parent = i\n        child = 2 * i + 1\n        while child < heap_size:\n            if child + 1 < heap_size and heap[child + 1] < heap[child]:\n                child += 1\n            if heap[parent] < heap[child]:\n                break\n            heap[parent], heap[child] = heap[child], heap[parent]\n            parent = child\n            child = 2 * parent + 1"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, value):\n    if not heap:\n        return\n\n    if value < heap[0]:\n        return\n\n    heappop(heap)\n    heappush(heap, value)\n\n\nif __name__ == \"__main__\":\n    heap = [3, 2, 1, 4, 5, 7, 8, 10, 9]\n    delete_and_insert(heap, 2)\n    assert heap == [2, 4, 7, 8, 5, 10, 9, 1, 3]"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "class Heap:\n\n    def __init__(self, data=[]):\n        self.data = data\n        self.heap_size = len(data)\n\n    def insert(self, value):\n        self.data.append(value)\n        self.heap_size += 1\n        self.bubble_up(self.heap_size - 1)\n\n    def bubble_up(self, index):\n        if index == 0:\n            return\n\n        parent_index = (index - 1) // 2\n        if self.data[parent_index] < self.data[index]:\n            self.data[parent_index], self.data[index] = self.data[index], self.data[parent_index]\n            self.bubble_up(parent_index)\n\n    def delete(self):\n        if self.heap_size == 0:\n            return None\n\n        item = self.data[0]\n        self.data[0] = self.data[self.heap_size - 1]\n        self.heap_size -= 1\n        self.bubble_down(0)\n        return item\n\n    def bubble_down(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n\n        if left_child_index >= self.heap_size:\n            return\n\n        min_index = self.get_min_index(left_child_index, right_child_index)\n        if self.data[index] > self.data[min_index]:\n            self.data[index], self.data[min_index] = self.data[min_index], self.data[index]\n            self.bubble_down(min_index)\n\n    def get_min_index(self, left_child_index, right_child_index):\n        if right_child_index >= self.heap_size:\n            return left_child_index\n\n        if self.data[left_child_index] < self.data[right_child_index]:\n            return left_child_index\n        else"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "import heapq\n\ndef delete_smallest_and_insert(heap, item):\n    heap.pop(0)\n    heapq.heapify(heap)\n    heapq.heappush(heap, item)\n\nheap = [1,2,3,4,5]\ndelete_smallest_and_insert(heap, 6)\nprint(heap)"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest_and_add(heap, item):\n    \"\"\"Delete the smallest element from the given heap and then insert a new item.\n\n    Args:\n        heap: a list representing a heap.\n        item: a new item to be inserted into the heap.\n\n    Returns:\n        None.\n\n    Time Complexity: O(logN)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(heap) == 1:\n        return\n\n    heappush(heap, item)\n    return heappop(heap)\n\n\nif __name__ == '__main__':\n    # Test 1\n    print(delete_smallest_and_add([10, 20, 30, 5, 15], 25))\n\n    # Test 2\n    print(delete_smallest_and_add([10, 20, 30, 5, 15], 2))\n\n    # Test 3\n    print(delete_smallest_and_add([10, 20, 30, 5, 15], 10))\n\n    # Test 4\n    print(delete_smallest_and_add([10, 20, 30, 5, 15], 15))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(h, item):\n    return heappush(heappop(h), item)\n\n\nif __name__ == \"__main__\":\n    h = [2, 3, 4, 1, 5]\n    heappush(h, 0)\n    print(delete_and_insert(h, 6))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_smallest_element(heap, new_element):\n    if heap and heap[0] > new_element:\n        return\n\n    heappush(heap, new_element)\n\n    while heap and heap[0] == new_element:\n        heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [2, 1, 4, 3]\n    heapify(heap)\n    delete_smallest_element(heap, 3)\n    print(heap)"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "import heapq\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        heapq.heappush(self.heap, item)\n\n    def delete_smallest(self):\n        return heapq.heappop(self.heap)\n\n    def get_smallest(self):\n        return self.heap[0]\n\n    def __repr__(self):\n        return str(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap()\n    h.insert(5)\n    h.insert(1)\n    h.insert(2)\n    h.insert(10)\n    h.insert(9)\n    print(h)\n    print(h.get_smallest())\n    print(h.delete_smallest())\n    print(h)"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, new_item):\n    return heappush(heap, new_item)\n\n\nif __name__ == \"__main__\":\n    heap = [2, 1, 4, 5, 7]\n    print(delete_smallest(heap, 3))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "def delete_smallest_element(heap, item):\n    \"\"\"\n    Delete the smallest element from the heap and then insert the new item.\n\n    Time complexity: O(logn).\n    Space complexity: O(1).\n    \"\"\"\n    if not heap:\n        return\n\n    # Replace the root with the last element.\n    heap[0] = heap.pop()\n\n    # Bubble down.\n    _bubble_down(heap, 0)\n\n    # Insert the new item.\n    heap.append(item)\n\n    # Bubble up.\n    _bubble_up(heap, len(heap) - 1)\n\n\ndef _bubble_down(heap, i):\n    \"\"\"Bubble down the heap to maintain the heap property.\"\"\"\n    if i < len(heap):\n        left_child = i * 2 + 1\n        right_child = i * 2 + 2\n\n        # If the left child is smaller than the root, swap with the left child.\n        if left_child < len(heap) and heap[left_child] < heap[i]:\n            heap[left_child], heap[i] = heap[i], heap[left_child]\n            _bubble_down(heap, left_child)\n            return\n\n        # If the right child is smaller than the root, swap with the right child.\n        if right_child < len(heap) and heap[right_child] < heap[i]:\n            heap[right_child], heap[i] = heap[i], heap[right_child]\n            _bubble_down(heap, right_child)\n            return\n\n\ndef _bubble_up(heap, i):\n    \"\"\"Bubble up the heap to maintain the heap property.\"\"\"\n    if i >= 0:\n        parent = (i - 1) // 2\n\n        # If the parent is smaller than the current node, swap with the parent.\n        if parent >= 0 and heap[parent] > heap[i]:\n            heap[parent], heap[i] = heap[i], heap[parent]\n            _bubble_up(heap, parent)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest_element(heap, new_item):\n    heappop(heap)\n    heappush(heap, new_item)\n\n\ndef main():\n\n    arr = [10, 11, 12, 13, 14, 15]\n    heap = list(arr)\n    heappush(heap, 1)\n    print(f\"Initial heap: {heap}\")\n    delete_smallest_element(heap, 2)\n    print(f\"After deleting smallest element: {heap}\")\n    heappush(heap, 2)\n    print(f\"After adding new element: {heap}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "import heapq\n\n\nclass MinHeap:\n    def __init__(self, array):\n        self.heap = array\n        heapq.heapify(self.heap)\n\n    def pop(self, item):\n        return heapq.heappush(self.heap, item)\n\n    def extract_min(self):\n        return heapq.heappop(self.heap)\n\n    def delete_min(self):\n        return heapq.heappop(self.heap)\n\n\nheap = MinHeap([2, 4, 5, 7, 1, 6, 3])\nprint(heap.delete_min())\nheap.pop(10)\nprint(heap.delete_min())"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def delete_and_insert(self, item):\n        if len(self.heap) == 0:\n            self.heap.append(item)\n        else:\n            if item > self.heap[0]:\n                self.heap[0] = item\n                heappop(self.heap)\n                heappush(self.heap, item)\n            else:\n                heappop(self.heap)\n                heappush(self.heap, item)\n\n    def get_max(self):\n        return self.heap[0]\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:\n        heap.delete_and_insert(i)\n        print(heap.get_max())"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_insert(arr, new_item):\n    \"\"\"\n    O(log n)\n    \"\"\"\n    if len(arr) == 0:\n        return\n\n    if len(arr) == 1:\n        return heappush(arr, new_item)\n\n    min_element = heappop(arr)\n    heappush(arr, new_item)\n    return min_element\n\n\nif __name__ == \"__main__\":\n    a = [1, 2, 3, 4, 5]\n    print(delete_min_insert(a, 10))\n    print(a)\n    print(delete_min_insert(a, 100))\n    print(a)"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def delete_smallest(arr):\n    arr.pop(0)\n    if len(arr) == 0:\n        return arr\n    elif len(arr) % 2 == 0:\n        if arr[0] > arr[1]:\n            arr[0], arr[1] = arr[1], arr[0]\n    else:\n        if arr[0] < arr[1]:\n            arr[0], arr[1] = arr[1], arr[0]\n    return arr\n\n\ndef heapify(arr, n, i):\n    smallest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] < arr[smallest]:\n        smallest = left\n\n    if right < n and arr[right] < arr[smallest]:\n        smallest = right\n\n    if smallest != i:\n        arr[i], arr[smallest] = arr[smallest], arr[i]\n        heapify(arr, n, smallest)\n\n\ndef insert(arr, n, ele):\n    arr.append(ele)\n    n += 1\n    i = n - 1\n    while i > 0:\n        parent = (i - 1) // 2\n        if arr[parent] > arr[i]:\n            arr[parent], arr[i] = arr[i], arr[parent]\n            i = parent\n        else:\n            break\n    return n\n\n\ndef delete(arr, n, ele):\n    arr.remove(ele)\n    n -= 1\n    i = 0\n    while True:\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left >= n:\n            break\n        elif right >= n:\n            if arr[i] > arr[left]:\n                arr[i], arr[left] = arr[left], arr[i]\n            break\n        else:\n            if arr[left] < arr[right]:\n                if arr[i] > arr[left]:\n                    arr[i], arr[left] = arr[left], arr[i]\n                    i = left"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, elems=[]):\n        self.elems = elems\n        self.heapify()\n\n    def heapify(self):\n        for i in range(len(self.elems)//2, -1, -1):\n            self.heap_down(i)\n\n    def heap_down(self, i):\n        min_i = i\n        left = 2*i + 1\n        right = 2*i + 2\n\n        if left < len(self.elems) and self.elems[left] < self.elems[min_i]:\n            min_i = left\n        if right < len(self.elems) and self.elems[right] < self.elems[min_i]:\n            min_i = right\n\n        if i != min_i:\n            self.elems[min_i], self.elems[i] = self.elems[i], self.elems[min_i]\n            self.heap_down(min_i)\n\n    def heap_up(self, i):\n        parent = (i-1)//2\n        if parent >= 0 and self.elems[parent] > self.elems[i]:\n            self.elems[parent], self.elems[i] = self.elems[i], self.elems[parent]\n            self.heap_up(parent)\n\n    def pop(self):\n        self.elems[0], self.elems[-1] = self.elems[-1], self.elems[0]\n        value = self.elems.pop()\n        self.heap_down(0)\n        return value\n\n    def push(self, elem):\n        self.elems.append(elem)\n        self.heap_up(len(self.elems)-1)\n\n    def __repr__(self):\n        return str(self.elems)\n\n\ndef delete_smallest(heap, elem):\n    if len(heap.elems) == 1:\n        return heap.pop()\n\n    heap.push(elem)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    if not heap:\n        return\n    if len(heap) == 1:\n        return heappop(heap)\n\n    # delete smallest item\n    smallest = heappop(heap)\n    # insert new item\n    heappush(heap, item)\n    return smallest\n\n\nif __name__ == \"__main__\":\n    print(delete_smallest([1, 2, 3], 0))\n    print(delete_smallest([1, 2, 3], 10))\n    print(delete_smallest([1, 2, 3], 2))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef delete_smallest(heap, item):\n    smallest = heapq.heappop(heap)\n    if smallest != item:\n        heapq.heappush(heap, item)\n\n\nheap = [1, 2, 3, 4, 5]\nprint(heap)\ndelete_smallest(heap, 1)\nprint(heap)"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def delete_and_insert(heap, new_item):\n    if new_item < heap[0]:\n        heap[0] = new_item\n    else:\n        if heap[0] < new_item:\n            heap[0] = new_item\n    return heap"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_insert(heap, item):\n    heap.remove(heap[0])\n    heappush(heap, item)\n\n\ndef main():\n\n    heap = [1, 2, 3, 4, 5]\n    heappush(heap, 6)\n    print(heap)\n    heappush(heap, 7)\n    print(heap)\n    heappush(heap, 8)\n    print(heap)\n    heappush(heap, 9)\n    print(heap)\n    heappush(heap, 10)\n    print(heap)\n    delete_min_insert(heap, 11)\n    print(heap)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\ndef delete_and_insert(heap, item):\n    \"\"\"\n    Delete the smallest element from the heap and insert a new item.\n    \"\"\"\n    if heap:\n        heap[0] = item\n        heappop(heap)\n        heappush(heap, heap[0])\n\ndef main():\n    heap = [3, 2, 1, 4, 5, 6, 7, 9, 8]\n    heappush(heap, 10)\n    heappush(heap, 11)\n    heappush(heap, 12)\n    print(heap)\n    delete_and_insert(heap, 15)\n    print(heap)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    heappush(heap, item)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [3, 5, 2, 6, 1, 7, 8, 9, 4]\n    print(delete_and_insert(heap, 0))\n    print(heap)"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def heapify(arr, n, i):\n    smallest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n\n    if l < n and arr[i] > arr[l]:\n        smallest = l\n\n    if r < n and arr[smallest] > arr[r]:\n        smallest = r\n\n    if smallest != i:\n        arr[i], arr[smallest] = arr[smallest], arr[i]\n        heapify(arr, n, smallest)\n\n\ndef delete_smallest(arr, n, i):\n    arr[0], arr[n - 1] = arr[n - 1], arr[0]\n    heapify(arr, n - 1, 0)\n\n\ndef insert(arr, n, item):\n    arr[n] = item\n    i = n\n    while i > 0 and arr[i // 2] < arr[i]:\n        arr[i // 2], arr[i] = arr[i], arr[i // 2]\n        i = i // 2\n\n\ndef delete_and_insert(arr, item):\n    delete_smallest(arr, len(arr), 0)\n    insert(arr, len(arr), item)\n\n\nif __name__ == \"__main__\":\n    arr = [5, 10, 100, 50, 1, 2]\n    delete_and_insert(arr, 99)\n    print(arr)"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def delete_min(heap, new_item):\n    heap[0] = new_item\n    i = 0\n    while i < len(heap):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        min_index = i\n        if left < len(heap) and heap[left] < heap[min_index]:\n            min_index = left\n        if right < len(heap) and heap[right] < heap[min_index]:\n            min_index = right\n        if min_index != i:\n            heap[i], heap[min_index] = heap[min_index], heap[i]\n            i = min_index\n        else:\n            break\n\n\nheap = [1, 2, 3, 4, 5]\ndelete_min(heap, 10)\nprint(heap)"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_smallest(h, x):\n    heappush(h, x)\n    return heappop(h)\n\n\nif __name__ == \"__main__\":\n    h = [1, 2, 3, 4, 5]\n    heapify(h)\n    print(delete_smallest(h, 6))\n    print(h)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef delete_smallest(heap, item):\n    # Create a new heap with the same elements as the original heap\n    # but without the smallest element\n    new_heap = heap[:]\n    heapq.heapify(new_heap)\n\n    # Insert the new item into the new heap\n    heapq.heappush(new_heap, item)\n\n    # Return the smallest element in the original heap\n    return heapq.heappop(new_heap)\n\n\nif __name__ == \"__main__\":\n    heap = [2, 4, 5, 1, 3, 8, 9]\n    print(delete_smallest(heap, 0))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "from heap_priority_queue import HeapPriorityQueue\n\n\ndef delete_min_insert(heap, item):\n    \"\"\"Delete the smallest element from the heap and then insert a new item.\"\"\"\n    if not heap.is_empty():\n        item = heap.delete_min()\n        heap.insert(item)\n\n\nheap = HeapPriorityQueue()\nheap.insert(1)\nheap.insert(5)\nheap.insert(6)\nheap.insert(2)\nheap.insert(7)\nheap.insert(3)\nheap.insert(8)\nheap.insert(4)\n\nprint(heap.heap)\nprint(heap.delete_min())\nprint(heap.heap)\ndelete_min_insert(heap, 9)\nprint(heap.heap)"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "import heapq\n\ndef delete_smallest(heap, item):\n    \"\"\"\n    :param heap: list\n    :param item: int\n    :return: list\n    \"\"\"\n    # Your code here\n    if len(heap) == 0:\n        heapq.heappush(heap, item)\n        return heap\n\n    if item < heap[0]:\n        heapq.heappush(heap, item)\n        return heap\n\n    return [item] + [heap[0]] + heap[1:]\n\nif __name__ == '__main__':\n    # Use the main function here to test your implementation\n    heap = [10, 2, 3]\n    print(delete_smallest(heap, 5))\n    print(delete_smallest(heap, 1))\n    print(delete_smallest(heap, 20))"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef delete_min_insert(heap, x):\n    min_val = heappop(heap)\n    heappush(heap, x)\n    return min_val\n\n\nif __name__ == \"__main__\":\n    h = [1, 2, 3, 4, 5]\n    heappush(h, 6)\n    print(h)\n    print(delete_min_insert(h, 7))\n    print(h)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    if heap[0] == item:\n        heappop(heap)\n        heappush(heap, item)\n    else:\n        heappop(heap)\n        heappush(heap, item)\n\n\ndef main():\n    heap = [10, 20, 30, 5, 15, 40]\n    print(\"Initial heap:\", heap)\n    delete_and_insert(heap, 100)\n    print(\"After delete and insert:\", heap)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef delete_smallest_and_insert(heap: List[int], item: int) -> List[int]:\n    \"\"\"\n    This is the solution I came up with.\n    But it's not very elegant.\n    \"\"\"\n    if len(heap) == 0:\n        return [item]\n\n    heap.append(item)\n    heap.sort()\n\n    return heap[:-1]\n\n\nif __name__ == \"__main__\":\n    assert delete_smallest_and_insert([1, 2, 3, 4, 5, 6], 7) == [1, 2, 3, 4, 7, 6]\n    assert delete_smallest_and_insert([1, 2, 3, 4, 5, 6], 0) == [1, 2, 3, 4, 6, 0]\n    assert delete_smallest_and_insert([1, 2, 3, 4, 5, 6], 6) == [1, 2, 3, 4, 5, 6]"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_insert(h, x):\n    return heappush(h, x)\n\n\nif __name__ == \"__main__\":\n    h = [1, 2, 3, 4, 5]\n    heappush(h, 6)\n    print(h)\n    heappop(h)\n    print(h)"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, value):\n    heappush(heap, value)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(delete_and_insert(heap, 6))"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef delete_and_add(heap, item):\n    # O(n)\n    heap.pop(0)\n    heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [2, 3, 4, 5, 6, 7, 8, 9]\n    heapify(heap)\n    print(heap)\n    delete_and_add(heap, 1)\n    print(heap)"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, elems):\n        self.elems = elems\n        self.heap_size = len(elems)\n\n    def min_heapify(self, i):\n        smallest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < self.heap_size and self.elems[l] < self.elems[smallest]:\n            smallest = l\n\n        if r < self.heap_size and self.elems[r] < self.elems[smallest]:\n            smallest = r\n\n        if smallest != i:\n            self.elems[i], self.elems[smallest] = self.elems[smallest], self.elems[i]\n            self.min_heapify(smallest)\n\n    def build_min_heap(self):\n        for i in range(len(self.elems) // 2, -1, -1):\n            self.min_heapify(i)\n\n    def delete_min(self):\n        if self.heap_size == 0:\n            return None\n        min_elem = self.elems[0]\n        self.elems[0] = self.elems[self.heap_size - 1]\n        self.heap_size -= 1\n        self.min_heapify(0)\n        return min_elem\n\n\ndef delete_and_insert(heap, elems):\n    min_elem = heap.delete_min()\n    heap.elems.append(elems)\n    heap.heap_size += 1\n    heap.build_min_heap()\n\n\ndef main():\n    elems = [10, 15, 13, 18, 20, 25]\n    heap = Heap(elems)\n    heap.build_min_heap()\n    print(\"Heap: \" + str(heap.elems))\n    print(\"Deleted min: \" + str(heap.delete_min()))\n    print(\"Heap: \" + str(he"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def delete_smallest(h, n):\n    if n == 1:\n        return h[1]\n    if n == 2:\n        return h[1]\n\n    # swap root with the last element\n    h[1], h[n] = h[n], h[1]\n    # delete the last element\n    h.pop()\n    # maintain the heap property\n    i = 1\n    while i <= len(h):\n        # if i is a parent node\n        if i * 2 <= len(h):\n            # get the smaller child\n            if h[i * 2] < h[i * 2 + 1]:\n                min_child = i * 2\n            else:\n                min_child = i * 2 + 1\n\n            # if the parent node is greater than the smaller child, swap them\n            if h[i] > h[min_child]:\n                h[i], h[min_child] = h[min_child], h[i]\n                i = min_child\n            else:\n                break\n        # if i is a leaf node\n        elif i * 2 > len(h):\n            # if the parent node is greater than the leaf node, swap them\n            if h[i // 2] > h[i]:\n                h[i // 2], h[i] = h[i], h[i // 2]\n                i = i // 2\n            else:\n                break\n        else:\n            # if the parent node is greater than the child node, swap them\n            if h[i // 2] > h[i]:\n                h[i // 2], h[i] = h[i], h[i // 2]\n                i = i // 2\n            else:\n                break\n    return h[1]\n\n\nif __name__ == \"__main__\":\n    h = [10, 5, 7, 11, 9, 8, 12, 14, 13, 17, 18, 20]\n    n = 12\n    print(delete_smallest(h, n))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    if not heap:\n        heappush(heap, item)\n    else:\n        if item < heap[0]:\n            heappop(heap)\n        else:\n            heappop(heap)\n        heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    h = [1, 3, 5, 4, 10, 12, 8]\n    heappush(h, 6)\n    print(h)\n    delete_smallest(h, 7)\n    print(h)"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "def delete_min(arr):\n    return arr[1:]\n\ndef insert(arr, val):\n    return [val] + arr\n\ndef delete_smallest_and_insert(arr, val):\n    return insert(delete_min(arr), val)\n\nif __name__ == '__main__':\n    print(delete_smallest_and_insert([1, 2, 3, 4, 5], 6))"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    \"\"\"Delete the smallest element from the heap and then insert a new item.\n\n    Args:\n        heap (list): list representation of a heap\n        item (int): item to insert\n\n    Returns:\n        list: list representation of a heap\n    \"\"\"\n    if not heap:\n        return\n\n    # pop smallest element from heap\n    heappop(heap)\n\n    # insert new item\n    heappush(heap, item)\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(delete_and_insert(heap, 6))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef delete_smallest_and_insert(heap: List[int], item: int) -> None:\n    \"\"\"Deletes the smallest element from the heap and then insert a new item.\n\n    Args:\n        heap (List[int]): list representation of the heap\n        item (int): the item to be inserted\n    \"\"\"\n    if len(heap) == 0:\n        heap.append(item)\n        return\n\n    if heap[0] >= item:\n        heap.insert(0, item)\n        heapify(heap)\n        return\n\n    # heap[0] < item\n    # find smallest index\n    smallest_index = 0\n    for i in range(1, len(heap)):\n        if heap[i] < heap[smallest_index]:\n            smallest_index = i\n\n    # smallest_index != 0\n    if smallest_index != 0:\n        heap[smallest_index], heap[0] = heap[0], heap[smallest_index]\n\n    heap.insert(0, item)\n    heapify(heap)\n\n\ndef heapify(heap: List[int]) -> None:\n    \"\"\"Converts a list into a max heap inplace.\n\n    Args:\n        heap (List[int]): list representation of the heap\n    \"\"\"\n    for i in range(len(heap) // 2, -1, -1):\n        heapify_parent_to_children(heap, i)\n\n\ndef heapify_parent_to_children(heap: List[int], i: int) -> None:\n    \"\"\"Converts the subtree starting from index i into a max heap.\n\n    Args:\n        heap (List[int]): list representation of the heap\n        i (int): index of the root\n    \"\"\"\n    left = i * 2 + 1\n    right = i * 2 + 2\n\n    largest = i\n    if left < len(heap) and heap[left] > heap[largest]:\n        largest = left\n\n    if right < len(heap) and heap[right] > heap[largest]:"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "def delete_smallest(h: list, x: int) -> None:\n    \"\"\"\n    Time Complexity: O(log(n))\n    \"\"\"\n    if h[0] == x:\n        h[0], h[-1] = h[-1], h[0]\n        del h[-1]\n        return\n\n    i = 1\n    while i < len(h):\n        if h[i] == x:\n            h[i], h[i - 1] = h[i - 1], h[i]\n            del h[i]\n            return\n        i *= 2\n\n\nif __name__ == \"__main__\":\n    heap = [2, 3, 5, 7, 13, 11]\n    delete_smallest(heap, 7)\n    print(heap)"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, new_item):\n    heappop(heap)\n    heappush(heap, new_item)\n\n\nif __name__ == \"__main__\":\n    heap = [4, 10, 3, 5, 1]\n    delete_smallest(heap, 100)\n    print(heap)"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def delete_smallest_heap(heap, new_item):\n    return heap[1:] + [new_item]\n\n\ndef main():\n    heap = [10, 11, 12, 13, 14, 15, 16, 17, 18]\n    new_item = 100\n    result = delete_smallest_heap(heap, new_item)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_and_insert(array: list, item: int) -> list:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    heapify(array)\n\n    smallest_item = heappop(array)\n\n    heappush(array, item)\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert delete_and_insert([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) == [\n        2,\n        4,\n        6,\n        8,\n        10,\n        9,\n        7,\n        5,\n        3,\n        11,\n    ]"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Heap:\n    def __init__(self, array: List[int]):\n        self.array = array\n        self.heap_size = len(array)\n\n    def build_heap(self):\n        for i in range(len(self.array) // 2, -1, -1):\n            self.heapify(i)\n\n    def heapify(self, i):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        smallest = i\n        if left < self.heap_size and self.array[left] < self.array[smallest]:\n            smallest = left\n        if right < self.heap_size and self.array[right] < self.array[smallest]:\n            smallest = right\n        if smallest != i:\n            self.array[i], self.array[smallest] = self.array[smallest], self.array[i]\n            self.heapify(smallest)\n\n    def delete_min(self) -> int:\n        if self.heap_size == 0:\n            return None\n        if self.heap_size == 1:\n            return self.array.pop(0)\n        result = self.array[0]\n        self.array[0] = self.array[self.heap_size - 1]\n        self.heap_size -= 1\n        self.heapify(0)\n        return result\n\n    def insert(self, key):\n        self.array.append(key)\n        self.heap_size += 1\n        i = self.heap_size - 1\n        while i > 0:\n            parent = (i - 1) // 2\n            if self.array[parent] > self.array[i]:\n                self.array[parent], self.array[i] = self.array[i], self.array[parent]\n                i = parent\n            else:\n                break\n\n\nclass Solution:\n    def delete_and_insert(self, heap: List[int], key: int) -> List[int]:\n        heap.append(key)\n        heap"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def insert(self, item):\n        self.arr.append(item)\n        self.heapify_down()\n\n    def delete_smallest(self):\n        self.arr[0], self.arr[-1] = self.arr[-1], self.arr[0]\n        del_item = self.arr.pop()\n        self.heapify_up()\n        return del_item\n\n    def heapify_down(self):\n        parent = 0\n        while (parent * 2) + 1 < len(self.arr):\n            left_child = (parent * 2) + 1\n            right_child = left_child + 1\n            largest_child = parent\n\n            if self.arr[largest_child] < self.arr[left_child]:\n                largest_child = left_child\n\n            if right_child < len(self.arr) and self.arr[largest_child] < self.arr[right_child]:\n                largest_child = right_child\n\n            if largest_child == parent:\n                break\n\n            self.arr[parent], self.arr[largest_child] = self.arr[largest_child], self.arr[parent]\n            parent = largest_child\n\n    def heapify_up(self):\n        child = len(self.arr) - 1\n        while child > 0:\n            parent = (child - 1) // 2\n            if self.arr[parent] < self.arr[child]:\n                self.arr[parent], self.arr[child] = self.arr[child], self.arr[parent]\n                child = parent\n            else:\n                break\n\n\nheap = Heap([10, 5, 2, 3, 6])\nheap.insert(1)\nheap.delete_smallest()\nprint(heap.arr)"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap: list, item: int):\n    heappop(heap)\n    heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    delete_and_insert(heap, 6)\n    print(heap)"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef delete_and_insert(heap, item):\n    heapq.heapreplace(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    delete_and_insert(heap, 11)\n    print(heap)"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "import heapq\n\ndef delete_smallest(heap, item):\n    \"\"\"\n    :param heap: list of items\n    :param item: item to insert\n    :return: None\n    \"\"\"\n    heapq.heappush(heap, item)\n    return heapq.heappop(heap)\n\n\nif __name__ == \"__main__\":\n    h = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(delete_smallest(h, 11))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from typing import List\nfrom heapq import heappush, heappop\n\n\ndef delete_smallest(lst: List[int], item: int) -> List[int]:\n    \"\"\"\n    Time Complexity: O(log(n))\n    Space Complexity: O(1)\n    \"\"\"\n\n    # Push the new item into the heap\n    heappush(lst, item)\n\n    # Extract the smallest item from the heap\n    return heappop(lst)\n\n\nif __name__ == \"__main__\":\n    lst = [5, 10, 15, 20, 25]\n    print(delete_smallest(lst, 11))\n    print(delete_smallest(lst, 15))\n    print(delete_smallest(lst, 20))\n    print(delete_smallest(lst, 30))"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest(heap, item):\n    \"\"\"Delete smallest element from the heap and insert new item.\"\"\"\n    if heap:\n        # If heap is not empty\n        smallest = heappop(heap)\n        if heap:\n            smallest = heappop(heap)\n            heappush(heap, smallest)\n            heappush(heap, item)\n        else:\n            heappush(heap, item)\n    else:\n        heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [10, 5, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    print(heap)\n    delete_smallest(heap, 15)\n    print(heap)"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "def delete_and_insert(heap, item):\n    heap.insert(item)\n    return heap.pop()\n\n\nif __name__ == \"__main__\":\n    heap = []\n    for i in range(1, 11):\n        heap.append(i)\n    print(delete_and_insert(heap, 100))"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef delete_smallest(heap, new_element):\n    \"\"\"Delete the smallest element from the heap and insert a new element.\"\"\"\n    heap.remove(heap[0])\n    heapq.heapify(heap)\n    heapq.heappush(heap, new_element)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(heap)\n    delete_smallest(heap, 10)\n    print(heap)"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "def delete_and_insert(heap, item):\n    heap.append(item)\n    smallest = heap.pop(0)\n    for index, num in enumerate(heap):\n        if num < smallest:\n            smallest = num\n            index_smallest = index\n    del heap[index_smallest]\n    heap.append(smallest)\n    heap.sort()\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(heap)\n    delete_and_insert(heap, 6)\n    print(heap)"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    \"\"\"Delete the smallest element and insert a new item.\"\"\"\n    heappush(heap, item)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(delete_and_insert(heap, 10))"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest_and_insert(heap, new_value):\n    heappush(heap, new_value)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [3, 2, 1, 4, 5, 6]\n    print(delete_smallest_and_insert(heap, 0))\n    print(delete_smallest_and_insert(heap, 7))\n    print(delete_smallest_and_insert(heap, 8))\n    print(delete_smallest_and_insert(heap, 9))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_and_insert(heap, item):\n    \"\"\"Delete minimum element from heap and insert a new element.\"\"\"\n    heappush(heap, item)\n    return heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    print(delete_min_and_insert(heap, 10))\n    print(delete_min_and_insert(heap, 100))\n    print(delete_min_and_insert(heap, 60))\n    print(delete_min_and_insert(heap, 20))\n    print(delete_min_and_insert(heap, 50))\n    print(delete_min_and_insert(heap, 30))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_insert(heap, item):\n    \"\"\"Deletes smallest element from the heap and then inserts a new item.\n\n    Args:\n        heap: A heap.\n        item: A new item.\n\n    Returns:\n        A heap with the deleted smallest element and the new item.\n    \"\"\"\n    return heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(delete_min_insert(heap, 11))"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import heapq\nfrom typing import List, Optional\n\n\ndef delete_smallest(heap: List[int], item: int) -> List[int]:\n    \"\"\"\n    Since heap is a min heap, we can delete the smallest item.\n    \"\"\"\n    if not heap:\n        return heap\n\n    heapq.heappushpop(heap, item)\n\n    return heap\n\n\ndef delete_smallest_v2(heap: List[int], item: int) -> List[int]:\n    \"\"\"\n    Since heap is a min heap, we can delete the smallest item.\n    \"\"\"\n    if not heap:\n        return heap\n\n    heapq.heapreplace(heap, item)\n\n    return heap\n\n\ndef main():\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    new_item = 10\n\n    print(delete_smallest(heap, new_item))\n    print(delete_smallest_v2(heap, new_item))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    \"\"\"Delete the smallest element from the given heap and then insert a new item.\"\"\"\n\n    if len(heap) == 1:\n        return [item]\n\n    heap.sort()\n    heap.pop(0)\n    heapify(heap)\n    heappush(heap, item)\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    print(delete_and_insert([10, 20, 40, 50], 30))\n    print(delete_and_insert([10, 20, 40, 50], 15))\n    print(delete_and_insert([10, 20, 40, 50], 25))\n    print(delete_and_insert([10, 20, 40, 50], 35))"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef delete_min_insert(heap, item):\n    \"\"\"\n    :param: heap: list representing a min heap\n    :param: item: item to be inserted\n    return: new heap\n    \"\"\"\n    # TODO: Write your code here\n    if heap:\n        heap.pop(0)\n        heapq.heapify(heap)\n    heapq.heappush(heap, item)\n    return heap\n\n\nif __name__ == '__main__':\n    h = [1, 2, 3, 4, 5]\n    print(delete_min_insert(h, 6))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    smallest = heappop(heap)\n    heappush(heap, item)\n    return smallest\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(delete_and_insert(heap, 10))"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def delete_and_insert(heap, item):\n    \"\"\"\n    :param heap: list of integers\n    :param item: integer\n    :return: list of integers\n    \"\"\"\n    if item < heap[0]:\n        return heap\n    heap[0] = item\n    heapq.heapify(heap)\n    return heap\n\n\nif __name__ == '__main__':\n    # These \"asserts\" using only for self-checking and not necessary for auto-testing\n    def checker(func, heap, item):\n        res = func(heap, item)\n        if not isinstance(res, list):\n            raise Error\n        if res[0] != item:\n            raise Error\n        heapq.heapify(heap)\n        for el in res:\n            if not el in heap:\n                raise Error\n        if len(res) != len(set(res)):\n            raise Error\n\n    try:\n        checker(delete_and_insert, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], 20)\n    except Exception:\n        pass"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def delete_smallest(heap, item):\n    \"\"\"\n    :param heap: list - the heap.\n    :param item: int - the item to insert.\n    :return: list - the heap after the new item was inserted.\n    \"\"\"\n    heap.insert(0, item)\n    heap.pop(heap.index(min(heap)) + 1)\n    heap.sort()\n    return heap\n\n\nif __name__ == '__main__':\n    print(delete_smallest([1, 2, 3, 4, 5], 6))"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, item):\n    \"\"\"Delete the smallest element from heap and insert new item.\"\"\"\n    smallest = heappop(heap)\n    heappush(heap, item)\n    return smallest\n\n\nif __name__ == \"__main__\":\n    h = [10, 8, 7, 6, 5, 4, 3, 2, 1]\n    print(delete_and_insert(h, 12))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_smallest_and_insert_new(heap, new_item):\n    \"\"\"\n    :param heap: list\n    :param new_item: int\n    :return: list\n    \"\"\"\n    return [heappop(heap), heappush(heap, new_item)]\n\n\nif __name__ == \"__main__\":\n    heap = [1, 2, 3, 4, 5]\n    new_item = 6\n    print(delete_smallest_and_insert_new(heap, new_item))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_and_insert(heap, element):\n    return [heappush(heap, element)] + heappop(heap)\n\n\nif __name__ == \"__main__\":\n    heap = [3, 1, 2]\n    print(delete_min_and_insert(heap, 5))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_and_insert(heap, new_item):\n    # Your code here\n    return heappop(heap), heappush(heap, new_item)\n\n\nif __name__ == '__main__':\n    h = [3, 5, 1, 2, 4, 6]\n    print(delete_and_insert(h, 9))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef delete_min_and_insert(heap, item):\n    \"\"\"\n    Delete the smallest item from the heap and then insert the new item.\n\n    :param heap: heap\n    :param item: item to be inserted\n    \"\"\"\n    heappop(heap)\n    heappush(heap, item)\n\n\nif __name__ == \"__main__\":\n    h = [2, 3, 1]\n    delete_min_and_insert(h, 0)\n    print(h)"
    }
  ]
}