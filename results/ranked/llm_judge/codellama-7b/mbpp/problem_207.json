{
  "timestamp": "2025-09-14T23:51:50.640966",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 207,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def min_operations(x, y):\n    \"\"\"\n    >>> min_operations(13, 110)\n    4\n    >>> min_operations(110, 13)\n    4\n    >>> min_operations(1000000, 1000100)\n    10\n    >>> min_operations(1234, 4321)\n    4\n    >>> min_operations(100, 200)\n    2\n    >>> min_operations(100, 20000)\n    18\n    >>> min_operations(100, 10)\n    9\n    \"\"\"\n    x_list = list(str(x))\n    y_list = list(str(y))\n    x_len = len(x_list)\n    y_len = len(y_list)\n    if x_len > y_len:\n        x_len, y_len = y_len, x_len\n        x_list, y_list = y_list, x_list\n    if x_len == 0:\n        return y_len\n    diff = abs(x_len - y_len)\n    if diff > 0:\n        for i in range(diff):\n            y_list.append(\"0\")\n    for i in range(x_len):\n        if x_list[i] != y_list[i]:\n            return y_len + x_len - i * 2\n    return min(x_len, y_len)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def min_operations(num1: int, num2: int) -> int:\n    \"\"\"\n    This function finds the minimum operations required to make two numbers equal.\n    :param num1: first number.\n    :param num2: second number.\n    :return: minimum operations required to make two numbers equal.\n    >>> min_operations(2, 3)\n    2\n    >>> min_operations(1, 4)\n    2\n    >>> min_operations(4, 6)\n    2\n    >>> min_operations(0, 1)\n    1\n    >>> min_operations(1, 0)\n    1\n    >>> min_operations(0, 0)\n    0\n    \"\"\"\n\n    # base case\n    if num1 == num2:\n        return 0\n\n    # if both numbers are even, then divide both by 2\n    if num1 % 2 == 0 and num2 % 2 == 0:\n        return min_operations(num1 // 2, num2 // 2) + 1\n\n    # if both numbers are odd, then either subtract both by 1 or divide both by 2\n    if num1 % 2 != 0 and num2 % 2 != 0:\n        return min(min_operations(num1 - 1, num2), min_operations(num1 // 2, num2 // 2)) + 1\n\n    # if both numbers are odd or one number is even and the other is odd, then either subtract both by 1 or divide both by 2\n    return min(min_operations(num1 - 1, num2), min_operations(num1 // 2, num2)) + 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def minOperations(num1, num2):\n    # Write your code here.\n\toperations = 0\n\twhile(num1!=num2):\n\t\tif num1>num2:\n\t\t\tnum1-=num2\n\t\t\toperations+=1\n\t\telse:\n\t\t\tnum2-=num1\n\t\t\toperations+=1\n\treturn operations\n\n\nminOperations(10, 10)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def min_operations(a, b):\n    # get the difference between a and b\n    diff = abs(a - b)\n\n    # if difference is 0 then return 0\n    if diff == 0:\n        return 0\n\n    # if difference is 1 then return 1\n    if diff == 1:\n        return 1\n\n    # if difference is 2 or 3 then return 2\n    if diff in [2, 3]:\n        return 2\n\n    # if difference is 4 or 5 then return 3\n    if diff in [4, 5]:\n        return 3\n\n    # if difference is 6 or 7 then return 4\n    if diff in [6, 7]:\n        return 4\n\n    # if difference is 8 then return 5\n    if diff == 8:\n        return 5\n\n    # if difference is 9 then return 6\n    if diff == 9:\n        return 6\n\n    # if difference is 10 then return 7\n    if diff == 10:\n        return 7\n\n    # if difference is 11 then return 8\n    if diff == 11:\n        return 8\n\n    # if difference is 12 or 13 then return 9\n    if diff in [12, 13]:\n        return 9\n\n    # if difference is 14 then return 10\n    if diff == 14:\n        return 10\n\n    # if difference is 15 then return 11\n    if diff == 15:\n        return 11\n\n    # if difference is 16 then return 12\n    if diff == 16:\n        return 12\n\n    # if difference is 17 then return 13\n    if diff == 17:\n        return 13\n\n    # if difference is 18 then return 14\n    if diff == 18:\n        return 14\n\n    # if difference is 19 then return 15\n    if diff == 19:\n        return 15\n\n    # if difference is"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def find_min_ops(n1: int, n2: int) -> int:\n    \"\"\"\n    >>> find_min_ops(2, 3)\n    2\n    >>> find_min_ops(5, 11)\n    3\n    >>> find_min_ops(4, 6)\n    2\n    >>> find_min_ops(10, 5)\n    5\n    \"\"\"\n    if n1 < n2:\n        return n2 - n1\n    else:\n        return n1 - n2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def find_min_operations(num1: int, num2: int) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    if num1 == num2:\n        return 0\n\n    # make num1 always larger than num2\n    if num1 < num2:\n        num1, num2 = num2, num1\n\n    # find the number of 1s in num2\n    num2_1_count = 0\n    while num2 > 0:\n        num2 = num2 & (num2 - 1)\n        num2_1_count += 1\n\n    # find the number of 1s in num1\n    num1_1_count = 0\n    while num1 > 0:\n        num1 = num1 & (num1 - 1)\n        num1_1_count += 1\n\n    return num1_1_count - num2_1_count\n\n\nprint(find_min_operations(4, 2))\nprint(find_min_operations(2, 4))\nprint(find_min_operations(10, 11))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def make_equal(a, b):\n    if a == b:\n        return 0\n    elif a > b:\n        return make_equal(a-b, b)\n    else:\n        return make_equal(a, b-a) + 1\n\n\nprint(make_equal(1, 2))\nprint(make_equal(2, 5))\nprint(make_equal(10, 15))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def find_min_operations(a, b):\n    \"\"\"\n    >>> find_min_operations(10, 17)\n    '1107'\n    >>> find_min_operations(10, 19)\n    '1117'\n    >>> find_min_operations(10, 21)\n    '1118'\n    >>> find_min_operations(10, 23)\n    '1119'\n    \"\"\"\n    num1 = str(a)\n    num2 = str(b)\n    total_len = len(num1) + len(num2)\n    if num1 == num2:\n        return \"0\" * (total_len - len(num1))\n    num1_len = len(num1)\n    num2_len = len(num2)\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    if num1_len < num2_len:\n        num1 = \"0\" * (num2_len - num1_len) + num1\n    elif num1_len > num2_len:\n        num2 = \"0\" * (num1_len - num2_len) + num2\n    diff = int(num1) - int(num2)\n    if diff < 0:\n        diff = -diff\n    return \"1\" * diff\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def min_operations(num1: int, num2: int) -> int:\n    \"\"\"\n    >>> min_operations(2, 1)\n    1\n    >>> min_operations(1, 2)\n    1\n    >>> min_operations(3, 1)\n    2\n    >>> min_operations(1, 3)\n    2\n    >>> min_operations(2, 3)\n    2\n    >>> min_operations(3, 2)\n    2\n    >>> min_operations(10, 15)\n    5\n    >>> min_operations(15, 10)\n    5\n    >>> min_operations(10, 16)\n    5\n    >>> min_operations(16, 10)\n    5\n    \"\"\"\n    if num1 < num2:\n        return min_operations(num2, num1)\n    if num1 - num2 > 0:\n        return min_operations(num1, num1 - num2)\n    else:\n        return num1 - num2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def min_ops_to_make_equal(num1: int, num2: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    count: int = 0\n\n    while num1 != num2:\n        num1, num2 = num1 ^ num2, (num1 & num2) << 1\n        count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(min_ops_to_make_equal(3, 10))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def min_operations_required(a: int, b: int) -> int:\n    \"\"\"\n    >>> min_operations_required(10, 15)\n    3\n    >>> min_operations_required(3, 100)\n    106\n    \"\"\"\n    operations = 0\n\n    while a != b:\n        if a > b:\n            a -= b\n            operations += a\n        else:\n            b -= a\n            operations += b\n\n    return operations\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def min_operations(a, b):\n    return abs(a - b)\n\n\nprint(min_operations(10, 5))\nprint(min_operations(10, 10))\nprint(min_operations(10, 15))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def min_operations(n1, n2):\n    return min_operations_helper(n1, n2, 0)\n\n\ndef min_operations_helper(n1, n2, count):\n    if n1 == n2:\n        return count\n    if n1 > n2:\n        return min_operations_helper(n1 - n2, n2, count + 1)\n    else:\n        return min_operations_helper(n1, n2 - n1, count + 1)\n\n\nprint(min_operations(13, 42))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def min_operations(n1, n2):\n    \"\"\"\n    >>> min_operations(2, 2)\n    0\n    >>> min_operations(2, 5)\n    1\n    >>> min_operations(10, 5)\n    5\n    >>> min_operations(1, 10)\n    9\n    \"\"\"\n    return abs(n1 - n2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def min_operations(a, b):\n    \"\"\"\n    Using dynamic programming.\n    \"\"\"\n    cache = {}\n    return _min_operations(a, b, cache)\n\ndef _min_operations(a, b, cache):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n\n    if (a, b) in cache:\n        return cache[(a, b)]\n\n    if a > b:\n        cache[(a, b)] = _min_operations(a - 1, b, cache) + 1\n    else:\n        cache[(a, b)] = _min_operations(a, b - 1, cache) + 1\n\n    return cache[(a, b)]\n\n\ndef min_operations2(a, b):\n    \"\"\"\n    Using recursion.\n    \"\"\"\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n\n    if a > b:\n        return min_operations2(a - 1, b) + 1\n    else:\n        return min_operations2(a, b - 1) + 1\n\n\ndef min_operations3(a, b):\n    \"\"\"\n    Using recursion and memorization.\n    \"\"\"\n    cache = {}\n    return min_operations3_helper(a, b, cache)\n\ndef min_operations3_helper(a, b, cache):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n\n    if (a, b) in cache:\n        return cache[(a, b)]\n\n    if a > b:\n        cache[(a, b)] = min_operations3_helper(a - 1, b, cache) + 1\n    else:\n        cache[(a, b)] = min_operations3_helper(a, b - 1, cache) + 1\n\n    return cache[(a, b)]\n\n\nprint(min_operations(2, 10))\nprint(min_operations2(2, 10))\nprint(min_operations3(2,"
    },
    {
      "rank": 16,
      "score": 9.370583536698913,
      "candidate": "def minimum_operations(a, b):\n    operations = 0\n    while a != b:\n        if a > b:\n            a = a - b\n        else:\n            b = b - a\n        operations += 1\n    return operations\n\nprint(minimum_operations(10, 12))\nprint(minimum_operations(10, 22))\nprint(minimum_operations(10, 21))\nprint(minimum_operations(10, 20))\nprint(minimum_operations(10, 10))"
    },
    {
      "rank": 17,
      "score": 9.234050852198141,
      "candidate": "def minimum_operations(n1, n2):\n    if n1 == n2:\n        return 0\n    if n1 < n2:\n        return minimum_operations(n1, n1 + 1) + 1\n    else:\n        return minimum_operations(n2, n2 + 1) + 1\n\n\nprint(minimum_operations(2, 6))"
    },
    {
      "rank": 18,
      "score": 9.226766272351448,
      "candidate": "def min_operations(a: int, b: int) -> int:\n    \"\"\"\n    :param a: first number\n    :param b: second number\n    :return: minimum operations\n    \"\"\"\n    operations = 0\n    while a != b:\n        if a > b:\n            a -= b\n        else:\n            b -= a\n        operations += 1\n    return operations\n\n\nif __name__ == \"__main__\":\n    print(min_operations(12, 23))\n    print(min_operations(10, 20))"
    },
    {
      "rank": 19,
      "score": 9.21346272767743,
      "candidate": "def min_operations(num1: int, num2: int) -> int:\n    \"\"\"\n    This function takes in two numbers and returns the minimum operations required to make\n    the two numbers equal.\n    \"\"\"\n    num1_str = str(num1)\n    num2_str = str(num2)\n    diff = len(num1_str) - len(num2_str)\n    if diff < 0:\n        num1_str = \"0\" * abs(diff) + num1_str\n    elif diff > 0:\n        num2_str = \"0\" * abs(diff) + num2_str\n    return len(num1_str) - len(set(num1_str).intersection(set(num2_str)))\n\n\nif __name__ == \"__main__\":\n    print(min_operations(32, 10))\n    print(min_operations(10, 32))\n    print(min_operations(100, 32))\n    print(min_operations(320, 10))"
    },
    {
      "rank": 20,
      "score": 9.205959372648458,
      "candidate": "def min_operations(n1, n2):\n    result = []\n    while n1 != n2:\n        if n1 > n2:\n            n1 = n1 - n2\n            result.append(\"-\")\n        else:\n            n2 = n2 - n1\n            result.append(\"+\")\n    return result\n\n\ndef main():\n    n1 = int(input(\"Enter first number: \"))\n    n2 = int(input(\"Enter second number: \"))\n    print(min_operations(n1, n2))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 21,
      "score": 9.177268828905222,
      "candidate": "def min_ops(num1, num2):\n    \"\"\"\n    >>> min_ops(15, 28)\n    3\n    \"\"\"\n    op = 0\n    while num1 != num2:\n        if num1 < num2:\n            num2 -= num1\n            op += 1\n        else:\n            num1 -= num2\n            op += 1\n    return op\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.122564458729856,
      "candidate": "def min_ops(x, y):\n    return abs(x - y)\n\nprint(min_ops(1, 2))\nprint(min_ops(2, 4))\nprint(min_ops(10, 13))\nprint(min_ops(23, 45))"
    },
    {
      "rank": 23,
      "score": 8.973005557553902,
      "candidate": "def find_min_operations(num1, num2):\n    count = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count\n\n\nprint(find_min_operations(100, 15))"
    },
    {
      "rank": 24,
      "score": 8.95994420569242,
      "candidate": "def find_min_operations(number1, number2):\n    operations = 0\n    while number1 != number2:\n        if number1 > number2:\n            number1 -= number2\n        else:\n            number2 -= number1\n        operations += 1\n    return operations"
    },
    {
      "rank": 25,
      "score": 8.946210893390457,
      "candidate": "def min_ops(n1, n2):\n    num_ops = 0\n    while n1 != n2:\n        if n1 > n2:\n            n1 = n1 - n2\n            num_ops += 1\n        else:\n            n2 = n2 - n1\n            num_ops += 1\n    return num_ops\n\n\nprint(min_ops(23, 56))"
    },
    {
      "rank": 26,
      "score": 8.932217008005624,
      "candidate": "def min_ops(a, b):\n    if a == b:\n        return 0\n\n    # Get the length of the numbers\n    len_a = len(str(a))\n    len_b = len(str(b))\n\n    # Get the difference between the length of the numbers\n    diff = abs(len_a - len_b)\n\n    # Get the smaller number\n    smaller = a if len_a < len_b else b\n\n    # Get the larger number\n    larger = a if len_a > len_b else b\n\n    # Get the larger number with the length of the smaller number\n    larger = int(str(larger) + (\"0\" * diff))\n\n    # Get the difference between the numbers\n    diff = larger - smaller\n\n    # Get the length of the difference\n    diff_len = len(str(diff))\n\n    # Get the length of the numbers\n    len_a = len(str(a))\n    len_b = len(str(b))\n\n    # Get the difference between the length of the numbers\n    diff = abs(len_a - len_b)\n\n    # Get the smaller number\n    smaller = a if len_a < len_b else b\n\n    # Get the larger number\n    larger = a if len_a > len_b else b\n\n    # Get the larger number with the length of the smaller number\n    larger = int(str(larger) + (\"0\" * diff))\n\n    # Get the difference between the numbers\n    diff = larger - smaller\n\n    # Get the length of the difference\n    diff_len = len(str(diff))\n\n    # Get the number of operations required to make the numbers equal\n    ops = diff_len - 1\n\n    # Return the number of operations required to make the numbers equal\n    return ops\n\n\ndef main():\n    a = int(input(\"Enter first number: \"))\n    b = int(input(\"Enter second number: \"))\n    print(f\"Minimum operations required to make the numbers equal: {min_ops(a, b)}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 27,
      "score": 8.910084504002544,
      "candidate": "def min_operations(num1, num2):\n    num1_arr = [int(x) for x in str(num1)]\n    num2_arr = [int(x) for x in str(num2)]\n    while num1_arr != num2_arr:\n        for i in range(len(num1_arr)):\n            if num1_arr[i] != num2_arr[i]:\n                num1_arr[i] = num1_arr[i] + 1\n                break\n        else:\n            for i in range(len(num1_arr)-1, -1, -1):\n                if num1_arr[i] != num2_arr[i]:\n                    num1_arr[i] = num1_arr[i] - 1\n                    break\n    print(num1_arr)\n\nmin_operations(235, 456)"
    },
    {
      "rank": 28,
      "score": 8.85571690049604,
      "candidate": "def minimum_operations(a,b):\n    operations = 0\n    while a != b:\n        if a > b:\n            a = a - b\n            operations += 1\n        else:\n            b = b - a\n            operations += 1\n    return operations\n\nprint(minimum_operations(14,2))"
    },
    {
      "rank": 29,
      "score": 8.855395696632057,
      "candidate": "def minimum_operations(a, b):\n    \"\"\"\n    :param a: first number\n    :param b: second number\n    :return: minimum operations\n    \"\"\"\n    # find the difference between the numbers\n    diff = abs(a - b)\n    # set the minimum operations to 0\n    min_ops = 0\n    # if the difference is greater than 0\n    if diff > 0:\n        # while the difference is greater than 0\n        while diff > 0:\n            # if the difference is even\n            if diff % 2 == 0:\n                # subtract 2 from the difference\n                diff -= 2\n                # increment the minimum operations\n                min_ops += 1\n            else:\n                # subtract 1 from the difference\n                diff -= 1\n                # increment the minimum operations\n                min_ops += 1\n        # return the minimum operations\n        return min_ops\n\n    else:\n        # return 0 if the difference is 0\n        return min_ops\n\n\nprint(minimum_operations(2, 6))\nprint(minimum_operations(4, 6))\nprint(minimum_operations(4, 8))\nprint(minimum_operations(6, 9))"
    },
    {
      "rank": 30,
      "score": 8.850707355641543,
      "candidate": "def min_operations(num1, num2):\n    num1 = str(num1)\n    num2 = str(num2)\n    count = 0\n    if len(num1) < len(num2):\n        for i in range(len(num2) - len(num1)):\n            count += 1\n            num1 = '0' + num1\n    elif len(num1) > len(num2):\n        for i in range(len(num1) - len(num2)):\n            count += 1\n            num2 = '0' + num2\n    for i in range(len(num1)):\n        if num1[i] != num2[i]:\n            count += 1\n    return count\n\n\nprint(min_operations(1234, 234))"
    },
    {
      "rank": 31,
      "score": 8.8281618090209,
      "candidate": "def min_operations(x, y):\n    x_list = list(str(x))\n    y_list = list(str(y))\n\n    if len(x_list) < len(y_list):\n        x_list = list(str(y))\n        y_list = list(str(x))\n\n    # 1. Find the difference between the two numbers\n    diff = int(\"\".join(x_list)) - int(\"\".join(y_list))\n\n    # 2. Find the absolute value of the difference\n    abs_diff = abs(diff)\n\n    # 3. Find the number of operations required to get the absolute value of the difference\n    ops = 0\n    while abs_diff > 0:\n        abs_diff //= 10\n        ops += 1\n\n    # 4. If the difference is positive, add the number of operations to make the number negative\n    if diff > 0:\n        return ops + x\n    else:\n        return ops - x\n\n\nprint(min_operations(12, 21))\nprint(min_operations(21, 12))\nprint(min_operations(21, 23))\nprint(min_operations(23, 21))\nprint(min_operations(100, 5))\nprint(min_operations(5, 100))"
    },
    {
      "rank": 32,
      "score": 8.81367773444215,
      "candidate": "def min_operations(a, b):\n    diff = abs(a - b)\n    if a > b:\n        return diff\n    else:\n        return diff * 2\n\n\nprint(min_operations(5, 2))\nprint(min_operations(2, 5))"
    },
    {
      "rank": 33,
      "score": 8.76828871349479,
      "candidate": "def min_ops(a, b):\n    \"\"\"\n    >>> min_ops(5, 3)\n    2\n    >>> min_ops(1, 1)\n    0\n    >>> min_ops(100, 34)\n    10\n    \"\"\"\n    if a == b:\n        return 0\n    if a > b:\n        return a - b\n    else:\n        return b - a\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 34,
      "score": 8.750282588864879,
      "candidate": "def min_operations(n1, n2):\n    n1_bin = bin(n1)[2:]\n    n2_bin = bin(n2)[2:]\n\n    if len(n1_bin) > len(n2_bin):\n        n2_bin = n2_bin.zfill(len(n1_bin))\n    else:\n        n1_bin = n1_bin.zfill(len(n2_bin))\n\n    count = 0\n    for i in range(len(n1_bin)):\n        if n1_bin[i] != n2_bin[i]:\n            count += 1\n\n    return count"
    },
    {
      "rank": 35,
      "score": 8.715724466237427,
      "candidate": "def min_ops(num1, num2):\n    num1 = str(num1)\n    num2 = str(num2)\n    diff = len(num1) - len(num2)\n    if diff < 0:\n        num2 = num2 + '0' * (-diff)\n    elif diff > 0:\n        num1 = num1 + '0' * diff\n    diff = 0\n    for i in range(len(num1)):\n        if num1[i] != num2[i]:\n            diff += 1\n    return diff\n\nprint(min_ops(123, 456))"
    },
    {
      "rank": 36,
      "score": 8.692801520950061,
      "candidate": "def find_min_op(n1, n2):\n    if n1 == n2:\n        return 0\n\n    if n1 == 0:\n        return n2\n\n    if n2 == 0:\n        return n1\n\n    if n1 == 1 or n2 == 1:\n        return max(n1, n2)\n\n    if n1 > n2:\n        return n1 - n2\n    else:\n        return n2 - n1\n\n\nif __name__ == \"__main__\":\n    print(find_min_op(10, 6))\n    print(find_min_op(10, 15))\n    print(find_min_op(5, 10))\n    print(find_min_op(10, 10))"
    },
    {
      "rank": 37,
      "score": 8.632293453617281,
      "candidate": "def minimum_operations(a, b):\n    count = 0\n    while a != b:\n        if a > b:\n            a = a - b\n            count += 1\n        else:\n            b = b - a\n            count += 1\n    return count\n\n\nprint(minimum_operations(10, 20))\nprint(minimum_operations(12, 19))\nprint(minimum_operations(25, 15))"
    },
    {
      "rank": 38,
      "score": 8.625262456968262,
      "candidate": "def minimum_operations(a, b):\n    if a < b:\n        a, b = b, a\n\n    for i in range(a + 1, b + 1):\n        if i & 1 == 0:\n            return b - i\n        else:\n            continue\n    return None\n\n\ndef minimum_operations_2(a, b):\n    if a < b:\n        a, b = b, a\n\n    for i in range(a + 1, b + 1):\n        if i & 1 == 0:\n            return b - i\n        else:\n            continue\n    return None\n\n\nprint(minimum_operations(2, 5))\nprint(minimum_operations(1, 3))"
    },
    {
      "rank": 39,
      "score": 8.625142247198651,
      "candidate": "def minimum_operations(n1, n2):\n    if n1 == n2:\n        return 0\n\n    count = 0\n    while n1 != n2:\n        if n1 > n2:\n            n1 = n1 - n2\n        else:\n            n2 = n2 - n1\n        count += 1\n\n    return count\n\nif __name__ == \"__main__\":\n    print(minimum_operations(21, 6))\n    print(minimum_operations(15, 9))"
    },
    {
      "rank": 40,
      "score": 8.616253589228675,
      "candidate": "def min_operations(num1, num2):\n    # check if numbers are equal\n    if num1 == num2:\n        return 0\n    # check if one number is 0\n    elif num1 == 0:\n        return num2\n    elif num2 == 0:\n        return num1\n    # check if both numbers are negative\n    elif num1 < 0 and num2 < 0:\n        # check if numbers are equal\n        if abs(num1) == abs(num2):\n            return 0\n        else:\n            return abs(num1) + abs(num2)\n    # check if one number is negative\n    elif abs(num1) > abs(num2):\n        return min_operations(abs(num1), abs(num2)) + max(abs(num1), abs(num2))\n    else:\n        return min_operations(abs(num2), abs(num1)) + max(abs(num1), abs(num2))\n\n\nprint(min_operations(0, 3))\nprint(min_operations(3, 0))\nprint(min_operations(5, 5))\nprint(min_operations(1, -1))\nprint(min_operations(-1, 1))\nprint(min_operations(1, 10))\nprint(min_operations(10, 1))\nprint(min_operations(10, 100))\nprint(min_operations(-1, -100))\nprint(min_operations(-100, -1))\nprint(min_operations(-100, 100))\nprint(min_operations(100, -100))"
    },
    {
      "rank": 41,
      "score": 8.610076160146226,
      "candidate": "def min_operations(a,b):\n    # find the difference between the numbers\n    diff = abs(a-b)\n    # if difference is 0 return 0\n    if diff == 0:\n        return 0\n    # find the length of the larger number\n    length = max(len(str(a)), len(str(b)))\n    # return difference multiplied by length\n    return diff * length\n\nprint(min_operations(12, 23))\nprint(min_operations(1234, 234))\nprint(min_operations(1234, 2345))\nprint(min_operations(2345, 1234))"
    },
    {
      "rank": 42,
      "score": 8.606486429141842,
      "candidate": "def min_operations(num1, num2):\n    count = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count\n\n\nprint(min_operations(13, 102))\nprint(min_operations(234, 442))"
    },
    {
      "rank": 43,
      "score": 8.60156811074208,
      "candidate": "def minimum_operations(num1, num2):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    if num1 == num2:\n        return 0\n\n    if num1 < num2:\n        temp = num1\n        num1 = num2\n        num2 = temp\n\n    num1_len = len(str(num1))\n    num2_len = len(str(num2))\n\n    # To handle negative numbers\n    num1_len += num1 < 0\n    num2_len += num2 < 0\n\n    diff = num1_len - num2_len\n\n    if diff % 2 == 0:\n        diff /= 2\n    else:\n        diff = abs(diff - 2) / 2\n\n    return diff + num1_len\n\n\ndef main():\n    num1 = 100\n    num2 = 10\n    print(f\"Minimum operations required to make {num1} and {num2} equal is {minimum_operations(num1, num2)}\")\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 44,
      "score": 8.565425580227462,
      "candidate": "def minimum_operations(n1, n2):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    operations = 0\n    while n1 != n2:\n        if n1 > n2:\n            n1 -= n2\n        else:\n            n2 -= n1\n        operations += 1\n    return operations"
    },
    {
      "rank": 45,
      "score": 8.548876241946822,
      "candidate": "def minimum_operations(n1, n2):\n    return abs(n1 - n2)\n\n\nif __name__ == \"__main__\":\n    n1 = int(input(\"Enter first number: \"))\n    n2 = int(input(\"Enter second number: \"))\n    print(f\"Minimum operations required to make two numbers equal: {minimum_operations(n1, n2)}\")"
    },
    {
      "rank": 46,
      "score": 8.542875062379007,
      "candidate": "def make_equal(number1, number2):\n    \"\"\"\n    :param: number1 (int) - first number\n    :param: number2 (int) - second number\n    return: operations (int) - number of operations\n    To solve this problem, we need to find the difference between the two numbers.\n    Then, we need to find the minimum operations required to make the difference equal to 0.\n    The minimum operations required to make the difference equal to 0 is equal to abs(difference).\n    \"\"\"\n    difference = number1 - number2\n    return abs(difference)\n\n#test\nprint(make_equal(10, 15))\nprint(make_equal(13, 10))"
    },
    {
      "rank": 47,
      "score": 8.53012858503943,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef minimum_operations(first_number, second_number):\n    if first_number == second_number:\n        return 0\n\n    if first_number < 0 or second_number < 0:\n        return float('inf')\n\n    if first_number == 0:\n        return second_number\n\n    if second_number == 0:\n        return first_number\n\n    if first_number < second_number:\n        smaller_number = first_number\n        bigger_number = second_number\n    else:\n        smaller_number = second_number\n        bigger_number = first_number\n\n    return 1 + minimum_operations(smaller_number - 1, bigger_number)\n\n\nif __name__ == \"__main__\":\n    print(minimum_operations(12, 20))\n    print(minimum_operations(1, 2))"
    },
    {
      "rank": 48,
      "score": 8.499905739299377,
      "candidate": "def min_op(a,b):\n    if a==b:\n        return 0\n    else:\n        if a>b:\n            return min_op(a-b,b)\n        else:\n            return min_op(a,b-a)\n\nprint(min_op(10,15))\nprint(min_op(15,10))\nprint(min_op(15,100))\nprint(min_op(100,15))"
    },
    {
      "rank": 49,
      "score": 8.478208546788407,
      "candidate": "def min_operations(num1, num2):\n    if num1 == num2:\n        return 0\n    if num1 > num2:\n        return num1 - num2\n    return num2 - num1\n\nprint(min_operations(3, 5))\nprint(min_operations(10, 15))"
    },
    {
      "rank": 50,
      "score": 8.437695832075478,
      "candidate": "def min_operations(n1, n2):\n    n1_arr = list(str(n1))\n    n2_arr = list(str(n2))\n    if len(n1_arr) > len(n2_arr):\n        for _ in range(len(n1_arr) - len(n2_arr)):\n            n2_arr.append(\"0\")\n    elif len(n1_arr) < len(n2_arr):\n        for _ in range(len(n2_arr) - len(n1_arr)):\n            n1_arr.append(\"0\")\n    diff_arr = []\n    for i in range(len(n1_arr)):\n        diff_arr.append(int(n1_arr[i]) - int(n2_arr[i]))\n    return sum(abs(i) for i in diff_arr)\n\n\ndef main():\n    num1 = int(input(\"Enter the first number: \"))\n    num2 = int(input(\"Enter the second number: \"))\n    min_op = min_operations(num1, num2)\n    print(f\"Minimum operations required to make two numbers equal: {min_op}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 51,
      "score": 8.426531424889468,
      "candidate": "def min_ops(num1, num2):\n    return abs(num1-num2)\n\n\ndef main():\n    num1 = int(input(\"Enter the first number: \"))\n    num2 = int(input(\"Enter the second number: \"))\n    print(min_ops(num1, num2))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 52,
      "score": 8.408439383654278,
      "candidate": "def min_operations(num1, num2):\n    count = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count\n\n\nprint(min_operations(14, 6))"
    },
    {
      "rank": 53,
      "score": 8.386620303250325,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef min_operations(a, b):\n    if a == b:\n        return 0\n\n    if a == 0:\n        return b\n\n    if b == 0:\n        return a\n\n    if a == 1 or b == 1:\n        return abs(a - b)\n\n    if a > b:\n        return min_operations(a - b, b) + 1\n\n    return min_operations(a, b - a) + 1\n\n\ndef main():\n    print(min_operations(10, 5))\n    print(min_operations(2, 2))\n    print(min_operations(5, 5))\n    print(min_operations(100, 20))\n    print(min_operations(1000, 2000))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 54,
      "score": 8.375312293858853,
      "candidate": "def min_operations(num1, num2):\n    operations = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        operations += 1\n    return operations\n\nprint(min_operations(5, 11))\nprint(min_operations(11, 5))\nprint(min_operations(13, 11))"
    },
    {
      "rank": 55,
      "score": 8.351614956112536,
      "candidate": "def min_operations(a, b):\n    operations = 0\n    while a != b:\n        if a > b:\n            a = a - b\n        else:\n            b = b - a\n        operations += 1\n    return operations\n\nprint(min_operations(3, 5))\nprint(min_operations(10, 5))\nprint(min_operations(15, 5))\nprint(min_operations(17, 15))\nprint(min_operations(18, 15))"
    },
    {
      "rank": 56,
      "score": 8.331556294201176,
      "candidate": "def min_operations_to_make_equal(a, b):\n    \"\"\"\n    :param a: int\n    :param b: int\n    :return: int\n    \"\"\"\n    operations = 0\n    while a != b:\n        if a > b:\n            a = a - b\n        else:\n            b = b - a\n        operations += 1\n    return operations\n\n\nprint(min_operations_to_make_equal(2, 1))\nprint(min_operations_to_make_equal(1, 2))"
    },
    {
      "rank": 57,
      "score": 8.327375965969855,
      "candidate": "def min_operations(n1, n2):\n    count = 0\n    while n1 != n2:\n        if n1 > n2:\n            n1 = n1 - n2\n        else:\n            n2 = n2 - n1\n        count += 1\n    return count\n\n\nprint(min_operations(2, 4))\nprint(min_operations(1, 3))"
    },
    {
      "rank": 58,
      "score": 8.327367757082776,
      "candidate": "def min_operations(num1, num2):\n    if num1 == num2:\n        return 0\n\n    if num1 > num2:\n        num1, num2 = num2, num1\n\n    count = 0\n    while num1 != num2:\n        if num1 & 1 == 0 and num2 & 1 == 0:\n            num1, num2 = num1 >> 1, num2 >> 1\n        elif num1 & 1 == 0 and num2 & 1 != 0:\n            num1 >>= 1\n            count += 1\n        elif num1 & 1 != 0 and num2 & 1 == 0:\n            num2 >>= 1\n            count += 1\n        else:\n            num1 += 1\n            num2 += 1\n            count += 2\n    return count\n\n\nprint(min_operations(13, 15))\nprint(min_operations(13, 17))"
    },
    {
      "rank": 59,
      "score": 8.298597569547805,
      "candidate": "def minimum_operations(a, b):\n    if a == b:\n        return 0\n    return abs(a - b)\n\nprint(minimum_operations(5, 2))\nprint(minimum_operations(1, 2))\nprint(minimum_operations(4, 6))\nprint(minimum_operations(4, 1))"
    },
    {
      "rank": 60,
      "score": 8.2938925966498,
      "candidate": "def min_operations(num1, num2):\n    num1, num2 = str(num1), str(num2)\n    operations = 0\n    if len(num1) != len(num2):\n        return -1\n\n    for i in range(len(num1)):\n        if num1[i] != num2[i]:\n            operations += 1\n\n    return operations\n\nprint(min_operations(2020, 20))\nprint(min_operations(12345, 54321))\nprint(min_operations(1, 2))\nprint(min_operations(2, 1))\nprint(min_operations(1, 1))\nprint(min_operations(1, 11))\nprint(min_operations(20, 21))"
    },
    {
      "rank": 61,
      "score": 8.289838256518838,
      "candidate": "def min_operations(a, b):\n    count = 0\n    while a != b:\n        if a > b:\n            a = a - b\n        else:\n            b = b - a\n        count += 1\n    return count\n\n\nprint(min_operations(1, 3))\nprint(min_operations(5, 12))\nprint(min_operations(10, 5))"
    },
    {
      "rank": 62,
      "score": 8.251903304236286,
      "candidate": "def min_ops(a, b):\n    if a == b:\n        return 0\n    else:\n        if a > b:\n            return min_ops(a-b, b) + 1\n        else:\n            return min_ops(b-a, a) + 1\n\nprint(min_ops(12, 4))\nprint(min_ops(1, 2))\nprint(min_ops(2, 3))\nprint(min_ops(3, 4))"
    },
    {
      "rank": 63,
      "score": 8.214125058964552,
      "candidate": "def find_min_ops(a, b):\n    a, b = a[::-1], b[::-1]\n    len_a, len_b = len(a), len(b)\n    dp = [[0 for _ in range(len_b + 1)] for _ in range(len_a + 1)]\n\n    for i in range(1, len_a + 1):\n        for j in range(1, len_b + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return len_a + len_b - 2 * dp[-1][-1]\n\n\nprint(find_min_ops(\"geek\", \"eke\"))"
    },
    {
      "rank": 64,
      "score": 8.212735598038213,
      "candidate": "def min_operations(a, b):\n    temp = []\n    temp.append((a, b))\n    count = 0\n    while True:\n        count += 1\n        new = []\n        for i in temp:\n            if i[0] == i[1]:\n                return count\n            elif i[0] < i[1]:\n                new.append((i[0]+1, i[1]))\n                new.append((i[0], i[1]-1))\n            elif i[1] < i[0]:\n                new.append((i[0], i[1]+1))\n                new.append((i[0]-1, i[1]))\n        temp = new\n\n\nprint(min_operations(2, 10))"
    },
    {
      "rank": 65,
      "score": 8.211579567659316,
      "candidate": "def find_min_operations(a, b):\n    if a == b:\n        return 0\n\n    n = max(len(str(a)), len(str(b)))\n    a_list = [0] * n\n    b_list = [0] * n\n\n    for i in range(n):\n        if a % 10 == b % 10:\n            a_list[i] = b_list[i] = 0\n        elif a % 10 > b % 10:\n            a_list[i] = 1\n        else:\n            b_list[i] = 1\n\n        a //= 10\n        b //= 10\n\n    return min(a_list) + min(b_list)\n\n\nif __name__ == \"__main__\":\n    print(find_min_operations(123, 123))\n    print(find_min_operations(1234, 12))\n    print(find_min_operations(456, 123))\n    print(find_min_operations(123, 456))"
    },
    {
      "rank": 66,
      "score": 8.209707251476969,
      "candidate": "def min_ops(num1, num2):\n    num1 = str(num1)\n    num2 = str(num2)\n    if num1 == num2:\n        return 0\n    else:\n        if len(num1) < len(num2):\n            min_len = len(num1)\n        else:\n            min_len = len(num2)\n        min_num = min(num1, num2)\n        max_num = max(num1, num2)\n        count = 0\n        for i in range(min_len, -1, -1):\n            if min_num[i] != max_num[i]:\n                count += 1\n                break\n        return count\n\n\nprint(min_ops(12345, 54321))"
    },
    {
      "rank": 67,
      "score": 8.2048573255218,
      "candidate": "def min_operations(a, b):\n    cnt = 0\n    while a != b:\n        cnt += 1\n        if a > b:\n            a -= b\n        else:\n            b -= a\n    return cnt\n\nprint(min_operations(25, 10))\nprint(min_operations(10, 25))\nprint(min_operations(100, 10))\nprint(min_operations(10, 100))"
    },
    {
      "rank": 68,
      "score": 8.172253082181854,
      "candidate": "def min_operations(number1, number2):\n    count = 0\n    while number1 != number2:\n        if number1 > number2:\n            number1 = number1 - number2\n        else:\n            number2 = number2 - number1\n        count += 1\n    return count"
    },
    {
      "rank": 69,
      "score": 8.163300679823958,
      "candidate": "def min_operations(n1, n2):\n    return abs(n1 - n2)\n\n\nprint(min_operations(3, 5))\nprint(min_operations(5, 10))\nprint(min_operations(2, 4))"
    },
    {
      "rank": 70,
      "score": 8.144125099485041,
      "candidate": "def min_operations(n1, n2):\n    x = n1\n    y = n2\n    if n1 > n2:\n        x = n2\n        y = n1\n    difference = 0\n    while x != y:\n        difference += 1\n        if x % 2 == 0 and y % 2 == 0:\n            x /= 2\n            y /= 2\n        elif x % 2 == 0:\n            x /= 2\n        elif y % 2 == 0:\n            y /= 2\n        else:\n            x += 1\n            y += 1\n    return difference\n\n\nprint(min_operations(2, 3))\nprint(min_operations(3, 2))\nprint(min_operations(1, 1))\nprint(min_operations(1, 0))\nprint(min_operations(1, 5))\nprint(min_operations(2, 6))\nprint(min_operations(2, 5))"
    },
    {
      "rank": 71,
      "score": 8.143591138329747,
      "candidate": "def minimum_operations(num1, num2):\n    operations = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        operations += 1\n    return operations\n\nprint(minimum_operations(13, 10))\nprint(minimum_operations(10, 13))\nprint(minimum_operations(10, 13))"
    },
    {
      "rank": 72,
      "score": 8.121884567141883,
      "candidate": "def min_ops(num1, num2):\n    ops = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n            ops += 1\n        else:\n            num2 -= num1\n            ops += 1\n    return ops\n\nprint(min_ops(2, 8))\nprint(min_ops(3, 11))"
    },
    {
      "rank": 73,
      "score": 8.105983444291466,
      "candidate": "def find_min_operations(a, b):\n    return find_min_operations_recursive(a, b, 0)\n\ndef find_min_operations_recursive(a, b, count):\n    if a == b:\n        return count\n    if a == 0:\n        return count + b\n    if b == 0:\n        return count + a\n\n    if a > b:\n        return find_min_operations_recursive(a - 2, b + 1, count + 1)\n    else:\n        return find_min_operations_recursive(a + 1, b - 2, count + 1)\n\ndef find_min_operations_iterative(a, b):\n    count = 0\n    while a != b:\n        if a > b:\n            a -= 2\n            b += 1\n        else:\n            a += 1\n            b -= 2\n        count += 1\n    return count\n\nprint(find_min_operations(15, 22))\nprint(find_min_operations(15, 22))\nprint(find_min_operations_iterative(15, 22))"
    },
    {
      "rank": 74,
      "score": 8.08452234024709,
      "candidate": "def min_op(num1, num2):\n    # num1 = int(input(\"Enter the first number: \"))\n    # num2 = int(input(\"Enter the second number: \"))\n    if num1 == num2:\n        return 0\n    if num1 == 0:\n        return num2\n    if num2 == 0:\n        return num1\n\n    if num1 > num2:\n        return min_op(num1 - num2, num2)\n    else:\n        return min_op(num1, num2 - num1)\n\n\nprint(min_op(10, 20))"
    },
    {
      "rank": 75,
      "score": 8.024835682833125,
      "candidate": "def min_operations(number_1, number_2):\n    count = 0\n    while number_1 != number_2:\n        if number_1 > number_2:\n            number_1 = number_1 - number_2\n        else:\n            number_2 = number_2 - number_1\n        count += 1\n    return count\n\n\nprint(min_operations(5, 2))\nprint(min_operations(4, 7))"
    },
    {
      "rank": 76,
      "score": 7.990432406683839,
      "candidate": "def min_op(a, b):\n    # Using a dict to store the min ops\n    d = dict()\n\n    # Base case\n    d[0] = 0\n\n    # Recursive case\n    if b > a:\n        diff = b - a\n    else:\n        diff = a - b\n    if diff in d:\n        return d[diff] + 1\n    else:\n        d[diff] = min_op(diff, diff - 1) + 1\n        return d[diff]\n\n\nif __name__ == \"__main__\":\n    print(min_op(11, 22))"
    },
    {
      "rank": 77,
      "score": 7.938028884277233,
      "candidate": "def minimum_operations(a,b):\n    res = []\n    while a != b:\n        if a > b:\n            a = a - b\n            res.append('Subtract')\n        else:\n            b = b - a\n            res.append('Add')\n    return res\n\nprint(minimum_operations(10, 15))\nprint(minimum_operations(15, 10))"
    },
    {
      "rank": 78,
      "score": 7.915588979966494,
      "candidate": "def min_ops(a,b):\n    if a == b:\n        return 0\n    if a < b:\n        a,b = b,a\n    return min(a-b, 2*b-a)\n\nif __name__ == \"__main__\":\n    print(min_ops(5,10))\n    print(min_ops(10,5))\n    print(min_ops(15,10))\n    print(min_ops(5,25))"
    },
    {
      "rank": 79,
      "score": 7.8912769574414305,
      "candidate": "def min_operations(num1, num2):\n    n1 = len(num1)\n    n2 = len(num2)\n    n = n1 if n1 > n2 else n2\n    num1 = \"0\" * (n - n1) + num1\n    num2 = \"0\" * (n - n2) + num2\n    count = 0\n    for i in range(n):\n        if num1[i] != num2[i]:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    num1 = \"12345\"\n    num2 = \"112345\"\n    print(min_operations(num1, num2))"
    },
    {
      "rank": 80,
      "score": 7.868947655733293,
      "candidate": "def min_operations(a, b):\n    count = 0\n    while a != b:\n        if a > b:\n            a = a - b\n        else:\n            b = b - a\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    a = int(input(\"Enter a number : \"))\n    b = int(input(\"Enter another number : \"))\n    print(\"Minimum operations required to make two numbers equal : \", min_operations(a, b))"
    },
    {
      "rank": 81,
      "score": 7.84634113240411,
      "candidate": "def min_operations(n1, n2):\n    n1_arr = list(map(int, str(n1)))\n    n2_arr = list(map(int, str(n2)))\n    min_len = min(len(n1_arr), len(n2_arr))\n    min_arr = n1_arr if len(n1_arr) <= len(n2_arr) else n2_arr\n    max_arr = n1_arr if len(n1_arr) >= len(n2_arr) else n2_arr\n    operations = 0\n    for i in range(min_len):\n        operations += max_arr[i] - min_arr[i]\n    if len(max_arr) > len(min_arr):\n        for i in range(min_len, len(max_arr)):\n            operations += max_arr[i]\n    return operations\n\n\ndef main():\n    n1 = int(input(\"Enter first number: \"))\n    n2 = int(input(\"Enter second number: \"))\n    result = min_operations(n1, n2)\n    print(f\"Minimum operations required to make two numbers equal: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 82,
      "score": 7.834022619458933,
      "candidate": "def min_operations(num1, num2):\n    num1_str = str(num1)\n    num2_str = str(num2)\n    len1 = len(num1_str)\n    len2 = len(num2_str)\n    if len1 == len2:\n        return len(set(num1_str) ^ set(num2_str))\n    elif len1 > len2:\n        return len(set(num1_str) ^ set(num2_str + '0' * (len1 - len2)))\n    else:\n        return len(set(num1_str + '0' * (len2 - len1)) ^ set(num2_str))"
    },
    {
      "rank": 83,
      "score": 7.780351419995229,
      "candidate": "def minimum_operations(n1, n2):\n    \"\"\"\n    This function takes two numbers as arguments and returns\n    the minimum operations required to make the two numbers equal.\n    \"\"\"\n    operations = 0\n    while n1 != n2:\n        if n1 > n2:\n            n1 -= n2\n        else:\n            n2 -= n1\n        operations += 1\n    return operations\n\nprint(minimum_operations(10, 15))"
    },
    {
      "rank": 84,
      "score": 7.738292593776799,
      "candidate": "def minimum_operations(a, b):\n    operations = 0\n    while a != b:\n        if a > b:\n            a = a - b\n            operations += 1\n        else:\n            b = b - a\n            operations += 1\n    return operations\n\n\nprint(minimum_operations(3, 1))"
    },
    {
      "rank": 85,
      "score": 7.7320703513377165,
      "candidate": "def min_ops(a, b):\n    count = 0\n    while a != b:\n        if a > b:\n            a -= b\n        else:\n            b -= a\n        count += 1\n    return count\n\n\nprint(min_ops(2, 1))\nprint(min_ops(5, 4))"
    },
    {
      "rank": 86,
      "score": 7.705183449260731,
      "candidate": "def min_ops(num1, num2):\n    \"\"\"\n    >>> min_ops(5, 3)\n    2\n    >>> min_ops(10, 10)\n    0\n    >>> min_ops(100, 110)\n    10\n    \"\"\"\n    num1_len = len(str(num1))\n    num2_len = len(str(num2))\n    # if the length of the number is different, add 0's to the smaller number until the length of the two number is the same\n    if num1_len < num2_len:\n        num1 = '0' * (num2_len - num1_len) + str(num1)\n    elif num2_len < num1_len:\n        num2 = '0' * (num1_len - num2_len) + str(num2)\n    # if the length of the number is the same, do nothing\n    else:\n        return 0\n    # if the number is the same, return 0\n    if num1 == num2:\n        return 0\n    # if the number is different, find the difference between the number and add 1 to the result\n    else:\n        diff = 0\n        for i in range(len(num1)):\n            if num1[i] != num2[i]:\n                diff += 1\n        return diff\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 7.5819855281879285,
      "candidate": "def min_operations(num1, num2):\n    n = len(str(num1))\n    m = len(str(num2))\n    if n < m:\n        num1, num2 = num2, num1\n        n, m = m, n\n    diff = num1 - num2\n    operations = 0\n    while diff != 0:\n        operations += 1\n        if diff >= 0:\n            diff = diff - 2 ** (m - 1)\n            m -= 1\n        else:\n            diff = diff + 2 ** (n - 1)\n            n -= 1\n    return operations\n\n\nprint(min_operations(15, 21))\nprint(min_operations(21, 15))"
    },
    {
      "rank": 88,
      "score": 7.562924366763077,
      "candidate": "def find_minimum_operations(num1, num2):\n    operations = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n            operations += 1\n        else:\n            num2 -= num1\n            operations += 1\n    return operations\n\n\nnum1 = 12\nnum2 = 45\nprint(find_minimum_operations(num1, num2))"
    },
    {
      "rank": 89,
      "score": 7.4878043221155455,
      "candidate": "def min_operations(n1, n2):\n    if n1 == n2:\n        return 0\n\n    if n1 > n2:\n        n1, n2 = n2, n1\n\n    count = 0\n\n    while n1 != n2:\n        if n1 == 0:\n            return -1\n\n        count += 1\n\n        if n1 % 2 == 0:\n            n1 = n1 / 2\n        else:\n            n1 = n1 + 1\n\n    return count\n\n\nprint(min_operations(2, 4))\nprint(min_operations(2, 6))\nprint(min_operations(5, 10))"
    },
    {
      "rank": 90,
      "score": 7.464609382504557,
      "candidate": "def min_op(a,b):\n    if a == b:\n        return 0\n    if a > b:\n        return min_op(a-b, b) + 1\n    else:\n        return min_op(a, b-a) + 1\n\nprint(min_op(123, 321))"
    },
    {
      "rank": 91,
      "score": 7.134571892399572,
      "candidate": "def min_operations(n1, n2):\n    if n1 == n2:\n        return 0\n    elif n1 > n2:\n        return n1 - n2\n    else:\n        return n2 - n1\n\n\nprint(min_operations(1, 2))\nprint(min_operations(3, 2))\nprint(min_operations(3, 3))"
    },
    {
      "rank": 92,
      "score": 3.0,
      "candidate": "def min_operations(n1, n2):\n    count = 0\n    if n1 > n2:\n        for i in range(n1 - n2):\n            count += 1\n            n1 -= 1\n    elif n1 < n2:\n        for i in range(n2 - n1):\n            count += 1\n            n2 -= 1\n    return count\n\n\nprint(min_operations(1, 2))"
    },
    {
      "rank": 93,
      "score": 3.0,
      "candidate": "def min_operations(num1, num2):\n    num1_arr = list(str(num1))\n    num2_arr = list(str(num2))\n\n    if len(num1_arr) > len(num2_arr):\n        for _ in range(len(num1_arr) - len(num2_arr)):\n            num2_arr.insert(0, \"0\")\n\n    diff = len(num1_arr) - len(num2_arr)\n\n    for i in range(diff):\n        num1_arr.pop(0)\n\n    diff = len(num2_arr) - len(num1_arr)\n\n    for i in range(diff):\n        num2_arr.pop(0)\n\n    # print(num1_arr)\n    # print(num2_arr)\n\n    count = 0\n    for i in range(len(num1_arr)):\n        if num1_arr[i] != num2_arr[i]:\n            count += 1\n\n    return count\n\n\nprint(min_operations(123, 124))"
    },
    {
      "rank": 94,
      "score": 3.0,
      "candidate": "def min_operations(x: int, y: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    x_str: str = str(x)\n    y_str: str = str(y)\n    x_len: int = len(x_str)\n    y_len: int = len(y_str)\n\n    if x_len < y_len:\n        return y_len - x_len + abs(int(x_str) - int(y_str))\n    elif x_len > y_len:\n        return x_len - y_len + abs(int(x_str) - int(y_str))\n    else:\n        return abs(int(x_str) - int(y_str))\n\n\nif __name__ == \"__main__\":\n    assert min_operations(123, 456) == 3\n    assert min_operations(456, 123) == 3\n    assert min_operations(123, 123) == 0\n    assert min_operations(234, 456) == 2\n    assert min_operations(456, 234) == 2\n    assert min_operations(123456, 456) == 6\n    assert min_operations(456, 123456) == 6\n    assert min_operations(123456, 123456) == 0\n    assert min_operations(123456, 12345) == 4\n    assert min_operations(12345, 123456) == 4"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "def minimumOperations(num1, num2):\n    num1_lst = list(str(num1))\n    num2_lst = list(str(num2))\n    # print(num1_lst, num2_lst)\n\n    # if both numbers are equal\n    if num1 == num2:\n        return 0\n    # if one number is zero\n    if num1 == 0 or num2 == 0:\n        return abs(num1) + abs(num2)\n    # if num1 is greater than num2\n    if num1 > num2:\n        # if last digit of num1 is same as first digit of num2\n        if num1_lst[-1] == num2_lst[0]:\n            return 1 + minimumOperations(int(\"\".join(num1_lst[:-1])), int(\"\".join(num2_lst[1:])))\n        # if last digit of num1 is not same as first digit of num2\n        else:\n            return 1 + minimumOperations(int(\"\".join(num1_lst[:-1])), num2)\n    # if num1 is smaller than num2\n    if num1 < num2:\n        # if first digit of num1 is same as last digit of num2\n        if num1_lst[0] == num2_lst[-1]:\n            return 1 + minimumOperations(int(\"\".join(num1_lst[1:])), int(\"\".join(num2_lst[:-1])))\n        # if first digit of num1 is not same as last digit of num2\n        else:\n            return 1 + minimumOperations(num1, int(\"\".join(num2_lst[:-1])))\n\n\nprint(minimumOperations(1234, 1224))"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "def minimum_operations(num1: int, num2: int) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    count = 0\n    while num1 != num2:\n        if num1 > num2:\n            num1 -= num2\n        else:\n            num2 -= num1\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    assert minimum_operations(12, 100) == 110"
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "def min_operations(num1, num2):\n    # Initialize the list to store the operations\n    op = []\n\n    # Check if both numbers are equal\n    if num1 == num2:\n        return 0\n\n    # Find the difference between the numbers\n    diff = abs(num1 - num2)\n\n    # Get the maximum number\n    max_num = max(num1, num2)\n\n    # Add the difference to the list\n    op.append(diff)\n\n    # Add the difference to the list\n    op.append(diff)\n\n    # Initialize count variable\n    count = 0\n\n    # Perform the operations\n    for i in range(len(op)):\n        if op[i] % 2 == 0:\n            count += op[i]\n        else:\n            count += op[i] - 1\n\n    # Return the count\n    return count\n\n\nif __name__ == '__main__':\n    num1 = 15\n    num2 = 13\n    print(min_operations(num1, num2))"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "def min_operations(n1: int, n2: int) -> int:\n    \"\"\"\n    This problem can be solved using a simple approach.\n    We can use a while loop to check if the numbers are equal.\n    If not, then we can use a while loop to subtract the minimum number from the maximum number.\n    We can do this until both numbers are equal.\n    The while loop will keep on repeating until we get the answer.\n    \"\"\"\n    operations = 0\n\n    while n1 != n2:\n        if n1 > n2:\n            n1 -= n2\n        else:\n            n2 -= n1\n        operations += 1\n    return operations\n\n\nif __name__ == \"__main__\":\n    print(min_operations(5, 15))"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "def min_operations(num1, num2):\n    # Using BFS\n    queue = [(num1, num2, 0)]\n    visited = set()\n    while queue:\n        num1, num2, count = queue.pop(0)\n        if (num1, num2) in visited:\n            continue\n        visited.add((num1, num2))\n        if num1 == num2:\n            return count\n        if num1 > 0 and (num1-1, num2) not in visited:\n            queue.append((num1-1, num2, count+1))\n        if num2 > 0 and (num1, num2-1) not in visited:\n            queue.append((num1, num2-1, count+1))\n    return -1\n\n\ndef min_operations_dp(num1, num2):\n    # Using DP\n    cache = [[-1 for _ in range(num2+1)] for _ in range(num1+1)]\n    for i in range(num1+1):\n        for j in range(num2+1):\n            if i == 0 or j == 0:\n                cache[i][j] = 0\n            elif i > 0 and j > 0:\n                cache[i][j] = min(cache[i-1][j]+1, cache[i][j-1]+1)\n    return cache[num1][num2]\n\n\ndef main():\n    print(min_operations(3, 4))\n    print(min_operations_dp(3, 4))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "def min_operations(num1, num2):\n    \"\"\"\n    Find the minimum operations required to make two numbers equal\n\n    Args:\n       num1(int): First number\n       num2(int): Second number\n    Returns:\n       int:  Minimum operations\n    \"\"\"\n    if num1 < num2:\n        smaller_num = num1\n        larger_num = num2\n    else:\n        smaller_num = num2\n        larger_num = num1\n    diff = larger_num - smaller_num\n    operations = 0\n    while diff != 0:\n        operations += 1\n        if diff & 1:\n            larger_num += 1\n            diff -= 1\n        else:\n            diff >>= 1\n    return operations\n\n\ndef test_function(test_case):\n    num1 = test_case[0]\n    num2 = test_case[1]\n    solution = test_case[2]\n    output = min_operations(num1, num2)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_function([1, 0, 1])\ntest_function([1, 1, 0])\ntest_function([1, 2, 1])\ntest_function([2, 2, 2])\ntest_function([1, 100, 99])\ntest_function([100, 1, 99])\ntest_function([100, 100, 100])\ntest_function([100, 100, 101])"
    }
  ]
}