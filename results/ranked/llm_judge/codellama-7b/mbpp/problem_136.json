{
  "timestamp": "2025-09-14T23:19:32.567680",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 136,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def find_max_total_path_sum(triangle):\n    if not triangle:\n        return 0\n\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    max_total = [0]\n    for i in range(len(triangle)):\n        if i == 0:\n            max_total.append(triangle[i][0] + max_total[0])\n            max_total.append(triangle[i][1] + max_total[1])\n        elif i == len(triangle) - 1:\n            max_total.append(triangle[i][len(triangle[i]) - 1] + max_total[len(triangle) - 1])\n        else:\n            max_total.append(triangle[i][i] + max(max_total[i], max_total[i - 1]))\n\n    return max(max_total)\n\n\ndef main():\n    triangle = [\n        [3],\n        [2, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]\n    print(find_max_total_path_sum(triangle))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        n = len(triangle)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def find_max_sum_path_recursive(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 0:\n        return 0\n\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    max_sum = 0\n\n    for i in range(len(triangle[-1])):\n        max_sum = max(max_sum, find_max_sum_path_recursive(triangle[:-1])[i] + triangle[-1][i])\n\n    return max_sum\n\n\ndef find_max_sum_path_iterative(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 0:\n        return 0\n\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    max_sum = triangle[-1][0]\n\n    for i in range(len(triangle[-1])):\n        max_sum = max(max_sum, find_max_sum_path_iterative(triangle[:-1])[i] + triangle[-1][i])\n\n    return max_sum\n\n\ndef find_max_sum_path(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 0:\n        return 0\n\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    max_sum = triangle[-1][0]\n    for i in range(len(triangle[-1])):\n        max_sum = max(max_sum, find_max_sum_path(triangle[:-1])[i] + triangle[-1][i])\n\n    return max_sum\n\n\nif __name__ == '__main__':\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    print(find_max_sum_path_iterative(triangle))\n    print("
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "triangle = [[1], [2, 3], [4, 5, 6]]\n\n\ndef max_path_sum(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for column in range(len(triangle[row])):\n            triangle[row][column] += max(triangle[row + 1][column], triangle[row + 1][column + 1])\n    return triangle[0][0]\n\n\nprint(max_path_sum(triangle))"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        n = len(triangle)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\na = Solution()\nprint(a.maxPathSum([[-10]]))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "# O(n^2) time | O(n^2) space\ndef maxSumPath(triangle):\n    maxPath = [0] * len(triangle)\n    for i in reversed(range(len(triangle))):\n        for j in range(i + 1):\n            if i == len(triangle) - 1:\n                maxPath[j] = triangle[i][j]\n            else:\n                maxPath[j] = max(triangle[i][j] + maxPath[j], triangle[i][j] + maxPath[j + 1])\n    return maxPath[0]\n\n\n# O(n) time | O(n) space\ndef maxSumPath2(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n\n\n# O(n) time | O(n) space\ndef maxSumPath3(triangle):\n    maxPath = [0] * len(triangle)\n    for i in reversed(range(len(triangle))):\n        for j in range(i + 1):\n            if i == len(triangle) - 1:\n                maxPath[j] = triangle[i][j]\n            else:\n                maxPath[j] = max(triangle[i][j] + maxPath[j], triangle[i][j] + maxPath[j + 1])\n    return maxPath[0]"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for i in range(len(triangle) - 1, 0, -1):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                triangle[i - 1][j] += triangle[i][j]\n            elif j == i:\n                triangle[i - 1][j - 1] += triangle[i][j]\n            else:\n                triangle[i - 1][j] = max(triangle[i - 1][j], triangle[i - 1][j - 1]) + triangle[i][j]\n            max_sum = max(max_sum, triangle[i - 1][j])\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    tri = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [6, 3, 5, 1, 0]]\n    print(max_path_sum(tri))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j])\n        return max(triangle[-1])\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxPathSum([[-1], [-2]])\n    print solution.maxPathSum([[-1, 0, 0]])\n    print solution.maxPathSum([[-1], [-2], [0, 0]])\n    print solution.maxPathSum([[-1], [-2], [1, 2]])\n    print solution.maxPathSum([[-1], [-2], [3, 4]])\n    print solution.maxPathSum([[-1], [-2], [3, 4], [5, 6]])\n    print solution.maxPathSum([[-1], [-2], [3, 4], [5, 6], [7, 8]])"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_sum = triangle[-1][-1]\n\n    for row in reversed(triangle[:-1]):\n        for col in range(len(row)):\n            max_sum = max(row[col] + max(max_sum, row[col + 1]), max_sum)\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    # print(max_path_sum([[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]))\n    # print(max_path_sum([[5], [9, 8], [7, 6, 5], [4, 1, 8, 3]]))\n    # print(max_path_sum([[1], [2, 3], [4, 5, 6]]))\n    # print(max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    # print(max_path_sum([[1], [2], [3]]))\n    # print(max_path_sum([[1], [2], [3, 4]]))\n    # print(max_path_sum([[1], [2], [3, 4], [5, 6, 7]]))\n    # print(max_path_sum([[1], [2], [3, 4], [5, 6, 7], [8, 9, 10, 11]]))\n\n    assert max_path_sum([[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]) == 23\n    assert max_path_sum([[5], [9, 8], [7, 6, 5], [4, 1, 8, 3]]) == 39\n    assert max_"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 1:\n        return triangle[0][0]\n    max_path = [0] * len(triangle)\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            max_path[j] = max(max_path[j], max_path[j + 1])\n            max_path[j] += triangle[i][j]\n    return max(max_path)\n\n\nif __name__ == \"__main__\":\n    t1 = [\n        [1],\n        [2, 3],\n        [4, 5, 6],\n        [7, 8, 9, 10],\n    ]\n    print max_path_sum(t1)"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def find_max_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    for row_idx in range(len(triangle) - 2, -1, -1):\n        for col_idx in range(len(triangle[row_idx])):\n            triangle[row_idx][col_idx] += max(\n                triangle[row_idx + 1][col_idx],\n                triangle[row_idx + 1][col_idx + 1]\n            )\n\n    return triangle[0][0]"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    print Solution().maxPathSum([[1], [2, 3], [4, 5, 6]])"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        dp = triangle[-1]\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = max(dp[j], dp[j+1]) + triangle[i][j]\n        return dp[0]\n\na = Solution()\n\nprint a.maxPathSum([[-10]]), 0\nprint a.maxPathSum([[10]]), 10\nprint a.maxPathSum([[2], [7, 4]]), 11\nprint a.maxPathSum([[5], [7, 4], [5, -4, 0]]), 12\nprint a.maxPathSum([[5, 1], [7, 4], [5, -4, 0]]), 15\nprint a.maxPathSum([[1], [-1], [-2], [-1]]), -1"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] = max(triangle[i][j] + triangle[i + 1][j], triangle[i][j] + triangle[i + 1][j + 1])\n\n        return triangle[0][0]"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1: DP\n\n        * We are given a triangle, with each node\n        having 2 children nodes.\n        The objective is to find the maximum path sum\n        through the triangle.\n\n        * We can either start from the bottom and\n        work upwards, or start from the top and\n        work downwards.\n        The following is a DP solution, where we\n        start from the top and work downwards.\n\n        Your runtime beats 72.84 % of python submissions\n        \"\"\"\n        # #Boundary Conditions\n        if not triangle:\n            return 0\n\n        height = len(triangle)\n\n        # #Initialization\n        for row in range(1, height):\n            for col in range(row + 1):\n                if col == 0:\n                    triangle[row][col] += triangle[row - 1][col]\n\n                elif col == row:\n                    triangle[row][col] += triangle[row - 1][col - 1]\n\n                else:\n                    triangle[row][col] += max(triangle[row - 1][col - 1],\n                                              triangle[row - 1][col])\n\n        return max(triangle[-1])"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                triangle[i][j] += triangle[i-1][j]\n            elif j == len(triangle[i]) - 1:\n                triangle[i][j] += triangle[i-1][j-1]\n            else:\n                triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])\n    return max(triangle[-1])\n\nif __name__ == '__main__':\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        if len(triangle) == 2:\n            return max(triangle[0][0], triangle[0][1], triangle[1][0], triangle[1][1])\n\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += max(triangle[i - 1][j], triangle[i - 1][j + 1])\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j])\n                else:\n                    triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j], triangle[i - 1][j + 1])\n        return max(triangle[-1])\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.maxPathSum([[1], [2, 3], [4, 5, 6]])"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "def maxPathSum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\n# test\nt1 = [\n        [2],\n        [3,4],\n        [6,5,7],\n        [4,1,8,3]\n    ]\n\nprint(maxPathSum(t1))"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    size = len(triangle)\n    if size == 0:\n        return 0\n    if size == 1:\n        return triangle[0][0]\n\n    max_sum = [0] * size\n    max_sum[0] = triangle[0][0]\n    max_sum[1] = max(triangle[1][0], triangle[1][1])\n\n    for i in range(2, size):\n        max_sum[i] = max(max_sum[i - 1], max_sum[i - 2]) + triangle[i][i]\n\n    return max(max_sum[size - 1], max_sum[size - 2])\n\n\nif __name__ == \"__main__\":\n    triangle = [\n        [1],\n        [2, 3],\n        [4, 5, 6],\n        [7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20, 21]\n    ]\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n        Your runtime beats 71.39 % of python submissions\n\n        The idea is to create a matrix of the same dimensions\n        as the triangle array and then fill it up with the\n        values of the triangle array. Then, the logic is the\n        same as the matrix chain multiplication problem.\n        \"\"\"\n        res = triangle[-1]\n        matrix = []\n\n        for i in range(len(triangle)):\n            matrix.append([None] * i)\n\n        for i in range(len(triangle)):\n            for j in range(len(triangle[i])):\n                if i == 0:\n                    matrix[i][j] = triangle[i][j]\n                elif j == 0:\n                    matrix[i][j] = matrix[i - 1][j] + triangle[i][j]\n                elif j == i:\n                    matrix[i][j] = matrix[i - 1][j - 1] + triangle[i][j]\n                else:\n                    matrix[i][j] = max(matrix[i - 1][j - 1], matrix[i - 1][j]) + triangle[i][j]\n\n                res = max(res, matrix[i][j])\n\n        return res"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [\n        4, 5, 2, 6, 5]]  # 37\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "def max_path(triangle):\n    for row in range(len(triangle)-2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row+1][col], triangle[row+1][col+1])\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]\n    print(max_path(triangle))"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return None\n\n    n = len(triangle)\n\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1])\n\n    return triangle[0][0]\n\n\nif __name__ == '__main__':\n    # 7\n    print(max_path_sum([\n        [2],\n        [3, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]))"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n        Your runtime beats 43.90 % of python submissions.\n        \"\"\"\n        def dp(triangle, row, col, dp_array):\n            if row >= len(triangle):\n                return 0\n\n            if (row, col) in dp_array:\n                return dp_array[(row, col)]\n\n            #Base Case\n            if row == len(triangle) - 1:\n                return max(triangle[row][col], triangle[row][col + 1])\n\n            #General Case\n            dp_array[(row, col)] = max(dp(triangle, row + 1, col, dp_array) + triangle[row][col],\n                                        dp(triangle, row + 1, col + 1, dp_array) + triangle[row][col])\n\n            return dp_array[(row, col)]\n\n        dp_array = {}\n        return max(dp(triangle, 0, 0, dp_array), dp(triangle, 0, 1, dp_array))"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "# O(n^2)\ndef find_max_total_path_sum_brute(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    max_sum = triangle[0][0]\n    for row in range(1, len(triangle)):\n        for col in range(len(triangle[row])):\n            if col == 0:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col])\n            elif col == len(triangle[row]) - 1:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col - 1])\n            else:\n                max_sum = max(max_sum, triangle[row][col] + max(triangle[row - 1][col - 1], triangle[row - 1][col]))\n\n    return max_sum\n\n\n# O(n)\ndef find_max_total_path_sum_optimized(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    max_sum = triangle[0][0]\n    for row in range(1, len(triangle)):\n        for col in range(len(triangle[row])):\n            if col == 0:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col])\n            elif col == len(triangle[row]) - 1:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col - 1])\n            else:\n                max_sum = max(max_sum, triangle[row][col] + max(triangle[row - 1][col - 1], triangle[row - 1][col]))\n\n    return max_sum\n\n\n# O(n)\ndef find_max_total_path_sum_optimized_2(triangle):\n    \"\"\"\n    :type triangle: List[List"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # use dp\n    # 1. dp[i][j] means the maximum path sum from the start to (i, j)\n    # 2. dp[i][j] = triangle[i][j] + max(dp[i - 1][j - 1], dp[i - 1][j])\n    # 3. dp[0][j] = triangle[0][j]\n\n    # init\n    dp = [[0 for _ in range(len(triangle[0]))] for _ in range(len(triangle))]\n    dp[0][0] = triangle[0][0]\n\n    # dp\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + triangle[i][j]\n            elif j == len(triangle[i]) - 1:\n                dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]\n\n    return max(dp[-1])\n\n\ntriangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [\n    6, 3, 5, 1, 9], [\n        1, 5, 3, 3, 1, 4], [\n            8, 4, 1, 7, 3, 1, 1], [\n                7, 5, 1, 1, 1, 1, 1, 1]]\nprint(max_path_sum(triangle))"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(tri: List[List[int]]) -> int:\n    \"\"\"\n    The maximum path sum in any triangle is the same as the maximum path sum\n    in the bottom row.\n\n    So, we can start from the bottom row and work our way upwards.\n    \"\"\"\n    for i in range(len(tri) - 2, -1, -1):\n        for j in range(len(tri[i])):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n\n    return tri[0][0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6]]) == 12"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]\n\n\nclass Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == i:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j])\n        return max(triangle[-1])\n\n\ns = Solution()\nprint(s.maxPathSum(triangle))"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        m = 0\n        for i, row in enumerate(triangle):\n            if i == 0:\n                m = max(row)\n            else:\n                for j in range(len(row) - 1):\n                    if row[j] > m:\n                        m = row[j]\n                    row[j + 1] += max(m, row[j])\n                if row[-1] > m:\n                    m = row[-1]\n        return m\n\n\nif __name__ == \"__main__\":\n    print(Solution().maxPathSum(\n        [\n            [1],\n            [2, 3],\n            [2, 5, 4],\n            [5, 1, 1, 2]\n        ]\n    ))"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_total_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    The total path sum can be found by adding the elements of the current\n    row, the path sum of the previous row, and the largest of the two.\n    \"\"\"\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(\n                triangle[row + 1][col],\n                triangle[row + 1][col + 1],\n            )\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    assert max_total_path_sum([[3], [2, 4], [5, 1, 1]]) == 10"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] = max(triangle[i][j], triangle[i][j] + triangle[i + 1][j], triangle[i][j] + triangle[i + 1][j + 1])\n        return max(triangle[0])"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        The idea is to start from the bottom.\n\n        Time complexity: O(n^2), where n is the number of elements in the list.\n        Space complexity: O(n).\n        \"\"\"\n        n = len(triangle)\n        if n == 0:\n            return 0\n\n        # Start from the bottom.\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    result = Solution().maxPathSum(triangle)\n    print(result)"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "from typing import List\n\n\n# O(n) time | O(1) space - where n is the length of the list\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    for i in range(len(triangle)-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] = triangle[i][j] + max(triangle[i+1][j], triangle[i+1][j+1])\n\n    return max(triangle[0][0], triangle[0][1])\n\n\nif __name__ == '__main__':\n    print(max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]))"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        n = len(triangle)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        dp[0][0] = triangle[0][0]\n        for i in range(1, n):\n            for j in range(i + 1):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + triangle[i][j]\n                elif j == i:\n                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]\n        return max(dp[-1])"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "def find_max_total_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    # 1st row\n    for i in range(1, len(triangle)):\n        for j in range(i+1):\n            triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])\n    return max(triangle[-1])\n\n\ndef find_max_total_path_sum_1(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                triangle[i][j] += triangle[i-1][j]\n            elif j == len(triangle[i])-1:\n                triangle[i][j] += triangle[i-1][j-1]\n            else:\n                triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])\n    return max(triangle[-1])\n\n\nif __name__ == \"__main__\":\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15],\n                [16, 17, 18, 19, 20, 21]]\n    print(find_max_total_path_sum(triangle))\n    print(find_max_total_path_sum_1(triangle))"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "# O(n^2) time, O(n) space\ndef max_path_sum(triangle):\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    sums = [[0] * (i+1) for i in range(len(triangle))]\n    sums[0][0] = triangle[0][0]\n\n    for row in range(1, len(triangle)):\n        for col in range(row+1):\n            if col == 0:\n                sums[row][col] = triangle[row][col] + sums[row-1][col]\n            elif col == row:\n                sums[row][col] = triangle[row][col] + sums[row-1][col-1]\n            else:\n                sums[row][col] = triangle[row][col] + max(sums[row-1][col], sums[row-1][col-1])\n\n    return max(sums[-1])\n\n\nif __name__ == '__main__':\n    assert max_path_sum([\n        [2],\n        [3, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]) == 20"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle or not triangle[0]:\n            return 0\n        row_num = len(triangle)\n        dp = [[0 for _ in range(row_num)] for _ in range(row_num)]\n        dp[0][0] = triangle[0][0]\n        for i in range(1, row_num):\n            for j in range(i + 1):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + triangle[i][j]\n                elif j == i:\n                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]\n        return max(dp[row_num - 1])"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [\n        [2],\n        [3, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]\n    assert max_path_sum(triangle) == 20"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n\n\n# test\nt1 = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]\nprint(max_path_sum(t1))"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] = max(triangle[i][j], triangle[i][j] + triangle[i + 1][j], triangle[i][j] + triangle[i + 1][j + 1])\n        return triangle[0][0]"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        m = triangle[0]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    m[j] = m[j] + triangle[i][j]\n                elif j == len(triangle[i]) - 1:\n                    m[j] = m[j - 1] + triangle[i][j]\n                else:\n                    m[j] = max(m[j], m[j - 1]) + triangle[i][j]\n        return max(m)"
    },
    {
      "rank": 45,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n        Your runtime beats 100.00 % of python submissions.\n        \"\"\"\n        max_sum = 0\n        for i in range(len(triangle) - 1, -1, -1):\n            for j in range(len(triangle[i]) - 1, -1, -1):\n                max_sum = max(max_sum, triangle[i][j] + max(triangle[i + 1][j], triangle[i + 1][j + 1]))\n\n        return max_sum"
    },
    {
      "rank": 46,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    test = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [6, 3, 5, 1, 0]]\n    print(max_path_sum(test))"
    },
    {
      "rank": 47,
      "score": 10.0,
      "candidate": "class Solution:\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n\n        * Note: The triangle is a DP problem\n\n        * The question is the same as asking for the maximum sum of a\n        \"path\" in a triangle\n\n        * A path in a triangle can be of 3 types:\n            - Going upwards\n            - Going downwards\n            - Going sideways\n\n        * Going upwards: The maximum path sum is the sum of the\n        two nodes above\n\n        * Going downwards: The maximum path sum is the sum of the\n        two nodes below\n\n        * Going sideways: The maximum path sum is the sum of the\n        two nodes at the same level\n\n        Your runtime beats 94.15 % of python3 submissions.\n        \"\"\"\n        # #Boundary Conditions\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return max(triangle[0])\n\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += max(triangle[i - 1][j],\n                                          triangle[i - 1][j + 1])\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += max(triangle[i - 1][j - 1],\n                                          triangle[i - 1][j])\n                else:\n                    triangle[i][j] += max(triangle[i - 1][j - 1],\n                                          triangle[i - 1][j],\n                                          triangle[i - 1][j + 1])\n\n        return max(triangle[-1])"
    },
    {
      "rank": 48,
      "score": 10.0,
      "candidate": "def max_total_path_sum(triangle):\n    \"\"\"\n    :param triangle: list of list of int\n    :return: int\n    \"\"\"\n    if not triangle:\n        return 0\n    n = len(triangle)\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n    print(max_total_path_sum(triangle))"
    },
    {
      "rank": 49,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        max_sum = triangle[0][0]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == i:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j])\n                max_sum = max(max_sum, triangle[i][j])\n        return max_sum\n\n\na = Solution()\nassert 19 == a.maxTotal([\n    [2],\n    [3,4],\n    [6,5,7],\n    [4,1,8,3]\n])\nassert 31 == a.maxTotal([\n    [-10],\n    [5,10],\n    [3, 2, 4],\n    [1, -7, 8, 3]\n])"
    },
    {
      "rank": 50,
      "score": 10.0,
      "candidate": "def maxPathSum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]\n    print(maxPathSum(triangle))"
    },
    {
      "rank": 51,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        dp = triangle[-1]\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = max(dp[j], dp[j+1]) + triangle[i][j]\n        return dp[0]\n\nsolution = Solution()\ntriangle = [[1], [2, 3], [1, 5, 1]]\nprint solution.maxPathSum(triangle)"
    },
    {
      "rank": 52,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        max_sum = [0 for _ in range(len(triangle))]\n        for row in range(len(triangle), 0, -1):\n            for col in range(row):\n                if col == 0:\n                    max_sum[col] = max(max_sum[col], triangle[row - 1][col])\n                elif col == row - 1:\n                    max_sum[col] = max(max_sum[col - 1], max_sum[col], triangle[row - 1][col])\n                else:\n                    max_sum[col] = max(max_sum[col - 1], max_sum[col], max_sum[col + 1] + triangle[row - 1][col])\n        return max_sum[0]"
    },
    {
      "rank": 53,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    n = len(triangle)\n\n    # create a new list with the same size as the triangle\n    # and initialize it to 0\n    dp = [0] * n\n\n    # base case: the first element in the first row is the max path sum\n    dp[0] = triangle[0][0]\n\n    # iterate through the triangle, starting from the second row\n    for i in range(1, n):\n        # set the first and last elements to their values\n        dp[0] = max(dp[0], triangle[i][0])\n        dp[i] = max(dp[i], triangle[i][i])\n\n        # iterate through the current row\n        for j in range(1, i):\n            # set the current dp[j] to the max of the two values\n            # above it\n            dp[j] = max(dp[j - 1], dp[j]) + triangle[i][j]\n\n    # return the max value\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    triangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [6, 3, 5, 1, 9]]\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 54,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    max_sum = 0\n    for i in range(len(triangle) - 1, -1, -1):\n        for j in range(len(triangle[i])):\n            if i == len(triangle) - 1:\n                max_sum = max(max_sum, triangle[i][j])\n            else:\n                max_sum = max(max_sum, triangle[i][j] + max(triangle[i + 1][j], triangle[i + 1][j + 1]))\n    return max_sum\n\n\nif __name__ == '__main__':\n    print(max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]))"
    },
    {
      "rank": 55,
      "score": 10.0,
      "candidate": "def max_sum_path(tri):\n    \"\"\"\n    :type tri: List[List[int]]\n    :rtype: int\n    \"\"\"\n    n = len(tri)\n    dp = [0] * n\n    for i in range(n-1, -1, -1):\n        for j in range(i+1):\n            if i == n-1:\n                dp[j] = tri[i][j]\n            else:\n                dp[j] = max(dp[j], dp[j+1]) + tri[i][j]\n    return dp[0]\n\n\nif __name__ == '__main__':\n    print(max_sum_path([[1], [2, 3], [4, 5, 6]]))"
    },
    {
      "rank": 56,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1: Dynamic Programming\n        Your runtime beats 43.79 % of python submissions\n        \"\"\"\n        if not triangle: return 0\n\n        dp = triangle[0]\n\n        for i in range(1, len(triangle)):\n            row = triangle[i]\n            prev_row = triangle[i - 1]\n\n            for j in range(len(row)):\n                if j == 0:\n                    dp[j] = max(dp[j], row[j])\n                elif j == i:\n                    dp[j] = max(dp[j - 1], dp[j]) + row[j]\n                else:\n                    dp[j] = max(dp[j - 1], dp[j]) + row[j]\n\n        return max(dp)"
    },
    {
      "rank": 57,
      "score": 10.0,
      "candidate": "triangle = [\n    [1],\n    [2, 3],\n    [4, 5, 6],\n    [7, 8, 9, 10],\n    [11, 12, 13, 14, 15],\n    [16, 17, 18, 19, 20, 21]\n]\n\ndef max_path_sum(triangle):\n    # Base case\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    # Recursive case\n    else:\n        current_row = triangle.pop(0)\n        next_row = triangle.pop(0)\n\n        # Calculate max sum for each path\n        max_sums = []\n        for i in range(len(current_row)):\n            max_sums.append(max(current_row[i] + next_row[i], current_row[i] + next_row[i+1]))\n\n        # Calculate sum for current row\n        max_path_sum(triangle)\n\n    return max(max_sums)\n\nprint(max_path_sum(triangle))"
    },
    {
      "rank": 58,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        dp = triangle[-1]\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = max(dp[j], dp[j + 1]) + triangle[i][j]\n        return dp[0]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    print solution.maxPathSum([[1], [2, 3], [1, 5, 1]])"
    },
    {
      "rank": 59,
      "score": 10.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    for row in range(1, len(triangle)):\n        for col in range(len(triangle[row])):\n            if col == 0:\n                triangle[row][col] += triangle[row - 1][col]\n            elif col == len(triangle[row]) - 1:\n                triangle[row][col] += triangle[row - 1][col - 1]\n            else:\n                triangle[row][col] += max(triangle[row - 1][col - 1], triangle[row - 1][col])\n    return max(triangle[-1])\n\n\nif __name__ == '__main__':\n    triangle = [\n        [2],\n        [3, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 60,
      "score": 10.0,
      "candidate": "triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]\n\n\ndef max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    m = [[0] * (i + 1) for i in range(len(triangle))]\n    m[0][0] = triangle[0][0]\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                m[i][j] = m[i - 1][j] + triangle[i][j]\n            elif j == len(triangle[i]) - 1:\n                m[i][j] = m[i - 1][j - 1] + triangle[i][j]\n            else:\n                m[i][j] = max(m[i - 1][j], m[i - 1][j - 1]) + triangle[i][j]\n    return max(m[len(triangle) - 1])\n\n\nprint(max_path_sum(triangle))"
    },
    {
      "rank": 61,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] = max(triangle[i][j] + triangle[i + 1][j], triangle[i][j] + triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\na = Solution()\nassert a.maxPathSum([[-10, 5, -20, -30], [10, -10, 5, -20], [5, -5, 5, 5], [-10, -10, -10, -10]]) == 25"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] = max(triangle[i][j],\n                                     triangle[i + 1][j] + triangle[i][j],\n                                     triangle[i + 1][j + 1] + triangle[i][j])\n        return triangle[0][0]"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "def max_path_sum(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n\n\nif __name__ == '__main__':\n    triangle = [\n        [2],\n        [3, 4],\n        [6, 5, 7],\n        [4, 1, 8, 3]\n    ]\n    print(max_path_sum(triangle))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "# O(n^2) time | O(n) space\ndef maximumTotal(triangle):\n    maxPathSum = [-float(\"inf\")]\n    for row in triangle[::-1]:\n        newRow = []\n        for idx, num in enumerate(row):\n            if idx == 0:\n                newRow.append(num)\n            else:\n                newRow.append(num + max(maxPathSum[idx - 1], maxPathSum[idx]))\n        maxPathSum = newRow\n    return maxPathSum[-1]"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def find_max_sum_path(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    m = len(triangle)\n    for i in range(m - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    max_sum = triangle[0][0]\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                triangle[i][j] += triangle[i - 1][j]\n            elif j == i:\n                triangle[i][j] += triangle[i - 1][j - 1]\n            else:\n                triangle[i][j] += max(triangle[i - 1][j - 1], triangle[i - 1][j])\n\n        max_sum = max(max_sum, triangle[i][-1])\n\n    return max_sum"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    if len(triangle) == 1:\n        return triangle[0][0]\n    dp = [[0] * len(triangle[i]) for i in range(len(triangle))]\n    for i in range(len(triangle)):\n        for j in range(len(triangle[i])):\n            if i == 0:\n                dp[i][j] = triangle[i][j]\n            elif i == len(triangle) - 1:\n                dp[i][j] = dp[i - 1][j] + triangle[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]\n    return max(dp[-1])"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "triangle = [[1], [2, 3], [1, 5, 1], [2, 1, 3, 1], [1, 2, 1, 1, 1]]\n\n\ndef max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] = max(triangle[row][col] + triangle[row + 1][col],\n                                     triangle[row + 1][col + 1])\n    return triangle[0][0]"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        max_path = [0] * len(triangle)\n        max_path[0] = triangle[0][0]\n        for i in range(1, len(triangle)):\n            for j in range(i, -1, -1):\n                if j == i:\n                    max_path[j] = max(max_path[j - 1], max_path[j]) + triangle[i][j]\n                else:\n                    max_path[j] = max(max_path[j - 1], max_path[j]) + triangle[i][j]\n        return max(max_path)\n\ntri = [[2],[3,4],[6,5,7],[4,1,8,3]]\nsolution = Solution()\nprint solution.maxPathSum(tri)"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def maxTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        return self.maxPathSum(triangle, 0, 0)\n\n    def maxPathSum(self, triangle, row, col):\n        if row == len(triangle) - 1:\n            return triangle[row][col]\n        left = self.maxPathSum(triangle, row + 1, col)\n        right = self.maxPathSum(triangle, row + 1, col + 1)\n        return max(left, right) + triangle[row][col]"
    },
    {
      "rank": 72,
      "score": 3.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n\n        * The question is to find the maximum path sum in a triangle\n        * We are basically finding the largest path sum\n        * For this, we can use a DP approach\n\n        * At each step, we can add the max of the two paths\n        * OR we can add the path itself\n\n        Your runtime beats 84.56 % of python submissions.\n        \"\"\"\n        # #Code Block for Method 1\n\n        # #Base Case\n        # if not triangle:\n        #     return 0\n\n        # #Initialization\n        # max_sum = triangle[0][0]\n\n        # #Dynamic Programming\n        # for i in range(1, len(triangle)):\n        #     for j in range(len(triangle[i])):\n        #         if j == 0:\n        #             max_sum = max(max_sum, triangle[i][j] + triangle[i-1][j])\n        #         elif j == len(triangle[i]) - 1:\n        #             max_sum = max(max_sum, triangle[i][j] + triangle[i-1][j-1])\n        #         else:\n        #             max_sum = max(max_sum, triangle[i][j] + max(triangle[i-1][j-1], triangle[i-1][j]))\n\n        # return max_sum\n\n        # #Code Block for Method 2\n\n        # #Base Case\n        # if not triangle:\n        #     return 0\n\n        # #Initialization\n        # max_sum = triangle[0][0]\n\n        # #Dynamic Programming\n        # for i in range(1, len(triangle)):\n        #     for j in range(len(triangle[i])):\n        #         if j == 0:\n        #             max_sum = max(max_sum, triangle[i][j] + triangle[i-1][j])\n        #         elif j == len(triangle["
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time complexity: O(n*m)\n    Space complexity: O(n)\n    \"\"\"\n    if not triangle:\n        return 0\n\n    rows = len(triangle)\n\n    # dp[i][j] is the maximum path sum ending at triangle[i][j]\n    dp = [[0] * (i + 1) for i in range(rows)]\n\n    # Initialize dp[0][j]\n    for j in range(rows):\n        dp[0][j] = triangle[0][j]\n\n    # Calculate dp[1][j]\n    for i in range(1, rows):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + triangle[i][j]\n            elif j == i:\n                dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]\n\n    return max(dp[-1])\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6]]) == 2 + 3 + 6\n    assert max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]) == 2 + 3 + 9 + 10"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def max_total_path(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not triangle:\n        return 0\n\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    t = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    assert max_total_path(t) == 20"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "triangle = [\n    [7],\n    [3, 4],\n    [8, 1, 0],\n    [5, 7, 2, 4],\n    [6, 1, 1, 3, 2],\n]\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # TODO:\n        pass"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        The idea is to maintain a cache for the path sum at each node.\n        The cache is initialized with the first row of the triangle.\n        Then, for each subsequent row, we traverse the triangle in a\n        left-to-right manner.\n        For each node, we compare the path sum at its left child with\n        the path sum at its right child.\n        The path sum at the current node is the maximum of the two\n        options.\n        If the current node is at the bottom row, the path sum at the\n        current node is the maximum of the two path sums.\n        \"\"\"\n        cache = triangle[0]\n\n        for row in triangle[1:]:\n            for i in range(len(row)):\n                if i == 0:\n                    cache[i] = max(cache[i], cache[i + 1]) + row[i]\n                elif i == len(row) - 1:\n                    cache[i] = max(cache[i], cache[i - 1]) + row[i]\n                else:\n                    cache[i] = max(cache[i], cache[i - 1]) + row[i]\n\n        return max(cache)\n\n\nif __name__ == \"__main__\":\n    tri = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    out = 23\n    res = Solution().maxPathSum(tri)\n    assert res == out, (res, out)\n\n    tri = [[-10]]\n    out = -10\n    res = Solution().maxPathSum(tri)\n    assert res == out, (res, out)\n\n    tri = [[1], [7, 6], [2, 9, 5], [6, 8, 7, 1]]\n    out = 23\n    res = Solution().maxPathSum(tri)\n    assert res == out, (res, out)"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    triangle = [[1], [2, 3], [4, 5, 6]]\n    assert solution.maxPathSum(triangle) == 16"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef find_max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    assert find_max_path_sum(\n        [[5], [9, 8], [7, 6, 5], [8, 7, 6, 5]]\n    ) == 25"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef maximum_total_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(1)\n    \"\"\"\n\n    def _maximum_total_path_sum(row: int) -> int:\n        if row == 0:\n            return triangle[row][0]\n\n        left = _maximum_total_path_sum(row - 1)\n        right = _maximum_total_path_sum(row - 1)\n\n        return triangle[row][row] + max(left, right)\n\n    return _maximum_total_path_sum(len(triangle) - 1)\n\n\nif __name__ == \"__main__\":\n    assert (\n        maximum_total_path_sum(\n            [\n                [1],\n                [2, 3],\n                [4, 5, 6],\n                [7, 8, 9, 10],\n            ]\n        )\n        == 40\n    )"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        if len(triangle) == 2:\n            return max(triangle[0][0] + triangle[1][0], triangle[0][1] + triangle[1][1])\n\n        dp = [0] * len(triangle[0])\n        dp[0] = triangle[0][0]\n        dp[1] = max(triangle[1][0], triangle[1][1])\n        for i in range(2, len(triangle)):\n            for j in range(i + 1):\n                if j == 0:\n                    dp[j] = max(dp[j], triangle[i][j] + dp[j])\n                elif j == i:\n                    dp[j] = max(dp[j], triangle[i][j] + dp[j - 1])\n                else:\n                    dp[j] = max(dp[j], triangle[i][j] + max(dp[j - 1], dp[j]))\n        return max(dp)\n\n\nif __name__ == \"__main__\":\n    print(Solution().maxPathSum([[1], [2, 3], [1, 5, 1]]))\n    print(Solution().maxPathSum([[1], [2, 3], [1, 5, 1], [2, 1, 3]]))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n^2)\n    Space Complexity: O(n)\n    \"\"\"\n\n    rows = len(triangle)\n\n    for row in range(rows - 2, -1, -1):\n        for col in range(row + 1):\n            triangle[row][col] += max(\n                triangle[row + 1][col], triangle[row + 1][col + 1]\n            )\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 54"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # \u9012\u5f52\n        # \u9012\u5f52\u7684\u89e3\u9898\u601d\u8def\uff0c\u9996\u5148\u660e\u786e\u8fd9\u9053\u9898\u7684\u76ee\u6807\u662f\u627e\u5230\u4e00\u6761\u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9\u7684\u8def\u5f84\n        # \u641c\u7d22\u7684\u601d\u8def\uff1a\u4ece\u5de6\u8fb9\u7684\u8282\u70b9\u5f00\u59cb\u641c\u7d22\uff0c\u627e\u5230\u4e00\u4e2a\u6700\u5927\u7684\u503c\uff0c\u8fd9\u4e2a\u6700\u5927\u503c\u5c31\u662f\u67d0\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\n        # \u7136\u540e\u518d\u4ece\u8fd9\u4e2a\u8282\u70b9\u7684\u53f3\u8fb9\u7684\u8282\u70b9\u5f00\u59cb\u641c\u7d22\uff0c\u5982\u679c\u8fd9\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\u5927\u4e8e\u67d0\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\uff0c\u90a3\u4e48\u5c31\u66f4\u65b0\u8fd9\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\n        # \u7136\u540e\u4ece\u8fd9\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u641c\u7d22\uff0c\u5982\u679c\u8fd9\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\u5927\u4e8e\u67d0\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\uff0c\u90a3\u4e48\u5c31\u66f4\u65b0\u8fd9\u4e2a\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u548c\n        # \u8fd9\u6837\u627e\u5230\u4e00\u6761\u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9\u7684\u8def\u5f84\uff0c\u627e\u5230\u6700\u5927\u7684\u8def\u5f84\u548c\uff0c\u5c31\u662f\u6700\u7ec8\u7ed3\u679c\n        # \u8fd9\u9053\u9898\u7684\u96be\u70b9\u5728\u4e8e\u600e\u4e48\u627e\u5230\u4e00\u6761\u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9\u7684\u8def\u5f84\uff0c\u6700\u540e\u627e\u5230\u7684\u8def\u5f84\u548c\u5c31\u662f\u6700\u7ec8\u7ed3\u679c\n        # \u56e0\u4e3a\u6211\u4eec\u8981\u627e\u5230\u4e00\u6761\u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9\u7684\u8def\u5f84\uff0c\u6240\u4ee5\u6211\u4eec\u4e00\u5b9a\u8981\u4ece\u6839\u8282\u70b9\u5f00\u59cb\u641c\u7d22\uff0c\u5982\u679c\u5728\u67d0\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u627e\u5230\u4e86\u4e00\u6761\u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9\u7684\u8def\u5f84\n        # \u90a3\u4e48\u8fd9\u4e2a\u8282"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    row_len = len(triangle)\n    dp = triangle[-1].copy()\n\n    for i in reversed(range(row_len - 1)):\n        for j in range(i + 1):\n            dp[j] = max(dp[j], dp[j + 1]) + triangle[i][j]\n\n    return dp[0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6]]) == 22"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    t1 = [[1], [2, 3], [4, 5, 6]]\n    assert s.maxPathSum(t1) == 12\n    t2 = [[-10], [2, 3], [4, 5, 6]]\n    assert s.maxPathSum(t2) == 14"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # \u9012\u5f52\u6cd5\n        # \u9012\u5f52\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u8bb0\u5f55\u6700\u5927\u7684\u4e24\u4e2a\u6570\n        # \u8fd9\u6837\u5c31\u53ef\u4ee5\u907f\u514d\u4e86\u8bb0\u5f55\u6574\u4e2a\u8def\u5f84\u7684\u95ee\u9898\u3002\n        # \u5982\u679c\u4e0d\u9012\u5f52\uff0c\u5219\u9700\u8981\u8bb0\u5f55\u6574\u4e2a\u8def\u5f84\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n        if not triangle or len(triangle) == 0:\n            return 0\n        return self.helper(triangle, 0, 0, float('-inf'))\n\n    def helper(self, triangle, i, path, max_path):\n        if i == len(triangle):\n            return max_path\n        path += triangle[i][i]\n        max_path = max(max_path, path)\n        if i == len(triangle) - 1:\n            return max_path\n        max_path = max(max_path, self.helper(triangle, i + 1, path, max_path))\n        max_path = max(max_path, self.helper(triangle, i + 1, path + triangle[i + 1][i], max_path))\n        return max_path"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef find_max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    def find_max_path_sum_recursively(row_index: int, col_index: int) -> int:\n        if row_index == len(triangle) - 1:\n            return triangle[row_index][col_index]\n\n        left = find_max_path_sum_recursively(row_index + 1, col_index)\n        right = find_max_path_sum_recursively(row_index + 1, col_index + 1)\n\n        return max(triangle[row_index][col_index], left, right) + triangle[row_index][col_index]\n\n    return find_max_path_sum_recursively(0, 0)\n\n\nif __name__ == \"__main__\":\n    assert find_max_path_sum([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]) == 23"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*n)\n    Space Complexity: O(n)\n    \"\"\"\n    max_path = triangle[-1]\n\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            max_path[j] = max(max_path[j], max_path[j + 1]) + triangle[i][j]\n\n    return max_path[0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]) == 40"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# O(n) time | O(n) space\ndef maximumTotal(self, triangle):\n    if not triangle:\n        return 0\n\n    # we have to keep track of the current row and the previous row\n    # we can do this by a list of 2 elements\n    # the first one is the previous row and the second one is the current row\n    # the first element of the current row is going to be the sum of the left child and the right child\n    # the other elements are going to be the max of the previous row and the sum of the current left child and the current right child\n\n    # we do this because we want to get the maximum sum of the previous row + the left child or the previous row + the right child\n    # we do this for each element of the current row, except the first one\n\n    # we can think of this as a recursive function\n    # the base case is when we have only one row, which means that we don't have to do any calculations\n    # we just return the last element of that row\n    # in this case, it's the maximum sum of the row\n\n    # the recursive case is when we have more than one row\n    # we just need to do the recursive call and check the max of the previous row and the current row\n    # we can do this by checking the maximum of the last element of the previous row and the sum of the last element of the current row and the last element of the current row\n\n    return self.maxPathSumHelper(triangle, 0, [float(\"-inf\"), float(\"-inf\")])\n\n\ndef maxPathSumHelper(self, triangle, row, cache):\n    if row >= len(triangle):\n        return float(\"-inf\")\n\n    if row == len(triangle) - 1:\n        return max(triangle[row])\n\n    if cache[row] != float(\"-inf\"):\n        return cache[row]\n\n    cache[row] = max(\n        self.maxPathSumHelper(triangle, row + 1, cache) + triangle[row][-1],\n        self.maxPathSumHelper(triangle, row + 1, cache) + triangle[row][-2],\n    )\n\n    return cache[row]"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        Dynamic Programming\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not triangle:\n            return 0\n\n        # dynamic programming\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                # find the max of two sides\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])\n        return max(triangle[-1])\n\n\nclass SolutionDFS:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        DFS\n        Time complexity: O(n)\n        Space complexity: O(n)\n        \"\"\"\n        if not triangle:\n            return 0\n\n        def dfs(i: int, j: int) -> int:\n            if i == len(triangle) - 1:\n                return triangle[i][j]\n\n            left = dfs(i + 1, j)\n            right = dfs(i + 1, j + 1)\n            return max(triangle[i][j] + left, triangle[i][j] + right)\n\n        return dfs(0, 0)\n\n\nif __name__ == \"__main__\":\n    # Test 1\n    triangle = [[7], [3, 4], [2, 4, 6], [1, 5, 8, 3]]\n    result = Solution().maxPathSum(triangle)\n    print(result)\n    # 23\n\n    # Test 2\n    triangle = [[5], [4, 5], [3, 4, 5], [2, 3, 4, 5]]\n    result ="
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    n = len(triangle)\n    if n == 1:\n        return triangle[0][0]\n\n    max_sum = triangle[0][0]\n\n    for row in range(1, n):\n        for col in range(row + 1):\n            if col == 0:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col])\n            elif col == row:\n                max_sum = max(max_sum, triangle[row][col] + triangle[row - 1][col - 1])\n            else:\n                max_sum = max(\n                    max_sum,\n                    triangle[row][col]\n                    + max(triangle[row - 1][col - 1], triangle[row - 1][col]),\n                )\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 55"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_total_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    def helper(i: int, j: int) -> int:\n        if i == len(triangle) - 1:\n            return triangle[i][j]\n        return max(\n            helper(i + 1, j),\n            helper(i + 1, j + 1),\n        ) + triangle[i][j]\n\n    return max(\n        helper(0, 0),\n        helper(0, 1),\n    )\n\n\nif __name__ == \"__main__\":\n    assert (\n        max_total_path_sum(\n            [\n                [2],\n                [3, 4],\n                [6, 5, 7],\n                [4, 1, 8, 3],\n            ],\n        )\n        == 23\n    )"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        if not triangle:\n            return 0\n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    out = 23\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)\n\n    triangle = [[-10]]\n    out = -10\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)\n\n    triangle = [[5], [6, 4], [2, 3, 2]]\n    out = 17\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(triangle) == 0:\n        return 0\n\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\ndef test_max_path_sum():\n    assert max_path_sum([\n        [2, 3, 4],\n        [5, 6, 7],\n        [4, 1, 1]\n    ]) == 19\n\n    assert max_path_sum([\n        [1]\n    ]) == 1\n\n    assert max_path_sum([\n        [1, 2],\n        [3, 4]\n    ]) == 5"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def max_path_sum(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # Runtime: 68 ms\n    # Memory: 13.4 MB\n    # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n\n    # Handle the base case\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    dp = [[0 for _ in range(len(triangle[-1]))] for _ in range(len(triangle))]\n    dp[-1] = triangle[-1]\n    for i in reversed(range(len(triangle) - 1)):\n        for j in range(len(triangle[i])):\n            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]\n    return max(dp[0])\n\n\ndef max_path_sum_2(triangle):\n    \"\"\"\n    :type triangle: List[List[int]]\n    :rtype: int\n    \"\"\"\n    # Runtime: 68 ms\n    # Memory: 13.4 MB\n    # dp[i] = max(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n\n    # Handle the base case\n    if len(triangle) == 1:\n        return triangle[0][0]\n\n    dp = [triangle[0][0]]\n    for i in range(1, len(triangle)):\n        dp.append(max(dp[-1] + triangle[i][0], dp[-1] + triangle[i][i]))\n        for j in range(1, i):\n            dp[i] = max(dp[i], dp[i - 1][j - 1] + triangle[i][j])\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3],"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n)\n\n    n = number of rows\n    m = number of columns in last row\n    \"\"\"\n\n    # find max path sum in last row\n    max_sum_last_row = [0] * len(triangle[-1])\n\n    for j in range(len(triangle[-1]) - 1, -1, -1):\n        if j == len(triangle[-1]) - 1:\n            max_sum_last_row[j] = triangle[-1][j]\n        else:\n            max_sum_last_row[j] = max(\n                max_sum_last_row[j + 1], max_sum_last_row[j] + triangle[-1][j]\n            )\n\n    # find max path sum in all rows except last row\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i]) - 1, -1, -1):\n            max_sum_last_row[j] = max(\n                max_sum_last_row[j + 1],\n                max_sum_last_row[j] + triangle[i][j],\n            )\n\n    return max_sum_last_row[0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6]]) == 23\n    assert max_path_sum([[5], [4, 0], [1, 1, 1], [1, 2, 3, 4]]) == 15"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def maxPathSum(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        res = [0 for _ in range(len(triangle))]\n        res[0] = triangle[0][0]\n        for i in range(1, len(triangle)):\n            res[i] = max(res[i-1], res[i-1] + triangle[i][i])\n            for j in range(i-1, 0, -1):\n                res[j] = max(res[j], res[j-1] + triangle[i][j])\n        return res[-1]\n\n\na = Solution()\nprint a.maxPathSum([[-10]]), 0\nprint a.maxPathSum([[-3]]), -3\nprint a.maxPathSum([[-10, -20, 30], [20, 10, -10], [\n                   -10, -10, -10], [-10, -10, -10]]), 20\nprint a.maxPathSum([[-10, -20, -30], [-20, -10, 30], [\n                   -30, -20, 20], [-30, -10, 10]]), 30"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        DP\n        Time complexity: O(n^2)\n        Space complexity: O(n)\n        \"\"\"\n        # Check for base case.\n        if not triangle:\n            return 0\n\n        # Initialize max_sum.\n        max_sum = triangle[0][0]\n\n        # Calculate path sum from bottom to top.\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(len(triangle[row])):\n                triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n\n        # Return maximum path sum.\n        return max(triangle[0])\n\n\nif __name__ == \"__main__\":\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    print(f\"Input: {triangle}\")\n    print(f\"Output: {Solution().maxPathSum(triangle)}\")"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxPathSum(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        Dynamic programming.\n        \"\"\"\n        if not triangle:\n            return 0\n\n        if len(triangle) == 1:\n            return triangle[0][0]\n\n        dp = [[0] * len(triangle) for _ in range(len(triangle))]\n        dp[0][0] = triangle[0][0]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + triangle[i][j]\n                elif j == i:\n                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]\n\n        return max(dp[-1])\n\n\nif __name__ == \"__main__\":\n    triangle = [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n    out = 53\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)\n\n    triangle = [[-10]]\n    out = -10\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)\n\n    triangle = [[1], [2, 3]]\n    out = 5\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)\n\n    triangle = [[1], [2, 3], [4, 5, 6]]\n    out = 12\n    res = Solution().maxPathSum(triangle)\n    assert res == out, (res, out)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    size = len(triangle)\n\n    if size == 0:\n        return 0\n\n    # dp[i][j] is the max path sum of triangle[i][j]\n    dp = [[0] * (i + 1) for i in range(size)]\n\n    # dp[0][j] = triangle[0][j]\n    for j in range(size):\n        dp[0][j] = triangle[0][j]\n\n    # dp[i][0] = dp[i-1][0] + triangle[i][0]\n    for i in range(1, size):\n        dp[i][0] = dp[i - 1][0] + triangle[i][0]\n\n    # dp[i][j] = max(dp[i][j-1], dp[i-1][j-1]) + triangle[i][j]\n    for i in range(1, size):\n        for j in range(1, i + 1):\n            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1]) + triangle[i][j]\n\n    return max(dp[-1])\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[3], [2, 4], [6, 5, 7], [4, 1, 8, 3]]) == 23"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_path_sum(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not triangle:\n        return 0\n\n    depth = len(triangle)\n\n    for i in range(depth - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    assert max_path_sum([[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]) == 40"
    }
  ]
}