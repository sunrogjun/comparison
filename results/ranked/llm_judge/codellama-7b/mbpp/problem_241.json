{
  "timestamp": "2025-09-15T00:07:29.097752",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 241,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def convert_to_polar(complex_number):\n    real = complex_number[0]\n    imaginary = complex_number[1]\n    radius = (real ** 2 + imaginary ** 2) ** 0.5\n    angle = (real / imaginary) * 180 / 3.14\n    return radius, angle\n\n\nprint(convert_to_polar((3, 4)))\nprint(convert_to_polar((-1, -1)))\nprint(convert_to_polar((2, 2)))\nprint(convert_to_polar((-2, -2)))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number):\n    \"\"\"\n    This function takes a complex number and returns its magnitude and angle\n    in polar coordinates.\n\n    >>> complex_to_polar(2 + 2j)\n    (2.8284271247461903, 0.7853981633974483)\n\n    >>> complex_to_polar(2 + 2j) == (math.sqrt(8), math.pi/4)\n    True\n\n    >>> complex_to_polar(1)\n    (1.0, 0.0)\n\n    >>> complex_to_polar(0)\n    (0.0, 0.0)\n    \"\"\"\n\n    return (math.sqrt(complex_number.real ** 2 + complex_number.imag ** 2),\n            math.atan2(complex_number.imag, complex_number.real))\n\n\ndef main():\n    complex_number = complex(input(\"Enter a complex number: \"))\n    print(complex_to_polar(complex_number))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def complex_to_polar(complex_num):\n    r = (complex_num.real ** 2 + complex_num.imag ** 2) ** 0.5\n    phi = (complex_num.imag / complex_num.real) * (complex_num.real > 0) + (complex_num.imag / complex_num.real) * (\n            complex_num.real < 0)\n    return r, phi\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(3, 4)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number: complex) -> tuple[float, float]:\n    \"\"\"\n    >>> complex_to_polar(3 + 5j)\n    (5.497787143782138, 0.7853981633974483)\n    >>> complex_to_polar(0 + 0j)\n    (0.0, 0.0)\n    >>> complex_to_polar(3 - 5j)\n    (5.497787143782138, 1.3634860768164192)\n    >>> complex_to_polar(1 + 0j)\n    (1.0, 0.0)\n    \"\"\"\n    magnitude = math.sqrt(complex_number.real ** 2 + complex_number.imag ** 2)\n    angle = math.atan2(complex_number.imag, complex_number.real)\n    return magnitude, angle\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import cmath\n\n\ndef convert_to_polar(complex_num: complex) -> tuple:\n    \"\"\"Convert a complex number to polar coordinates.\n\n    Args:\n        complex_num (complex): A complex number.\n\n    Returns:\n        tuple: A tuple of the real and imaginary components of the complex number.\n    \"\"\"\n    return cmath.polar(complex_num)\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(input())\n    real, imag = convert_to_polar(complex_num)\n    print(f\"{real} {imag}\")"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def convert_to_polar(complex_number):\n    \"\"\"\n    >>> convert_to_polar(3+5j)\n    (5.0, 1.3591804347826024)\n    >>> convert_to_polar(5-3j)\n    (5.0, 1.7320508075688772)\n    >>> convert_to_polar(-5+3j)\n    (-5.0, 1.7320508075688772)\n    >>> convert_to_polar(3-5j)\n    (3.0, 4.123105625617661)\n    \"\"\"\n    return (abs(complex_number), cmath.phase(complex_number))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def complex_polar(complex_num):\n    \"\"\"Returns the polar coordinates of a complex number.\n\n    Args:\n        complex_num (complex): A complex number\n\n    Returns:\n        (tuple): Returns a tuple containing the modulus and argument in that order.\n    \"\"\"\n    return abs(complex_num), (complex_num / abs(complex_num)).arg"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def complex_polar(x, y):\n    r = (x**2 + y**2)**(0.5)\n    theta = (y/x) * 180 / 3.14\n    return (r, theta)\n\n\nprint(complex_polar(1, 1))\nprint(complex_polar(1, -1))\nprint(complex_polar(0, 1))\nprint(complex_polar(2, 2))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "import math\n\n\ndef convert_to_polar(complex_num):\n    \"\"\"Convert complex number to polar coordinates.\n\n    Args:\n        complex_num (int): Complex number.\n\n    Returns:\n        tuple: Tuple of polar coordinates.\n    \"\"\"\n    return (abs(complex_num), math.atan2(complex_num.imag, complex_num.real))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def convert_to_polar(complex_number):\n    \"\"\"\n    >>> convert_to_polar(3+2j)\n    (3.1622776601683795, 0.4472135954999579)\n\n    >>> convert_to_polar(0)\n    (0.0, 0.0)\n\n    >>> convert_to_polar(0+1j)\n    (1.0, 1.5707963267948966)\n\n    >>> convert_to_polar(2-4j)\n    (5.0, 2.356194490192345)\n    \"\"\"\n    # return (abs(complex_number), math.atan(complex_number.imag/complex_number.real))\n    # Using the math library\n    return (abs(complex_number), math.atan(complex_number.imag / complex_number.real))\n    # Using the numpy library\n    # return (np.abs(complex_number), np.angle(complex_number))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def complex_to_polar(real, imaginary):\n    \"\"\"\n    >>> complex_to_polar(1, 2)\n    (3.605551275463989, 0.9827937232473298)\n    >>> complex_to_polar(2, 4)\n    (6.324555320336759, 0.9827937232473298)\n    >>> complex_to_polar(1, -2)\n    (3.605551275463989, 2.356194490192345)\n    >>> complex_to_polar(-1, -2)\n    (3.605551275463989, 3.141592653589793)\n    \"\"\"\n    radius = (real**2 + imaginary**2)**0.5\n    angle = (1j**0.5 * real + imaginary) / radius\n    return radius, angle\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def complex_to_polar(real, imaginary):\n    \"\"\"\n    >>> complex_to_polar(3, 4)\n    (5.0, 0.9272952180016122)\n    \"\"\"\n    magnitude = (real ** 2 + imaginary ** 2) ** 0.5\n    angle = 180 * (imaginary / magnitude + 1j).conjugate().imag / 3.14\n    return magnitude, angle\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number: str) -> tuple:\n    \"\"\"\n    >>> complex_to_polar(\"2+3j\")\n    (3.605551275463989, 0.321750555460571)\n    >>> complex_to_polar(\"10+20j\")\n    (24.737617266511004, 1.2630296298746552)\n    \"\"\"\n    real, imag = complex_number.strip(\"()\").split(\"+\")\n    real, imag = float(real), float(imag.strip(\"ij\"))\n    return math.sqrt(real ** 2 + imag ** 2), math.atan(imag / real)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "import cmath\n\n\ndef complex_to_polar(complex_num):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    :param complex_num: Complex numbers.\n    :return: Polar coordinates of complex numbers.\n    \"\"\"\n    return cmath.polar(complex_num)\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(1, 1)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_num):\n    \"\"\"\n    >>> complex_to_polar(3+5j)\n    (5.0, 1.3730755970386041)\n    >>> complex_to_polar(0)\n    (0.0, 0.0)\n    \"\"\"\n    return (\n        math.sqrt(complex_num.real ** 2 + complex_num.imag ** 2),\n        math.atan2(complex_num.imag, complex_num.real),\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def complex_to_polar(real, imaginary):\n    return ((real ** 2 + imaginary ** 2) ** 0.5, (real * imaginary * 1j))\n\n\nprint(complex_to_polar(5, 6))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "def convert_complex_to_polar(complex_number):\n    \"\"\"\n    >>> convert_complex_to_polar(complex(1, 1))\n    (1.4142135623730951, 0.7853981633974483)\n    >>> convert_complex_to_polar(complex(-1, 1))\n    (1.4142135623730951, 2.356194490192345)\n    \"\"\"\n    return (\n        (abs(complex_number)),\n        (cmath.phase(complex_number))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "def convert_to_polar(a: float, b: float) -> tuple:\n    \"\"\"\n    >>> convert_to_polar(1, 1)\n    (1.4142135623730951, 45.0)\n    >>> convert_to_polar(1, 1j)\n    (1.0, 90.0)\n    \"\"\"\n    return (abs(a + b * 1j), (180 / 3.14) * (b / (a + b * 1j).real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "from math import sqrt\n\n\ndef convert_to_polar(a_complex_number):\n    \"\"\"\n    >>> convert_to_polar(1+2j)\n    (2.2360679774997898, 1.1071487177940907)\n    \"\"\"\n    a, b = a_complex_number.real, a_complex_number.imag\n    return sqrt(a ** 2 + b ** 2), (a / sqrt(a ** 2 + b ** 2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "import math\n\n\ndef complex_to_polar(a: int, b: int) -> tuple:\n    \"\"\"\n    >>> complex_to_polar(3, 4)\n    (5.0, 0.9272952180016122)\n    >>> complex_to_polar(0, 0)\n    (0.0, 0.0)\n    >>> complex_to_polar(4, 0)\n    (4.0, 1.0)\n    \"\"\"\n    return (\n        math.sqrt(a ** 2 + b ** 2),\n        math.atan2(b, a)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def complex_to_polar(real, imaginary):\n    return [\n        ((real**2 + imaginary**2)**0.5),\n        (((real**2 + imaginary**2)**0.5) * (3.14/180))\n    ]\n\n\nprint(complex_to_polar(1, 1))"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "class Complex:\n    def __init__(self, real, imaginary):\n        self.real = real\n        self.imaginary = imaginary\n\n    def __add__(self, no):\n        return Complex(self.real + no.real, self.imaginary + no.imaginary)\n\n    def __sub__(self, no):\n        return Complex(self.real - no.real, self.imaginary - no.imaginary)\n\n    def __mul__(self, no):\n        return Complex(self.real * no.real - self.imaginary * no.imaginary,\n                       self.real * no.imaginary + self.imaginary * no.real)\n\n    def __truediv__(self, no):\n        return Complex((self.real * no.real + self.imaginary * no.imaginary) / (no.real ** 2 + no.imaginary ** 2),\n                       (self.imaginary * no.real - self.real * no.imaginary) / (no.real ** 2 + no.imaginary ** 2))\n\n    def mod(self):\n        return Complex((self.real ** 2 + self.imaginary ** 2) ** 0.5, 0)\n\n    def __str__(self):\n        if self.imaginary == 0:\n            result = \"%.2f+0.00i\" % self.real\n        elif self.real == 0:\n            if self.imaginary >= 0:\n                result = \"0.00+%.2fi\" % self.imaginary\n            else:\n                result = \"0.00-%.2fi\" % (abs(self.imaginary))\n        elif self.imaginary > 0:\n            result = \"%.2f+%.2fi\" % (self.real, self.imaginary)\n        else:\n            result = \"%.2f-%.2fi\" % (self.real, abs(self.imaginary))\n        return result\n\n\nif __name__ == '__main__':\n    c = map(float, input().split())\n    d"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "def complex_to_polar(complex_num):\n    \"\"\"\n    >>> complex_to_polar(2+3j)\n    (3.605551275463989, 0.4638352495867674)\n    >>> complex_to_polar(0)\n    (0.0, 0.0)\n    \"\"\"\n\n    import cmath\n    return cmath.polar(complex_num)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "import math\n\n\ndef convert_to_polar(complex_num):\n    a, b = complex_num.real, complex_num.imag\n    r = math.sqrt(a ** 2 + b ** 2)\n    theta = math.atan2(b, a)\n    return r, theta\n\n\ncomplex_number = complex(input())\npolar_coordinates = convert_to_polar(complex_number)\nprint(polar_coordinates[0], polar_coordinates[1])"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "def convert_to_polar(complex_number: str):\n    \"\"\"\n    >>> convert_to_polar('3+5i')\n    (5.0, 1.0471975511965976)\n    \"\"\"\n    real, imag = complex_number.strip().replace(\"i\", \"j\").split(\"+\")\n    real, imag = float(real), float(imag)\n    radius = complex(real, imag).__abs__()\n    angle = cmath.phase(complex(real, imag))\n    return radius, angle\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "def complex_to_polar(complex_number):\n    \"\"\"\n    >>> complex_to_polar(3+5j)\n    (5.0, 1.1071487177940904)\n    \"\"\"\n    real, imaginary = complex_number.real, complex_number.imag\n    magnitude = (real ** 2 + imaginary ** 2) ** 0.5\n    angle = (real / magnitude) if real else (imaginary / magnitude)\n    return magnitude, angle\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "def complex_to_polar(real, imag):\n    \"\"\"\n    >>> complex_to_polar(2, 2)\n    (2.8284271247461903, 1.1071487177940907)\n    >>> complex_to_polar(1, 2)\n    (2.2360679774997898, 1.1071487177940907)\n    >>> complex_to_polar(2, -2)\n    (2.8284271247461903, -1.1071487177940907)\n    >>> complex_to_polar(-2, -2)\n    (2.8284271247461903, 3.141592653589793)\n    \"\"\"\n    if real == 0 and imag == 0:\n        return 0.0, 0.0\n    elif real == 0 and imag != 0:\n        return 0.0, abs(imag)\n    elif real != 0 and imag == 0:\n        return abs(real), 0.0\n    else:\n        return abs(real ** 2 + imag ** 2) ** 0.5, (real / abs(real ** 2 + imag ** 2) ** 0.5) * (imag / abs(real ** 2 + imag ** 2) ** 0.5)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "def complex_to_polar(complex_number):\n    return complex_number.real, complex_number.imag, abs(complex_number), cmath.phase(complex_number)\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(2, -5)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "def complex_to_polar(a, b):\n    r = (a**2 + b**2)**0.5\n    theta = (a**2 + b**2)**0.5\n    return r, theta\n\n\nif __name__ == '__main__':\n    print(complex_to_polar(2, 2))"
    },
    {
      "rank": 30,
      "score": 9.0,
      "candidate": "def convert_to_polar(complex_num):\n    return [abs(complex_num),\n            (complex_num.real ** 2 + complex_num.imag ** 2) ** 0.5,\n            (complex_num.imag >= 0) * 180 - (complex_num.imag < 0) * 180]"
    },
    {
      "rank": 31,
      "score": 9.0,
      "candidate": "def complex_to_polar(complex_number):\n    x = complex_number.real\n    y = complex_number.imag\n    radius = (x**2 + y**2)**0.5\n    angle = (180/3.14)*(x/radius)\n    return radius, angle\n\n\nif __name__ == \"__main__\":\n    complex_number = complex(input(\"Enter a complex number: \"))\n    print(complex_to_polar(complex_number))"
    },
    {
      "rank": 32,
      "score": 9.0,
      "candidate": "import math\n\ndef complex_to_polar(a, b):\n    return (math.sqrt(a**2 + b**2), math.atan2(b, a))\n\nif __name__ == '__main__':\n    print(complex_to_polar(3, 4))"
    },
    {
      "rank": 33,
      "score": 9.0,
      "candidate": "def convert_polar(number):\n    \"\"\"Convert complex numbers to polar coordinates.\"\"\"\n    real = number.real\n    imaginary = number.imag\n    magnitude = (real ** 2 + imaginary ** 2) ** 0.5\n    phase = (180 / 3.14) * (imaginary / magnitude)\n    return magnitude, phase"
    },
    {
      "rank": 34,
      "score": 9.0,
      "candidate": "def complex_to_polar(complex_num):\n    \"\"\"\n    Takes a complex number and returns its magnitude and phase in a tuple.\n    \"\"\"\n    return (abs(complex_num), cmath.phase(complex_num))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(num):\n    return (math.sqrt(num.real**2 + num.imag**2), math.atan2(num.imag, num.real))\n\n\n#complex number\nnum = 3 + 5j\nprint(complex_to_polar(num))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "import cmath\n\ndef convert_to_polar(x, y):\n    \"\"\"\n    x: the real part of a complex number\n    y: the imaginary part of a complex number\n\n    returns: a list containing the result [r, phi]\n    \"\"\"\n    r = cmath.sqrt(x**2 + y**2)\n    phi = cmath.atan(y/x)\n    return [r, phi]\n\n\nprint(convert_to_polar(3, 5))\nprint(convert_to_polar(3, -5))\nprint(convert_to_polar(4.25, -2))\nprint(convert_to_polar(0, -4.25))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "import math\n\ndef toPolar(complexNumber):\n    return math.sqrt(complexNumber.real**2 + complexNumber.imag**2), math.atan2(complexNumber.imag, complexNumber.real)"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def complex_to_polar(a, b):\n    r = (a ** 2 + b ** 2) ** 0.5\n    theta = (a / r) if r else 0\n    return r, theta\n\n\nprint(complex_to_polar(1, 1))\nprint(complex_to_polar(2, 2))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return abs(complex_num), cmath.phase(complex_num)\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(input(\"Enter a complex number: \"))\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_number):\n    real_part = complex_number.real\n    imaginary_part = complex_number.imag\n    magnitude = math.sqrt(real_part ** 2 + imaginary_part ** 2)\n    angle = math.atan2(imaginary_part, real_part)\n    return magnitude, angle\n\n#complex_number = complex(1, 1)\n#print(complex_to_polar(complex_number))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_num):\n    return math.sqrt(complex_num.real ** 2 + complex_num.imag ** 2), math.atan2(complex_num.imag, complex_num.real)\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(3, 4)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    \"\"\"\n    :param complex_num: complex number\n    :return: polar coordinate of complex number\n    \"\"\"\n    return (abs(complex_num), cmath.phase(complex_num))\n\n\ncomplex_to_polar(complex(3, 4))\ncomplex_to_polar(complex(0, 0))\ncomplex_to_polar(complex(-3, -4))"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "def convert_to_polar(complex_number):\n    if type(complex_number) == complex:\n        magnitude = abs(complex_number)\n        angle = cmath.phase(complex_number)\n        return magnitude, angle\n    else:\n        return \"Not a complex number.\"\n\n\nprint(convert_to_polar(5))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_num):\n    \"\"\"Convert complex number to polar coordinates\"\"\"\n\n    real_part, imag_part = complex_num.real, complex_num.imag\n    magnitude = math.sqrt(real_part**2 + imag_part**2)\n\n    if real_part == 0 and imag_part == 0:\n        return 0, 0\n    elif real_part == 0 and imag_part != 0:\n        return 0, math.pi/2\n    elif real_part != 0 and imag_part == 0:\n        return 0, math.pi/2\n    elif real_part > 0 and imag_part > 0:\n        return magnitude, math.atan(imag_part/real_part)\n    elif real_part > 0 and imag_part < 0:\n        return magnitude, math.atan(imag_part/real_part) + math.pi\n    elif real_part < 0 and imag_part > 0:\n        return magnitude, math.atan(imag_part/real_part) + math.pi\n    elif real_part < 0 and imag_part < 0:\n        return magnitude, math.atan(imag_part/real_part)\n\nprint(complex_to_polar(complex(1, 1)))"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return (abs(complex_num), (3.14/2)*(complex_num.real/complex_num.imag))\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(1, 2)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(real, imaginary):\n    return (math.sqrt(real ** 2 + imaginary ** 2), math.atan2(imaginary, real))\n\n\ndef main():\n    real = float(input(\"Enter real number: \"))\n    imaginary = float(input(\"Enter imaginary number: \"))\n    print(complex_to_polar(real, imaginary))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "import math\n\n\ndef convert(a, b):\n    r = math.sqrt(a**2 + b**2)\n    theta = math.atan(a/b)\n    return r, theta\n\n\nif __name__ == \"__main__\":\n    a, b = 3, 2\n    r, theta = convert(a, b)\n    print(\"Converted number is : \", r, theta)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number):\n    x, y = complex_number\n    magnitude = math.sqrt(x ** 2 + y ** 2)\n    phase = math.atan2(y, x)\n    return magnitude, phase\n\n\ndef main():\n    complex_num = complex(input(\"Enter a complex number: \"))\n    magnitude, phase = complex_to_polar(complex_num)\n    print(f\"Polar form: r = {magnitude}, \u03b8 = {phase}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(a, b):\n    r = math.sqrt(a**2 + b**2)\n    theta = math.atan2(b, a)\n    return r, theta\n\na = float(input(\"Enter the real part of complex number: \"))\nb = float(input(\"Enter the imaginary part of complex number: \"))\n\nprint(complex_to_polar(a, b))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_number):\n    \"\"\"\n    Converts complex number to polar coordinates\n    \"\"\"\n    real_part = complex_number.real\n    imag_part = complex_number.imag\n    return (math.sqrt(real_part ** 2 + imag_part ** 2), math.atan(imag_part / real_part))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def complex_to_polar(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2), (x ** 2 + y ** 2) ** (1 / 2)\n\n\nprint(complex_to_polar(1, 2))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "class Complex:\n    def __init__(self, real=0, imag=0):\n        self.real = real\n        self.imag = imag\n\n    def __add__(self, other):\n        return Complex(self.real + other.real, self.imag + other.imag)\n\n    def __sub__(self, other):\n        return Complex(self.real - other.real, self.imag - other.imag)\n\n    def __mul__(self, other):\n        return Complex(\n            self.real * other.real - self.imag * other.imag,\n            self.imag * other.real + self.real * other.imag,\n        )\n\n    def __truediv__(self, other):\n        r = other.real ** 2 + other.imag ** 2\n        return Complex((self.real * other.real + self.imag * other.imag) / r,\n                       (self.imag * other.real - self.real * other.imag) / r)\n\n    def __eq__(self, other):\n        return self.real == other.real and self.imag == other.imag\n\n    def __repr__(self):\n        return f\"{self.real} + {self.imag}i\"\n\n    def mod(self):\n        return Complex(math.sqrt(self.real ** 2 + self.imag ** 2))\n\n    def arg(self):\n        return math.atan2(self.imag, self.real)\n\n\ndef complex_to_polar(complex_num):\n    return complex_num.mod(), complex_num.arg()\n\n\nif __name__ == \"__main__\":\n    print(complex_to_polar(Complex(1, 2)))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_number):\n    return (abs(complex_number), (abs(complex_number)) * (complex_number.real / abs(complex_number)))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "import cmath\n\ndef complex_to_polar(complex_number):\n    return abs(complex_number), cmath.phase(complex_number)\n\ndef main():\n    complex_number = complex(1, 1)\n    print(\"Complex Number: {}\\nPolar Coordinates: {}\".format(complex_number, complex_to_polar(complex_number)))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_num):\n    return (abs(complex_num), math.atan2(complex_num.imag, complex_num.real))\n\n\nif __name__ == \"__main__\":\n    print(complex_to_polar(complex(1, 2)))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return (abs(complex_num), cmath.phase(complex_num))\n\n\nif __name__ == \"__main__\":\n    complex_num = 2 + 3j\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "import math\n\n\ndef convert_polar(complex_number):\n    \"\"\"\n    convert_polar function\n    :param complex_number: int\n    :return: float\n    \"\"\"\n    return math.sqrt(complex_number.real ** 2 + complex_number.imag ** 2)\n\n\ndef convert_polar_complex(complex_number):\n    \"\"\"\n    convert_polar_complex function\n    :param complex_number: int\n    :return: float\n    \"\"\"\n    return math.atan(complex_number.imag / complex_number.real)"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "import cmath\n\n\ndef complex_to_polar(complex_num):\n    return abs(complex_num), cmath.phase(complex_num)\n\n\ndef main():\n    complex_num = complex(1, 2)\n    print(complex_num)\n    print(complex_to_polar(complex_num))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "import cmath\n\n\ndef convert_polar(complex_num):\n    \"\"\"Convert complex numbers to polar coordinates.\"\"\"\n    return cmath.polar(complex_num)\n\n\ndef main():\n    \"\"\"Print the complex numbers and their polar coordinates.\"\"\"\n    complex_num = complex(input(\"Enter a complex number: \"))\n    print(convert_polar(complex_num))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_num):\n    return (abs(complex_num), math.atan2(complex_num.imag, complex_num.real))\n\ndef main():\n    complex_num = complex(input(\"Enter a complex number: \"))\n    print(complex_to_polar(complex_num))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "import math\n\ndef convert(num):\n    return [math.sqrt(num[0]**2+num[1]**2), math.atan2(num[1],num[0])]\n\nnum = [2, 3]\n\nprint(convert(num))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number):\n    \"\"\"\n    Function to convert complex numbers to polar coordinates\n    \"\"\"\n    return abs(complex_number), math.atan2(complex_number.imag, complex_number.real)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(a, b):\n    return math.sqrt(a ** 2 + b ** 2), math.atan2(b, a)\n\na, b = 1 + 2j, 3 - 4j\nprint(complex_to_polar(a.real, a.imag))\nprint(complex_to_polar(b.real, b.imag))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return (abs(complex_num), (complex_num.real * complex_num.imag) * (-1))\n\n\ncomplex_num = complex(input(\"Enter the real part: \"), input(\"Enter the imaginary part: \"))\nprint(\"Complex number: \", complex_num)\nprint(\"Polar number: \", complex_to_polar(complex_num))"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def complex_to_polar(real_part, imag_part):\n    return (abs(complex(real_part, imag_part)), math.atan2(imag_part, real_part))\n\nprint(complex_to_polar(5, 3))"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_number):\n    \"\"\"\n    :param complex_number: (int,int)\n    :return: polar_coordinates: (float, float)\n    \"\"\"\n    return float(abs(complex_number[0] + complex_number[1] * 1j)), float(cmath.phase(complex_number[0] + complex_number[1] * 1j))\n\n\nif __name__ == \"__main__\":\n    complex_number = (2, -1)\n    print(\"Complex Number is: \", complex_number)\n    polar_coordinates = complex_to_polar(complex_number)\n    print(\"Polar Coordinates are: \", polar_coordinates)"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "def complex_polar(complex_num):\n    return complex(abs(complex_num), cmath.phase(complex_num))\n\nprint(complex_polar(complex(3, 4)))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(real, imag):\n    return [\n        math.sqrt(real*real + imag*imag),\n        math.atan2(imag, real)\n    ]\n\n\nprint(complex_to_polar(3, 1))\nprint(complex_to_polar(1, -2))"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_number):\n    real_part = complex_number.real\n    imag_part = complex_number.imag\n    return (math.sqrt(real_part**2 + imag_part**2), math.atan2(imag_part, real_part))\n\nif __name__ == \"__main__\":\n    complex_number = complex(1, -1)\n    print(complex_number)\n    print(complex_to_polar(complex_number))"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    a, b = complex_num.real, complex_num.imag\n    return (\n        (abs(complex_num), (a * 1j) + (b * 1j)),\n        (abs(complex_num), a, b),\n    )\n\n\nprint(complex_to_polar(complex(1, 2)))"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "import math\n\n\ndef polar_coordinates(real, imag):\n    radius = math.sqrt(real**2 + imag**2)\n    angle = math.atan(imag/real)\n    return radius, angle\n\n\ndef main():\n    print(polar_coordinates(1, 1))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def convert_to_polar(real, imag):\n    radius = (real ** 2 + imag ** 2) ** 0.5\n    if imag < 0:\n        angle = 2 * (real * 0.5 + imag * 0.5)\n    else:\n        angle = real * 0.5 + imag * 0.5\n    return radius, angle\n\n\ndef main():\n    real = float(input(\"Enter real number: \"))\n    imag = float(input(\"Enter imaginary number: \"))\n    radius, angle = convert_to_polar(real, imag)\n    print(\"Radius: \", radius)\n    print(\"Angle: \", angle)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    r = complex_num.real\n    i = complex_num.imag\n    return (abs(complex_num), (abs(complex_num) ** 2 + i ** 2) ** 0.5)\n\n\nif __name__ == \"__main__\":\n    print(complex_to_polar(complex(2, -1)))"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "def complex_to_polar(a, b):\n    return (abs(a+b*1j), cmath.phase(a+b*1j))\n\n\nif __name__ == \"__main__\":\n    a = float(input(\"Enter the value of a: \"))\n    b = float(input(\"Enter the value of b: \"))\n    print(complex_to_polar(a, b))"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_num):\n    \"\"\"\n    Takes a complex number and converts it to polar coordinates.\n    \"\"\"\n    return math.sqrt(complex_num.real**2 + complex_num.imag**2), math.atan2(complex_num.imag, complex_num.real)"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "import math\n\ndef complex_to_polar(complex_num):\n    \"\"\"\n    >>> complex_to_polar(1+2j)\n    (2.23606797749979, 1.1071487177940904)\n    >>> complex_to_polar(0)\n    (0.0, 0.0)\n    \"\"\"\n    magnitude = math.sqrt(complex_num.real ** 2 + complex_num.imag ** 2)\n    angle = math.atan2(complex_num.imag, complex_num.real)\n    return magnitude, angle\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return (abs(complex_num), cmath.phase(complex_num))\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(1, 1)\n    print(complex_to_polar(complex_num))"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_number):\n    return (abs(complex_number), cmath.phase(complex_number))\n\n\nprint(complex_to_polar(complex(1, 2)))"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "def to_polar(c):\n    \"\"\"\n    Takes a complex number as input and returns the polar coordinate form.\n    \"\"\"\n    return abs(c), c.real * c.real + c.imag * c.imag\n\n\nif __name__ == \"__main__\":\n    c = complex(input())\n    print(to_polar(c))"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "import math\n\n\ndef convert(a, b):\n    r = math.sqrt(a**2 + b**2)\n    theta = math.atan2(b, a)\n    return r, theta\n\n\na = int(input(\"Enter a: \"))\nb = int(input(\"Enter b: \"))\nprint(convert(a, b))"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(num):\n    return (abs(num), math.atan2(num.imag, num.real))\n\n\n# Tests\nassert complex_to_polar(complex(-4 + 3j)) == (5, math.atan2(-3, -4))"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "import math\n\ndef convert_complex_to_polar(a, b):\n    r = math.sqrt(a**2 + b**2)\n    theta = math.atan2(b, a)\n    return r, theta\n\na = int(input(\"Enter real part of complex number: \"))\nb = int(input(\"Enter imaginary part of complex number: \"))\nprint(f\"Complex number is {a}+{b}i\")\nprint(f\"Polar Coordinates are {convert_complex_to_polar(a, b)}\")"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    x, y = complex_num.real, complex_num.imag\n    return ((x**2 + y**2) ** 0.5, (180 / 3.14) * (x / (x**2 + y**2)**0.5))\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(input())\n    polar_num = complex_to_polar(complex_num)\n    print(polar_num[0], polar_num[1], end='')"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "from math import atan2, sqrt\n\n\ndef complex_to_polar(real_part, imaginary_part):\n    magnitude = sqrt(real_part ** 2 + imaginary_part ** 2)\n    phase = atan2(imaginary_part, real_part)\n    return magnitude, phase\n\n\nif __name__ == \"__main__\":\n    real_part = float(input(\"Enter the real part: \"))\n    imaginary_part = float(input(\"Enter the imaginary part: \"))\n    magnitude, phase = complex_to_polar(real_part, imaginary_part)\n    print(f\"The polar coordinates of {real_part} + {imaginary_part}i are:\")\n    print(f\"Magnitude: {magnitude:.2f}\")\n    print(f\"Phase: {phase:.2f}\")"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "import math\n\ndef convert_complex_to_polar(complex_number):\n    \"\"\"\n    Converts a complex number to polar coordinates.\n\n    Args:\n        complex_number (complex): A complex number\n\n    Returns:\n        A tuple of the polar coordinates.\n    \"\"\"\n    real = complex_number.real\n    imag = complex_number.imag\n    magnitude = math.sqrt(real ** 2 + imag ** 2)\n    angle = math.atan2(imag, real)\n\n    return magnitude, angle"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "class ComplexNumber:\n    def __init__(self, real, imaginary):\n        self.real = real\n        self.imaginary = imaginary\n\n    def __add__(self, no):\n        real = self.real + no.real\n        imaginary = self.imaginary + no.imaginary\n        return ComplexNumber(real, imaginary)\n\n    def __sub__(self, no):\n        real = self.real - no.real\n        imaginary = self.imaginary - no.imaginary\n        return ComplexNumber(real, imaginary)\n\n    def __mul__(self, no):\n        real = self.real * no.real - self.imaginary * no.imaginary\n        imaginary = self.real * no.imaginary + self.imaginary * no.real\n        return ComplexNumber(real, imaginary)\n\n    def __truediv__(self, no):\n        real = (self.real * no.real + self.imaginary * no.imaginary) / (\n            no.real ** 2 + no.imaginary ** 2\n        )\n        imaginary = (self.imaginary * no.real - self.real * no.imaginary) / (\n            no.real ** 2 + no.imaginary ** 2\n        )\n        return ComplexNumber(real, imaginary)\n\n    def mod(self):\n        \"\"\"\n        Returns the magnitude of the complex number\n        \"\"\"\n        return (self.real ** 2 + self.imaginary ** 2) ** 0.5\n\n    def __str__(self):\n        if self.imaginary == 0:\n            result = \"%.2f+0.00i\" % (self.real)\n        elif self.real == 0:\n            if self.imaginary >= 0:\n                result = \"0.00+%.2fi\" % (self.imaginary)\n            else:\n                result = \"0.00-%.2fi\" % (abs(self.imaginary))\n        elif self.imaginary > 0:\n            result = \"%.2f+%.2fi\" % (self"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "def convert(num):\n    return (num.real ** 2 + num.imag ** 2) ** (1 / 2), (num.real ** 2 + num.imag ** 2) ** (1 / 2)\n\n\nif __name__ == \"__main__\":\n    complex_number = complex(input())\n    print(convert(complex_number))"
    },
    {
      "rank": 88,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    \"\"\"\n    Takes a complex number and returns its magnitude and phase.\n\n    :param complex_num: complex number\n    :type complex_num: complex\n    :return: magnitude and phase of complex number\n    :rtype: tuple\n    \"\"\"\n    return (abs(complex_num), cmath.phase(complex_num))\n\n\ndef main():\n    \"\"\"\n    Print out complex numbers and their corresponding polar coordinates.\n    \"\"\"\n    complex_nums = [complex(-1, -1), complex(0, 0), complex(1, 1)]\n    for num in complex_nums:\n        print(\"Complex number:\", num)\n        print(\"Polar coordinates:\", complex_to_polar(num))\n        print()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 89,
      "score": 8.0,
      "candidate": "import cmath\n\n\ndef complex_to_polar(complex_num):\n    return cmath.polar(complex_num)\n\n\ncomplex_num = complex(input(\"Enter a complex number: \"))\nprint(complex_num)\nprint(\"Complex to polar coordinates:\", complex_to_polar(complex_num))"
    },
    {
      "rank": 90,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(complex_number):\n    return (math.sqrt(complex_number.real ** 2 + complex_number.imag ** 2), math.atan(complex_number.imag / complex_number.real))\n\n\nif __name__ == '__main__':\n    complex_number = complex(1, 1)\n    print(complex_to_polar(complex_number))"
    },
    {
      "rank": 91,
      "score": 8.0,
      "candidate": "from math import sqrt\n\n\ndef convert_to_polar(a, b):\n    r = sqrt(a ** 2 + b ** 2)\n    theta = abs(b) / r\n    return r, theta\n\n\na = float(input(\"Enter first number: \"))\nb = float(input(\"Enter second number: \"))\nprint(convert_to_polar(a, b))"
    },
    {
      "rank": 92,
      "score": 8.0,
      "candidate": "def complex_to_polar(complex_num):\n    return [abs(complex_num), cmath.phase(complex_num)]\n\ncomplex_num = input(\"Enter a complex number: \")\ncomplex_num = complex(complex_num)\n\nprint(complex_to_polar(complex_num))"
    },
    {
      "rank": 93,
      "score": 8.0,
      "candidate": "import math\n\ndef convert_complex_to_polar(a, b):\n    r = math.sqrt(a**2 + b**2)\n    theta = math.atan(a/b)\n    return r, theta\n\na, b = map(int, input().split())\nprint(convert_complex_to_polar(a, b))"
    },
    {
      "rank": 94,
      "score": 8.0,
      "candidate": "import math\n\n\ndef complex_to_polar(num):\n    return (math.sqrt(num.real ** 2 + num.imag ** 2), math.atan2(num.imag, num.real))\n\n\nif __name__ == \"__main__\":\n    complex_num = complex(input())\n    print(*complex_to_polar(complex_num))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "class ComplexNumber:\n    \"\"\"Represents a complex number.\n\n    Attributes:\n        real (float): The real part of the complex number.\n        imaginary (float): The imaginary part of the complex number.\n    \"\"\"\n\n    def __init__(self, real, imaginary):\n        self.real = real\n        self.imaginary = imaginary\n\n    def __repr__(self):\n        return f\"{self.real} + {self.imaginary}i\"\n\n    def __add__(self, other):\n        return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary)\n\n    def __sub__(self, other):\n        return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary)\n\n    def __mul__(self, other):\n        return ComplexNumber(\n            self.real * other.real - self.imaginary * other.imaginary,\n            self.imaginary * other.real + self.real * other.imaginary,\n        )\n\n    def __truediv__(self, other):\n        if other.real == 0 and other.imaginary == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        return ComplexNumber(\n            (self.real * other.real + self.imaginary * other.imaginary)\n            / (other.real ** 2 + other.imaginary ** 2),\n            (self.imaginary * other.real - self.real * other.imaginary)\n            / (other.real ** 2 + other.imaginary ** 2),\n        )\n\n    def __abs__(self):\n        return (self.real ** 2 + self.imaginary ** 2) ** 0.5\n\n    def conjugate(self):\n        return ComplexNumber(self.real, -self.imaginary)\n\n    def to_polar(self):\n        return abs(self), math.atan2(self.imaginary, self.real)\n\n\ndef main():\n    complex_number = ComplexNumber(1, 2)\n    print(complex"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def complex_polar(complex_number: int) -> list:\n    \"\"\"\n    Write a python function to convert complex numbers to polar coordinates.\n    :param complex_number: int.\n    :return: list.\n    >>> complex_polar(1+2j)\n    [3.605551275463989, 0.447213595499958]\n    >>> complex_polar(0+0j)\n    [0.0, 0.0]\n    >>> complex_polar(-2-3j)\n    [4.123105625617661, 1.3250157799831047]\n    >>> complex_polar(-4-0j)\n    [4.0, 0.0]\n    >>> complex_polar(-4+0j)\n    [4.0, 1.5707963267948966]\n    \"\"\"\n    return [abs(complex_number), (math.atan2(complex_number.imag, complex_number.real))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def complex_to_polar(complex_number):\n    return [abs(complex_number), math.atan2(complex_number.imag, complex_number.real)]\n\n\n\"\"\"\nWrite a python function to find the maximum and minimum number in a list of\nnumbers.\n\"\"\"\n\n\ndef find_max_min(numbers):\n    return [max(numbers), min(numbers)]\n\n\n\"\"\"\nWrite a python function to find the sum of the digits of a given input number.\n\"\"\"\n\n\ndef sum_of_digits(number):\n    return sum([int(n) for n in str(number)])\n\n\n\"\"\"\nWrite a python function to find the digits of a given number which are divisible\nby 3.\n\"\"\"\n\n\ndef divisible_by_3(number):\n    return [int(n) for n in str(number) if int(n) % 3 == 0]\n\n\n\"\"\"\nWrite a python function to find the digits of a given number which are divisible\nby 3 or 5.\n\"\"\"\n\n\ndef divisible_by_3_5(number):\n    return [int(n) for n in str(number) if int(n) % 3 == 0 or int(n) % 5 == 0]\n\n\n\"\"\"\nWrite a python function to find the digits of a given number which are divisible\nby 3 or 5.\n\"\"\"\n\n\ndef divisible_by_3_5_7(number):\n    return [int(n) for n in str(number) if int(n) % 3 == 0 or int(n) % 5 == 0 or int(n) % 7 == 0]\n\n\n\"\"\"\nWrite a python function to find the digits of a given number which are divisible\nby 3 or 5.\n\"\"\"\n\n\ndef divisible_by_3_5_7_9(number):\n    return [int(n) for n in str(number) if int(n) % 3 == 0 or int(n) % 5 == 0 or int(n) % 7 == 0 or int(n) % 9"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "def complex_to_polar(a: int, b: int) -> tuple:\n    \"\"\"\n    :param a: int\n    :param b: int\n    :return: tuple\n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0, 0\n        if b > 0:\n            return 0, abs(b)\n        return 0, -abs(b)\n    if a > 0:\n        if b == 0:\n            return abs(a), 0\n        return abs(a) * (180 / 3.14159), abs(b) * (180 / 3.14159)\n    if a < 0:\n        if b == 0:\n            return abs(a), 0\n        return abs(a) * (180 / 3.14159), abs(b) * (180 / 3.14159) + 180\n\n\nif __name__ == \"__main__\":\n    print(complex_to_polar(1, 1))"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def convert_to_polar(complex_number):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Args:\n        complex_number (str): Complex number to be converted to polar coordinates.\n\n    Returns:\n        polar_coordinates (str): Complex number converted to polar coordinates.\n    \"\"\"\n\n    real_number, imaginary_number = complex_number.split('+')\n    real_number, imaginary_number = float(real_number), float(imaginary_number.split('j')[0])\n\n    return str(abs(complex(complex_number))) + ' * (cos(' + str(imaginary_number) + ') + j * sin(' + str(imaginary_number) + '))'\n\n\nprint(convert_to_polar('1+5j'))\nprint(convert_to_polar('-1+5j'))\nprint(convert_to_polar('-1+0j'))\nprint(convert_to_polar('0+5j'))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "import math\ndef complex_to_polar(complex_num):\n    r = abs(complex_num)\n    arg = math.atan2(complex_num.imag, complex_num.real)\n    return r, arg\n\n\"\"\"\nWrite a python function to find the square root of a number.\n\"\"\"\ndef sqrt(num):\n    if num >= 0:\n        return math.sqrt(num)\n    else:\n        return 0 - math.sqrt(abs(num))\n\n\"\"\"\nWrite a python function to find the sum of the first N natural numbers.\n\"\"\"\ndef sum_of_n_numbers(n):\n    return (n * (n + 1)) / 2\n\n\"\"\"\nWrite a python function to find the sum of the first N even numbers.\n\"\"\"\ndef sum_of_n_even_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N odd numbers.\n\"\"\"\ndef sum_of_n_odd_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N positive numbers.\n\"\"\"\ndef sum_of_n_positive_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N negative numbers.\n\"\"\"\ndef sum_of_n_negative_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N floating numbers.\n\"\"\"\ndef sum_of_n_floating_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N integer numbers.\n\"\"\"\ndef sum_of_n_integer_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a python function to find the sum of the first N string numbers.\n\"\"\"\ndef sum_of_n_string_numbers(n):\n    return n * (n + 1)\n\n\"\"\"\nWrite a"
    }
  ]
}