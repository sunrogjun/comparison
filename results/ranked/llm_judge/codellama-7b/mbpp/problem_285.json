{
  "timestamp": "2025-09-15T00:27:25.753625",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 285,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def count_inversions(arr):\n    return merge_sort(arr, 0, len(arr) - 1)\n\n\ndef merge(arr, left_idx, mid_idx, right_idx):\n    left_arr = arr[left_idx:mid_idx + 1]\n    right_arr = arr[mid_idx + 1:right_idx + 1]\n    left_idx = 0\n    right_idx = 0\n    inversion_count = 0\n    for idx in range(left_idx, right_idx + mid_idx + 1):\n        if left_idx >= len(left_arr) or right_idx >= len(right_arr):\n            break\n\n        if left_arr[left_idx] <= right_arr[right_idx]:\n            arr[idx] = left_arr[left_idx]\n            left_idx += 1\n        else:\n            arr[idx] = right_arr[right_idx]\n            right_idx += 1\n            inversion_count += len(left_arr[left_idx:])\n    return inversion_count\n\n\ndef merge_sort(arr, left_idx, right_idx):\n    inversion_count = 0\n    if left_idx >= right_idx:\n        return 0\n\n    mid_idx = (left_idx + right_idx) // 2\n    inversion_count += merge_sort(arr, left_idx, mid_idx)\n    inversion_count += merge_sort(arr, mid_idx + 1, right_idx)\n    inversion_count += merge(arr, left_idx, mid_idx, right_idx)\n    return inversion_count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    print(count_inversions(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef count_inversions(arr):\n    \"\"\"\n    Time complexity: O(n*log(n))\n    Space complexity: O(n)\n    \"\"\"\n\n    # sort the array and count the number of swaps to sort\n    return _count_inversions(arr, 0, len(arr) - 1)\n\n\ndef _count_inversions(arr, left, right):\n    if left >= right:\n        return 0\n\n    middle = (left + right) // 2\n\n    count_left = _count_inversions(arr, left, middle)\n    count_right = _count_inversions(arr, middle + 1, right)\n\n    count = count_left + count_right\n\n    # Merge the sorted halves\n    i = left\n    j = middle + 1\n    temp = []\n    for _ in range(right - left + 1):\n        if i > middle:\n            temp.append(arr[j])\n            j += 1\n        elif j > right:\n            temp.append(arr[i])\n            i += 1\n        elif arr[i] <= arr[j]:\n            temp.append(arr[i])\n            i += 1\n        else:\n            temp.append(arr[j])\n            count += (middle - i + 1)\n            j += 1\n\n    for index in range(left, right + 1):\n        arr[index] = temp[index - left]\n\n    return count\n\n\ndef count_inversions_using_hash(arr):\n    \"\"\"\n    Time complexity: O(n*log(n))\n    Space complexity: O(n)\n    \"\"\"\n    count = 0\n    counter = defaultdict(int)\n    for index, num in enumerate(arr):\n        counter[num] += 1\n\n    for index, num in enumerate(arr):\n        count += (index - counter[num])\n\n    return count\n\n\ndef main():\n\n    arr1 = [2, 5, 1, 3, 4]\n    arr2 = [54, 99, 76, 65, 4"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"\n    Merge two sorted arrays and count the inversions\n    :param left:\n    :param right:\n    :return:\n    \"\"\"\n    count = 0\n    merged = []\n    left_index, right_index = 0, 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n            count += len(left) - left_index\n    merged += left[left_index:]\n    merged += right[right_index:]\n    return merged, count\n\n\ndef merge_sort(arr):\n    \"\"\"\n    Sort the array and count the inversions\n    :param arr:\n    :return:\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return arr, 0\n    mid = n // 2\n    left, left_inv_count = merge_sort(arr[:mid])\n    right, right_inv_count = merge_sort(arr[mid:])\n    merged, count = merge_and_count(left, right)\n    return merged, left_inv_count + right_inv_count + count\n\n\ndef count_inversions(arr):\n    merged, count = merge_sort(arr)\n    return count\n\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 2, 3, 5, 4, 6, 7, 9, 8]))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from random import randint\n\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef count_inversion(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\n\ndef count_inversion_efficient(arr):\n    n = len(arr)\n    inversions = 0\n    merge_sort(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            inversions += 1\n    return inversions\n\n\ndef main():\n    arr = [randint(0, 10) for _ in range(10)]\n    print(arr)\n    assert count_inversion(arr) == count_inversion_efficient(arr)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    i, j = 0, 0\n    inversions = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\n\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    else:\n        mid = len(arr) // 2\n        left, left_count = merge_sort_and_count(arr[:mid])\n        right, right_count = merge_sort_and_count(arr[mid:])\n        return merge_and_count(left, right), left_count + right_count\n\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr)[1]\n\n\ndef test_count_inversions():\n    \"\"\"\n    >>> count_inversions([2, 4, 1, 3, 5])\n    3\n    >>> count_inversions([1, 2, 3, 4, 5])\n    0\n    >>> count_inversions([5, 4, 3, 2, 1])\n    10\n    >>> count_inversions([1, 2, 7, 6, 5, 4, 3])\n    10\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def merge_and_count(arr, temp, left, middle, right):\n    i = left\n    j = middle + 1\n    k = left\n    count = 0\n\n    while i <= middle and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n            count += (middle - i + 1)\n            k += 1\n\n    while i <= middle:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n\n    return count\n\n\ndef merge_sort_and_count(arr, temp, left, right):\n    inv_count = 0\n    if right > left:\n        middle = (left + right) // 2\n        inv_count = merge_sort_and_count(arr, temp, left, middle)\n        inv_count += merge_sort_and_count(arr, temp, middle + 1, right)\n        inv_count += merge_and_count(arr, temp, left, middle, right)\n    return inv_count\n\n\ndef count_inversions(arr):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    temp = [0] * n\n    return merge_sort_and_count(arr, temp, 0, n - 1)\n\n\ndef main():\n    arr = [2, 4, 1, 3, 5]\n    ans = count_inversions(arr)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def merge_sort(array, temp, left, right):\n    if right - left <= 1:\n        return 0\n\n    count = 0\n    middle = (left + right) // 2\n\n    count += merge_sort(array, temp, left, middle)\n    count += merge_sort(array, temp, middle, right)\n\n    count += merge(array, temp, left, middle, right)\n\n    return count\n\n\ndef merge(array, temp, left, middle, right):\n    count = 0\n    i = left\n    j = middle\n    k = left\n\n    while i < middle and j < right:\n        if array[i] < array[j]:\n            temp[k] = array[i]\n            k += 1\n            i += 1\n        else:\n            temp[k] = array[j]\n            count += (middle - i)\n            k += 1\n            j += 1\n\n    while i < middle:\n        temp[k] = array[i]\n        k += 1\n        i += 1\n\n    while j < right:\n        temp[k] = array[j]\n        k += 1\n        j += 1\n\n    for i in range(left, right):\n        array[i] = temp[i]\n\n    return count\n\n\ndef count_inversions(array):\n    temp = [0] * len(array)\n\n    return merge_sort(array, temp, 0, len(array))\n\n\ndef main():\n    array = [2, 1, 5, 3, 4]\n    assert count_inversions(array) == 3\n\n    array = [54, 99, 49, 22, 37, 18, 22, 90, 86, 33]\n    assert count_inversions(array) == 26\n\n    array = [1, 2, 5, 3, 4, 6, 7]\n    assert count_inversions(array) == 3\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    inversions = 0\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_inv = merge_sort_and_count(arr[:mid])\n    right, right_inv = merge_sort_and_count(arr[mid:])\n    return merge_and_count(left, right)\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr)[1]\n\nprint(count_inversions([1, 2, 5, 3, 4, 7, 6, 10, 9, 8]))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inversion += len(left) - i\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef count_inversions(arr):\n    inversion = 0\n    merge_sort(arr)\n    return inversion\n\n\narr = [1, 20, 6, 4, 5]\nprint(\"Merge sort:\", count_inversions(arr))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count the number of inversions in the given array.\n\n    An inversion in an array is defined as an element a[i] which comes after\n    another element a[j] in the array such that i < j.\n\n    Time complexity: O(nlogn)\n    Space complexity: O(n)\n    \"\"\"\n\n    return _merge_sort(arr)[1]\n\n\ndef _merge_sort(arr):\n    \"\"\"\n    Merge sort the given array and return the number of inversions\n    and sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return (0, arr)\n\n    mid = len(arr) // 2\n    left_inversion, left = _merge_sort(arr[:mid])\n    right_inversion, right = _merge_sort(arr[mid:])\n    inversion, arr = _merge(left, right)\n\n    return (left_inversion + right_inversion + inversion, arr)\n\n\ndef _merge(left, right):\n    \"\"\"\n    Merge the sorted left and right arrays and return the number of inversions\n    and the sorted array.\n    \"\"\"\n    left_len = len(left)\n    right_len = len(right)\n\n    i = 0\n    j = 0\n    inversion = 0\n    arr = []\n\n    while i < left_len and j < right_len:\n        if left[i] <= right[j]:\n            arr.append(left[i])\n            i += 1\n        else:\n            arr.append(right[j])\n            j += 1\n            inversion += left_len - i\n\n    if i < left_len:\n        arr.extend(left[i:])\n    elif j < right_len:\n        arr.extend(right[j:])\n\n    return inversion, arr\n\n\nprint(count_inversions([1, 2, 5, 3, 4, 6, 7]))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    i,j = 0,0\n    count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i+=1\n        else:\n            result.append(right[j])\n            j+=1\n            count += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return (result, count)\n\n\ndef merge_sort_and_count(a):\n    if len(a) <= 1:\n        return (a, 0)\n    mid = len(a)//2\n    left, left_count = merge_sort_and_count(a[:mid])\n    right, right_count = merge_sort_and_count(a[mid:])\n    return merge_and_count(left, right)\n\n\ndef count_inversions(a):\n    _, count = merge_sort_and_count(a)\n    return count\n\n\nprint(count_inversions([1, 2, 5, 3, 4, 7, 6]))\nprint(count_inversions([2, 5, 1, 3, 4]))\nprint(count_inversions([1, 3, 5, 2, 4, 6, 7]))\nprint(count_inversions([5, 3, 1, 4, 2]))\nprint(count_inversions([3, 1, 2, 5, 4, 6]))\nprint(count_inversions([6, 5, 4, 3, 2, 1]))\nprint(count_inversions([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))\nprint(count_inversions([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 11]))\nprint(count_inversions([10, 9, 8, 7, 6,"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    i = 0\n    j = 0\n    inversions = 0\n    result = []\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n\n    return result, inversions\n\n\ndef count_inversions(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv = count_inversions(arr[:mid])\n    right, right_inv = count_inversions(arr[mid:])\n    sorted_arr, inversions = merge_and_count(left, right)\n\n    return sorted_arr, (left_inv + right_inv + inversions)\n\n\ndef main():\n    arr = [5, 3, 2, 1, 6, 8]\n    sorted_arr, inversions = count_inversions(arr)\n    print(sorted_arr)\n    print(inversions)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "from __future__ import annotations\n\n\ndef merge_and_count(left_arr: list[int], right_arr: list[int]) -> list[int]:\n    \"\"\"\n    Merge and count the number of inversions in the two arrays\n    >>> merge_and_count([1, 2, 3], [0, 2, 4])\n    (3, [0, 1, 2, 2, 3, 4])\n    >>> merge_and_count([1, 2, 3, 4], [0, 2, 4])\n    (5, [0, 1, 2, 2, 3, 4])\n    >>> merge_and_count([1, 2, 3, 4], [0, 2, 4, 5])\n    (7, [0, 1, 2, 2, 3, 4, 4, 5])\n    >>> merge_and_count([1, 2, 3, 4], [0, 2, 4, 5, 6])\n    (9, [0, 1, 2, 2, 3, 4, 4, 5, 5, 6])\n    \"\"\"\n\n    inversions, result = 0, []\n    i, j = 0, 0\n\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            result.append(left_arr[i])\n            i += 1\n        else:\n            result.append(right_arr[j])\n            j += 1\n            inversions += len(left_arr) - i\n\n    while i < len(left_arr):\n        result.append(left_arr[i])\n        i += 1\n\n    while j < len(right_arr):\n        result.append(right_arr[j])\n        j += 1\n\n    return inversions, result\n\n\ndef merge_sort_and_count(arr: list[int]) -> tuple[int, list[int]]:\n    \"\"\"\n    Sort the array and count the number"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    i, j = 0, 0\n    count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            count += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, count\n\n\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    sorted_arr, count = merge_and_count(left, right)\n    return sorted_arr, (left_count + right_count + count)\n\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr)[1]\n\n\ndef main():\n    print(\"Number of inversions in a list: \" +\n          str(count_inversions([1, 20, 6, 4, 5])))\n    print(\"Number of inversions in a list: \" +\n          str(count_inversions([1, 3, 5, 2, 4, 6, 8, 7])))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "from time import perf_counter\nfrom typing import List\n\n\ndef merge_and_count(left: List, right: List, inversions: int) -> List:\n    \"\"\"Merge two sorted lists in ascending order and count inversions\n    while merging.\n\n    Args:\n        left (List): left sublist\n        right (List): right sublist\n        inversions (int): inversions count\n\n    Returns:\n        List: merged sublist\n    \"\"\"\n    i, j, k = 0, 0, 0\n    merged = []\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            inversions += len(left[i:])\n            j += 1\n\n    merged += left[i:]\n    merged += right[j:]\n\n    return merged, inversions\n\n\ndef count_inversions(arr: List) -> int:\n    \"\"\"Count inversions in an array.\n\n    Args:\n        arr (List): list of numbers\n\n    Returns:\n        int: inversions count\n    \"\"\"\n    inversions = 0\n    if len(arr) <= 1:\n        return inversions\n\n    mid = len(arr) // 2\n    left, left_inv = count_inversions(arr[:mid])\n    right, right_inv = count_inversions(arr[mid:])\n    merged, inversions = merge_and_count(left, right, inversions)\n\n    return merged, left_inv + right_inv + inversions\n\n\nif __name__ == \"__main__\":\n    start_time = perf_counter()\n    inversions = count_inversions([1, 20, 6, 4, 5])\n    print(f\"Inversions: {inversions}\")\n    print(f\"Elapsed time: {perf_counter() - start_time:.7f}\")"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def merge_and_count(arr, left, right):\n    i, j = 0, 0\n    inversions = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\n\ndef merge_sort_and_count(arr, left, right):\n    if (right - left) <= 1:\n        return arr, 0\n    mid = (left + right) // 2\n    left_sorted, left_inversions = merge_sort_and_count(arr, left, mid)\n    right_sorted, right_inversions = merge_sort_and_count(arr, mid, right)\n    sorted_merged, merged_inversions = merge_and_count(left_sorted, right_sorted)\n    return sorted_merged, left_inversions + right_inversions + merged_inversions\n\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr, 0, len(arr))[1]\n\n\nprint(count_inversions([1, 20, 6, 4, 5]))\nprint(count_inversions([1, 2, 5, 3, 6, 4]))\nprint(count_inversions([1, 3, 5, 2, 4, 6]))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "def merge_sort(array):\n    if len(array) <= 1:\n        return array, 0\n    mid = len(array) // 2\n    left, left_count = merge_sort(array[:mid])\n    right, right_count = merge_sort(array[mid:])\n    result, count = [], 0\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            count += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, count + left_count + right_count\n\n\ndef count_inversions(array):\n    return merge_sort(array)[1]\n\n\nprint(count_inversions([1, 2, 5, 3, 4, 0]))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_inv = merge_sort(arr[:mid])\n    right, right_inv = merge_sort(arr[mid:])\n    merged, inv_count = merge(left, right)\n    return merged, left_inv + right_inv + inv_count\n\n\ndef merge(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    merged += left[i:]\n    merged += right[j:]\n    return merged, inv_count\n\n\ndef main():\n    arr = [5, 3, 8, 6, 7]\n    res, inv_count = merge_sort(arr)\n    print(f\"Sorted Array: {res}\")\n    print(f\"Inversions Count: {inv_count}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    left_index = 0\n    right_index = 0\n    count = 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n            count += len(left[left_index:])\n    result += left[left_index:]\n    result += right[right_index:]\n    return result, count\n\n\ndef merge_sort_and_count(arr):\n    if len(arr) == 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    return merge_and_count(left, right), left_count + right_count\n\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr)[1]\n\n\ndef main():\n    print(\"Number of inversions are: \" + str(count_inversions([1, 2, 5, 3, 4, 7, 6, 9, 8])))\n    print(\"Number of inversions are: \" + str(count_inversions([1, 2, 5, 3, 4, 7, 6, 9, 8, 11, 12, 13, 10, 15, 14, 17, 16])))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "def count_inversions(arr):\n    return count_inversions_recursive(arr, 0, len(arr))\n\n\ndef count_inversions_recursive(arr, start, end):\n    if end - start == 1:\n        return 0\n    elif end - start == 2:\n        if arr[start] > arr[start + 1]:\n            return 1\n        else:\n            return 0\n    else:\n        mid = (start + end) // 2\n        inversion_left = count_inversions_recursive(arr, start, mid)\n        inversion_right = count_inversions_recursive(arr, mid, end)\n        inversion_split = merge_and_count(arr, start, mid, end)\n        return inversion_left + inversion_right + inversion_split\n\n\ndef merge_and_count(arr, start, mid, end):\n    left = arr[start:mid]\n    right = arr[mid:end]\n    inversions = 0\n    i, j = 0, 0\n    k = start\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inversions += len(left[i:])\n        k += 1\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    return inversions\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    assert count_inversions(arr) == 3\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 21,
      "score": 9.370583536698913,
      "candidate": "def count_inversions(array):\n    \"\"\"\n    Time complexity: O(n*log(n))\n    Space complexity: O(n)\n    \"\"\"\n    # If the input is empty, return 0\n    if not array:\n        return 0\n\n    # If the input has only one element, return 0\n    if len(array) == 1:\n        return 0\n\n    # Divide and conquer\n    mid = len(array) // 2\n    left_count = count_inversions(array[:mid])\n    right_count = count_inversions(array[mid:])\n\n    # Merge\n    left_array = array[:mid]\n    right_array = array[mid:]\n\n    # Initialize the index of left and right array\n    left_index = right_index = 0\n\n    # Initialize the count of inversions\n    inversion_count = 0\n\n    # Iterate through the left and right array\n    for i in range(len(array)):\n        # If the left index is less than the length of left array\n        if left_index < len(left_array):\n            # If the right index is less than the length of right array\n            if right_index < len(right_array):\n                # Check if the left element is less than the right element\n                if left_array[left_index] <= right_array[right_index]:\n                    # Add the left element to the output array\n                    array[i] = left_array[left_index]\n                    # Increment the left index\n                    left_index += 1\n                else:\n                    # Add the right element to the output array\n                    array[i] = right_array[right_index]\n                    # Increment the inversion count\n                    inversion_count += len(left_array[left_index:])\n                    # Increment the right index\n                    right_index += 1\n            else:\n                # Add the left element to the output array\n                array[i] = left_array[left_index]\n                # Increment the left index\n                left_index += 1\n        else:\n            # Add the right element to the output array"
    },
    {
      "rank": 22,
      "score": 9.226766272351448,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    >>> count_inversions([1, 2, 5, 3, 4, 0])\n    3\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return 0\n\n    mid = n // 2\n    left_count = count_inversions(arr[:mid])\n    right_count = count_inversions(arr[mid:])\n\n    merged_count = merge_and_count(arr[:mid], arr[mid:])\n\n    return left_count + right_count + merged_count\n\n\ndef merge_and_count(left, right):\n    \"\"\"\n    >>> merge_and_count([1, 2, 5], [3, 4, 0])\n    3\n    >>> merge_and_count([1, 2], [3, 4, 0])\n    2\n    >>> merge_and_count([1, 2], [2, 3])\n    1\n    >>> merge_and_count([1, 2], [3, 4, 5])\n    0\n    >>> merge_and_count([1, 2, 5], [3, 4, 0])\n    3\n    \"\"\"\n    left_size = len(left)\n    right_size = len(right)\n\n    left_cursor = 0\n    right_cursor = 0\n\n    inversions = 0\n\n    result = []\n\n    while left_cursor < left_size and right_cursor < right_size:\n        if left[left_cursor] <= right[right_cursor]:\n            result.append(left[left_cursor])\n            left_cursor += 1\n        else:\n            result.append(right[right_cursor])\n            right_cursor += 1\n            inversions += left_size - left_cursor\n\n    while left_cursor < left_size:\n        result.append(left[left_cursor])\n        left_cursor += 1\n\n    while right_cursor < right_size:\n        result.append(right[right_cursor])\n        right_cursor += 1\n\n    return inversions\n\n\nif __name"
    },
    {
      "rank": 23,
      "score": 9.21346272767743,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count inversions in an array in O(n log n) time complexity.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0, arr\n    mid = n//2\n    left_count, left_arr = count_inversions(arr[:mid])\n    right_count, right_arr = count_inversions(arr[mid:])\n    merged_count, merged_arr = count_split_inversions(left_arr, right_arr)\n    return left_count + right_count + merged_count, merged_arr\n\ndef count_split_inversions(left_arr, right_arr):\n    \"\"\"\n    Count inversions in two sorted arrays of equal length in O(n) time complexity.\n    \"\"\"\n    left_count = right_count = 0\n    left_idx, right_idx = 0, 0\n    merged_arr = []\n    while left_idx < len(left_arr) and right_idx < len(right_arr):\n        if left_arr[left_idx] <= right_arr[right_idx]:\n            merged_arr.append(left_arr[left_idx])\n            left_idx += 1\n        else:\n            merged_arr.append(right_arr[right_idx])\n            right_idx += 1\n            left_count += len(left_arr) - left_idx\n    merged_arr += left_arr[left_idx:]\n    merged_arr += right_arr[right_idx:]\n    return left_count + right_count, merged_arr\n\nif __name__ == '__main__':\n    arr = [1, 2, 5, 3, 7, 10, 9, 12]\n    inversions, arr = count_inversions(arr)\n    print(inversions)"
    },
    {
      "rank": 24,
      "score": 9.205959372648458,
      "candidate": "from typing import List\n\n\ndef merge_and_count(left: List[int], right: List[int]) -> (List[int], int):\n    result: List[int] = []\n    left_ptr, right_ptr = 0, 0\n    count = 0\n    while left_ptr < len(left) and right_ptr < len(right):\n        if left[left_ptr] <= right[right_ptr]:\n            result.append(left[left_ptr])\n            left_ptr += 1\n        else:\n            result.append(right[right_ptr])\n            right_ptr += 1\n            count += len(left) - left_ptr\n    result.extend(left[left_ptr:] or right[right_ptr:])\n    return result, count\n\n\ndef merge_sort_and_count(arr: List[int]) -> (List[int], int):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    sorted_arr, count = merge_and_count(left, right)\n    return sorted_arr, left_count + right_count + count\n\n\ndef count_inversions(arr: List[int]) -> int:\n    _, count = merge_sort_and_count(arr)\n    return count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    a2 = [5, 3, 1, 2, 4]\n    a3 = [2, 4, 1, 3, 5]\n    print(count_inversions(arr))\n    print(count_inversions(a2))\n    print(count_inversions(a3))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 25,
      "score": 9.177268828905222,
      "candidate": "def merge_sort(array):\n    if len(array) <= 1:\n        return array\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n    return merge(left, right)\n\n\ndef merge(left, right):\n    merged = []\n    i, j = 0, 0\n    inversions = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    merged += left[i:]\n    merged += right[j:]\n    return merged, inversions\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    sorted_arr, inversions = merge_sort(arr)\n    print(\"Sorted Array: {}\\nInversions: {}\".format(sorted_arr, inversions))"
    },
    {
      "rank": 26,
      "score": 9.122564458729856,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return arr\n\n\ndef count_inversions(arr):\n    inv_count = 0\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        inv_count += count_inversions(left)\n        inv_count += count_inversions(right)\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inv_count += (len(left) - i)\n            k += 1\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return inv_count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    a = merge_sort(arr)\n    print(a)\n    print(count_inversions"
    },
    {
      "rank": 27,
      "score": 8.95994420569242,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    i, j = 0, 0\n    inversion_count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversion_count += len(left[i:])\n    result += left[i:]\n    result += right[j:]\n\n    return result, inversion_count\n\n\ndef merge_sort_and_count(array):\n    if len(array) <= 1:\n        return array, 0\n\n    mid = len(array) // 2\n    left, left_inversion_count = merge_sort_and_count(array[:mid])\n    right, right_inversion_count = merge_sort_and_count(array[mid:])\n\n    return merge_and_count(left, right)\n\n\ndef count_inversions(array):\n    _, inversion_count = merge_sort_and_count(array)\n    return inversion_count\n\n\ndef main():\n    array = [1, 20, 6, 4, 5]\n    assert count_inversions(array) == 3\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 28,
      "score": 8.946210893390457,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    :param: arr - input array\n    TODO: complete this method and return the number of inversions in the array\n    \"\"\"\n    pass\n\n\na = [2, 1, 5, 3, 4]\ncount_inversions(a)"
    },
    {
      "rank": 29,
      "score": 8.910084504002544,
      "candidate": "def count_inversions(arr):\n    if len(arr) == 1:\n        return 0\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    left_inv = count_inversions(left)\n    right_inv = count_inversions(right)\n    merge_inv = merge_inversions(left, right)\n    return left_inv + right_inv + merge_inv\n\n\ndef merge_inversions(left, right):\n    result = []\n    left_index = 0\n    right_index = 0\n    left_len = len(left)\n    right_len = len(right)\n    left_inversion = 0\n    right_inversion = 0\n    while left_index < left_len and right_index < right_len:\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n            left_inversion += left_len - left_index\n    result += left[left_index:]\n    result += right[right_index:]\n    return left_inversion + right_inversion\n\n\ndef main():\n    arr = [2, 1, 5, 3, 4]\n    print(f\"Inversions are {count_inversions(arr)}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 30,
      "score": 8.855395696632057,
      "candidate": "def count_inversions(array):\n    \"\"\"\n    Count inversions in array.\n\n    :param array: list\n    :return: int\n    \"\"\"\n    if len(array) <= 1:\n        return 0\n    else:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n        left_count = count_inversions(left)\n        right_count = count_inversions(right)\n        merge_count = count_inversions_merge(left, right)\n        return left_count + right_count + merge_count\n\n\ndef count_inversions_merge(left, right):\n    \"\"\"\n    Count inversions in merge.\n\n    :param left: list\n    :param right: list\n    :return: int\n    \"\"\"\n    i = 0\n    j = 0\n    result = 0\n    left_copy = left.copy()\n    right_copy = right.copy()\n    while i < len(left) and j < len(right):\n        if left_copy[i] <= right_copy[j]:\n            i += 1\n        else:\n            j += 1\n            result += len(left) - i\n    return result\n\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 31,
      "score": 8.8281618090209,
      "candidate": "from typing import List\n\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Merge sort\n    Time Complexity: O(nlog(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort(left)\n    right = merge_sort(right)\n\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted lists\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    inversion_count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversion_count += len(left[i:])\n\n    result += left[i:]\n    result += right[j:]\n\n    return result, inversion_count\n\n\ndef count_inversions(arr: List[int]) -> int:\n    arr, inversion_count = merge_sort(arr)\n    return inversion_count\n\n\nif __name__ == \"__main__\":\n    assert count_inversions([1, 2, 5, 3, 4, 7, 6, 9, 8]) == 24\n    assert count_inversions([2, 1, 5, 3, 4, 7, 6, 9, 8]) == 24\n    assert count_inversions([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n    assert count_inversions([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 45"
    },
    {
      "rank": 32,
      "score": 8.81367773444215,
      "candidate": "def merge_sort(arr):\n    if len(arr) == 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left_arr, left_inv_count = merge_sort(arr[:mid])\n    right_arr, right_inv_count = merge_sort(arr[mid:])\n    merged_arr, merge_inv_count = merge(left_arr, right_arr)\n    return merged_arr, left_inv_count + right_inv_count + merge_inv_count\n\n\ndef merge(left_arr, right_arr):\n    merged_arr = []\n    left_inv_count = 0\n    right_inv_count = 0\n    i, j = 0, 0\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            merged_arr.append(left_arr[i])\n            i += 1\n        else:\n            merged_arr.append(right_arr[j])\n            left_inv_count += len(left_arr) - i\n            j += 1\n    merged_arr += left_arr[i:]\n    merged_arr += right_arr[j:]\n    return merged_arr, left_inv_count + right_inv_count\n\n\ndef count_inversions(arr):\n    sorted_arr, inv_count = merge_sort(arr)\n    return inv_count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    print(count_inversions(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 33,
      "score": 8.715724466237427,
      "candidate": "def count_inversions(array):\n    if len(array) == 1:\n        return array, 0\n    else:\n        middle = len(array) // 2\n        left = array[:middle]\n        right = array[middle:]\n\n        left_sorted, left_inv_count = count_inversions(left)\n        right_sorted, right_inv_count = count_inversions(right)\n        merged_sorted, merge_inv_count = merge_and_count(left_sorted, right_sorted)\n\n        return merged_sorted, left_inv_count + right_inv_count + merge_inv_count\n\n\ndef merge_and_count(left, right):\n    merged = []\n    inversion_count = 0\n    left_indx, right_indx = 0, 0\n    while left_indx < len(left) and right_indx < len(right):\n        if left[left_indx] <= right[right_indx]:\n            merged.append(left[left_indx])\n            left_indx += 1\n        else:\n            merged.append(right[right_indx])\n            inversion_count += len(left) - left_indx\n            right_indx += 1\n\n    merged += left[left_indx:]\n    merged += right[right_indx:]\n\n    return merged, inversion_count\n\n\nif __name__ == \"__main__\":\n    array = [1, 20, 6, 4, 5]\n    sorted_array, inversion_count = count_inversions(array)\n    print(\"Original array:\", array)\n    print(\"Sorted array:\", sorted_array)\n    print(\"Inversion count:\", inversion_count)"
    },
    {
      "rank": 34,
      "score": 8.692801520950061,
      "candidate": "def merge_sort(array):\n    if len(array) <= 1:\n        return array\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n    return merge(left, right)\n\n\ndef merge(left, right):\n    array = []\n    left_index, right_index = 0, 0\n    left_len, right_len = len(left), len(right)\n    inversions = 0\n    while left_index < left_len and right_index < right_len:\n        if left[left_index] <= right[right_index]:\n            array.append(left[left_index])\n            left_index += 1\n        else:\n            array.append(right[right_index])\n            right_index += 1\n            inversions += left_len - left_index\n    array += left[left_index:]\n    array += right[right_index:]\n    return array, inversions\n\n\ndef count_inversions(array):\n    return merge_sort(array)[1]\n\n\nif __name__ == \"__main__\":\n    array = [2, 4, 1, 3, 5]\n    print(count_inversions(array))"
    },
    {
      "rank": 35,
      "score": 8.632293453617281,
      "candidate": "def merge_sort(array):\n    if len(array) == 1:\n        return array\n    mid = len(array) // 2\n    left = merge_sort(array[:mid])\n    right = merge_sort(array[mid:])\n    return merge(left, right)\n\n\ndef merge(left, right):\n    i = 0\n    j = 0\n    result = []\n    inversions = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\n\nif __name__ == \"__main__\":\n    array = [2, 4, 1, 3]\n    result, inversions = merge_sort(array)\n    print(inversions)"
    },
    {
      "rank": 36,
      "score": 8.625142247198651,
      "candidate": "def count_inversions(arr):\n    n = len(arr)\n    if n == 1:\n        return arr, 0\n\n    mid = n//2\n    left_arr, left_count = count_inversions(arr[:mid])\n    right_arr, right_count = count_inversions(arr[mid:])\n    merged_arr, merge_count = merge_sort(left_arr, right_arr)\n\n    return merged_arr, left_count + right_count + merge_count\n\ndef merge_sort(left, right):\n    merged = []\n    left_len = len(left)\n    right_len = len(right)\n    left_index, right_index = 0, 0\n    inversion_count = 0\n\n    while left_index < left_len and right_index < right_len:\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n            inversion_count += left_len - left_index\n\n    merged += left[left_index:]\n    merged += right[right_index:]\n    return merged, inversion_count\n\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 2, 5, 3, 4, 7, 6]))\n    print(count_inversions([1, 2, 4, 3, 5, 7, 6]))"
    },
    {
      "rank": 37,
      "score": 8.616253589228675,
      "candidate": "def merge_sort_and_count(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort_and_count(left)\n        merge_sort_and_count(right)\n\n        i = 0\n        j = 0\n        k = 0\n        inversions = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inversions += len(left) - i\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n        return inversions\n\n\ndef count_inversion(arr):\n    return merge_sort_and_count(arr)\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversions = count_inversion(arr)\n    print(f\"Array: {arr}\")\n    print(f\"Inversions: {inversions}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 38,
      "score": 8.60156811074208,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_arr = arr[:mid]\n        right_arr = arr[mid:]\n\n        merge_sort(left_arr)\n        merge_sort(right_arr)\n\n        i = 0\n        j = 0\n        k = 0\n        inversions = 0\n\n        while i < len(left_arr) and j < len(right_arr):\n            if left_arr[i] < right_arr[j]:\n                arr[k] = left_arr[i]\n                i += 1\n            else:\n                arr[k] = right_arr[j]\n                j += 1\n                inversions += len(left_arr) - i\n            k += 1\n\n        while i < len(left_arr):\n            arr[k] = left_arr[i]\n            i += 1\n            k += 1\n\n        while j < len(right_arr):\n            arr[k] = right_arr[j]\n            j += 1\n            k += 1\n\n        return inversions\n    return 0\n\n\ndef count_inversions(arr):\n    return merge_sort(arr)\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversions = count_inversions(arr)\n    print(inversions)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 39,
      "score": 8.565425580227462,
      "candidate": "def count_inversions(arr):\n    if len(arr) == 1:\n        return 0\n\n    mid = len(arr) // 2\n    left_count = count_inversions(arr[:mid])\n    right_count = count_inversions(arr[mid:])\n\n    left_sorted = merge_sort(arr[:mid])\n    right_sorted = merge_sort(arr[mid:])\n\n    left_sorted_count = merge(left_sorted, right_sorted)\n    return left_count + right_count + left_sorted_count\n\n\ndef merge(left, right):\n    sorted_arr = []\n    left_len = len(left)\n    right_len = len(right)\n\n    left_idx, right_idx = 0, 0\n\n    while left_idx < left_len and right_idx < right_len:\n        if left[left_idx] < right[right_idx]:\n            sorted_arr.append(left[left_idx])\n            left_idx += 1\n        else:\n            sorted_arr.append(right[right_idx])\n            right_idx += 1\n            return left_len - left_idx + right_len - right_idx\n    sorted_arr += left[left_idx:]\n    sorted_arr += right[right_idx:]\n    return 0\n\n\ndef merge_sort(arr):\n    if len(arr) == 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left_sorted = merge_sort(left)\n    right_sorted = merge_sort(right)\n\n    return merge(left_sorted, right_sorted)\n\n\nif __name__ == '__main__':\n    print(count_inversions([2, 1, 5, 3, 4]))"
    },
    {
      "rank": 40,
      "score": 8.548876241946822,
      "candidate": "def count_inversions(arr):\n    if len(arr) <= 1:\n        return 0, arr\n    mid = len(arr) // 2\n    left_count, left_sorted_arr = count_inversions(arr[:mid])\n    right_count, right_sorted_arr = count_inversions(arr[mid:])\n    merged_count, sorted_arr = merge_and_count(left_sorted_arr, right_sorted_arr)\n\n    return left_count + right_count + merged_count, sorted_arr\n\n\ndef merge_and_count(left_arr, right_arr):\n    merged_arr = []\n    left_index, right_index = 0, 0\n    inversion_count = 0\n\n    while left_index < len(left_arr) and right_index < len(right_arr):\n        if left_arr[left_index] <= right_arr[right_index]:\n            merged_arr.append(left_arr[left_index])\n            left_index += 1\n        else:\n            merged_arr.append(right_arr[right_index])\n            inversion_count += len(left_arr) - left_index\n            right_index += 1\n\n    merged_arr += left_arr[left_index:]\n    merged_arr += right_arr[right_index:]\n\n    return inversion_count, merged_arr\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversion_count, sorted_arr = count_inversions(arr)\n    print(f\"arr: {arr}\")\n    print(f\"sorted_arr: {sorted_arr}\")\n    print(f\"inversion_count: {inversion_count}\")\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 41,
      "score": 8.542875062379007,
      "candidate": "def count_inversions(arr):\n    if len(arr) == 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = count_inversions(arr[:mid])\n    right, right_count = count_inversions(arr[mid:])\n    merged_arr, merged_count = merge_and_count(left, right, arr)\n    return merged_arr, left_count + right_count + merged_count\n\n\ndef merge_and_count(left, right, arr):\n    merged_arr = []\n    i, j, count = 0, 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged_arr.append(left[i])\n            i += 1\n        else:\n            merged_arr.append(right[j])\n            j += 1\n            count += len(left[i:])\n    merged_arr += left[i:]\n    merged_arr += right[j:]\n    return merged_arr, count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    merged, count = count_inversions(arr)\n    print(merged, count)"
    },
    {
      "rank": 42,
      "score": 8.53012858503943,
      "candidate": "def count_inversion(arr):\n    if len(arr) < 2:\n        return 0\n\n    inversions = 0\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] > arr[right]:\n            inversions += (right - left)\n            break\n        else:\n            left += 1\n\n    return inversions\n\n\nprint(count_inversion([1, 2, 5, 3, 4, 7, 6, 10, 9, 8]))"
    },
    {
      "rank": 43,
      "score": 8.478208546788407,
      "candidate": "def merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n        inversions = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n                inversions += (len(left) - i)\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return inversions\n\ndef count_inversions(array):\n    return merge_sort(array)\n\n\nif __name__ == \"__main__\":\n    array = [1, 20, 6, 4, 5]\n    print(count_inversions(array))"
    },
    {
      "rank": 44,
      "score": 8.426531424889468,
      "candidate": "def count_inversions(arr):\n    if len(arr) < 2:\n        return arr, 0\n    mid = len(arr) // 2\n    first_half, inv_count_first_half = count_inversions(arr[:mid])\n    second_half, inv_count_second_half = count_inversions(arr[mid:])\n    combined, inv_count_combined = merge_and_count(first_half, second_half)\n    return combined, inv_count_first_half + inv_count_second_half + inv_count_combined\n\n\ndef merge_and_count(arr1, arr2):\n    combined = []\n    inv_count = 0\n    while len(arr1) > 0 and len(arr2) > 0:\n        if arr1[0] <= arr2[0]:\n            combined.append(arr1.pop(0))\n        else:\n            combined.append(arr2.pop(0))\n            inv_count += len(arr1)\n\n    while len(arr1) > 0:\n        combined.append(arr1.pop(0))\n\n    while len(arr2) > 0:\n        combined.append(arr2.pop(0))\n\n    return combined, inv_count\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        [1, 2, 5, 3, 4, 7, 6],\n        [1, 2, 3, 4, 5, 6, 7],\n        [3, 7, 9, 6, 5, 2, 8, 4, 1],\n    ]\n\n    for elements in test_cases:\n        print(count_inversions(elements))"
    },
    {
      "rank": 45,
      "score": 8.408439383654278,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return arr\n\n\ndef count_inversions(arr):\n    sorted_arr = merge_sort(arr)\n    return len(arr) - sorted_arr.index(arr[0])\n\n\nprint(count_inversions([2, 4, 1, 3, 5]))"
    },
    {
      "rank": 46,
      "score": 8.386620303250325,
      "candidate": "def merge_sort(array):\n    if len(array) <= 1:\n        return array\n    mid = len(array) // 2\n    left = array[:mid]\n    right = array[mid:]\n    return merge(merge_sort(left), merge_sort(right))\n\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n    inversion_count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversion_count += len(left[i:])\n    result += left[i:]\n    result += right[j:]\n    return result, inversion_count\n\n\ndef count_inversions(array):\n    return merge_sort(array)[1]\n\n\ndef main():\n    array = [1, 20, 6, 4, 5]\n    result = count_inversions(array)\n    print(f\"Array: {array}\")\n    print(f\"Inversions count: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 47,
      "score": 8.375312293858853,
      "candidate": "def merge_and_count_split(a, b):\n    \"\"\"Merge two sorted arrays and count split inversions.\"\"\"\n    c = []\n    a_idx = 0\n    b_idx = 0\n    split = 0\n    while a_idx < len(a) and b_idx < len(b):\n        if a[a_idx] <= b[b_idx]:\n            c.append(a[a_idx])\n            a_idx += 1\n        else:\n            c.append(b[b_idx])\n            b_idx += 1\n            split += len(a) - a_idx\n    c += a[a_idx:]\n    c += b[b_idx:]\n    return c, split\n\n\ndef merge_sort_and_count_split(a):\n    \"\"\"Merge sort an array and count split inversions.\"\"\"\n    if len(a) == 1:\n        return a, 0\n    mid = len(a) // 2\n    a_split, a_split_count = merge_sort_and_count_split(a[:mid])\n    b_split, b_split_count = merge_sort_and_count_split(a[mid:])\n    c, split_count = merge_and_count_split(a_split, b_split)\n    return c, a_split_count + b_split_count + split_count\n\n\ndef count_inversions(a):\n    \"\"\"Count the number of inversions in the array.\"\"\"\n    _, count = merge_sort_and_count_split(a)\n    return count\n\n\ndef test_merge_and_count_split():\n    \"\"\"Test merge and count split.\"\"\"\n    a = [1, 2, 4, 3]\n    b = [6, 5, 3, 2]\n    c, split = merge_and_count_split(a, b)\n    assert c == [1, 2, 2, 3, 3, 4, 5, 6]\n    assert split == 3\n\n\ndef test_merge_sort_and_count_split():\n    \"\"\"Test merge sort and count"
    },
    {
      "rank": 48,
      "score": 8.331556294201176,
      "candidate": "def count_inversions(array):\n    \"\"\"\n    Count the number of inversions in the array\n    \"\"\"\n    inversions = 0\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            if array[i] > array[j]:\n                inversions += 1\n    return inversions\n\n\ndef test_count_inversions():\n    \"\"\"\n    Tests for the count_inversions function\n    \"\"\"\n    assert count_inversions([1, 2, 3, 4, 5]) == 0\n    assert count_inversions([1, 3, 2, 4, 5]) == 1\n    assert count_inversions([1, 2, 4, 3, 5]) == 2\n    assert count_inversions([1, 2, 3, 5, 4]) == 3\n    assert count_inversions([1, 5, 2, 4, 3]) == 4\n    assert count_inversions([1, 3, 5, 4, 2]) == 7\n    assert count_inversions([1, 3, 5, 2, 4]) == 6\n    assert count_inversions([1, 5, 4, 3, 2]) == 10\n    assert count_inversions([1, 4, 5, 3, 2]) == 11\n    assert count_inversions([1, 3, 2, 4, 5]) == 1\n    assert count_inversions([1, 3, 2, 5, 4]) == 2\n    assert count_inversions([1, 3, 2, 5, 4]) == 2\n    assert count_inversions([1, 2, 4, 5, 3]) == 3\n    assert count_inversions([1, 4, 2, 3, 5]) == 4\n    assert count_inversions([1, 5, 2, 4, 3]) == 5\n    assert count_inversions([1, 2, 5, 3, 4])"
    },
    {
      "rank": 49,
      "score": 8.327375965969855,
      "candidate": "def merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n        inversions = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                array[k] = left[i]\n                i += 1\n            else:\n                array[k] = right[j]\n                j += 1\n                inversions += len(left) - i\n            k += 1\n\n        while i < len(left):\n            array[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            array[k] = right[j]\n            j += 1\n            k += 1\n\n    return inversions\n\n\nif __name__ == \"__main__\":\n    array = [1, 20, 6, 4, 5]\n    print(merge_sort(array))"
    },
    {
      "rank": 50,
      "score": 8.327367757082776,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count inversions in an array.\n\n    >>> count_inversions([1, 2, 5, 3, 4, 7, 6, 9, 8])\n    24\n    \"\"\"\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 51,
      "score": 8.294940769211511,
      "candidate": "def merge_sort(array):\n    if len(array) == 1:\n        return array, 0\n    mid = len(array) // 2\n    left, l_inv = merge_sort(array[:mid])\n    right, r_inv = merge_sort(array[mid:])\n    merged, inv_count = merge(left, right)\n    return merged, l_inv + r_inv + inv_count\n\n\ndef merge(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            inv_count += len(left) - i\n            j += 1\n    merged += left[i:]\n    merged += right[j:]\n    return merged, inv_count\n\n\ndef inversions(array):\n    return merge_sort(array)[1]\n\n\nprint(inversions([1, 5, 4, 3, 2]))\nprint(inversions([1, 2, 3, 4, 5]))\nprint(inversions([2, 4, 1, 3, 5]))"
    },
    {
      "rank": 52,
      "score": 8.289838256518838,
      "candidate": "def merge_sort(array, inversion_count):\n    if len(array) <= 1:\n        return array, inversion_count\n\n    mid = len(array) // 2\n    left_array, left_count = merge_sort(array[:mid], inversion_count)\n    right_array, right_count = merge_sort(array[mid:], inversion_count)\n\n    merged_array, merged_count = merge(left_array, right_array, inversion_count)\n\n    return merged_array, merged_count + left_count + right_count\n\n\ndef merge(left_array, right_array, inversion_count):\n    merged_array = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left_array) and right_index < len(right_array):\n        if left_array[left_index] <= right_array[right_index]:\n            merged_array.append(left_array[left_index])\n            left_index += 1\n        else:\n            merged_array.append(right_array[right_index])\n            right_index += 1\n            inversion_count += len(left_array) - left_index\n\n    merged_array += left_array[left_index:]\n    merged_array += right_array[right_index:]\n\n    return merged_array, inversion_count\n\n\ndef count_inversion(array):\n    inversion_count = 0\n    merged_array, inversion_count = merge_sort(array, inversion_count)\n    return inversion_count\n\n\ndef main():\n    array = [1, 20, 6, 4, 5]\n    inversion_count = count_inversion(array)\n    print(f\"Number of inversions are: {inversion_count}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 53,
      "score": 8.251903304236286,
      "candidate": "def count_inversions(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversions = count_inversions(arr)\n    print(inversions)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 54,
      "score": 8.214125058964552,
      "candidate": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort(arr[:mid])\n    right, right_count = merge_sort(arr[mid:])\n    merged_arr, count = merge(left, right, left_count, right_count)\n    return merged_arr, count\n\n\ndef merge(left, right, left_count, right_count):\n    i = j = 0\n    merged_arr = []\n    count = left_count + right_count\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged_arr.append(left[i])\n            i += 1\n        else:\n            merged_arr.append(right[j])\n            count += len(left) - i\n            j += 1\n\n    merged_arr += left[i:]\n    merged_arr += right[j:]\n    return merged_arr, count\n\n\ndef count_inversion(arr):\n    merged_arr, count = merge_sort(arr)\n    return count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    a2 = [1, 2, 5, 3, 6, 4]\n    print(\"Arr: \", arr)\n    print(count_inversion(arr))\n    print(\"Arr: \", a2)\n    print(count_inversion(a2))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 55,
      "score": 8.212735598038213,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Time complexity: O(nlogn)\n    Space complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return arr, 0\n\n    mid = n // 2\n    left, left_inv = count_inversions(arr[:mid])\n    right, right_inv = count_inversions(arr[mid:])\n\n    merged, merged_inv = merge_and_count_inversions(left, right)\n\n    return merged, left_inv + right_inv + merged_inv\n\ndef merge_and_count_inversions(left, right):\n    merged = []\n    left_idx, right_idx = 0, 0\n    left_len, right_len = len(left), len(right)\n    inv_count = 0\n    while left_idx < left_len and right_idx < right_len:\n        if left[left_idx] <= right[right_idx]:\n            merged.append(left[left_idx])\n            left_idx += 1\n        else:\n            merged.append(right[right_idx])\n            right_idx += 1\n            inv_count += left_len - left_idx\n    merged += left[left_idx:]\n    merged += right[right_idx:]\n\n    return merged, inv_count\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    arr, inv_count = count_inversions(arr)\n    print(arr)\n    print(inv_count)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 56,
      "score": 8.211579567659316,
      "candidate": "def merge_sort(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left = array[:mid]\n        right = array[mid:]\n        merge_sort(left)\n        merge_sort(right)\n        merge(left, right, array)\n    return array\n\n\ndef merge(left, right, array):\n    i = 0\n    j = 0\n    k = 0\n    inversions = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            array[k] = left[i]\n            i += 1\n        else:\n            array[k] = right[j]\n            j += 1\n            inversions += len(left) - i\n        k += 1\n    while i < len(left):\n        array[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        array[k] = right[j]\n        j += 1\n        k += 1\n    return inversions\n\n\ndef count_inversions(array):\n    array = merge_sort(array)\n    return array\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversions = count_inversions(arr)\n    print(f\"Array: {arr}\")\n    print(f\"Number of inversions: {inversions}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 57,
      "score": 8.209707251476969,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"\n    Merge two sorted subarrays\n    \"\"\"\n    i = 0\n    j = 0\n    count = 0\n    merged = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            count += len(left) - i\n            j += 1\n    merged += left[i:]\n    merged += right[j:]\n    return merged, count\n\n\ndef merge_sort_and_count(array):\n    \"\"\"\n    Sort array in ascending order and count inversions\n    \"\"\"\n    if len(array) == 1:\n        return array, 0\n    mid = len(array) // 2\n    left, left_count = merge_sort_and_count(array[:mid])\n    right, right_count = merge_sort_and_count(array[mid:])\n    merged, count = merge_and_count(left, right)\n    return merged, left_count + right_count + count\n\n\ndef count_inversions(array):\n    \"\"\"\n    Count inversions in given array\n    \"\"\"\n    return merge_sort_and_count(array)[1]"
    },
    {
      "rank": 58,
      "score": 8.2048573255218,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    left_index, right_index = 0, 0\n    inversions = 0\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n            inversions += len(left) - left_index\n\n    if left:\n        result.extend(left[left_index:])\n    if right:\n        result.extend(right[right_index:])\n    return result, inversions\n\n\ndef merge_sort_and_count(array):\n    if len(array) <= 1:\n        return array, 0\n    middle = len(array) // 2\n    left, left_inv_count = merge_sort_and_count(array[:middle])\n    right, right_inv_count = merge_sort_and_count(array[middle:])\n    return merge_and_count(left, right)\n\n\ndef count_inversions(array):\n    return merge_sort_and_count(array)[1]\n\n\nif __name__ == \"__main__\":\n    array = [1, 20, 6, 4, 5]\n    print(count_inversions(array))"
    },
    {
      "rank": 59,
      "score": 8.172253082181854,
      "candidate": "def count_inversions(array):\n    \"\"\"\n    Counts inversions in an array\n    \"\"\"\n    return _merge_sort(array)\n\n\ndef _merge_sort(array):\n    \"\"\"\n    Private function to sort an array\n    \"\"\"\n    if len(array) == 1:\n        return 0, array\n\n    mid = len(array) // 2\n    left_count, left_array = _merge_sort(array[:mid])\n    right_count, right_array = _merge_sort(array[mid:])\n\n    left_pointer, right_pointer = 0, 0\n    inversions, merge_array = 0, []\n\n    while left_pointer < len(left_array) and right_pointer < len(right_array):\n        if left_array[left_pointer] <= right_array[right_pointer]:\n            merge_array.append(left_array[left_pointer])\n            left_pointer += 1\n        else:\n            merge_array.append(right_array[right_pointer])\n            right_pointer += 1\n            inversions += len(left_array[left_pointer:])\n\n    merge_array += left_array[left_pointer:]\n    merge_array += right_array[right_pointer:]\n\n    return left_count + right_count + inversions, merge_array\n\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 2, 5, 3, 4, 7, 6]))"
    },
    {
      "rank": 60,
      "score": 8.144125099485041,
      "candidate": "def merge_and_count(arr, left, mid, right):\n    inv_count = 0\n    i, j = left, mid\n    temp = [0] * (right - left + 1)\n\n    for k in range(left, right + 1):\n        if i > mid:\n            temp[k] = arr[j]\n            j += 1\n        elif j > right:\n            temp[k] = arr[i]\n            i += 1\n        elif arr[i] > arr[j]:\n            temp[k] = arr[j]\n            j += 1\n            inv_count += (mid - i + 1)\n        else:\n            temp[k] = arr[i]\n            i += 1\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n    return inv_count, arr\n\n\ndef count_inversions(arr, left, right):\n    if left >= right:\n        return 0, arr\n    else:\n        mid = (left + right) // 2\n        inv_count_left, arr_left = count_inversions(arr, left, mid)\n        inv_count_right, arr_right = count_inversions(arr, mid + 1, right)\n        inv_count, arr = merge_and_count(arr, left, mid, right)\n        return inv_count + inv_count_left + inv_count_right, arr\n\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 20, 6, 4, 5], 0, 4))"
    },
    {
      "rank": 61,
      "score": 8.143591138329747,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    This solution has a time complexity of O(nlog(n))\n    and a space complexity of O(n)\n    \"\"\"\n    if len(arr) == 1:\n        return 0, arr\n\n    mid = len(arr) // 2\n    left_count, left = count_inversions(arr[:mid])\n    right_count, right = count_inversions(arr[mid:])\n\n    merged_arr, merged_count = merge_and_count_inversions(left, right)\n\n    return left_count + right_count + merged_count, merged_arr\n\n\ndef merge_and_count_inversions(left, right):\n    \"\"\"\n    This function merges the two sorted arrays and\n    returns the merged array and the count of inversions\n    \"\"\"\n    merged_arr = []\n    count = 0\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged_arr.append(left[i])\n            i += 1\n        else:\n            merged_arr.append(right[j])\n            count += len(left[i:])\n            j += 1\n\n    merged_arr += left[i:]\n    merged_arr += right[j:]\n\n    return merged_arr, count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    count, sorted_arr = count_inversions(arr)\n    print(f\"Sorted array: {sorted_arr}\")\n    print(f\"Count of inversions: {count}\")"
    },
    {
      "rank": 62,
      "score": 8.121884567141883,
      "candidate": "def count_inversion(arr):\n    \"\"\"\n    Count inversion in an array.\n\n    :param arr: list of integers\n    :return: number of inversions\n    :rtype: int\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    return count_inversion(arr[:n//2]) + \\\n        count_inversion(arr[n//2:]) + \\\n        count_split_inversion(arr[:n//2], arr[n//2:])\n\n\ndef count_split_inversion(arr1, arr2):\n    \"\"\"\n    Count inversion in two sorted arrays.\n\n    :param arr1: first list of integers\n    :param arr2: second list of integers\n    :return: number of inversions\n    :rtype: int\n    \"\"\"\n    n1 = len(arr1)\n    n2 = len(arr2)\n\n    inversion_count = 0\n    i1 = 0\n    i2 = 0\n    while i1 < n1 and i2 < n2:\n        if arr1[i1] <= arr2[i2]:\n            i1 += 1\n        else:\n            inversion_count += (n1 - i1)\n            i2 += 1\n    return inversion_count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    print(\"Inversions:\", count_inversion(arr))"
    },
    {
      "rank": 63,
      "score": 8.105983444291466,
      "candidate": "def count_inversion(arr):\n    if len(arr) == 1:\n        return 0\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left_inv = count_inversion(left)\n    right_inv = count_inversion(right)\n\n    left_inv += merge_inversion(left, right)\n\n    return left_inv + right_inv\n\n\ndef merge_inversion(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    inversion = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n            inversion += len(left[left_index:])\n\n    merged += left[left_index:]\n    merged += right[right_index:]\n\n    return inversion\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    print(count_inversion(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 64,
      "score": 8.08452234024709,
      "candidate": "def count_inversions(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    else:\n        mid = n // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        return count_inversions(left) + count_inversions(right) + merge(left, right, arr)\n\n\ndef merge(left, right, arr):\n    i = 0\n    j = 0\n    k = 0\n    inversion_count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inversion_count += len(left) - i\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inversion_count\n\n\nif __name__ == \"__main__\":\n    arr = [2, 4, 1, 3, 5]\n    print(count_inversions(arr))"
    },
    {
      "rank": 65,
      "score": 8.024835682833125,
      "candidate": "def merge_and_count_split(arr, left, mid, right):\n    len1, len2 = mid - left + 1, right - mid\n    L, R = [0] * (len1), [0] * (len2)\n    for i in range(0, len1):\n        L[i] = arr[left + i]\n    for j in range(0, len2):\n        R[j] = arr[mid + 1 + j]\n    i, j, k = 0, 0, left\n    inversion_count = 0\n    while i < len1 and j < len2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversion_count += len1 - i\n        k += 1\n    while i < len1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < len2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversion_count\n\n\ndef count_inversions(arr, left, right):\n    if right <= left:\n        return 0\n    mid = (left + right) // 2\n    inversion_count = count_inversions(arr, left, mid)\n    inversion_count += count_inversions(arr, mid + 1, right)\n    inversion_count += merge_and_count_split(arr, left, mid, right)\n    return inversion_count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    inversion_count = count_inversions(arr, 0, len(arr) - 1)\n    print(f\"Array: {arr}\")\n    print(f\"Inversion Count: {inversion_count}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 66,
      "score": 7.990432406683839,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"\n    Merge two sorted array and count the number of inversions\n    \"\"\"\n    result = []\n    left_index = 0\n    right_index = 0\n    inversion_count = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n            inversion_count += len(left) - left_index\n\n    result += left[left_index:]\n    result += right[right_index:]\n\n    return result, inversion_count\n\n\ndef merge_sort_and_count(arr):\n    \"\"\"\n    Sort an array and count the number of inversions\n    \"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid_index = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid_index])\n    right, right_count = merge_sort_and_count(arr[mid_index:])\n\n    return merge_and_count(left, right), left_count + right_count\n\n\ndef count_inversions(arr):\n    return merge_sort_and_count(arr)[1]\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    result = count_inversions(arr)\n    print(f\"Array: {arr}\")\n    print(f\"Inversions: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 67,
      "score": 7.915588979966494,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"Merge and count.\"\"\"\n    i = j = inv = 0\n    result = []\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inv += len(left) - i\n\n    result += left[i:]\n    result += right[j:]\n\n    return result, inv\n\n\ndef count_inversions(arr):\n    \"\"\"Count inversions.\"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        mid = len(arr) // 2\n        left, left_inv = count_inversions(arr[:mid])\n        right, right_inv = count_inversions(arr[mid:])\n        merged, merged_inv = merge_and_count(left, right)\n\n        return merged, left_inv + right_inv + merged_inv\n\n\ndef merge_sort(arr):\n    \"\"\"Merge sort.\"\"\"\n    if len(arr) == 1:\n        return arr\n    else:\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n\ndef merge(left, right):\n    \"\"\"Merge.\"\"\"\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n\n\ndef main():\n    \"\"\"Print the number of inversions.\"\"\"\n    arr = [1, 20, 6, 4, 5]\n    result, count = count_inversions(arr)\n    print(\"Array is {}\"."
    },
    {
      "rank": 68,
      "score": 7.84634113240411,
      "candidate": "def count_inversions(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n\n    return inversions\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    assert count_inversions(arr) == 3\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 69,
      "score": 7.834022619458933,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"Merge and count inversions in sorted arrays `left` and `right`.\"\"\"\n    count = 0\n    i, j = 0, 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            count += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, count\n\ndef sort_and_count(arr):\n    \"\"\"Sort `arr` in ascending order and count inversions.\"\"\"\n    n = len(arr)\n    if n < 2:\n        return arr, 0\n    mid = n // 2\n    left, left_count = sort_and_count(arr[:mid])\n    right, right_count = sort_and_count(arr[mid:])\n    sorted_arr, cross = merge_and_count(left, right)\n    return sorted_arr, left_count + right_count + cross\n\ndef inversion_count(arr):\n    \"\"\"Return number of inversions in array `arr`.\"\"\"\n    _, count = sort_and_count(arr)\n    return count\n\n\n# Tests\nassert inversion_count([4, 3, 2, 1]) == 0\nassert inversion_count([3, 2, 5, 1]) == 2\nassert inversion_count([3, 7, 5, 1]) == 3\nassert inversion_count([2, 4, 1, 3, 5]) == 4"
    },
    {
      "rank": 70,
      "score": 7.780351419995229,
      "candidate": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    left = merge_sort(left)\n    right = merge_sort(right)\n    return merge(left, right)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            count += len(left) - i\n    merged += left[i:]\n    merged += right[j:]\n    return merged, count\n\ndef count_inversions(arr):\n    return merge_sort(arr)[1]\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    print(\"Sorted Array: \", merge_sort(arr))\n    print(\"Inversions count: \", count_inversions(arr))"
    },
    {
      "rank": 71,
      "score": 7.5819855281879285,
      "candidate": "def merge(left, right):\n    i,j = 0,0\n    result = []\n    inversions = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left[i:])\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr)//2\n    left,left_inversions = merge_sort(arr[:mid])\n    right,right_inversions = merge_sort(arr[mid:])\n    return merge(left,right), left_inversions + right_inversions\n\n\ndef count_inversions(arr):\n    return merge_sort(arr)[1]\n\nif __name__ == \"__main__\":\n    print(count_inversions([1, 2, 7, 4, 8, 7]))"
    },
    {
      "rank": 72,
      "score": 7.4878043221155455,
      "candidate": "def count_inversions(arr):\n    if len(arr) == 1:\n        return 0, arr\n\n    mid = len(arr) // 2\n    left_count, left_arr = count_inversions(arr[:mid])\n    right_count, right_arr = count_inversions(arr[mid:])\n    merged_arr = []\n    merged_count = 0\n    left_i = 0\n    right_i = 0\n\n    while left_i < len(left_arr) and right_i < len(right_arr):\n        if left_arr[left_i] <= right_arr[right_i]:\n            merged_arr.append(left_arr[left_i])\n            left_i += 1\n        else:\n            merged_arr.append(right_arr[right_i])\n            merged_count += len(left_arr[left_i:])\n            right_i += 1\n\n    merged_arr.extend(left_arr[left_i:] if left_i < len(left_arr) else right_arr[right_i:])\n    return merged_count + left_count + right_count, merged_arr\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    print(count_inversions(arr))"
    },
    {
      "rank": 73,
      "score": 7.4506599871439985,
      "candidate": "def merge_and_count(left_array, right_array):\n    left_len = len(left_array)\n    right_len = len(right_array)\n    i = 0\n    j = 0\n    inversion_count = 0\n    merged_array = []\n\n    while i < left_len and j < right_len:\n        if left_array[i] <= right_array[j]:\n            merged_array.append(left_array[i])\n            i += 1\n        else:\n            merged_array.append(right_array[j])\n            j += 1\n            inversion_count += left_len - i\n\n    while i < left_len:\n        merged_array.append(left_array[i])\n        i += 1\n\n    while j < right_len:\n        merged_array.append(right_array[j])\n        j += 1\n\n    return merged_array, inversion_count\n\n\ndef count_inversions(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_array = array[:mid]\n        right_array = array[mid:]\n\n        left_count = count_inversions(left_array)\n        right_count = count_inversions(right_array)\n        merged_array, inversion_count = merge_and_count(left_array, right_array)\n\n        return left_count + right_count + inversion_count\n\n    return 0\n\n\ndef main():\n    array = [1, 20, 6, 4, 5]\n    print(count_inversions(array))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 74,
      "score": 3.4263874601869957,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n\ndef merge_count(arr):\n    count = 0\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        count += merge_count(L)\n        count += merge_count(R)\n\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                count += len(L) - i\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    arr = [1, 20, 6, 4, 5]\n    merge_sort(arr)\n    print(arr)\n    print(merge_count(arr))"
    },
    {
      "rank": 75,
      "score": 3.2854230010791072,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    left_index = 0\n    right_index = 0\n    left_length = len(left)\n    right_length = len(right)\n    inversions = 0\n\n    while left_index < left_length and right_index < right_length:\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n            inversions += left_length - left_index\n\n    result += left[left_index:]\n    result += right[right_index:]\n\n    return result, inversions\n\n\ndef merge_sort_and_count(array):\n    if len(array) <= 1:\n        return array, 0\n\n    mid = len(array) // 2\n    left, left_inversions = merge_sort_and_count(array[:mid])\n    right, right_inversions = merge_sort_and_count(array[mid:])\n\n    return merge_and_count(left, right) + (left_inversions + right_inversions)\n\n\ndef count_inversions(array):\n    return merge_sort_and_count(array)[1]\n\n\nif __name__ == \"__main__\":\n    assert count_inversions([1, 2, 5, 3, 4, 7, 6]) == 3"
    },
    {
      "rank": 76,
      "score": 3.263397184323037,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Return the number of inversions in the array.\n    An inversion is when an element is bigger than the element to its right.\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n    return count_inversions_helper(arr, 0, n-1)\n\n\ndef count_inversions_helper(arr, start, end):\n    \"\"\"\n    Helper function for count_inversions.\n    \"\"\"\n    if start >= end:\n        return 0\n\n    mid = (start + end) // 2\n    left_inv = count_inversions_helper(arr, start, mid)\n    right_inv = count_inversions_helper(arr, mid+1, end)\n    cross_inv = merge_and_count_split(arr, start, mid, end)\n\n    return left_inv + right_inv + cross_inv\n\n\ndef merge_and_count_split(arr, start, mid, end):\n    \"\"\"\n    Merge the arrays in order and count inversions.\n    \"\"\"\n    left = arr[start:mid+1]\n    right = arr[mid+1:end+1]\n    result = []\n    left_ptr = right_ptr = 0\n    inversions = 0\n\n    while left_ptr < len(left) and right_ptr < len(right):\n        if left[left_ptr] <= right[right_ptr]:\n            result.append(left[left_ptr])\n            left_ptr += 1\n        else:\n            result.append(right[right_ptr])\n            right_ptr += 1\n            inversions += len(left[left_ptr:])\n\n    if left_ptr < len(left):\n        result.extend(left[left_ptr:])\n    if right_ptr < len(right):\n        result.extend(right[right_ptr:])\n\n    for i in range(start, end+1):\n        arr[i] = result[i-start]\n\n    return inversions\n\n\ndef test_function(test_case):\n    arr = test_case[0]"
    },
    {
      "rank": 77,
      "score": 3.222087126267861,
      "candidate": "def merge_and_count(left_arr, right_arr):\n    result = []\n    i, j = 0, 0\n    inversions = 0\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            result.append(left_arr[i])\n            i += 1\n        else:\n            result.append(right_arr[j])\n            j += 1\n            inversions += len(left_arr) - i\n    result.extend(left_arr[i:])\n    result.extend(right_arr[j:])\n    return result, inversions\n\n\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left_arr, left_inv = merge_sort_and_count(arr[:mid])\n    right_arr, right_inv = merge_sort_and_count(arr[mid:])\n    sorted_arr, inversions = merge_and_count(left_arr, right_arr)\n    return sorted_arr, left_inv + right_inv + inversions\n\n\ndef count_inversions(arr):\n    _, inversions = merge_sort_and_count(arr)\n    return inversions\n\n\ndef main():\n    arr = [5, 3, 7, 2, 8]\n    print(count_inversions(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 78,
      "score": 3.2193819720464334,
      "candidate": "def count_inversions(arr: list) -> int:\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(logn)\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    mid = n // 2\n\n    return merge_count(arr, 0, mid, n - 1)\n\n\ndef merge_count(arr: list, left: int, mid: int, right: int) -> int:\n    if left >= right:\n        return 0\n\n    count = 0\n    count += merge_count(arr, left, mid, right)\n    count += merge_count(arr, mid + 1, right, right)\n\n    merged_arr = merge(arr, left, mid, right)\n    for i in range(len(merged_arr)):\n        if i + 1 < len(merged_arr) and merged_arr[i] > merged_arr[i + 1]:\n            count += 1\n    return count\n\n\ndef merge(arr: list, left: int, mid: int, right: int) -> list:\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    left_arr = arr[left : mid + 1]\n    right_arr = arr[mid + 1 : right + 1]\n\n    merged_arr = [None] * (n1 + n2)\n\n    i = 0\n    j = 0\n    k = 0\n\n    while i < n1 and j < n2:\n        if left_arr[i] <= right_arr[j]:\n            merged_arr[k] = left_arr[i]\n            i += 1\n        else:\n            merged_arr[k] = right_arr[j]\n            j += 1\n        k += 1\n\n    while i < n1:\n        merged_arr[k] = left_arr[i]\n        i += 1\n        k += 1\n\n    while j < n2:\n        merged_arr[k] = right_arr[j]\n        j += 1"
    },
    {
      "rank": 79,
      "score": 3.174875905287187,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count number of inversions in an array\n\n    Args:\n       arr(array): Input Array\n    Returns:\n       count(int): Count of inversions\n    \"\"\"\n    # TODO: Write your solution here\n    return count_inversions_recursive(arr)\n\n\ndef count_inversions_recursive(arr):\n    # Base case\n    if len(arr) <= 1:\n        return 0\n\n    mid = len(arr) // 2\n\n    left_count = count_inversions_recursive(arr[:mid])\n    right_count = count_inversions_recursive(arr[mid:])\n\n    left_arr = arr[:mid]\n    right_arr = arr[mid:]\n\n    count = left_count + right_count\n\n    left_index = 0\n    right_index = 0\n\n    for i in range(len(arr)):\n        if left_index < len(left_arr) and right_index < len(right_arr):\n            if left_arr[left_index] <= right_arr[right_index]:\n                arr[i] = left_arr[left_index]\n                left_index += 1\n            else:\n                arr[i] = right_arr[right_index]\n                right_index += 1\n                count += len(left_arr) - left_index\n        elif left_index < len(left_arr):\n            arr[i] = left_arr[left_index]\n            left_index += 1\n        elif right_index < len(right_arr):\n            arr[i] = right_arr[right_index]\n            right_index += 1\n\n    return count\n\n\ndef main():\n    print(\"Count of inversions: \" +\n          str(count_inversions([1, 20, 6, 4, 5])))\n    print(\"Count of inversions: \" +\n          str(count_inversions([1, 2, 5, 3, 6, 4])))\n    print(\"Count of inversions: \" +\n          str(count_inversions([5, 3"
    },
    {
      "rank": 80,
      "score": 3.1651525979870345,
      "candidate": "def merge_sort(array):\n    if len(array) <= 1:\n        return array, 0\n\n    mid = len(array) // 2\n    left, left_inv_count = merge_sort(array[:mid])\n    right, right_inv_count = merge_sort(array[mid:])\n    merged_array, merge_inv_count = merge(left, right)\n    return merged_array, left_inv_count + right_inv_count + merge_inv_count\n\ndef merge(left, right):\n    merged_array = []\n    left_cur, right_cur = 0, 0\n    left_len, right_len = len(left), len(right)\n    inv_count = 0\n\n    while left_cur < left_len and right_cur < right_len:\n        if left[left_cur] <= right[right_cur]:\n            merged_array.append(left[left_cur])\n            left_cur += 1\n        else:\n            merged_array.append(right[right_cur])\n            right_cur += 1\n            inv_count += left_len - left_cur\n\n    merged_array += left[left_cur:]\n    merged_array += right[right_cur:]\n\n    return merged_array, inv_count\n\ndef count_inversions(array):\n    return merge_sort(array)[1]\n\n\ndef test_function(test_case):\n    array = test_case[0]\n    solution = test_case[1]\n    output = count_inversions(array)\n    \n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n# test case 1\ntest_case = [[2, 5, 1, 3, 4], 3]\ntest_function(test_case)\n\n# test case 2\ntest_case = [[54, 99, 49, 22, 37, 18, 22, 90], 26]\ntest_function(test_case)\n\n# test case 3\ntest_case = [[1, 2, 5"
    },
    {
      "rank": 81,
      "score": 3.0976417267628613,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n\n    left_arr, left_inv = count_inversions(arr[:mid])\n    right_arr, right_inv = count_inversions(arr[mid:])\n    merged_arr, merged_inv = merge_arrays(left_arr, right_arr)\n\n    return merged_arr, merged_inv + left_inv + right_inv\n\n\ndef merge_arrays(left_arr, right_arr):\n    merged_arr = []\n    left_index, right_index = 0, 0\n    inversions = 0\n\n    while left_index < len(left_arr) and right_index < len(right_arr):\n        if left_arr[left_index] <= right_arr[right_index]:\n            merged_arr.append(left_arr[left_index])\n            left_index += 1\n        else:\n            merged_arr.append(right_arr[right_index])\n            right_index += 1\n            inversions += len(left_arr) - left_index\n\n    merged_arr += left_arr[left_index:]\n    merged_arr += right_arr[right_index:]\n\n    return merged_arr, inversions\n\n\ndef count_inversions_quicksort(arr):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(logn)\n    \"\"\"\n    return _count_inversions_quicksort(arr, 0, len(arr) - 1)\n\n\ndef _count_inversions_quicksort(arr, left, right):\n    if left >= right:\n        return 0\n\n    mid = (left + right) // 2\n    left_inv = _count_inversions_quicksort(arr, left, mid)\n    right_inv = _count_inversions_quicksort(arr, mid + 1, right)\n    sorted_inv = merge_"
    },
    {
      "rank": 82,
      "score": 3.0894411264789623,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    :param: arr - input array\n    TODO: complete this method and return the number of inversions in the array\n    \"\"\"\n    if len(arr) == 1:\n        return 0\n    mid = len(arr)//2\n    left = arr[:mid]\n    right = arr[mid:]\n    left_inv = count_inversions(left)\n    right_inv = count_inversions(right)\n    # merge_inv = merge_inversion(arr,left,right)\n    merge_inv = merge_inversion(arr,left,right,0,len(arr)-1)\n\n    return left_inv + right_inv + merge_inv\n\n\ndef merge_inversion(arr,left,right,left_start,left_end):\n    # print(arr)\n    # print(left)\n    # print(right)\n    result = []\n    i=0\n    j=0\n    k=0\n    left_inv = 0\n    while i<len(left) and j<len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i+=1\n        else:\n            result.append(right[j])\n            j+=1\n            left_inv+= len(left)-i\n    # print(result)\n    # print(left_inv)\n    while i<len(left):\n        result.append(left[i])\n        i+=1\n    while j<len(right):\n        result.append(right[j])\n        j+=1\n    # print(result)\n    arr[left_start:left_end+1] = result\n    return left_inv\n\n\n# print(count_inversions([1,2,3,4,5,6]))\n# print(count_inversions([1,3,5,2,4,6]))\nprint(count_inversions([2,4,1,3,5]))"
    },
    {
      "rank": 83,
      "score": 3.0875026717365945,
      "candidate": "def merge_sort_count_inversions(array):\n    \"\"\"\n    A merge sort that counts the number of inversions.\n    \"\"\"\n    return _merge_sort_count_inversions(array, 0, len(array) - 1)\n\n\ndef _merge_sort_count_inversions(array, left, right):\n    \"\"\"\n    Sort the given array in ascending order and count the number of inversions.\n    \"\"\"\n    if left >= right:\n        return 0, array\n\n    mid = (left + right) // 2\n    left_inversion, left_sorted = _merge_sort_count_inversions(array, left, mid)\n    right_inversion, right_sorted = _merge_sort_count_inversions(array, mid + 1, right)\n    inversion, sorted_array = _merge_and_count_inversions(left_sorted, right_sorted)\n    return left_inversion + right_inversion + inversion, sorted_array\n\n\ndef _merge_and_count_inversions(left, right):\n    \"\"\"\n    Merge two sorted arrays and count the inversions.\n    \"\"\"\n    inversion = 0\n    i = j = 0\n    sorted_array = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted_array.append(left[i])\n            i += 1\n        else:\n            sorted_array.append(right[j])\n            j += 1\n            inversion += len(left) - i\n\n    sorted_array += left[i:]\n    sorted_array += right[j:]\n    return inversion, sorted_array\n\n\ndef test_function(test_case):\n    array = test_case[0]\n    solution = test_case[1]\n    output = merge_sort_count_inversions(array)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narray = [2, 4, 1, 3, 5]\nsolution = 3\ntest_case = [array, solution]\ntest_function("
    },
    {
      "rank": 84,
      "score": 3.029949099221664,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count inversions in an array using merge sort.\n    Time Complexity: O(nlog(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left_half, left_count = count_inversions(arr[:mid])\n    right_half, right_count = count_inversions(arr[mid:])\n    sorted_arr, merge_count = merge(left_half, right_half)\n    return sorted_arr, left_count + right_count + merge_count\n\n\ndef merge(left_half, right_half):\n    \"\"\"\n    Merge two sorted arrays into a single sorted array\n    \"\"\"\n    sorted_arr = []\n    left_index, right_index, inversion_count = 0, 0, 0\n    while left_index < len(left_half) and right_index < len(right_half):\n        if left_half[left_index] < right_half[right_index]:\n            sorted_arr.append(left_half[left_index])\n            left_index += 1\n        else:\n            sorted_arr.append(right_half[right_index])\n            right_index += 1\n            inversion_count += len(left_half) - left_index\n    sorted_arr += left_half[left_index:]\n    sorted_arr += right_half[right_index:]\n    return sorted_arr, inversion_count\n\n\ndef count_inversions_recursive(arr):\n    \"\"\"\n    Count inversions in an array using merge sort.\n    Time Complexity: O(nlog(n))\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left_half, left_count = count_inversions_recursive(arr[:mid])\n    right_half, right_count = count_inversions_recursive(arr[mid:])\n    sorted_arr, merge_count = merge_"
    },
    {
      "rank": 85,
      "score": 3.024775409664586,
      "candidate": "def merge_and_count(left, right):\n    \"\"\"\n    :param left: list\n    :param right: list\n    :return: int\n    \"\"\"\n    result = []\n    count = 0\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            count += len(left) - i\n\n    result += left[i:]\n    result += right[j:]\n    return result, count\n\n\ndef merge_sort_and_count(arr):\n    \"\"\"\n    :param arr: list\n    :return: int\n    \"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    sorted_arr, count = merge_and_count(left, right)\n    return sorted_arr, left_count + right_count + count\n\n\ndef inversion_count(arr):\n    \"\"\"\n    :param arr: list\n    :return: int\n    \"\"\"\n    _, count = merge_sort_and_count(arr)\n    return count\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    solution = test_case[1]\n    output = inversion_count(arr)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [2, 4, 1, 3, 5]\nsolution = 3\ntest_case = [arr, solution]\ntest_function(test_case)"
    },
    {
      "rank": 86,
      "score": 3.023502708424306,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    This function counts the number of inversions in the given array\n    :param arr: list\n    :return: int\n    \"\"\"\n    return _count_inversions(arr, 0, len(arr))\n\n\ndef _count_inversions(arr, start, end):\n    \"\"\"\n    This function counts the number of inversions in the given array\n    :param arr: list\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    if end - start <= 1:\n        return 0\n    mid = (start + end) // 2\n    left_inversions = _count_inversions(arr, start, mid)\n    right_inversions = _count_inversions(arr, mid, end)\n    merge_inversions = _merge_inversions(arr, start, mid, end)\n    return left_inversions + right_inversions + merge_inversions\n\n\ndef _merge_inversions(arr, start, mid, end):\n    \"\"\"\n    This function counts the number of inversions in the given array\n    :param arr: list\n    :param start: int\n    :param mid: int\n    :param end: int\n    :return: int\n    \"\"\"\n    temp = [0] * len(arr)\n    left = start\n    right = mid\n    k = start\n    count = 0\n    while left < mid and right < end:\n        if arr[left] <= arr[right]:\n            temp[k] = arr[left]\n            left += 1\n        else:\n            temp[k] = arr[right]\n            right += 1\n            count += mid - left\n        k += 1\n    while left < mid:\n        temp[k] = arr[left]\n        left += 1\n        k += 1\n    while right < end:\n        temp[k] = arr[right]\n        right += 1\n        k += 1\n    for i in range(start, end):\n        arr[i] = temp[i]\n    return count\n\n\ndef main():\n    arr = [1, 20, 6,"
    },
    {
      "rank": 87,
      "score": 2.9963557493207578,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n        inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inv_count += len(left[i:])\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n        return inv_count\n\n\narr = [2, 4, 1, 3, 5]\nprint(merge_sort(arr))"
    },
    {
      "rank": 88,
      "score": 2.9498720763007693,
      "candidate": "def merge_sort_count_inv(input_list):\n    \"\"\"\n    Helper function for merge sort\n    \"\"\"\n    inv_count = 0\n    if len(input_list) > 1:\n        mid = len(input_list) // 2\n        left_list = input_list[:mid]\n        right_list = input_list[mid:]\n\n        # Recursive call on each half\n        inv_count += merge_sort_count_inv(left_list)\n        inv_count += merge_sort_count_inv(right_list)\n\n        i = 0\n        j = 0\n        len_left = len(left_list)\n        len_right = len(right_list)\n        merged_list = []\n\n        # Until we run out of elements in both halves\n        while i < len_left and j < len_right:\n            if left_list[i] < right_list[j]:\n                merged_list.append(left_list[i])\n                i += 1\n            else:\n                merged_list.append(right_list[j])\n                # this means left_list[i] > right_list[j]\n                inv_count += len_left - i\n                j += 1\n\n        # Merge any remaining elements\n        while i < len_left:\n            merged_list.append(left_list[i])\n            i += 1\n\n        while j < len_right:\n            merged_list.append(right_list[j])\n            j += 1\n\n        input_list[:] = merged_list\n\n    return inv_count\n\n\ndef count_inversions(input_list):\n    \"\"\"\n    This function takes in a list and returns the number of inversions in the list.\n    \"\"\"\n    return merge_sort_count_inv(input_list)\n\n\ndef test_function(test_case):\n    output = count_inversions(test_case[0])\n    if output == test_case[1]:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\ntest_case_1 = [[2, 5, 1, 3, 4"
    },
    {
      "rank": 89,
      "score": 2.9212426875558153,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Count the number of inversions in an array.\n\n    Parameters:\n        arr (list): The array to count inversions in.\n\n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n\n    return inversions\n\ndef merge_and_count(left, right):\n    \"\"\"\n    Merge two sorted arrays and count the number of inversions.\n\n    Parameters:\n        left (list): The left array to merge.\n        right (list): The right array to merge.\n\n    Returns:\n        list: The merged array.\n        int: The number of inversions in the merged array.\n    \"\"\"\n    i = 0\n    j = 0\n    merged = []\n    inversions = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += len(left[i:])\n\n    merged += left[i:]\n    merged += right[j:]\n\n    return merged, inversions\n\ndef count_inversions_recursive(arr):\n    \"\"\"\n    Recursively count the number of inversions in an array.\n\n    Parameters:\n        arr (list): The array to count inversions in.\n\n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    else:\n        mid = len(arr) // 2\n        left, left_inversions = count_inversions_recursive(arr[:mid])\n        right, right_inversions = count_inversions_recursive(arr[mid:])\n        merged, merged_inversions = merge_and_count(left, right)\n        return merged, left"
    },
    {
      "rank": 90,
      "score": 2.918702002190892,
      "candidate": "def merge_sort(arr):\n    n = len(arr)\n    if n > 1:\n        mid = n // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inversions += (n - 2 * j)\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n\ndef count_inversions(arr):\n    global inversions\n    inversions = 0\n    merge_sort(arr)\n    return inversions\n\n\narr = [2, 4, 1, 3, 5]\nprint(count_inversions(arr))\n\narr = [54, 99, 49, 22, 37, 18, 22, 90, 86, 33]\nprint(count_inversions(arr))"
    },
    {
      "rank": 91,
      "score": 2.8481823671049376,
      "candidate": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv_count = merge_sort(arr[:mid])\n    right, right_inv_count = merge_sort(arr[mid:])\n    merged_arr, merge_inv_count = merge(left, right)\n    return merged_arr, (left_inv_count + right_inv_count + merge_inv_count)\n\n\ndef merge(left, right):\n    merged_arr = []\n    inv_count = 0\n\n    left_ptr, right_ptr = 0, 0\n    while left_ptr < len(left) and right_ptr < len(right):\n        if left[left_ptr] <= right[right_ptr]:\n            merged_arr.append(left[left_ptr])\n            left_ptr += 1\n        else:\n            merged_arr.append(right[right_ptr])\n            inv_count += len(left) - left_ptr\n            right_ptr += 1\n\n    merged_arr += left[left_ptr:]\n    merged_arr += right[right_ptr:]\n    return merged_arr, inv_count\n\n\ndef count_inversions(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv_count = count_inversions(arr[:mid])\n    right, right_inv_count = count_inversions(arr[mid:])\n    merged_arr, merge_inv_count = merge_inversions(left, right)\n    return merged_arr, (left_inv_count + right_inv_count + merge_inv_count)\n\n\ndef merge_inversions(left, right):\n    merged_arr = []\n    inv_count = 0\n\n    left_ptr, right_ptr = 0, 0\n    while left_ptr < len(left) and right_ptr < len(right):\n        if left[left_ptr] <= right[right_ptr]:\n            merged_arr.append(left[left"
    },
    {
      "rank": 92,
      "score": 2.7265355975097054,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Time Complexity: O(nlog(n))\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n    return merge_sort(arr, 0, n - 1)\n\n\ndef merge_sort(arr, left, right):\n    if left >= right:\n        return 0\n    mid = (left + right) // 2\n    inv_count = merge_sort(arr, left, mid) + merge_sort(arr, mid + 1, right)\n    inv_count += merge(arr, left, mid, right)\n    return inv_count\n\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [0] * (n1)\n    R = [0] * (n2)\n    for i in range(0, n1):\n        L[i] = arr[left + i]\n    for j in range(0, n2):\n        R[j] = arr[mid + 1 + j]\n\n    i = 0\n    j = 0\n    k = left\n    inv_count = 0\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inv_count += n1 - i\n        k += 1\n\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\n    return inv_count\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    print(\"Array: \", arr)\n    ans = count_inversions(arr)\n    print(ans)\n\n\nif __name__"
    },
    {
      "rank": 93,
      "score": 2.7012895570183724,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        mid = len(arr) // 2\n        left_arr, left_count = count_inversions(arr[:mid])\n        right_arr, right_count = count_inversions(arr[mid:])\n        merged_arr, merge_count = merge_count_split(left_arr, right_arr)\n    return merged_arr, left_count + right_count + merge_count\n\n\ndef merge_count_split(left_arr, right_arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    left_size = len(left_arr)\n    right_size = len(right_arr)\n    merge_arr = []\n    left_count = 0\n    right_count = 0\n    i, j = 0, 0\n    while i < left_size and j < right_size:\n        if left_arr[i] <= right_arr[j]:\n            merge_arr.append(left_arr[i])\n            i += 1\n        else:\n            merge_arr.append(right_arr[j])\n            j += 1\n            left_count += left_size - i\n    if i == left_size:\n        merge_arr.extend(right_arr[j:])\n    else:\n        merge_arr.extend(left_arr[i:])\n    return merge_arr, left_count + right_count\n\n\ndef merge_count(left_arr, right_arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    left_size = len(left_arr)\n    right_size = len(right_arr)\n    merge_arr = []\n    left_count = 0\n    right_count = 0\n    i, j = 0, 0\n    while i < left_size and j < right_size:"
    },
    {
      "rank": 94,
      "score": 2.689231734095978,
      "candidate": "def merge_and_count(left, right):\n    result = []\n    inversions = 0\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result += left[i:]\n    result += right[j:]\n    return result, inversions\n\n\ndef merge_sort_and_count(array):\n    if len(array) <= 1:\n        return array, 0\n    mid = len(array) // 2\n    left, left_inv = merge_sort_and_count(array[:mid])\n    right, right_inv = merge_sort_and_count(array[mid:])\n    return merge_and_count(left, right)\n\n\ndef count_inversions(array):\n    return merge_sort_and_count(array)[1]\n\n\nif __name__ == \"__main__\":\n    array = [1, 20, 6, 4, 5]\n    print(count_inversions(array))"
    },
    {
      "rank": 95,
      "score": 2.618678000639471,
      "candidate": "def count_inversions(arr):\n    if len(arr) == 1:\n        return 0\n    mid = len(arr) // 2\n    first_half = arr[:mid]\n    second_half = arr[mid:]\n    first_half_inversions = count_inversions(first_half)\n    second_half_inversions = count_inversions(second_half)\n    merged_inversions = merge_count_inversions(first_half, second_half)\n    return first_half_inversions + second_half_inversions + merged_inversions\n\ndef merge_count_inversions(first_half, second_half):\n    merged = []\n    inversions = 0\n    while len(first_half) > 0 and len(second_half) > 0:\n        if first_half[0] <= second_half[0]:\n            merged.append(first_half.pop(0))\n        else:\n            merged.append(second_half.pop(0))\n            inversions += len(first_half)\n    merged += first_half if len(second_half) == 0 else second_half\n    return inversions\n\narr = [1, 2, 7, 4, 5, 3, 9]\nprint(count_inversions(arr))\n\narr = [1, 3, 5, 2, 4, 6, 7]\nprint(count_inversions(arr))\n\narr = [9, 8, 7, 6, 5, 4, 3, 2, 1]\nprint(count_inversions(arr))\n\narr = [5, 3, 1, 2, 4]\nprint(count_inversions(arr))\n\narr = [2, 4, 1, 3, 5]\nprint(count_inversions(arr))"
    },
    {
      "rank": 96,
      "score": 2.6153179897223664,
      "candidate": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_count = merge_sort(arr[:mid])\n    right, right_count = merge_sort(arr[mid:])\n    merged_arr, inversion_count = merge(left, right, left_count, right_count)\n    return merged_arr, inversion_count\n\n\ndef merge(left, right, left_count, right_count):\n    merged_arr = []\n    inversion_count = left_count + right_count\n    i, j = 0, 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged_arr.append(left[i])\n            i += 1\n        else:\n            merged_arr.append(right[j])\n            j += 1\n            inversion_count += len(left) - i\n    merged_arr += left[i:]\n    merged_arr += right[j:]\n    return merged_arr, inversion_count\n\n\ndef count_inversions(arr):\n    return merge_sort(arr)[1]\n\n\ndef main():\n    arr = [1, 20, 6, 4, 5]\n    print(\"Merge sort of {}\".format(arr))\n    sorted_arr, inversion_count = merge_sort(arr)\n    print(\"Sorted array: {}\".format(sorted_arr))\n    print(\"Inversions count: {}\".format(inversion_count))\n\n    arr = [1, 2, 5, 3, 6, 9, 8, 7, 4]\n    print(\"\\nMerge sort of {}\".format(arr))\n    sorted_arr, inversion_count = merge_sort(arr)\n    print(\"Sorted array: {}\".format(sorted_arr))\n    print(\"Inversions count: {}\".format(inversion_count))\n\n    arr = [54, 34, 31, 98, 72, 55, 99,"
    },
    {
      "rank": 97,
      "score": 2.6007990626007946,
      "candidate": "def merge_sort(arr):\n    \"\"\"\n    merge_sort takes an array as input and sorts it in increasing order\n    using the merge sort algorithm\n\n    >>> merge_sort([1,2,3,4,5])\n    [1, 2, 3, 4, 5]\n\n    >>> merge_sort([5,4,3,2,1])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_array = arr[:mid]\n        right_array = arr[mid:]\n        merge_sort(left_array)\n        merge_sort(right_array)\n        i = j = k = 0\n        while i < len(left_array) and j < len(right_array):\n            if left_array[i] < right_array[j]:\n                arr[k] = left_array[i]\n                i += 1\n            else:\n                arr[k] = right_array[j]\n                j += 1\n            k += 1\n        while i < len(left_array):\n            arr[k] = left_array[i]\n            i += 1\n            k += 1\n        while j < len(right_array):\n            arr[k] = right_array[j]\n            j += 1\n            k += 1\n\n\ndef merge(arr1, arr2):\n    \"\"\"\n    merge takes two arrays as input and returns a new sorted array containing\n    the elements of both the arrays\n\n    >>> merge([1,2,3,4,5],[5,4,3,2,1])\n    [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]\n\n    >>> merge([1,2,3,4,5],[1,2,3,4,5])\n    [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\n    \"\"\"\n    i = j = 0\n    result = []\n    while i <"
    },
    {
      "rank": 98,
      "score": 2.523979158052062,
      "candidate": "def merge_and_count_split_inv(arr, left, mid, right):\n    # merge step\n    i = left\n    j = mid + 1\n    k = left\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n            # count inversions\n            inv += mid - i + 1\n            k += 1\n\n    # copy remaining elements\n    while i <= mid:\n        temp[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        k += 1\n        j += 1\n\n    # copy merged elements into original array\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n\n    return inv\n\n\ndef count_inversions(arr, left, right):\n    if right <= left:\n        return 0\n    mid = left + (right - left) // 2\n    inv = count_inversions(arr, left, mid) + count_inversions(arr, mid + 1, right)\n    return inv + merge_and_count_split_inv(arr, left, mid, right)\n\n\nif __name__ == \"__main__\":\n    arr = [2, 4, 1, 3, 5]\n    inv = 0\n    temp = [0] * len(arr)\n    print(count_inversions(arr, 0, len(arr) - 1))"
    },
    {
      "rank": 99,
      "score": 2.4708890665524605,
      "candidate": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return arr\n\n\ndef merge_sort_count_inv(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort_count_inv(left)\n        merge_sort_count_inv(right)\n\n        i = j = k = 0\n        inversion = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inversion += len(left[i:])\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n    return inversion\n\n\ndef merge_count_inversion(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]"
    },
    {
      "rank": 100,
      "score": 2.292668821895769,
      "candidate": "def count_inversions(arr):\n    \"\"\"\n    Time complexity: O(n log n)\n    Space complexity: O(n)\n    \"\"\"\n\n    if len(arr) == 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inversions = count_inversions(arr[:mid])\n    right, right_inversions = count_inversions(arr[mid:])\n    merged, merge_inversions = merge_sorted(left, right)\n\n    return merged, left_inversions + right_inversions + merge_inversions\n\n\ndef merge_sorted(left, right):\n    \"\"\"\n    merge two sorted array\n    \"\"\"\n    inversions = 0\n    merged = []\n\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += len(left) - i\n\n    merged += left[i:]\n    merged += right[j:]\n\n    return merged, inversions\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    res = count_inversions(arr)\n    print(res)"
    }
  ]
}